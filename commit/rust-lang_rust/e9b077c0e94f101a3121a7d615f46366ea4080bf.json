{"sha": "e9b077c0e94f101a3121a7d615f46366ea4080bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YjA3N2MwZTk0ZjEwMWEzMTIxYTdkNjE1ZjQ2MzY2ZWE0MDgwYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T20:00:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T20:00:56Z"}, "message": "auto merge of #5488 : pcwalton/rust/depure, r=pcwalton", "tree": {"sha": "dc19fd536559f43d6ba3fbca2a83a489c421cfe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc19fd536559f43d6ba3fbca2a83a489c421cfe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9b077c0e94f101a3121a7d615f46366ea4080bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9b077c0e94f101a3121a7d615f46366ea4080bf", "html_url": "https://github.com/rust-lang/rust/commit/e9b077c0e94f101a3121a7d615f46366ea4080bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9b077c0e94f101a3121a7d615f46366ea4080bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f9aa1fd75f0e9468b3bb9ee10a95d18c40b567", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f9aa1fd75f0e9468b3bb9ee10a95d18c40b567", "html_url": "https://github.com/rust-lang/rust/commit/b6f9aa1fd75f0e9468b3bb9ee10a95d18c40b567"}, {"sha": "3eda11a4f79103a7f6d73c38e5e4f0880e26cc3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eda11a4f79103a7f6d73c38e5e4f0880e26cc3c", "html_url": "https://github.com/rust-lang/rust/commit/3eda11a4f79103a7f6d73c38e5e4f0880e26cc3c"}], "stats": {"total": 5070, "additions": 2517, "deletions": 2553}, "files": [{"sha": "29b7e35e24b7f26abc7e0ce7b9943edf5c78a78d", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -38,7 +38,7 @@ pub mod rustrt {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pub pure fn capacity<T>(v: @[const T]) -> uint {\n+pub fn capacity<T>(v: @[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n             ::cast::reinterpret_cast(&addr_of(&v));\n@@ -59,8 +59,7 @@ pub pure fn capacity<T>(v: @[const T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized<A>(size: uint,\n-                           builder: &fn(push: &pure fn(v: A))) -> @[A] {\n+pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec: @[const A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|+x| unsafe { raw::push(&mut vec, x) });\n@@ -78,7 +77,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> @[A] {\n+pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -95,14 +94,15 @@ pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                               builder: &fn(push: &pure fn(v: A))) -> @[A] {\n+pub fn build_sized_opt<A>(size: Option<uint>,\n+                          builder: &fn(push: &fn(v: A)))\n+                       -> @[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n+pub fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for vec::each(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n@@ -111,7 +111,7 @@ pub pure fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n+pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n         for vec::each(v) |elem| {\n             push(f(elem));\n@@ -125,7 +125,7 @@ pub pure fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n+pub fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -138,7 +138,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T:Copy>(n_elts: uint, t: T) -> @[T] {\n+pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(copy t); i += 1u; }\n@@ -176,7 +176,7 @@ pub mod traits {\n \n     impl<T:Copy> Add<&'self [const T],@[T]> for @[T] {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &'self [const T]) -> @[T] {\n+        fn add(&self, rhs: & &'self [const T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n     }"}, {"sha": "2b669a285b31cc0157ddf6949bbe8944f60ede9c", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,39 +17,39 @@ use from_str::FromStr;\n #[cfg(notest)] use cmp;\n \n /// Negation / inverse\n-pub pure fn not(v: bool) -> bool { !v }\n+pub fn not(v: bool) -> bool { !v }\n \n /// Conjunction\n-pub pure fn and(a: bool, b: bool) -> bool { a && b }\n+pub fn and(a: bool, b: bool) -> bool { a && b }\n \n /// Disjunction\n-pub pure fn or(a: bool, b: bool) -> bool { a || b }\n+pub fn or(a: bool, b: bool) -> bool { a || b }\n \n /**\n  * Exclusive or\n  *\n  * Identical to `or(and(a, not(b)), and(not(a), b))`\n  */\n-pub pure fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n+pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n \n /// Implication in the logic, i.e. from `a` follows `b`\n-pub pure fn implies(a: bool, b: bool) -> bool { !a || b }\n+pub fn implies(a: bool, b: bool) -> bool { !a || b }\n \n /// true if truth values `a` and `b` are indistinguishable in the logic\n-pub pure fn eq(a: bool, b: bool) -> bool { a == b }\n+pub fn eq(a: bool, b: bool) -> bool { a == b }\n \n /// true if truth values `a` and `b` are distinguishable in the logic\n-pub pure fn ne(a: bool, b: bool) -> bool { a != b }\n+pub fn ne(a: bool, b: bool) -> bool { a != b }\n \n /// true if `v` represents truth in the logic\n-pub pure fn is_true(v: bool) -> bool { v }\n+pub fn is_true(v: bool) -> bool { v }\n \n /// true if `v` represents falsehood in the logic\n-pub pure fn is_false(v: bool) -> bool { !v }\n+pub fn is_false(v: bool) -> bool { !v }\n \n /// Parse logic value from `s`\n impl FromStr for bool {\n-    static pure fn from_str(s: &str) -> Option<bool> {\n+    fn from_str(s: &str) -> Option<bool> {\n         if s == \"true\" {\n             Some(true)\n         } else if s == \"false\" {\n@@ -61,7 +61,7 @@ impl FromStr for bool {\n }\n \n /// Convert `v` into a string\n-pub pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n+pub fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n \n /**\n  * Iterates over all truth values by passing them to `blk` in an unspecified\n@@ -73,12 +73,12 @@ pub fn all_values(blk: &fn(v: bool)) {\n }\n \n /// converts truth value to an 8 bit byte\n-pub pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n+pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[cfg(notest)]\n impl cmp::Eq for bool {\n-    pure fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-    pure fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n \n #[test]"}, {"sha": "bf5f93159381a7dc4b3f9d5407910fa26f55dd9e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -21,22 +21,22 @@ pub struct Cell<T> {\n }\n \n impl<T:cmp::Eq> cmp::Eq for Cell<T> {\n-    pure fn eq(&self, other: &Cell<T>) -> bool {\n+    fn eq(&self, other: &Cell<T>) -> bool {\n         unsafe {\n             let frozen_self: &Option<T> = transmute(&mut self.value);\n             let frozen_other: &Option<T> = transmute(&mut other.value);\n             frozen_self == frozen_other\n         }\n     }\n-    pure fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n }\n \n /// Creates a new full cell with the given value.\n pub fn Cell<T>(value: T) -> Cell<T> {\n     Cell { value: Some(value) }\n }\n \n-pub pure fn empty_cell<T>() -> Cell<T> {\n+pub fn empty_cell<T>() -> Cell<T> {\n     Cell { value: None }\n }\n \n@@ -61,7 +61,7 @@ pub impl<T> Cell<T> {\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n-    pure fn is_empty(&self) -> bool {\n+    fn is_empty(&self) -> bool {\n         self.value.is_none()\n     }\n "}, {"sha": "027329a235544bb7f49fa0b267c7ced30f0e3c58", "filename": "src/libcore/char.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -61,7 +61,7 @@ pub use is_XID_continue = unicode::derived_property::XID_Continue;\n  * in terms of the Unicode General Category 'Ll'\n  */\n #[inline(always)]\n-pub pure fn is_lowercase(c: char) -> bool {\n+pub fn is_lowercase(c: char) -> bool {\n     return unicode::general_category::Ll(c);\n }\n \n@@ -70,7 +70,7 @@ pub pure fn is_lowercase(c: char) -> bool {\n  * in terms of the Unicode General Category 'Lu'.\n  */\n #[inline(always)]\n-pub pure fn is_uppercase(c: char) -> bool {\n+pub fn is_uppercase(c: char) -> bool {\n     return unicode::general_category::Lu(c);\n }\n \n@@ -80,7 +80,7 @@ pub pure fn is_uppercase(c: char) -> bool {\n  * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n  */\n #[inline(always)]\n-pub pure fn is_whitespace(c: char) -> bool {\n+pub fn is_whitespace(c: char) -> bool {\n     return ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n@@ -93,7 +93,7 @@ pub pure fn is_whitespace(c: char) -> bool {\n  * and the Derived Core Property 'Alphabetic'.\n  */\n #[inline(always)]\n-pub pure fn is_alphanumeric(c: char) -> bool {\n+pub fn is_alphanumeric(c: char) -> bool {\n     return unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n@@ -102,13 +102,13 @@ pub pure fn is_alphanumeric(c: char) -> bool {\n \n /// Indicates whether the character is an ASCII character\n #[inline(always)]\n-pub pure fn is_ascii(c: char) -> bool {\n+pub fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n #[inline(always)]\n-pub pure fn is_digit(c: char) -> bool {\n+pub fn is_digit(c: char) -> bool {\n     return unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n@@ -127,7 +127,7 @@ pub pure fn is_digit(c: char) -> bool {\n  * Note: This just wraps `to_digit()`.\n  */\n #[inline(always)]\n-pub pure fn is_digit_radix(c: char, radix: uint) -> bool {\n+pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n         Some(_) => true,\n         None    => false\n@@ -148,7 +148,7 @@ pub pure fn is_digit_radix(c: char, radix: uint) -> bool {\n  * Fails if given a `radix` outside the range `[0..36]`.\n  */\n #[inline]\n-pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n+pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n         fail!(fmt!(\"to_digit: radix %? is to high (maximum 36)\", radix));\n     }\n@@ -171,7 +171,7 @@ pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n  * Fails if given an `radix` > 36.\n  */\n #[inline]\n-pub pure fn from_digit(num: uint, radix: uint) -> Option<char> {\n+pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         fail!(fmt!(\"from_digit: radix %? is to high (maximum 36)\", num));\n     }\n@@ -195,7 +195,7 @@ pub pure fn from_digit(num: uint, radix: uint) -> Option<char> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n-pub pure fn escape_unicode(c: char) -> ~str {\n+pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str_radix(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n@@ -223,7 +223,7 @@ pub pure fn escape_unicode(c: char) -> ~str {\n  *   - Any other chars in the range [0x20,0x7e] are not escaped.\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n-pub pure fn escape_default(c: char) -> ~str {\n+pub fn escape_default(c: char) -> ~str {\n     match c {\n       '\\t' => ~\"\\\\t\",\n       '\\r' => ~\"\\\\r\",\n@@ -244,16 +244,16 @@ pub pure fn escape_default(c: char) -> ~str {\n  * -1 if a < b, 0 if a == b, +1 if a > b\n  */\n #[inline(always)]\n-pub pure fn cmp(a: char, b: char) -> int {\n+pub fn cmp(a: char, b: char) -> int {\n     return  if b > a { -1 }\n     else if b < a { 1 }\n     else { 0 }\n }\n \n #[cfg(notest)]\n impl Eq for char {\n-    pure fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    pure fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n \n #[test]"}, {"sha": "7c45ecae63234cb183866ea8bbdb438625da9c82", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -33,73 +33,73 @@ and `Eq` to overload the `==` and `!=` operators.\n */\n #[lang=\"eq\"]\n pub trait Eq {\n-    pure fn eq(&self, other: &Self) -> bool;\n-    pure fn ne(&self, other: &Self) -> bool;\n+    fn eq(&self, other: &Self) -> bool;\n+    fn ne(&self, other: &Self) -> bool;\n }\n \n #[deriving(Eq)]\n pub enum Ordering { Less, Equal, Greater }\n \n /// Trait for types that form a total order\n pub trait TotalOrd {\n-    pure fn cmp(&self, other: &Self) -> Ordering;\n+    fn cmp(&self, other: &Self) -> Ordering;\n }\n \n #[inline(always)]\n-pure fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n+fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n     if *a < *b { Less }\n     else if *a > *b { Greater }\n     else { Equal }\n }\n \n impl TotalOrd for u8 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for u16 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for u32 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for u64 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i8 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i16 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i32 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i64 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for int {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for uint {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n }\n \n /**\n@@ -114,39 +114,39 @@ impl TotalOrd for uint {\n */\n #[lang=\"ord\"]\n pub trait Ord {\n-    pure fn lt(&self, other: &Self) -> bool;\n-    pure fn le(&self, other: &Self) -> bool;\n-    pure fn ge(&self, other: &Self) -> bool;\n-    pure fn gt(&self, other: &Self) -> bool;\n+    fn lt(&self, other: &Self) -> bool;\n+    fn le(&self, other: &Self) -> bool;\n+    fn ge(&self, other: &Self) -> bool;\n+    fn gt(&self, other: &Self) -> bool;\n }\n \n #[inline(always)]\n-pub pure fn lt<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn lt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2)\n }\n \n #[inline(always)]\n-pub pure fn le<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn le<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).le(v2)\n }\n \n #[inline(always)]\n-pub pure fn eq<T:Eq>(v1: &T, v2: &T) -> bool {\n+pub fn eq<T:Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).eq(v2)\n }\n \n #[inline(always)]\n-pub pure fn ne<T:Eq>(v1: &T, v2: &T) -> bool {\n+pub fn ne<T:Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).ne(v2)\n }\n \n #[inline(always)]\n-pub pure fn ge<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn ge<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).ge(v2)\n }\n \n #[inline(always)]\n-pub pure fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }\n \n@@ -155,16 +155,16 @@ pub pure fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `~str` keys.\n pub trait Equiv<T> {\n-    pure fn equiv(&self, other: &T) -> bool;\n+    fn equiv(&self, other: &T) -> bool;\n }\n \n #[inline(always)]\n-pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n+pub fn min<T:Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n #[inline(always)]\n-pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n+pub fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n "}, {"sha": "6dadca8dc57ba3c72bd199db83b054eb1c9b0334", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -50,7 +50,7 @@ pub trait GenericPort<T> {\n /// Ports that can `peek`\n pub trait Peekable<T> {\n     /// Returns true if a message is available\n-    pure fn peek(&self) -> bool;\n+    fn peek(&self) -> bool;\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n@@ -148,7 +148,7 @@ fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n pub impl<T: Owned> Port<T> {\n     fn recv(&self) -> T { port_recv(self) }\n     fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n-    pure fn peek(&self) -> bool { port_peek(self) }\n+    fn peek(&self) -> bool { port_peek(self) }\n }\n \n impl<T: Owned> GenericPort<T> for Port<T> {\n@@ -180,11 +180,11 @@ fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    pure fn peek(&self) -> bool { port_peek(self) }\n+    fn peek(&self) -> bool { port_peek(self) }\n }\n \n #[inline(always)]\n-pure fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n+fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n     unsafe {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -198,7 +198,7 @@ pure fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n }\n \n impl<T: Owned> Selectable for Port<T> {\n-    pure fn header(&self) -> *PacketHeader {\n+    fn header(&self) -> *PacketHeader {\n         unsafe {\n             match self.endp {\n               Some(ref endp) => endp.header(),\n@@ -223,7 +223,7 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n pub impl<T:Owned> PortSet<T> {\n     fn recv(&self) -> T { port_set_recv(self) }\n     fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n-    pure fn peek(&self) -> bool { port_set_peek(self) }\n+    fn peek(&self) -> bool { port_set_peek(self) }\n }\n \n pub impl<T: Owned> PortSet<T> {\n@@ -272,11 +272,11 @@ fn port_set_try_recv<T:Owned>(self: &PortSet<T>) -> Option<T> {\n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    pure fn peek(&self) -> bool { port_set_peek(self) }\n+    fn peek(&self) -> bool { port_set_peek(self) }\n }\n \n #[inline(always)]\n-pure fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n+fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n     // It'd be nice to use self.port.each, but that version isn't\n     // pure.\n     for uint::range(0, vec::uniq_len(&const self.ports)) |i| {"}, {"sha": "1cda04ee06ec1b61ed494df6f5cda150e402990e", "filename": "src/libcore/container.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,10 +14,10 @@ use option::Option;\n \n pub trait Container {\n     /// Return the number of elements in the container\n-    pure fn len(&const self) -> uint;\n+    fn len(&const self) -> uint;\n \n     /// Return true if the container contains no elements\n-    pure fn is_empty(&const self) -> bool;\n+    fn is_empty(&const self) -> bool;\n }\n \n pub trait Mutable: Container {\n@@ -27,19 +27,19 @@ pub trait Mutable: Container {\n \n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &K) -> bool;\n+    fn contains_key(&self, key: &K) -> bool;\n \n     /// Visit all keys\n-    pure fn each_key(&self, f: &fn(&K) -> bool);\n+    fn each_key(&self, f: &fn(&K) -> bool);\n \n     /// Visit all values\n-    pure fn each_value(&self, f: &fn(&V) -> bool);\n+    fn each_value(&self, f: &fn(&V) -> bool);\n \n     /// Iterate over the map and mutate the contained values\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n \n     /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&'self V>;\n+    fn find(&self, key: &K) -> Option<&'self V>;\n \n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n@@ -53,7 +53,7 @@ pub trait Map<K, V>: Mutable {\n \n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n-    pure fn contains(&self, value: &T) -> bool;\n+    fn contains(&self, value: &T) -> bool;\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n@@ -65,23 +65,23 @@ pub trait Set<T>: Mutable {\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n-    pure fn is_disjoint(&self, other: &Self) -> bool;\n+    fn is_disjoint(&self, other: &Self) -> bool;\n \n     /// Return true if the set is a subset of another\n-    pure fn is_subset(&self, other: &Self) -> bool;\n+    fn is_subset(&self, other: &Self) -> bool;\n \n     /// Return true if the set is a superset of another\n-    pure fn is_superset(&self, other: &Self) -> bool;\n+    fn is_superset(&self, other: &Self) -> bool;\n \n     /// Visit the values representing the difference\n-    pure fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the symmetric difference\n-    pure fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the intersection\n-    pure fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the union\n-    pure fn union(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn union(&self, other: &Self, f: &fn(&T) -> bool);\n }"}, {"sha": "ff86e8d1ffcdb35c9c1338578280d4fa9293ed58", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -42,7 +42,7 @@ pub struct DList<T> {\n }\n \n priv impl<T> DListNode<T> {\n-    pure fn assert_links(@mut self) {\n+    fn assert_links(@mut self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n               Some(me) => if !managed::mut_ptr_eq(self, me) {\n@@ -66,24 +66,24 @@ priv impl<T> DListNode<T> {\n \n pub impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link(@mut self) -> DListLink<T> {\n+    fn next_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    pure fn next_node(@mut self) -> @mut DListNode<T> {\n+    fn next_node(@mut self) -> @mut DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => fail!(~\"This dlist node has no next neighbour.\")\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link(@mut self) -> DListLink<T> {\n+    fn prev_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    pure fn prev_node(@mut self) -> @mut DListNode<T> {\n+    fn prev_node(@mut self) -> @mut DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => fail!(~\"This dlist node has no previous neighbour.\")\n@@ -92,17 +92,17 @@ pub impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pub pure fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n+pub fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n     @mut DListNode { data: data, linked: false, prev: None, next: None }\n }\n \n /// Creates a new, empty dlist.\n-pub pure fn DList<T>() -> @mut DList<T> {\n+pub fn DList<T>() -> @mut DList<T> {\n     @mut DList { size: 0, hd: None, tl: None }\n }\n \n /// Creates a new dlist with a single element\n-pub pure fn from_elem<T>(data: T) -> @mut DList<T> {\n+pub fn from_elem<T>(data: T) -> @mut DList<T> {\n     let list = DList();\n     unsafe { list.push(data); }\n     list\n@@ -126,15 +126,15 @@ pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n }\n \n priv impl<T> DList<T> {\n-    static pure fn new_link(data: T) -> DListLink<T> {\n+    fn new_link(data: T) -> DListLink<T> {\n         Some(@mut DListNode {\n             data: data,\n             linked: true,\n             prev: None,\n             next: None\n         })\n     }\n-    pure fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n+    fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n@@ -212,9 +212,9 @@ priv impl<T> DList<T> {\n \n pub impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    pure fn len(@mut self) -> uint { self.size }\n+    fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    pure fn is_empty(@mut self) -> bool { self.len() == 0 }\n+    fn is_empty(@mut self) -> bool { self.len() == 0 }\n \n     /// Add data to the head of the list. O(1).\n     fn push_head(@mut self, data: T) {\n@@ -316,20 +316,20 @@ pub impl<T> DList<T> {\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n(@mut self) -> DListLink<T> { self.hd }\n+    fn peek_n(@mut self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n+    fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    pure fn head_n(@mut self) -> @mut DListNode<T> {\n+    fn head_n(@mut self) -> @mut DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => fail!(\n                 ~\"Attempted to get the head of an empty dlist.\")\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    pure fn tail_n(@mut self) -> @mut DListNode<T> {\n+    fn tail_n(@mut self) -> @mut DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => fail!(\n@@ -399,7 +399,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n+    fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -471,23 +471,23 @@ pub impl<T:Copy> DList<T> {\n     }\n \n     /// Get data at the list's head. O(1).\n-    pure fn peek(@mut self) -> Option<T> {\n+    fn peek(@mut self) -> Option<T> {\n         self.peek_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n-    pure fn peek_tail(@mut self) -> Option<T> {\n+    fn peek_tail(@mut self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    pure fn head(@mut self) -> T { self.head_n().data }\n+    fn head(@mut self) -> T { self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    pure fn tail(@mut self) -> T { self.tail_n().data }\n+    fn tail(@mut self) -> T { self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n-    pure fn to_vec(@mut self) -> ~[T] {\n+    fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         unsafe {\n             // Take this out of the unchecked when iter's functions are pure\n@@ -507,7 +507,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n     * allow for e.g. breadth-first search with in-place enqueues), but\n     * removing the current node is forbidden.\n     */\n-    pure fn each(&self, f: &fn(v: &T) -> bool) {\n+    fn each(&self, f: &fn(v: &T) -> bool) {\n         let mut link = self.peek_n();\n         while option::is_some(&link) {\n             let nobe = option::get(link);\n@@ -536,7 +536,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n     }\n \n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n #[cfg(test)]"}, {"sha": "1cf2c5e1fff2939cd7de8ea3f0a503773e4ef490", "filename": "src/libcore/either.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -87,7 +87,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>])\n }\n \n #[inline(always)]\n-pub pure fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n+pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n     //! Flips between left and right of a given either\n \n     match eith {\n@@ -97,7 +97,7 @@ pub pure fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n }\n \n #[inline(always)]\n-pub pure fn to_result<T, U>(eith: Either<T, U>)\n+pub fn to_result<T, U>(eith: Either<T, U>)\n     -> Result<U, T> {\n     /*!\n      * Converts either::t to a result::t\n@@ -113,21 +113,21 @@ pub pure fn to_result<T, U>(eith: Either<T, U>)\n }\n \n #[inline(always)]\n-pub pure fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n+pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n     match *eith { Left(_) => true, _ => false }\n }\n \n #[inline(always)]\n-pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n+pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n     match *eith { Right(_) => true, _ => false }\n }\n \n #[inline(always)]\n-pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n+pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n     match eith {\n@@ -137,7 +137,7 @@ pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n+pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n     match eith {"}, {"sha": "ebf6d212466a5f7ce2a37c93e971a28ce2f49b28", "filename": "src/libcore/from_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffrom_str.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,5 +13,5 @@\n use option::Option;\n \n pub trait FromStr {\n-    static pure fn from_str(s: &str) -> Option<Self>;\n+    fn from_str(s: &str) -> Option<Self>;\n }"}, {"sha": "1bfa0e9522ddd4a08ef8f10658ae7375732bcb88", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -50,17 +50,17 @@ pub trait Hash {\n      * function and require most types to only implement the\n      * IterBytes trait, that feeds SipHash.\n      */\n-    pure fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n+    fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n }\n \n // When we have default methods, won't need this.\n pub trait HashUtil {\n-    pure fn hash(&self) -> u64;\n+    fn hash(&self) -> u64;\n }\n \n impl<A:Hash> HashUtil for A {\n     #[inline(always)]\n-    pure fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n+    fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n }\n \n /// Streaming hash-functions should implement this.\n@@ -75,7 +75,7 @@ pub trait Streaming {\n \n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n-    pure fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n+    fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         unsafe {\n             let s = &State(k0, k1);\n             for self.iter_bytes(true) |bytes| {\n@@ -86,9 +86,8 @@ impl<A:IterBytes> Hash for A {\n     }\n }\n \n-pure fn hash_keyed_2<A: IterBytes,\n-                     B: IterBytes>(a: &A, b: &B,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_2<A: IterBytes,\n+                B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -97,10 +96,9 @@ pure fn hash_keyed_2<A: IterBytes,\n     }\n }\n \n-pure fn hash_keyed_3<A: IterBytes,\n-                     B: IterBytes,\n-                     C: IterBytes>(a: &A, b: &B, c: &C,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_3<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -110,11 +108,11 @@ pure fn hash_keyed_3<A: IterBytes,\n     }\n }\n \n-pure fn hash_keyed_4<A: IterBytes,\n-                     B: IterBytes,\n-                     C: IterBytes,\n-                     D: IterBytes>(a: &A, b: &B, c: &C, d: &D,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_4<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes>(a: &A, b: &B, c: &C, d: &D, k0: u64, k1: u64)\n+                           -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -125,12 +123,12 @@ pure fn hash_keyed_4<A: IterBytes,\n     }\n }\n \n-pure fn hash_keyed_5<A: IterBytes,\n-                     B: IterBytes,\n-                     C: IterBytes,\n-                     D: IterBytes,\n-                     E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_5<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes,\n+                E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n+                              k0: u64, k1: u64) -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }"}, {"sha": "64806cd21aaecb9f34b71559e477becf3373601c", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -48,7 +48,7 @@ pub mod linear {\n     }\n \n     #[inline(always)]\n-    pure fn resize_at(capacity: uint) -> uint {\n+    fn resize_at(capacity: uint) -> uint {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n@@ -59,7 +59,7 @@ pub mod linear {\n                                           initial_capacity)\n     }\n \n-    pure fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n+    fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n         k0: u64, k1: u64,\n         initial_capacity: uint) -> LinearMap<K, V> {\n         LinearMap {\n@@ -72,21 +72,21 @@ pub mod linear {\n \n     priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n         #[inline(always)]\n-        pure fn to_bucket(&self, h: uint) -> uint {\n+        fn to_bucket(&self, h: uint) -> uint {\n             // A good hash function with entropy spread over all of the\n             // bits is assumed. SipHash is more than good enough.\n             h % self.buckets.len()\n         }\n \n         #[inline(always)]\n-        pure fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n+        fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n             debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n             n\n         }\n \n         #[inline(always)]\n-        pure fn bucket_sequence(&self, hash: uint,\n+        fn bucket_sequence(&self, hash: uint,\n                                 op: &fn(uint) -> bool) -> uint {\n             let start_idx = self.to_bucket(hash);\n             let len_buckets = self.buckets.len();\n@@ -103,24 +103,24 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key(&self, k: &K) -> SearchResult {\n+        fn bucket_for_key(&self, k: &K) -> SearchResult {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.bucket_for_key_with_hash(hash, k)\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(\n-                &self,\n-                k: &Q)\n-             -> SearchResult {\n+        fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self,\n+                                                               k: &Q)\n+                                                            -> SearchResult {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.bucket_for_key_with_hash_equiv(hash, k)\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_with_hash(&self,\n-                                         hash: uint,\n-                                         k: &K) -> SearchResult {\n+        fn bucket_for_key_with_hash(&self,\n+                                    hash: uint,\n+                                    k: &K)\n+                                 -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match self.buckets[i] {\n                     Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n@@ -133,10 +133,10 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n-                                                           hash: uint,\n-                                                           k: &Q)\n-                                                        -> SearchResult {\n+        fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n+                                                      hash: uint,\n+                                                      k: &Q)\n+                                                   -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match self.buckets[i] {\n                     Some(ref bkt) => {\n@@ -185,7 +185,7 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn value_for_bucket(&self, idx: uint) -> &'self V {\n+        fn value_for_bucket(&self, idx: uint) -> &'self V {\n             match self.buckets[idx] {\n                 Some(ref bkt) => &bkt.value,\n                 None => fail!(~\"LinearMap::find: internal logic error\"),\n@@ -273,7 +273,7 @@ pub mod linear {\n         BaseIter<(&'self K, &'self V)> for LinearMap<K, V>\n     {\n         /// Visit all key-value pairs\n-        pure fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n+        fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {\n                 let mut broke = false;\n                 do self.buckets[i].map |bucket| {\n@@ -284,16 +284,16 @@ pub mod linear {\n                 if broke { break; }\n             }\n         }\n-        pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+        fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n \n     impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n         /// Return the number of elements in the map\n-        pure fn len(&const self) -> uint { self.size }\n+        fn len(&const self) -> uint { self.size }\n \n         /// Return true if the map contains no elements\n-        pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+        fn is_empty(&const self) -> bool { self.len() == 0 }\n     }\n \n     impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n@@ -308,20 +308,20 @@ pub mod linear {\n \n     impl<K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n         /// Return true if the map contains a value for the specified key\n-        pure fn contains_key(&self, k: &K) -> bool {\n+        fn contains_key(&self, k: &K) -> bool {\n             match self.bucket_for_key(k) {\n                 FoundEntry(_) => {true}\n                 TableFull | FoundHole(_) => {false}\n             }\n         }\n \n         /// Visit all keys\n-        pure fn each_key(&self, blk: &fn(k: &K) -> bool) {\n+        fn each_key(&self, blk: &fn(k: &K) -> bool) {\n             self.each(|&(k, _)| blk(k))\n         }\n \n         /// Visit all values\n-        pure fn each_value(&self, blk: &fn(v: &V) -> bool) {\n+        fn each_value(&self, blk: &fn(v: &V) -> bool) {\n             self.each(|&(_, v)| blk(v))\n         }\n \n@@ -339,7 +339,7 @@ pub mod linear {\n         }\n \n         /// Return the value corresponding to the key in the map\n-        pure fn find(&self, k: &K) -> Option<&'self V> {\n+        fn find(&self, k: &K) -> Option<&'self V> {\n             match self.bucket_for_key(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,\n@@ -373,7 +373,7 @@ pub mod linear {\n \n     pub impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n         /// Create an empty LinearMap\n-        static fn new() -> LinearMap<K, V> {\n+        fn new() -> LinearMap<K, V> {\n             linear_map_with_capacity(INITIAL_CAPACITY)\n         }\n \n@@ -487,7 +487,7 @@ pub mod linear {\n             }\n         }\n \n-        pure fn get(&self, k: &K) -> &'self V {\n+        fn get(&self, k: &K) -> &'self V {\n             match self.find(k) {\n                 Some(v) => v,\n                 None => fail!(fmt!(\"No entry found for key: %?\", k)),\n@@ -496,10 +496,8 @@ pub mod linear {\n \n         /// Return true if the map contains a value for the specified key,\n         /// using equivalence\n-        pure fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(\n-                &self,\n-                key: &Q)\n-             -> bool {\n+        fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n+                                                          -> bool {\n             match self.bucket_for_key_equiv(key) {\n                 FoundEntry(_) => {true}\n                 TableFull | FoundHole(_) => {false}\n@@ -508,8 +506,8 @@ pub mod linear {\n \n         /// Return the value corresponding to the key in the map, using\n         /// equivalence\n-        pure fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n-                                                       -> Option<&'self V> {\n+        fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n+                                                  -> Option<&'self V> {\n             match self.bucket_for_key_equiv(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,\n@@ -518,7 +516,7 @@ pub mod linear {\n     }\n \n     impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n-        pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n+        fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n             for self.each |&(key, value)| {\n@@ -531,7 +529,7 @@ pub mod linear {\n             true\n         }\n \n-        pure fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n+        fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n     }\n \n     pub struct LinearSet<T> {\n@@ -540,25 +538,21 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n         /// Visit all values in order\n-        pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n-        pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+        fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+        fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Eq for LinearSet<T> {\n-        pure fn eq(&self, other: &LinearSet<T>) -> bool {\n-            self.map == other.map\n-        }\n-        pure fn ne(&self, other: &LinearSet<T>) -> bool {\n-            self.map != other.map\n-        }\n+        fn eq(&self, other: &LinearSet<T>) -> bool { self.map == other.map }\n+        fn ne(&self, other: &LinearSet<T>) -> bool { self.map != other.map }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n         /// Return the number of elements in the set\n-        pure fn len(&const self) -> uint { self.map.len() }\n+        fn len(&const self) -> uint { self.map.len() }\n \n         /// Return true if the set contains no elements\n-        pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n+        fn is_empty(&const self) -> bool { self.map.is_empty() }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {\n@@ -568,9 +562,7 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n         /// Return true if the set contains a value\n-        pure fn contains(&self, value: &T) -> bool {\n-            self.map.contains_key(value)\n-        }\n+        fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n         /// Add a value to the set. Return true if the value was not already\n         /// present in the set.\n@@ -582,22 +574,22 @@ pub mod linear {\n \n         /// Return true if the set has no elements in common with `other`.\n         /// This is equivalent to checking for an empty intersection.\n-        pure fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n+        fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n             iter::all(self, |v| !other.contains(v))\n         }\n \n         /// Return true if the set is a subset of another\n-        pure fn is_subset(&self, other: &LinearSet<T>) -> bool {\n+        fn is_subset(&self, other: &LinearSet<T>) -> bool {\n             iter::all(self, |v| other.contains(v))\n         }\n \n         /// Return true if the set is a superset of another\n-        pure fn is_superset(&self, other: &LinearSet<T>) -> bool {\n+        fn is_superset(&self, other: &LinearSet<T>) -> bool {\n             other.is_subset(self)\n         }\n \n         /// Visit the values representing the difference\n-        pure fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !other.contains(v) {\n                     if !f(v) { return }\n@@ -606,16 +598,15 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the symmetric difference\n-        pure fn symmetric_difference(&self, other: &LinearSet<T>,\n-                                     f: &fn(&T) -> bool) {\n+        fn symmetric_difference(&self,\n+                                other: &LinearSet<T>,\n+                                f: &fn(&T) -> bool) {\n             self.difference(other, f);\n             other.difference(self, f);\n         }\n \n         /// Visit the values representing the intersection\n-        pure fn intersection(&self,\n-                             other: &LinearSet<T>,\n-                             f: &fn(&T) -> bool) {\n+        fn intersection(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if other.contains(v) {\n                     if !f(v) { return }\n@@ -624,7 +615,7 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the union\n-        pure fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !f(v) { return }\n             }\n@@ -639,7 +630,7 @@ pub mod linear {\n \n     pub impl <T:Hash + IterBytes + Eq> LinearSet<T> {\n         /// Create an empty LinearSet\n-        static fn new() -> LinearSet<T> { LinearSet{map: LinearMap::new()} }\n+        fn new() -> LinearSet<T> { LinearSet{map: LinearMap::new()} }\n \n         /// Reserve space for at least `n` elements in the hash table.\n         fn reserve_at_least(&mut self, n: uint) {"}, {"sha": "fb305560ba333c32cb88dc2cab9c8edc755d55da", "filename": "src/libcore/io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -646,11 +646,11 @@ impl Reader for BytesReader<'self> {\n     fn tell(&self) -> uint { self.pos }\n }\n \n-pub pure fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n+pub fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n     f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n }\n \n-pub pure fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n+pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n \n@@ -1165,18 +1165,18 @@ impl Writer for BytesWriter {\n     fn get_type(&self) -> WriterType { File }\n }\n \n-pub pure fn BytesWriter() -> BytesWriter {\n+pub fn BytesWriter() -> BytesWriter {\n     BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n-pub pure fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n+pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as @Writer);\n     let @BytesWriter{bytes, _} = wr;\n     return bytes;\n }\n \n-pub pure fn with_str_writer(f: &fn(@Writer)) -> ~str {\n+pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // FIXME (#3758): This should not be needed."}, {"sha": "f94c62d23ece330572016d9aba8fed3698098a97", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -23,54 +23,53 @@ use vec;\n pub type InitOp<T> = &'self fn(uint) -> T;\n \n pub trait BaseIter<A> {\n-    pure fn each(&self, blk: &fn(v: &A) -> bool);\n-    pure fn size_hint(&self) -> Option<uint>;\n+    fn each(&self, blk: &fn(v: &A) -> bool);\n+    fn size_hint(&self) -> Option<uint>;\n }\n \n pub trait ReverseIter<A>: BaseIter<A> {\n-    pure fn each_reverse(&self, blk: &fn(&A) -> bool);\n+    fn each_reverse(&self, blk: &fn(&A) -> bool);\n }\n \n pub trait MutableIter<A>: BaseIter<A> {\n     fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n }\n \n pub trait ExtendedIter<A> {\n-    pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n-    pure fn all(&self, blk: &fn(&A) -> bool) -> bool;\n-    pure fn any(&self, blk: &fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n-    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n-    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B];\n+    fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    fn all(&self, blk: &fn(&A) -> bool) -> bool;\n+    fn any(&self, blk: &fn(&A) -> bool) -> bool;\n+    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n+    fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n+    fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n pub trait EqIter<A:Eq> {\n-    pure fn contains(&self, x: &A) -> bool;\n-    pure fn count(&self, x: &A) -> uint;\n+    fn contains(&self, x: &A) -> bool;\n+    fn count(&self, x: &A) -> uint;\n }\n \n pub trait Times {\n-    pure fn times(&self, it: &fn() -> bool);\n+    fn times(&self, it: &fn() -> bool);\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n-    pure fn to_vec(&self) -> ~[A];\n-    pure fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n+    fn to_vec(&self) -> ~[A];\n+    fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy + Ord> {\n-    pure fn min(&self) -> A;\n-    pure fn max(&self) -> A;\n+    fn min(&self) -> A;\n+    fn max(&self) -> A;\n }\n \n pub trait CopyableNonstrictIter<A:Copy> {\n     // Like \"each\", but copies out the value. If the receiver is mutated while\n     // iterating over it, the semantics must not be memory-unsafe but are\n     // otherwise undefined.\n-    pure fn each_val(&const self, f: &fn(A) -> bool);\n+    fn each_val(&const self, f: &fn(A) -> bool);\n }\n \n // A trait for sequences that can be built by imperatively pushing elements\n@@ -89,13 +88,11 @@ pub trait Buildable<A> {\n      *             as an argument a function that will push an element\n      *             onto the sequence being constructed.\n      */\n-     static pure fn build_sized(size: uint,\n-                                builder: &fn(push: &pure fn(A))) -> Self;\n+     fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n }\n \n #[inline(always)]\n-pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n-                                    blk: &fn(uint, &A) -> bool) {\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n     let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n@@ -104,26 +101,25 @@ pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n }\n \n #[inline(always)]\n-pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: &fn(&A) -> bool) -> bool {\n+pub fn all<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n     return true;\n }\n \n #[inline(always)]\n-pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: &fn(&A) -> bool) -> bool {\n+pub fn any<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n     return false;\n }\n \n #[inline(always)]\n-pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n-    self: &IA, prd: &fn(&A) -> bool) -> ~[A] {\n+pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: &IA,\n+                                            prd: &fn(&A) -> bool)\n+                                         -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(a) { push(*a); }\n@@ -132,9 +128,7 @@ pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n }\n \n #[inline(always)]\n-pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n-                                           op: &fn(&A) -> B)\n-    -> ~[B] {\n+pub fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA, op: &fn(&A) -> B) -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             push(op(a));\n@@ -143,8 +137,9 @@ pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n }\n \n #[inline(always)]\n-pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: &IA, op: &fn(&A) -> IB) -> ~[B] {\n+pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(self: &IA,\n+                                                          op: &fn(&A) -> IB)\n+                                                       -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n             for op(a).each |&b| {\n@@ -155,9 +150,8 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n }\n \n #[inline(always)]\n-pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n-                                      blk: &fn(&B, &A) -> B)\n-    -> B {\n+pub fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B, blk: &fn(&B, &A) -> B)\n+                              -> B {\n     let mut b = b0;\n     for self.each |a| {\n         b = blk(&b, a);\n@@ -166,20 +160,20 @@ pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n }\n \n #[inline(always)]\n-pub pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n+pub fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy (*r), ~[*a]))\n }\n \n #[inline(always)]\n-pub pure fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n+pub fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n     for self.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n #[inline(always)]\n-pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n+pub fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n     do foldl(self, 0) |count, value| {\n         if *value == *x {\n             *count + 1\n@@ -190,9 +184,8 @@ pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n }\n \n #[inline(always)]\n-pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n-    -> Option<uint>\n-{\n+pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+                               -> Option<uint> {\n     let mut i = 0;\n     for self.each |a| {\n         if f(a) { return Some(i); }\n@@ -206,7 +199,7 @@ pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n // it would have to be implemented with foldr, which is too inefficient.\n \n #[inline(always)]\n-pub pure fn repeat(times: uint, blk: &fn() -> bool) {\n+pub fn repeat(times: uint, blk: &fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n@@ -215,7 +208,7 @@ pub pure fn repeat(times: uint, blk: &fn() -> bool) {\n }\n \n #[inline(always)]\n-pub pure fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n@@ -230,7 +223,7 @@ pub pure fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n@@ -245,8 +238,8 @@ pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n-                                   f: &fn(&A) -> bool) -> Option<A> {\n+pub fn find<A:Copy,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+                                -> Option<A> {\n     for self.each |i| {\n         if f(i) { return Some(*i) }\n     }\n@@ -266,8 +259,7 @@ pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A,B: Buildable<A>>(builder: &fn(push: &pure fn(A)))\n-    -> B {\n+pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(4, builder)\n }\n \n@@ -285,10 +277,8 @@ pub pure fn build<A,B: Buildable<A>>(builder: &fn(push: &pure fn(A)))\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A,B: Buildable<A>>(\n-    size: Option<uint>,\n-    builder: &fn(push: &pure fn(A))) -> B {\n-\n+pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n+                                          builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(size.get_or_default(4), builder)\n }\n \n@@ -312,8 +302,7 @@ pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n  * to the value returned by the function `op`.\n  */\n #[inline(always)]\n-pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n-                                        op: InitOp<T>) -> BT {\n+pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -327,8 +316,7 @@ pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n  * to the value `t`.\n  */\n #[inline(always)]\n-pub pure fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint,\n-                                                t: T) -> BT {\n+pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n         while i < n_elts { push(t); i += 1; }\n@@ -337,8 +325,8 @@ pub pure fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint,\n \n /// Appends two generic sequences.\n #[inline(always)]\n-pub pure fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n-    lhs: &IT, rhs: &IT) -> BT {\n+pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n+                                                  -> BT {\n     let size_opt = lhs.size_hint().chain_ref(\n         |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n     do build_sized_opt(size_opt) |push| {\n@@ -350,8 +338,7 @@ pub pure fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n #[inline(always)]\n-pub pure fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n-    v: &IT) -> BT {\n+pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(*x); }\n     }"}, {"sha": "30ebeda3f5cdc1f089d61f9c9beb617de741188a", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -37,55 +37,55 @@ pub mod raw {\n }\n \n #[inline(always)]\n-pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n+pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n     unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n #[inline(always)]\n-pub pure fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n+pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     //! Determine if two mutable shared boxes point to the same object\n     unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @mut T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for @T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for @mut T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n }\n \n #[test]"}, {"sha": "fc4e52891dd26005e1d22c38f661b1aba99f2893", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -55,7 +55,7 @@ pub impl<T> Data<T> {\n         }\n     }\n \n-    pure fn borrow_const<R>(&self, op: &fn(t: &const T) -> R) -> R {\n+    fn borrow_const<R>(&self, op: &fn(t: &const T) -> R) -> R {\n         op(&const self.value)\n     }\n "}, {"sha": "8c52ac9593a274c81a2b7938737fc7b33e8982b7", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -20,25 +20,25 @@ use cmp::{Eq, Ord, TotalOrd, Ordering, Equal};\n #[cfg(notest)]\n impl Eq for () {\n     #[inline(always)]\n-    pure fn eq(&self, _other: &()) -> bool { true }\n+    fn eq(&self, _other: &()) -> bool { true }\n     #[inline(always)]\n-    pure fn ne(&self, _other: &()) -> bool { false }\n+    fn ne(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(notest)]\n impl Ord for () {\n     #[inline(always)]\n-    pure fn lt(&self, _other: &()) -> bool { false }\n+    fn lt(&self, _other: &()) -> bool { false }\n     #[inline(always)]\n-    pure fn le(&self, _other: &()) -> bool { true }\n+    fn le(&self, _other: &()) -> bool { true }\n     #[inline(always)]\n-    pure fn ge(&self, _other: &()) -> bool { true }\n+    fn ge(&self, _other: &()) -> bool { true }\n     #[inline(always)]\n-    pure fn gt(&self, _other: &()) -> bool { false }\n+    fn gt(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(notest)]\n impl TotalOrd for () {\n     #[inline(always)]\n-    pure fn cmp(&self, _other: &()) -> Ordering { Equal }\n+    fn cmp(&self, _other: &()) -> Ordering { Equal }\n }"}, {"sha": "719e5620d02ca70d8e33e2a057b8695aa66634a0", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -33,7 +33,7 @@ macro_rules! delegate(\n             ),*\n         ) -> $rv:ty = $bound_name:path\n     ) => (\n-        pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\n+        pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n             unsafe {\n                 $bound_name($( $arg ),*)\n             }\n@@ -109,65 +109,67 @@ pub const infinity: f32 = 1.0_f32/0.0_f32;\n pub const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n #[inline(always)]\n-pub pure fn is_NaN(f: f32) -> bool { f != f }\n+pub fn is_NaN(f: f32) -> bool { f != f }\n \n #[inline(always)]\n-pub pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n+pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n #[inline(always)]\n-pub pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n+pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n #[inline(always)]\n-pub pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n+pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n #[inline(always)]\n-pub pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n+pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n #[inline(always)]\n-pub pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n+pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n #[inline(always)]\n-pub pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n+pub fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n #[inline(always)]\n-pub pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n+pub fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n #[inline(always)]\n-pub pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n+pub fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n #[inline(always)]\n-pub pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n+pub fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n #[inline(always)]\n-pub pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n+pub fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n #[inline(always)]\n-pub pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n+pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n /// Returns `x` rounded down\n #[inline(always)]\n-pub pure fn floor(x: f32) -> f32 { unsafe { floorf32(x) } }\n+pub fn floor(x: f32) -> f32 { unsafe { floorf32(x) } }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n /// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n #[inline(always)]\n-pub pure fn is_positive(x: f32) -> bool\n-    { return x > 0.0f32 || (1.0f32/x) == infinity; }\n+pub fn is_positive(x: f32) -> bool {\n+    x > 0.0f32 || (1.0f32/x) == infinity\n+}\n \n /// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n #[inline(always)]\n-pub pure fn is_negative(x: f32) -> bool\n-    { return x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n+pub fn is_negative(x: f32) -> bool {\n+    x < 0.0f32 || (1.0f32/x) == neg_infinity\n+}\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n  *\n  * This is the same as `f32::is_negative`.\n  */\n #[inline(always)]\n-pub pure fn is_nonpositive(x: f32) -> bool {\n+pub fn is_nonpositive(x: f32) -> bool {\n   return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n@@ -177,25 +179,25 @@ pub pure fn is_nonpositive(x: f32) -> bool {\n  * This is the same as `f32::is_positive`.)\n  */\n #[inline(always)]\n-pub pure fn is_nonnegative(x: f32) -> bool {\n+pub fn is_nonnegative(x: f32) -> bool {\n   return x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n-pub pure fn is_zero(x: f32) -> bool {\n+pub fn is_zero(x: f32) -> bool {\n     return x == 0.0f32 || x == -0.0f32;\n }\n \n /// Returns true if `x`is an infinite number\n #[inline(always)]\n-pub pure fn is_infinite(x: f32) -> bool {\n+pub fn is_infinite(x: f32) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n #[inline(always)]\n-pub pure fn is_finite(x: f32) -> bool {\n+pub fn is_finite(x: f32) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n@@ -246,97 +248,97 @@ pub mod consts {\n }\n \n #[inline(always)]\n-pub pure fn signbit(x: f32) -> int {\n+pub fn signbit(x: f32) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n #[inline(always)]\n-pub pure fn logarithm(n: f32, b: f32) -> f32 {\n+pub fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n }\n \n #[cfg(notest)]\n impl cmp::Eq for f32 {\n     #[inline(always)]\n-    pure fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n+    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n+    fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl cmp::Ord for f32 {\n     #[inline(always)]\n-    pure fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n impl num::Zero for f32 {\n     #[inline(always)]\n-    static pure fn zero() -> f32 { 0.0 }\n+    fn zero() -> f32 { 0.0 }\n }\n \n impl num::One for f32 {\n     #[inline(always)]\n-    static pure fn one() -> f32 { 1.0 }\n+    fn one() -> f32 { 1.0 }\n }\n \n impl NumCast for f32 {\n     /**\n      * Cast `n` to an `f32`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n+    fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self          }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self          }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[cfg(notest)]\n impl ops::Add<f32,f32> for f32 {\n-    pure fn add(&self, other: &f32) -> f32 { *self + *other }\n+    fn add(&self, other: &f32) -> f32 { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<f32,f32> for f32 {\n-    pure fn sub(&self, other: &f32) -> f32 { *self - *other }\n+    fn sub(&self, other: &f32) -> f32 { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<f32,f32> for f32 {\n-    pure fn mul(&self, other: &f32) -> f32 { *self * *other }\n+    fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<f32,f32> for f32 {\n-    pure fn div(&self, other: &f32) -> f32 { *self / *other }\n+    fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<f32,f32> for f32 {\n-    pure fn modulo(&self, other: &f32) -> f32 { *self % *other }\n+    fn modulo(&self, other: &f32) -> f32 { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<f32> for f32 {\n-    pure fn neg(&self) -> f32 { -*self }\n+    fn neg(&self) -> f32 { -*self }\n }\n \n impl num::Round for f32 {\n     #[inline(always)]\n-    pure fn round(&self, mode: num::RoundMode) -> f32 {\n+    fn round(&self, mode: num::RoundMode) -> f32 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n@@ -348,11 +350,11 @@ impl num::Round for f32 {\n     }\n \n     #[inline(always)]\n-    pure fn floor(&self) -> f32 { floor(*self) }\n+    fn floor(&self) -> f32 { floor(*self) }\n     #[inline(always)]\n-    pure fn ceil(&self) -> f32 { ceil(*self) }\n+    fn ceil(&self) -> f32 { ceil(*self) }\n     #[inline(always)]\n-    pure fn fract(&self) -> f32 {\n+    fn fract(&self) -> f32 {\n         if is_negative(*self) {\n             (*self) - ceil(*self)\n         } else {\n@@ -373,7 +375,7 @@ impl num::Round for f32 {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str(num: f32) -> ~str {\n+pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -387,7 +389,7 @@ pub pure fn to_str(num: f32) -> ~str {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str_hex(num: f32) -> ~str {\n+pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -408,7 +410,7 @@ pub pure fn to_str_hex(num: f32) -> ~str {\n  * are expected, use `to_str_radix_special()` instead.\n  */\n #[inline(always)]\n-pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n+pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n@@ -426,7 +428,7 @@ pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n  * * radix - The base to use\n  */\n #[inline(always)]\n-pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n@@ -441,7 +443,7 @@ pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n+pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n@@ -457,20 +459,20 @@ pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_digits(num: f32, dig: uint) -> ~str {\n+pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f32 {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f32 {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+    fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n }\n@@ -503,7 +505,7 @@ impl num::ToStrRadix for f32 {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str(num: &str) -> Option<f32> {\n+pub fn from_str(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false)\n }\n@@ -536,7 +538,7 @@ pub pure fn from_str(num: &str) -> Option<f32> {\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n #[inline(always)]\n-pub pure fn from_str_hex(num: &str) -> Option<f32> {\n+pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false)\n }\n@@ -561,19 +563,19 @@ pub pure fn from_str_hex(num: &str) -> Option<f32> {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n+pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for f32 {\n     #[inline(always)]\n-    static pure fn from_str(val: &str) -> Option<f32> { from_str(val) }\n+    fn from_str(val: &str) -> Option<f32> { from_str(val) }\n }\n \n impl num::FromStrRadix for f32 {\n     #[inline(always)]\n-    static pure fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n+    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         from_str_radix(val, rdx)\n     }\n }"}, {"sha": "6a581ddfa9424e6f18aa637fc955513279a8d9a9", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -34,7 +34,7 @@ macro_rules! delegate(\n             ),*\n         ) -> $rv:ty = $bound_name:path\n     ) => (\n-        pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\n+        pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n             unsafe {\n                 $bound_name($( $arg ),*)\n             }\n@@ -136,49 +136,49 @@ pub const infinity: f64 = 1.0_f64/0.0_f64;\n pub const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n #[inline(always)]\n-pub pure fn is_NaN(f: f64) -> bool { f != f }\n+pub fn is_NaN(f: f64) -> bool { f != f }\n \n #[inline(always)]\n-pub pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n+pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n #[inline(always)]\n-pub pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n+pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n #[inline(always)]\n-pub pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n+pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n #[inline(always)]\n-pub pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n+pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n #[inline(always)]\n-pub pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n+pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n #[inline(always)]\n-pub pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n+pub fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n #[inline(always)]\n-pub pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n+pub fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n #[inline(always)]\n-pub pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n+pub fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n #[inline(always)]\n-pub pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n+pub fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n #[inline(always)]\n-pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n+pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n #[inline(always)]\n-pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n+pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n #[inline(always)]\n-pub pure fn is_positive(x: f64) -> bool\n+pub fn is_positive(x: f64) -> bool\n     { return x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n #[inline(always)]\n-pub pure fn is_negative(x: f64) -> bool\n+pub fn is_negative(x: f64) -> bool\n     { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n /**\n@@ -187,7 +187,7 @@ pub pure fn is_negative(x: f64) -> bool\n  * This is the same as `f64::is_negative`.\n  */\n #[inline(always)]\n-pub pure fn is_nonpositive(x: f64) -> bool {\n+pub fn is_nonpositive(x: f64) -> bool {\n   return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n@@ -197,31 +197,31 @@ pub pure fn is_nonpositive(x: f64) -> bool {\n  * This is the same as `f64::positive`.\n  */\n #[inline(always)]\n-pub pure fn is_nonnegative(x: f64) -> bool {\n+pub fn is_nonnegative(x: f64) -> bool {\n   return x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n-pub pure fn is_zero(x: f64) -> bool {\n+pub fn is_zero(x: f64) -> bool {\n     return x == 0.0f64 || x == -0.0f64;\n }\n \n /// Returns true if `x`is an infinite number\n #[inline(always)]\n-pub pure fn is_infinite(x: f64) -> bool {\n+pub fn is_infinite(x: f64) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x` is a finite number\n #[inline(always)]\n-pub pure fn is_finite(x: f64) -> bool {\n+pub fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n /// Returns `x` rounded down\n #[inline(always)]\n-pub pure fn floor(x: f64) -> f64 { unsafe { floorf64(x) } }\n+pub fn floor(x: f64) -> f64 { unsafe { floorf64(x) } }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n@@ -270,97 +270,97 @@ pub mod consts {\n }\n \n #[inline(always)]\n-pub pure fn signbit(x: f64) -> int {\n+pub fn signbit(x: f64) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n #[inline(always)]\n-pub pure fn logarithm(n: f64, b: f64) -> f64 {\n+pub fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n }\n \n #[cfg(notest)]\n impl cmp::Eq for f64 {\n     #[inline(always)]\n-    pure fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n+    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n+    fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl cmp::Ord for f64 {\n     #[inline(always)]\n-    pure fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n impl NumCast for f64 {\n     /**\n      * Cast `n` to an `f64`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n+    fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self          }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self          }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n impl num::Zero for f64 {\n     #[inline(always)]\n-    static pure fn zero() -> f64 { 0.0 }\n+    fn zero() -> f64 { 0.0 }\n }\n \n impl num::One for f64 {\n     #[inline(always)]\n-    static pure fn one() -> f64 { 1.0 }\n+    fn one() -> f64 { 1.0 }\n }\n \n #[cfg(notest)]\n impl ops::Add<f64,f64> for f64 {\n-    pure fn add(&self, other: &f64) -> f64 { *self + *other }\n+    fn add(&self, other: &f64) -> f64 { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<f64,f64> for f64 {\n-    pure fn sub(&self, other: &f64) -> f64 { *self - *other }\n+    fn sub(&self, other: &f64) -> f64 { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<f64,f64> for f64 {\n-    pure fn mul(&self, other: &f64) -> f64 { *self * *other }\n+    fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<f64,f64> for f64 {\n-    pure fn div(&self, other: &f64) -> f64 { *self / *other }\n+    fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<f64,f64> for f64 {\n-    pure fn modulo(&self, other: &f64) -> f64 { *self % *other }\n+    fn modulo(&self, other: &f64) -> f64 { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<f64> for f64 {\n-    pure fn neg(&self) -> f64 { -*self }\n+    fn neg(&self) -> f64 { -*self }\n }\n \n impl num::Round for f64 {\n     #[inline(always)]\n-    pure fn round(&self, mode: num::RoundMode) -> f64 {\n+    fn round(&self, mode: num::RoundMode) -> f64 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n@@ -372,11 +372,11 @@ impl num::Round for f64 {\n     }\n \n     #[inline(always)]\n-    pure fn floor(&self) -> f64 { floor(*self) }\n+    fn floor(&self) -> f64 { floor(*self) }\n     #[inline(always)]\n-    pure fn ceil(&self) -> f64 { ceil(*self) }\n+    fn ceil(&self) -> f64 { ceil(*self) }\n     #[inline(always)]\n-    pure fn fract(&self) -> f64 {\n+    fn fract(&self) -> f64 {\n         if is_negative(*self) {\n             (*self) - ceil(*self)\n         } else {\n@@ -397,7 +397,7 @@ impl num::Round for f64 {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str(num: f64) -> ~str {\n+pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -411,7 +411,7 @@ pub pure fn to_str(num: f64) -> ~str {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str_hex(num: f64) -> ~str {\n+pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -432,7 +432,7 @@ pub pure fn to_str_hex(num: f64) -> ~str {\n  * are expected, use `to_str_radix_special()` instead.\n  */\n #[inline(always)]\n-pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n+pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n@@ -450,7 +450,7 @@ pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n  * * radix - The base to use\n  */\n #[inline(always)]\n-pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n@@ -465,7 +465,7 @@ pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n+pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n@@ -481,20 +481,20 @@ pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_digits(num: f64, dig: uint) -> ~str {\n+pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f64 {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f64 {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+    fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n }\n@@ -527,7 +527,7 @@ impl num::ToStrRadix for f64 {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str(num: &str) -> Option<f64> {\n+pub fn from_str(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false)\n }\n@@ -560,7 +560,7 @@ pub pure fn from_str(num: &str) -> Option<f64> {\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n #[inline(always)]\n-pub pure fn from_str_hex(num: &str) -> Option<f64> {\n+pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false)\n }\n@@ -585,19 +585,19 @@ pub pure fn from_str_hex(num: &str) -> Option<f64> {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n+pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for f64 {\n     #[inline(always)]\n-    static pure fn from_str(val: &str) -> Option<f64> { from_str(val) }\n+    fn from_str(val: &str) -> Option<f64> { from_str(val) }\n }\n \n impl num::FromStrRadix for f64 {\n     #[inline(always)]\n-    static pure fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n+    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         from_str_radix(val, rdx)\n     }\n }"}, {"sha": "4e9a1b62b6ece4bc20428eb5a97f1ddff637d63a", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -103,7 +103,7 @@ pub mod consts {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str(num: float) -> ~str {\n+pub fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -117,7 +117,7 @@ pub pure fn to_str(num: float) -> ~str {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str_hex(num: float) -> ~str {\n+pub fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -138,7 +138,7 @@ pub pure fn to_str_hex(num: float) -> ~str {\n  * are expected, use `to_str_radix_special()` instead.\n  */\n #[inline(always)]\n-pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n+pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, radix, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n@@ -156,7 +156,7 @@ pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n  * * radix - The base to use\n  */\n #[inline(always)]\n-pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n@@ -171,7 +171,7 @@ pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n+pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n@@ -193,20 +193,20 @@ pub fn test_to_str_exact_do_decimal() {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_digits(num: float, digits: uint) -> ~str {\n+pub fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n \n impl to_str::ToStr for float {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for float {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }\n@@ -239,7 +239,7 @@ impl num::ToStrRadix for float {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str(num: &str) -> Option<float> {\n+pub fn from_str(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false)\n }\n@@ -272,7 +272,7 @@ pub pure fn from_str(num: &str) -> Option<float> {\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n #[inline(always)]\n-pub pure fn from_str_hex(num: &str) -> Option<float> {\n+pub fn from_str_hex(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false)\n }\n@@ -297,19 +297,19 @@ pub pure fn from_str_hex(num: &str) -> Option<float> {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n+pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n     strconv::from_str_common(num, radix, true, true, false,\n                              strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for float {\n     #[inline(always)]\n-    static pure fn from_str(val: &str) -> Option<float> { from_str(val) }\n+    fn from_str(val: &str) -> Option<float> { from_str(val) }\n }\n \n impl num::FromStrRadix for float {\n     #[inline(always)]\n-    static pure fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n+    fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n         from_str_radix(val, radix)\n     }\n }\n@@ -330,7 +330,7 @@ impl num::FromStrRadix for float {\n  *\n  * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n  */\n-pub pure fn pow_with_uint(base: uint, pow: uint) -> float {\n+pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n             return NaN as float;\n@@ -351,98 +351,98 @@ pub pure fn pow_with_uint(base: uint, pow: uint) -> float {\n }\n \n #[inline(always)]\n-pub pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+pub fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n #[inline(always)]\n-pub pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+pub fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n #[inline(always)]\n-pub pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+pub fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n #[inline(always)]\n-pub pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+pub fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n #[inline(always)]\n-pub pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+pub fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n #[inline(always)]\n-pub pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+pub fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n #[inline(always)]\n-pub pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+pub fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n #[inline(always)]\n-pub pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n+pub fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n \n #[inline(always)]\n-pub pure fn abs(x: float) -> float {\n+pub fn abs(x: float) -> float {\n     unsafe { f64::abs(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn sqrt(x: float) -> float {\n+pub fn sqrt(x: float) -> float {\n     unsafe { f64::sqrt(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn atan(x: float) -> float {\n+pub fn atan(x: float) -> float {\n     unsafe { f64::atan(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn sin(x: float) -> float {\n+pub fn sin(x: float) -> float {\n     unsafe { f64::sin(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn cos(x: float) -> float {\n+pub fn cos(x: float) -> float {\n     unsafe { f64::cos(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn tan(x: float) -> float {\n+pub fn tan(x: float) -> float {\n     unsafe { f64::tan(x as f64) as float }\n }\n \n #[cfg(notest)]\n impl Eq for float {\n-    pure fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-    pure fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl Ord for float {\n-    pure fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    pure fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    pure fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    pure fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n+    fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n+    fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n+    fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n+    fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n impl num::Zero for float {\n     #[inline(always)]\n-    static pure fn zero() -> float { 0.0 }\n+    fn zero() -> float { 0.0 }\n }\n \n impl num::One for float {\n     #[inline(always)]\n-    static pure fn one() -> float { 1.0 }\n+    fn one() -> float { 1.0 }\n }\n \n impl NumCast for float {\n     /**\n      * Cast `n` to a `float`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> float { n.to_float() }\n+    fn from<N:NumCast>(n: N) -> float { n.to_float() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self          }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self          }\n }\n \n impl num::Round for float {\n     #[inline(always)]\n-    pure fn round(&self, mode: num::RoundMode) -> float {\n+    fn round(&self, mode: num::RoundMode) -> float {\n         match mode {\n             num::RoundDown\n                 => f64::floor(*self as f64) as float,\n@@ -460,11 +460,11 @@ impl num::Round for float {\n     }\n \n     #[inline(always)]\n-    pure fn floor(&self) -> float { f64::floor(*self as f64) as float}\n+    fn floor(&self) -> float { f64::floor(*self as f64) as float}\n     #[inline(always)]\n-    pure fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n+    fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n     #[inline(always)]\n-    pure fn fract(&self) -> float {\n+    fn fract(&self) -> float {\n         if is_negative(*self) {\n             (*self) - (f64::ceil(*self as f64) as float)\n         } else {\n@@ -475,27 +475,27 @@ impl num::Round for float {\n \n #[cfg(notest)]\n impl ops::Add<float,float> for float {\n-    pure fn add(&self, other: &float) -> float { *self + *other }\n+    fn add(&self, other: &float) -> float { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<float,float> for float {\n-    pure fn sub(&self, other: &float) -> float { *self - *other }\n+    fn sub(&self, other: &float) -> float { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<float,float> for float {\n-    pure fn mul(&self, other: &float) -> float { *self * *other }\n+    fn mul(&self, other: &float) -> float { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<float,float> for float {\n-    pure fn div(&self, other: &float) -> float { *self / *other }\n+    fn div(&self, other: &float) -> float { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<float,float> for float {\n-    pure fn modulo(&self, other: &float) -> float { *self % *other }\n+    fn modulo(&self, other: &float) -> float { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<float> for float {\n-    pure fn neg(&self) -> float { -*self }\n+    fn neg(&self) -> float { -*self }\n }\n \n #[test]"}, {"sha": "4d5ac92311ef8e02f1024c343b1319364c25407a", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -28,13 +28,13 @@ pub const min_value: T = (-1 as T) << (bits - 1);\n pub const max_value: T = min_value - 1 as T;\n \n #[inline(always)]\n-pub pure fn add(x: T, y: T) -> T { x + y }\n+pub fn add(x: T, y: T) -> T { x + y }\n #[inline(always)]\n-pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n-pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub pure fn div(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n \n /**\n  * Returns the remainder of y / x.\n@@ -57,29 +57,29 @@ pub pure fn div(x: T, y: T) -> T { x / y }\n  *\n  */\n #[inline(always)]\n-pub pure fn rem(x: T, y: T) -> T { x % y }\n+pub fn rem(x: T, y: T) -> T { x % y }\n \n #[inline(always)]\n-pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub fn lt(x: T, y: T) -> bool { x < y }\n #[inline(always)]\n-pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub fn le(x: T, y: T) -> bool { x <= y }\n #[inline(always)]\n-pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub fn eq(x: T, y: T) -> bool { x == y }\n #[inline(always)]\n-pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub fn ne(x: T, y: T) -> bool { x != y }\n #[inline(always)]\n-pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n-pub pure fn gt(x: T, y: T) -> bool { x > y }\n+pub fn gt(x: T, y: T) -> bool { x > y }\n \n #[inline(always)]\n-pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub fn is_positive(x: T) -> bool { x > 0 as T }\n #[inline(always)]\n-pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub fn is_negative(x: T) -> bool { x < 0 as T }\n #[inline(always)]\n-pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n #[inline(always)]\n-pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n /**\n  * Iterate over the range [`lo`..`hi`)\n@@ -100,7 +100,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  */\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub pure fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n+pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n@@ -119,116 +119,116 @@ pub pure fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T, it);\n }\n \n /// Computes the bitwise complement\n #[inline(always)]\n-pub pure fn compl(i: T) -> T {\n+pub fn compl(i: T) -> T {\n     -1 as T ^ i\n }\n \n /// Computes the absolute value\n #[inline(always)]\n-pub pure fn abs(i: T) -> T {\n+pub fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n #[cfg(notest)]\n impl Ord for T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n+    fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n     #[inline(always)]\n-    pure fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n+    fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n     #[inline(always)]\n-    pure fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n+    fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n     #[inline(always)]\n-    pure fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n+    fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(notest)]\n impl Eq for T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n     #[inline(always)]\n-    pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n+    fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl num::Zero for T {\n     #[inline(always)]\n-    static pure fn zero() -> T { 0 }\n+    fn zero() -> T { 0 }\n }\n \n impl num::One for T {\n     #[inline(always)]\n-    static pure fn one() -> T { 1 }\n+    fn one() -> T { 1 }\n }\n \n #[cfg(notest)]\n impl ops::Add<T,T> for T {\n-    pure fn add(&self, other: &T) -> T { *self + *other }\n+    fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<T,T> for T {\n-    pure fn sub(&self, other: &T) -> T { *self - *other }\n+    fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<T,T> for T {\n-    pure fn mul(&self, other: &T) -> T { *self * *other }\n+    fn mul(&self, other: &T) -> T { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<T,T> for T {\n-    pure fn div(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<T,T> for T {\n-    pure fn modulo(&self, other: &T) -> T { *self % *other }\n+    fn modulo(&self, other: &T) -> T { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<T> for T {\n-    pure fn neg(&self) -> T { -*self }\n+    fn neg(&self) -> T { -*self }\n }\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T> {\n+pub fn from_str(s: &str) -> Option<T> {\n     strconv::from_str_common(s, 10u, true, false, false,\n                          strconv::ExpNone, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n-pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+pub fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n     strconv::from_str_common(s, radix, true, false, false,\n                          strconv::ExpNone, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n-pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n     strconv::from_str_bytes_common(buf, radix, true, false, false,\n                                strconv::ExpNone, false)\n }\n \n impl FromStr for T {\n     #[inline(always)]\n-    static pure fn from_str(s: &str) -> Option<T> {\n+    fn from_str(s: &str) -> Option<T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for T {\n     #[inline(always)]\n-    static pure fn from_str_radix(&self, s: &str, radix: uint) -> Option<T> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n         from_str_radix(s, radix)\n     }\n }\n@@ -237,38 +237,38 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n-pub pure fn to_str(num: T) -> ~str {\n+pub fn to_str(num: T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n-pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+pub fn to_str_radix(num: T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for T {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for T {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }"}, {"sha": "9914807c98f6f4408e4b4ac28ed8bd725a5c6632", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i16 {\n      * Cast `n` to a `i16`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n+    fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self          }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self          }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "c02facd47db25a95ddc2c535344191dbf0098009", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i32 {\n      * Cast `n` to a `i32`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n+    fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self          }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self          }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "c285ba23c27899e444f9a0ba1a21e133f249d8fb", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i64 {\n      * Cast `n` to a `i64`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n+    fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self          }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self          }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "2733a064563269d26b8928f202f5b0dff9419641", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i8 {\n      * Cast `n` to a `i8`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n+    fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self          }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self          }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "29e1e52348eb9eb821a839f209092dfecb13ec6d", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -19,7 +19,7 @@ mod inst {\n     pub const bits: uint = ::uint::bits;\n \n     /// Returns `base` raised to the power of `exponent`\n-    pub pure fn pow(base: int, exponent: uint) -> int {\n+    pub fn pow(base: int, exponent: uint) -> int {\n         if exponent == 0u {\n             //Not mathemtically true if ~[base == 0]\n             return 1;\n@@ -63,23 +63,23 @@ impl NumCast for int {\n      * Cast `n` to a `int`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> int { n.to_int() }\n+    fn from<N:NumCast>(n: N) -> int { n.to_int() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self          }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self          }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "32d48aac0b342d55e0ed11bb8e3b9df8b732005f", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,28 +17,28 @@ use kinds::Copy;\n pub mod strconv;\n \n pub trait IntConvertible {\n-    pure fn to_int(&self) -> int;\n-    static pure fn from_int(n: int) -> Self;\n+    fn to_int(&self) -> int;\n+    fn from_int(n: int) -> Self;\n }\n \n pub trait Zero {\n-    static pure fn zero() -> Self;\n+    fn zero() -> Self;\n }\n \n pub trait One {\n-    static pure fn one() -> Self;\n+    fn one() -> Self;\n }\n \n-pub pure fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n+pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }\n \n pub trait Round {\n-    pure fn round(&self, mode: RoundMode) -> Self;\n+    fn round(&self, mode: RoundMode) -> Self;\n \n-    pure fn floor(&self) -> Self;\n-    pure fn ceil(&self)  -> Self;\n-    pure fn fract(&self) -> Self;\n+    fn floor(&self) -> Self;\n+    fn ceil(&self)  -> Self;\n+    fn fract(&self) -> Self;\n }\n \n pub enum RoundMode {\n@@ -59,39 +59,39 @@ pub enum RoundMode {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n+pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n \n /**\n  * An interface for generic numeric type casts\n  */\n pub trait NumCast {\n-    static pure fn from<T:NumCast>(n: T) -> Self;\n-\n-    pure fn to_u8(&self) -> u8;\n-    pure fn to_u16(&self) -> u16;\n-    pure fn to_u32(&self) -> u32;\n-    pure fn to_u64(&self) -> u64;\n-    pure fn to_uint(&self) -> uint;\n-\n-    pure fn to_i8(&self) -> i8;\n-    pure fn to_i16(&self) -> i16;\n-    pure fn to_i32(&self) -> i32;\n-    pure fn to_i64(&self) -> i64;\n-    pure fn to_int(&self) -> int;\n-\n-    pure fn to_f32(&self) -> f32;\n-    pure fn to_f64(&self) -> f64;\n-    pure fn to_float(&self) -> float;\n+    fn from<T:NumCast>(n: T) -> Self;\n+\n+    fn to_u8(&self) -> u8;\n+    fn to_u16(&self) -> u16;\n+    fn to_u32(&self) -> u32;\n+    fn to_u64(&self) -> u64;\n+    fn to_uint(&self) -> uint;\n+\n+    fn to_i8(&self) -> i8;\n+    fn to_i16(&self) -> i16;\n+    fn to_i32(&self) -> i32;\n+    fn to_i64(&self) -> i64;\n+    fn to_int(&self) -> int;\n+\n+    fn to_f32(&self) -> f32;\n+    fn to_f64(&self) -> f64;\n+    fn to_float(&self) -> float;\n }\n \n pub trait ToStrRadix {\n-    pub pure fn to_str_radix(&self, radix: uint) -> ~str;\n+    pub fn to_str_radix(&self, radix: uint) -> ~str;\n }\n \n pub trait FromStrRadix {\n-    static pub pure fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+    pub fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n // Generic math functions:\n@@ -109,7 +109,7 @@ pub trait FromStrRadix {\n  * - If code written to use this function doesn't care about it, it's\n  *   probably assuming that `x^0` always equals `1`.\n  */\n-pub pure fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n+pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();"}, {"sha": "e39d52d86f2cdbf7f784ec39571833d0228636ed", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -37,78 +37,78 @@ pub enum SignFormat {\n }\n \n #[inline(always)]\n-pure fn is_NaN<T:Eq>(num: &T) -> bool {\n+fn is_NaN<T:Eq>(num: &T) -> bool {\n     *num != *num\n }\n \n #[inline(always)]\n-pure fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n+fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n #[inline(always)]\n-pure fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n+fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::neg_inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n #[inline(always)]\n-pure fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n+fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n     *num == _0 && is_neg_inf(&(_1 / *num))\n }\n \n pub trait NumStrConv {\n-    static pure fn NaN()      -> Option<Self>;\n-    static pure fn inf()      -> Option<Self>;\n-    static pure fn neg_inf()  -> Option<Self>;\n-    static pure fn neg_zero() -> Option<Self>;\n+    fn NaN()      -> Option<Self>;\n+    fn inf()      -> Option<Self>;\n+    fn neg_inf()  -> Option<Self>;\n+    fn neg_zero() -> Option<Self>;\n \n-    pure fn round_to_zero(&self)   -> Self;\n-    pure fn fractional_part(&self) -> Self;\n+    fn round_to_zero(&self)   -> Self;\n+    fn fractional_part(&self) -> Self;\n }\n \n macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n     impl NumStrConv for $t {\n         #[inline(always)]\n-        static pure fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n+        fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n         #[inline(always)]\n-        static pure fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n+        fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n         #[inline(always)]\n-        static pure fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n+        fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n         #[inline(always)]\n-        static pure fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n+        fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n \n         #[inline(always)]\n-        pure fn round_to_zero(&self) -> $t {\n+        fn round_to_zero(&self) -> $t {\n             ( if *self < 0.0 { f64::ceil(*self as f64)  }\n               else           { f64::floor(*self as f64) }\n             ) as $t\n         }\n \n         #[inline(always)]\n-        pure fn fractional_part(&self) -> $t {\n+        fn fractional_part(&self) -> $t {\n             *self - self.round_to_zero()\n         }\n     }\n ))\n \n macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline(always)] static pure fn NaN()      -> Option<$t> { None }\n-        #[inline(always)] static pure fn inf()      -> Option<$t> { None }\n-        #[inline(always)] static pure fn neg_inf()  -> Option<$t> { None }\n-        #[inline(always)] static pure fn neg_zero() -> Option<$t> { None }\n+        #[inline(always)] fn NaN()      -> Option<$t> { None }\n+        #[inline(always)] fn inf()      -> Option<$t> { None }\n+        #[inline(always)] fn neg_inf()  -> Option<$t> { None }\n+        #[inline(always)] fn neg_zero() -> Option<$t> { None }\n \n-        #[inline(always)] pure fn round_to_zero(&self)   -> $t { *self }\n-        #[inline(always)] pure fn fractional_part(&self) -> $t {     0 }\n+        #[inline(always)] fn round_to_zero(&self)   -> $t { *self }\n+        #[inline(always)] fn fractional_part(&self) -> $t {     0 }\n     }\n ))\n \n@@ -161,7 +161,7 @@ impl_NumStrConv_Integer!(u64)\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                                   Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n@@ -383,7 +383,7 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                             Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n@@ -439,7 +439,7 @@ priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Could accept option to allow ignoring underscores, allowing for numbers\n  *   formated like `FF_AE_FF_FF`.\n  */\n-pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -628,7 +628,7 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool"}, {"sha": "b8e713ff3aba5d6fc332a9eb36ee8ed36b59807e", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -30,44 +30,44 @@ pub const min_value: T = 0 as T;\n pub const max_value: T = 0 as T - 1 as T;\n \n #[inline(always)]\n-pub pure fn add(x: T, y: T) -> T { x + y }\n+pub fn add(x: T, y: T) -> T { x + y }\n #[inline(always)]\n-pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n-pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub pure fn div(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n #[inline(always)]\n-pub pure fn rem(x: T, y: T) -> T { x % y }\n+pub fn rem(x: T, y: T) -> T { x % y }\n \n #[inline(always)]\n-pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub fn lt(x: T, y: T) -> bool { x < y }\n #[inline(always)]\n-pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub fn le(x: T, y: T) -> bool { x <= y }\n #[inline(always)]\n-pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub fn eq(x: T, y: T) -> bool { x == y }\n #[inline(always)]\n-pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub fn ne(x: T, y: T) -> bool { x != y }\n #[inline(always)]\n-pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n-pub pure fn gt(x: T, y: T) -> bool { x > y }\n+pub fn gt(x: T, y: T) -> bool { x > y }\n \n #[inline(always)]\n-pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub fn is_positive(x: T) -> bool { x > 0 as T }\n #[inline(always)]\n-pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub fn is_negative(x: T) -> bool { x < 0 as T }\n #[inline(always)]\n-pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n #[inline(always)]\n-pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n /**\n  * Iterate over the range [`start`,`start`+`step`..`stop`)\n  *\n  */\n-pub pure fn range_step(start: T,\n+pub fn range_step(start: T,\n                        stop: T,\n                        step: T_SIGNED,\n                        it: &fn(T) -> bool) {\n@@ -91,110 +91,110 @@ pub pure fn range_step(start: T,\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T_SIGNED, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T_SIGNED, it);\n }\n \n /// Computes the bitwise complement\n #[inline(always)]\n-pub pure fn compl(i: T) -> T {\n+pub fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n #[cfg(notest)]\n impl Ord for T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(notest)]\n impl Eq for T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n     #[inline(always)]\n-    pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n+    fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl num::Zero for T {\n     #[inline(always)]\n-    static pure fn zero() -> T { 0 }\n+    fn zero() -> T { 0 }\n }\n \n impl num::One for T {\n     #[inline(always)]\n-    static pure fn one() -> T { 1 }\n+    fn one() -> T { 1 }\n }\n \n #[cfg(notest)]\n impl ops::Add<T,T> for T {\n-    pure fn add(&self, other: &T) -> T { *self + *other }\n+    fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<T,T> for T {\n-    pure fn sub(&self, other: &T) -> T { *self - *other }\n+    fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<T,T> for T {\n-    pure fn mul(&self, other: &T) -> T { *self * *other }\n+    fn mul(&self, other: &T) -> T { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<T,T> for T {\n-    pure fn div(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<T,T> for T {\n-    pure fn modulo(&self, other: &T) -> T { *self % *other }\n+    fn modulo(&self, other: &T) -> T { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<T> for T {\n-    pure fn neg(&self) -> T { -*self }\n+    fn neg(&self) -> T { -*self }\n }\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T> {\n+pub fn from_str(s: &str) -> Option<T> {\n     strconv::from_str_common(s, 10u, false, false, false,\n                              strconv::ExpNone, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n-pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+pub fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n     strconv::from_str_common(s, radix, false, false, false,\n                              strconv::ExpNone, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n-pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n     strconv::from_str_bytes_common(buf, radix, false, false, false,\n                                    strconv::ExpNone, false)\n }\n \n impl FromStr for T {\n     #[inline(always)]\n-    static pure fn from_str(s: &str) -> Option<T> {\n+    fn from_str(s: &str) -> Option<T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for T {\n     #[inline(always)]\n-    static pure fn from_str_radix(&self, s: &str, radix: uint) -> Option<T> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n         from_str_radix(s, radix)\n     }\n }\n@@ -203,38 +203,38 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n-pub pure fn to_str(num: T) -> ~str {\n+pub fn to_str(num: T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n-pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+pub fn to_str_radix(num: T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for T {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for T {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }"}, {"sha": "bdd951201362118b8ac79e8b48670297aa2470fb", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,23 +24,23 @@ impl NumCast for u16 {\n      * Cast `n` to a `u16`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n+    fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self          }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self          }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "7bef51489f22188f2e4e63b9011f23421111ec5d", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,23 +24,23 @@ impl NumCast for u32 {\n      * Cast `n` to a `u32`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n+    fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self          }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self          }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "fecafe37f3d935b93acfaaf050bbfe8228c802b6", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,23 +24,23 @@ impl NumCast for u64 {\n      * Cast `n` to a `u64`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n+    fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self          }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self          }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "0d48de67334a525fa9b9583ee1be60265aa641fd", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -23,31 +23,31 @@ mod inst {\n     // Type-specific functions here. These must be reexported by the\n     // parent module so that they appear in core::u8 and not core::u8::u8;\n \n-    pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n+    pub fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n }\n \n impl NumCast for u8 {\n     /**\n      * Cast `n` to a `u8`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n+    fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self          }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self          }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "f3f27a4e48ab65d44c9be730110c4592ebb5d422", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -45,7 +45,7 @@ pub mod inst {\n     *\n     * The smallest integer `q` such that `x/y <= q`.\n     */\n-    pub pure fn div_ceil(x: uint, y: uint) -> uint {\n+    pub fn div_ceil(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y == 0u { div }\n         else { div + 1u }\n@@ -63,7 +63,7 @@ pub mod inst {\n     *\n     * The integer `q` closest to `x/y`.\n     */\n-    pub pure fn div_round(x: uint, y: uint) -> uint {\n+    pub fn div_round(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y * 2u  < y { div }\n         else { div + 1u }\n@@ -84,7 +84,7 @@ pub mod inst {\n     * The smallest integer `q` such that `x/y <= q`. This\n     * is either `x/y` or `x/y + 1`.\n     */\n-    pub pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n+    pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n     /**\n     * Iterate over the range [`lo`..`hi`), or stop when requested\n@@ -101,7 +101,7 @@ pub mod inst {\n     * `true` If execution proceeded correctly, `false` if it was interrupted,\n     * that is if `it` returned `false` at any point.\n     */\n-    pub pure fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n         let mut i = lo;\n         while i < hi {\n             if (!it(i)) { return false; }\n@@ -122,7 +122,7 @@ pub mod inst {\n         * use with integer literals of inferred integer-type as\n         * the self-value (eg. `for 100.times { ... }`).\n         */\n-        pure fn times(&self, it: &fn() -> bool) {\n+        fn times(&self, it: &fn() -> bool) {\n             let mut i = *self;\n             while i > 0 {\n                 if !it() { break }\n@@ -133,7 +133,7 @@ pub mod inst {\n \n     /// Returns the smallest power of 2 greater than or equal to `n`\n     #[inline(always)]\n-    pub pure fn next_power_of_two(n: uint) -> uint {\n+    pub fn next_power_of_two(n: uint) -> uint {\n         let halfbits: uint = sys::size_of::<uint>() * 4u;\n         let mut tmp: uint = n - 1u;\n         let mut shift: uint = 1u;\n@@ -215,23 +215,23 @@ impl NumCast for uint {\n      * Cast `n` to a `uint`\n      */\n     #[inline(always)]\n-    static pure fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n+    fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self          }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self          }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "2f7fe1e4aa8bf519d004c543c0e75facdce0d632", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,65 +17,65 @@ pub trait Drop {\n \n #[lang=\"add\"]\n pub trait Add<RHS,Result> {\n-    pure fn add(&self, rhs: &RHS) -> Result;\n+    fn add(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"sub\"]\n pub trait Sub<RHS,Result> {\n-    pure fn sub(&self, rhs: &RHS) -> Result;\n+    fn sub(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"mul\"]\n pub trait Mul<RHS,Result> {\n-    pure fn mul(&self, rhs: &RHS) -> Result;\n+    fn mul(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"div\"]\n pub trait Div<RHS,Result> {\n-    pure fn div(&self, rhs: &RHS) -> Result;\n+    fn div(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"modulo\"]\n pub trait Modulo<RHS,Result> {\n-    pure fn modulo(&self, rhs: &RHS) -> Result;\n+    fn modulo(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"neg\"]\n pub trait Neg<Result> {\n-    pure fn neg(&self) -> Result;\n+    fn neg(&self) -> Result;\n }\n \n #[lang=\"not\"]\n pub trait Not<Result> {\n-    pure fn not(&self) -> Result;\n+    fn not(&self) -> Result;\n }\n \n #[lang=\"bitand\"]\n pub trait BitAnd<RHS,Result> {\n-    pure fn bitand(&self, rhs: &RHS) -> Result;\n+    fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"bitor\"]\n pub trait BitOr<RHS,Result> {\n-    pure fn bitor(&self, rhs: &RHS) -> Result;\n+    fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"bitxor\"]\n pub trait BitXor<RHS,Result> {\n-    pure fn bitxor(&self, rhs: &RHS) -> Result;\n+    fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"shl\"]\n pub trait Shl<RHS,Result> {\n-    pure fn shl(&self, rhs: &RHS) -> Result;\n+    fn shl(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"shr\"]\n pub trait Shr<RHS,Result> {\n-    pure fn shr(&self, rhs: &RHS) -> Result;\n+    fn shr(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"index\"]\n pub trait Index<Index,Result> {\n-    pure fn index(&self, index: Index) -> Result;\n+    fn index(&self, index: Index) -> Result;\n }"}, {"sha": "dd92333b61dbe8051dff25b59137d9c23d0daa7b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -59,7 +59,7 @@ pub enum Option<T> {\n }\n \n impl<T:Ord> Ord for Option<T> {\n-    pure fn lt(&self, other: &Option<T>) -> bool {\n+    fn lt(&self, other: &Option<T>) -> bool {\n         match (self, other) {\n             (&None, &None) => false,\n             (&None, &Some(_)) => true,\n@@ -68,7 +68,7 @@ impl<T:Ord> Ord for Option<T> {\n         }\n     }\n \n-    pure fn le(&self, other: &Option<T>) -> bool {\n+    fn le(&self, other: &Option<T>) -> bool {\n         match (self, other) {\n             (&None, &None) => true,\n             (&None, &Some(_)) => true,\n@@ -77,18 +77,18 @@ impl<T:Ord> Ord for Option<T> {\n         }\n     }\n \n-    pure fn ge(&self, other: &Option<T>) -> bool {\n+    fn ge(&self, other: &Option<T>) -> bool {\n         ! (self < other)\n     }\n \n-    pure fn gt(&self, other: &Option<T>) -> bool {\n+    fn gt(&self, other: &Option<T>) -> bool {\n         ! (self <= other)\n     }\n }\n \n impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n     #[inline(always)]\n-    pure fn add(&self, other: &Option<T>) -> Option<T> {\n+    fn add(&self, other: &Option<T>) -> Option<T> {\n         match (*self, *other) {\n             (None, None) => None,\n             (_, None) => *self,\n@@ -99,7 +99,7 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn get<T:Copy>(opt: Option<T>) -> T {\n+pub fn get<T:Copy>(opt: Option<T>) -> T {\n     /*!\n     Gets the value out of an option\n \n@@ -122,7 +122,7 @@ pub pure fn get<T:Copy>(opt: Option<T>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n+pub fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n     /*!\n     Gets an immutable reference to the value inside an option.\n \n@@ -143,7 +143,7 @@ pub pure fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n     }\n }\n \n-pub pure fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n+pub fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n     /*!\n     Gets a mutable reference to the value inside an option.\n \n@@ -165,14 +165,14 @@ pub pure fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n }\n \n #[inline(always)]\n-pub pure fn map<T, U>(opt: &'r Option<T>, f: &fn(x: &'r T) -> U) -> Option<U> {\n+pub fn map<T, U>(opt: &'r Option<T>, f: &fn(x: &'r T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n #[inline(always)]\n-pub pure fn map_consume<T, U>(opt: Option<T>,\n+pub fn map_consume<T, U>(opt: Option<T>,\n                               f: &fn(v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n@@ -182,7 +182,7 @@ pub pure fn map_consume<T, U>(opt: Option<T>,\n }\n \n #[inline(always)]\n-pub pure fn chain<T, U>(opt: Option<T>,\n+pub fn chain<T, U>(opt: Option<T>,\n                         f: &fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n@@ -196,7 +196,7 @@ pub pure fn chain<T, U>(opt: Option<T>,\n }\n \n #[inline(always)]\n-pub pure fn chain_ref<T, U>(opt: &Option<T>,\n+pub fn chain_ref<T, U>(opt: &Option<T>,\n                             f: &fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n@@ -207,7 +207,7 @@ pub pure fn chain_ref<T, U>(opt: &Option<T>,\n }\n \n #[inline(always)]\n-pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n+pub fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost Some() value, or None if both are None.\n      */\n@@ -218,7 +218,7 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n+pub fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt = x;\n@@ -228,43 +228,43 @@ pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n }\n \n #[inline(always)]\n-pub pure fn is_none<T>(opt: &const Option<T>) -> bool {\n+pub fn is_none<T>(opt: &const Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n     match *opt { None => true, Some(_) => false }\n }\n \n #[inline(always)]\n-pub pure fn is_some<T>(opt: &const Option<T>) -> bool {\n+pub fn is_some<T>(opt: &const Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n #[inline(always)]\n-pub pure fn get_or_zero<T:Copy + Zero>(opt: Option<T>) -> T {\n+pub fn get_or_zero<T:Copy + Zero>(opt: Option<T>) -> T {\n     //! Returns the contained value or zero (for this type)\n \n     match opt { Some(copy x) => x, None => Zero::zero() }\n }\n \n #[inline(always)]\n-pub pure fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n+pub fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n     match opt { Some(copy x) => x, None => def }\n }\n \n #[inline(always)]\n-pub pure fn map_default<T, U>(opt: &'r Option<T>, def: U,\n+pub fn map_default<T, U>(opt: &'r Option<T>, def: U,\n                               f: &fn(&'r T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => def, Some(ref t) => f(t) }\n }\n \n #[inline(always)]\n-pub pure fn unwrap<T>(opt: Option<T>) -> T {\n+pub fn unwrap<T>(opt: Option<T>) -> T {\n     /*!\n     Moves a value out of an option type and returns it.\n \n@@ -302,7 +302,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n+pub fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     match opt {\n         Some(val) => val,\n@@ -313,12 +313,12 @@ pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(x: &'self T) -> bool) {\n+    fn each(&self, f: &fn(x: &'self T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> {\n+    fn size_hint(&self) -> Option<uint> {\n         if self.is_some() { Some(1) } else { Some(0) }\n     }\n }\n@@ -333,42 +333,42 @@ impl<T> MutableIter<T> for Option<T> {\n pub impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n     #[inline(always)]\n-    pure fn is_none(&const self) -> bool { is_none(self) }\n+    fn is_none(&const self) -> bool { is_none(self) }\n \n     /// Returns true if the option contains some value\n     #[inline(always)]\n-    pure fn is_some(&const self) -> bool { is_some(self) }\n+    fn is_some(&const self) -> bool { is_some(self) }\n \n     /**\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n     #[inline(always)]\n-    pure fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n+    fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n         chain_ref(self, f)\n     }\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    pure fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> { map(self, f) }\n+    fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> { map(self, f) }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n-    pure fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n+    fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         map_consume(self, f)\n     }\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    pure fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n+    fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n         map_default(self, def, f)\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n-    pure fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n+    fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n \n@@ -403,7 +403,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    pure fn get_ref(&self) -> &'self T { get_ref(self) }\n+    fn get_ref(&self) -> &'self T { get_ref(self) }\n \n     /**\n     Gets a mutable reference to the value inside an option.\n@@ -420,7 +420,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    pure fn get_mut_ref(&mut self) -> &'self mut T { get_mut_ref(self) }\n+    fn get_mut_ref(&mut self) -> &'self mut T { get_mut_ref(self) }\n \n     /**\n      * Gets the value out of an option without copying.\n@@ -430,7 +430,7 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `none`\n      */\n     #[inline(always)]\n-    pure fn unwrap(self) -> T { unwrap(self) }\n+    fn unwrap(self) -> T { unwrap(self) }\n \n     /**\n      * The option dance. Moves a value out of an option type and returns it,\n@@ -452,7 +452,7 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `none`\n      */\n     #[inline(always)]\n-    pure fn expect(self, reason: &str) -> T { expect(self, reason) }\n+    fn expect(self, reason: &str) -> T { expect(self, reason) }\n }\n \n pub impl<T:Copy> Option<T> {\n@@ -471,21 +471,21 @@ pub impl<T:Copy> Option<T> {\n     case explicitly.\n     */\n     #[inline(always)]\n-    pure fn get(self) -> T { get(self) }\n+    fn get(self) -> T { get(self) }\n \n     #[inline(always)]\n-    pure fn get_or_default(self, def: T) -> T { get_or_default(self, def) }\n+    fn get_or_default(self, def: T) -> T { get_or_default(self, def) }\n \n     /// Applies a function zero or more times until the result is none.\n     #[inline(always)]\n-    pure fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n+    fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         while_some(self, blk)\n     }\n }\n \n pub impl<T:Copy + Zero> Option<T> {\n     #[inline(always)]\n-    pure fn get_or_zero(self) -> T { get_or_zero(self) }\n+    fn get_or_zero(self) -> T { get_or_zero(self) }\n }\n \n #[test]"}, {"sha": "c483ec79e21d99e71a114daeb0330c36b319b2f9", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,20 +15,20 @@\n #[cfg(notest)]\n impl<T:Eq> Eq for ~T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for ~T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "5181c08bba0fce2782c6ff016ad1cef5c70c46a0", "filename": "src/libcore/path.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -28,7 +28,7 @@ pub struct WindowsPath {\n     components: ~[~str],\n }\n \n-pub pure fn WindowsPath(s: &str) -> WindowsPath {\n+pub fn WindowsPath(s: &str) -> WindowsPath {\n     GenericPath::from_str(s)\n }\n \n@@ -38,50 +38,50 @@ pub struct PosixPath {\n     components: ~[~str],\n }\n \n-pub pure fn PosixPath(s: &str) -> PosixPath {\n+pub fn PosixPath(s: &str) -> PosixPath {\n     GenericPath::from_str(s)\n }\n \n pub trait GenericPath {\n-    static pure fn from_str(&str) -> Self;\n+    fn from_str(&str) -> Self;\n \n-    pure fn dirname(&self) -> ~str;\n-    pure fn filename(&self) -> Option<~str>;\n-    pure fn filestem(&self) -> Option<~str>;\n-    pure fn filetype(&self) -> Option<~str>;\n+    fn dirname(&self) -> ~str;\n+    fn filename(&self) -> Option<~str>;\n+    fn filestem(&self) -> Option<~str>;\n+    fn filetype(&self) -> Option<~str>;\n \n-    pure fn with_dirname(&self, (&str)) -> Self;\n-    pure fn with_filename(&self, (&str)) -> Self;\n-    pure fn with_filestem(&self, (&str)) -> Self;\n-    pure fn with_filetype(&self, (&str)) -> Self;\n+    fn with_dirname(&self, (&str)) -> Self;\n+    fn with_filename(&self, (&str)) -> Self;\n+    fn with_filestem(&self, (&str)) -> Self;\n+    fn with_filetype(&self, (&str)) -> Self;\n \n-    pure fn dir_path(&self) -> Self;\n-    pure fn file_path(&self) -> Self;\n+    fn dir_path(&self) -> Self;\n+    fn file_path(&self) -> Self;\n \n-    pure fn push(&self, (&str)) -> Self;\n-    pure fn push_rel(&self, (&Self)) -> Self;\n-    pure fn push_many(&self, (&[~str])) -> Self;\n-    pure fn pop(&self) -> Self;\n+    fn push(&self, (&str)) -> Self;\n+    fn push_rel(&self, (&Self)) -> Self;\n+    fn push_many(&self, (&[~str])) -> Self;\n+    fn pop(&self) -> Self;\n \n-    pure fn unsafe_join(&self, (&Self)) -> Self;\n-    pure fn is_restricted(&self) -> bool;\n+    fn unsafe_join(&self, (&Self)) -> Self;\n+    fn is_restricted(&self) -> bool;\n \n-    pure fn normalize(&self) -> Self;\n+    fn normalize(&self) -> Self;\n }\n \n #[cfg(windows)]\n pub type Path = WindowsPath;\n \n #[cfg(windows)]\n-pub pure fn Path(s: &str) -> Path {\n+pub fn Path(s: &str) -> Path {\n     WindowsPath(s)\n }\n \n #[cfg(unix)]\n pub type Path = PosixPath;\n \n #[cfg(unix)]\n-pub pure fn Path(s: &str) -> Path {\n+pub fn Path(s: &str) -> Path {\n     PosixPath(s)\n }\n \n@@ -367,7 +367,7 @@ pub impl Path {\n }\n \n impl ToStr for PosixPath {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         if self.is_absolute {\n             s += \"/\";\n@@ -380,14 +380,14 @@ impl ToStr for PosixPath {\n // PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n \n-    static pure fn from_str(s: &str) -> PosixPath {\n+    fn from_str(s: &str) -> PosixPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n                            components: components }\n     }\n \n-    pure fn dirname(&self) -> ~str {\n+    fn dirname(&self) -> ~str {\n         unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n@@ -398,14 +398,14 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn filename(&self) -> Option<~str> {\n+    fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n           0 => None,\n           n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem(&self) -> Option<~str> {\n+    fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -417,7 +417,7 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn filetype(&self) -> Option<~str> {\n+    fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -429,29 +429,29 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn with_dirname(&self, d: &str) -> PosixPath {\n+    fn with_dirname(&self, d: &str) -> PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n           None => dpath\n         }\n     }\n \n-    pure fn with_filename(&self, f: &str) -> PosixPath {\n+    fn with_filename(&self, f: &str) -> PosixPath {\n         unsafe {\n             fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n             self.dir_path().push(f)\n         }\n     }\n \n-    pure fn with_filestem(&self, s: &str) -> PosixPath {\n+    fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n           None => self.with_filename(s),\n           Some(ref t) => self.with_filename(str::from_slice(s) + *t)\n         }\n     }\n \n-    pure fn with_filetype(&self, t: &str) -> PosixPath {\n+    fn with_filetype(&self, t: &str) -> PosixPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               None => copy *self,\n@@ -466,15 +466,15 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn dir_path(&self) -> PosixPath {\n+    fn dir_path(&self) -> PosixPath {\n         if self.components.len() != 0 {\n             self.pop()\n         } else {\n             copy *self\n         }\n     }\n \n-    pure fn file_path(&self) -> PosixPath {\n+    fn file_path(&self) -> PosixPath {\n         let cs = match self.filename() {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n@@ -483,12 +483,12 @@ impl GenericPath for PosixPath {\n                            components: cs }\n     }\n \n-    pure fn push_rel(&self, other: &PosixPath) -> PosixPath {\n+    fn push_rel(&self, other: &PosixPath) -> PosixPath {\n         fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n-    pure fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n+    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n         if other.is_absolute {\n             PosixPath { is_absolute: true,\n                         components: copy other.components }\n@@ -497,11 +497,11 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn is_restricted(&self) -> bool {\n+    fn is_restricted(&self) -> bool {\n         false\n     }\n \n-    pure fn push_many(&self, cs: &[~str]) -> PosixPath {\n+    fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(\n@@ -513,14 +513,14 @@ impl GenericPath for PosixPath {\n                     components: v }\n     }\n \n-    pure fn push(&self, s: &str) -> PosixPath {\n+    fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n         unsafe { v.push_all_move(ss); }\n         PosixPath { components: v, ..copy *self }\n     }\n \n-    pure fn pop(&self) -> PosixPath {\n+    fn pop(&self) -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n@@ -532,7 +532,7 @@ impl GenericPath for PosixPath {\n                           //..self }\n     }\n \n-    pure fn normalize(&self) -> PosixPath {\n+    fn normalize(&self) -> PosixPath {\n         return PosixPath {\n             is_absolute: self.is_absolute,\n             components: normalize(self.components)\n@@ -543,7 +543,7 @@ impl GenericPath for PosixPath {\n \n \n impl ToStr for WindowsPath {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n           Some(ref h) => { s += \"\\\\\\\\\"; s += *h; }\n@@ -563,7 +563,7 @@ impl ToStr for WindowsPath {\n \n impl GenericPath for WindowsPath {\n \n-    static pure fn from_str(s: &str) -> WindowsPath {\n+    fn from_str(s: &str) -> WindowsPath {\n         let host;\n         let device;\n         let rest;\n@@ -599,7 +599,7 @@ impl GenericPath for WindowsPath {\n                              components: components }\n     }\n \n-    pure fn dirname(&self) -> ~str {\n+    fn dirname(&self) -> ~str {\n         unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n@@ -610,14 +610,14 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn filename(&self) -> Option<~str> {\n+    fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n           0 => None,\n           n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem(&self) -> Option<~str> {\n+    fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -629,7 +629,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn filetype(&self) -> Option<~str> {\n+    fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -641,27 +641,27 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn with_dirname(&self, d: &str) -> WindowsPath {\n+    fn with_dirname(&self, d: &str) -> WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n           None => dpath\n         }\n     }\n \n-    pure fn with_filename(&self, f: &str) -> WindowsPath {\n+    fn with_filename(&self, f: &str) -> WindowsPath {\n         fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n         self.dir_path().push(f)\n     }\n \n-    pure fn with_filestem(&self, s: &str) -> WindowsPath {\n+    fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n           None => self.with_filename(s),\n           Some(ref t) => self.with_filename(str::from_slice(s) + *t)\n         }\n     }\n \n-    pure fn with_filetype(&self, t: &str) -> WindowsPath {\n+    fn with_filetype(&self, t: &str) -> WindowsPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               None => copy *self,\n@@ -677,15 +677,15 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn dir_path(&self) -> WindowsPath {\n+    fn dir_path(&self) -> WindowsPath {\n         if self.components.len() != 0 {\n             self.pop()\n         } else {\n             copy *self\n         }\n     }\n \n-    pure fn file_path(&self) -> WindowsPath {\n+    fn file_path(&self) -> WindowsPath {\n         let cs = match self.filename() {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n@@ -696,12 +696,12 @@ impl GenericPath for WindowsPath {\n                              components: cs }\n     }\n \n-    pure fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n+    fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n         fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n-    pure fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n+    fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n         /* rhs not absolute is simple push */\n         if !other.is_absolute {\n             return self.push_many(other.components);\n@@ -743,7 +743,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn is_restricted(&self) -> bool {\n+    fn is_restricted(&self) -> bool {\n         match self.filestem() {\n             Some(stem) => {\n                 match stem.to_lower() {\n@@ -756,7 +756,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn push_many(&self, cs: &[~str]) -> WindowsPath {\n+    fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(\n@@ -773,14 +773,14 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn push(&self, s: &str) -> WindowsPath {\n+    fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n         unsafe { v.push_all_move(ss); }\n         return WindowsPath { components: v, ..copy *self }\n     }\n \n-    pure fn pop(&self) -> WindowsPath {\n+    fn pop(&self) -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n@@ -793,7 +793,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn normalize(&self) -> WindowsPath {\n+    fn normalize(&self) -> WindowsPath {\n         return WindowsPath {\n             host: copy self.host,\n             device: match self.device {\n@@ -807,7 +807,7 @@ impl GenericPath for WindowsPath {\n }\n \n \n-pub pure fn normalize(components: &[~str]) -> ~[~str] {\n+pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n     unsafe {\n         for components.each |c| {\n@@ -831,11 +831,11 @@ pub mod windows {\n     use option::{None, Option, Some};\n \n     #[inline(always)]\n-    pub pure fn is_sep(u: u8) -> bool {\n+    pub fn is_sep(u: u8) -> bool {\n         u == '/' as u8 || u == '\\\\' as u8\n     }\n \n-    pub pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n+    pub fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n         if (s.len() > 1 &&\n             (s[0] == '\\\\' as u8 || s[0] == '/' as u8) &&\n             s[0] == s[1]) {\n@@ -852,7 +852,7 @@ pub mod windows {\n         None\n     }\n \n-    pub pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n+    pub fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n         unsafe {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&"}, {"sha": "710f2c51ee8c73dbae149d5225fb5db06016a4d3", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -111,10 +111,10 @@ enum State {\n }\n \n impl Eq for State {\n-    pure fn eq(&self, other: &State) -> bool {\n+    fn eq(&self, other: &State) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n }\n \n pub struct BufferHeader {\n@@ -551,7 +551,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pub pure fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pub fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty | Terminated => false,\n       Blocked => fail!(~\"peeking on blocked packet\"),\n@@ -723,11 +723,11 @@ pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n \n #[doc(hidden)]\n pub trait Selectable {\n-    pure fn header(&self) -> *PacketHeader;\n+    fn header(&self) -> *PacketHeader;\n }\n \n impl Selectable for *PacketHeader {\n-    pure fn header(&self) -> *PacketHeader { *self }\n+    fn header(&self) -> *PacketHeader { *self }\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n@@ -812,7 +812,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         option::unwrap(p)\n     }\n \n-    pure fn header(&self) -> *PacketHeader {\n+    fn header(&self) -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n@@ -879,7 +879,7 @@ pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n }\n \n impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n-    pure fn header(&self) -> *PacketHeader {\n+    fn header(&self) -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;"}, {"sha": "fa96467cb0f674642c6cf969b7024166b67e1918", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -51,27 +51,27 @@ pub mod rusti {\n \n /// Get an unsafe pointer to a value\n #[inline(always)]\n-pub pure fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n+pub fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n \n /// Calculate the offset from a pointer\n #[inline(always)]\n-pub pure fn offset<T>(ptr: *T, count: uint) -> *T {\n+pub fn offset<T>(ptr: *T, count: uint) -> *T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a const pointer\n #[inline(always)]\n-pub pure fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n+pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a mut pointer\n #[inline(always)]\n-pub pure fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n+pub fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n@@ -93,19 +93,19 @@ pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n \n /// Create an unsafe null pointer\n #[inline(always)]\n-pub pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Create an unsafe mutable null pointer\n #[inline(always)]\n-pub pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Returns true if the pointer is equal to the null pointer.\n #[inline(always)]\n-pub pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n+pub fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n #[inline(always)]\n-pub pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n+pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n  * Copies data from one location to another\n@@ -138,7 +138,7 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub pure fn to_unsafe_ptr<T>(thing: &T) -> *T {\n+pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -148,7 +148,7 @@ pub pure fn to_unsafe_ptr<T>(thing: &T) -> *T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub pure fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n+pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -158,7 +158,7 @@ pub pure fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n+pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -170,15 +170,15 @@ pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   (I couldn't think of a cutesy name for this one.)\n */\n #[inline(always)]\n-pub pure fn to_uint<T>(thing: &T) -> uint {\n+pub fn to_uint<T>(thing: &T) -> uint {\n     unsafe {\n         cast::reinterpret_cast(&thing)\n     }\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-pub pure fn ref_eq<T>(thing: &'a T, other: &'b T) -> bool {\n+pub fn ref_eq<T>(thing: &'a T, other: &'b T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n@@ -223,85 +223,85 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n }\n \n pub trait Ptr<T> {\n-    pure fn is_null(&const self) -> bool;\n-    pure fn is_not_null(&const self) -> bool;\n-    pure fn offset(&self, count: uint) -> Self;\n+    fn is_null(&const self) -> bool;\n+    fn is_not_null(&const self) -> bool;\n+    fn offset(&self, count: uint) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> Ptr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a pointer.\n     #[inline(always)]\n-    pure fn offset(&self, count: uint) -> *T { offset(*self, count) }\n+    fn offset(&self, count: uint) -> *T { offset(*self, count) }\n }\n \n /// Extension methods for mutable pointers\n impl<T> Ptr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a mutable pointer.\n     #[inline(always)]\n-    pure fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n+    fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n }\n \n // Equality for pointers\n #[cfg(notest)]\n impl<T> Eq for *const T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &*const T) -> bool {\n+    fn eq(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a == b;\n         }\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n }\n \n // Comparison for pointers\n #[cfg(notest)]\n impl<T> Ord for *const T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &*const T) -> bool {\n+    fn lt(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a < b;\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &*const T) -> bool {\n+    fn le(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a <= b;\n         }\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &*const T) -> bool {\n+    fn ge(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a >= b;\n         }\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &*const T) -> bool {\n+    fn gt(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n@@ -314,11 +314,11 @@ impl<T> Ord for *const T {\n #[cfg(notest)]\n impl<T:Eq> Eq for &'self const T {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &'self const T) -> bool {\n+    fn eq(&self, other: & &'self const T) -> bool {\n         return *(*self) == *(*other);\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &'self const T) -> bool {\n+    fn ne(&self, other: & &'self const T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n@@ -327,19 +327,19 @@ impl<T:Eq> Eq for &'self const T {\n #[cfg(notest)]\n impl<T:Ord> Ord for &'self const T {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &'self const T) -> bool {\n+    fn lt(&self, other: & &'self const T) -> bool {\n         *(*self) < *(*other)\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: & &'self const T) -> bool {\n+    fn le(&self, other: & &'self const T) -> bool {\n         *(*self) <= *(*other)\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &'self const T) -> bool {\n+    fn ge(&self, other: & &'self const T) -> bool {\n         *(*self) >= *(*other)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &'self const T) -> bool {\n+    fn gt(&self, other: & &'self const T) -> bool {\n         *(*self) > *(*other)\n     }\n }"}, {"sha": "fbdda02dcdc78e9ecbfe9b004ee1327fc860d427", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,95 +22,95 @@ use libc::size_t;\n \n /// A type that can be randomly generated using an RNG\n pub trait Rand {\n-    static fn rand(rng: @rand::Rng) -> Self;\n+    fn rand(rng: @rand::Rng) -> Self;\n }\n \n impl Rand for int {\n-    static fn rand(rng: @rand::Rng) -> int {\n+    fn rand(rng: @rand::Rng) -> int {\n         rng.gen_int()\n     }\n }\n \n impl Rand for i8 {\n-    static fn rand(rng: @rand::Rng) -> i8 {\n+    fn rand(rng: @rand::Rng) -> i8 {\n         rng.gen_i8()\n     }\n }\n \n impl Rand for i16 {\n-    static fn rand(rng: @rand::Rng) -> i16 {\n+    fn rand(rng: @rand::Rng) -> i16 {\n         rng.gen_i16()\n     }\n }\n \n impl Rand for i32 {\n-    static fn rand(rng: @rand::Rng) -> i32 {\n+    fn rand(rng: @rand::Rng) -> i32 {\n         rng.gen_i32()\n     }\n }\n \n impl Rand for i64 {\n-    static fn rand(rng: @rand::Rng) -> i64 {\n+    fn rand(rng: @rand::Rng) -> i64 {\n         rng.gen_i64()\n     }\n }\n \n impl Rand for u8 {\n-    static fn rand(rng: @rand::Rng) -> u8 {\n+    fn rand(rng: @rand::Rng) -> u8 {\n         rng.gen_u8()\n     }\n }\n \n impl Rand for u16 {\n-    static fn rand(rng: @rand::Rng) -> u16 {\n+    fn rand(rng: @rand::Rng) -> u16 {\n         rng.gen_u16()\n     }\n }\n \n impl Rand for u32 {\n-    static fn rand(rng: @rand::Rng) -> u32 {\n+    fn rand(rng: @rand::Rng) -> u32 {\n         rng.gen_u32()\n     }\n }\n \n impl Rand for u64 {\n-    static fn rand(rng: @rand::Rng) -> u64 {\n+    fn rand(rng: @rand::Rng) -> u64 {\n         rng.gen_u64()\n     }\n }\n \n impl Rand for float {\n-    static fn rand(rng: @rand::Rng) -> float {\n+    fn rand(rng: @rand::Rng) -> float {\n         rng.gen_float()\n     }\n }\n \n impl Rand for f32 {\n-    static fn rand(rng: @rand::Rng) -> f32 {\n+    fn rand(rng: @rand::Rng) -> f32 {\n         rng.gen_f32()\n     }\n }\n \n impl Rand for f64 {\n-    static fn rand(rng: @rand::Rng) -> f64 {\n+    fn rand(rng: @rand::Rng) -> f64 {\n         rng.gen_f64()\n     }\n }\n \n impl Rand for char {\n-    static fn rand(rng: @rand::Rng) -> char {\n+    fn rand(rng: @rand::Rng) -> char {\n         rng.gen_char()\n     }\n }\n \n impl Rand for bool {\n-    static fn rand(rng: @rand::Rng) -> bool {\n+    fn rand(rng: @rand::Rng) -> bool {\n         rng.gen_bool()\n     }\n }\n \n impl<T:Rand> Rand for Option<T> {\n-    static fn rand(rng: @rand::Rng) -> Option<T> {\n+    fn rand(rng: @rand::Rng) -> Option<T> {\n         if rng.gen_bool() {\n             Some(Rand::rand(rng))\n         } else {\n@@ -527,12 +527,12 @@ impl Rng for XorShiftState {\n     }\n }\n \n-pub pure fn xorshift() -> @Rng {\n+pub fn xorshift() -> @Rng {\n     // constants taken from http://en.wikipedia.org/wiki/Xorshift\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n \n-pub pure fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n+pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n     @XorShiftState { x: x, y: y, z: z, w: w } as @Rng\n }\n "}, {"sha": "5dd2eaf5533d4cd78b732f527a6a6d781a3f2b48", "filename": "src/libcore/result.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -36,7 +36,7 @@ pub enum Result<T, U> {\n  * If the result is an error\n  */\n #[inline(always)]\n-pub pure fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n+pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n       Err(ref the_err) => unsafe {\n@@ -53,7 +53,7 @@ pub pure fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n  * If the result is an error\n  */\n #[inline(always)]\n-pub pure fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n+pub fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n         Err(ref the_err) => unsafe {\n@@ -70,7 +70,7 @@ pub pure fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n  * If the result is not an error\n  */\n #[inline(always)]\n-pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n+pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(copy u) => u,\n       Ok(_) => fail!(~\"get_err called on ok result\")\n@@ -79,7 +79,7 @@ pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n \n /// Returns true if the result is `ok`\n #[inline(always)]\n-pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n+pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n     match *res {\n       Ok(_) => true,\n       Err(_) => false\n@@ -88,7 +88,7 @@ pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n \n /// Returns true if the result is `err`\n #[inline(always)]\n-pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n+pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n \n@@ -99,7 +99,7 @@ pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * result variants are converted to `either::left`.\n  */\n #[inline(always)]\n-pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n+pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n       Ok(copy res) => either::Right(res),\n@@ -122,7 +122,7 @@ pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n  *     }\n  */\n #[inline(always)]\n-pub pure fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n+pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match res {\n         Ok(t) => op(t),\n@@ -139,7 +139,7 @@ pub pure fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn chain_err<T, U, V>(\n+pub fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: &fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n@@ -164,7 +164,7 @@ pub pure fn chain_err<T, U, V>(\n  *     }\n  */\n #[inline(always)]\n-pub pure fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n+pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -180,7 +180,7 @@ pub pure fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n  * handling an error.\n  */\n #[inline(always)]\n-pub pure fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n+pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -202,7 +202,7 @@ pub pure fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n  *     }\n  */\n #[inline(always)]\n-pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n+pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -219,7 +219,7 @@ pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n+pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -229,53 +229,53 @@ pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n \n pub impl<T, E> Result<T, E> {\n     #[inline(always)]\n-    pure fn get_ref(&self) -> &'self T { get_ref(self) }\n+    fn get_ref(&self) -> &'self T { get_ref(self) }\n \n     #[inline(always)]\n-    pure fn is_ok(&self) -> bool { is_ok(self) }\n+    fn is_ok(&self) -> bool { is_ok(self) }\n \n     #[inline(always)]\n-    pure fn is_err(&self) -> bool { is_err(self) }\n+    fn is_err(&self) -> bool { is_err(self) }\n \n     #[inline(always)]\n-    pure fn iter(&self, f: &fn(&T)) { iter(self, f) }\n+    fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n     #[inline(always)]\n-    pure fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n+    fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n     #[inline(always)]\n-    pure fn unwrap(self) -> T { unwrap(self) }\n+    fn unwrap(self) -> T { unwrap(self) }\n \n     #[inline(always)]\n-    pure fn unwrap_err(self) -> E { unwrap_err(self) }\n+    fn unwrap_err(self) -> E { unwrap_err(self) }\n \n     #[inline(always)]\n-    pure fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n+    fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n     #[inline(always)]\n-    pure fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n+    fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n \n pub impl<T:Copy,E> Result<T, E> {\n     #[inline(always)]\n-    pure fn get(&self) -> T { get(self) }\n+    fn get(&self) -> T { get(self) }\n \n     #[inline(always)]\n-    pure fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n+    fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n \n pub impl<T, E: Copy> Result<T, E> {\n     #[inline(always)]\n-    pure fn get_err(&self) -> E { get_err(self) }\n+    fn get_err(&self) -> E { get_err(self) }\n \n     #[inline(always)]\n-    pure fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n+    fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n }\n@@ -375,7 +375,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n \n /// Unwraps a result, assuming it is an `ok(T)`\n #[inline(always)]\n-pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n+pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match res {\n       Ok(t) => t,\n       Err(_) => fail!(~\"unwrap called on an err result\")\n@@ -384,7 +384,7 @@ pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n \n /// Unwraps a result, assuming it is an `err(U)`\n #[inline(always)]\n-pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n+pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match res {\n       Err(u) => u,\n       Ok(_) => fail!(~\"unwrap called on an ok result\")"}, {"sha": "4150366dacfa32f1142d68acf91b55575c7d117a", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -19,14 +19,14 @@ use cast::{transmute, transmute_mut_unsafe,\n pub struct Context(~Registers);\n \n pub impl Context {\n-    static fn empty() -> Context {\n+    fn empty() -> Context {\n         Context(new_regs())\n     }\n \n     /// Create a new context that will resume execution by running ~fn()\n     /// # Safety Note\n     /// The `start` closure must remain valid for the life of the Task\n-    static fn new(start: &~fn(), stack: &mut StackSegment) -> Context {\n+    fn new(start: &~fn(), stack: &mut StackSegment) -> Context {\n \n         // The C-ABI function that is the task entry point\n         extern fn task_start_wrapper(f: &~fn()) { (*f)() }\n@@ -49,7 +49,7 @@ pub impl Context {\n         return Context(regs);\n     }\n \n-    static fn swap(out_context: &mut Context, in_context: &Context) {\n+    fn swap(out_context: &mut Context, in_context: &Context) {\n         let out_regs: &mut Registers = match out_context {\n             &Context(~ref mut r) => r\n         };\n@@ -184,7 +184,7 @@ fn align_down(sp: *mut uint) -> *mut uint {\n \n // XXX: ptr::offset is positive ints only\n #[inline(always)]\n-pub pure fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n     unsafe {\n         (ptr as int + count * (size_of::<T>() as int)) as *mut T"}, {"sha": "4a140458fd341911b85826330fec50319879a082", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -50,11 +50,11 @@ pub struct Scheduler {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait HackAroundBorrowCk {\n-    static fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n+    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n     fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n }\n impl HackAroundBorrowCk for UnsafeTaskReceiver {\n-    static fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n+    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n         unsafe { transmute(f) }\n     }\n     fn to_fn(self) -> &fn(&mut Scheduler, ~Task) {\n@@ -70,7 +70,7 @@ enum CleanupJob {\n \n pub impl Scheduler {\n \n-    static pub fn new(event_loop: ~EventLoopObject) -> Scheduler {\n+    pub fn new(event_loop: ~EventLoopObject) -> Scheduler {\n         Scheduler {\n             event_loop: event_loop,\n             task_queue: WorkQueue::new(),\n@@ -114,7 +114,7 @@ pub impl Scheduler {\n         return tlsched.take_scheduler();\n     }\n \n-    static fn local(f: &fn(&mut Scheduler)) {\n+    fn local(f: &fn(&mut Scheduler)) {\n         let mut tlsched = ThreadLocalScheduler::new();\n         f(tlsched.get_scheduler());\n     }\n@@ -296,7 +296,7 @@ pub struct Task {\n }\n \n impl Task {\n-    static pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+    pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n         // XXX: Putting main into a ~ so it's a thin pointer and can\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n@@ -337,7 +337,7 @@ impl Task {\n struct ThreadLocalScheduler(tls::Key);\n \n impl ThreadLocalScheduler {\n-    static fn new() -> ThreadLocalScheduler {\n+    fn new() -> ThreadLocalScheduler {\n         unsafe {\n             // NB: This assumes that the TLS key has been created prior.\n             // Currently done in rust_start."}, {"sha": "9b164eb08fa7c8437420b70da892387ef323d46b", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,7 +15,7 @@ pub struct StackSegment {\n }\n \n pub impl StackSegment {\n-    static fn new(size: uint) -> StackSegment {\n+    fn new(size: uint) -> StackSegment {\n         // Crate a block of uninitialized values\n         let mut stack = vec::with_capacity(size);\n         unsafe {\n@@ -37,7 +37,7 @@ pub impl StackSegment {\n pub struct StackPool(());\n \n impl StackPool {\n-    static pub fn new() -> StackPool { StackPool(()) }\n+    pub fn new() -> StackPool { StackPool(()) }\n \n     fn take_segment(&self, min_size: uint) -> StackSegment {\n         StackSegment::new(min_size)"}, {"sha": "c45e4295ab144d5209d02c5a96cd3f8d844f02ad", "filename": "src/libcore/rt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -20,7 +20,7 @@ struct Thread {\n }\n \n impl Thread {\n-    static pub fn start(main: ~fn()) -> Thread {\n+    pub fn start(main: ~fn()) -> Thread {\n         fn substart(main: &fn()) -> *raw_thread {\n             unsafe { rust_raw_thread_start(&main) }\n         }"}, {"sha": "4d87bdb02e81a4dbe4fa255478459544f50f1831", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -74,7 +74,7 @@ impl Callback for NullCallback { }\n \n /// A type that wraps a native handle\n trait NativeHandle<T> {\n-    static pub fn from_native_handle(T) -> Self;\n+    pub fn from_native_handle(T) -> Self;\n     pub fn native_handle(&self) -> T;\n }\n \n@@ -86,7 +86,7 @@ pub struct Loop {\n }\n \n pub impl Loop {\n-    static fn new() -> Loop {\n+    fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n         fail_unless!(handle.is_not_null());\n         NativeHandle::from_native_handle(handle)\n@@ -102,7 +102,7 @@ pub impl Loop {\n }\n \n impl NativeHandle<*uvll::uv_loop_t> for Loop {\n-    static fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n+    fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n         Loop { handle: handle }\n     }\n     fn native_handle(&self) -> *uvll::uv_loop_t {\n@@ -132,7 +132,7 @@ type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n impl Callback for IdleCallback { }\n \n pub impl IdleWatcher {\n-    static fn new(loop_: &mut Loop) -> IdleWatcher {\n+    fn new(loop_: &mut Loop) -> IdleWatcher {\n         unsafe {\n             let handle = uvll::idle_new();\n             fail_unless!(handle.is_not_null());\n@@ -177,7 +177,7 @@ pub impl IdleWatcher {\n }\n \n impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    static fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n         IdleWatcher(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_idle_t {\n@@ -307,7 +307,7 @@ pub impl StreamWatcher {\n }\n \n impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n-    static fn from_native_handle(\n+    fn from_native_handle(\n         handle: *uvll::uv_stream_t) -> StreamWatcher {\n         StreamWatcher(handle)\n     }\n@@ -328,7 +328,7 @@ type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n impl Callback for ConnectionCallback { }\n \n pub impl TcpWatcher {\n-    static fn new(loop_: &mut Loop) -> TcpWatcher {\n+    fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n             let size = size_of::<uvll::uv_tcp_t>() as size_t;\n             let handle = malloc(size) as *uvll::uv_tcp_t;\n@@ -421,7 +421,7 @@ pub impl TcpWatcher {\n }\n \n impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n-    static fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n+    fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n         TcpWatcher(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_tcp_t {\n@@ -441,7 +441,7 @@ impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n \n-    static fn new() -> ConnectRequest {\n+    fn new() -> ConnectRequest {\n         let connect_handle = unsafe {\n             malloc(size_of::<uvll::uv_connect_t>() as size_t)\n         };\n@@ -465,7 +465,7 @@ impl ConnectRequest {\n }\n \n impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n-    static fn from_native_handle(\n+    fn from_native_handle(\n         handle: *uvll:: uv_connect_t) -> ConnectRequest {\n         ConnectRequest(handle)\n     }\n@@ -480,7 +480,7 @@ impl Request for WriteRequest { }\n \n impl WriteRequest {\n \n-    static fn new() -> WriteRequest {\n+    fn new() -> WriteRequest {\n         let write_handle = unsafe {\n             malloc(size_of::<uvll::uv_write_t>() as size_t)\n         };\n@@ -503,7 +503,7 @@ impl WriteRequest {\n }\n \n impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n-    static fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n+    fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n         WriteRequest(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_write_t {\n@@ -518,7 +518,7 @@ struct UvError(uvll::uv_err_t);\n \n impl UvError {\n \n-    pure fn name(&self) -> ~str {\n+    fn name(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let name_str = uvll::err_name(inner);\n@@ -527,7 +527,7 @@ impl UvError {\n         }\n     }\n \n-    pure fn desc(&self) -> ~str {\n+    fn desc(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let desc_str = uvll::strerror(inner);\n@@ -538,7 +538,7 @@ impl UvError {\n }\n \n impl ToStr for UvError {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"%s: %s\", self.name(), self.desc())\n     }\n }"}, {"sha": "58a4a65ca90c4768a6dcf04c3b7c9e228d49e6e1", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -29,14 +29,14 @@ pub struct UvEventLoop {\n }\n \n pub impl UvEventLoop {\n-    static fn new() -> UvEventLoop {\n+    fn new() -> UvEventLoop {\n         UvEventLoop {\n             uvio: UvIoFactory(Loop::new())\n         }\n     }\n \n     /// A convenience constructor\n-    static fn new_scheduler() -> Scheduler {\n+    fn new_scheduler() -> Scheduler {\n         Scheduler::new(~UvEventLoop::new())\n     }\n }\n@@ -221,7 +221,7 @@ impl TcpListener for UvTcpListener {\n pub struct UvStream(StreamWatcher);\n \n impl UvStream {\n-    static fn new(watcher: StreamWatcher) -> UvStream {\n+    fn new(watcher: StreamWatcher) -> UvStream {\n         UvStream(watcher)\n     }\n "}, {"sha": "dfa88b783c59f7647e2fda7d15f224fe094eb04b", "filename": "src/libcore/rt/work_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fwork_queue.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,7 +15,7 @@ pub struct WorkQueue<T> {\n }\n \n pub impl<T> WorkQueue<T> {\n-    static fn new() -> WorkQueue<T> {\n+    fn new() -> WorkQueue<T> {\n         WorkQueue {\n             queue: ~[]\n         }"}, {"sha": "fc4d1e387dd86a75ac7a162fdd9f30d48e8ef880", "filename": "src/libcore/str.rs", "status": "modified", "additions": 217, "deletions": 217, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -44,27 +44,27 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n+pub fn from_bytes(vv: &[const u8]) -> ~str {\n     fail_unless!(is_utf8(vv));\n     return unsafe { raw::from_bytes(vv) };\n }\n \n /// Copy a slice into a new unique str\n-pub pure fn from_slice(s: &str) -> ~str {\n+pub fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_unique(s, 0, len(s)) }\n }\n \n impl ToStr for ~str {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { copy *self }\n+    fn to_str(&self) -> ~str { copy *self }\n }\n impl ToStr for &'self str {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n impl ToStr for @str {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n \n /**\n@@ -74,7 +74,7 @@ impl ToStr for @str {\n  *\n  * Fails if invalid UTF-8\n  */\n-pub pure fn from_byte(b: u8) -> ~str {\n+pub fn from_byte(b: u8) -> ~str {\n     fail_unless!(b < 128u8);\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n@@ -151,14 +151,14 @@ pub fn push_char(s: &mut ~str, ch: char) {\n }\n \n /// Convert a char to a string\n-pub pure fn from_char(ch: char) -> ~str {\n+pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { push_char(&mut buf, ch); }\n     buf\n }\n \n /// Convert a vector of chars to a string\n-pub pure fn from_chars(chs: &[char]) -> ~str {\n+pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, chs.len());\n@@ -206,7 +206,7 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n \n /// Concatenate two strings together\n #[inline(always)]\n-pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n+pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v = lhs;\n     unsafe {\n         push_str_no_overallocate(&mut v, rhs);\n@@ -216,7 +216,7 @@ pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n \n \n /// Concatenate a vector of strings\n-pub pure fn concat(v: &[~str]) -> ~str {\n+pub fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n         unsafe { push_str(&mut s, *ss) };\n@@ -225,7 +225,7 @@ pub pure fn concat(v: &[~str]) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n+pub fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n@@ -235,7 +235,7 @@ pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pub pure fn connect_slices(v: &[&str], sep: &str) -> ~str {\n+pub fn connect_slices(v: &[&str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n@@ -245,7 +245,7 @@ pub pure fn connect_slices(v: &[&str], sep: &str) -> ~str {\n }\n \n /// Given a string, make a new string with repeated copies of it\n-pub pure fn repeat(ss: &str, nn: uint) -> ~str {\n+pub fn repeat(ss: &str, nn: uint) -> ~str {\n     let mut acc = ~\"\";\n     for nn.times { acc += ss; }\n     acc\n@@ -313,7 +313,7 @@ pub fn unshift_char(s: &mut ~str, ch: char) {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+pub fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     if chars_to_trim.is_empty() { return s; }\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n@@ -331,7 +331,7 @@ pub pure fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+pub fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     if chars_to_trim.is_empty() { return s; }\n \n     match rfind(s, |c| !chars_to_trim.contains(&c)) {\n@@ -352,20 +352,20 @@ pub pure fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+pub fn trim_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     trim_left_chars(trim_right_chars(s, chars_to_trim), chars_to_trim)\n }\n \n /// Returns a string with leading whitespace removed\n-pub pure fn trim_left(s: &'a str) -> &'a str {\n+pub fn trim_left(s: &'a str) -> &'a str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => \"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n-pub pure fn trim_right(s: &'a str) -> &'a str {\n+pub fn trim_right(s: &'a str) -> &'a str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n       None => \"\",\n       Some(last) => {\n@@ -376,7 +376,7 @@ pub pure fn trim_right(s: &'a str) -> &'a str {\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pub pure fn trim(s: &'a str) -> &'a str { trim_left(trim_right(s)) }\n+pub fn trim(s: &'a str) -> &'a str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -387,7 +387,7 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pub pure fn to_bytes(s: &str) -> ~[u8] {\n+pub fn to_bytes(s: &str) -> ~[u8] {\n     unsafe {\n         let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n         vec::raw::set_len(&mut v, len(s));\n@@ -397,14 +397,14 @@ pub pure fn to_bytes(s: &str) -> ~[u8] {\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pub pure fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n+pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n         unsafe { vec::raw::buf_as_slice(p, n-1u, f) }\n     }\n }\n \n /// Convert a string to a vector of characters\n-pub pure fn chars(s: &str) -> ~[char] {\n+pub fn chars(s: &str) -> ~[char] {\n     let mut buf = ~[], i = 0;\n     let len = len(s);\n     while i < len {\n@@ -421,7 +421,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * Returns a string containing `n` characters starting at byte offset\n  * `begin`.\n  */\n-pub pure fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n+pub fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -431,15 +431,15 @@ pub pure fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pub pure fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n+pub fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given\n /// character.\n-pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n+pub fn split_char(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true, true)\n }\n \n@@ -449,25 +449,25 @@ pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n-pub pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n+pub fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n     split_char_inner(s, sep, count, true, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n-pub pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n+pub fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), false, false)\n }\n \n /**\n  * Like `split_char`, but a trailing empty string is omitted\n  * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n  */\n-pub pure fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n+pub fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true, false)\n }\n \n-pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n-                         allow_trailing_empty: bool) -> ~[~str] {\n+fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n+                    allow_trailing_empty: bool) -> ~[~str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = ~[], done = 0u;\n@@ -496,23 +496,23 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n \n \n /// Splits a string into substrings using a character function\n-pub pure fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+pub fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true, true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub pure fn splitn(s: &str,\n+pub fn splitn(s: &str,\n                    sepfn: &fn(char) -> bool,\n                    count: uint)\n                 -> ~[~str] {\n     split_inner(s, sepfn, count, true, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+pub fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false, false)\n }\n \n@@ -521,11 +521,11 @@ pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n  * Like `split`, but a trailing empty string is omitted\n  * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n  */\n-pub pure fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+pub fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true, false)\n }\n \n-pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n+fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n                allow_empty: bool, allow_trailing_empty: bool) -> ~[~str] {\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n@@ -551,7 +551,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -578,7 +578,7 @@ pure fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     let mut last_end = 0u;\n     do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n@@ -596,15 +596,15 @@ pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n  * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n  * ~~~\n  */\n-pub pure fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n+pub fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n     }\n     result\n }\n \n-pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n+pub fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n@@ -651,15 +651,15 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n').\n  */\n-pub pure fn lines(s: &str) -> ~[~str] {\n+pub fn lines(s: &str) -> ~[~str] {\n     split_char_no_trailing(s, '\\n')\n }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pub pure fn lines_any(s: &str) -> ~[~str] {\n+pub fn lines_any(s: &str) -> ~[~str] {\n     vec::map(lines(s), |s| {\n         let l = len(*s);\n         let mut cp = copy *s;\n@@ -671,7 +671,7 @@ pub pure fn lines_any(s: &str) -> ~[~str] {\n }\n \n /// Splits a string into a vector of the substrings separated by whitespace\n-pub pure fn words(s: &str) -> ~[~str] {\n+pub fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, char::is_whitespace)\n }\n \n@@ -710,14 +710,14 @@ pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n \n \n /// Convert a string to lowercase. ASCII only\n-pub pure fn to_lower(s: &str) -> ~str {\n+pub fn to_lower(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n /// Convert a string to uppercase. ASCII only\n-pub pure fn to_upper(s: &str) -> ~str {\n+pub fn to_upper(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::toupper(c as libc::c_char)) as char}\n     )\n@@ -736,7 +736,7 @@ pub pure fn to_upper(s: &str) -> ~str {\n  *\n  * The original string with all occurances of `from` replaced with `to`\n  */\n-pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n+pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first {\n@@ -756,7 +756,7 @@ Section: Comparing strings\n /// Bytewise slice equality\n #[cfg(notest)]\n #[lang=\"str_eq\"]\n-pub pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -772,7 +772,7 @@ pub pure fn eq_slice(a: &str, b: &str) -> bool {\n }\n \n #[cfg(test)]\n-pub pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -790,16 +790,16 @@ pub pure fn eq_slice(a: &str, b: &str) -> bool {\n /// Bytewise string equality\n #[cfg(notest)]\n #[lang=\"uniq_str_eq\"]\n-pub pure fn eq(a: &~str, b: &~str) -> bool {\n+pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n #[cfg(test)]\n-pub pure fn eq(a: &~str, b: &~str) -> bool {\n+pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n-pure fn cmp(a: &str, b: &str) -> Ordering {\n+fn cmp(a: &str, b: &str) -> Ordering {\n     let low = uint::min(a.len(), b.len());\n \n     for uint::range(0, low) |idx| {\n@@ -815,21 +815,21 @@ pure fn cmp(a: &str, b: &str) -> Ordering {\n \n #[cfg(notest)]\n impl TotalOrd for &'self str {\n-    pure fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl TotalOrd for ~str {\n-    pure fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl TotalOrd for @str {\n-    pure fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n }\n \n /// Bytewise slice less than\n-pure fn lt(a: &str, b: &str) -> bool {\n+fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n \n@@ -845,90 +845,90 @@ pure fn lt(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise less than or equal\n-pub pure fn le(a: &str, b: &str) -> bool {\n+pub fn le(a: &str, b: &str) -> bool {\n     !lt(b, a)\n }\n \n /// Bytewise greater than or equal\n-pure fn ge(a: &str, b: &str) -> bool {\n+fn ge(a: &str, b: &str) -> bool {\n     !lt(a, b)\n }\n \n /// Bytewise greater than\n-pure fn gt(a: &str, b: &str) -> bool {\n+fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n \n #[cfg(notest)]\n impl Eq for &'self str {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &'self str) -> bool {\n+    fn eq(&self, other: & &'self str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl Eq for ~str {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~str) -> bool {\n+    fn eq(&self, other: &~str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl Eq for @str {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@str) -> bool {\n+    fn eq(&self, other: &@str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl Ord for ~str {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl Ord for &'self str {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl Ord for @str {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl Equiv<~str> for &'self str {\n     #[inline(always)]\n-    pure fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n+    fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n }\n \n /*\n@@ -939,20 +939,20 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pub pure fn all(s: &str, it: &fn(char) -> bool) -> bool {\n+pub fn all(s: &str, it: &fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pub pure fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n+pub fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n+pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n@@ -965,13 +965,13 @@ pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n+pub fn each(s: &str, it: &fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b))\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n+pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = 0;\n     let len = s.len();\n \n@@ -983,13 +983,13 @@ pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n \n /// Iterate over the bytes in a string in reverse\n #[inline(always)]\n-pub pure fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n+pub fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n     eachi_reverse(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n-pub pure fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n+pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = s.len();\n     while pos > 0 {\n         pos -= 1;\n@@ -999,13 +999,13 @@ pub pure fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pub pure fn each_char(s: &str, it: &fn(char) -> bool) {\n+pub fn each_char(s: &str, it: &fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n+pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = 0;\n     let mut ch_pos = 0u;\n     let len = s.len();\n@@ -1019,7 +1019,7 @@ pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n \n /// Iterates over the chars in a string in reverse\n #[inline(always)]\n-pub pure fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n+pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n     let mut pos = 0;\n     let len = s.char_len();\n     while pos > 0 {\n@@ -1031,7 +1031,7 @@ pub pure fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n \n // Iterates over the chars in a string in reverse, with indices\n #[inline(always)]\n-pub pure fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n+pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n     let mut ch_pos = s.char_len();\n     for s.each_char_reverse |ch| {\n         ch_pos -= 1;\n@@ -1040,28 +1040,28 @@ pub pure fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pub pure fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n+pub fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pub pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n+pub fn splitn_char_each(ss: &str, sep: char, count: uint,\n                          ff: &fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pub pure fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n+pub fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pub pure fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n+pub fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n }\n \n@@ -1082,7 +1082,7 @@ Section: Searching\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pub pure fn find_char(s: &str, c: char) -> Option<uint> {\n+pub fn find_char(s: &str, c: char) -> Option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -1106,7 +1106,7 @@ pub pure fn find_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -1131,7 +1131,7 @@ pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n+pub fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         fail_unless!(start <= end);\n@@ -1161,7 +1161,7 @@ pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pub pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n+pub fn rfind_char(s: &str, c: char) -> Option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -1185,7 +1185,7 @@ pub pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -1210,7 +1210,7 @@ pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n+pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         fail_unless!(start >= end);\n@@ -1241,7 +1241,7 @@ pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pub pure fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n+pub fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1265,7 +1265,7 @@ pub pure fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_from(s: &str, start: uint, f: &fn(char)\n+pub fn find_from(s: &str, start: uint, f: &fn(char)\n     -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1292,7 +1292,7 @@ pub pure fn find_from(s: &str, start: uint, f: &fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_between(s: &str,\n+pub fn find_between(s: &str,\n                          start: uint,\n                          end: uint,\n                          f: &fn(char) -> bool)\n@@ -1323,7 +1323,7 @@ pub pure fn find_between(s: &str,\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pub pure fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n+pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1347,7 +1347,7 @@ pub pure fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pub pure fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n+pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n     -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1374,7 +1374,7 @@ pub pure fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pub pure fn rfind_between(s: &str, start: uint, end: uint,\n+pub fn rfind_between(s: &str, start: uint, end: uint,\n                           f: &fn(char) -> bool)\n     -> Option<uint> {\n     fail_unless!(start >= end);\n@@ -1390,7 +1390,7 @@ pub pure fn rfind_between(s: &str, start: uint, end: uint,\n }\n \n // Utility used by various searching functions\n-pure fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n+fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) |c| { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n@@ -1409,7 +1409,7 @@ pure fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pub pure fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n+pub fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1432,7 +1432,7 @@ pub pure fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pub pure fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n+pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n   -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1457,7 +1457,7 @@ pub pure fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pub pure fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n+pub fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n@@ -1483,7 +1483,7 @@ pub pure fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn contains(haystack: &'a str, needle: &'b str) -> bool {\n+pub fn contains(haystack: &'a str, needle: &'b str) -> bool {\n     find_str(haystack, needle).is_some()\n }\n \n@@ -1495,7 +1495,7 @@ pub pure fn contains(haystack: &'a str, needle: &'b str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The char to look for\n  */\n-pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n+pub fn contains_char(haystack: &str, needle: char) -> bool {\n     find_char(haystack, needle).is_some()\n }\n \n@@ -1507,7 +1507,7 @@ pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n+pub fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1522,7 +1522,7 @@ pub pure fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn ends_with(haystack: &'a str, needle: &'b str) -> bool {\n+pub fn ends_with(haystack: &'a str, needle: &'b str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1534,21 +1534,21 @@ Section: String properties\n */\n \n /// Determines if a string contains only ASCII characters\n-pub pure fn is_ascii(s: &str) -> bool {\n+pub fn is_ascii(s: &str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { return false; } }\n     return true;\n }\n \n /// Returns true if the string has length 0\n-pub pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n+pub fn is_empty(s: &str) -> bool { len(s) == 0u }\n \n /**\n  * Returns true if the string contains only whitespace\n  *\n  * Whitespace characters are determined by `char::is_whitespace`\n  */\n-pub pure fn is_whitespace(s: &str) -> bool {\n+pub fn is_whitespace(s: &str) -> bool {\n     return all(s, char::is_whitespace);\n }\n \n@@ -1557,24 +1557,24 @@ pub pure fn is_whitespace(s: &str) -> bool {\n  *\n  * Alphanumeric characters are determined by `char::is_alphanumeric`\n  */\n-pure fn is_alphanumeric(s: &str) -> bool {\n+fn is_alphanumeric(s: &str) -> bool {\n     return all(s, char::is_alphanumeric);\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n-pub pure fn len(s: &str) -> uint {\n+pub fn len(s: &str) -> uint {\n     do as_buf(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n-pub pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n+pub fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pub pure fn is_utf8(v: &[const u8]) -> bool {\n+pub fn is_utf8(v: &[const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1592,7 +1592,7 @@ pub pure fn is_utf8(v: &[const u8]) -> bool {\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n-pub pure fn is_utf16(v: &[u16]) -> bool {\n+pub fn is_utf16(v: &[u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1613,7 +1613,7 @@ pub pure fn is_utf16(v: &[u16]) -> bool {\n }\n \n /// Converts to a vector of `u16` encoded as UTF-16\n-pub pure fn to_utf16(s: &str) -> ~[u16] {\n+pub fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n     for s.each_char |ch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1638,7 +1638,7 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n     u\n }\n \n-pub pure fn utf16_chars(v: &[u16], f: &fn(char)) {\n+pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1663,7 +1663,7 @@ pub pure fn utf16_chars(v: &[u16], f: &fn(char)) {\n }\n \n \n-pub pure fn from_utf16(v: &[u16]) -> ~str {\n+pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, vec::len(v));\n@@ -1672,7 +1672,7 @@ pub pure fn from_utf16(v: &[u16]) -> ~str {\n     buf\n }\n \n-pub pure fn with_capacity(capacity: uint) -> ~str {\n+pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { reserve(&mut buf, capacity); }\n     buf\n@@ -1691,7 +1691,7 @@ pub pure fn with_capacity(capacity: uint) -> ~str {\n  *\n  * The number of Unicode characters in `s` between the given indices.\n  */\n-pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n+pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     fail_unless!(is_char_boundary(s, start));\n     fail_unless!(is_char_boundary(s, end));\n     let mut i = start, len = 0u;\n@@ -1704,7 +1704,7 @@ pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-pub pure fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n+pub fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n     fail_unless!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1718,7 +1718,7 @@ pub pure fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n }\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n-pub pure fn utf8_char_width(b: u8) -> uint {\n+pub fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { return 1u; }\n     // Not a valid start byte\n@@ -1734,7 +1734,7 @@ pub pure fn utf8_char_width(b: u8) -> uint {\n  * Returns false if the index points into the middle of a multi-byte\n  * character sequence.\n  */\n-pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n+pub fn is_char_boundary(s: &str, index: uint) -> bool {\n     if index == len(s) { return true; }\n     let b = s[index];\n     return b < 128u8 || b >= 192u8;\n@@ -1789,7 +1789,7 @@ pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * If `i` is greater than or equal to the length of the string.\n  * If `i` is not the index of the beginning of a valid UTF-8 character.\n  */\n-pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n+pub fn char_range_at(s: &str, i: uint) -> CharRange {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     fail_unless!((w != 0u));\n@@ -1812,7 +1812,7 @@ pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n }\n \n /// Plucks the `n`th character from the beginning of a string\n-pub pure fn char_at(s: &str, i: uint) -> char {\n+pub fn char_at(s: &str, i: uint) -> char {\n     return char_range_at(s, i).ch;\n }\n \n@@ -1826,7 +1826,7 @@ pub struct CharRange {\n  *\n  * This function can be used to iterate over a unicode string in reverse.\n  */\n-pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n+fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n     let mut prev = start;\n \n     // while there is a previous byte == 10......\n@@ -1842,7 +1842,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n }\n \n /// Plucks the `n`th character from the end of a string\n-pub pure fn char_at_reverse(s: &str, i: uint) -> char {\n+pub fn char_at_reverse(s: &str, i: uint) -> char {\n     char_range_at_reverse(s, i).ch\n }\n \n@@ -1868,7 +1868,7 @@ pub pure fn char_at_reverse(s: &str, i: uint) -> char {\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub pure fn all_between(s: &str, start: uint, end: uint,\n+pub fn all_between(s: &str, start: uint, end: uint,\n                     it: &fn(char) -> bool) -> bool {\n     fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n@@ -1901,7 +1901,7 @@ pub pure fn all_between(s: &str, start: uint, end: uint,\n  *\n  * `true` if `it` returns `true` for any character\n  */\n-pub pure fn any_between(s: &str, start: uint, end: uint,\n+pub fn any_between(s: &str, start: uint, end: uint,\n                     it: &fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n@@ -1940,7 +1940,7 @@ pub const nan_buf: [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n+pub fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n         f(&*v)\n@@ -1952,7 +1952,7 @@ pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n  *\n  * The byte slice does not include the null terminator.\n  */\n-pub pure fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n+pub fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n     unsafe {\n         let (ptr, len): (*u8, uint) = ::cast::reinterpret_cast(&s);\n         let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n@@ -1975,7 +1975,7 @@ pub pure fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pub pure fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n+pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n         fail_unless!(len > 0);\n@@ -1997,7 +1997,7 @@ pub pure fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pub pure fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n+pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(&s));\n         let (buf,len) = *v;\n@@ -2056,7 +2056,7 @@ pub fn reserve_at_least(s: &mut ~str, n: uint) {\n  * Returns the number of single-byte characters the string can hold without\n  * reallocating\n  */\n-pub pure fn capacity(s: &const ~str) -> uint {\n+pub fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         fail_unless!(vcap > 0u);\n@@ -2065,7 +2065,7 @@ pub pure fn capacity(s: &const ~str) -> uint {\n }\n \n /// Escape each char in `s` with char::escape_default.\n-pub pure fn escape_default(s: &str) -> ~str {\n+pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -2077,7 +2077,7 @@ pub pure fn escape_default(s: &str) -> ~str {\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n-pub pure fn escape_unicode(s: &str) -> ~str {\n+pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -2263,7 +2263,7 @@ pub mod traits {\n \n     impl Add<&'self str,~str> for ~str {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &'self str) -> ~str {\n+        fn add(&self, rhs: & &'self str) -> ~str {\n             append(copy *self, (*rhs))\n         }\n     }\n@@ -2273,44 +2273,44 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    pure fn all(&self, it: &fn(char) -> bool) -> bool;\n-    pure fn any(&self, it: &fn(char) -> bool) -> bool;\n-    pure fn contains(&self, needle: &'a str) -> bool;\n-    pure fn contains_char(&self, needle: char) -> bool;\n-    pure fn each(&self, it: &fn(u8) -> bool);\n-    pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n-    pure fn each_reverse(&self, it: &fn(u8) -> bool);\n-    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n-    pure fn each_char(&self, it: &fn(char) -> bool);\n-    pure fn each_chari(&self, it: &fn(uint, char) -> bool);\n-    pure fn each_char_reverse(&self, it: &fn(char) -> bool);\n-    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n-    pure fn ends_with(&self, needle: &str) -> bool;\n-    pure fn is_empty(&self) -> bool;\n-    pure fn is_whitespace(&self) -> bool;\n-    pure fn is_alphanumeric(&self) -> bool;\n-    pure fn len(&self) -> uint;\n-    pure fn char_len(&self) -> uint;\n-    pure fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n-    pure fn split_char(&self, sep: char) -> ~[~str];\n-    pure fn split_str(&self, sep: &'a str) -> ~[~str];\n-    pure fn starts_with(&self, needle: &'a str) -> bool;\n-    pure fn substr(&self, begin: uint, n: uint) -> &'self str;\n-    pure fn to_lower(&self) -> ~str;\n-    pure fn to_upper(&self) -> ~str;\n-    pure fn escape_default(&self) -> ~str;\n-    pure fn escape_unicode(&self) -> ~str;\n-    pure fn trim(&self) -> &'self str;\n-    pure fn trim_left(&self) -> &'self str;\n-    pure fn trim_right(&self) -> &'self str;\n-    pure fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    pure fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    pure fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    pure fn to_owned(&self) -> ~str;\n-    pure fn to_managed(&self) -> @str;\n-    pure fn char_at(&self, i: uint) -> char;\n-    pure fn char_at_reverse(&self, i: uint) -> char;\n+    fn all(&self, it: &fn(char) -> bool) -> bool;\n+    fn any(&self, it: &fn(char) -> bool) -> bool;\n+    fn contains(&self, needle: &'a str) -> bool;\n+    fn contains_char(&self, needle: char) -> bool;\n+    fn each(&self, it: &fn(u8) -> bool);\n+    fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    fn each_reverse(&self, it: &fn(u8) -> bool);\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n+    fn each_char(&self, it: &fn(char) -> bool);\n+    fn each_chari(&self, it: &fn(uint, char) -> bool);\n+    fn each_char_reverse(&self, it: &fn(char) -> bool);\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n+    fn ends_with(&self, needle: &str) -> bool;\n+    fn is_empty(&self) -> bool;\n+    fn is_whitespace(&self) -> bool;\n+    fn is_alphanumeric(&self) -> bool;\n+    fn len(&self) -> uint;\n+    fn char_len(&self) -> uint;\n+    fn slice(&self, begin: uint, end: uint) -> &'self str;\n+    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n+    fn split_char(&self, sep: char) -> ~[~str];\n+    fn split_str(&self, sep: &'a str) -> ~[~str];\n+    fn starts_with(&self, needle: &'a str) -> bool;\n+    fn substr(&self, begin: uint, n: uint) -> &'self str;\n+    fn to_lower(&self) -> ~str;\n+    fn to_upper(&self) -> ~str;\n+    fn escape_default(&self) -> ~str;\n+    fn escape_unicode(&self) -> ~str;\n+    fn trim(&self) -> &'self str;\n+    fn trim_left(&self) -> &'self str;\n+    fn trim_right(&self) -> &'self str;\n+    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn to_owned(&self) -> ~str;\n+    fn to_managed(&self) -> @str;\n+    fn char_at(&self, i: uint) -> char;\n+    fn char_at_reverse(&self, i: uint) -> char;\n     fn to_bytes(&self) -> ~[u8];\n }\n \n@@ -2321,86 +2321,86 @@ impl StrSlice for &'self str {\n      * contains no characters\n      */\n     #[inline]\n-    pure fn all(&self, it: &fn(char) -> bool) -> bool { all(*self, it) }\n+    fn all(&self, it: &fn(char) -> bool) -> bool { all(*self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    pure fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n+    fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    pure fn contains(&self, needle: &'a str) -> bool {\n+    fn contains(&self, needle: &'a str) -> bool {\n         contains(*self, needle)\n     }\n     /// Returns true if a string contains a char\n     #[inline]\n-    pure fn contains_char(&self, needle: char) -> bool {\n+    fn contains_char(&self, needle: char) -> bool {\n         contains_char(*self, needle)\n     }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n+    fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n+    fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each_reverse(&self, it: &fn(u8) -> bool) {\n+    fn each_reverse(&self, it: &fn(u8) -> bool) {\n         each_reverse(*self, it)\n     }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n         eachi_reverse(*self, it)\n     }\n     /// Iterate over the chars in a string\n     #[inline]\n-    pure fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n+    fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    pure fn each_chari(&self, it: &fn(uint, char) -> bool) {\n+    fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n     /// Iterate over the chars in a string in reverse\n     #[inline]\n-    pure fn each_char_reverse(&self, it: &fn(char) -> bool) {\n+    fn each_char_reverse(&self, it: &fn(char) -> bool) {\n         each_char_reverse(*self, it)\n     }\n     /// Iterate over the chars in a string in reverse, with indices from the\n     /// end\n     #[inline]\n-    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n         each_chari_reverse(*self, it)\n     }\n     /// Returns true if one string ends with another\n     #[inline]\n-    pure fn ends_with(&self, needle: &str) -> bool {\n+    fn ends_with(&self, needle: &str) -> bool {\n         ends_with(*self, needle)\n     }\n     /// Returns true if the string has length 0\n     #[inline]\n-    pure fn is_empty(&self) -> bool { is_empty(*self) }\n+    fn is_empty(&self) -> bool { is_empty(*self) }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n      * Whitespace characters are determined by `char::is_whitespace`\n      */\n     #[inline]\n-    pure fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n     /**\n      * Returns true if the string contains only alphanumerics\n      *\n      * Alphanumeric characters are determined by `char::is_alphanumeric`\n      */\n     #[inline]\n-    pure fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n     /// Returns the size in bytes not counting the null terminator\n     #[inline]\n-    pure fn len(&self) -> uint { len(*self) }\n+    fn len(&self) -> uint { len(*self) }\n     /// Returns the number of characters that a string holds\n     #[inline]\n-    pure fn char_len(&self) -> uint { char_len(*self) }\n+    fn char_len(&self) -> uint { char_len(*self) }\n     /**\n      * Returns a slice of the given string from the byte range\n      * [`begin`..`end`)\n@@ -2409,28 +2409,28 @@ impl StrSlice for &'self str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice(&self, begin: uint, end: uint) -> &'self str {\n+    fn slice(&self, begin: uint, end: uint) -> &'self str {\n         slice(*self, begin, end)\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n+    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n         split(*self, sepfn)\n     }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    pure fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n+    fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    pure fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n+    fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    pure fn starts_with(&self, needle: &'a str) -> bool {\n+    fn starts_with(&self, needle: &'a str) -> bool {\n         starts_with(*self, needle)\n     }\n     /**\n@@ -2440,62 +2440,62 @@ impl StrSlice for &'self str {\n      * `begin`.\n      */\n     #[inline]\n-    pure fn substr(&self, begin: uint, n: uint) -> &'self str {\n+    fn substr(&self, begin: uint, n: uint) -> &'self str {\n         substr(*self, begin, n)\n     }\n     /// Convert a string to lowercase\n     #[inline]\n-    pure fn to_lower(&self) -> ~str { to_lower(*self) }\n+    fn to_lower(&self) -> ~str { to_lower(*self) }\n     /// Convert a string to uppercase\n     #[inline]\n-    pure fn to_upper(&self) -> ~str { to_upper(*self) }\n+    fn to_upper(&self) -> ~str { to_upper(*self) }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n-    pure fn escape_default(&self) -> ~str { escape_default(*self) }\n+    fn escape_default(&self) -> ~str { escape_default(*self) }\n     /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n-    pure fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n+    fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    pure fn trim(&self) -> &'self str { trim(*self) }\n+    fn trim(&self) -> &'self str { trim(*self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    pure fn trim_left(&self) -> &'self str { trim_left(*self) }\n+    fn trim_left(&self) -> &'self str { trim_left(*self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    pure fn trim_right(&self) -> &'self str { trim_right(*self) }\n+    fn trim_right(&self) -> &'self str { trim_right(*self) }\n \n     #[inline]\n-    pure fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n         trim_chars(*self, chars_to_trim)\n     }\n     #[inline]\n-    pure fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n         trim_left_chars(*self, chars_to_trim)\n     }\n     #[inline]\n-    pure fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n         trim_right_chars(*self, chars_to_trim)\n     }\n \n \n     #[inline]\n-    pure fn to_owned(&self) -> ~str { from_slice(*self) }\n+    fn to_owned(&self) -> ~str { from_slice(*self) }\n \n     #[inline]\n-    pure fn to_managed(&self) -> @str {\n+    fn to_managed(&self) -> @str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n             if i == self.len() { 0 } else { self[i] }\n         });\n         unsafe { ::cast::transmute(v) }\n     }\n \n     #[inline]\n-    pure fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n+    fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n \n     #[inline]\n-    pure fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: uint) -> char {\n         char_at_reverse(*self, i)\n     }\n "}, {"sha": "706cb10dba9f774c2e405f615eb9f7e8259f60ca", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -60,15 +60,15 @@ pub mod rustrt {\n \n /// Compares contents of two pointers using the default method.\n /// Equivalent to `*x1 == *x2`.  Useful for hashtables.\n-pub pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n+pub fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n     *x1 == *x2\n }\n \n-pub pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 < *x2\n }\n \n-pub pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 <= *x2\n }\n \n@@ -79,13 +79,13 @@ pub pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n  * performing dark magick.\n  */\n #[inline(always)]\n-pub pure fn get_type_desc<T>() -> *TypeDesc {\n+pub fn get_type_desc<T>() -> *TypeDesc {\n     unsafe { rusti::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns the size of a type\n #[inline(always)]\n-pub pure fn size_of<T>() -> uint {\n+pub fn size_of<T>() -> uint {\n     unsafe { rusti::size_of::<T>() }\n }\n \n@@ -95,7 +95,7 @@ pub pure fn size_of<T>() -> uint {\n  * Useful for building structures containing variable-length arrays.\n  */\n #[inline(always)]\n-pub pure fn nonzero_size_of<T>() -> uint {\n+pub fn nonzero_size_of<T>() -> uint {\n     let s = size_of::<T>();\n     if s == 0 { 1 } else { s }\n }\n@@ -107,26 +107,26 @@ pub pure fn nonzero_size_of<T>() -> uint {\n  * than the preferred alignment.\n  */\n #[inline(always)]\n-pub pure fn min_align_of<T>() -> uint {\n+pub fn min_align_of<T>() -> uint {\n     unsafe { rusti::min_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of a type\n #[inline(always)]\n-pub pure fn pref_align_of<T>() -> uint {\n+pub fn pref_align_of<T>() -> uint {\n     unsafe { rusti::pref_align_of::<T>() }\n }\n \n /// Returns the refcount of a shared box (as just before calling this)\n #[inline(always)]\n-pub pure fn refcount<T>(t: @T) -> uint {\n+pub fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::reinterpret_cast(&t);\n         *ref_ptr - 1\n     }\n }\n \n-pub pure fn log_str<T>(t: &T) -> ~str {\n+pub fn log_str<T>(t: &T) -> ~str {\n     unsafe {\n         do io::with_str_writer |wr| {\n             repr::write_repr(wr, t)\n@@ -135,7 +135,7 @@ pub pure fn log_str<T>(t: &T) -> ~str {\n }\n \n /** Initiate task failure */\n-pub pure fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n+pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n     do str::as_buf(msg) |msg_buf, _msg_len| {\n         do str::as_buf(file) |file_buf, _file_len| {\n             unsafe {\n@@ -148,15 +148,15 @@ pub pure fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n }\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n-pub pure fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     unsafe {\n         gc::cleanup_stack_for_failure();\n         rustrt::rust_upcall_fail(msg, file, line);\n         cast::transmute(())\n     }\n }\n \n-pub pure fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n+pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n     unsafe {\n         let (msg, file) = (msg.to_owned(), file.to_owned());\n         begin_unwind(~\"assertion failed: \" + msg, file, line)"}, {"sha": "59f4942b3a4a7396c40771f63e7698e389e40abe", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,14 +24,14 @@ pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }\n \n impl Eq for @LocalData {\n-    pure fn eq(&self, other: &@LocalData) -> bool {\n+    fn eq(&self, other: &@LocalData) -> bool {\n         unsafe {\n             let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n             let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n             return ptr_a == ptr_b;\n         }\n     }\n-    pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n \n // If TLS is used heavily in future, this could be made more efficient with a"}, {"sha": "a38b44afb513fe77d596ea75c063fad9499227df", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -78,13 +78,13 @@ pub enum TaskResult {\n }\n \n impl Eq for TaskResult {\n-    pure fn eq(&self, other: &TaskResult) -> bool {\n+    fn eq(&self, other: &TaskResult) -> bool {\n         match ((*self), (*other)) {\n             (Success, Success) | (Failure, Failure) => true,\n             (Success, _) | (Failure, _) => false\n         }\n     }\n-    pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n }\n \n /// Scheduler modes"}, {"sha": "b97a682c4e5caf1d1715e231a113a6f4643b57f4", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -126,7 +126,7 @@ type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n type TaskGroupInner = &'self mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n+fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&const tg.members).is_empty()\n }\n "}, {"sha": "f379878c8eb0bee3dbbf964a284cbd3a1868a879", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -43,12 +43,12 @@ pub trait IterBytes {\n      * left-to-right in declaration order, regardless of\n      * underlying memory endianness.\n      */\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb);\n+    fn iter_bytes(&self, lsb0: bool, f: Cb);\n }\n \n impl IterBytes for bool {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         f([\n             *self as u8\n         ]);\n@@ -57,7 +57,7 @@ impl IterBytes for bool {\n \n impl IterBytes for u8 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         f([\n             *self\n         ]);\n@@ -66,7 +66,7 @@ impl IterBytes for u8 {\n \n impl IterBytes for u16 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 *self as u8,\n@@ -83,7 +83,7 @@ impl IterBytes for u16 {\n \n impl IterBytes for u32 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 *self as u8,\n@@ -104,7 +104,7 @@ impl IterBytes for u32 {\n \n impl IterBytes for u64 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 *self as u8,\n@@ -133,35 +133,35 @@ impl IterBytes for u64 {\n \n impl IterBytes for i8 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i16 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i32 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i64 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for char {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n@@ -172,7 +172,7 @@ pub mod x32 {\n \n     impl IterBytes for uint {\n         #[inline(always)]\n-        pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n             (*self as u32).iter_bytes(lsb0, f)\n         }\n     }\n@@ -184,22 +184,22 @@ pub mod x64 {\n \n     impl IterBytes for uint {\n         #[inline(always)]\n-        pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n             (*self as u64).iter_bytes(lsb0, f)\n         }\n     }\n }\n \n impl IterBytes for int {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for &'self [A] {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         for (*self).each |elt| {\n             do elt.iter_bytes(lsb0) |bytes| {\n                 f(bytes)\n@@ -210,7 +210,7 @@ impl<A:IterBytes> IterBytes for &'self [A] {\n \n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline(always)]\n-  pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) {\n     match *self {\n       (ref a, ref b) => {\n         iter_bytes_2(a, b, lsb0, f);\n@@ -221,7 +221,7 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n \n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   #[inline(always)]\n-  pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) {\n     match *self {\n       (ref a, ref b, ref c) => {\n         iter_bytes_3(a, b, c, lsb0, f);\n@@ -231,33 +231,33 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n }\n \n // Move this to vec, probably.\n-pure fn borrow<A>(a: &'x [A]) -> &'x [A] {\n+fn borrow<A>(a: &'x [A]) -> &'x [A] {\n     a\n }\n \n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n-pub pure fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n+pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_3<A: IterBytes,\n+pub fn iter_bytes_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C,\n                               lsb0: bool, z: Cb) {\n@@ -269,7 +269,7 @@ pub pure fn iter_bytes_3<A: IterBytes,\n     c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_4<A: IterBytes,\n+pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes>(a: &A, b: &B, c: &C,\n@@ -285,7 +285,7 @@ pub pure fn iter_bytes_4<A: IterBytes,\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_5<A: IterBytes,\n+pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -304,7 +304,7 @@ pub pure fn iter_bytes_5<A: IterBytes,\n     e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_6<A: IterBytes,\n+pub fn iter_bytes_6<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -326,7 +326,7 @@ pub pure fn iter_bytes_6<A: IterBytes,\n     f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_7<A: IterBytes,\n+pub fn iter_bytes_7<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -354,7 +354,7 @@ pub pure fn iter_bytes_7<A: IterBytes,\n \n impl IterBytes for &'self str {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n             f(bytes);\n         }\n@@ -363,7 +363,7 @@ impl IterBytes for &'self str {\n \n impl IterBytes for ~str {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n             f(bytes);\n         }\n@@ -372,7 +372,7 @@ impl IterBytes for ~str {\n \n impl IterBytes for @str {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n             f(bytes);\n         }\n@@ -381,7 +381,7 @@ impl IterBytes for @str {\n \n impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         match *self {\n           Some(ref a) => iter_bytes_2(&0u8, a, lsb0, f),\n           None => 1u8.iter_bytes(lsb0, f)\n@@ -391,21 +391,21 @@ impl<A:IterBytes> IterBytes for Option<A> {\n \n impl<A:IterBytes> IterBytes for &'self A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A:IterBytes> IterBytes for @A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A:IterBytes> IterBytes for ~A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n@@ -414,7 +414,7 @@ impl<A:IterBytes> IterBytes for ~A {\n // to the target; it just gives you the pointer-bytes.\n impl<A> IterBytes for *const A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "576f794483d20f69d3e35e67c7af8a4c41af36ad", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,23 +17,23 @@ The `ToStr` trait for converting to strings\n use str;\n \n pub trait ToStr {\n-    pure fn to_str(&self) -> ~str;\n+    fn to_str(&self) -> ~str;\n }\n \n impl ToStr for bool {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::bool::to_str(*self) }\n+    fn to_str(&self) -> ~str { ::bool::to_str(*self) }\n }\n impl ToStr for () {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ~\"()\" }\n+    fn to_str(&self) -> ~str { ~\"()\" }\n }\n \n // FIXME #4898: impl for one-tuples\n \n impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // FIXME(#4760): this causes an llvm assertion\n         //let &(ref a, ref b) = self;\n         match *self {\n@@ -45,7 +45,7 @@ impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n }\n impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // FIXME(#4760): this causes an llvm assertion\n         //let &(ref a, ref b, ref c) = self;\n         match *self {\n@@ -62,7 +62,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n \n impl<A:ToStr> ToStr for &'self [A] {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         unsafe {\n             // FIXME #4568\n             // Bleh -- not really unsafe\n@@ -83,7 +83,7 @@ impl<A:ToStr> ToStr for &'self [A] {\n \n impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         unsafe {\n             // FIXME #4568\n             // Bleh -- not really unsafe\n@@ -104,7 +104,7 @@ impl<A:ToStr> ToStr for ~[A] {\n \n impl<A:ToStr> ToStr for @[A] {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         unsafe {\n             // FIXME #4568\n             // Bleh -- not really unsafe"}, {"sha": "258de5c81db1aa1ffd3b236a435da909e3b8ff21", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -32,29 +32,29 @@ pub struct TrieMap<T> {\n impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(&(uint, &'self T)) -> bool) {\n+    fn each(&self, f: &fn(&(uint, &'self T)) -> bool) {\n         self.root.each(f);\n     }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) {\n+    fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) {\n         self.root.each_reverse(f);\n     }\n }\n \n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n     #[inline(always)]\n-    pure fn len(&const self) -> uint { self.length }\n+    fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n@@ -69,19 +69,19 @@ impl<T> Mutable for TrieMap<T> {\n impl<T> Map<uint, T> for TrieMap<T> {\n     /// Return true if the map contains a value for the specified key\n     #[inline(always)]\n-    pure fn contains_key(&self, key: &uint) -> bool {\n+    fn contains_key(&self, key: &uint) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all keys in order\n     #[inline(always)]\n-    pure fn each_key(&self, f: &fn(&uint) -> bool) {\n+    fn each_key(&self, f: &fn(&uint) -> bool) {\n         self.each(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in order\n     #[inline(always)]\n-    pure fn each_value(&self, f: &fn(&T) -> bool) {\n+    fn each_value(&self, f: &fn(&T) -> bool) {\n         self.each(|&(_, v)| f(v))\n     }\n \n@@ -93,7 +93,7 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Return the value corresponding to the key in the map\n     #[inline(hint)]\n-    pure fn find(&self, key: &uint) -> Option<&'self T> {\n+    fn find(&self, key: &uint) -> Option<&'self T> {\n         let mut node: &'self TrieNode<T> = &self.root;\n         let mut idx = 0;\n         loop {\n@@ -139,19 +139,19 @@ impl<T> Map<uint, T> for TrieMap<T> {\n pub impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n     #[inline(always)]\n-    static pure fn new() -> TrieMap<T> {\n+    fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n     /// Visit all keys in reverse order\n     #[inline(always)]\n-    pure fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n+    fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n         self.each_reverse(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n-    pure fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n+    fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n }\n@@ -162,25 +162,25 @@ pub struct TrieSet {\n \n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n-    pure fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: &fn(&uint) -> bool) {\n+    fn each_reverse(&self, f: &fn(&uint) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl Container for TrieSet {\n     /// Return the number of elements in the set\n     #[inline(always)]\n-    pure fn len(&const self) -> uint { self.map.len() }\n+    fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {\n@@ -192,13 +192,13 @@ impl Mutable for TrieSet {\n impl TrieSet {\n     /// Create an empty TrieSet\n     #[inline(always)]\n-    static pure fn new() -> TrieSet {\n+    fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n     /// Return true if the set contains a value\n     #[inline(always)]\n-    pure fn contains(&self, value: &uint) -> bool {\n+    fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n \n@@ -220,7 +220,7 @@ struct TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     #[inline(always)]\n-    static pure fn new() -> TrieNode<T> {\n+    fn new() -> TrieNode<T> {\n         // FIXME: #5244: [Nothing, ..SIZE] should be possible without Copy\n         TrieNode{count: 0,\n                  children: [Nothing, Nothing, Nothing, Nothing,\n@@ -231,7 +231,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    pure fn each(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n+    fn each(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(f) { return false },\n@@ -242,7 +242,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    pure fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n+    fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n                 Internal(ref x) => if !x.each_reverse(f) { return false },\n@@ -269,7 +269,7 @@ impl<T> TrieNode<T> {\n \n // if this was done via a trait, the key could be generic\n #[inline(always)]\n-pure fn chunk(n: uint, idx: uint) -> uint {\n+fn chunk(n: uint, idx: uint) -> uint {\n     let sh = uint::bits - (SHIFT * (idx + 1));\n     (n >> sh) & MASK\n }"}, {"sha": "fc7834a7514acd1dcfc02baaf8f8d221c26a9b3b", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,50 +16,50 @@ use vec;\n #[cfg(notest)] use cmp::{Eq, Ord};\n \n pub trait CopyableTuple<T, U> {\n-    pure fn first(&self) -> T;\n-    pure fn second(&self) -> U;\n-    pure fn swap(&self) -> (U, T);\n+    fn first(&self) -> T;\n+    fn second(&self) -> U;\n+    fn swap(&self) -> (U, T);\n }\n \n impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n \n     /// Return the first element of self\n     #[inline(always)]\n-    pure fn first(&self) -> T {\n+    fn first(&self) -> T {\n         let (t, _) = *self;\n         return t;\n     }\n \n     /// Return the second element of self\n     #[inline(always)]\n-    pure fn second(&self) -> U {\n+    fn second(&self) -> U {\n         let (_, u) = *self;\n         return u;\n     }\n \n     /// Return the results of swapping the two elements of self\n     #[inline(always)]\n-    pure fn swap(&self) -> (U, T) {\n+    fn swap(&self) -> (U, T) {\n         let (t, u) = *self;\n         return (u, t);\n     }\n \n }\n \n pub trait ImmutableTuple<T, U> {\n-    pure fn first_ref(&self) -> &'self T;\n-    pure fn second_ref(&self) -> &'self U;\n+    fn first_ref(&self) -> &'self T;\n+    fn second_ref(&self) -> &'self U;\n }\n \n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n-    pure fn first_ref(&self) -> &'self T {\n+    fn first_ref(&self) -> &'self T {\n         match *self {\n             (ref t, _) => t,\n         }\n     }\n     #[inline(always)]\n-    pure fn second_ref(&self) -> &'self U {\n+    fn second_ref(&self) -> &'self U {\n         match *self {\n             (_, ref u) => u,\n         }\n@@ -117,7 +117,7 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n #[cfg(notest)]\n impl<A:Eq,B:Eq> Eq for (A, B) {\n     #[inline(always)]\n-    pure fn eq(&self, other: &(A, B)) -> bool {\n+    fn eq(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => match other {\n                 &(ref other_a, ref other_b) => {\n@@ -127,13 +127,13 @@ impl<A:Eq,B:Eq> Eq for (A, B) {\n         }\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<A:Ord,B:Ord> Ord for (A, B) {\n     #[inline(always)]\n-    pure fn lt(&self, other: &(A, B)) -> bool {\n+    fn lt(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => {\n                 match (*other) {\n@@ -148,17 +148,17 @@ impl<A:Ord,B:Ord> Ord for (A, B) {\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n+    fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n+    fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n+    fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n }\n \n #[cfg(notest)]\n impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n     #[inline(always)]\n-    pure fn eq(&self, other: &(A, B, C)) -> bool {\n+    fn eq(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => match other {\n                 &(ref other_a, ref other_b, ref other_c) => {\n@@ -169,13 +169,13 @@ impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n         }\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n     #[inline(always)]\n-    pure fn lt(&self, other: &(A, B, C)) -> bool {\n+    fn lt(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => {\n                 match (*other) {\n@@ -192,11 +192,11 @@ impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n+    fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n+    fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n+    fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n \n #[test]"}, {"sha": "9f2ab66d5c20745f464e9dca9c1d1dcf769084ec", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,15 +11,15 @@\n #[doc(hidden)]; // FIXME #3538\n \n pub mod general_category {\n-    pub pure fn Cc(c: char) -> bool {\n+    pub fn Cc(c: char) -> bool {\n         return match c {\n               '\\x00' .. '\\x1f'\n             | '\\x7f' .. '\\x9f' => true,\n             _ => false\n         };\n     }\n \n-    pub pure fn Cf(c: char) -> bool {\n+    pub fn Cf(c: char) -> bool {\n         return match c {\n               '\\xad'\n             | '\\u0600' .. '\\u0603'\n@@ -38,21 +38,21 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Co(c: char) -> bool {\n+    pub fn Co(c: char) -> bool {\n         return match c {\n           '\\ue000' .. '\\uf8ff' => true,\n           _ => false\n         };\n     }\n \n-    pub pure fn Cs(c: char) -> bool {\n+    pub fn Cs(c: char) -> bool {\n         return match c {\n               '\\ud800' .. '\\udfff' => true,\n             _ => false\n         };\n     }\n \n-    pub pure fn Ll(c: char) -> bool {\n+    pub fn Ll(c: char) -> bool {\n         return match c {\n               '\\x61' .. '\\x7a'\n             | '\\xaa'\n@@ -657,7 +657,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lm(c: char) -> bool {\n+    pub fn Lm(c: char) -> bool {\n         return match c {\n               '\\u02b0' .. '\\u02c1'\n             | '\\u02c6' .. '\\u02d1'\n@@ -713,7 +713,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lo(c: char) -> bool {\n+    pub fn Lo(c: char) -> bool {\n         return match c {\n               '\\u01bb'\n             | '\\u01c0' .. '\\u01c3'\n@@ -899,7 +899,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lt(c: char) -> bool {\n+    pub fn Lt(c: char) -> bool {\n         return match c {\n               '\\u01c5'\n             | '\\u01c8'\n@@ -916,7 +916,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lu(c: char) -> bool {\n+    pub fn Lu(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\xc0' .. '\\xd6'\n@@ -1508,7 +1508,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Mc(c: char) -> bool {\n+    pub fn Mc(c: char) -> bool {\n         return match c {\n               '\\u0903'\n             | '\\u093b'\n@@ -1619,7 +1619,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Me(c: char) -> bool {\n+    pub fn Me(c: char) -> bool {\n         return match c {\n               '\\u0488' .. '\\u0489'\n             | '\\u20dd' .. '\\u20e0'\n@@ -1630,7 +1630,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Mn(c: char) -> bool {\n+    pub fn Mn(c: char) -> bool {\n         return match c {\n               '\\u0300' .. '\\u036f'\n             | '\\u0483' .. '\\u0487'\n@@ -1823,7 +1823,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Nd(c: char) -> bool {\n+    pub fn Nd(c: char) -> bool {\n         return match c {\n               '\\x30' .. '\\x39'\n             | '\\u0660' .. '\\u0669'\n@@ -1867,7 +1867,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Nl(c: char) -> bool {\n+    pub fn Nl(c: char) -> bool {\n         return match c {\n               '\\u16ee' .. '\\u16f0'\n             | '\\u2160' .. '\\u2182'\n@@ -1886,7 +1886,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn No(c: char) -> bool {\n+    pub fn No(c: char) -> bool {\n         return match c {\n               '\\xb2' .. '\\xb3'\n             | '\\xb9'\n@@ -1934,7 +1934,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pc(c: char) -> bool {\n+    pub fn Pc(c: char) -> bool {\n         return match c {\n               '\\x5f'\n             | '\\u203f' .. '\\u2040'\n@@ -1947,7 +1947,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pd(c: char) -> bool {\n+    pub fn Pd(c: char) -> bool {\n         return match c {\n               '\\x2d'\n             | '\\u058a'\n@@ -1969,7 +1969,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pe(c: char) -> bool {\n+    pub fn Pe(c: char) -> bool {\n         return match c {\n               '\\x29'\n             | '\\x5d'\n@@ -2046,7 +2046,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pf(c: char) -> bool {\n+    pub fn Pf(c: char) -> bool {\n         return match c {\n               '\\xbb'\n             | '\\u2019'\n@@ -2063,7 +2063,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pi(c: char) -> bool {\n+    pub fn Pi(c: char) -> bool {\n         return match c {\n               '\\xab'\n             | '\\u2018'\n@@ -2081,7 +2081,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Po(c: char) -> bool {\n+    pub fn Po(c: char) -> bool {\n         return match c {\n               '\\x21' .. '\\x23'\n             | '\\x25' .. '\\x27'\n@@ -2214,7 +2214,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Ps(c: char) -> bool {\n+    pub fn Ps(c: char) -> bool {\n         return match c {\n               '\\x28'\n             | '\\x5b'\n@@ -2293,7 +2293,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Sc(c: char) -> bool {\n+    pub fn Sc(c: char) -> bool {\n         return match c {\n               '\\x24'\n             | '\\xa2' .. '\\xa5'\n@@ -2316,7 +2316,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Sk(c: char) -> bool {\n+    pub fn Sk(c: char) -> bool {\n         return match c {\n               '\\x5e'\n             | '\\x60'\n@@ -2350,7 +2350,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Sm(c: char) -> bool {\n+    pub fn Sm(c: char) -> bool {\n         return match c {\n               '\\x2b'\n             | '\\x3c' .. '\\x3e'\n@@ -2421,7 +2421,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn So(c: char) -> bool {\n+    pub fn So(c: char) -> bool {\n         return match c {\n               '\\xa6' .. '\\xa7'\n             | '\\xa9'\n@@ -2540,21 +2540,21 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Zl(c: char) -> bool {\n+    pub fn Zl(c: char) -> bool {\n         return match c {\n           '\\u2028' => true,\n           _ => false\n         };\n     }\n \n-    pub pure fn Zp(c: char) -> bool {\n+    pub fn Zp(c: char) -> bool {\n         return match c {\n           '\\u2029' => true,\n           _ => false\n         };\n     }\n \n-    pub pure fn Zs(c: char) -> bool {\n+    pub fn Zs(c: char) -> bool {\n         return match c {\n               '\\x20'\n             | '\\xa0'\n@@ -2572,7 +2572,7 @@ pub mod general_category {\n }\n mod derived_property {\n     /// Check if a character has the alphabetic unicode property\n-    pub pure fn Alphabetic(c: char) -> bool {\n+    pub fn Alphabetic(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\x61' .. '\\x7a'\n@@ -3310,7 +3310,7 @@ mod derived_property {\n         };\n     }\n \n-    pub pure fn XID_Continue(c: char) -> bool {\n+    pub fn XID_Continue(c: char) -> bool {\n         return match c {\n               '\\x30' .. '\\x39'\n             | '\\x41' .. '\\x5a'\n@@ -4181,7 +4181,7 @@ mod derived_property {\n         };\n     }\n \n-    pub pure fn XID_Start(c: char) -> bool {\n+    pub fn XID_Start(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\x61' .. '\\x7a'"}, {"sha": "2571dca1c96c73c2f0fd2a3057f8e57d65284478", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -140,7 +140,7 @@ pub mod ct {\n     }\n \n     pub impl<T> Parsed<T> {\n-        static pure fn new(&self, val: T, next: uint) -> Parsed<T> {\n+        fn new(val: T, next: uint) -> Parsed<T> {\n             Parsed {val: val, next: next}\n         }\n     }\n@@ -705,7 +705,7 @@ pub mod rt {\n         ty: Ty,\n     }\n \n-    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n+    pub fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -718,7 +718,7 @@ pub mod rt {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pub fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -730,17 +730,17 @@ pub mod rt {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pub fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pub fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pub fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -753,7 +753,7 @@ pub mod rt {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pub fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str_digits, 6u)\n@@ -768,14 +768,14 @@ pub mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+    pub fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    pub pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+    pub fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         return if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n@@ -784,7 +784,7 @@ pub mod rt {\n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+    pub fn uint_to_str_prec(num: uint, radix: uint,\n                                  prec: uint) -> ~str {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n@@ -798,7 +798,7 @@ pub mod rt {\n                 } else { s }\n             };\n     }\n-    pub pure fn get_int_precision(cv: Conv) -> uint {\n+    pub fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n               CountIs(c) => c as uint,\n               CountImplied => 1u\n@@ -828,7 +828,7 @@ pub mod rt {\n           PadFloat    => (true, true),\n           PadUnsigned => (true, false)\n         };\n-        pure fn have_precision(cv: Conv) -> bool {\n+        fn have_precision(cv: Conv) -> bool {\n             return match cv.precision { CountImplied => false, _ => true };\n         }\n         let zero_padding = {\n@@ -858,7 +858,7 @@ pub mod rt {\n         }\n         return padstr + s;\n     }\n-    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n+    pub fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }\n }"}, {"sha": "739314bf619086cf5b86b30b0f26d586608eea87", "filename": "src/libcore/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -18,11 +18,11 @@ use prelude::*;\n \n /// The identity function.\n #[inline(always)]\n-pub pure fn id<T>(x: T) -> T { x }\n+pub fn id<T>(x: T) -> T { x }\n \n /// Ignores a value.\n #[inline(always)]\n-pub pure fn ignore<T>(_x: T) { }\n+pub fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`."}, {"sha": "56d547874d8dede7f3e8fe852dfcf80c56728a2b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 228, "deletions": 231, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -47,12 +47,12 @@ pub mod rustrt {\n }\n \n /// Returns true if a vector contains no elements\n-pub pure fn is_empty<T>(v: &[const T]) -> bool {\n+pub fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n }\n \n /// Returns true if two vectors have the same length\n-pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n+pub fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n     xs.len() == ys.len()\n }\n \n@@ -105,7 +105,7 @@ pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pub pure fn capacity<T>(v: &const ~[T]) -> uint {\n+pub fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n@@ -114,12 +114,12 @@ pub pure fn capacity<T>(v: &const ~[T]) -> uint {\n \n /// Returns the length of a vector\n #[inline(always)]\n-pub pure fn len<T>(v: &[const T]) -> uint {\n+pub fn len<T>(v: &[const T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n // A botch to tide us over until core and std are fully demuted.\n-pub pure fn uniq_len<T>(v: &const ~[T]) -> uint {\n+pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let v: &~[T] = ::cast::transmute(v);\n         as_const_buf(*v, |_p, len| len)\n@@ -132,7 +132,7 @@ pub pure fn uniq_len<T>(v: &const ~[T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n+pub fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         do as_mut_buf(v) |p, _len| {\n@@ -154,16 +154,16 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n+pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     from_fn(n_elts, |_i| copy t)\n }\n \n /// Creates a new unique vector with the same contents as the slice\n-pub pure fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n+pub fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n-pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n+pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n     unsafe { reserve(&mut vec, capacity); }\n     vec\n@@ -182,8 +182,7 @@ pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized<A>(size: uint,\n-                       builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n+pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|x| unsafe { vec.push(x) });\n     vec\n@@ -200,7 +199,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n+pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -217,54 +216,55 @@ pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n+pub fn build_sized_opt<A>(size: Option<uint>,\n+                          builder: &fn(push: &fn(v: A)))\n+                       -> ~[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n \n // Accessors\n \n /// Returns the first element of a vector\n-pub pure fn head<T>(v: &'r [T]) -> &'r T {\n+pub fn head<T>(v: &'r [T]) -> &'r T {\n     if v.len() == 0 { fail!(~\"head: empty vector\") }\n     &v[0]\n }\n \n /// Returns `Some(x)` where `x` is the first element of the slice `v`,\n /// or `None` if the vector is empty.\n-pub pure fn head_opt<T>(v: &'r [T]) -> Option<&'r T> {\n+pub fn head_opt<T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[0]) }\n }\n \n /// Returns a vector containing all but the first element of a slice\n-pub pure fn tail<T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n+pub fn tail<T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n \n /// Returns a vector containing all but the first `n` elements of a slice\n-pub pure fn tailn<T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n+pub fn tailn<T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n \n /// Returns a vector containing all but the last element of a slice\n-pub pure fn init<T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n+pub fn init<T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n \n /// Returns a vector containing all but the last `n' elements of a slice\n-pub pure fn initn<T>(v: &'r [T], n: uint) -> &'r [T] {\n+pub fn initn<T>(v: &'r [T], n: uint) -> &'r [T] {\n     slice(v, 0, v.len() - n)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub pure fn last<T>(v: &'r [T]) -> &'r T {\n+pub fn last<T>(v: &'r [T]) -> &'r T {\n     if v.len() == 0 { fail!(~\"last: empty vector\") }\n     &v[v.len() - 1]\n }\n \n /// Returns `Some(x)` where `x` is the last element of the slice `v`, or\n /// `None` if the vector is empty.\n-pub pure fn last_opt<T>(v: &'r [T]) -> Option<&'r T> {\n+pub fn last_opt<T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n }\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n+pub fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n@@ -278,10 +278,7 @@ pub pure fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn mut_slice<T>(v: &'r mut [T],\n-                         start: uint,\n-                         end: uint)\n-                      -> &'r mut [T] {\n+pub fn mut_slice<T>(v: &'r mut [T], start: uint, end: uint) -> &'r mut [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n@@ -295,10 +292,8 @@ pub pure fn mut_slice<T>(v: &'r mut [T],\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn const_slice<T>(v: &'r [const T],\n-                           start: uint,\n-                           end: uint)\n-                        -> &'r [const T] {\n+pub fn const_slice<T>(v: &'r [const T], start: uint, end: uint)\n+                   -> &'r [const T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n@@ -434,7 +429,7 @@ pub fn partition<T>(v: ~[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub pure fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -713,7 +708,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v = lhs;\n     unsafe {\n         v.push_all(rhs);\n@@ -722,7 +717,7 @@ pub pure fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n }\n \n #[inline(always)]\n-pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n+pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n     unsafe { v.push(x); }\n     v\n@@ -788,7 +783,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n+pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n         unsafe {\n@@ -807,7 +802,7 @@ pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n+pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -819,14 +814,14 @@ pub pure fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pub pure fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     result\n }\n \n /// Apply a function to each pair of elements and return the results\n-pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n+pub fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n                                   f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail!(); }\n@@ -860,7 +855,7 @@ pub fn filter_map<T, U>(\n     result\n }\n \n-pub pure fn filter_mapped<T, U: Copy>(\n+pub fn filter_mapped<T, U: Copy>(\n     v: &[T],\n     f: &fn(t: &T) -> Option<U>) -> ~[U]\n {\n@@ -904,7 +899,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub pure fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n+pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n@@ -915,7 +910,7 @@ pub pure fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n /**\n  * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n  */\n-pub fn retain<T>(v: &mut ~[T], f: &pure fn(t: &T) -> bool) {\n+pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n     let len = v.len();\n     let mut deleted: uint = 0;\n \n@@ -937,14 +932,14 @@ pub fn retain<T>(v: &mut ~[T], f: &pure fn(t: &T) -> bool) {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pub pure fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n+pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { r.push_all(*inner); } }\n     r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n+pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n@@ -971,7 +966,7 @@ pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n  * ~~~\n  *\n  */\n-pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n+pub fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     let mut i = 0;\n     let l = v.len();\n@@ -1003,7 +998,7 @@ pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n  * ~~~\n  *\n  */\n-pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n+pub fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n     for v.each_reverse |elt| {\n         accum = p(elt, accum);\n@@ -1016,7 +1011,7 @@ pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pub pure fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n+pub fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { return true; } }\n     false\n }\n@@ -1026,7 +1021,7 @@ pub pure fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n  *\n  * If the vectors contains no elements then false is returned.\n  */\n-pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n+pub fn any2<T, U>(v0: &[T], v1: &[U],\n                    f: &fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n@@ -1043,7 +1038,7 @@ pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n+pub fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { return false; } }\n     true\n }\n@@ -1053,7 +1048,7 @@ pub pure fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n+pub fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     true\n }\n@@ -1063,7 +1058,7 @@ pub pure fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n  *\n  * If the vectors are not the same size then false is returned.\n  */\n-pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n+pub fn all2<T, U>(v0: &[T], v1: &[U],\n                    f: &fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n@@ -1073,13 +1068,13 @@ pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n }\n \n /// Return true if a vector contains an element with the given value\n-pub pure fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n+pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n     false\n }\n \n /// Returns the number of elements that are equal to a given value\n-pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n+pub fn count<T:Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n     cnt\n@@ -1092,7 +1087,7 @@ pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n+pub fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -1103,7 +1098,7 @@ pub pure fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n+pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n                       f: &fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n@@ -1115,7 +1110,7 @@ pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n+pub fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -1126,13 +1121,16 @@ pub pure fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is return.\n  */\n-pub pure fn rfind_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                               f: &fn(t: &T) -> bool) -> Option<T> {\n+pub fn rfind_between<T:Copy>(v: &[T],\n+                             start: uint,\n+                             end: uint,\n+                             f: &fn(t: &T) -> bool)\n+                          -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value\n-pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n+pub fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     position(v, |y| *x == *y)\n }\n \n@@ -1143,7 +1141,7 @@ pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pub pure fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n+pub fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1154,8 +1152,11 @@ pub pure fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: &fn(t: &T) -> bool) -> Option<uint> {\n+pub fn position_between<T>(v: &[T],\n+                           start: uint,\n+                           end: uint,\n+                           f: &fn(t: &T) -> bool)\n+                        -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     let mut i = start;\n@@ -1164,7 +1165,7 @@ pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n+pub fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     rposition(v, |y| *x == *y)\n }\n \n@@ -1175,7 +1176,7 @@ pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n+pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1187,7 +1188,7 @@ pub pure fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n  * containing the index is returned. If `f` matches no elements then none is\n  * returned.\n  */\n-pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n+pub fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: &fn(t: &T) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n@@ -1206,7 +1207,7 @@ pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n /**\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n-pure fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n+pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n         let (t, u) = *p;\n@@ -1226,7 +1227,7 @@ pure fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * and the i-th element of the second vector contains the second element\n  * of the i-th tuple of the input vector.\n  */\n-pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n+pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n         do consume(v) |_i, p| {\n@@ -1241,7 +1242,7 @@ pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n+pub fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -1259,7 +1260,7 @@ pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n  * Returns a vector of tuples, where the i-th tuple contains contains the\n  * i-th elements from each of the input vectors.\n  */\n-pub pure fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n+pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     let mut i = len(v);\n     fail_unless!(i == len(u));\n     let mut w = with_capacity(i);\n@@ -1292,7 +1293,7 @@ pub fn reverse<T>(v: &mut [T]) {\n }\n \n /// Returns a vector with the order of elements reversed\n-pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n+pub fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (rs); } else { i -= 1; }\n@@ -1342,7 +1343,7 @@ pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn each<T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n+pub fn each<T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1380,7 +1381,7 @@ pub fn each_mut<T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n+pub fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1397,7 +1398,7 @@ pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n+pub fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1411,7 +1412,7 @@ pub pure fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n+pub fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n     eachi_reverse(v, |_i, v| blk(v))\n }\n \n@@ -1421,7 +1422,7 @@ pub pure fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+pub fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1439,7 +1440,7 @@ pub pure fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n     fail_unless!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1458,7 +1459,7 @@ pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pub pure fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n+pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1482,7 +1483,7 @@ pub pure fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     }\n }\n \n-pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n+pub fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     fail_unless!(1u <= nn);\n     for vec::eachi (xx) |ii, _x| {\n@@ -1503,9 +1504,9 @@ pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n  * foreign interop.\n  */\n #[inline(always)]\n-pub pure fn as_imm_buf<T,U>(s: &[T],\n-                            /* NB---this CANNOT be const, see below */\n-                            f: &fn(*T, uint) -> U) -> U {\n+pub fn as_imm_buf<T,U>(s: &[T],\n+                       /* NB---this CANNOT be const, see below */\n+                       f: &fn(*T, uint) -> U) -> U {\n \n     // NB---Do not change the type of s to `&[const T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n@@ -1523,9 +1524,7 @@ pub pure fn as_imm_buf<T,U>(s: &[T],\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n-pub pure fn as_const_buf<T,U>(s: &[const T],\n-                          f: &fn(*const T, uint) -> U) -> U {\n-\n+pub fn as_const_buf<T,U>(s: &[const T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*const T,uint) =\n             ::cast::reinterpret_cast(&addr_of(&s));\n@@ -1536,9 +1535,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pub pure fn as_mut_buf<T,U>(s: &mut [T],\n-                        f: &fn(*mut T, uint) -> U) -> U {\n-\n+pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*mut T,uint) =\n             ::cast::reinterpret_cast(&addr_of(&s));\n@@ -1549,7 +1546,7 @@ pub pure fn as_mut_buf<T,U>(s: &mut [T],\n \n // Equality\n \n-pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n+fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n \n@@ -1565,37 +1562,37 @@ pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n #[cfg(notest)]\n impl<T:Eq> Eq for &'self [T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n }\n \n \n #[cfg(notest)]\n impl<T:Eq> Eq for ~[T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @[T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Equiv<~[T]> for &'self [T] {\n     #[inline(always)]\n-    pure fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n+    fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n }\n \n // Lexicographical comparison\n \n-pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n+fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n     let low = uint::min(a.len(), b.len());\n \n     for uint::range(0, low) |idx| {\n@@ -1612,22 +1609,22 @@ pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for &'self [T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for ~[T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for @[T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n }\n \n-pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n+fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n \n@@ -1642,44 +1639,44 @@ pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     a_len < b_len\n }\n \n-pure fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n-pure fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n-pure fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n+fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n+fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n+fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for &'self [T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for ~[T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for @[T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n@@ -1690,7 +1687,7 @@ pub mod traits {\n \n     impl<T:Copy> Add<&'self [const T],~[T]> for ~[T] {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &'self [const T]) -> ~[T] {\n+        fn add(&self, rhs: & &'self [const T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n@@ -1699,22 +1696,22 @@ pub mod traits {\n impl<T> Container for &'self [const T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    pure fn is_empty(&const self) -> bool { is_empty(*self) }\n+    fn is_empty(&const self) -> bool { is_empty(*self) }\n \n     /// Returns the length of a vector\n     #[inline]\n-    pure fn len(&const self) -> uint { len(*self) }\n+    fn len(&const self) -> uint { len(*self) }\n }\n \n pub trait CopyableVector<T> {\n-    pure fn to_owned(&self) -> ~[T];\n+    fn to_owned(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n impl<T: Copy> CopyableVector<T> for &'self [const T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    pure fn to_owned(&self) -> ~[T] {\n+    fn to_owned(&self) -> ~[T] {\n         let mut result = ~[];\n         // FIXME: #4568\n         unsafe {\n@@ -1729,93 +1726,93 @@ impl<T: Copy> CopyableVector<T> for &'self [const T] {\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn slice(&self, start: uint, end: uint) -> &'self [T];\n-    pure fn head(&self) -> &'self T;\n-    pure fn head_opt(&self) -> Option<&'self T>;\n-    pure fn tail(&self) -> &'self [T];\n-    pure fn tailn(&self, n: uint) -> &'self [T];\n-    pure fn init(&self) -> &'self [T];\n-    pure fn initn(&self, n: uint) -> &'self [T];\n-    pure fn last(&self) -> &'self T;\n-    pure fn last_opt(&self) -> Option<&'self T>;\n-    pure fn each_reverse(&self, blk: &fn(&T) -> bool);\n-    pure fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n-    pure fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n-    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n+    fn slice(&self, start: uint, end: uint) -> &'self [T];\n+    fn head(&self) -> &'self T;\n+    fn head_opt(&self) -> Option<&'self T>;\n+    fn tail(&self) -> &'self [T];\n+    fn tailn(&self, n: uint) -> &'self [T];\n+    fn init(&self) -> &'self [T];\n+    fn initn(&self, n: uint) -> &'self [T];\n+    fn last(&self) -> &'self T;\n+    fn last_opt(&self) -> Option<&'self T>;\n+    fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n+    fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n-    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n impl<T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         slice(*self, start, end)\n     }\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n-    pure fn head(&self) -> &'self T { head(*self) }\n+    fn head(&self) -> &'self T { head(*self) }\n \n     /// Returns the first element of a vector\n     #[inline]\n-    pure fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n+    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n \n     /// Returns all but the first element of a vector\n     #[inline]\n-    pure fn tail(&self) -> &'self [T] { tail(*self) }\n+    fn tail(&self) -> &'self [T] { tail(*self) }\n \n     /// Returns all but the first `n' elements of a vector\n     #[inline]\n-    pure fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n+    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n \n     /// Returns all but the last elemnt of a vector\n     #[inline]\n-    pure fn init(&self) -> &'self [T] { init(*self) }\n+    fn init(&self) -> &'self [T] { init(*self) }\n \n     /// Returns all but the last `n' elemnts of a vector\n     #[inline]\n-    pure fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n+    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last(&self) -> &'self T { last(*self) }\n+    fn last(&self) -> &'self T { last(*self) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n+    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n \n     /// Iterates over a vector's elements in reverse.\n     #[inline]\n-    pure fn each_reverse(&self, blk: &fn(&T) -> bool) {\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n         each_reverse(*self, blk)\n     }\n \n     /// Iterates over a vector's elements and indices in reverse.\n     #[inline]\n-    pure fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n         eachi_reverse(*self, blk)\n     }\n \n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n+    fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n         foldr(*self, z, p)\n     }\n \n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n \n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n         mapi(*self, f)\n     }\n \n@@ -1835,15 +1832,15 @@ impl<T> ImmutableVector<T> for &'self [T] {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n         alli(*self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n     /**\n@@ -1853,16 +1850,16 @@ impl<T> ImmutableVector<T> for &'self [T] {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n }\n \n pub trait ImmutableEqVector<T:Eq> {\n-    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    pure fn position_elem(&self, t: &T) -> Option<uint>;\n-    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n+    fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n+    fn position_elem(&self, t: &T) -> Option<uint>;\n+    fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n+    fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n@@ -1874,13 +1871,13 @@ impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n+    fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         position(*self, f)\n     }\n \n     /// Find the first index containing a matching value\n     #[inline]\n-    pure fn position_elem(&self, x: &T) -> Option<uint> {\n+    fn position_elem(&self, x: &T) -> Option<uint> {\n         position_elem(*self, x)\n     }\n \n@@ -1892,21 +1889,21 @@ impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n+    fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         rposition(*self, f)\n     }\n \n     /// Find the last index containing a matching value\n     #[inline]\n-    pure fn rposition_elem(&self, t: &T) -> Option<uint> {\n+    fn rposition_elem(&self, t: &T) -> Option<uint> {\n         rposition_elem(*self, t)\n     }\n }\n \n pub trait ImmutableCopyableVector<T> {\n-    pure fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n-    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n-    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n+    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n+    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n }\n \n /// Extension methods for vectors\n@@ -1919,7 +1916,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n+    fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n         filtered(*self, f)\n     }\n \n@@ -1931,7 +1928,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n+    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n         rfind(*self, f)\n     }\n \n@@ -1940,7 +1937,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      * those that do not.\n      */\n     #[inline]\n-    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partitioned(*self, f)\n     }\n }\n@@ -1955,10 +1952,10 @@ pub trait OwnedVector<T> {\n     fn remove(&mut self, i: uint) -> T;\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n-    fn retain(&mut self, f: &pure fn(t: &T) -> bool);\n+    fn retain(&mut self, f: &fn(t: &T) -> bool);\n     fn consume(self, f: &fn(uint, v: T));\n     fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n-    fn partition(self, f: &pure fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n }\n \n@@ -2009,7 +2006,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn retain(&mut self, f: &pure fn(t: &T) -> bool) {\n+    fn retain(&mut self, f: &fn(t: &T) -> bool) {\n         retain(self, f);\n     }\n \n@@ -2258,7 +2255,7 @@ pub mod bytes {\n     use vec;\n \n     /// Bytewise string comparison\n-    pub pure fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = a.len();\n         let b_len = b.len();\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -2279,22 +2276,22 @@ pub mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n+    pub fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n+    pub fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n+    pub fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n+    pub fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n+    pub fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n+    pub fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n@@ -2314,25 +2311,25 @@ pub mod bytes {\n \n impl<A> iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n+    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n+    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n+    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<A> iter::MutableIter<A> for &'self mut [A] {\n@@ -2359,150 +2356,150 @@ impl<A> iter::MutableIter<A> for @mut [A] {\n }\n \n impl<A> iter::ExtendedIter<A> for &'self [A] {\n-    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for ~[A] {\n-    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for @[A] {\n-    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n impl<A:Eq> iter::EqIter<A> for &'self [A] {\n-    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Eq> iter::EqIter<A> for ~[A] {\n-    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Eq> iter::EqIter<A> for @[A] {\n-    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A:Copy> iter::CopyableIter<A> for &'self [A] {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for ~[A] {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for @[A] {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &'self [A] {\n-    pure fn min(&self) -> A { iter::min(self) }\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn min(&self) -> A { iter::min(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for ~[A] {\n-    pure fn min(&self) -> A { iter::min(self) }\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn min(&self) -> A { iter::min(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n-    pure fn min(&self) -> A { iter::min(self) }\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn min(&self) -> A { iter::min(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }\n \n impl<A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n-    pure fn each_val(&const self, f: &fn(A) -> bool) {\n+    fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2513,7 +2510,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n-    pure fn each_val(&const self, f: &fn(A) -> bool) {\n+    fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < uniq_len(self) {\n             if !f(copy self[i]) { break; }\n@@ -2524,7 +2521,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for @[A] {\n-    pure fn each_val(&const self, f: &fn(A) -> bool) {\n+    fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2559,11 +2556,11 @@ mod tests {\n \n     fn square_ref(n: &uint) -> uint { square(*n) }\n \n-    pure fn is_three(n: &uint) -> bool { *n == 3u }\n+    fn is_three(n: &uint) -> bool { *n == 3u }\n \n-    pure fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n+    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n \n-    pure fn is_equal(x: &uint, y:&uint) -> bool { *x == *y }\n+    fn is_equal(x: &uint, y:&uint) -> bool { *x == *y }\n \n     fn square_if_odd_r(n: &uint) -> Option<uint> {\n         if *n % 2u == 1u { Some(*n * *n) } else { None }"}, {"sha": "eedd3bebedfc42bdee89e1d14963579fa6cb780b", "filename": "src/libfuzzer/ast_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -25,8 +25,8 @@ fn vec_equal<T>(v: ~[T],\n     return true;\n }\n \n-pure fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n-pure fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n+fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n+fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n \n fn main() {\n     fail_unless!((builtin_equal(5, 5)));"}, {"sha": "71f7072fa7f9641989dd121807ad4d0bb431c5da", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -95,11 +95,11 @@ pub fn common_exprs() -> ~[ast::expr] {\n     ]\n }\n \n-pub pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n+pub fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n     safe_to_use_expr(*e, tm)\n }\n \n-pub pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+pub fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     match tm {\n       tm_converge => {\n         match e.node {"}, {"sha": "1137b2a2c08a0a4672faab32ab300441525282fc", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -20,7 +20,7 @@ use core::util;\n use core::vec;\n use core::hashmap::linear::LinearSet;\n \n-pure fn not_win32(os: session::os) -> bool {\n+fn not_win32(os: session::os) -> bool {\n   match os {\n       session::os_win32 => false,\n       _ => true"}, {"sha": "b952aff9e1ce15749ad5a841b973773cd4353732", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -872,7 +872,7 @@ pub fn get_item_attrs(cdata: cmd,\n     }\n }\n \n-pure fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n+fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n     match family {\n       PublicField => ast::public,\n       PrivateField => ast::private,"}, {"sha": "d5c4b27e6cbb8f084cf9955c198134e59131cd22", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -444,7 +444,7 @@ pub impl LoanKind {\n /// Creates and returns a new root_map\n \n impl to_bytes::IterBytes for root_map_key {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }"}, {"sha": "c319ca891052f434e5da215cf7b6b1e1172911db", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -82,7 +82,7 @@ pub struct LanguageItems {\n }\n \n pub impl LanguageItems {\n-    static pub fn new(&self) -> LanguageItems {\n+    pub fn new() -> LanguageItems {\n         LanguageItems {\n             items: [ None, ..35 ]\n         }\n@@ -96,7 +96,7 @@ pub impl LanguageItems {\n         }\n     }\n \n-    static pub fn item_name(&self, index: uint) -> &'static str {\n+    pub fn item_name(index: uint) -> &'static str {\n         match index {\n             0  => \"const\",\n             1  => \"copy\","}, {"sha": "2b16ccdd1d22025bc0ca3ee31c43131d9f4523ef", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -534,7 +534,7 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n-    pure fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n+    fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n             ast::lt => v <= max,\n@@ -546,7 +546,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn rev_binop(binop: ast::binop) -> ast::binop {\n+    fn rev_binop(binop: ast::binop) -> ast::binop {\n         match binop {\n             ast::lt => ast::gt,\n             ast::le => ast::ge,\n@@ -556,7 +556,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n+    fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n         match int_ty {\n             ast::ty_i =>    (int::min_value as i64, int::max_value as i64),\n             ast::ty_char => (u32::min_value as i64, u32::max_value as i64),\n@@ -567,7 +567,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n+    fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n         match uint_ty {\n             ast::ty_u =>   (uint::min_value as u64, uint::max_value as u64),\n             ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n@@ -622,7 +622,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn is_comparison(binop: ast::binop) -> bool {\n+    fn is_comparison(binop: ast::binop) -> bool {\n         match binop {\n             ast::eq | ast::lt | ast::le |\n             ast::ne | ast::ge | ast::gt => true,"}, {"sha": "0959e2eb0937ac54a5566e6b7ad7729d1c0fe6f1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -141,13 +141,13 @@ struct Variable(uint);\n struct LiveNode(uint);\n \n impl cmp::Eq for Variable {\n-    pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n+    fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n+    fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n }\n \n impl cmp::Eq for LiveNode {\n-    pure fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n+    fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n+    fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n }\n \n enum LiveNodeKind {\n@@ -158,7 +158,7 @@ enum LiveNodeKind {\n }\n \n impl cmp::Eq for LiveNodeKind {\n-    pure fn eq(&self, other: &LiveNodeKind) -> bool {\n+    fn eq(&self, other: &LiveNodeKind) -> bool {\n         match (*self) {\n             FreeVarNode(e0a) => {\n                 match (*other) {\n@@ -186,7 +186,7 @@ impl cmp::Eq for LiveNodeKind {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n }\n \n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n@@ -224,11 +224,11 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n impl to_str::ToStr for LiveNode {\n-    pure fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n+    fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n }\n \n impl to_str::ToStr for Variable {\n-    pure fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n+    fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n }\n \n // ______________________________________________________________________\n@@ -254,7 +254,7 @@ impl to_str::ToStr for Variable {\n // assignment.  And so forth.\n \n pub impl LiveNode {\n-    pure fn is_valid(&self) -> bool { **self != uint::max_value }\n+    fn is_valid(&self) -> bool { **self != uint::max_value }\n }\n \n fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }"}, {"sha": "e767b0ff812f408c7939fe3dbf74246d6a92d5f6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -305,13 +305,13 @@ pub struct mem_categorization_ctxt {\n }\n \n impl ToStr for MutabilityCategory {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"%?\", *self)\n     }\n }\n \n pub impl MutabilityCategory {\n-    static fn from_mutbl(&self, m: ast::mutability) -> MutabilityCategory {\n+    fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n         match m {\n             m_imm => McImmutable,\n             m_const => McReadOnly,"}, {"sha": "9517494e492b842e975bfcda33d4fcfdea26194b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -151,7 +151,7 @@ pub enum NamespaceResult {\n }\n \n pub impl NamespaceResult {\n-    pure fn is_unknown(&self) -> bool {\n+    fn is_unknown(&self) -> bool {\n         match *self {\n             UnknownResult => true,\n             _ => false"}, {"sha": "4d0ad2c19f1159d755732e54b657864124349782", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -41,10 +41,10 @@ enum x86_64_reg_class {\n }\n \n impl cmp::Eq for x86_64_reg_class {\n-    pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n+    fn eq(&self, other: &x86_64_reg_class) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n }\n \n fn is_sse(++c: x86_64_reg_class) -> bool {"}, {"sha": "c220bd23e20f0b84300ff6d048e7342eaad7ba4b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -678,9 +678,9 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n pub impl block_ {\n-    pure fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n-    pure fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n-    pure fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n+    fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n+    fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n \n     fn node_id_to_str(@mut self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n@@ -1290,7 +1290,7 @@ pub struct mono_id_ {\n pub type mono_id = @mono_id_;\n \n impl to_bytes::IterBytes for mono_param_id {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             mono_precise(t, ref mids) =>\n                 to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n@@ -1304,7 +1304,7 @@ impl to_bytes::IterBytes for mono_param_id {\n }\n \n impl to_bytes::IterBytes for mono_id_ {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }"}, {"sha": "600f637f72b59cb43c4a2f9c6cbe05662cde4695", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -158,14 +158,14 @@ pub impl DatumMode {\n }\n \n impl cmp::Eq for DatumMode {\n-    pure fn eq(&self, other: &DatumMode) -> bool {\n+    fn eq(&self, other: &DatumMode) -> bool {\n         (*self) as uint == (*other as uint)\n     }\n-    pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n impl to_bytes::IterBytes for DatumMode {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "7cfa1ff49292a022d14bbf34f4515e11ddc6fd8d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -175,15 +175,15 @@ pub impl Dest {\n }\n \n impl cmp::Eq for Dest {\n-    pure fn eq(&self, other: &Dest) -> bool {\n+    fn eq(&self, other: &Dest) -> bool {\n         match ((*self), (*other)) {\n             (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n             (Ignore, Ignore) => true,\n             (SaveIn(*), _) => false,\n             (Ignore, _) => false,\n         }\n     }\n-    pure fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n }\n \n fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n@@ -1695,7 +1695,7 @@ pub enum cast_kind {\n }\n \n impl cmp::Eq for cast_kind {\n-    pure fn eq(&self, other: &cast_kind) -> bool {\n+    fn eq(&self, other: &cast_kind) -> bool {\n         match ((*self), (*other)) {\n             (cast_pointer, cast_pointer) => true,\n             (cast_integral, cast_integral) => true,\n@@ -1709,7 +1709,7 @@ impl cmp::Eq for cast_kind {\n             (cast_other, _) => false,\n         }\n     }\n-    pure fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n }\n \n pub fn cast_type_kind(t: ty::t) -> cast_kind {"}, {"sha": "bf5a699ed8237b8b688a5834dee151c618fc23e7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -218,8 +218,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub pure fn cast_glue(ccx: @CrateContext, ti: @mut tydesc_info, v: ValueRef)\n-                   -> ValueRef {\n+pub fn cast_glue(ccx: @CrateContext, ti: @mut tydesc_info, v: ValueRef)\n+              -> ValueRef {\n     unsafe {\n         let llfnty = type_of_glue_fn(ccx, ti.ty);\n         llvm::LLVMConstPointerCast(v, T_ptr(llfnty))"}, {"sha": "ce6f6c8efa702ae61e0e904ece05dbdd016b3008", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -282,7 +282,7 @@ pub fn trans_static_method_callee(bcx: block,\n     // When we translate a static fn defined in a trait like:\n     //\n     //   trait<T1...Tn> Trait {\n-    //       static fn foo<M1...Mn>(...) {...}\n+    //       fn foo<M1...Mn>(...) {...}\n     //   }\n     //\n     // this winds up being translated as something like:"}, {"sha": "cbd2ad86b75fe100057e2214de4790443710c91c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -121,7 +121,7 @@ pub struct creader_cache_key {\n type creader_cache = HashMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n@@ -135,18 +135,18 @@ struct intern_key {\n // implementation will not recurse through sty and you will get stack\n // exhaustion.\n impl cmp::Eq for intern_key {\n-    pure fn eq(&self, other: &intern_key) -> bool {\n+    fn eq(&self, other: &intern_key) -> bool {\n         unsafe {\n             *self.sty == *other.sty && self.o_def_id == other.o_def_id\n         }\n     }\n-    pure fn ne(&self, other: &intern_key) -> bool {\n+    fn ne(&self, other: &intern_key) -> bool {\n         !self.eq(other)\n     }\n }\n \n impl to_bytes::IterBytes for intern_key {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n             to_bytes::iter_bytes_2(&*self.sty, &self.o_def_id, lsb0, f);\n         }\n@@ -165,7 +165,7 @@ pub type opt_region_variance = Option<region_variance>;\n pub enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl cmp::Eq for region_variance {\n-    pure fn eq(&self, other: &region_variance) -> bool {\n+    fn eq(&self, other: &region_variance) -> bool {\n         match ((*self), (*other)) {\n             (rv_covariant, rv_covariant) => true,\n             (rv_invariant, rv_invariant) => true,\n@@ -175,7 +175,7 @@ impl cmp::Eq for region_variance {\n             (rv_contravariant, _) => false\n         }\n     }\n-    pure fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n }\n \n #[auto_encode]\n@@ -334,7 +334,7 @@ struct t_box_ {\n enum t_opaque {}\n pub type t = *t_opaque;\n \n-pub pure fn get(t: t) -> t_box {\n+pub fn get(t: t) -> t_box {\n     unsafe {\n         let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n         let t3 = t2;\n@@ -343,21 +343,21 @@ pub pure fn get(t: t) -> t_box {\n     }\n }\n \n-pub pure fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n+pub fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n     (tb.flags & (flag as uint)) != 0u\n }\n-pub pure fn type_has_params(t: t) -> bool {\n+pub fn type_has_params(t: t) -> bool {\n     tbox_has_flag(get(t), has_params)\n }\n-pub pure fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n-pub pure fn type_needs_infer(t: t) -> bool {\n+pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n+pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), needs_infer)\n }\n-pub pure fn type_has_regions(t: t) -> bool {\n+pub fn type_has_regions(t: t) -> bool {\n     tbox_has_flag(get(t), has_regions)\n }\n-pub pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n-pub pure fn type_id(t: t) -> uint { get(t).id }\n+pub fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n+pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Eq)]\n pub struct BareFnTy {\n@@ -388,13 +388,13 @@ pub struct FnSig {\n }\n \n impl to_bytes::IterBytes for BareFnTy {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.purity, &self.abi, &self.sig, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for ClosureTy {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n                                &self.region, &self.sig, lsb0, f)\n     }\n@@ -407,7 +407,7 @@ pub struct param_ty {\n }\n \n impl to_bytes::IterBytes for param_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n     }\n }\n@@ -616,7 +616,7 @@ pub enum InferTy {\n }\n \n impl to_bytes::IterBytes for InferTy {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n           IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n@@ -633,7 +633,7 @@ pub enum InferRegion {\n }\n \n impl to_bytes::IterBytes for InferRegion {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n             ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n@@ -642,7 +642,7 @@ impl to_bytes::IterBytes for InferRegion {\n }\n \n impl cmp::Eq for InferRegion {\n-    pure fn eq(&self, other: &InferRegion) -> bool {\n+    fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n             (ReVar(rva), ReVar(rvb)) => {\n                 rva == rvb\n@@ -653,13 +653,13 @@ impl cmp::Eq for InferRegion {\n             _ => false\n         }\n     }\n-    pure fn ne(&self, other: &InferRegion) -> bool {\n+    fn ne(&self, other: &InferRegion) -> bool {\n         !((*self) == (*other))\n     }\n }\n \n impl to_bytes::IterBytes for param_bound {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bound_copy => 0u8.iter_bytes(lsb0, f),\n           bound_durable => 1u8.iter_bytes(lsb0, f),\n@@ -672,50 +672,50 @@ impl to_bytes::IterBytes for param_bound {\n }\n \n pub trait Vid {\n-    pure fn to_uint(&self) -> uint;\n+    fn to_uint(&self) -> uint;\n }\n \n impl Vid for TyVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for TyVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n impl Vid for IntVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for IntVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n impl Vid for FloatVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for FloatVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n impl Vid for RegionVid {\n-    pure fn to_uint(&self) -> uint { self.id }\n+    fn to_uint(&self) -> uint { self.id }\n }\n \n impl ToStr for RegionVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n+    fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n }\n \n impl ToStr for FnSig {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // grr, without tcx not much we can do.\n         return ~\"(...)\";\n     }\n }\n \n impl ToStr for InferTy {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             TyVar(ref v) => v.to_str(),\n             IntVar(ref v) => v.to_str(),\n@@ -725,7 +725,7 @@ impl ToStr for InferTy {\n }\n \n impl ToStr for IntVarValue {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             IntType(ref v) => v.to_str(),\n             UintType(ref v) => v.to_str(),\n@@ -734,25 +734,25 @@ impl ToStr for IntVarValue {\n }\n \n impl to_bytes::IterBytes for TyVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for IntVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FloatVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for RegionVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n@@ -1112,7 +1112,7 @@ pub fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n }\n \n // Converts s to its machine type equivalent\n-pub pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n+pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n     match get(t).sty {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n@@ -1532,58 +1532,58 @@ pub fn get_element_type(ty: t, i: uint) -> t {\n     }\n }\n \n-pub pure fn type_is_box(ty: t) -> bool {\n+pub fn type_is_box(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) => return true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_boxed(ty: t) -> bool {\n+pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) | ty_opaque_box |\n       ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n       _ => false\n     }\n }\n \n-pub pure fn type_is_region_ptr(ty: t) -> bool {\n+pub fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_rptr(_, _) => true,\n       _ => false\n     }\n }\n \n-pub pure fn type_is_slice(ty: t) -> bool {\n+pub fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_unique_box(ty: t) -> bool {\n+pub fn type_is_unique_box(ty: t) -> bool {\n     match get(ty).sty {\n       ty_uniq(_) => return true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_unsafe_ptr(ty: t) -> bool {\n+pub fn type_is_unsafe_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_vec(ty: t) -> bool {\n+pub fn type_is_vec(ty: t) -> bool {\n     return match get(ty).sty {\n           ty_evec(_, _) | ty_unboxed_vec(_) => true,\n           ty_estr(_) => true,\n           _ => false\n         };\n }\n \n-pub pure fn type_is_unique(ty: t) -> bool {\n+pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) |\n         ty_evec(_, vstore_uniq) |\n@@ -1598,7 +1598,7 @@ pub pure fn type_is_unique(ty: t) -> bool {\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n  contents are abstract to rustc.)\n */\n-pub pure fn type_is_scalar(ty: t) -> bool {\n+pub fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n@@ -1720,7 +1720,7 @@ pub impl TypeContents {\n         !self.intersects(TypeContents::noncopyable(cx))\n     }\n \n-    static fn noncopyable(_cx: ctxt) -> TypeContents {\n+    fn noncopyable(_cx: ctxt) -> TypeContents {\n         TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_OWNED_CLOSURE +\n             TC_EMPTY_ENUM\n     }\n@@ -1729,15 +1729,15 @@ pub impl TypeContents {\n         !self.intersects(TypeContents::nondurable(cx))\n     }\n \n-    static fn nondurable(_cx: ctxt) -> TypeContents {\n+    fn nondurable(_cx: ctxt) -> TypeContents {\n         TC_BORROWED_POINTER\n     }\n \n     fn is_owned(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::nonowned(cx))\n     }\n \n-    static fn nonowned(_cx: ctxt) -> TypeContents {\n+    fn nonowned(_cx: ctxt) -> TypeContents {\n         TC_MANAGED + TC_BORROWED_POINTER\n     }\n \n@@ -1749,15 +1749,15 @@ pub impl TypeContents {\n         !self.intersects(TypeContents::nonconst(cx))\n     }\n \n-    static fn nonconst(_cx: ctxt) -> TypeContents {\n+    fn nonconst(_cx: ctxt) -> TypeContents {\n         TC_MUTABLE\n     }\n \n     fn moves_by_default(&self, cx: ctxt) -> bool {\n         self.intersects(TypeContents::nonimplicitly_copyable(cx))\n     }\n \n-    static fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n+    fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n         let base = TypeContents::noncopyable(cx) + TC_OWNED_POINTER;\n         if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_VEC}\n     }\n@@ -1766,7 +1766,7 @@ pub impl TypeContents {\n         !self.intersects(TypeContents::nondefault_mode(cx))\n     }\n \n-    static fn nondefault_mode(cx: ctxt) -> TypeContents {\n+    fn nondefault_mode(cx: ctxt) -> TypeContents {\n         let tc = TypeContents::nonimplicitly_copyable(cx);\n         tc + TC_BIG + TC_OWNED_VEC // disregard cx.vecs_implicitly_copyable\n     }\n@@ -1776,26 +1776,26 @@ pub impl TypeContents {\n         self.intersects(tc)\n     }\n \n-    static fn owned(&self, _cx: ctxt) -> TypeContents {\n+    fn owned(_cx: ctxt) -> TypeContents {\n         //! Any kind of owned contents.\n         TC_OWNED_CLOSURE + TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n }\n \n impl ops::Add<TypeContents,TypeContents> for TypeContents {\n-    pure fn add(&self, other: &TypeContents) -> TypeContents {\n+    fn add(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n-    pure fn sub(&self, other: &TypeContents) -> TypeContents {\n+    fn sub(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}\n     }\n }\n \n impl ToStr for TypeContents {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"TypeContents(%s)\", u32::to_str_radix(self.bits, 2))\n     }\n }\n@@ -2534,7 +2534,7 @@ pub fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n }\n \n impl to_bytes::IterBytes for bound_region {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ty::br_self => 0u8.iter_bytes(lsb0, f),\n \n@@ -2554,7 +2554,7 @@ impl to_bytes::IterBytes for bound_region {\n }\n \n impl to_bytes::IterBytes for Region {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           re_bound(ref br) =>\n           to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n@@ -2574,7 +2574,7 @@ impl to_bytes::IterBytes for Region {\n }\n \n impl to_bytes::IterBytes for vstore {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           vstore_fixed(ref u) =>\n           to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n@@ -2589,7 +2589,7 @@ impl to_bytes::IterBytes for vstore {\n }\n \n impl to_bytes::IterBytes for TraitStore {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           BareTraitStore => 0u8.iter_bytes(lsb0, f),\n           UniqTraitStore => 1u8.iter_bytes(lsb0, f),\n@@ -2600,44 +2600,44 @@ impl to_bytes::IterBytes for TraitStore {\n }\n \n impl to_bytes::IterBytes for substs {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for mt {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for field {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for arg {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.mode,\n                                &self.ty, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FnSig {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n \n impl to_bytes::IterBytes for sty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ty_nil => 0u8.iter_bytes(lsb0, f),\n           ty_bool => 1u8.iter_bytes(lsb0, f),\n@@ -2768,7 +2768,7 @@ pub fn ty_fn_purity(fty: t) -> ast::purity {\n     }\n }\n \n-pub pure fn ty_fn_ret(fty: t) -> t {\n+pub fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n@@ -2786,7 +2786,7 @@ pub fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n-pub pure fn ty_vstore(ty: t) -> vstore {\n+pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n@@ -3716,13 +3716,13 @@ pub enum DtorKind {\n }\n \n pub impl DtorKind {\n-    pure fn is_not_present(&const self) -> bool {\n+    fn is_not_present(&const self) -> bool {\n         match *self {\n             NoDtor => true,\n             _ => false\n         }\n     }\n-    pure fn is_present(&const self) -> bool {\n+    fn is_present(&const self) -> bool {\n         !self.is_not_present()\n     }\n }\n@@ -4000,7 +4000,7 @@ pub fn lookup_struct_field(cx: ctxt,\n     }\n }\n \n-pure fn is_public(f: field_ty) -> bool {\n+fn is_public(f: field_ty) -> bool {\n     // XXX: This is wrong.\n     match f.vis {\n         public | inherited => true,\n@@ -4260,7 +4260,7 @@ pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n }\n \n // Determine what purity to check a nested function under\n-pub pure fn determine_inherited_purity(parent_purity: ast::purity,\n+pub fn determine_inherited_purity(parent_purity: ast::purity,\n                                        child_purity: ast::purity,\n                                        child_sigil: ast::Sigil)\n                                     -> ast::purity {\n@@ -4364,14 +4364,14 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n }\n \n impl cmp::Eq for mt {\n-    pure fn eq(&self, other: &mt) -> bool {\n+    fn eq(&self, other: &mt) -> bool {\n         (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl\n     }\n-    pure fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for Region {\n-    pure fn eq(&self, other: &Region) -> bool {\n+    fn eq(&self, other: &Region) -> bool {\n         match (*self) {\n             re_bound(e0a) => {\n                 match (*other) {\n@@ -4405,11 +4405,11 @@ impl cmp::Eq for Region {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for bound_region {\n-    pure fn eq(&self, other: &bound_region) -> bool {\n+    fn eq(&self, other: &bound_region) -> bool {\n         match (*self) {\n             br_self => {\n                 match (*other) {\n@@ -4443,11 +4443,11 @@ impl cmp::Eq for bound_region {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for param_bound {\n-    pure fn eq(&self, other: &param_bound) -> bool {\n+    fn eq(&self, other: &param_bound) -> bool {\n         match (*self) {\n             bound_copy => {\n                 match (*other) {\n@@ -4481,7 +4481,7 @@ impl cmp::Eq for param_bound {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n }\n \n // Local Variables:"}, {"sha": "a83d6f1755ecca254fac682df37196731e9b380d", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -51,27 +51,23 @@ use util::common::indenter;\n use std::list;\n \n pub trait LatticeValue {\n-    static fn sub(&self, cf: &CombineFields, a: &Self, b: &Self) -> ures;\n-    static fn lub(&self, cf: &CombineFields, a: &Self, b: &Self)\n-                 -> cres<Self>;\n-    static fn glb(&self, cf: &CombineFields, a: &Self, b: &Self)\n-                 -> cres<Self>;\n+    fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n+    fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n+    fn glb(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n }\n \n pub type LatticeOp<T> = &'self fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n \n impl LatticeValue for ty::t {\n-    static fn sub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n+    fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n         Sub(*cf).tys(*a, *b).to_ures()\n     }\n \n-    static fn lub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t)\n-                 -> cres<ty::t> {\n+    fn lub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n         Lub(*cf).tys(*a, *b)\n     }\n \n-    static fn glb(&self, cf: &CombineFields, a: &ty::t, b: &ty::t)\n-                 -> cres<ty::t> {\n+    fn glb(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n         Glb(*cf).tys(*a, *b)\n     }\n }"}, {"sha": "f0b5ce9ff60a5cf02b8f271cf43b4e362d78182f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -563,7 +563,7 @@ enum Constraint {\n }\n \n impl cmp::Eq for Constraint {\n-    pure fn eq(&self, other: &Constraint) -> bool {\n+    fn eq(&self, other: &Constraint) -> bool {\n         match ((*self), (*other)) {\n             (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n                 v0a == v0b && v1a == v1b\n@@ -579,11 +579,11 @@ impl cmp::Eq for Constraint {\n             (ConstrainVarSubReg(*), _) => false\n         }\n     }\n-    pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n impl to_bytes::IterBytes for Constraint {\n-   pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+   fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ConstrainVarSubVar(ref v0, ref v1) =>\n           to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n@@ -603,14 +603,14 @@ struct TwoRegions {\n }\n \n impl cmp::Eq for TwoRegions {\n-    pure fn eq(&self, other: &TwoRegions) -> bool {\n+    fn eq(&self, other: &TwoRegions) -> bool {\n         (*self).a == (*other).a && (*self).b == (*other).b\n     }\n-    pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n impl to_bytes::IterBytes for TwoRegions {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n     }\n }"}, {"sha": "7711794d91db514a0dd29fe05ea21a16005206d9", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -35,8 +35,8 @@ pub struct Node<V, T> {\n }\n \n pub trait UnifyVid<T> {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n-        -> &'v mut ValsAndBindings<Self, T>;\n+    fn appropriate_vals_and_bindings(infcx: &'v mut InferCtxt)\n+                                  -> &'v mut ValsAndBindings<Self, T>;\n }\n \n pub impl InferCtxt {\n@@ -144,7 +144,7 @@ pub impl InferCtxt {\n // doesn't have a subtyping relationship we need to worry about.\n \n pub trait SimplyUnifiable {\n-    static fn to_type_err(&self, expected_found<Self>) -> ty::type_err;\n+    fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n pub fn mk_err<T:SimplyUnifiable>(+a_is_expected: bool,\n@@ -235,36 +235,34 @@ pub impl InferCtxt {\n // ______________________________________________________________________\n \n impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+    fn appropriate_vals_and_bindings(infcx: &'v mut InferCtxt)\n         -> &'v mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n         return &mut infcx.ty_var_bindings;\n     }\n }\n \n impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+    fn appropriate_vals_and_bindings(infcx: &'v mut InferCtxt)\n         -> &'v mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n         return &mut infcx.int_var_bindings;\n     }\n }\n \n impl SimplyUnifiable for IntVarValue {\n-    static fn to_type_err(&self, err: expected_found<IntVarValue>)\n-        -> ty::type_err {\n+    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+    fn appropriate_vals_and_bindings(infcx: &'v mut InferCtxt)\n         -> &'v mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n         return &mut infcx.float_var_bindings;\n     }\n }\n \n impl SimplyUnifiable for ast::float_ty {\n-    static fn to_type_err(&self, err: expected_found<ast::float_ty>)\n-        -> ty::type_err {\n+    fn to_type_err(err: expected_found<ast::float_ty>) -> ty::type_err {\n         return ty::terr_float_mismatch(err);\n     }\n }"}, {"sha": "84f2f5191f31a000831391013ac4ddacef20a7f6", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -29,10 +29,10 @@ pub enum OutputFormat {\n }\n \n impl cmp::Eq for OutputFormat {\n-    pure fn eq(&self, other: &OutputFormat) -> bool {\n+    fn eq(&self, other: &OutputFormat) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &OutputFormat) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &OutputFormat) -> bool { !(*self).eq(other) }\n }\n \n /// How to organize the output\n@@ -44,10 +44,10 @@ pub enum OutputStyle {\n }\n \n impl cmp::Eq for OutputStyle {\n-    pure fn eq(&self, other: &OutputStyle) -> bool {\n+    fn eq(&self, other: &OutputStyle) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &OutputStyle) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &OutputStyle) -> bool { !(*self).eq(other) }\n }\n \n /// The configuration for a rustdoc session"}, {"sha": "4ed510c353b5542dfa8bd83899c61c18143e2a94", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -358,11 +358,11 @@ impl PageUtils for ~[Page] {\n }\n \n pub trait Item {\n-    pure fn item(&self) -> ItemDoc;\n+    fn item(&self) -> ItemDoc;\n }\n \n impl Item for ItemTag {\n-    pure fn item(&self) -> ItemDoc {\n+    fn item(&self) -> ItemDoc {\n         match self {\n           &doc::ModTag(ref doc) => copy doc.item,\n           &doc::NmodTag(ref doc) => copy doc.item,\n@@ -378,64 +378,64 @@ impl Item for ItemTag {\n }\n \n impl Item for SimpleItemDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n impl Item for ModDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n impl Item for NmodDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n impl Item for EnumDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n impl Item for TraitDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n impl Item for ImplDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n impl Item for StructDoc {\n-    pure fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc { copy self.item }\n }\n \n pub trait ItemUtils {\n-    pure fn id(&self) -> AstId;\n-    pure fn name(&self) -> ~str;\n-    pure fn path(&self) -> ~[~str];\n-    pure fn brief(&self) -> Option<~str>;\n-    pure fn desc(&self) -> Option<~str>;\n-    pure fn sections(&self) -> ~[Section];\n+    fn id(&self) -> AstId;\n+    fn name(&self) -> ~str;\n+    fn path(&self) -> ~[~str];\n+    fn brief(&self) -> Option<~str>;\n+    fn desc(&self) -> Option<~str>;\n+    fn sections(&self) -> ~[Section];\n }\n \n impl<A:Item> ItemUtils for A {\n-    pure fn id(&self) -> AstId {\n+    fn id(&self) -> AstId {\n         self.item().id\n     }\n \n-    pure fn name(&self) -> ~str {\n+    fn name(&self) -> ~str {\n         copy self.item().name\n     }\n \n-    pure fn path(&self) -> ~[~str] {\n+    fn path(&self) -> ~[~str] {\n         copy self.item().path\n     }\n \n-    pure fn brief(&self) -> Option<~str> {\n+    fn brief(&self) -> Option<~str> {\n         copy self.item().brief\n     }\n \n-    pure fn desc(&self) -> Option<~str> {\n+    fn desc(&self) -> Option<~str> {\n         copy self.item().desc\n     }\n \n-    pure fn sections(&self) -> ~[Section] {\n+    fn sections(&self) -> ~[Section] {\n         copy self.item().sections\n     }\n }"}, {"sha": "227eb25aa81fefe2e07efea550e0d21d1baaa7d1", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -45,8 +45,8 @@ fn run(\n     writer_factory: WriterFactory\n ) -> doc::Doc {\n \n-    pure fn mods_last(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        pure fn is_mod(item: &doc::ItemTag) -> bool {\n+    fn mods_last(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n+        fn is_mod(item: &doc::ItemTag) -> bool {\n             match *item {\n               doc::ModTag(_) => true,\n               _ => false"}, {"sha": "b3fb874cdb26031e79bfaf49a25058ba1ce6d742", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,7 +16,7 @@ use pass::Pass;\n use sort_pass;\n \n pub fn mk_pass() -> Pass {\n-    pure fn by_item_name(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n+    fn by_item_name(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         (*item1).name() <= (*item2).name()\n     }\n     sort_pass::mk_pass(~\"sort_item_name\", by_item_name)"}, {"sha": "96727f6386d237d5ed2311ee754497d09922a789", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,8 +15,8 @@ use pass::Pass;\n use sort_pass;\n \n pub fn mk_pass() -> Pass {\n-    pure fn by_score(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        pure fn score(item: &doc::ItemTag) -> int {\n+    fn by_score(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n+        fn score(item: &doc::ItemTag) -> int {\n             match *item {\n               doc::ConstTag(_) => 0,\n               doc::TyTag(_) => 1,"}, {"sha": "e66eb3c0fae308f93747cde1e65fdf8503bdc8a8", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -21,7 +21,7 @@ use util::NominalOp;\n \n use std::sort;\n \n-pub type ItemLtEqOp = @pure fn(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n+pub type ItemLtEqOp = @fn(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n \n type ItemLtEq = NominalOp<ItemLtEqOp>;\n \n@@ -59,7 +59,7 @@ fn fold_mod(\n \n #[test]\n fn test() {\n-    pure fn name_lteq(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n+    fn name_lteq(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         (*item1).name() <= (*item2).name()\n     }\n \n@@ -76,7 +76,7 @@ fn test() {\n \n #[test]\n fn should_be_stable() {\n-    pure fn always_eq(_item1: &doc::ItemTag, _item2: &doc::ItemTag) -> bool {\n+    fn always_eq(_item1: &doc::ItemTag, _item2: &doc::ItemTag) -> bool {\n         true\n     }\n "}, {"sha": "d76438dd89bc1e4d2ed392bd493e4d41838d64f9", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -123,7 +123,7 @@ pub fn Arena() -> Arena {\n }\n \n #[inline(always)]\n-pure fn round_up_to(base: uint, align: uint) -> uint {\n+fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n "}, {"sha": "ff026324404abbbb197c93e25d47f079a0ed3132", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,11 +13,11 @@ use core::str;\n use core::vec;\n \n pub trait ToBase64 {\n-    pure fn to_base64(&self) -> ~str;\n+    fn to_base64(&self) -> ~str;\n }\n \n impl ToBase64 for &'self [u8] {\n-    pure fn to_base64(&self) -> ~str {\n+    fn to_base64(&self) -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n         );\n@@ -70,17 +70,17 @@ impl ToBase64 for &'self [u8] {\n }\n \n impl ToBase64 for &'self str {\n-    pure fn to_base64(&self) -> ~str {\n+    fn to_base64(&self) -> ~str {\n         str::to_bytes(*self).to_base64()\n     }\n }\n \n pub trait FromBase64 {\n-    pure fn from_base64(&self) -> ~[u8];\n+    fn from_base64(&self) -> ~[u8];\n }\n \n impl FromBase64 for ~[u8] {\n-    pure fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> ~[u8] {\n         if self.len() % 4u != 0u { fail!(~\"invalid base64 length\"); }\n \n         let len = self.len();\n@@ -142,7 +142,7 @@ impl FromBase64 for ~[u8] {\n }\n \n impl FromBase64 for ~str {\n-    pure fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> ~[u8] {\n         str::to_bytes(*self).from_base64()\n     }\n }"}, {"sha": "309925e7cf9b48e2462770baf21bb620059dd600", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -53,16 +53,16 @@ pub mod BigDigit {\n     priv const hi_mask: uint = (-1 as uint) << bits;\n     priv const lo_mask: uint = (-1 as uint) >> bits;\n \n-    priv pure fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-    priv pure fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+    priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n-    pub pure fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n+    pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n-    pub pure fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n+    pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n }\n@@ -78,53 +78,53 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n-    pure fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n+    fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n }\n \n impl Ord for BigUint {\n-    pure fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n+    fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n+    fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n+    fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n }\n \n impl ToStr for BigUint {\n-    pure fn to_str(&self) -> ~str { self.to_str_radix(10) }\n+    fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigUint {\n-    static pure fn from_str(s: &str) -> Option<BigUint> {\n+    fn from_str(s: &str) -> Option<BigUint> {\n         BigUint::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n-    pure fn shl(&self, rhs: &uint) -> BigUint {\n+    fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n         return self.shl_unit(n_unit).shl_bits(n_bits);\n     }\n }\n \n impl Shr<uint, BigUint> for BigUint {\n-    pure fn shr(&self, rhs: &uint) -> BigUint {\n+    fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n         return self.shr_unit(n_unit).shr_bits(n_bits);\n     }\n }\n \n impl Zero for BigUint {\n-    static pure fn zero() -> BigUint { BigUint::new(~[]) }\n+    fn zero() -> BigUint { BigUint::new(~[]) }\n }\n \n impl One for BigUint {\n-    static pub pure fn one() -> BigUint { BigUint::new(~[1]) }\n+    pub fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Add<BigUint, BigUint> for BigUint {\n-    pure fn add(&self, other: &BigUint) -> BigUint {\n+    fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n@@ -143,7 +143,7 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n-    pure fn sub(&self, other: &BigUint) -> BigUint {\n+    fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n@@ -168,7 +168,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n }\n \n impl Mul<BigUint, BigUint> for BigUint {\n-    pure fn mul(&self, other: &BigUint) -> BigUint {\n+    fn mul(&self, other: &BigUint) -> BigUint {\n         if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n         let s_len = self.data.len(), o_len = other.data.len();\n@@ -200,7 +200,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n-        pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n+        fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n             if n == 1 { return copy *a; }\n \n@@ -216,14 +216,14 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod + [carry]);\n         }\n \n-        pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n+        fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n             return (BigUint::from_slice(vec::slice(a.data, mid,\n                                                    a.data.len())),\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n-        pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n+        fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n             match a.cmp(&b) {\n                 s if s < 0 => (s, b - a),\n                 s if s > 0 => (s, a - b),\n@@ -234,36 +234,36 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Div<BigUint, BigUint> for BigUint {\n-    pure fn div(&self, other: &BigUint) -> BigUint {\n+    fn div(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.divmod(other);\n         return d;\n     }\n }\n \n impl Modulo<BigUint, BigUint> for BigUint {\n-    pure fn modulo(&self, other: &BigUint) -> BigUint {\n+    fn modulo(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.divmod(other);\n         return m;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n-    pure fn neg(&self) -> BigUint { fail!() }\n+    fn neg(&self) -> BigUint { fail!() }\n }\n \n impl IntConvertible for BigUint {\n-    pure fn to_int(&self) -> int {\n+    fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n-    static pure fn from_int(n: int) -> BigUint {\n+    fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n pub impl BigUint {\n     /// Creates and initializes an BigUint.\n-    static pub pure fn new(v: ~[BigDigit]) -> BigUint {\n+    pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n \n@@ -274,7 +274,7 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    static pub pure fn from_uint(n: uint) -> BigUint {\n+    pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n             (0,  n0) => BigUint::new(~[n0]),\n@@ -283,18 +283,18 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    static pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n+    pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(vec::from_slice(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n-    static pub pure fn from_str_radix(s: &str, radix: uint)\n+    pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(str::to_bytes(s), radix)\n     }\n \n     /// Creates and initializes an BigUint.\n-    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+    pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n         let base_num: BigUint = BigUint::from_uint(base);\n@@ -316,10 +316,10 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn abs(&self) -> BigUint { copy *self }\n+    fn abs(&self) -> BigUint { copy *self }\n \n     /// Compare two BigUint value.\n-    pure fn cmp(&self, other: &BigUint) -> int {\n+    fn cmp(&self, other: &BigUint) -> int {\n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len < o_len { return -1; }\n         if s_len > o_len { return  1;  }\n@@ -334,7 +334,7 @@ pub impl BigUint {\n         return 0;\n     }\n \n-    pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n@@ -355,7 +355,7 @@ pub impl BigUint {\n         let (d, m) = divmod_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n-        pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+        fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut r = a;\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n@@ -377,7 +377,7 @@ pub impl BigUint {\n             return (d, r);\n         }\n \n-        pure fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n+        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n                 return (Zero::zero(), Zero::zero(), copy *a);\n@@ -405,26 +405,26 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn quot(&self, other: &BigUint) -> BigUint {\n+    fn quot(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.quotrem(other);\n         return q;\n     }\n-    pure fn rem(&self, other: &BigUint) -> BigUint {\n+    fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.quotrem(other);\n         return r;\n     }\n-    pure fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.divmod(other)\n     }\n \n-    pure fn is_zero(&self) -> bool { self.data.is_empty() }\n-    pure fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n-    pure fn is_positive(&self) -> bool { self.is_not_zero() }\n-    pure fn is_negative(&self) -> bool { false }\n-    pure fn is_nonpositive(&self) -> bool { self.is_zero() }\n-    pure fn is_nonnegative(&self) -> bool { true }\n+    fn is_zero(&self) -> bool { self.data.is_empty() }\n+    fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n+    fn is_positive(&self) -> bool { self.is_not_zero() }\n+    fn is_negative(&self) -> bool { false }\n+    fn is_nonpositive(&self) -> bool { self.is_zero() }\n+    fn is_nonnegative(&self) -> bool { true }\n \n-    pure fn to_uint(&self) -> uint {\n+    fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n             1 => self.data[0] as uint,\n@@ -433,15 +433,15 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         fail_unless!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n         }\n         return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n-        pure fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n+        fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n             let mut r      = n;\n@@ -456,7 +456,7 @@ pub impl BigUint {\n             return result;\n         }\n \n-        pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n+        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let s = str::concat(vec::reversed(v).map(|n| {\n                 let s = uint::to_str_radix(*n as uint, radix);\n@@ -466,13 +466,13 @@ pub impl BigUint {\n         }\n     }\n \n-    priv pure fn shl_unit(self, n_unit: uint) -> BigUint {\n+    priv fn shl_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n-    priv pure fn shl_bits(self, n_bits: uint) -> BigUint {\n+    priv fn shl_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return self; }\n \n         let mut carry = 0;\n@@ -487,15 +487,15 @@ pub impl BigUint {\n         return BigUint::new(shifted + [carry]);\n     }\n \n-    priv pure fn shr_unit(self, n_unit: uint) -> BigUint {\n+    priv fn shr_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             vec::slice(self.data, n_unit, self.data.len())\n         );\n     }\n \n-    priv pure fn shr_bits(self, n_bits: uint) -> BigUint {\n+    priv fn shr_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return self; }\n \n         let mut borrow = 0;\n@@ -509,7 +509,7 @@ pub impl BigUint {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n@@ -534,7 +534,7 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n-priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),\n@@ -560,20 +560,20 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Eq for Sign {\n-    pure fn eq(&self, other: &Sign) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &Sign) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &Sign) -> bool { self.cmp(other) == 0 }\n+    fn ne(&self, other: &Sign) -> bool { self.cmp(other) != 0 }\n }\n \n impl Ord for Sign {\n-    pure fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n+    fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n+    fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n+    fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n }\n \n pub impl Sign {\n     /// Compare two Sign.\n-    pure fn cmp(&self, other: &Sign) -> int {\n+    fn cmp(&self, other: &Sign) -> int {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) =>  0,\n           (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => -1,\n@@ -582,7 +582,7 @@ pub impl Sign {\n     }\n \n     /// Negate Sign value.\n-    pure fn neg(&self) -> Sign {\n+    fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n           Zero  => Zero,\n@@ -598,53 +598,53 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-    pure fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n+    fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n }\n \n impl Ord for BigInt {\n-    pure fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n+    fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n+    fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n+    fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n }\n \n impl ToStr for BigInt {\n-    pure fn to_str(&self) -> ~str { self.to_str_radix(10) }\n+    fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigInt {\n-    static pure fn from_str(s: &str) -> Option<BigInt> {\n+    fn from_str(s: &str) -> Option<BigInt> {\n         BigInt::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n-    pure fn shl(&self, rhs: &uint) -> BigInt {\n+    fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n-    pure fn shr(&self, rhs: &uint) -> BigInt {\n+    fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-    static pub pure fn zero() -> BigInt {\n+    pub fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n }\n \n impl One for BigInt {\n-    static pub pure fn one() -> BigInt {\n+    pub fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n-    pure fn add(&self, other: &BigInt) -> BigInt {\n+    fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => copy *other,\n             (_,    Zero)   => copy *self,\n@@ -658,7 +658,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n-    pure fn sub(&self, other: &BigInt) -> BigInt {\n+    fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n             (_,    Zero) => copy *self,\n@@ -678,7 +678,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n-    pure fn mul(&self, other: &BigInt) -> BigInt {\n+    fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n             (Plus, Plus)  | (Minus, Minus) => {\n@@ -692,27 +692,27 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Div<BigInt, BigInt> for BigInt {\n-    pure fn div(&self, other: &BigInt) -> BigInt {\n+    fn div(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.divmod(other);\n         return d;\n     }\n }\n \n impl Modulo<BigInt, BigInt> for BigInt {\n-    pure fn modulo(&self, other: &BigInt) -> BigInt {\n+    fn modulo(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.divmod(other);\n         return m;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n-    pure fn neg(&self) -> BigInt {\n+    fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), copy self.data)\n     }\n }\n \n impl IntConvertible for BigInt {\n-    pure fn to_int(&self) -> int {\n+    fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n             Zero  => 0,\n@@ -721,7 +721,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n-    static pure fn from_int(n: int) -> BigInt {\n+    fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n         }\n@@ -736,37 +736,37 @@ impl IntConvertible for BigInt {\n \n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n-    static pub pure fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n+    pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n-    static pub pure fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n+    pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n         }\n         return BigInt { sign: sign, data: data };\n     }\n \n     /// Creates and initializes an BigInt.\n-    static pub pure fn from_uint(n: uint) -> BigInt {\n+    pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n-    static pub pure fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n+    pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n-    static pub pure fn from_str_radix(s: &str, radix: uint)\n+    pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n         BigInt::parse_bytes(str::to_bytes(s), radix)\n     }\n \n     /// Creates and initializes an BigInt.\n-    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+    pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n         let mut sign  = Plus;\n@@ -779,11 +779,11 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n-    pure fn abs(&self) -> BigInt {\n+    fn abs(&self) -> BigInt {\n         BigInt::from_biguint(Plus, copy self.data)\n     }\n \n-    pure fn cmp(&self, other: &BigInt) -> int {\n+    fn cmp(&self, other: &BigInt) -> int {\n         let ss = self.sign, os = other.sign;\n         if ss < os { return -1; }\n         if ss > os { return  1; }\n@@ -796,7 +796,7 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.divmod(&other.data);\n         let d = BigInt::from_biguint(Plus, d_ui),\n@@ -818,16 +818,16 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn quot(&self, other: &BigInt) -> BigInt {\n+    fn quot(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.quotrem(other);\n         return q;\n     }\n-    pure fn rem(&self, other: &BigInt) -> BigInt {\n+    fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.quotrem(other);\n         return r;\n     }\n \n-    pure fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (q_ui, r_ui) = self.data.quotrem(&other.data);\n         let q = BigInt::from_biguint(Plus, q_ui);\n@@ -841,22 +841,22 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn is_zero(&self) -> bool { self.sign == Zero }\n-    pure fn is_not_zero(&self) -> bool { self.sign != Zero }\n-    pure fn is_positive(&self) -> bool { self.sign == Plus }\n-    pure fn is_negative(&self) -> bool { self.sign == Minus }\n-    pure fn is_nonpositive(&self) -> bool { self.sign != Plus }\n-    pure fn is_nonnegative(&self) -> bool { self.sign != Minus }\n+    fn is_zero(&self) -> bool { self.sign == Zero }\n+    fn is_not_zero(&self) -> bool { self.sign != Zero }\n+    fn is_positive(&self) -> bool { self.sign == Plus }\n+    fn is_negative(&self) -> bool { self.sign == Minus }\n+    fn is_nonpositive(&self) -> bool { self.sign != Plus }\n+    fn is_nonnegative(&self) -> bool { self.sign != Minus }\n \n-    pure fn to_uint(&self) -> uint {\n+    fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n             Zero  => 0,\n             Minus => 0\n         }\n     }\n \n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n             Zero  => ~\"0\","}, {"sha": "270a2c1fc1b316c0c8b8b9e5ca854867b714a90e", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -27,7 +27,7 @@ fn small_mask(nbits: uint) -> uint {\n }\n \n pub impl SmallBitv {\n-    static fn new(bits: uint) -> SmallBitv {\n+    fn new(bits: uint) -> SmallBitv {\n         SmallBitv {bits: bits}\n     }\n \n@@ -62,7 +62,7 @@ pub impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    pure fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n@@ -124,7 +124,7 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n }\n \n pub impl BigBitv {\n-    static fn new(storage: ~[uint]) -> BigBitv {\n+    fn new(storage: ~[uint]) -> BigBitv {\n         BigBitv {storage: storage}\n     }\n \n@@ -181,7 +181,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    pure fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n@@ -256,7 +256,7 @@ priv impl Bitv {\n }\n \n pub impl Bitv {\n-    static fn new(nbits: uint, init: bool) -> Bitv {\n+    fn new(nbits: uint, init: bool) -> Bitv {\n         let rep = if nbits <= uint::bits {\n             Small(~SmallBitv::new(if init {!0} else {0}))\n         }\n@@ -299,7 +299,7 @@ pub impl Bitv {\n \n     /// Retrieve the value at index `i`\n     #[inline(always)]\n-    pure fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n        fail_unless!((i < self.nbits));\n        match self.rep {\n          Big(ref b)   => b.get(i),\n@@ -555,13 +555,13 @@ pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n }\n \n impl ops::Index<uint,bool> for Bitv {\n-    pure fn index(&self, i: uint) -> bool {\n+    fn index(&self, i: uint) -> bool {\n         self.get(i)\n     }\n }\n \n #[inline(always)]\n-pure fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n+fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n@@ -592,12 +592,12 @@ pub struct BitvSet {\n \n pub impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n-    static fn new() -> BitvSet {\n+    fn new() -> BitvSet {\n         BitvSet{ size: 0, bitv: BigBitv::new(~[0]) }\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n-    static fn from_bitv(bitv: Bitv) -> BitvSet {\n+    fn from_bitv(bitv: Bitv) -> BitvSet {\n         let mut size = 0;\n         for bitv.ones |_| {\n             size += 1;\n@@ -612,7 +612,7 @@ pub impl BitvSet {\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    pure fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+    fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n \n     /// Consumes this set to return the underlying bit vector\n     fn unwrap(self) -> Bitv {\n@@ -667,9 +667,9 @@ pub impl BitvSet {\n }\n \n impl BaseIter<uint> for BitvSet {\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    pure fn each(&self, blk: &fn(v: &uint) -> bool) {\n+    fn each(&self, blk: &fn(v: &uint) -> bool) {\n         for self.bitv.storage.eachi |i, &w| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return;\n@@ -679,7 +679,7 @@ impl BaseIter<uint> for BitvSet {\n }\n \n impl cmp::Eq for BitvSet {\n-    pure fn eq(&self, other: &BitvSet) -> bool {\n+    fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n             return false;\n         }\n@@ -696,12 +696,12 @@ impl cmp::Eq for BitvSet {\n         return true;\n     }\n \n-    pure fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n }\n \n impl Container for BitvSet {\n-    pure fn len(&const self) -> uint { self.size }\n-    pure fn is_empty(&const self) -> bool { self.size == 0 }\n+    fn len(&const self) -> uint { self.size }\n+    fn is_empty(&const self) -> bool { self.size == 0 }\n }\n \n impl Mutable for BitvSet {\n@@ -712,7 +712,7 @@ impl Mutable for BitvSet {\n }\n \n impl Set<uint> for BitvSet {\n-    pure fn contains(&self, value: &uint) -> bool {\n+    fn contains(&self, value: &uint) -> bool {\n         *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n     }\n \n@@ -748,14 +748,14 @@ impl Set<uint> for BitvSet {\n         return true;\n     }\n \n-    pure fn is_disjoint(&self, other: &BitvSet) -> bool {\n+    fn is_disjoint(&self, other: &BitvSet) -> bool {\n         for self.intersection(other) |_| {\n             return false;\n         }\n         return true;\n     }\n \n-    pure fn is_subset(&self, other: &BitvSet) -> bool {\n+    fn is_subset(&self, other: &BitvSet) -> bool {\n         for self.each_common(other) |_, w1, w2| {\n             if w1 & w2 != w1 {\n                 return false;\n@@ -774,11 +774,11 @@ impl Set<uint> for BitvSet {\n         return true;\n     }\n \n-    pure fn is_superset(&self, other: &BitvSet) -> bool {\n+    fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n-    pure fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return;\n@@ -790,7 +790,7 @@ impl Set<uint> for BitvSet {\n         );\n     }\n \n-    pure fn symmetric_difference(&self, other: &BitvSet,\n+    fn symmetric_difference(&self, other: &BitvSet,\n                                  f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n@@ -802,15 +802,15 @@ impl Set<uint> for BitvSet {\n         );\n     }\n \n-    pure fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n                 return;\n             }\n         }\n     }\n \n-    pure fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return;\n@@ -827,7 +827,7 @@ priv impl BitvSet {\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n-    pure fn each_common(&self, other: &BitvSet,\n+    fn each_common(&self, other: &BitvSet,\n                         f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n@@ -845,7 +845,7 @@ priv impl BitvSet {\n     /// The yielded arguments are a bool, the bit offset, and a word. The bool\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n-    pure fn each_outlier(&self, other: &BitvSet,\n+    fn each_outlier(&self, other: &BitvSet,\n                          f: &fn(bool, uint, uint) -> bool) {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();"}, {"sha": "1787be75e24d264183bdd84db7fe8253d9ff4e33", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -141,7 +141,7 @@ pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n  */\n \n /// Returns the length of the vector\n-pub pure fn len<T>(t: CVec<T>) -> uint { t.len }\n+pub fn len<T>(t: CVec<T>) -> uint { t.len }\n \n /// Returns a pointer to the first element of the vector\n pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }"}, {"sha": "6fd77de034262372d37969c02d94f358c3ed300f", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,36 +17,36 @@ use core::float;\n pub const FUZZY_EPSILON: float = 1.0e-6;\n \n pub trait FuzzyEq<Eps> {\n-    pure fn fuzzy_eq(&self, other: &Self) -> bool;\n-    pure fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n+    fn fuzzy_eq(&self, other: &Self) -> bool;\n+    fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n }\n \n impl FuzzyEq<float> for float {\n-    pure fn fuzzy_eq(&self, other: &float) -> bool {\n+    fn fuzzy_eq(&self, other: &float) -> bool {\n         self.fuzzy_eq_eps(other, &FUZZY_EPSILON)\n     }\n \n-    pure fn fuzzy_eq_eps(&self, other: &float, epsilon: &float) -> bool {\n+    fn fuzzy_eq_eps(&self, other: &float, epsilon: &float) -> bool {\n         float::abs(*self - *other) < *epsilon\n     }\n }\n \n impl FuzzyEq<f32> for f32 {\n-    pure fn fuzzy_eq(&self, other: &f32) -> bool {\n+    fn fuzzy_eq(&self, other: &f32) -> bool {\n         self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f32))\n     }\n \n-    pure fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n+    fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n         f32::abs(*self - *other) < *epsilon\n     }\n }\n \n impl FuzzyEq<f64> for f64 {\n-    pure fn fuzzy_eq(&self, other: &f64) -> bool {\n+    fn fuzzy_eq(&self, other: &f64) -> bool {\n         self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f64))\n     }\n \n-    pure fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n+    fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n         f64::abs(*self - *other) < *epsilon\n     }\n }\n@@ -71,11 +71,11 @@ mod test_complex{\n     struct Complex { r: float, i: float }\n \n     impl FuzzyEq<float> for Complex {\n-        pure fn fuzzy_eq(&self, other: &Complex) -> bool {\n+        fn fuzzy_eq(&self, other: &Complex) -> bool {\n             self.fuzzy_eq_eps(other, &FUZZY_EPSILON)\n         }\n \n-        pure fn fuzzy_eq_eps(&self, other: &Complex,\n+        fn fuzzy_eq_eps(&self, other: &Complex,\n                              epsilon: &float) -> bool {\n             self.r.fuzzy_eq_eps(&other.r, epsilon) &&\n             self.i.fuzzy_eq_eps(&other.i, epsilon)"}, {"sha": "9f68c6762228d14347ab2c88a88d6f3ad407d6b4", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -39,7 +39,7 @@ pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n     fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    pure fn peek(&self) -> bool {\n+    fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n@@ -67,13 +67,13 @@ impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n }\n \n impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n-    pure fn peek(&self) -> bool {\n+    fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n \n impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n-    pure fn header(&self) -> *pipes::PacketHeader {\n+    fn header(&self) -> *pipes::PacketHeader {\n         self.port.header()\n     }\n }"}, {"sha": "4f61321b4e777d749e7a455d5c7f5ee740d3a67c", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -25,10 +25,10 @@ pub struct Deque<T> {\n \n impl<T> Container for Deque<T> {\n     /// Return the number of elements in the deque\n-    pure fn len(&const self) -> uint { self.nelts }\n+    fn len(&const self) -> uint { self.nelts }\n \n     /// Return true if the deque contains no elements\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for Deque<T> {\n@@ -43,7 +43,7 @@ impl<T> Mutable for Deque<T> {\n \n pub impl<T> Deque<T> {\n     /// Create an empty Deque\n-    static pure fn new() -> Deque<T> {\n+    fn new() -> Deque<T> {\n         Deque{nelts: 0, lo: 0, hi: 0,\n               elts: vec::from_fn(initial_capacity, |_| None)}\n     }"}, {"sha": "437ab561f954576ab610c76c2b6b63a335ffbfb2", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -69,7 +69,7 @@ pub mod reader {\n     // ebml reading\n \n     impl ops::Index<uint,Doc> for Doc {\n-        pure fn index(&self, tag: uint) -> Doc {\n+        fn index(&self, tag: uint) -> Doc {\n             unsafe {\n                 get_doc(*self, tag)\n             }"}, {"sha": "9855e803ccbccdf18b9d6613ffa67713c05bcc51", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -314,7 +314,7 @@ impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n }\n \n pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n-    static fn new(u: U, p: P) -> FlatPort<T, U, P> {\n+    fn new(u: U, p: P) -> FlatPort<T, U, P> {\n         FlatPort {\n             unflattener: u,\n             byte_port: p\n@@ -323,7 +323,7 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n }\n \n pub impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n-    static fn new(f: F, c: C) -> FlatChan<T, F, C> {\n+    fn new(f: F, c: C) -> FlatChan<T, F, C> {\n         FlatChan {\n             flattener: f,\n             byte_chan: c\n@@ -376,15 +376,15 @@ pub mod flatteners {\n     }\n \n     pub impl<T:Copy + Owned> PodUnflattener<T> {\n-        static fn new() -> PodUnflattener<T> {\n+        fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n     pub impl<T:Copy + Owned> PodFlattener<T> {\n-        static fn new() -> PodFlattener<T> {\n+        fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()\n             }\n@@ -419,7 +419,7 @@ pub mod flatteners {\n     }\n \n     pub impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n-        static fn new(deserialize_buffer: DeserializeBuffer<T>)\n+        fn new(deserialize_buffer: DeserializeBuffer<T>)\n                    -> DeserializingUnflattener<D, T> {\n             DeserializingUnflattener {\n                 deserialize_buffer: deserialize_buffer\n@@ -428,7 +428,7 @@ pub mod flatteners {\n     }\n \n     pub impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n-        static fn new(serialize_value: SerializeValue<T>)\n+        fn new(serialize_value: SerializeValue<T>)\n                    -> SerializingFlattener<S, T> {\n             SerializingFlattener {\n                 serialize_value: serialize_value\n@@ -459,15 +459,15 @@ pub mod flatteners {\n     }\n \n     pub trait FromReader {\n-        static fn from_reader(r: @Reader) -> Self;\n+        fn from_reader(r: @Reader) -> Self;\n     }\n \n     pub trait FromWriter {\n-        static fn from_writer(w: @Writer) -> Self;\n+        fn from_writer(w: @Writer) -> Self;\n     }\n \n     impl FromReader for json::Decoder/&self {\n-        static fn from_reader(r: @Reader) -> json::Decoder/&self {\n+        fn from_reader(r: @Reader) -> json::Decoder/&self {\n             match json::from_reader(r) {\n                 Ok(json) => {\n                     json::Decoder(json)\n@@ -478,21 +478,21 @@ pub mod flatteners {\n     }\n \n     impl FromWriter for json::Encoder {\n-        static fn from_writer(w: @Writer) -> json::Encoder {\n+        fn from_writer(w: @Writer) -> json::Encoder {\n             json::Encoder(w)\n         }\n     }\n \n     impl FromReader for ebml::reader::Decoder {\n-        static fn from_reader(r: @Reader) -> ebml::reader::Decoder {\n+        fn from_reader(r: @Reader) -> ebml::reader::Decoder {\n             let buf = @r.read_whole_stream();\n             let doc = ebml::reader::Doc(buf);\n             ebml::reader::Decoder(doc)\n         }\n     }\n \n     impl FromWriter for ebml::writer::Encoder {\n-        static fn from_writer(w: @Writer) -> ebml::writer::Encoder {\n+        fn from_writer(w: @Writer) -> ebml::writer::Encoder {\n             ebml::writer::Encoder(w)\n         }\n     }\n@@ -543,15 +543,15 @@ pub mod bytepipes {\n     }\n \n     pub impl<R:Reader> ReaderBytePort<R> {\n-        static fn new(r: R) -> ReaderBytePort<R> {\n+        fn new(r: R) -> ReaderBytePort<R> {\n             ReaderBytePort {\n                 reader: r\n             }\n         }\n     }\n \n     pub impl<W:Writer> WriterByteChan<W> {\n-        static fn new(w: W) -> WriterByteChan<W> {\n+        fn new(w: W) -> WriterByteChan<W> {\n             WriterByteChan {\n                 writer: w\n             }\n@@ -606,7 +606,7 @@ pub mod bytepipes {\n     }\n \n     pub impl PipeBytePort {\n-        static fn new(p: Port<~[u8]>) -> PipeBytePort {\n+        fn new(p: Port<~[u8]>) -> PipeBytePort {\n             PipeBytePort {\n                 port: p,\n                 buf: ~[]\n@@ -615,7 +615,7 @@ pub mod bytepipes {\n     }\n \n     pub impl PipeByteChan {\n-        static fn new(c: Chan<~[u8]>) -> PipeByteChan {\n+        fn new(c: Chan<~[u8]>) -> PipeByteChan {\n             PipeByteChan {\n                 chan: c\n             }"}, {"sha": "29771fa350122670609518e1ec77599813f6a096", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -56,7 +56,7 @@ pub impl<A:Copy> Future<A> {\n \n pub impl<A> Future<A> {\n \n-    pure fn get_ref(&self) -> &'self A {\n+    fn get_ref(&self) -> &'self A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as"}, {"sha": "50d2eb6a7852189d02b683ff93042bf087b4e6c6", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,7 +17,7 @@ pub struct BufReader {\n }\n \n pub impl BufReader {\n-    static pub fn new(v: ~[u8]) -> BufReader {\n+    pub fn new(v: ~[u8]) -> BufReader {\n         BufReader {\n             buf: v,\n             pos: 0"}, {"sha": "0973e90dad3d2b5ddccbecef914007ba2458c5e1", "filename": "src/libstd/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -345,7 +345,7 @@ pub fn to_writer(wr: @io::Writer, json: &Json) {\n }\n \n /// Encodes a json value into a string\n-pub pure fn to_str(json: &Json) -> ~str {\n+pub fn to_str(json: &Json) -> ~str {\n     unsafe {\n         // ugh, should be safe\n         io::with_str_writer(|wr| to_writer(wr, json))\n@@ -947,7 +947,7 @@ impl serialize::Decoder for Decoder/&self {\n }\n \n impl Eq for Json {\n-    pure fn eq(&self, other: &Json) -> bool {\n+    fn eq(&self, other: &Json) -> bool {\n         match (self) {\n             &Number(f0) =>\n                 match other { &Number(f1) => f0 == f1, _ => false },\n@@ -980,12 +980,12 @@ impl Eq for Json {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &Json) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Json) -> bool { !self.eq(other) }\n }\n \n /// Test if two json values are less than one another\n impl Ord for Json {\n-    pure fn lt(&self, other: &Json) -> bool {\n+    fn lt(&self, other: &Json) -> bool {\n         match (*self) {\n             Number(f0) => {\n                 match *other {\n@@ -1055,18 +1055,18 @@ impl Ord for Json {\n             }\n         }\n     }\n-    pure fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n-    pure fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n-    pure fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n+    fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n+    fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n+    fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n }\n \n impl Eq for Error {\n-    pure fn eq(&self, other: &Error) -> bool {\n+    fn eq(&self, other: &Error) -> bool {\n         (*self).line == other.line &&\n         (*self).col == other.col &&\n         (*self).msg == other.msg\n     }\n-    pure fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n }\n \n trait ToJson { fn to_json(&self) -> Json; }\n@@ -1191,11 +1191,11 @@ impl<A:ToJson> ToJson for Option<A> {\n }\n \n impl to_str::ToStr for Json {\n-    pure fn to_str(&self) -> ~str { to_str(self) }\n+    fn to_str(&self) -> ~str { to_str(self) }\n }\n \n impl to_str::ToStr for Error {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }"}, {"sha": "b918f8505c80203fbfbb36a688b20554f0fd4555", "filename": "src/libstd/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,7 +22,7 @@ pub enum List<T> {\n }\n \n /// Create a list from a vector\n-pub pure fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n+pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n }\n \n@@ -52,7 +52,7 @@ pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n+pub fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -74,30 +74,30 @@ pub fn has<T:Copy + Eq>(ls: @List<T>, elt: T) -> bool {\n }\n \n /// Returns true if the list is empty\n-pub pure fn is_empty<T:Copy>(ls: @List<T>) -> bool {\n+pub fn is_empty<T:Copy>(ls: @List<T>) -> bool {\n     match *ls {\n         Nil => true,\n         _ => false\n     }\n }\n \n /// Returns the length of a list\n-pub pure fn len<T>(ls: @List<T>) -> uint {\n+pub fn len<T>(ls: @List<T>) -> uint {\n     let mut count = 0u;\n     iter(ls, |_e| count += 1u);\n     count\n }\n \n /// Returns all but the first element of a list\n-pub pure fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n+pub fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n         Nil => fail!(~\"list empty\")\n     }\n }\n \n /// Returns the first element of a list\n-pub pure fn head<T:Copy>(ls: @List<T>) -> T {\n+pub fn head<T:Copy>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(copy hd, _) => hd,\n       // makes me sad\n@@ -106,7 +106,7 @@ pub pure fn head<T:Copy>(ls: @List<T>) -> T {\n }\n \n /// Appends one list to another\n-pub pure fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n+pub fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n       Cons(copy x, xs) => {\n@@ -119,13 +119,13 @@ pub pure fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-pure fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n+fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */\n \n /// Iterate over a list\n-pub pure fn iter<T>(l: @List<T>, f: &fn(&T)) {\n+pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -139,7 +139,7 @@ pub pure fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n-pub pure fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n+pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {"}, {"sha": "e20ac624278f702fb20b5d0efae5e0b93b23ea02", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -19,7 +19,7 @@ struct Quad {\n     d: u32\n }\n \n-pub pure fn md4(msg: &[u8]) -> Quad {\n+pub fn md4(msg: &[u8]) -> Quad {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n@@ -45,7 +45,7 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n     let mut c = 0x98badcfeu32;\n     let mut d = 0x10325476u32;\n \n-    pure fn rot(r: int, x: u32) -> u32 {\n+    fn rot(r: int, x: u32) -> u32 {\n         let r = r as u32;\n         (x << r) | (x >> (32u32 - r))\n     }\n@@ -103,9 +103,9 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n     return Quad {a: a, b: b, c: c, d: d};\n }\n \n-pub pure fn md4_str(msg: &[u8]) -> ~str {\n+pub fn md4_str(msg: &[u8]) -> ~str {\n     let Quad {a, b, c, d} = md4(msg);\n-    pure fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n+    fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = ~\"\";\n@@ -121,7 +121,7 @@ pub pure fn md4_str(msg: &[u8]) -> ~str {\n     result\n }\n \n-pub pure fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n+pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {"}, {"sha": "21b60584635fcc9418cfc353ae8f21c59345fca3", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -45,7 +45,7 @@ struct UserInfo {\n pub type Query = ~[(~str, ~str)];\n \n pub impl Url {\n-    static pure fn new(\n+    fn new(\n         scheme: ~str,\n         user: Option<UserInfo>,\n         host: ~str,\n@@ -67,7 +67,7 @@ pub impl Url {\n }\n \n pub impl UserInfo {\n-    static pure fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+    fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }\n@@ -117,7 +117,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This function is compliant with RFC 3986.\n  */\n-pub pure fn encode(s: &str) -> ~str {\n+pub fn encode(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because encode_inner does (string) IO\n     unsafe {encode_inner(s, true)}\n }\n@@ -129,7 +129,7 @@ pub pure fn encode(s: &str) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n \n-pub pure fn encode_component(s: &str) -> ~str {\n+pub fn encode_component(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because encode_inner does (string) IO\n     unsafe {encode_inner(s, false)}\n }\n@@ -177,15 +177,15 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This will only decode escape sequences generated by encode.\n  */\n-pub pure fn decode(s: &str) -> ~str {\n+pub fn decode(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {decode_inner(s, true)}\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-pub pure fn decode_component(s: &str) -> ~str {\n+pub fn decode_component(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {decode_inner(s, false)}\n }\n@@ -297,7 +297,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n }\n \n \n-pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n+fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = str::len(s);\n     let mut index = len;\n     let mut mat = 0;\n@@ -324,7 +324,7 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     }\n }\n \n-pure fn userinfo_from_str(uinfo: &str) -> UserInfo {\n+fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n     let pass = if str::len(p) == 0 {\n         None\n@@ -334,14 +334,14 @@ pure fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     return UserInfo::new(user, pass);\n }\n \n-pure fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n+fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n     match userinfo.pass {\n         Some(ref pass) => fmt!(\"%s:%s@\", userinfo.user, *pass),\n         None => fmt!(\"%s@\", userinfo.user),\n     }\n }\n \n-pure fn query_from_str(rawquery: &str) -> Query {\n+fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n@@ -353,7 +353,7 @@ pure fn query_from_str(rawquery: &str) -> Query {\n     return query;\n }\n \n-pub pure fn query_to_str(query: &Query) -> ~str {\n+pub fn query_to_str(query: &Query) -> ~str {\n     unsafe {\n         // FIXME(#3722): unsafe only because decode_inner does (string) IO\n         let mut strvec = ~[];\n@@ -372,7 +372,7 @@ pub pure fn query_to_str(query: &Query) -> ~str {\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-pub pure fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n+pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n@@ -406,7 +406,7 @@ enum Input {\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-pure fn get_authority(rawurl: &str) ->\n+fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n@@ -534,7 +534,7 @@ pure fn get_authority(rawurl: &str) ->\n \n     let end = end; // make end immutable so it can be captured\n \n-    let host_is_end_plus_one: &pure fn() -> bool = || {\n+    let host_is_end_plus_one: &fn() -> bool = || {\n         end+1 == len\n             && !['?', '#', '/'].contains(&(rawurl[end] as char))\n     };\n@@ -573,7 +573,7 @@ pure fn get_authority(rawurl: &str) ->\n \n \n // returns the path and unparsed part of url, or an error\n-pure fn get_path(rawurl: &str, authority: bool) ->\n+fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n@@ -604,7 +604,7 @@ pure fn get_path(rawurl: &str, authority: bool) ->\n }\n \n // returns the parsed query and the fragment, if present\n-pure fn get_query_fragment(rawurl: &str) ->\n+fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n@@ -636,7 +636,7 @@ pure fn get_query_fragment(rawurl: &str) ->\n  *\n  */\n \n-pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n+pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n     // scheme\n     let (scheme, rest) = match get_scheme(rawurl) {\n         Ok(val) => val,\n@@ -666,7 +666,7 @@ pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n }\n \n impl FromStr for Url {\n-    static pure fn from_str(s: &str) -> Option<Url> {\n+    fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n             Ok(url) => Some(url),\n             Err(_) => None\n@@ -689,7 +689,7 @@ impl FromStr for Url {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-pub pure fn to_str(url: &Url) -> ~str {\n+pub fn to_str(url: &Url) -> ~str {\n     let user = match url.user {\n         Some(ref user) => userinfo_to_str(user),\n         None => ~\"\",\n@@ -716,13 +716,13 @@ pub pure fn to_str(url: &Url) -> ~str {\n }\n \n impl to_str::ToStr for Url {\n-    pub pure fn to_str(&self) -> ~str {\n+    pub fn to_str(&self) -> ~str {\n         to_str(self)\n     }\n }\n \n impl to_bytes::IterBytes for Url {\n-    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_str().iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "0b688f0c67861bb3a282616c177fd1492cfc5582", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -31,7 +31,7 @@ pub mod util {\n         den: int,\n     }\n \n-    pub pure fn rational_leq(x: Rational, y: Rational) -> bool {\n+    pub fn rational_leq(x: Rational, y: Rational) -> bool {\n         // NB: Uses the fact that rationals have positive denominators WLOG:\n \n         x.num * y.den <= y.num * x.den\n@@ -74,7 +74,7 @@ pub mod chained {\n     }\n \n     priv impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        pure fn search_rem(&self, k: &K, h: uint, idx: uint,\n+        fn search_rem(&self, k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n@@ -100,7 +100,7 @@ pub mod chained {\n             };\n         }\n \n-        pure fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n+        fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n             let idx = h % vec::uniq_len(&const self.chains);\n             match copy self.chains[idx] {\n               None => {\n@@ -134,7 +134,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        pure fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n+        fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n             let mut i = 0u, n = vec::uniq_len(&const self.chains);\n@@ -161,12 +161,12 @@ pub mod chained {\n     }\n \n     impl<K:Eq + IterBytes + Hash,V> Container for HashMap_<K, V> {\n-        pure fn len(&const self) -> uint { self.count }\n-        pure fn is_empty(&const self) -> bool { self.count == 0 }\n+        fn len(&const self) -> uint { self.count }\n+        fn is_empty(&const self) -> bool { self.count == 0 }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        pure fn contains_key(@self, k: &K) -> bool {\n+        fn contains_key(@self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n               NotFound => false,\n@@ -234,23 +234,23 @@ pub mod chained {\n             }\n         }\n \n-        pure fn each(@self, blk: &fn(key: &K, value: &V) -> bool) {\n+        fn each(@self, blk: &fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        pure fn each_key(@self, blk: &fn(key: &K) -> bool) {\n+        fn each_key(@self, blk: &fn(key: &K) -> bool) {\n             self.each(|k, _v| blk(k))\n         }\n \n-        pure fn each_value(@self, blk: &fn(value: &V) -> bool) {\n+        fn each_value(@self, blk: &fn(value: &V) -> bool) {\n             self.each(|_k, v| blk(v))\n         }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash + Copy,V:Copy> HashMap_<K, V> {\n-        pure fn find(&self, k: &K) -> Option<V> {\n+        fn find(&self, k: &K) -> Option<V> {\n             match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => None,\n               FoundFirst(_, entry) => Some(entry.value),\n@@ -314,7 +314,7 @@ pub mod chained {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n-        pure fn get(&self, k: &K) -> V {\n+        fn get(&self, k: &K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n                 fail!(fmt!(\"Key not found in table: %?\", k));\n@@ -348,7 +348,7 @@ pub mod chained {\n \n     impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> ToStr\n             for HashMap_<K, V> {\n-        pure fn to_str(&self) -> ~str {\n+        fn to_str(&self) -> ~str {\n             unsafe {\n                 // Meh -- this should be safe\n                 do io::with_str_writer |wr| { self.to_writer(wr) }\n@@ -358,7 +358,7 @@ pub mod chained {\n \n     impl<K:Eq + IterBytes + Hash + Copy,V:Copy> ops::Index<K, V>\n             for HashMap_<K, V> {\n-        pure fn index(&self, k: K) -> V {\n+        fn index(&self, k: K) -> V {\n             self.get(&k)\n         }\n     }\n@@ -391,7 +391,7 @@ pub fn set_add<K:Eq + IterBytes + Hash + Const + Copy>(set: Set<K>, key: K)\n }\n \n /// Convert a set into a vector.\n-pub pure fn vec_from_set<T:Eq + IterBytes + Hash + Copy>(s: Set<T>) -> ~[T] {\n+pub fn vec_from_set<T:Eq + IterBytes + Hash + Copy>(s: Set<T>) -> ~[T] {\n     do vec::build_sized(s.len()) |push| {\n         for s.each_key() |&k| {\n             push(k);\n@@ -422,8 +422,8 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         debug!(\"*** starting test_simple\");\n-        pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n-        pure fn uint_id(x: &uint) -> uint { *x }\n+        fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n+        fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n         let hm_uu: HashMap<uint, uint> =\n             HashMap::<uint, uint>();\n@@ -491,8 +491,8 @@ mod tests {\n     fn test_growth() {\n         debug!(\"*** starting test_growth\");\n         let num_to_insert: uint = 64u;\n-        pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n-        pure fn uint_id(x: &uint) -> uint { *x }\n+        fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n+        fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n         let hm_uu: HashMap<uint, uint> =\n             HashMap::<uint, uint>();"}, {"sha": "03d518f1f6300d714c60d1dc843cb75dd6151912", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -31,16 +31,16 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n-    pure fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n-    pure fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n+    fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n+    fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n \n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n-    pure fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n+    fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n \n     /// Returns true if a queue contains no elements\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T:Ord> Mutable for PriorityQueue<T> {\n@@ -50,15 +50,15 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    pure fn top(&self) -> &'self T { &self.data[0] }\n+    fn top(&self) -> &'self T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    pure fn maybe_top(&self) -> Option<&'self T> {\n+    fn maybe_top(&self) -> Option<&'self T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    pure fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    fn capacity(&self) -> uint { vec::capacity(&self.data) }\n \n     fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n \n@@ -102,11 +102,11 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Consume the PriorityQueue and return the underlying vector\n-    pure fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n+    fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n     /// (ascending) order\n-    pure fn to_sorted_vec(self) -> ~[T] {\n+    fn to_sorted_vec(self) -> ~[T] {\n         let mut q = self;\n         let mut end = q.len();\n         while end > 1 {\n@@ -118,10 +118,10 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Create an empty PriorityQueue\n-    static pure fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n+    fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n \n     /// Create a PriorityQueue from a vector (heapify)\n-    static pure fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n+    fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n         let mut q = PriorityQueue{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {"}, {"sha": "c9ad762880ca562141ef8310256aad0550996124", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -47,7 +47,7 @@ pub type Rope = node::Root;\n  */\n \n /// Create an empty rope\n-pub pure fn empty() -> Rope {\n+pub fn empty() -> Rope {\n    return node::Empty;\n }\n \n@@ -491,7 +491,7 @@ pub mod iterator {\n  *\n  * Constant time.\n  */\n-pub pure fn height(rope: Rope) -> uint {\n+pub fn height(rope: Rope) -> uint {\n    match (rope) {\n       node::Empty      => return 0u,\n       node::Content(x) => return node::height(x)\n@@ -507,7 +507,7 @@ pub pure fn height(rope: Rope) -> uint {\n  *\n  * Constant time.\n  */\n-pub pure fn char_len(rope: Rope) -> uint {\n+pub fn char_len(rope: Rope) -> uint {\n    match (rope) {\n      node::Empty            => return 0u,\n      node::Content(x)       => return node::char_len(x)\n@@ -521,7 +521,7 @@ pub pure fn char_len(rope: Rope) -> uint {\n  *\n  * Constant time.\n  */\n-pub pure fn byte_len(rope: Rope) -> uint {\n+pub fn byte_len(rope: Rope) -> uint {\n    match (rope) {\n      node::Empty            => return 0u,\n      node::Content(x)       => return node::byte_len(x)\n@@ -761,15 +761,15 @@ pub mod node {\n         }\n     }\n \n-    pub pure fn byte_len(node: @Node) -> uint {\n+    pub fn byte_len(node: @Node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         match (*node) {\n           Leaf(y) => y.byte_len,\n           Concat(ref y) => y.byte_len\n         }\n     }\n \n-    pub pure fn char_len(node: @Node) -> uint {\n+    pub fn char_len(node: @Node) -> uint {\n         match (*node) {\n           Leaf(y) => y.char_len,\n           Concat(ref y) => y.char_len\n@@ -1050,7 +1050,7 @@ pub mod node {\n         })\n     }\n \n-    pub pure fn height(node: @Node) -> uint {\n+    pub fn height(node: @Node) -> uint {\n         match (*node) {\n           Leaf(_) => 0u,\n           Concat(ref x) => x.height,\n@@ -1131,7 +1131,7 @@ pub mod node {\n      * proportional to the height of the rope + the (bounded)\n      * length of the largest leaf.\n      */\n-    pub pure fn char_at(node: @Node, pos: uint) -> char {\n+    pub fn char_at(node: @Node, pos: uint) -> char {\n         let mut node    = node;\n         let mut pos     = pos;\n         loop {"}, {"sha": "50579db47072b2edb2e7572f3bb1eeb12b0f8c09", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -27,7 +27,7 @@ pub enum Identifier {\n \n impl cmp::Ord for Identifier {\n     #[inline(always)]\n-    pure fn lt(&self, other: &Identifier) -> bool {\n+    fn lt(&self, other: &Identifier) -> bool {\n         match (self, other) {\n             (&Numeric(a), &Numeric(b)) => a < b,\n             (&Numeric(_), _) => true,\n@@ -36,22 +36,22 @@ impl cmp::Ord for Identifier {\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &Identifier) -> bool {\n+    fn le(&self, other: &Identifier) -> bool {\n         ! (other < self)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &Identifier) -> bool {\n+    fn gt(&self, other: &Identifier) -> bool {\n         other < self\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &Identifier) -> bool {\n+    fn ge(&self, other: &Identifier) -> bool {\n         ! (self < other)\n     }\n }\n \n impl ToStr for Identifier {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match self {\n             &Numeric(n) => n.to_str(),\n             &AlphaNumeric(ref s) => s.to_str()\n@@ -71,7 +71,7 @@ pub struct Version {\n \n impl ToStr for Version {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n         let s = if self.pre.is_empty() {\n             s\n@@ -88,7 +88,7 @@ impl ToStr for Version {\n \n impl cmp::Ord for Version {\n     #[inline(always)]\n-    pure fn lt(&self, other: &Version) -> bool {\n+    fn lt(&self, other: &Version) -> bool {\n \n         self.major < other.major ||\n \n@@ -121,15 +121,15 @@ impl cmp::Ord for Version {\n     }\n \n     #[inline(always)]\n-    pure fn le(&self, other: &Version) -> bool {\n+    fn le(&self, other: &Version) -> bool {\n         ! (other < self)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &Version) -> bool {\n+    fn gt(&self, other: &Version) -> bool {\n         other < self\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &Version) -> bool {\n+    fn ge(&self, other: &Version) -> bool {\n         ! (self < other)\n     }\n }"}, {"sha": "d288c06d2935cfc9c295850755f56884f2ca3c54", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -110,15 +110,15 @@ pub trait Encodable<S:Encoder> {\n }\n \n pub trait Decodable<D:Decoder> {\n-    static fn decode(&self, d: &D) -> Self;\n+    fn decode(d: &D) -> Self;\n }\n \n impl<S:Encoder> Encodable<S> for uint {\n     fn encode(&self, s: &S) { s.emit_uint(*self) }\n }\n \n impl<D:Decoder> Decodable<D> for uint {\n-    static fn decode(&self, d: &D) -> uint {\n+    fn decode(d: &D) -> uint {\n         d.read_uint()\n     }\n }\n@@ -128,7 +128,7 @@ impl<S:Encoder> Encodable<S> for u8 {\n }\n \n impl<D:Decoder> Decodable<D> for u8 {\n-    static fn decode(&self, d: &D) -> u8 {\n+    fn decode(d: &D) -> u8 {\n         d.read_u8()\n     }\n }\n@@ -138,7 +138,7 @@ impl<S:Encoder> Encodable<S> for u16 {\n }\n \n impl<D:Decoder> Decodable<D> for u16 {\n-    static fn decode(&self, d: &D) -> u16 {\n+    fn decode(d: &D) -> u16 {\n         d.read_u16()\n     }\n }\n@@ -148,7 +148,7 @@ impl<S:Encoder> Encodable<S> for u32 {\n }\n \n impl<D:Decoder> Decodable<D> for u32 {\n-    static fn decode(&self, d: &D) -> u32 {\n+    fn decode(d: &D) -> u32 {\n         d.read_u32()\n     }\n }\n@@ -158,7 +158,7 @@ impl<S:Encoder> Encodable<S> for u64 {\n }\n \n impl<D:Decoder> Decodable<D> for u64 {\n-    static fn decode(&self, d: &D) -> u64 {\n+    fn decode(d: &D) -> u64 {\n         d.read_u64()\n     }\n }\n@@ -168,7 +168,7 @@ impl<S:Encoder> Encodable<S> for int {\n }\n \n impl<D:Decoder> Decodable<D> for int {\n-    static fn decode(&self, d: &D) -> int {\n+    fn decode(d: &D) -> int {\n         d.read_int()\n     }\n }\n@@ -178,7 +178,7 @@ impl<S:Encoder> Encodable<S> for i8 {\n }\n \n impl<D:Decoder> Decodable<D> for i8 {\n-    static fn decode(&self, d: &D) -> i8 {\n+    fn decode(d: &D) -> i8 {\n         d.read_i8()\n     }\n }\n@@ -188,7 +188,7 @@ impl<S:Encoder> Encodable<S> for i16 {\n }\n \n impl<D:Decoder> Decodable<D> for i16 {\n-    static fn decode(&self, d: &D) -> i16 {\n+    fn decode(d: &D) -> i16 {\n         d.read_i16()\n     }\n }\n@@ -198,7 +198,7 @@ impl<S:Encoder> Encodable<S> for i32 {\n }\n \n impl<D:Decoder> Decodable<D> for i32 {\n-    static fn decode(&self, d: &D) -> i32 {\n+    fn decode(d: &D) -> i32 {\n         d.read_i32()\n     }\n }\n@@ -208,7 +208,7 @@ impl<S:Encoder> Encodable<S> for i64 {\n }\n \n impl<D:Decoder> Decodable<D> for i64 {\n-    static fn decode(&self, d: &D) -> i64 {\n+    fn decode(d: &D) -> i64 {\n         d.read_i64()\n     }\n }\n@@ -222,7 +222,7 @@ impl<S:Encoder> Encodable<S> for ~str {\n }\n \n impl<D:Decoder> Decodable<D> for ~str {\n-    static fn decode(&self, d: &D) -> ~str {\n+    fn decode(d: &D) -> ~str {\n         d.read_owned_str()\n     }\n }\n@@ -232,7 +232,7 @@ impl<S:Encoder> Encodable<S> for @str {\n }\n \n impl<D:Decoder> Decodable<D> for @str {\n-    static fn decode(&self, d: &D) -> @str {\n+    fn decode(d: &D) -> @str {\n         d.read_managed_str()\n     }\n }\n@@ -242,7 +242,7 @@ impl<S:Encoder> Encodable<S> for float {\n }\n \n impl<D:Decoder> Decodable<D> for float {\n-    static fn decode(&self, d: &D) -> float {\n+    fn decode(d: &D) -> float {\n         d.read_float()\n     }\n }\n@@ -252,7 +252,7 @@ impl<S:Encoder> Encodable<S> for f32 {\n }\n \n impl<D:Decoder> Decodable<D> for f32 {\n-    static fn decode(&self, d: &D) -> f32 {\n+    fn decode(d: &D) -> f32 {\n         d.read_f32() }\n }\n \n@@ -261,7 +261,7 @@ impl<S:Encoder> Encodable<S> for f64 {\n }\n \n impl<D:Decoder> Decodable<D> for f64 {\n-    static fn decode(&self, d: &D) -> f64 {\n+    fn decode(d: &D) -> f64 {\n         d.read_f64()\n     }\n }\n@@ -271,7 +271,7 @@ impl<S:Encoder> Encodable<S> for bool {\n }\n \n impl<D:Decoder> Decodable<D> for bool {\n-    static fn decode(&self, d: &D) -> bool {\n+    fn decode(d: &D) -> bool {\n         d.read_bool()\n     }\n }\n@@ -281,7 +281,7 @@ impl<S:Encoder> Encodable<S> for () {\n }\n \n impl<D:Decoder> Decodable<D> for () {\n-    static fn decode(&self, d: &D) -> () {\n+    fn decode(d: &D) -> () {\n         d.read_nil()\n     }\n }\n@@ -299,7 +299,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n-    static fn decode(&self, d: &D) -> ~T {\n+    fn decode(d: &D) -> ~T {\n         d.read_owned(|| ~Decodable::decode(d))\n     }\n }\n@@ -311,7 +311,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n-    static fn decode(&self, d: &D) -> @T {\n+    fn decode(d: &D) -> @T {\n         d.read_managed(|| @Decodable::decode(d))\n     }\n }\n@@ -337,7 +337,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n-    static fn decode(&self, d: &D) -> ~[T] {\n+    fn decode(d: &D) -> ~[T] {\n         do d.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n                 d.read_vec_elt(i, || Decodable::decode(d))\n@@ -357,7 +357,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n-    static fn decode(&self, d: &D) -> @[T] {\n+    fn decode(d: &D) -> @[T] {\n         do d.read_managed_vec |len| {\n             do at_vec::from_fn(len) |i| {\n                 d.read_vec_elt(i, || Decodable::decode(d))\n@@ -382,7 +382,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n-    static fn decode(&self, d: &D) -> Option<T> {\n+    fn decode(d: &D) -> Option<T> {\n         do d.read_enum(~\"option\") {\n             do d.read_enum_variant |i| {\n                 match i {\n@@ -410,7 +410,7 @@ impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n }\n \n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n-    static fn decode(&self, d: &D) -> (T0, T1) {\n+    fn decode(d: &D) -> (T0, T1) {\n         do d.read_tup(2) {\n             (\n                 d.read_tup_elt(0, || Decodable::decode(d)),\n@@ -445,7 +445,7 @@ impl<\n     T1: Decodable<D>,\n     T2: Decodable<D>\n > Decodable<D> for (T0, T1, T2) {\n-    static fn decode(&self, d: &D) -> (T0, T1, T2) {\n+    fn decode(d: &D) -> (T0, T1, T2) {\n         do d.read_tup(3) {\n             (\n                 d.read_tup_elt(0, || Decodable::decode(d)),\n@@ -484,7 +484,7 @@ impl<\n     T2: Decodable<D>,\n     T3: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3) {\n-    static fn decode(&self, d: &D) -> (T0, T1, T2, T3) {\n+    fn decode(d: &D) -> (T0, T1, T2, T3) {\n         do d.read_tup(4) {\n             (\n                 d.read_tup_elt(0, || Decodable::decode(d)),\n@@ -527,7 +527,7 @@ impl<\n     T3: Decodable<D>,\n     T4: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n-    static fn decode(&self, d: &D)\n+    fn decode(d: &D)\n       -> (T0, T1, T2, T3, T4) {\n         do d.read_tup(5) {\n             ("}, {"sha": "a559e7540d4146ce62cfcb39133f5d5b07143ab4", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,7 +24,7 @@ pub struct SmallIntMap<T> {\n \n impl<V> BaseIter<(uint, &'self V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, it: &fn(&(uint, &'self V)) -> bool) {\n+    fn each(&self, it: &fn(&(uint, &'self V)) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref elt) => if !it(&(i, elt)) { break },\n@@ -33,12 +33,12 @@ impl<V> BaseIter<(uint, &'self V)> for SmallIntMap<V> {\n         }\n     }\n \n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, it: &fn(&(uint, &'self V)) -> bool) {\n+    fn each_reverse(&self, it: &fn(&(uint, &'self V)) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(&(i - 1, elt)) { break },\n@@ -50,7 +50,7 @@ impl<V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n \n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n-    pure fn len(&const self) -> uint {\n+    fn len(&const self) -> uint {\n         let mut sz = 0;\n         for uint::range(0, vec::uniq_len(&const self.v)) |i| {\n             match self.v[i] {\n@@ -62,7 +62,7 @@ impl<V> Container for SmallIntMap<V> {\n     }\n \n     /// Return true if the map contains no elements\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<V> Mutable for SmallIntMap<V> {\n@@ -72,17 +72,17 @@ impl<V> Mutable for SmallIntMap<V> {\n \n impl<V> Map<uint, V> for SmallIntMap<V> {\n     /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &uint) -> bool {\n+    fn contains_key(&self, key: &uint) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n+    fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|&(k, _)| blk(&k))\n     }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n+    fn each_value(&self, blk: &fn(value: &V) -> bool) {\n         self.each(|&(_, v)| blk(v))\n     }\n \n@@ -97,7 +97,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    pure fn find(&self, key: &uint) -> Option<&'self V> {\n+    fn find(&self, key: &uint) -> Option<&'self V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -135,9 +135,9 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n \n pub impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n-    static pure fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+    fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n-    pure fn get(&self, key: &uint) -> &'self V {\n+    fn get(&self, key: &uint) -> &'self V {\n         self.find(key).expect(\"key not present\")\n     }\n }"}, {"sha": "8ab2c40116ad7b1b0d108c8e55ea465355a24022", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,15 +16,15 @@ use core::util;\n use core::vec::{len, push};\n use core::vec;\n \n-type Le<T> = &'self pure fn(v1: &T, v2: &T) -> bool;\n+type Le<T> = &'self fn(v1: &T, v2: &T) -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n  *\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub pure fn merge_sort<T:Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n+pub fn merge_sort<T:Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     unsafe {return merge_sort_(v, (0u, len(v)), le);}\n@@ -259,7 +259,7 @@ fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     }\n }\n \n-pure fn min_run_length(n: uint) -> uint {\n+fn min_run_length(n: uint) -> uint {\n     let mut n = n;\n     let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n \n@@ -290,7 +290,7 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n+fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     fail_unless!(size != 0 && hint < size);\n@@ -339,7 +339,7 @@ pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n     return ofs;\n }\n \n-pure fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n+fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     fail_unless!(size != 0 && hint < size);\n@@ -779,7 +779,7 @@ mod test_qsort {\n \n     pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n-        pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n+        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n         while i < len {\n@@ -844,7 +844,7 @@ mod tests {\n \n     pub fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n-        pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n         let v3 = merge_sort::<int>(v1, f);\n         let mut i = 0u;\n@@ -874,7 +874,7 @@ mod tests {\n \n     #[test]\n     pub fn test_merge_sort_mutable() {\n-        pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         fail_unless!(v2 == ~[1, 2, 3]);\n@@ -883,7 +883,7 @@ mod tests {\n     #[test]\n     pub fn test_merge_sort_stability() {\n         // tjc: funny that we have to use parens\n-        pure fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n+        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n             unsafe // to_lower is not pure...\n             {\n@@ -917,16 +917,16 @@ mod test_tim_sort {\n     }\n \n     impl Ord for CVal {\n-        pure fn lt(&self, other: &CVal) -> bool {\n+        fn lt(&self, other: &CVal) -> bool {\n             unsafe {\n                 let rng = rand::Rng();\n                 if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n             }\n             (*self).val < other.val\n         }\n-        pure fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        pure fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n+        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n+        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n+        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n@@ -982,10 +982,10 @@ mod test_tim_sort {\n     struct DVal { val: uint }\n \n     impl Ord for DVal {\n-        pure fn lt(&self, _x: &DVal) -> bool { true }\n-        pure fn le(&self, _x: &DVal) -> bool { true }\n-        pure fn gt(&self, _x: &DVal) -> bool { true }\n-        pure fn ge(&self, _x: &DVal) -> bool { true }\n+        fn lt(&self, _x: &DVal) -> bool { true }\n+        fn le(&self, _x: &DVal) -> bool { true }\n+        fn gt(&self, _x: &DVal) -> bool { true }\n+        fn ge(&self, _x: &DVal) -> bool { true }\n     }\n \n     #[test]\n@@ -1206,16 +1206,16 @@ mod big_tests {\n     }\n \n     impl Ord for LVal/&self {\n-        pure fn lt(&self, other: &'a LVal/&self) -> bool {\n+        fn lt(&self, other: &'a LVal/&self) -> bool {\n             (*self).val < other.val\n         }\n-        pure fn le(&self, other: &'a LVal/&self) -> bool {\n+        fn le(&self, other: &'a LVal/&self) -> bool {\n             (*self).val <= other.val\n         }\n-        pure fn gt(&self, other: &'a LVal/&self) -> bool {\n+        fn gt(&self, other: &'a LVal/&self) -> bool {\n             (*self).val > other.val\n         }\n-        pure fn ge(&self, other: &'a LVal/&self) -> bool {\n+        fn ge(&self, other: &'a LVal/&self) -> bool {\n             (*self).val >= other.val\n         }\n     }"}, {"sha": "16645f151ee8e399e07f891a7000e22c745884e6", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -43,9 +43,10 @@ pub impl<T> TaskPool<T> {\n     /// new scheduler with the given mode. The provided `init_fn_factory`\n     /// returns a function which, given the index of the task, should return\n     /// local data to be kept around in that task.\n-    static fn new(n_tasks: uint,\n-                  opt_sched_mode: Option<SchedMode>,\n-                  init_fn_factory: ~fn() -> ~fn(uint) -> T) -> TaskPool<T> {\n+    fn new(n_tasks: uint,\n+           opt_sched_mode: Option<SchedMode>,\n+           init_fn_factory: ~fn() -> ~fn(uint) -> T)\n+        -> TaskPool<T> {\n         fail_unless!(n_tasks >= 1);\n \n         let channels = do vec::from_fn(n_tasks) |i| {"}, {"sha": "7531992ae848546883eee3966f6c69f6d9a2a2b4", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -53,7 +53,7 @@ pub enum TestName {\n     DynTestName(~str)\n }\n impl ToStr for TestName {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match self {\n             &StaticTestName(s) => s.to_str(),\n             &DynTestName(s) => s.to_str()\n@@ -536,7 +536,7 @@ pub fn filter_tests(\n     };\n \n     // Sort the tests alphabetically\n-    pure fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n+    fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n         str::le(t1.desc.name.to_str(), t2.desc.name.to_str())\n     }\n     sort::quick_sort(filtered, lteq);"}, {"sha": "b46d58f891b6cbf51f9c99e2d71b5c6fde8a3445", "filename": "src/libstd/time.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -51,27 +51,27 @@ pub struct Timespec { sec: i64, nsec: i32 }\n  * nsec: 800_000_000_i32 }`.\n  */\n pub impl Timespec {\n-    static pure fn new(sec: i64, nsec: i32) -> Timespec {\n+    fn new(sec: i64, nsec: i32) -> Timespec {\n         fail_unless!(nsec >= 0 && nsec < NSEC_PER_SEC);\n         Timespec { sec: sec, nsec: nsec }\n     }\n }\n \n impl Eq for Timespec {\n-    pure fn eq(&self, other: &Timespec) -> bool {\n+    fn eq(&self, other: &Timespec) -> bool {\n         self.sec == other.sec && self.nsec == other.nsec\n     }\n-    pure fn ne(&self, other: &Timespec) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Timespec) -> bool { !self.eq(other) }\n }\n \n impl Ord for Timespec {\n-    pure fn lt(&self, other: &Timespec) -> bool {\n+    fn lt(&self, other: &Timespec) -> bool {\n         self.sec < other.sec ||\n             (self.sec == other.sec && self.nsec < other.nsec)\n     }\n-    pure fn le(&self, other: &Timespec) -> bool { !other.lt(self) }\n-    pure fn ge(&self, other: &Timespec) -> bool { !self.lt(other) }\n-    pure fn gt(&self, other: &Timespec) -> bool { !self.le(other) }\n+    fn le(&self, other: &Timespec) -> bool { !other.lt(self) }\n+    fn ge(&self, other: &Timespec) -> bool { !self.lt(other) }\n+    fn gt(&self, other: &Timespec) -> bool { !self.le(other) }\n }\n \n /**\n@@ -133,7 +133,7 @@ pub struct Tm {\n }\n \n impl Eq for Tm {\n-    pure fn eq(&self, other: &Tm) -> bool {\n+    fn eq(&self, other: &Tm) -> bool {\n         self.tm_sec == (*other).tm_sec &&\n         self.tm_min == (*other).tm_min &&\n         self.tm_hour == (*other).tm_hour &&\n@@ -147,10 +147,10 @@ impl Eq for Tm {\n         self.tm_zone == (*other).tm_zone &&\n         self.tm_nsec == (*other).tm_nsec\n     }\n-    pure fn ne(&self, other: &Tm) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Tm) -> bool { !self.eq(other) }\n }\n \n-pub pure fn empty_tm() -> Tm {\n+pub fn empty_tm() -> Tm {\n     Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n@@ -198,14 +198,14 @@ pub fn now() -> Tm {\n }\n \n /// Parses the time from the string according to the format string.\n-pub pure fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n+pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     // unsafe only because do_strptime is annoying to make pure\n     // (it does IO with a str_reader)\n     unsafe {do_strptime(s, format)}\n }\n \n /// Formats the time according to the format string.\n-pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n+pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     // unsafe only because do_strftime is annoying to make pure\n     // (it does IO with a str_reader)\n     unsafe { do_strftime(format, tm) }\n@@ -239,10 +239,10 @@ pub impl Tm {\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    pure fn ctime(&self) -> ~str { self.strftime(~\"%c\") }\n+    fn ctime(&self) -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n-    pure fn strftime(&self, format: &str) -> ~str {\n+    fn strftime(&self, format: &str) -> ~str {\n         strftime(format, self)\n     }\n \n@@ -252,7 +252,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    pure fn rfc822(&self) -> ~str {\n+    fn rfc822(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(~\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -266,7 +266,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    pure fn rfc822z(&self) -> ~str {\n+    fn rfc822z(&self) -> ~str {\n         self.strftime(~\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -276,7 +276,7 @@ pub impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    pure fn rfc3339(&self) -> ~str {\n+    fn rfc3339(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(~\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {"}, {"sha": "e42c65907244122ab887dbb42a1a4ffe8520da55", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -36,7 +36,7 @@ pub struct TreeMap<K, V> {\n }\n \n impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n-    pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n+    fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n         } else {\n@@ -53,11 +53,11 @@ impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n             true\n         }\n     }\n-    pure fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n }\n \n // Lexicographical comparison\n-pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n+fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n@@ -77,39 +77,39 @@ pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n \n impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     #[inline(always)]\n-    pure fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n+    fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n+    fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n+    fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n+    fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n+    fn each(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n         each(&self.root, f)\n     }\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<'self, K: TotalOrd, V>\n     ReverseIter<(&'self K, &'self V)>\n     for TreeMap<K, V>\n {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n+    fn each_reverse(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n-    pure fn len(&const self) -> uint { self.length }\n+    fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    pure fn is_empty(&const self) -> bool { self.root.is_none() }\n+    fn is_empty(&const self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n@@ -122,15 +122,15 @@ impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n \n impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &K) -> bool {\n+    fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n+    fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, f: &fn(&V) -> bool) {\n+    fn each_value(&self, f: &fn(&V) -> bool) {\n         self.each(|&(_, v)| f(v))\n     }\n \n@@ -140,7 +140,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&'self V> {\n+    fn find(&self, key: &K) -> Option<&'self V> {\n         let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n         loop {\n             match *current {\n@@ -176,21 +176,21 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n \n pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n-    static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all keys in reverse order\n-    pure fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n+    fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n         self.each_reverse(|&(k, _)| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    pure fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n+    fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n+    fn iter(&self) -> TreeMapIterator/&self<K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n@@ -242,45 +242,45 @@ pub struct TreeSet<T> {\n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: &fn(&T) -> bool) {\n+    fn each_reverse(&self, f: &fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     #[inline(always)]\n-    pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n+    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     #[inline(always)]\n-    pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n+    fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline(always)]\n-    pure fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n+    fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n     #[inline(always)]\n-    pure fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n+    fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n     #[inline(always)]\n-    pure fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n+    fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n     #[inline(always)]\n-    pure fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n+    fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     #[inline(always)]\n-    pure fn len(&const self) -> uint { self.map.len() }\n+    fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {\n@@ -292,7 +292,7 @@ impl<T: TotalOrd> Mutable for TreeSet<T> {\n impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n     #[inline(always)]\n-    pure fn contains(&self, value: &T) -> bool {\n+    fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n \n@@ -308,7 +308,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n-    pure fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+    fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n@@ -329,12 +329,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n     /// Return true if the set is a subset of another\n     #[inline(always)]\n-    pure fn is_subset(&self, other: &TreeSet<T>) -> bool {\n+    fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         other.is_superset(self)\n     }\n \n     /// Return true if the set is a superset of another\n-    pure fn is_superset(&self, other: &TreeSet<T>) -> bool {\n+    fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n@@ -361,7 +361,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    pure fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n+    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -393,7 +393,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n-    pure fn symmetric_difference(&self, other: &TreeSet<T>,\n+    fn symmetric_difference(&self, other: &TreeSet<T>,\n                                  f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -433,7 +433,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    pure fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n+    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -460,7 +460,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    pure fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n+    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -501,12 +501,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n pub impl <T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline(always)]\n-    static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+    fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n-    pure fn iter(&self) -> TreeSetIterator/&self<T> {\n+    fn iter(&self) -> TreeSetIterator/&self<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n }\n@@ -542,20 +542,20 @@ struct TreeNode<K, V> {\n \n pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     #[inline(always)]\n-    static pure fn new(key: K, value: V) -> TreeNode<K, V> {\n+    fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n-pure fn each<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n+fn each<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                              f: &fn(&(&'r K, &'r V)) -> bool) {\n     for node.each |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n+fn each_reverse<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                      f: &fn(&(&'r K, &'r V)) -> bool) {\n     for node.each |x| {\n         each_reverse(&x.right, f);"}, {"sha": "f22bdaff3a0fcd1070f11aa703aadbdcf25c1d01", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -173,12 +173,12 @@ pub mod icu {\n     }\n }\n \n-pub pure fn is_XID_start(c: char) -> bool {\n+pub fn is_XID_start(c: char) -> bool {\n     return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n \n-pub pure fn is_XID_continue(c: char) -> bool {\n+pub fn is_XID_continue(c: char) -> bool {\n     return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n@@ -188,7 +188,7 @@ Function: is_digit\n \n Returns true if a character is a digit.\n */\n-pub pure fn is_digit(c: char) -> bool {\n+pub fn is_digit(c: char) -> bool {\n     return icu::libicu::u_isdigit(c) == icu::TRUE;\n }\n \n@@ -197,7 +197,7 @@ Function: is_lower\n \n Returns true if a character is a lowercase letter.\n */\n-pub pure fn is_lower(c: char) -> bool {\n+pub fn is_lower(c: char) -> bool {\n     return icu::libicu::u_islower(c) == icu::TRUE;\n }\n \n@@ -206,7 +206,7 @@ Function: is_space\n \n Returns true if a character is space.\n */\n-pub pure fn is_space(c: char) -> bool {\n+pub fn is_space(c: char) -> bool {\n     return icu::libicu::u_isspace(c) == icu::TRUE;\n }\n \n@@ -215,7 +215,7 @@ Function: is_upper\n \n Returns true if a character is an uppercase letter.\n */\n-pub pure fn is_upper(c: char) -> bool {\n+pub fn is_upper(c: char) -> bool {\n     return icu::libicu::u_isupper(c) == icu::TRUE;\n }\n "}, {"sha": "b26b4b1c3330b52383af3177fb3da393891dda1e", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -106,7 +106,7 @@ struct WorkKey {\n \n impl to_bytes::IterBytes for WorkKey {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         let mut flag = true;\n         self.kind.iter_bytes(lsb0, |bytes| {flag = f(bytes); flag});\n         if !flag { return; }\n@@ -115,24 +115,24 @@ impl to_bytes::IterBytes for WorkKey {\n }\n \n impl cmp::Ord for WorkKey {\n-    pure fn lt(&self, other: &WorkKey) -> bool {\n+    fn lt(&self, other: &WorkKey) -> bool {\n         self.kind < other.kind ||\n             (self.kind == other.kind &&\n              self.name < other.name)\n     }\n-    pure fn le(&self, other: &WorkKey) -> bool {\n+    fn le(&self, other: &WorkKey) -> bool {\n         self.lt(other) || self.eq(other)\n     }\n-    pure fn ge(&self, other: &WorkKey) -> bool {\n+    fn ge(&self, other: &WorkKey) -> bool {\n         self.gt(other) || self.eq(other)\n     }\n-    pure fn gt(&self, other: &WorkKey) -> bool {\n+    fn gt(&self, other: &WorkKey) -> bool {\n         ! self.le(other)\n     }\n }\n \n pub impl WorkKey {\n-    static fn new(kind: &str, name: &str) -> WorkKey {\n+    fn new(kind: &str, name: &str) -> WorkKey {\n     WorkKey { kind: kind.to_owned(), name: name.to_owned() }\n     }\n }\n@@ -151,7 +151,7 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n }\n \n impl<D:Decoder> Decodable<D> for WorkMap {\n-    static fn decode(&self, d: &D) -> WorkMap {\n+    fn decode(d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = LinearMap::new();\n         for v.each |&(k, v)| {\n@@ -258,7 +258,7 @@ fn digest_file(path: &Path) -> ~str {\n \n pub impl Context {\n \n-    static fn new(db: @Mut<Database>,\n+    fn new(db: @Mut<Database>,\n                   lg: @Mut<Logger>,\n                   cfg: @json::Object) -> Context {\n         Context{db: db, logger: lg, cfg: cfg, freshness: LinearMap::new()}\n@@ -367,7 +367,7 @@ impl TPrep for @Mut<Prep> {\n pub impl<T:Owned +\n          Encodable<json::Encoder> +\n          Decodable<json::Decoder/&static>> Work<T> { // FIXME(#5121)\n-    static fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+    fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n }"}, {"sha": "c37d9d1c1c4f7ff72fc0f1014f52d7282679cfed", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -75,7 +75,7 @@ impl<S:Encoder> Encodable<S> for ident {\n }\n \n impl<D:Decoder> Decodable<D> for ident {\n-    static fn decode(d: &D) -> ident {\n+    fn decode(d: &D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n@@ -88,7 +88,7 @@ impl<D:Decoder> Decodable<D> for ident {\n }\n \n impl to_bytes::IterBytes for ident {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n@@ -274,7 +274,7 @@ pub enum binding_mode {\n }\n \n impl to_bytes::IterBytes for binding_mode {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bind_by_copy => 0u8.iter_bytes(lsb0, f),\n \n@@ -320,7 +320,7 @@ pub enum pat_ {\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n impl to_bytes::IterBytes for mutability {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -333,13 +333,13 @@ pub enum Abi {\n }\n \n impl to_bytes::IterBytes for Abi {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl ToStr for Abi {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             RustAbi => ~\"\\\"rust\\\"\"\n         }\n@@ -356,13 +356,13 @@ pub enum Sigil {\n }\n \n impl to_bytes::IterBytes for Sigil {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl ToStr for Sigil {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             BorrowedSigil => ~\"&\",\n             OwnedSigil => ~\"~\",\n@@ -440,7 +440,7 @@ pub enum inferable<T> {\n }\n \n impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>\n           to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n@@ -458,7 +458,7 @@ impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n pub enum rmode { by_ref, by_copy }\n \n impl to_bytes::IterBytes for rmode {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -796,13 +796,13 @@ pub enum trait_method {\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl ToStr for int_ty {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         ::ast_util::int_ty_to_str(*self)\n     }\n }\n \n impl to_bytes::IterBytes for int_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -813,13 +813,13 @@ impl to_bytes::IterBytes for int_ty {\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl ToStr for uint_ty {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         ::ast_util::uint_ty_to_str(*self)\n     }\n }\n \n impl to_bytes::IterBytes for uint_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -830,13 +830,13 @@ impl to_bytes::IterBytes for uint_ty {\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl ToStr for float_ty {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         ::ast_util::float_ty_to_str(*self)\n     }\n }\n \n impl to_bytes::IterBytes for float_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -872,7 +872,7 @@ pub enum Onceness {\n }\n \n impl ToStr for Onceness {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             Once => ~\"once\",\n             Many => ~\"many\"\n@@ -881,7 +881,7 @@ impl ToStr for Onceness {\n }\n \n impl to_bytes::IterBytes for Onceness {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n@@ -930,7 +930,7 @@ pub enum ty_ {\n }\n \n impl to_bytes::IterBytes for Ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n@@ -966,7 +966,7 @@ pub enum purity {\n }\n \n impl ToStr for purity {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             impure_fn => ~\"impure\",\n             unsafe_fn => ~\"unsafe\",\n@@ -977,7 +977,7 @@ impl ToStr for purity {\n }\n \n impl to_bytes::IterBytes for purity {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -992,7 +992,7 @@ pub enum ret_style {\n }\n \n impl to_bytes::IterBytes for ret_style {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1278,7 +1278,7 @@ pub enum item_ {\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n impl to_bytes::IterBytes for struct_mutability {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "8989bb88cd7f469531186f80ce3a889b0f98a09b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -33,7 +33,7 @@ pub enum path_elt {\n }\n \n impl cmp::Eq for path_elt {\n-    pure fn eq(&self, other: &path_elt) -> bool {\n+    fn eq(&self, other: &path_elt) -> bool {\n         match (*self) {\n             path_mod(e0a) => {\n                 match (*other) {\n@@ -49,7 +49,7 @@ impl cmp::Eq for path_elt {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n }\n \n pub type path = ~[path_elt];"}, {"sha": "764393e0feb6e0a21adb38cedfdde6fc6fcc7bab", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,22 +24,21 @@ use core::str;\n use core::to_bytes;\n use core::vec;\n \n-pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n-                     -> ~str {\n+pub fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     str::connect(idents.map(|i| copy *intr.get(*i)), ~\"::\")\n }\n \n \n-pub pure fn path_to_ident(p: @path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: @path) -> ident { copy *p.idents.last() }\n \n-pub pure fn local_def(id: node_id) -> def_id {\n+pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n }\n \n-pub pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n+pub fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n-pub pure fn stmt_id(s: stmt) -> node_id {\n+pub fn stmt_id(s: stmt) -> node_id {\n     match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n@@ -57,7 +56,7 @@ pub fn variant_def_ids(d: def) -> (def_id, def_id) {\n     }\n }\n \n-pub pure fn def_id_of_def(d: def) -> def_id {\n+pub fn def_id_of_def(d: def) -> def_id {\n     match d {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n@@ -75,7 +74,7 @@ pub pure fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-pub pure fn binop_to_str(op: binop) -> ~str {\n+pub fn binop_to_str(op: binop) -> ~str {\n     match op {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n@@ -98,7 +97,7 @@ pub pure fn binop_to_str(op: binop) -> ~str {\n     }\n }\n \n-pub pure fn binop_to_method_name(op: binop) -> Option<~str> {\n+pub fn binop_to_method_name(op: binop) -> Option<~str> {\n     match op {\n       add => return Some(~\"add\"),\n       subtract => return Some(~\"sub\"),\n@@ -120,23 +119,23 @@ pub pure fn binop_to_method_name(op: binop) -> Option<~str> {\n     }\n }\n \n-pub pure fn lazy_binop(b: binop) -> bool {\n+pub fn lazy_binop(b: binop) -> bool {\n     match b {\n       and => true,\n       or => true,\n       _ => false\n     }\n }\n \n-pub pure fn is_shift_binop(b: binop) -> bool {\n+pub fn is_shift_binop(b: binop) -> bool {\n     match b {\n       shl => true,\n       shr => true,\n       _ => false\n     }\n }\n \n-pub pure fn unop_to_str(op: unop) -> ~str {\n+pub fn unop_to_str(op: unop) -> ~str {\n     match op {\n       box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n       uniq(mt) => if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" },\n@@ -146,11 +145,11 @@ pub pure fn unop_to_str(op: unop) -> ~str {\n     }\n }\n \n-pub pure fn is_path(e: @expr) -> bool {\n+pub fn is_path(e: @expr) -> bool {\n     return match e.node { expr_path(_) => true, _ => false };\n }\n \n-pub pure fn int_ty_to_str(t: int_ty) -> ~str {\n+pub fn int_ty_to_str(t: int_ty) -> ~str {\n     match t {\n       ty_char => ~\"u8\", // ???\n       ty_i => ~\"\",\n@@ -161,7 +160,7 @@ pub pure fn int_ty_to_str(t: int_ty) -> ~str {\n     }\n }\n \n-pub pure fn int_ty_max(t: int_ty) -> u64 {\n+pub fn int_ty_max(t: int_ty) -> u64 {\n     match t {\n       ty_i8 => 0x80u64,\n       ty_i16 => 0x8000u64,\n@@ -170,7 +169,7 @@ pub pure fn int_ty_max(t: int_ty) -> u64 {\n     }\n }\n \n-pub pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n+pub fn uint_ty_to_str(t: uint_ty) -> ~str {\n     match t {\n       ty_u => ~\"u\",\n       ty_u8 => ~\"u8\",\n@@ -180,7 +179,7 @@ pub pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n     }\n }\n \n-pub pure fn uint_ty_max(t: uint_ty) -> u64 {\n+pub fn uint_ty_max(t: uint_ty) -> u64 {\n     match t {\n       ty_u8 => 0xffu64,\n       ty_u16 => 0xffffu64,\n@@ -189,18 +188,18 @@ pub pure fn uint_ty_max(t: uint_ty) -> u64 {\n     }\n }\n \n-pub pure fn float_ty_to_str(t: float_ty) -> ~str {\n+pub fn float_ty_to_str(t: float_ty) -> ~str {\n     match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n-pub pure fn is_call_expr(e: @expr) -> bool {\n+pub fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(_, _, _) => true, _ => false }\n }\n \n // This makes def_id hashable\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n@@ -238,14 +237,14 @@ pub fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n                 span: s }\n }\n \n-pub pure fn is_unguarded(a: &arm) -> bool {\n+pub fn is_unguarded(a: &arm) -> bool {\n     match a.guard {\n       None => true,\n       _    => false\n     }\n }\n \n-pub pure fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n+pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n     if is_unguarded(a) { Some(/* FIXME (#2543) */ copy a.pats) } else { None }\n }\n \n@@ -290,7 +289,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     (reqd, provd)\n }\n \n-pub pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n+pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n     match field.node.kind {\n         ast::named_field(_, _, visibility) => visibility,\n         ast::unnamed_field => ast::public\n@@ -509,7 +508,7 @@ pub fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n     compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n }\n \n-pub pure fn is_item_impl(item: @ast::item) -> bool {\n+pub fn is_item_impl(item: @ast::item) -> bool {\n     match item.node {\n        item_impl(*) => true,\n        _            => false"}, {"sha": "b22d71afaed2dc72a485df537d2298c9cf58ee06", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -89,11 +89,11 @@ pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n \n /* Accessors */\n \n-pub pure fn get_attr_name(attr: &ast::attribute) -> @~str {\n+pub fn get_attr_name(attr: &ast::attribute) -> @~str {\n     get_meta_item_name(attr.node.value)\n }\n \n-pub pure fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n+pub fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n     match meta.node {\n         ast::meta_word(n) => n,\n         ast::meta_name_value(n, _) => n,\n@@ -333,10 +333,10 @@ pub enum inline_attr {\n }\n \n impl cmp::Eq for inline_attr {\n-    pure fn eq(&self, other: &inline_attr) -> bool {\n+    fn eq(&self, other: &inline_attr) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n }\n \n /// True if something like #[inline] is found in the list of attrs."}, {"sha": "c082f4c08385038870adbfb1cda01bd4c59173e1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -30,8 +30,8 @@ use core::uint;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n pub trait Pos {\n-    static pure fn from_uint(n: uint) -> Self;\n-    pure fn to_uint(&self) -> uint;\n+    fn from_uint(n: uint) -> Self;\n+    fn to_uint(&self) -> uint;\n }\n \n /// A byte offset\n@@ -45,71 +45,71 @@ pub struct CharPos(uint);\n // have been unsuccessful\n \n impl Pos for BytePos {\n-    static pure fn from_uint(n: uint) -> BytePos { BytePos(n) }\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn from_uint(n: uint) -> BytePos { BytePos(n) }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl cmp::Eq for BytePos {\n-    pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n-    pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n+    fn eq(&self, other: &BytePos) -> bool { **self == **other }\n+    fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Ord for BytePos {\n-    pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n-    pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n-    pure fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n-    pure fn gt(&self, other: &BytePos) -> bool { **self > **other }\n+    fn lt(&self, other: &BytePos) -> bool { **self < **other }\n+    fn le(&self, other: &BytePos) -> bool { **self <= **other }\n+    fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n+    fn gt(&self, other: &BytePos) -> bool { **self > **other }\n }\n \n impl Add<BytePos, BytePos> for BytePos {\n-    pure fn add(&self, rhs: &BytePos) -> BytePos {\n+    fn add(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self + **rhs)\n     }\n }\n \n impl Sub<BytePos, BytePos> for BytePos {\n-    pure fn sub(&self, rhs: &BytePos) -> BytePos {\n+    fn sub(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self - **rhs)\n     }\n }\n \n impl to_bytes::IterBytes for BytePos {\n-    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl Pos for CharPos {\n-    static pure fn from_uint(n: uint) -> CharPos { CharPos(n) }\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn from_uint(n: uint) -> CharPos { CharPos(n) }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl cmp::Eq for CharPos {\n-    pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n-    pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n+    fn eq(&self, other: &CharPos) -> bool { **self == **other }\n+    fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Ord for CharPos {\n-    pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n-    pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n-    pure fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n-    pure fn gt(&self, other: &CharPos) -> bool { **self > **other }\n+    fn lt(&self, other: &CharPos) -> bool { **self < **other }\n+    fn le(&self, other: &CharPos) -> bool { **self <= **other }\n+    fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n+    fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n impl to_bytes::IterBytes for CharPos {\n-    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl Add<CharPos,CharPos> for CharPos {\n-    pure fn add(&self, rhs: &CharPos) -> CharPos {\n+    fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self + **rhs)\n     }\n }\n \n impl Sub<CharPos,CharPos> for CharPos {\n-    pure fn sub(&self, rhs: &CharPos) -> CharPos {\n+    fn sub(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self - **rhs)\n     }\n }\n@@ -132,10 +132,10 @@ pub struct span {\n pub struct spanned<T> { node: T, span: span }\n \n impl cmp::Eq for span {\n-    pure fn eq(&self, other: &span) -> bool {\n+    fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n-    pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n impl<S:Encoder> Encodable<S> for span {\n@@ -144,30 +144,30 @@ impl<S:Encoder> Encodable<S> for span {\n }\n \n impl<D:Decoder> Decodable<D> for span {\n-    static fn decode(_d: &D) -> span {\n+    fn decode(_d: &D) -> span {\n         dummy_sp()\n     }\n }\n \n-pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+pub fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n \n-pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+pub fn respan<T>(sp: span, +t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n-pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+pub fn dummy_spanned<T>(+t: T) -> spanned<T> {\n     respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */\n-pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+pub fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n     span {lo: lo, hi: hi, expn_info: None}\n }\n \n // make this a const, once the compiler supports it\n-pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n+pub fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n \n \n \n@@ -286,7 +286,7 @@ pub struct CodeMap {\n }\n \n pub impl CodeMap {\n-    static pub fn new() -> CodeMap {\n+    pub fn new() -> CodeMap {\n         CodeMap {\n             files: @mut ~[],\n         }"}, {"sha": "54ca5dc0d72f78ae152eaafc7cbaa44191933f7d", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -32,7 +32,7 @@ impl<S:std::serialize::Encoder> Encodable<S> for Node {\n }\n \n impl<D:Decoder> Decodable for node_id {\n-    static fn decode(d: &D) -> Node {\n+    fn decode(d: &D) -> Node {\n         do d.read_struct(\"Node\", 1) {\n             Node {\n                 id: d.read_field(~\"x\", 0, || decode(d))\n@@ -66,7 +66,7 @@ would yield functions like:\n         D: Decoder,\n         T: Decodable<D>\n     > spanned<T>: Decodable<D> {\n-        static fn decode(d: &D) -> spanned<T> {\n+        fn decode(d: &D) -> spanned<T> {\n             do d.read_rec {\n                 {\n                     node: d.read_field(~\"node\", 0, || decode(d)),"}, {"sha": "d93a997213da20a9a405bc7ed7c67b84eb0e3e41", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -231,7 +231,7 @@ pub trait ext_ctxt {\n     fn span_bug(@mut self, sp: span, msg: &str) -> !;\n     fn bug(@mut self, msg: &str) -> !;\n     fn next_id(@mut self) -> ast::node_id;\n-    pure fn trace_macros(@mut self) -> bool;\n+    fn trace_macros(@mut self) -> bool;\n     fn set_trace_macros(@mut self, x: bool);\n     /* for unhygienic identifier transformation */\n     fn str_of(@mut self, id: ast::ident) -> ~str;\n@@ -310,7 +310,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, +cfg: ast::crate_cfg)\n         fn next_id(@mut self) -> ast::node_id {\n             return parse::next_node_id(self.parse_sess);\n         }\n-        pure fn trace_macros(@mut self) -> bool {\n+        fn trace_macros(@mut self) -> bool {\n             self.trace_mac\n         }\n         fn set_trace_macros(@mut self, x: bool) {\n@@ -439,7 +439,7 @@ pub enum MapChain<K,V> {\n impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // Constructor. I don't think we need a zero-arg one.\n-    static fn new(+init: ~LinearMap<K,@V>) -> @mut MapChain<K,V> {\n+    fn new(+init: ~LinearMap<K,@V>) -> @mut MapChain<K,V> {\n         @mut BaseMapChain(init)\n     }\n \n@@ -464,7 +464,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n // traits just don't work anywhere...?\n //pub impl Map<Name,SyntaxExtension> for MapChain {\n \n-    pure fn contains_key (&self, key: &K) -> bool {\n+    fn contains_key (&self, key: &K) -> bool {\n         match *self {\n             BaseMapChain (ref map) => map.contains_key(key),\n             ConsMapChain (ref map,ref rest) =>\n@@ -475,11 +475,11 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n     // should each_key and each_value operate on shadowed\n     // names? I think not.\n     // delaying implementing this....\n-    pure fn each_key (&self, _f: &fn (&K)->bool) {\n+    fn each_key (&self, _f: &fn (&K)->bool) {\n         fail!(~\"unimplemented 2013-02-15T10:01\");\n     }\n \n-    pure fn each_value (&self, _f: &fn (&V) -> bool) {\n+    fn each_value (&self, _f: &fn (&V) -> bool) {\n         fail!(~\"unimplemented 2013-02-15T10:02\");\n     }\n "}, {"sha": "4a8ceedc8e3011135619ee6f44de620068a059b9", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -21,7 +21,7 @@ use core::to_str::ToStr;\n pub enum direction { send, recv }\n \n impl ToStr for direction {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n           send => ~\"Send\",\n           recv => ~\"Recv\""}, {"sha": "49076c74972f69cb5e07588614f416d86180dcef", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -79,7 +79,7 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n     return r;\n }\n \n-pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n+fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n         readme: @mut (copy *f.readme),\n         idx: f.idx,\n@@ -92,7 +92,7 @@ pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     }\n }\n \n-pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n+pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n         interner: r.interner,\n@@ -106,10 +106,10 @@ pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n }\n \n \n-pure fn lookup_cur_matched_by_matched(r: &mut TtReader,\n+fn lookup_cur_matched_by_matched(r: &mut TtReader,\n                                       start: @named_match)\n                                    -> @named_match {\n-    pure fn red(+ad: @named_match, idx: &uint) -> @named_match {\n+    fn red(+ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth"}, {"sha": "67c3d19dd0fb762be17e1cf3212f444cf42aca71", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -61,18 +61,18 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pure fn get(&self, i: uint) -> &'self T {\n+    fn get(&self, i: uint) -> &'self T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),\n             Vec(ref v) => &v[i]\n         }\n     }\n \n-    pure fn is_empty(&self) -> bool {\n+    fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n \n-    pure fn len(&self) -> uint {\n+    fn len(&self) -> uint {\n         match *self {\n             Empty => 0,\n             Vec(ref v) => v.len()\n@@ -105,7 +105,7 @@ impl<T:Copy> OptVec<T> {\n }\n \n impl<A:Eq> Eq for OptVec<A> {\n-    pure fn eq(&self, other: &OptVec<A>) -> bool {\n+    fn eq(&self, other: &OptVec<A>) -> bool {\n         // Note: cannot use #[deriving(Eq)] here because\n         // (Empty, Vec(~[])) ought to be equal.\n         match (self, other) {\n@@ -116,51 +116,51 @@ impl<A:Eq> Eq for OptVec<A> {\n         }\n     }\n \n-    pure fn ne(&self, other: &OptVec<A>) -> bool {\n+    fn ne(&self, other: &OptVec<A>) -> bool {\n         !self.eq(other)\n     }\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n-    pure fn each(&self, blk: &fn(v: &A) -> bool) {\n+    fn each(&self, blk: &fn(v: &A) -> bool) {\n         match *self {\n             Empty => {}\n             Vec(ref v) => v.each(blk)\n         }\n     }\n \n-    pure fn size_hint(&self) -> Option<uint> {\n+    fn size_hint(&self) -> Option<uint> {\n         Some(self.len())\n     }\n }\n \n impl<A> iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n+    fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n     #[inline(always)]\n-    pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n     #[inline(always)]\n-    pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n     #[inline(always)]\n-    pure fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n-    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n     #[inline(always)]\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n     #[inline(always)]\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n@@ -169,27 +169,27 @@ impl<A> iter::ExtendedIter<A> for OptVec<A> {\n \n impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     #[inline(always)]\n-    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     #[inline(always)]\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n     #[inline(always)]\n-    pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n impl<A: Copy+Ord> iter::CopyableOrderedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn min(&self) -> A { iter::min(self) }\n+    fn min(&self) -> A { iter::min(self) }\n     #[inline(always)]\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }"}, {"sha": "3f8a5588c7163eca060d2d4d40fd5d2437aeae53", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -35,10 +35,10 @@ pub enum cmnt_style {\n }\n \n impl cmp::Eq for cmnt_style {\n-    pure fn eq(&self, other: &cmnt_style) -> bool {\n+    fn eq(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &cmnt_style) -> bool {\n+    fn ne(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) != ((*other) as uint)\n     }\n }"}, {"sha": "ea599e8290a27c01137bb74311cb980403af3f1c", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -134,7 +134,7 @@ pub impl Parser {\n         }\n     }\n \n-    pure fn token_is_word(&self, word: &~str, tok: &token::Token) -> bool {\n+    fn token_is_word(&self, word: &~str, tok: &token::Token) -> bool {\n         match *tok {\n             token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n              _ => { false }"}, {"sha": "ffd2a1d801c960649e8d645c8cac6e227a904a76", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -32,7 +32,7 @@ pub trait reader {\n     fn next_token(@mut self) -> TokenAndSpan;\n     fn fatal(@mut self, ~str) -> !;\n     fn span_diag(@mut self) -> @span_handler;\n-    pure fn interner(@mut self) -> @token::ident_interner;\n+    fn interner(@mut self) -> @token::ident_interner;\n     fn peek(@mut self) -> TokenAndSpan;\n     fn dup(@mut self) -> @reader;\n }\n@@ -122,7 +122,7 @@ impl reader for StringReader {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n-    pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.peek_tok,\n@@ -139,7 +139,7 @@ impl reader for TtReader {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n     fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n-    pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.cur_tok,\n@@ -261,7 +261,7 @@ fn consume_whitespace_and_comments(rdr: @mut StringReader)\n     return consume_any_line_comment(rdr);\n }\n \n-pub pure fn is_line_non_doc_comment(s: &str) -> bool {\n+pub fn is_line_non_doc_comment(s: &str) -> bool {\n     s.trim_right().all(|ch| ch == '/')\n }\n \n@@ -313,7 +313,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n     return None;\n }\n \n-pub pure fn is_block_non_doc_comment(s: &str) -> bool {\n+pub fn is_block_non_doc_comment(s: &str) -> bool {\n     fail_unless!(s.len() >= 1u);\n     str::all_between(s, 1u, s.len() - 1u, |ch| ch == '*')\n }"}, {"sha": "65eb87fb83c05c693bb6bb15eb43b3d30ee2e55a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -63,7 +63,7 @@ pub enum ObsoleteSyntax {\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "7ee45eea0def23f77209e311aca275b6977e8a79", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -196,8 +196,8 @@ macro_rules! maybe_whole (\n )\n \n \n-pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n-                  -> ~[attribute] {\n+fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n+             -> ~[attribute] {\n     match rhs {\n         None => lhs,\n         Some(ref attrs) => vec::append(lhs, (*attrs))\n@@ -331,7 +331,7 @@ pub impl Parser {\n     }\n     fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n-    pure fn id_to_str(&self, id: ident) -> @~str {\n+    fn id_to_str(&self, id: ident) -> @~str {\n         self.sess.interner.get(id)\n     }\n "}, {"sha": "f5542fa81a6a988fd7881757be2269edfce6fa36", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -118,7 +118,7 @@ pub enum nonterminal {\n     nt_matchers(~[ast::matcher])\n }\n \n-pub pure fn binop_to_str(o: binop) -> ~str {\n+pub fn binop_to_str(o: binop) -> ~str {\n     match o {\n       PLUS => ~\"+\",\n       MINUS => ~\"-\",\n@@ -228,7 +228,7 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n     }\n }\n \n-pub pure fn can_begin_expr(t: &Token) -> bool {\n+pub fn can_begin_expr(t: &Token) -> bool {\n     match *t {\n       LPAREN => true,\n       LBRACE => true,\n@@ -286,22 +286,22 @@ pub fn is_lit(t: &Token) -> bool {\n     }\n }\n \n-pub pure fn is_ident(t: &Token) -> bool {\n+pub fn is_ident(t: &Token) -> bool {\n     match *t { IDENT(_, _) => true, _ => false }\n }\n \n-pub pure fn is_ident_or_path(t: &Token) -> bool {\n+pub fn is_ident_or_path(t: &Token) -> bool {\n     match *t {\n       IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n       _ => false\n     }\n }\n \n-pub pure fn is_plain_ident(t: &Token) -> bool {\n+pub fn is_plain_ident(t: &Token) -> bool {\n     match *t { IDENT(_, false) => true, _ => false }\n }\n \n-pub pure fn is_bar(t: &Token) -> bool {\n+pub fn is_bar(t: &Token) -> bool {\n     match *t { BINOP(OR) | OROR => true, _ => false }\n }\n \n@@ -366,7 +366,7 @@ pub impl ident_interner {\n     fn gensym(&self, val: @~str) -> ast::ident {\n         ast::ident { repr: self.interner.gensym(val) }\n     }\n-    pure fn get(&self, idx: ast::ident) -> @~str {\n+    fn get(&self, idx: ast::ident) -> @~str {\n         self.interner.get(idx.repr)\n     }\n     fn len(&self) -> uint {"}, {"sha": "ce12e0a7b875f75a799b53031fd6709fdc7fd878", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -2214,7 +2214,7 @@ pub fn opt_sigil_to_str(opt_p: Option<ast::Sigil>) -> ~str {\n     }\n }\n \n-pub pure fn purity_to_str(p: ast::purity) -> ~str {\n+pub fn purity_to_str(p: ast::purity) -> ~str {\n     match p {\n       ast::impure_fn => ~\"impure\",\n       ast::unsafe_fn => ~\"unsafe\",\n@@ -2223,7 +2223,7 @@ pub pure fn purity_to_str(p: ast::purity) -> ~str {\n     }\n }\n \n-pub pure fn onceness_to_str(o: ast::Onceness) -> ~str {\n+pub fn onceness_to_str(o: ast::Onceness) -> ~str {\n     match o {\n         ast::Once => ~\"once\",\n         ast::Many => ~\"many\""}, {"sha": "159a205637b59bcfb4db109229e258d1a0f3d939", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -22,14 +22,14 @@ pub struct Interner<T> {\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n-    static fn new() -> Interner<T> {\n+    fn new() -> Interner<T> {\n         Interner {\n             map: @mut LinearMap::new(),\n             vect: @mut ~[],\n         }\n     }\n \n-    static fn prefill(init: &[T]) -> Interner<T> {\n+    fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n         for init.each() |v| { rv.intern(*v); }\n         rv\n@@ -61,7 +61,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pure fn get(&self, idx: uint) -> T { self.vect[idx] }\n+    fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n     fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n }"}, {"sha": "9a778b18874141276b6c28dd2f6231f90a16b772", "filename": "src/test/auxiliary/anon_trait_static_method_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,7 +13,7 @@ pub struct Foo {\n }\n \n pub impl Foo {\n-    static fn new() -> Foo {\n+    fn new() -> Foo {\n         Foo { x: 3 }\n     }\n }"}, {"sha": "edda0644b16a6fc69be5e99104f7cc8000300dfb", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -18,7 +18,7 @@ pub mod kitty {\n     }\n \n     impl ToStr for cat {\n-       pure fn to_str(&self) -> ~str { copy self.name }\n+       fn to_str(&self) -> ~str { copy self.name }\n     }\n \n     priv impl cat {"}, {"sha": "c120a971c6b90fdbbff6638a0860b38ebbbbb172", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -25,11 +25,11 @@ pub enum e {\n \n pub fn nominal() -> e { e_val }\n \n-pub pure fn nominal_eq(e1: e, e2: e) -> bool { true }\n+pub fn nominal_eq(e1: e, e2: e) -> bool { true }\n \n impl Eq for e {\n-    pure fn eq(&self, other: &e) -> bool { nominal_eq(*self, *other) }\n-    pure fn ne(&self, other: &e) -> bool { !nominal_eq(*self, *other) }\n+    fn eq(&self, other: &e) -> bool { nominal_eq(*self, *other) }\n+    fn ne(&self, other: &e) -> bool { !nominal_eq(*self, *other) }\n }\n \n pub fn f() -> int { 10 }"}, {"sha": "230fdad04689179b4658de72423fae8dac6a121f", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -23,12 +23,12 @@ pub enum e {\n }\n \n impl Eq for e {\n-    pure fn eq(&self, other: &e) -> bool { !nominal_neq(*self, *other) }\n-    pure fn ne(&self, other: &e) -> bool { nominal_neq(*self, *other) }\n+    fn eq(&self, other: &e) -> bool { !nominal_neq(*self, *other) }\n+    fn ne(&self, other: &e) -> bool { nominal_neq(*self, *other) }\n }\n \n pub fn nominal() -> e { e_val }\n \n-pub pure fn nominal_neq(e1: e, e2: e) -> bool { false }\n+pub fn nominal_neq(e1: e, e2: e) -> bool { false }\n \n pub fn f() -> int { 20 }"}, {"sha": "0fa15fa14f61310dc36eafe2b86fa992bf55b3f1", "filename": "src/test/auxiliary/impl_privacy_xc_2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -7,8 +7,8 @@ pub struct Fish {\n mod unexported {\n     use super::Fish;\n     impl Eq for Fish {\n-        pure fn eq(&self, _: &Fish) -> bool { true }\n-        pure fn ne(&self, _: &Fish) -> bool { false }\n+        fn eq(&self, _: &Fish) -> bool { true }\n+        fn ne(&self, _: &Fish) -> bool { false }\n     }\n }\n "}, {"sha": "74c46a8b8c6b472f9380f0fa72841298c02c0b01", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,17 +14,17 @@\n #[crate_type = \"lib\"];\n \n pub trait read {\n-    static fn readMaybe(s: ~str) -> Option<Self>;\n+    fn readMaybe(s: ~str) -> Option<Self>;\n }\n \n impl read for int {\n-    static fn readMaybe(s: ~str) -> Option<int> {\n+    fn readMaybe(s: ~str) -> Option<int> {\n         int::from_str(s)\n     }\n }\n \n impl read for bool {\n-    static fn readMaybe(s: ~str) -> Option<bool> {\n+    fn readMaybe(s: ~str) -> Option<bool> {\n         match s {\n           ~\"true\" => Some(true),\n           ~\"false\" => Some(false),"}, {"sha": "b1bdfcfcffcb892f495586561a249d8bf59c0dd1", "filename": "src/test/auxiliary/static_fn_inline_xc_aux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fstatic_fn_inline_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fstatic_fn_inline_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_fn_inline_xc_aux.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,14 +11,14 @@\n \n pub mod num {\n     pub trait Num2 {\n-        static pure fn from_int2(n: int) -> Self;\n+        static fn from_int2(n: int) -> Self;\n     }\n }\n \n pub mod float {\n     impl ::num::Num2 for float {\n         #[inline]\n-        static pure fn from_int2(n: int) -> float { return n as float;  }\n+        static fn from_int2(n: int) -> float { return n as float;  }\n     }\n }\n "}, {"sha": "cc03ac38943045d23e307050a5559c34843aebab", "filename": "src/test/auxiliary/static_fn_trait_xc_aux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fstatic_fn_trait_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Fstatic_fn_trait_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_fn_trait_xc_aux.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -1,11 +1,11 @@\n pub mod num {\n     pub trait Num2 {\n-        static pure fn from_int2(n: int) -> Self;\n+        fn from_int2(n: int) -> Self;\n     }\n }\n \n pub mod float {\n     impl ::num::Num2 for float {\n-        static pure fn from_int2(n: int) -> float { return n as float;  }\n+        fn from_int2(n: int) -> float { return n as float;  }\n     }\n }"}, {"sha": "1b480ff17b330fd16c632d5293afc3ffe55effa3", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -18,24 +18,24 @@ pub struct MyInt {\n }\n \n impl Add<MyInt, MyInt> for MyInt {\n-    pure fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+    fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n impl Sub<MyInt, MyInt> for MyInt {\n-    pure fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n+    fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n impl Mul<MyInt, MyInt> for MyInt {\n-    pure fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n+    fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n impl Eq for MyInt {\n-    pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n+    fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n \n-    pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }\n \n impl MyNum for MyInt;\n \n-pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+fn mi(v: int) -> MyInt { MyInt { val: v } }\n "}, {"sha": "f0847b635b4bd285ee48f708457eaff2c64ec5d2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -27,14 +27,14 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   pure fn le_by_val<TT:Copy,UU:Copy + Ord>(kv0: &(TT,UU),\n+   fn le_by_val<TT:Copy,UU:Copy + Ord>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (_, v0) = *kv0;\n       let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   pure fn le_by_key<TT:Copy + Ord,UU:Copy>(kv0: &(TT,UU),\n+   fn le_by_key<TT:Copy + Ord,UU:Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (k0, _) = *kv0;\n       let (k1, _) = *kv1;"}, {"sha": "ada5ff7be2fa8461d2dc575e68f45e685f40c17d", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -33,7 +33,7 @@ struct cmplx {\n }\n \n impl ops::Mul<cmplx,cmplx> for cmplx {\n-    pure fn mul(&self, x: &cmplx) -> cmplx {\n+    fn mul(&self, x: &cmplx) -> cmplx {\n         cmplx {\n             re: self.re*(*x).re - self.im*(*x).im,\n             im: self.re*(*x).im + self.im*(*x).re\n@@ -42,7 +42,7 @@ impl ops::Mul<cmplx,cmplx> for cmplx {\n }\n \n impl ops::Add<cmplx,cmplx> for cmplx {\n-    pure fn add(&self, x: &cmplx) -> cmplx {\n+    fn add(&self, x: &cmplx) -> cmplx {\n         cmplx {\n             re: self.re + (*x).re,\n             im: self.im + (*x).im\n@@ -52,7 +52,7 @@ impl ops::Add<cmplx,cmplx> for cmplx {\n \n struct Line {i: uint, b: ~[u8]}\n \n-pure fn cabs(x: cmplx) -> f64\n+fn cabs(x: cmplx) -> f64\n {\n     x.re*x.re + x.im*x.im\n }"}, {"sha": "1e32697eb1073232af6f64ed844736a67dd3831c", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -40,11 +40,11 @@ struct Sudoku {\n }\n \n pub impl Sudoku {\n-    static pub fn new(g: grid) -> Sudoku {\n+    pub fn new(g: grid) -> Sudoku {\n         return Sudoku { grid: g }\n     }\n \n-    static pub fn from_vec(vec: &[[u8 * 9] * 9]) -> Sudoku {\n+    pub fn from_vec(vec: &[[u8 * 9] * 9]) -> Sudoku {\n         let mut g = do vec::from_fn(9u) |i| {\n             do vec::from_fn(9u) |j| { vec[i][j] }\n         };\n@@ -62,7 +62,7 @@ pub impl Sudoku {\n         return true;\n     }\n \n-    static pub fn read(reader: @io::Reader) -> Sudoku {\n+    pub fn read(reader: @io::Reader) -> Sudoku {\n         fail_unless!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n@@ -156,7 +156,7 @@ struct Colors(u16);\n const heads: u16 = (1u16 << 10) - 1; /* bits 9..0 */\n \n impl Colors {\n-    static fn new(start_color: u8) -> Colors {\n+    fn new(start_color: u8) -> Colors {\n         // Sets bits 9..start_color\n         let tails = !0u16 << start_color;\n         return Colors(heads & tails);"}, {"sha": "609e8de87d68b58cf3229c07baf90f71592f802e", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -20,9 +20,9 @@ fn main() {\n }\n \n trait MyIter {\n-    pure fn test_mut(&mut self);\n+    fn test_mut(&mut self);\n }\n \n impl MyIter for &'self [int] {\n-    pure fn test_mut(&mut self) { }\n+    fn test_mut(&mut self) { }\n }"}, {"sha": "482d1b6b8b617f6f9598f162a99a0ffa79c0b4d1", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,7 +13,7 @@\n struct foo(~uint);\n \n impl Add<foo, foo> for foo {\n-    pure fn add(f: &foo) -> foo {\n+    fn add(f: &foo) -> foo {\n         foo(~(**self + **(*f)))\n     }\n }"}, {"sha": "a4ad7e69b3336902745f2a30bc7669825227890b", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,7 +14,7 @@ struct Point {\n }\n \n impl ops::Add<int,int> for Point {\n-    pure fn add(&self, z: &int) -> int {\n+    fn add(&self, z: &int) -> int {\n         self.x + self.y + (*z)\n     }\n }"}, {"sha": "4473574926a34d85fe66b21fb8569337593c7c0a", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,7 +13,7 @@ struct point { x: int, y: int }\n trait methods {\n     fn impurem(&self);\n     fn blockm(&self, f: &fn());\n-    pure fn purem(&self);\n+    fn purem(&self);\n }\n \n impl methods for point {\n@@ -22,7 +22,7 @@ impl methods for point {\n \n     fn blockm(&self, f: &fn()) { f() }\n \n-    pure fn purem(&self) {\n+    fn purem(&self) {\n     }\n }\n "}, {"sha": "e931a8fa7e144fce3e4b2c475106c4224ca1fa24", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -10,8 +10,8 @@\n \n struct thing(uint);\n impl cmp::Ord for thing { //~ ERROR missing method `gt`\n-    pure fn lt(&self, other: &thing) -> bool { **self < **other }\n-    pure fn le(&self, other: &thing) -> bool { **self < **other }\n-    pure fn ge(&self, other: &thing) -> bool { **self < **other }\n+    fn lt(&self, other: &thing) -> bool { **self < **other }\n+    fn le(&self, other: &thing) -> bool { **self < **other }\n+    fn ge(&self, other: &thing) -> bool { **self < **other }\n }\n fn main() {}"}, {"sha": "2c8f94c4695b0192c07515fa3cb13eadf9dce82c", "filename": "src/test/compile-fail/issue-3707.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,10 +14,10 @@ struct Obj {\n }\n \n pub impl Obj {\n-    static pure fn boom() -> bool {\n+    fn boom() -> bool {\n         return 1+1 == 2\n     }\n-    pure fn chirp() {\n+    fn chirp() {\n         self.boom(); //~ ERROR wat\n     }\n }"}, {"sha": "68c00494b9b4d66023ba0337fd9cab0d4a432edb", "filename": "src/test/compile-fail/issue-3820.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3820.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3820.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3820.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,7 +14,7 @@ struct Thing {\n }\n \n impl Mul<int, Thing>*/ for Thing/* { //~ ERROR Look ma, no Mul!\n-    pure fn mul(c: &int) -> Thing {\n+    fn mul(c: &int) -> Thing {\n         Thing {x: self.x * *c}\n     }\n }"}, {"sha": "b726f090e7db74e6db9545275d039f7d56edf408", "filename": "src/test/compile-fail/issue-3953.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -25,8 +25,8 @@ struct Lol(int);\n impl Hahaha for Lol { }\n \n impl Eq for Lol {\n-    pure fn eq(&self, other: &Lol) -> bool { **self != **other }\n-    pure fn ne(&self, other: &Lol) -> bool { **self == **other }\n+    fn eq(&self, other: &Lol) -> bool { **self != **other }\n+    fn ne(&self, other: &Lol) -> bool { **self == **other }\n }\n \n fn main() {"}, {"sha": "60991d40a54c394ce50b69c50f0e24296270ae37", "filename": "src/test/compile-fail/issue-3969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -17,7 +17,7 @@ trait BikeMethods {\n }\n \n impl BikeMethods for Bike {\n-    static fn woops(&const self) -> ~str { ~\"foo\" }\n+    fn woops() -> ~str { ~\"foo\" }\n     //~^ ERROR method `woops` is declared as static in its impl, but not in its trait\n }\n "}, {"sha": "b1d741f9186b392a3a21ff4a692288f28983d866", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,11 +16,11 @@ struct Point {\n }\n \n impl ToStr for Point { //~ ERROR implements a method not defined in the trait\n-    static fn new(x: float, y: float) -> Point {\n+    fn new(x: float, y: float) -> Point {\n         Point { x: x, y: y }\n     }\n \n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"(%f, %f)\", self.x, self.y)\n     }\n }"}, {"sha": "67cf67bfa5a04de29c07c60c2ea8f617a008e039", "filename": "src/test/compile-fail/missing-derivable-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n trait MyEq {\n-    pure fn eq(&self, other: &Self) -> bool;\n+    fn eq(&self, other: &Self) -> bool;\n }\n \n struct A {\n     x: int\n }\n \n impl MyEq for int {\n-    pure fn eq(&self, other: &int) -> bool { *self == *other }\n+    fn eq(&self, other: &int) -> bool { *self == *other }\n }\n \n impl MyEq for A;  //~ ERROR missing method"}, {"sha": "50df4f04971c81835dcc38195edb30d3bc62f930", "filename": "src/test/compile-fail/static-method-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -1,7 +1,7 @@\n mod a {\n     pub struct S;\n     impl S {\n-        static fn new() -> S { S }\n+        fn new() -> S { S }\n     }\n }\n "}, {"sha": "719da233335e1db3190fb223c9eba744aa44f5ae", "filename": "src/test/compile-fail/staticness-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -10,7 +10,7 @@\n \n \n trait foo {\n-    static fn bar();\n+    fn bar();\n }\n \n impl foo for int {"}, {"sha": "296fba2ae9bcce3752db2007d0a85510e8152456", "filename": "src/test/run-fail/die-macro-pure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-fail%2Fdie-macro-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-fail%2Fdie-macro-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdie-macro-pure.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:test\n \n-pure fn f() {\n+fn f() {\n     fail!(~\"test\");\n }\n "}, {"sha": "a77d520b07e9583320320d33d7b7a8e83c9de418", "filename": "src/test/run-fail/if-check-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // error-pattern:Number is odd\n-pure fn even(x: uint) -> bool {\n+fn even(x: uint) -> bool {\n     if x < 2u {\n         return false;\n     } else if x == 2u { return true; } else { return even(x - 2u); }"}, {"sha": "8e11786786ff995043dab24103f1972e31fe3693", "filename": "src/test/run-pass/anon-trait-static-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,7 +13,7 @@ struct Foo {\n }\n \n pub impl Foo {\n-    static fn new() -> Foo {\n+    fn new() -> Foo {\n         Foo { x: 3 }\n     }\n }"}, {"sha": "1a8ad446c7954718ad35db0566147d5cde95b85e", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -60,7 +60,7 @@ enum Expr {\n }\n \n impl cmp::Eq for Expr {\n-    pure fn eq(&self, other: &Expr) -> bool {\n+    fn eq(&self, other: &Expr) -> bool {\n         match *self {\n             Val(e0a) => {\n                 match *other {\n@@ -82,18 +82,18 @@ impl cmp::Eq for Expr {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &Expr) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Expr) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for Point {\n-    pure fn eq(&self, other: &Point) -> bool {\n+    fn eq(&self, other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n     }\n-    pure fn ne(&self, other: &Point) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Point) -> bool { !(*self).eq(other) }\n }\n \n impl<T:cmp::Eq> cmp::Eq for Quark<T> {\n-    pure fn eq(&self, other: &Quark<T>) -> bool {\n+    fn eq(&self, other: &Quark<T>) -> bool {\n         match *self {\n             Top(ref q) => {\n                 match *other {\n@@ -109,14 +109,14 @@ impl<T:cmp::Eq> cmp::Eq for Quark<T> {\n             },\n         }\n     }\n-    pure fn ne(&self, other: &Quark<T>) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Quark<T>) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for CLike {\n-    pure fn eq(&self, other: &CLike) -> bool {\n+    fn eq(&self, other: &CLike) -> bool {\n         (*self) as int == *other as int\n     }\n-    pure fn ne(&self, other: &CLike) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &CLike) -> bool { !self.eq(other) }\n }\n \n #[auto_encode]"}, {"sha": "65366a350efa3716f2fd7100f9d272ab6d90ec08", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -12,18 +12,18 @@\n // and also references them to create the &self pointer\n \n trait MyIter {\n-    pure fn test_imm(&self);\n-    pure fn test_const(&const self);\n+    fn test_imm(&self);\n+    fn test_const(&const self);\n }\n \n impl MyIter for &'self [int] {\n-    pure fn test_imm(&self) { fail_unless!(self[0] == 1) }\n-    pure fn test_const(&const self) { fail_unless!(self[0] == 1) }\n+    fn test_imm(&self) { fail_unless!(self[0] == 1) }\n+    fn test_const(&const self) { fail_unless!(self[0] == 1) }\n }\n \n impl MyIter for &'self str {\n-    pure fn test_imm(&self) { fail_unless!(*self == \"test\") }\n-    pure fn test_const(&const self) { fail_unless!(*self == \"test\") }\n+    fn test_imm(&self) { fail_unless!(*self == \"test\") }\n+    fn test_const(&const self) { fail_unless!(*self == \"test\") }\n }\n \n pub fn main() {"}, {"sha": "40dd1a46574b1ce8961d9c95e755c54c5fa58e39", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,10 +16,10 @@ use core::iter::BaseIter;\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n impl cmp::Eq for cat_type {\n-    pure fn eq(&self, other: &cat_type) -> bool {\n+    fn eq(&self, other: &cat_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &cat_type) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &cat_type) -> bool { !(*self).eq(other) }\n }\n \n // Very silly -- this just returns the value of the name field\n@@ -50,34 +50,34 @@ pub impl<T> cat<T> {\n }\n \n impl<T> BaseIter<(int, &'self T)> for cat<T> {\n-    pure fn each(&self, f: &fn(&(int, &'self T)) -> bool) {\n+    fn each(&self, f: &fn(&(int, &'self T)) -> bool) {\n         let mut n = int::abs(self.meows);\n         while n > 0 {\n             if !f(&(n, &self.name)) { break; }\n             n -= 1;\n         }\n     }\n \n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T> Container for cat<T> {\n-    pure fn len(&const self) -> uint { self.meows as uint }\n-    pure fn is_empty(&const self) -> bool { self.meows == 0 }\n+    fn len(&const self) -> uint { self.meows as uint }\n+    fn is_empty(&const self) -> bool { self.meows == 0 }\n }\n \n impl<T> Mutable for cat<T> {\n     fn clear(&mut self) {}\n }\n \n impl<T> Map<int, T> for cat<T> {\n-    pure fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n+    fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    pure fn each_key(&self, f: &fn(v: &int) -> bool) {\n+    fn each_key(&self, f: &fn(v: &int) -> bool) {\n         for self.each |&(k, _)| { if !f(&k) { break; } loop;};\n     }\n \n-    pure fn each_value(&self, f: &fn(v: &T) -> bool) {\n+    fn each_value(&self, f: &fn(v: &T) -> bool) {\n         for self.each |&(_, v)| { if !f(v) { break; } loop;};\n     }\n \n@@ -90,7 +90,7 @@ impl<T> Map<int, T> for cat<T> {\n         true\n     }\n \n-    pure fn find(&self, k: &int) -> Option<&'self T> {\n+    fn find(&self, k: &int) -> Option<&'self T> {\n         if *k <= self.meows {\n             Some(&self.name)\n         } else {\n@@ -108,14 +108,14 @@ impl<T> Map<int, T> for cat<T> {\n }\n \n pub impl<T> cat<T> {\n-    pure fn get(&self, k: &int) -> &'self T {\n+    fn get(&self, k: &int) -> &'self T {\n         match self.find(k) {\n           Some(v) => { v }\n           None    => { fail!(~\"epic fail\"); }\n         }\n     }\n \n-    static pure fn new(in_x: int, in_y: int, in_name: T) -> cat<T> {\n+    fn new(in_x: int, in_y: int, in_name: T) -> cat<T> {\n         cat{meows: in_x, how_hungry: in_y, name: in_name }\n     }\n }"}, {"sha": "168f2d872e7373606c5831f3682913d198ea9f3d", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -51,7 +51,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n impl ToStr for cat {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // FIXME #5384: this unsafe block is to work around purity\n         unsafe {\n             self.name.clone()"}, {"sha": "e40272bb7a4d546ba5ea59efb7beb3add3908720", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -1,4 +1,4 @@\n-pure fn negate(x: &int) -> int {\n+fn negate(x: &int) -> int {\n     -*x\n }\n "}, {"sha": "12ca00fedd3f9b729c7579b0426fea1b8f050777", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -3,7 +3,7 @@ struct SpeechMaker {\n }\n \n pub impl SpeechMaker {\n-    pure fn how_many(&const self) -> uint { self.speeches }\n+    fn how_many(&const self) -> uint { self.speeches }\n }\n \n fn foo(speaker: &const SpeechMaker) -> uint {"}, {"sha": "ad5eb50ccef306f85a330fe51e4ce98fc4d30c0b", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -1,6 +1,6 @@\n // xfail-test\n \n-pure fn sum(x: &[int]) -> int {\n+fn sum(x: &[int]) -> int {\n     let mut sum = 0;\n     for x.each |y| { sum += *y; }\n     return sum;"}, {"sha": "7643799df0637fe2feedbc18f9700789e9d28c8e", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,9 +11,9 @@\n pub fn main() {\n     enum x { foo }\n     impl ::core::cmp::Eq for x {\n-        pure fn eq(&self, other: &x) -> bool {\n+        fn eq(&self, other: &x) -> bool {\n             (*self) as int == (*other) as int\n         }\n-        pure fn ne(&self, other: &x) -> bool { !(*self).eq(other) }\n+        fn ne(&self, other: &x) -> bool { !(*self).eq(other) }\n     }\n }"}, {"sha": "38854abff47f104d93339a2cc24780a17935bd2f", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -130,9 +130,9 @@ mod test_methods {\n \n     impl Fooable for Foo {\n         #[cfg(bogus)]\n-        static fn what(&self) { }\n+        fn what(&self) { }\n \n-        static fn what(&self) { }\n+        fn what(&self) { }\n \n         #[cfg(bogus)]\n         fn the(&self) { }\n@@ -142,9 +142,9 @@ mod test_methods {\n \n     trait Fooable {\n         #[cfg(bogus)]\n-        static fn what(&self);\n+        fn what(&self);\n \n-        static fn what(&self);\n+        fn what(&self);\n \n         #[cfg(bogus)]\n         fn the(&self);"}, {"sha": "f2b5be4e36ff9e09081efdea7d673a21034c5bb2", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -12,12 +12,12 @@\n struct foo { a: int, b: int, c: int }\n \n impl cmp::Eq for foo {\n-    pure fn eq(&self, other: &foo) -> bool {\n+    fn eq(&self, other: &foo) -> bool {\n         (*self).a == (*other).a &&\n         (*self).b == (*other).b &&\n         (*self).c == (*other).c\n     }\n-    pure fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n }\n \n const x : foo = foo { a:1, b:2, c: 3 };"}, {"sha": "08056f59acd3f3e0bf000bd8fa03781b66824c3a", "filename": "src/test/run-pass/do-pure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fdo-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fdo-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-pure.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pure fn f(f: &fn()) {\n+fn f(f: &fn()) {\n }\n \n-pure fn g() {\n+fn g() {\n     // `f || { }` is considered pure, so `do f { }` should be too\n     do f { }\n }"}, {"sha": "0589ffc79e054ccb66239e28ebf3ae1c15eb8867", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,10 +11,10 @@\n enum chan { chan_t, }\n \n impl cmp::Eq for chan {\n-    pure fn eq(&self, other: &chan) -> bool {\n+    fn eq(&self, other: &chan) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &chan) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &chan) -> bool { !(*self).eq(other) }\n }\n \n fn wrapper3(i: chan) {"}, {"sha": "e22e739f570ff6ad910c21e90b0d52f1554e2491", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,8 +15,8 @@ extern mod std;\n  *\n  * The hash should concentrate entropy in the lower bits.\n  */\n-type HashFn<K> = ~pure fn(K) -> uint;\n-type EqFn<K> = ~pure fn(K, K) -> bool;\n+type HashFn<K> = ~fn(K) -> uint;\n+type EqFn<K> = ~fn(K, K) -> bool;\n \n struct LM { resize_at: uint, size: uint }\n "}, {"sha": "4634cc4ef1101cb2ad1c0c570dd4e07d0a604d01", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,10 +16,10 @@ mod foo {\n     enum t { t1, t2, }\n \n     impl cmp::Eq for t {\n-        pure fn eq(&self, other: &t) -> bool {\n+        fn eq(&self, other: &t) -> bool {\n             ((*self) as uint) == ((*other) as uint)\n         }\n-        pure fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n+        fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n     }\n \n     pub fn f() -> t { return t1; }"}, {"sha": "03358f2511bb6d0c00b4da71bed2ba32c55ce727", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -24,10 +24,10 @@ fn test_rec() {\n enum mood { happy, sad, }\n \n impl cmp::Eq for mood {\n-    pure fn eq(&self, other: &mood) -> bool {\n+    fn eq(&self, other: &mood) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &mood) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &mood) -> bool { !(*self).eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "142123478357598249c51c31bab1ea60ec7ab221", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -25,10 +25,10 @@ fn test_rec() {\n enum mood { happy, sad, }\n \n impl cmp::Eq for mood {\n-    pure fn eq(&self, other: &mood) -> bool {\n+    fn eq(&self, other: &mood) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &mood) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &mood) -> bool { !(*self).eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "5c72de87ccbefaa0a25d33760e8d9ce08b265dea", "filename": "src/test/run-pass/if-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fif-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fif-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pure fn even(x: uint) -> bool {\n+fn even(x: uint) -> bool {\n     if x < 2u {\n         return false;\n     } else if x == 2u { return true; } else { return even(x - 2u); }"}, {"sha": "8a7e2b8a9a9bfbc89383ad40039959ea008fc646", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -28,7 +28,7 @@ enum square {\n }\n \n impl to_str::ToStr for square {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n           bot => { ~\"R\" }\n           wall => { ~\"#\" }"}, {"sha": "e433141c44dbd34bce971176c2c130f00fe5222a", "filename": "src/test/run-pass/issue-3149.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3149.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pure fn Matrix4<T:Copy>(m11: T, m12: T, m13: T, m14: T,\n-                        m21: T, m22: T, m23: T, m24: T,\n-                        m31: T, m32: T, m33: T, m34: T,\n-                        m41: T, m42: T, m43: T, m44: T)\n-                     -> Matrix4<T> {\n+fn Matrix4<T:Copy>(m11: T, m12: T, m13: T, m14: T,\n+                   m21: T, m22: T, m23: T, m24: T,\n+                   m31: T, m32: T, m33: T, m34: T,\n+                   m41: T, m42: T, m43: T, m44: T)\n+                -> Matrix4<T> {\n \n     Matrix4 {\n         m11: m11, m12: m12, m13: m13, m14: m14,"}, {"sha": "aaff822398d6f1df4fa48cd743bbf256d6c7b507", "filename": "src/test/run-pass/issue-3480.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3480.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,13 +13,12 @@ type IMap<K:Copy,V:Copy> = ~[(K, V)];\n \n trait ImmutableMap<K:Copy,V:Copy>\n {\n-    pure fn contains_key(key: K) -> bool;\n+    fn contains_key(key: K) -> bool;\n }\n \n impl<K:Copy,V:Copy> IMap<K, V> : ImmutableMap<K, V>\n {\n-    pure fn contains_key(key: K) -> bool\n-    {\n+    fn contains_key(key: K) -> bool {\n         vec::find(self, |e| {e.first() == key}).is_some()\n     }\n }"}, {"sha": "fdbd7ec304edd22251aae00984b73fe173fc27fe", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -111,8 +111,7 @@ impl AsciiArt\n // Allows AsciiArt to be converted to a string using the libcore ToStr trait.\n // Note that the %s fmt! specifier will not call this automatically.\n impl ToStr for AsciiArt {\n-    pure fn to_str(&self) -> ~str\n-    {\n+    fn to_str(&self) -> ~str {\n         // Convert each line into a string.\n         let lines = do self.lines.map |line| {str::from_chars(*line)};\n "}, {"sha": "f54d2f9fafc4e4d59d4cc9895d5c299a6793cc5a", "filename": "src/test/run-pass/issue-3874.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3874.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n enum PureCounter { PureCounter(uint) }\n \n-pure fn each(self: PureCounter, blk: &fn(v: &uint)) {\n+fn each(self: PureCounter, blk: &fn(v: &uint)) {\n     let PureCounter(ref x) = self;\n     blk(x);\n }"}, {"sha": "8628d84d4e7dbfb26cdf390ea756fb5fe50afc4e", "filename": "src/test/run-pass/mod-merge-hack-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fmod-merge-hack-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fmod-merge-hack-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-merge-hack-template.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,4 +13,4 @@\n use T = self::inst::T;\n \n pub const bits: uint = inst::bits;\n-pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+pub fn min(x: T, y: T) -> T { if x < y { x } else { y } }"}, {"sha": "12b41fc91485e30b578f8e77e2cf4b05e3401fc4", "filename": "src/test/run-pass/new-impl-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -4,7 +4,7 @@ struct Thingy {\n }\n \n impl ToStr for Thingy {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"{ x: %d, y: %d }\", self.x, self.y)\n     }\n }\n@@ -14,7 +14,7 @@ struct PolymorphicThingy<T> {\n }\n \n impl<T:ToStr> ToStr for PolymorphicThingy<T> {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         self.x.to_str()\n     }\n }"}, {"sha": "ae241e458fc1504657b49ffaadb4b54db929684e", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,13 +14,13 @@ extern mod std;\n \n use std::list::*;\n \n-pure fn pure_length_go<T:Copy>(ls: @List<T>, acc: uint) -> uint {\n+fn pure_length_go<T:Copy>(ls: @List<T>, acc: uint) -> uint {\n     match *ls { Nil => { acc } Cons(_, tl) => { pure_length_go(tl, acc + 1u) } }\n }\n \n-pure fn pure_length<T:Copy>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n+fn pure_length<T:Copy>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<T:Copy>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n+fn nonempty_list<T:Copy>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n \n fn safe_head<T:Copy>(ls: @List<T>) -> T {\n     fail_unless!(!is_empty(ls));"}, {"sha": "9299e3e365e33dccb3de736177ccd1f9bed3f6d6", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -16,40 +16,40 @@ struct Point {\n }\n \n impl ops::Add<Point,Point> for Point {\n-    pure fn add(&self, other: &Point) -> Point {\n+    fn add(&self, other: &Point) -> Point {\n         Point {x: self.x + (*other).x, y: self.y + (*other).y}\n     }\n }\n \n impl ops::Sub<Point,Point> for Point {\n-    pure fn sub(&self, other: &Point) -> Point {\n+    fn sub(&self, other: &Point) -> Point {\n         Point {x: self.x - (*other).x, y: self.y - (*other).y}\n     }\n }\n \n impl ops::Neg<Point> for Point {\n-    pure fn neg(&self) -> Point {\n+    fn neg(&self) -> Point {\n         Point {x: -self.x, y: -self.y}\n     }\n }\n \n impl ops::Not<Point> for Point {\n-    pure fn not(&self) -> Point {\n+    fn not(&self) -> Point {\n         Point {x: !self.x, y: !self.y }\n     }\n }\n \n impl ops::Index<bool,int> for Point {\n-    pure fn index(&self, +x: bool) -> int {\n+    fn index(&self, +x: bool) -> int {\n         if x { self.x } else { self.y }\n     }\n }\n \n impl cmp::Eq for Point {\n-    pure fn eq(&self, other: &Point) -> bool {\n+    fn eq(&self, other: &Point) -> bool {\n         (*self).x == (*other).x && (*self).y == (*other).y\n     }\n-    pure fn ne(&self, other: &Point) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Point) -> bool { !(*self).eq(other) }\n }\n \n pub fn main() {"}, {"sha": "127b845ad4ce4d9a89fef13a7787293a1dd22c61", "filename": "src/test/run-pass/pred-not-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpred-not-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpred-not-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpred-not-bool.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,6 +11,6 @@\n // this checks that a pred with a non-bool return\n // type is rejected, even if the pred is never used\n \n-pure fn bad(a: int) -> int { return 37; } //~ ERROR Non-boolean return type\n+fn bad(a: int) -> int { return 37; } //~ ERROR Non-boolean return type\n \n pub fn main() { }"}, {"sha": "424a5e4e8efa64f15507b2d576cf822c67a67598", "filename": "src/test/run-pass/pure-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-fmt.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,7 +13,7 @@\n struct Big { b: @~str, c: uint, d: int, e: char,\n             f: float, g: bool }\n \n-pure fn foo() {\n+fn foo() {\n     let a = Big {\n         b: @~\"hi\",\n         c: 0,"}, {"sha": "6327a3f238d41adf4f60b83ef03c53e384ffac15", "filename": "src/test/run-pass/pure-sum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-sum.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that pure functions can modify local state.\n+// Check that functions can modify local state.\n \n-pure fn sums_to(v: ~[int], sum: int) -> bool {\n+fn sums_to(v: ~[int], sum: int) -> bool {\n     let mut i = 0u, sum0 = 0;\n     while i < v.len() {\n         sum0 += v[i];\n@@ -19,7 +19,7 @@ pure fn sums_to(v: ~[int], sum: int) -> bool {\n     return sum0 == sum;\n }\n \n-pure fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n+fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n     let mut i = 0u, sum0 = ~0;\n     while i < v.len() {\n         *sum0 += v[i];\n@@ -28,7 +28,7 @@ pure fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n     return *sum0 == sum;\n }\n \n-pure fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n+fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n     let mut i = 0u, sum0 = F {f: 0};\n     while i < v.len() {\n         sum0.f += v[i];\n@@ -39,7 +39,7 @@ pure fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n \n struct F<T> { f: T }\n \n-pure fn sums_to_using_uniq_rec(v: ~[int], sum: int) -> bool {\n+fn sums_to_using_uniq_rec(v: ~[int], sum: int) -> bool {\n     let mut i = 0u, sum0 = F {f: ~0};\n     while i < v.len() {\n         *sum0.f += v[i];"}, {"sha": "debde77b21128d08853803e6a500898682218ba7", "filename": "src/test/run-pass/purity-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpurity-infer.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn something(f: &pure fn()) { f(); }\n+fn something(f: &fn()) { f(); }\n pub fn main() {\n     something(|| error!(\"hi!\") );\n }"}, {"sha": "1b5cb86360b207c12c85d8265d492183ea7637e7", "filename": "src/test/run-pass/static-method-in-trait-with-tps-intracrate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-method-in-trait-with-tps-intracrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-method-in-trait-with-tps-intracrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-in-trait-with-tps-intracrate.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,11 +13,11 @@ trait Deserializer {\n }\n \n trait Deserializable<D:Deserializer> {\n-    static fn deserialize(&self, d: &D) -> Self;\n+    fn deserialize(d: &D) -> Self;\n }\n \n impl<D:Deserializer> Deserializable<D> for int {\n-    static fn deserialize(&self, d: &D) -> int {\n+    fn deserialize(d: &D) -> int {\n         return d.read_int();\n     }\n }"}, {"sha": "624a38b789b1c9c3e6bbfa03fa61f563ea89c508", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -14,49 +14,46 @@\n // A trait for objects that can be used to do an if-then-else\n // (No actual need for this to be static, but it is a simple test.)\n trait bool_like {\n-    static fn select<A>(b: Self, +x1: A, +x2: A) -> A;\n+    fn select<A>(b: Self, +x1: A, +x2: A) -> A;\n }\n \n fn andand<T:bool_like + Copy>(x1: T, x2: T) -> T {\n     bool_like::select(x1, x2, x1)\n }\n \n impl bool_like for bool {\n-    static fn select<A>(&&b: bool, +x1: A, +x2: A) -> A {\n+    fn select<A>(&&b: bool, +x1: A, +x2: A) -> A {\n         if b { x1 } else { x2 }\n     }\n }\n \n impl bool_like for int {\n-    static fn select<A>(&&b: int, +x1: A, +x2: A) -> A {\n+    fn select<A>(&&b: int, +x1: A, +x2: A) -> A {\n         if b != 0 { x1 } else { x2 }\n     }\n }\n \n // A trait for sequences that can be constructed imperatively.\n trait buildable<A> {\n-     static pure fn build_sized(size: uint,\n-                                builder: &fn(push: &pure fn(+v: A))) -> Self;\n+     fn build_sized(size: uint, builder: &fn(push: &fn(+v: A))) -> Self;\n }\n \n \n impl<A> buildable<A> for @[A] {\n     #[inline(always)]\n-     static pure fn build_sized(size: uint,\n-                                builder: &fn(push: &pure fn(+v: A))) -> @[A] {\n+     fn build_sized(size: uint, builder: &fn(push: &fn(+v: A))) -> @[A] {\n          at_vec::build_sized(size, builder)\n      }\n }\n impl<A> buildable<A> for ~[A] {\n     #[inline(always)]\n-     static pure fn build_sized(size: uint,\n-                                builder: &fn(push: &pure fn(+v: A))) -> ~[A] {\n+     fn build_sized(size: uint, builder: &fn(push: &fn(+v: A))) -> ~[A] {\n          vec::build_sized(size, builder)\n      }\n }\n \n #[inline(always)]\n-pure fn build<A, B: buildable<A>>(builder: &fn(push: &pure fn(+v: A))) -> B {\n+fn build<A, B: buildable<A>>(builder: &fn(push: &fn(+v: A))) -> B {\n     buildable::build_sized(4, builder)\n }\n "}, {"sha": "24bcfcef1e7455f21e3749bef81db0f7f04e2ecf", "filename": "src/test/run-pass/static-methods-in-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -10,17 +10,17 @@\n \n mod a {\n \tpub trait Foo {\n-\t\tstatic pub fn foo() -> Self;\n+\t\tpub fn foo() -> Self;\n \t}\n \n \timpl Foo for int {\n-\t\tstatic pub fn foo() -> int {\n+\t\tpub fn foo() -> int {\n \t\t\t3\n \t\t}\n \t}\n \t\n \timpl Foo for uint {\n-\t\tstatic pub fn foo() -> uint {\n+\t\tpub fn foo() -> uint {\n \t\t\t5u\n \t\t}\n \t}"}, {"sha": "20e6efa11f0903aa9ab190dffee2e4b903c2717d", "filename": "src/test/run-pass/static-methods-in-traits2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -1,17 +1,17 @@\n pub trait Number: NumConv {\n-    static pure fn from<T:Number>(n: T) -> Self;\n+    fn from<T:Number>(n: T) -> Self;\n }\n \n impl Number for float {\n-    static pure fn from<T:Number>(n: T) -> float { n.to_float() }\n+    fn from<T:Number>(n: T) -> float { n.to_float() }\n }\n \n pub trait NumConv {\n-    pure fn to_float(&self) -> float;\n+    fn to_float(&self) -> float;\n }\n \n impl NumConv for float {\n-    pure fn to_float(&self) -> float { *self }\n+    fn to_float(&self) -> float { *self }\n }\n \n pub fn main() {"}, {"sha": "d987203344723b351dcf51d4de5811ad72ee3e88", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -13,10 +13,10 @@\n enum foo { large, small, }\n \n impl cmp::Eq for foo {\n-    pure fn eq(&self, other: &foo) -> bool {\n+    fn eq(&self, other: &foo) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n }\n \n pub fn main() {"}, {"sha": "63300342bd33ce2d1f49e6aa0216643d9b1b4d29", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -20,10 +20,10 @@ enum color {\n }\n \n impl cmp::Eq for color {\n-    pure fn eq(&self, other: &color) -> bool {\n+    fn eq(&self, other: &color) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &color) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &color) -> bool { !(*self).eq(other) }\n }\n \n pub fn main() {"}, {"sha": "4e126379410be9ca5723690f9038e817f97ccc2c", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,7 +15,7 @@\n enum colour { red(int, int), green, }\n \n impl cmp::Eq for colour {\n-    pure fn eq(&self, other: &colour) -> bool {\n+    fn eq(&self, other: &colour) -> bool {\n         match *self {\n             red(a0, b0) => {\n                 match (*other) {\n@@ -31,7 +31,7 @@ impl cmp::Eq for colour {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &colour) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &colour) -> bool { !(*self).eq(other) }\n }\n \n fn f() { let x = red(1, 2); let y = green; fail_unless!((x != y)); }"}, {"sha": "89dad2d462ccaa013cada7f93b15628862fdda05", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -52,7 +52,7 @@ enum t {\n }\n \n impl cmp::Eq for t {\n-    pure fn eq(&self, other: &t) -> bool {\n+    fn eq(&self, other: &t) -> bool {\n         match *self {\n             tag1 => {\n                 match (*other) {\n@@ -75,7 +75,7 @@ impl cmp::Eq for t {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "aae430dc4cdf9138d17adb5af6f48196db2a5fdb", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,7 +15,7 @@\n use core::num::NumCast::from;\n \n trait Num {\n-    static fn from_int(i: int) -> Self;\n+    fn from_int(i: int) -> Self;\n     fn gt(&self, other: &Self) -> bool;\n }\n "}, {"sha": "283ed8ae2c188e5d666b8251c5b40bab23e5ba8c", "filename": "src/test/run-pass/trait-inheritance-overloading-simple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,8 +15,8 @@ trait MyNum : Eq { }\n struct MyInt { val: int }\n \n impl Eq for MyInt {\n-    pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n-    pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n+    fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n+    fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }\n \n impl MyNum for MyInt;\n@@ -25,7 +25,7 @@ fn f<T:MyNum>(x: T, y: T) -> bool {\n     return x == y;\n }\n \n-pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+fn mi(v: int) -> MyInt { MyInt { val: v } }\n \n pub fn main() {\n     let (x, y, z) = (mi(3), mi(5), mi(3));"}, {"sha": "d4d16f2b43ebd432387cd498e507690b739c6876", "filename": "src/test/run-pass/trait-inheritance-overloading-xc-exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -18,7 +18,7 @@ fn f<T:Copy + MyNum>(x: T, y: T) -> (T, T, T) {\n     return (x + y, x - y, x * y);\n }\n \n-pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+fn mi(v: int) -> MyInt { MyInt { val: v } }\n \n pub fn main() {\n     let (x, y) = (mi(3), mi(5));"}, {"sha": "d4f8d50b92b647b8b8e738aed8ce6081294c8f06", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -15,20 +15,20 @@ trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + Eq { }\n struct MyInt { val: int }\n \n impl Add<MyInt, MyInt> for MyInt {\n-    pure fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+    fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n impl Sub<MyInt, MyInt> for MyInt {\n-    pure fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n+    fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n impl Mul<MyInt, MyInt> for MyInt {\n-    pure fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n+    fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n impl Eq for MyInt {\n-    pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n-    pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n+    fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n+    fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }\n \n impl MyNum for MyInt;\n@@ -37,7 +37,7 @@ fn f<T:Copy + MyNum>(x: T, y: T) -> (T, T, T) {\n     return (x + y, x - y, x * y);\n }\n \n-pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+fn mi(v: int) -> MyInt { MyInt { val: v } }\n \n pub fn main() {\n     let (x, y) = (mi(3), mi(5));"}, {"sha": "f3adea18ecdc18a0100f6a5987798271080cfbb7", "filename": "src/test/run-pass/trait-inheritance-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n trait MyNum {\n-    static fn from_int(int) -> Self;\n+    fn from_int(int) -> Self;\n }\n \n pub trait NumExt: MyNum { }\n \n struct S { v: int }\n \n impl MyNum for S {\n-    static fn from_int(i: int) -> S {\n+    fn from_int(i: int) -> S {\n         S {\n             v: i\n         }"}, {"sha": "45369d4ec19d5010c2976f3fd058ead209234249", "filename": "src/test/run-pass/trait-inheritance-static2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -11,7 +11,7 @@\n trait MyEq { }\n \n trait MyNum {\n-    static fn from_int(int) -> Self;\n+    fn from_int(int) -> Self;\n }\n \n pub trait NumExt: MyEq + MyNum { }\n@@ -21,7 +21,7 @@ struct S { v: int }\n impl MyEq for S { }\n \n impl MyNum for S {\n-    static fn from_int(i: int) -> S {\n+    fn from_int(i: int) -> S {\n         S {\n             v: i\n         }"}, {"sha": "9d0e5fa1f13d4dcee944774017367078ae0abab2", "filename": "src/test/run-pass/trait-inheritance-subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n pub trait Add<RHS,Result> {\n-    pure fn add(&self, rhs: &RHS) -> Result;\n+    fn add(&self, rhs: &RHS) -> Result;\n }\n \n trait MyNum : Add<Self,Self> { }\n \n struct MyInt { val: int }\n \n impl Add<MyInt, MyInt> for MyInt {\n-    pure fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+    fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n impl MyNum for MyInt;\n@@ -26,7 +26,7 @@ fn f<T:MyNum>(x: T, y: T) -> T {\n     return x.add(&y);\n }\n \n-pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+fn mi(v: int) -> MyInt { MyInt { val: v } }\n \n pub fn main() {\n     let (x, y) = (mi(3), mi(5));"}, {"sha": "a8a579422a372fe8d0b835cfd66c95ebc42f6dec", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -12,15 +12,15 @@\n \n mod base {\n     pub trait HasNew<T> {\n-        static pure fn new() -> T;\n+        fn new() -> T;\n     }\n \n     pub struct Foo {\n         dummy: (),\n     }\n \n     impl ::base::HasNew<Foo> for Foo {\n-        static pure fn new() -> Foo {\n+        fn new() -> Foo {\n \t\t\tunsafe { io::println(\"Foo\"); }\n             Foo { dummy: () }\n         }\n@@ -31,7 +31,7 @@ mod base {\n     }\n \n     impl ::base::HasNew<Bar> for Bar {\n-        static pure fn new() -> Bar {\n+        fn new() -> Bar {\n \t\t\tunsafe { io::println(\"Bar\"); }\n             Bar { dummy: () }\n         }"}, {"sha": "4228f72b7caa4c7cb9b17bc14481113ccd3b355d", "filename": "src/test/run-pass/tstate-loop-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftstate-loop-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftstate-loop-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftstate-loop-break.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n \n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn is_even(i: int) -> bool { (i%2) == 0 }\n fn even(i: int) : is_even(i) -> int { i }\n \n fn test() {"}, {"sha": "7303f5ecbdf6c102bcc4cb0b3d2e416d9c561c19", "filename": "src/test/run-pass/typeclasses-eq-example-static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example-static.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -12,13 +12,13 @@\n // methods!\n \n trait Equal {\n-    static fn isEq(a: Self, b: Self) -> bool;\n+    fn isEq(a: Self, b: Self) -> bool;\n }\n \n enum Color { cyan, magenta, yellow, black }\n \n impl Equal for Color {\n-    static fn isEq(a: Color, b: Color) -> bool {\n+    fn isEq(a: Color, b: Color) -> bool {\n         match (a, b) {\n           (cyan, cyan)       => { true  }\n           (magenta, magenta) => { true  }\n@@ -35,7 +35,7 @@ enum ColorTree {\n }\n \n impl Equal for ColorTree {\n-    static fn isEq(a: ColorTree, b: ColorTree) -> bool {\n+    fn isEq(a: ColorTree, b: ColorTree) -> bool {\n         match (a, b) {\n           (leaf(x), leaf(y)) => { Equal::isEq(x, y) }\n           (branch(l1, r1), branch(l2, r2)) => { "}, {"sha": "0af35a6c619e5df9ad196ffbc59bf378fcf62c1d", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b077c0e94f101a3121a7d615f46366ea4080bf/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=e9b077c0e94f101a3121a7d615f46366ea4080bf", "patch": "@@ -56,7 +56,7 @@ fn notsure() {\n }\n \n fn canttouchthis() -> uint {\n-    pure fn p() -> bool { true }\n+    fn p() -> bool { true }\n     let _a = (fail_unless!((true)) == (fail_unless!(p())));\n     let _c = (fail_unless!((p())) == ());\n     let _b: bool = (debug!(\"%d\", 0) == (return 0u));"}]}