{"sha": "77746b906071b17a6ce3634b91b60ec085fb268f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NzQ2YjkwNjA3MWIxN2E2Y2UzNjM0YjkxYjYwZWMwODVmYjI2OGY=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-10-25T15:43:53Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-10-25T15:43:53Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "444d879c69dfcd6f4087d0a71cb6a844722f1693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/444d879c69dfcd6f4087d0a71cb6a844722f1693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77746b906071b17a6ce3634b91b60ec085fb268f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl+VnToACgkQaTCGhp1Q\nZje15Q//UFnAvPQONV9lWXJGBpx64qnJVRvtLAIavCkpor1B7BSvJn/B9oLXwsVv\nW7QqNCZt+GaAWV3ibIA5tbMUC08UjNm2B9yOEgrvoFIklxwTmDwLkqzxqaKq5aoV\nuj/tj1xuP3aZhg+dRs9TlAt5VnqwDfJ6zbVcJF2NeYVfCIRfLcIgQqv5HLpr1xc+\nqQOPaBRfGxVuCi2jU9ZVEHK0G2YBnP5iEGvVyiwz9DkXXU86+5Tx5CZF+6YSUPKv\n5eXWZcDvrvWGHdUGEcHiABSkymeBTDyF6XvIh+yBkcvhRFKrP32JAbiQ0zxRsEYt\nUO4+ZEjLB0MyRwC6MeUAZUuFAtXXLGCj3KPWQPYjcOWGDLXJMluWYSkzYjIaG3lf\nC7WNrP4pd/TXy+TBJ1+JxjqbLARzqM4y/Ws465vEZm9ftYxR35SWKqFpH5j/6nMq\n2Oo42D7YyqqiColZ9feAwf3lNnXcQH2ZiMcC35EJeaM3naqCPd6UvOZdF37M8uFM\n2x1wWrQKZFrMFVi4ly++lww3LjNOSjRAQqE5UKratOj8z3pRtSy2WVi1vpKulnS7\nRzwMXvJdNE3woK8syPw8Y5EpBumnjyom9OFCAQ+X6lmBXUR/vegqI4akcHbvLm5p\nwMi0kH765G0h5xwuSb7zpzx1Ucq8tA7n5Qwv2weUhGZlPUg2SP8=\n=kd+l\n-----END PGP SIGNATURE-----", "payload": "tree 444d879c69dfcd6f4087d0a71cb6a844722f1693\nparent df855321126580ace6e3022372991c725d3e1b0a\nparent 9c9aa2db52dd4d031cb55412771fdba57b52e2c0\nauthor flip1995 <hello@philkrones.com> 1603640633 +0100\ncommitter flip1995 <hello@philkrones.com> 1603640633 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77746b906071b17a6ce3634b91b60ec085fb268f", "html_url": "https://github.com/rust-lang/rust/commit/77746b906071b17a6ce3634b91b60ec085fb268f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77746b906071b17a6ce3634b91b60ec085fb268f/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df855321126580ace6e3022372991c725d3e1b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/df855321126580ace6e3022372991c725d3e1b0a", "html_url": "https://github.com/rust-lang/rust/commit/df855321126580ace6e3022372991c725d3e1b0a"}, {"sha": "9c9aa2db52dd4d031cb55412771fdba57b52e2c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9aa2db52dd4d031cb55412771fdba57b52e2c0", "html_url": "https://github.com/rust-lang/rust/commit/9c9aa2db52dd4d031cb55412771fdba57b52e2c0"}], "stats": {"total": 2469, "additions": 2076, "deletions": 393}, "files": [{"sha": "7fd79deb56c60670df690c9a4ae5857ba26891c9", "filename": "CHANGELOG.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1632,6 +1632,7 @@ Released 2018-09-13\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`async_yields_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#async_yields_async\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n+[`await_holding_refcell_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n@@ -1779,6 +1780,7 @@ Released 2018-09-13\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n+[`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n [`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n [`len_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n [`let_and_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\n@@ -1793,6 +1795,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n+[`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n@@ -1841,6 +1844,7 @@ Released 2018-09-13\n [`must_use_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_unit\n [`mut_from_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_from_ref\n [`mut_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_mut\n+[`mut_mutex_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_mutex_lock\n [`mut_range_bound`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_range_bound\n [`mutable_key_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key_type\n [`mutex_atomic`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_atomic\n@@ -1936,6 +1940,7 @@ Released 2018-09-13\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n [`single_char_push_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_push_str\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n+[`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n [`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n@@ -1979,6 +1984,7 @@ Released 2018-09-13\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n [`type_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity\n [`type_repetition_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds\n+[`undropped_manually_drops`]: https://rust-lang.github.io/rust-clippy/master/index.html#undropped_manually_drops\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init"}, {"sha": "fcebb54c6c217840d3b5a2b7faa8f1249dc72a29", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "renamed", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -45,13 +45,52 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub AWAIT_HOLDING_LOCK,\n-    pedantic,\n+    correctness,\n     \"Inside an async function, holding a MutexGuard while calling await\"\n }\n \n-declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// `RefCell` `Ref` or `RefMut`.\n+    ///\n+    /// **Why is this bad?** `RefCell` refs only check for exclusive mutable access\n+    /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+    /// risks panics from a mutable ref shared while other refs are outstanding.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   let b = x.borrow_mut()();\n+    ///   *ref += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let b = x.borrow_mut();\n+    ///     *ref += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_REFCELL_REF,\n+    correctness,\n+    \"Inside an async function, holding a RefCell ref while calling await\"\n+}\n \n-impl LateLintPass<'_> for AwaitHoldingLock {\n+declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n+\n+impl LateLintPass<'_> for AwaitHolding {\n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n@@ -78,6 +117,16 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n                     \"these are all the await points this lock is held through\",\n                 );\n             }\n+            if is_refcell_ref(cx, adt.did) {\n+                span_lint_and_note(\n+                        cx,\n+                        AWAIT_HOLDING_REFCELL_REF,\n+                        ty_cause.span,\n+                        \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n+                        ty_cause.scope_span.or(Some(span)),\n+                        \"these are all the await points this ref is held through\",\n+                    );\n+            }\n         }\n     }\n }\n@@ -90,3 +139,7 @@ fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n }\n+\n+fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n+}", "previous_filename": "clippy_lints/src/await_holding_lock.rs"}, {"sha": "9c0efef95de8a4ac93a1aa3dbe9956b6397bae66", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -579,9 +579,8 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<\n     if let hir::PatKind::Wild = pat.kind {\n         return false; // ignore `_` patterns\n     }\n-    let def_id = pat.hir_id.owner.to_def_id();\n-    if cx.tcx.has_typeck_results(def_id) {\n-        is_mutable_ty(cx, &cx.tcx.typeck(def_id.expect_local()).pat_ty(pat), pat.span, tys)\n+    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n+        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n     } else {\n         false\n     }\n@@ -694,11 +693,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             Call(_, args) | MethodCall(_, _, args, _) => {\n                 let mut tys = FxHashSet::default();\n                 for arg in args {\n-                    let def_id = arg.hir_id.owner.to_def_id();\n-                    if self.cx.tcx.has_typeck_results(def_id)\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n                             self.cx,\n-                            self.cx.tcx.typeck(def_id.expect_local()).expr_ty(arg),\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )"}, {"sha": "71a30d1c33d4f385bfd918058ede1a3df2fd4049", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -92,13 +92,8 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                         |db| {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n-                                    infcx.maybe_note_obligation_cause_for_async_await(\n-                                        db,\n-                                        &obligation,\n-                                    );\n-                                    if let Trait(trait_pred, _) =\n-                                        obligation.predicate.skip_binders()\n-                                    {\n+                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                    if let Trait(trait_pred, _) = obligation.predicate.skip_binders() {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n                                             trait_pred.self_ty(),"}, {"sha": "b330b66776c1ce97ddb2f405f7d526c62ae5505c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -160,7 +160,7 @@ mod assign_ops;\n mod async_yields_async;\n mod atomic_ordering;\n mod attrs;\n-mod await_holding_lock;\n+mod await_holding_invalid;\n mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n@@ -255,6 +255,7 @@ mod modulo_arithmetic;\n mod multiple_crate_versions;\n mod mut_key;\n mod mut_mut;\n+mod mut_mutex_lock;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n@@ -278,6 +279,7 @@ mod overflow_check_conditional;\n mod panic_in_result_fn;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n+mod pass_by_ref_or_value;\n mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n@@ -311,9 +313,9 @@ mod to_string_in_display;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n-mod trivially_copy_pass_by_ref;\n mod try_err;\n mod types;\n+mod undropped_manually_drops;\n mod unicode;\n mod unit_return_expecting_ord;\n mod unnamed_address;\n@@ -509,7 +511,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::MISMATCHED_TARGET_OS,\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n-        &await_holding_lock::AWAIT_HOLDING_LOCK,\n+        &await_holding_invalid::AWAIT_HOLDING_LOCK,\n+        &await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -633,6 +636,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::NEEDLESS_RANGE_LOOP,\n         &loops::NEVER_LOOP,\n         &loops::SAME_ITEM_PUSH,\n+        &loops::SINGLE_ELEMENT_LOOP,\n         &loops::WHILE_IMMUTABLE_CONDITION,\n         &loops::WHILE_LET_LOOP,\n         &loops::WHILE_LET_ON_ITERATOR,\n@@ -743,6 +747,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n         &mut_key::MUTABLE_KEY_TYPE,\n         &mut_mut::MUT_MUT,\n+        &mut_mutex_lock::MUT_MUTEX_LOCK,\n         &mut_reference::UNNECESSARY_MUT_PASSED,\n         &mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL,\n         &mutex_atomic::MUTEX_ATOMIC,\n@@ -776,6 +781,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &panic_unimplemented::UNIMPLEMENTED,\n         &panic_unimplemented::UNREACHABLE,\n         &partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n+        &pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n+        &pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n         &path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n         &pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         &precedence::PRECEDENCE,\n@@ -785,6 +792,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ptr_eq::PTR_EQ,\n         &ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n         &question_mark::QUESTION_MARK,\n+        &ranges::MANUAL_RANGE_CONTAINS,\n         &ranges::RANGE_MINUS_ONE,\n         &ranges::RANGE_PLUS_ONE,\n         &ranges::RANGE_ZIP_WITH_LEN,\n@@ -835,7 +843,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &transmute::USELESS_TRANSMUTE,\n         &transmute::WRONG_TRANSMUTE,\n         &transmuting_null::TRANSMUTING_NULL,\n-        &trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         &try_err::TRY_ERR,\n         &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n@@ -862,6 +869,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::UNIT_CMP,\n         &types::UNNECESSARY_CAST,\n         &types::VEC_BOX,\n+        &undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n         &unicode::INVISIBLE_CHARACTERS,\n         &unicode::NON_ASCII_LITERAL,\n         &unicode::UNICODE_NOT_NFC,\n@@ -905,7 +913,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n-    store.register_late_pass(|| box await_holding_lock::AwaitHoldingLock);\n+    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1009,11 +1017,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold));\n     store.register_late_pass(|| box explicit_write::ExplicitWrite);\n     store.register_late_pass(|| box needless_pass_by_value::NeedlessPassByValue);\n-    let trivially_copy_pass_by_ref = trivially_copy_pass_by_ref::TriviallyCopyPassByRef::new(\n+    let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n         conf.trivial_copy_size_limit,\n+        conf.pass_by_value_size_limit,\n         &sess.target,\n     );\n-    store.register_late_pass(move || box trivially_copy_pass_by_ref);\n+    store.register_late_pass(move || box pass_by_ref_or_value);\n     store.register_late_pass(|| box try_err::TryErr);\n     store.register_late_pass(|| box use_self::UseSelf);\n     store.register_late_pass(|| box bytecount::ByteCount);\n@@ -1109,6 +1118,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n+    store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n     store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n@@ -1137,6 +1147,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n+    store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n \n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n@@ -1188,7 +1199,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n-        LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),\n@@ -1237,13 +1247,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n         LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n+        LintId::of(&pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n+        LintId::of(&pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&types::CAST_LOSSLESS),\n         LintId::of(&types::CAST_POSSIBLE_TRUNCATION),\n         LintId::of(&types::CAST_POSSIBLE_WRAP),\n@@ -1287,6 +1298,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n@@ -1363,6 +1376,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::NEVER_LOOP),\n         LintId::of(&loops::SAME_ITEM_PUSH),\n+        LintId::of(&loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(&loops::WHILE_IMMUTABLE_CONDITION),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n@@ -1441,6 +1455,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::UNNEEDED_WILDCARD_PATTERN),\n         LintId::of(&misc_early::ZERO_PREFIXED_LITERAL),\n         LintId::of(&mut_key::MUTABLE_KEY_TYPE),\n+        LintId::of(&mut_mutex_lock::MUT_MUTEX_LOCK),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n         LintId::of(&mutex_atomic::MUTEX_ATOMIC),\n         LintId::of(&needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n@@ -1469,6 +1484,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&question_mark::QUESTION_MARK),\n+        LintId::of(&ranges::MANUAL_RANGE_CONTAINS),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n@@ -1521,6 +1537,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNIT_CMP),\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n+        LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n@@ -1612,6 +1629,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::DUPLICATE_UNDERSCORE_ARGUMENT),\n         LintId::of(&misc_early::MIXED_CASE_HEX_LITERALS),\n         LintId::of(&misc_early::REDUNDANT_PATTERN),\n+        LintId::of(&mut_mutex_lock::MUT_MUTEX_LOCK),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n         LintId::of(&new_without_default::NEW_WITHOUT_DEFAULT),\n@@ -1624,6 +1642,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&question_mark::QUESTION_MARK),\n+        LintId::of(&ranges::MANUAL_RANGE_CONTAINS),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n@@ -1664,6 +1683,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n+        LintId::of(&loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n@@ -1733,6 +1753,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::DEPRECATED_SEMVER),\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&booleans::LOGIC_BUG),\n@@ -1790,6 +1812,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::CAST_REF_TO_MUT),\n         LintId::of(&types::UNIT_CMP),\n+        LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),"}, {"sha": "c8a5a9c9431352ab2d2f4f7cf09c07fa55677550", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -414,7 +414,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                 let mut visitor = RefVisitor::new(cx);\n                 // walk the type F, it may not contain LT refs\n                 walk_ty(&mut visitor, &pred.bounded_ty);\n-                if !visitor.lts.is_empty() {\n+                if !visitor.all_lts().is_empty() {\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n@@ -424,7 +424,9 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                     walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n-                return visitor.all_lts().iter().any(|it| !allowed_lts.contains(it));\n+                if visitor.all_lts().iter().any(|it| !allowed_lts.contains(it)) {\n+                    return true;\n+                }\n             },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);"}, {"sha": "23ca35fffaaf1850ca753dd6f0aa1667be987bec", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 92, "deletions": 11, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -4,9 +4,10 @@ use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n+    indent_of, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment,\n+    match_trait_method, match_type, match_var, multispan_sugg, qpath_res, single_segment_path, snippet,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n+    span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -293,9 +294,24 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// **What it does:** Checks for empty `loop` expressions.\n     ///\n-    /// **Why is this bad?** Those busy loops burn CPU cycles without doing\n-    /// anything. Think of the environment and either block on something or at least\n-    /// make the thread sleep for some microseconds.\n+    /// **Why is this bad?** These busy loops burn CPU cycles without doing\n+    /// anything. It is _almost always_ a better idea to `panic!` than to have\n+    /// a busy loop.\n+    ///\n+    /// If panicking isn't possible, think of the environment and either:\n+    ///   - block on something\n+    ///   - sleep the thread for some microseconds\n+    ///   - yield or pause the thread\n+    ///\n+    /// For `std` targets, this can be done with\n+    /// [`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n+    /// or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n+    ///\n+    /// For `no_std` targets, doing this is more complicated, especially because\n+    /// `#[panic_handler]`s can't panic. To stop/pause the thread, you will\n+    /// probably need to invoke some target-specific intrinsic. Examples include:\n+    ///   - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n+    ///   - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -452,6 +468,31 @@ declare_clippy_lint! {\n     \"the same item is pushed inside of a for loop\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop has a single element.\n+    ///\n+    /// **Why is this bad?** There is no reason to have a loop of a\n+    /// single element.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// for item in &[item1] {\n+    ///     println!(\"{}\", item);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item = &item1;\n+    /// println!(\"{}\", item);\n+    /// ```\n+    pub SINGLE_ELEMENT_LOOP,\n+    complexity,\n+    \"there is no reason to have a single element loop\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     NEEDLESS_RANGE_LOOP,\n@@ -469,6 +510,7 @@ declare_lint_pass!(Loops => [\n     MUT_RANGE_BOUND,\n     WHILE_IMMUTABLE_CONDITION,\n     SAME_ITEM_PUSH,\n+    SINGLE_ELEMENT_LOOP,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -502,13 +544,15 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // (even if the \"match\" or \"if let\" is used for declaration)\n         if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.kind {\n             // also check for empty `loop {}` statements\n+            // TODO(issue #6161): Enable for no_std crates (outside of #[panic_handler])\n             if block.stmts.is_empty() && block.expr.is_none() && !is_no_std_crate(cx.tcx.hir().krate()) {\n-                span_lint(\n+                span_lint_and_help(\n                     cx,\n                     EMPTY_LOOP,\n                     expr.span,\n-                    \"empty `loop {}` detected. You may want to either use `panic!()` or add \\\n-                     `std::thread::sleep(..);` to the loop body.\",\n+                    \"empty `loop {}` wastes CPU cycles\",\n+                    None,\n+                    \"You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\",\n                 );\n             }\n \n@@ -777,6 +821,7 @@ fn check_for_loop<'tcx>(\n     check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n+    check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n }\n \n@@ -1866,6 +1911,43 @@ fn check_for_loop_over_map_kv<'tcx>(\n     }\n }\n \n+fn check_for_single_element_loop<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n+        if let PatKind::Binding(.., target, _) = pat.kind;\n+        if let ExprKind::Array(ref arg_expr_list) = arg_expr.kind;\n+        if let [arg_expression] = arg_expr_list;\n+        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n+        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n+        if let ExprKind::Block(ref block, _) = body.kind;\n+        if !block.stmts.is_empty();\n+\n+        then {\n+            let for_span = get_span_of_entire_for_loop(expr);\n+            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            block_str.remove(0);\n+            block_str.pop();\n+\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SINGLE_ELEMENT_LOOP,\n+                for_span,\n+                \"for loop over a single element\",\n+                \"try\",\n+                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n+                Applicability::MachineApplicable\n+            )\n+        }\n+    }\n+}\n+\n struct MutatePairDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     hir_id_low: Option<HirId>,\n@@ -1969,12 +2051,11 @@ fn check_for_mutation<'tcx>(\n         span_low: None,\n         span_high: None,\n     };\n-    let def_id = body.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         ExprUseVisitor::new(\n             &mut delegate,\n             &infcx,\n-            def_id.expect_local(),\n+            body.hir_id.owner,\n             cx.param_env,\n             cx.typeck_results(),\n         )"}, {"sha": "22aa37e41fec0e4124b7b3ba316c4bfc91e777f9", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,16 +1,17 @@\n use crate::consts::constant_simple;\n use crate::utils;\n+use crate::utils::sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Arm, Expr, ExprKind, PatKind, QPath};\n+use rustc_hir::{def, Arm, Expr, ExprKind, Pat, PatKind, QPath};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Finds patterns that reimplement `Option::unwrap_or`.\n+    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n     ///\n     /// **Why is this bad?**\n     /// Concise code helps focusing on behavior instead of boilerplate.\n@@ -33,7 +34,7 @@ declare_clippy_lint! {\n     /// ```\n     pub MANUAL_UNWRAP_OR,\n     complexity,\n-    \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\"\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n }\n \n declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n@@ -43,32 +44,50 @@ impl LateLintPass<'_> for ManualUnwrapOr {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        lint_option_unwrap_or_case(cx, expr);\n+        lint_manual_unwrap_or(cx, expr);\n     }\n }\n \n-fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_none_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+#[derive(Copy, Clone)]\n+enum Case {\n+    Option,\n+    Result,\n+}\n+\n+impl Case {\n+    fn unwrap_fn_path(&self) -> &str {\n+        match self {\n+            Case::Option => \"Option::unwrap_or\",\n+            Case::Result => \"Result::unwrap_or\",\n+        }\n+    }\n+}\n+\n+fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn applicable_or_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n             if arms.len() == 2;\n             if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, none_arm)) = arms.iter().enumerate().find(|(_, arm)|\n-                if let PatKind::Path(ref qpath) = arm.pat.kind {\n-                    utils::match_qpath(qpath, &utils::paths::OPTION_NONE)\n-                } else {\n-                    false\n+            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+                match arm.pat.kind {\n+                    PatKind::Path(ref some_qpath) =>\n+                        utils::match_qpath(some_qpath, &utils::paths::OPTION_NONE),\n+                    PatKind::TupleStruct(ref err_qpath, &[Pat { kind: PatKind::Wild, .. }], _) =>\n+                        utils::match_qpath(err_qpath, &utils::paths::RESULT_ERR),\n+                    _ => false,\n                 }\n             );\n-            let some_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref some_qpath, &[some_binding], _) = some_arm.pat.kind;\n-            if utils::match_qpath(some_qpath, &utils::paths::OPTION_SOME);\n-            if let PatKind::Binding(_, binding_hir_id, ..) = some_binding.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, body_path)) = some_arm.body.kind;\n+            let unwrap_arm = &arms[1 - idx];\n+            if let PatKind::TupleStruct(ref unwrap_qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n+            if utils::match_qpath(unwrap_qpath, &utils::paths::OPTION_SOME)\n+                || utils::match_qpath(unwrap_qpath, &utils::paths::RESULT_OK);\n+            if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, body_path)) = unwrap_arm.body.kind;\n             if let def::Res::Local(body_path_hir_id) = body_path.res;\n             if body_path_hir_id == binding_hir_id;\n-            if !utils::usage::contains_return_break_continue_macro(none_arm.body);\n+            if !utils::usage::contains_return_break_continue_macro(or_arm.body);\n             then {\n-                Some(none_arm)\n+                Some(or_arm)\n             } else {\n                 None\n             }\n@@ -78,24 +97,29 @@ fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tc\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if utils::is_type_diagnostic_item(cx, ty, sym!(option_type));\n-        if let Some(none_arm) = applicable_none_arm(match_arms);\n-        if let Some(scrutinee_snippet) = utils::snippet_opt(cx, scrutinee.span);\n-        if let Some(none_body_snippet) = utils::snippet_opt(cx, none_arm.body.span);\n+        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+            Some(Case::Option)\n+        } else if utils::is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+            Some(Case::Result)\n+        } else {\n+            None\n+        };\n+        if let Some(or_arm) = applicable_or_arm(match_arms);\n+        if let Some(or_body_snippet) = utils::snippet_opt(cx, or_arm.body.span);\n         if let Some(indent) = utils::indent_of(cx, expr.span);\n-        if constant_simple(cx, cx.typeck_results(), none_arm.body).is_some();\n+        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n         then {\n-            let reindented_none_body =\n-                utils::reindent_multiline(none_body_snippet.into(), true, Some(indent));\n+            let reindented_or_body =\n+                utils::reindent_multiline(or_body_snippet.into(), true, Some(indent));\n             utils::span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n-                \"this pattern reimplements `Option::unwrap_or`\",\n+                &format!(\"this pattern reimplements `{}`\", case.unwrap_fn_path()),\n                 \"replace with\",\n                 format!(\n                     \"{}.unwrap_or({})\",\n-                    scrutinee_snippet,\n-                    reindented_none_body,\n+                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par(),\n+                    reindented_or_body,\n                 ),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "df1cecb328cb151698aff17b375176e714e3619c", "filename": "clippy_lints/src/mut_mutex_lock.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,68 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `&mut Mutex::lock` calls\n+    ///\n+    /// **Why is this bad?** `Mutex::lock` is less efficient than\n+    /// calling `Mutex::get_mut`. In addition you also have a statically\n+    /// guarantee that the mutex isn't locked, instead of just a runtime\n+    /// guarantee.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let mut value = value_mutex.lock().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let value = value_mutex.get_mut().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    pub MUT_MUTEX_LOCK,\n+    style,\n+    \"`&mut Mutex::lock` does unnecessary locking\"\n+}\n+\n+declare_lint_pass!(MutMutexLock => [MUT_MUTEX_LOCK]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, method_span, args, _) = &ex.kind;\n+            if path.ident.name == sym!(lock);\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n+            if is_type_diagnostic_item(cx, inner_ty, sym!(mutex_type));\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MUT_MUTEX_LOCK,\n+                    *method_span,\n+                    \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n+                    \"change this to\",\n+                    \"get_mut\".to_owned(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "a799a644e970e1d3bce83435db28f6576bba5115", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -3,7 +3,9 @@\n //! This lint is **warn** by default\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{higher, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{\n+    higher, is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -233,6 +235,9 @@ fn check_comparison<'a, 'tcx>(\n             cx.typeck_results().expr_ty(left_side),\n             cx.typeck_results().expr_ty(right_side),\n         );\n+        if is_expn_of(left_side.span, \"cfg\").is_some() || is_expn_of(right_side.span, \"cfg\").is_some() {\n+            return;\n+        }\n         if l_ty.is_bool() && r_ty.is_bool() {\n             let mut applicability = Applicability::MachineApplicable;\n \n@@ -295,7 +300,14 @@ fn suggest_bool_comparison<'a, 'tcx>(\n     message: &str,\n     conv_hint: impl FnOnce(Sugg<'a>) -> Sugg<'a>,\n ) {\n-    let hint = Sugg::hir_with_applicability(cx, expr, \"..\", &mut applicability);\n+    let hint = if expr.span.from_expansion() {\n+        if applicability != Applicability::Unspecified {\n+            applicability = Applicability::MaybeIncorrect;\n+        }\n+        Sugg::hir_with_macro_callsite(cx, expr, \"..\")\n+    } else {\n+        Sugg::hir_with_applicability(cx, expr, \"..\", &mut applicability)\n+    };\n     span_lint_and_sugg(\n         cx,\n         BOOL_COMPARISON,"}, {"sha": "28816c3076ddf5f38f3639e19cf563d01adc59e5", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,256 @@\n+use std::cmp;\n+\n+use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::attr;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::Target;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by reference, where\n+    /// the argument type is `Copy` and small enough to be more efficient to always\n+    /// pass by value.\n+    ///\n+    /// **Why is this bad?** In many calling conventions instances of structs will\n+    /// be passed through registers if they fit into two or less general purpose\n+    /// registers.\n+    ///\n+    /// **Known problems:** This lint is target register size dependent, it is\n+    /// limited to 32-bit to try and reduce portability problems between 32 and\n+    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n+    /// will be different.\n+    ///\n+    /// The configuration option `trivial_copy_size_limit` can be set to override\n+    /// this limit for a project.\n+    ///\n+    /// This lint attempts to allow passing arguments by reference if a reference\n+    /// to that argument is returned. This is implemented by comparing the lifetime\n+    /// of the argument and return value for equality. However, this can cause\n+    /// false positives in cases involving multiple lifetimes that are bounded by\n+    /// each other.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn foo(v: &u32) {}\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// // Better\n+    /// fn foo(v: u32) {}\n+    /// ```\n+    pub TRIVIALLY_COPY_PASS_BY_REF,\n+    pedantic,\n+    \"functions taking small copyable arguments by reference\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by value, where\n+    /// the argument type is `Copy` and large enough to be worth considering\n+    /// passing by reference. Does not trigger if the function is being exported,\n+    /// because that might induce API breakage, if the parameter is declared as mutable,\n+    /// or if the argument is a `self`.\n+    ///\n+    /// **Why is this bad?** Arguments passed by value might result in an unnecessary\n+    /// shallow copy, taking up more space in the stack and requiring a call to\n+    /// `memcpy`, which which can be expensive.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// #[derive(Clone, Copy)]\n+    /// struct TooLarge([u8; 2048]);\n+    ///\n+    /// // Bad\n+    /// fn foo(v: TooLarge) {}\n+    /// ```\n+    /// ```rust\n+    /// #[derive(Clone, Copy)]\n+    /// struct TooLarge([u8; 2048]);\n+    ///\n+    /// // Good\n+    /// fn foo(v: &TooLarge) {}\n+    /// ```\n+    pub LARGE_TYPES_PASSED_BY_VALUE,\n+    pedantic,\n+    \"functions taking large arguments by value\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PassByRefOrValue {\n+    ref_min_size: u64,\n+    value_max_size: u64,\n+}\n+\n+impl<'tcx> PassByRefOrValue {\n+    pub fn new(ref_min_size: Option<u64>, value_max_size: u64, target: &Target) -> Self {\n+        let ref_min_size = ref_min_size.unwrap_or_else(|| {\n+            let bit_width = u64::from(target.pointer_width);\n+            // Cap the calculated bit width at 32-bits to reduce\n+            // portability problems between 32 and 64-bit targets\n+            let bit_width = cmp::min(bit_width, 32);\n+            #[allow(clippy::integer_division)]\n+            let byte_width = bit_width / 8;\n+            // Use a limit of 2 times the register byte width\n+            byte_width * 2\n+        });\n+\n+        Self {\n+            ref_min_size,\n+            value_max_size,\n+        }\n+    }\n+\n+    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n+        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n+\n+        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n+\n+        let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n+\n+        for (index, (input, &ty)) in decl.inputs.iter().zip(fn_sig.inputs()).enumerate() {\n+            // All spans generated from a proc-macro invocation are the same...\n+            match span {\n+                Some(s) if s == input.span => return,\n+                _ => (),\n+            }\n+\n+            match ty.kind() {\n+                ty::Ref(input_lt, ty, Mutability::Not) => {\n+                    // Use lifetimes to determine if we're returning a reference to the\n+                    // argument. In that case we can't switch to pass-by-value as the\n+                    // argument will not live long enough.\n+                    let output_lts = match *fn_sig.output().kind() {\n+                        ty::Ref(output_lt, _, _) => vec![output_lt],\n+                        ty::Adt(_, substs) => substs.regions().collect(),\n+                        _ => vec![],\n+                    };\n+\n+                    if_chain! {\n+                        if !output_lts.contains(&input_lt);\n+                        if is_copy(cx, ty);\n+                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if size <= self.ref_min_size;\n+                        if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n+                        then {\n+                            let value_type = if is_self_ty(decl_ty) {\n+                                \"self\".into()\n+                            } else {\n+                                snippet(cx, decl_ty.span, \"_\").into()\n+                            };\n+                            span_lint_and_sugg(\n+                                cx,\n+                                TRIVIALLY_COPY_PASS_BY_REF,\n+                                input.span,\n+                                &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n+                                \"consider passing by value instead\",\n+                                value_type,\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                },\n+\n+                ty::Adt(_, _) | ty::Array(_, _) | ty::Tuple(_) => {\n+                    // if function has a body and parameter is annotated with mut, ignore\n+                    if let Some(param) = fn_body.and_then(|body| body.params.get(index)) {\n+                        match param.pat.kind {\n+                            PatKind::Binding(BindingAnnotation::Unannotated, _, _, _) => {},\n+                            _ => continue,\n+                        }\n+                    }\n+\n+                    if_chain! {\n+                        if !cx.access_levels.is_exported(hir_id);\n+                        if is_copy(cx, ty);\n+                        if !is_self_ty(input);\n+                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if size > self.value_max_size;\n+                        then {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                LARGE_TYPES_PASSED_BY_VALUE,\n+                                input.span,\n+                                &format!(\"this argument ({} byte) is passed by value, but might be more efficient if passed by reference (limit: {} byte)\", size, self.value_max_size),\n+                                \"consider passing by reference instead\",\n+                                format!(\"&{}\", snippet(cx, input.span, \"_\")),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                },\n+\n+                _ => {},\n+            }\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(PassByRefOrValue => [TRIVIALLY_COPY_PASS_BY_REF, LARGE_TYPES_PASSED_BY_VALUE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n+            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n+        }\n+    }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        _body: &'tcx Body<'_>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if span.from_expansion() {\n+            return;\n+        }\n+\n+        match kind {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n+                    return;\n+                }\n+                for a in attrs {\n+                    if let Some(meta_items) = a.meta_item_list() {\n+                        if a.has_name(sym!(proc_macro_derive))\n+                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        {\n+                            return;\n+                        }\n+                    }\n+                }\n+            },\n+            FnKind::Method(..) => (),\n+            FnKind::Closure(..) => return,\n+        }\n+\n+        // Exclude non-inherent impls\n+        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n+            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n+            ItemKind::Trait(..))\n+            {\n+                return;\n+            }\n+        }\n+\n+        self.check_poly_fn(cx, hir_id, decl, Some(span));\n+    }\n+}"}, {"sha": "de54711d8511b6998238d5787b95e8acbb1f042a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 185, "deletions": 31, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -2,15 +2,19 @@ use crate::consts::{constant, Constant};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n+use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{get_parent_expr, is_integer_const, snippet, snippet_opt, span_lint, span_lint_and_then};\n+use crate::utils::{\n+    get_parent_expr, is_integer_const, single_segment_path, snippet, snippet_opt, snippet_with_applicability,\n+    span_lint, span_lint_and_sugg, span_lint_and_then,\n+};\n use crate::utils::{higher, SpanlessEq};\n \n declare_clippy_lint! {\n@@ -128,43 +132,51 @@ declare_clippy_lint! {\n     \"reversing the limits of range expressions, resulting in empty ranges\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions like `x >= 3 && x < 8` that could\n+    /// be more readably expressed as `(3..8).contains(x)`.\n+    ///\n+    /// **Why is this bad?** `contains` expresses the intent better and has less\n+    /// failure modes (such as fencepost errors or using `||` instead of `&&`).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // given\n+    /// let x = 6;\n+    ///\n+    /// assert!(x >= 3 && x < 8);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    ///# let x = 6;\n+    /// assert!((3..8).contains(&x));\n+    /// ```\n+    pub MANUAL_RANGE_CONTAINS,\n+    style,\n+    \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\"\n+}\n+\n declare_lint_pass!(Ranges => [\n     RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n     REVERSED_EMPTY_RANGES,\n+    MANUAL_RANGE_CONTAINS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-            let name = path.ident.as_str();\n-            if name == \"zip\" && args.len() == 2 {\n-                let iter = &args[0].kind;\n-                let zip_arg = &args[1];\n-                if_chain! {\n-                    // `.iter()` call\n-                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args , _) = *iter;\n-                    if iter_path.ident.name == sym!(iter);\n-                    // range expression in `.zip()` call: `0..x.len()`\n-                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n-                    if is_integer_const(cx, start, 0);\n-                    // `.len()` call\n-                    if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n-                    if len_path.ident.name == sym!(len) && len_args.len() == 1;\n-                    // `.iter()` and `.len()` called on same `Path`\n-                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n-                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n-                    if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n-                     then {\n-                         span_lint(cx,\n-                                   RANGE_ZIP_WITH_LEN,\n-                                   expr.span,\n-                                   &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                                            snippet(cx, iter_args[0].span, \"_\")));\n-                    }\n-                }\n-            }\n+        match expr.kind {\n+            ExprKind::MethodCall(ref path, _, ref args, _) => {\n+                check_range_zip_with_len(cx, path, args, expr.span);\n+            },\n+            ExprKind::Binary(ref op, ref l, ref r) => {\n+                check_possible_range_contains(cx, op.node, l, r, expr.span);\n+            },\n+            _ => {},\n         }\n \n         check_exclusive_range_plus_one(cx, expr);\n@@ -173,6 +185,148 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n     }\n }\n \n+fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, span: Span) {\n+    let combine_and = match op {\n+        BinOpKind::And | BinOpKind::BitAnd => true,\n+        BinOpKind::Or | BinOpKind::BitOr => false,\n+        _ => return,\n+    };\n+    // value, name, order (higher/lower), inclusiveness\n+    if let (Some((lval, lname, name_span, lval_span, lord, linc)), Some((rval, rname, _, rval_span, rord, rinc))) =\n+        (check_range_bounds(cx, l), check_range_bounds(cx, r))\n+    {\n+        // we only lint comparisons on the same name and with different\n+        // direction\n+        if lname != rname || lord == rord {\n+            return;\n+        }\n+        let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l), &lval, &rval);\n+        if combine_and && ord == Some(rord) {\n+            // order lower bound and upper bound\n+            let (l_span, u_span, l_inc, u_inc) = if rord == Ordering::Less {\n+                (lval_span, rval_span, linc, rinc)\n+            } else {\n+                (rval_span, lval_span, rinc, linc)\n+            };\n+            // we only lint inclusive lower bounds\n+            if !l_inc {\n+                return;\n+            }\n+            let (range_type, range_op) = if u_inc {\n+                (\"RangeInclusive\", \"..=\")\n+            } else {\n+                (\"Range\", \"..\")\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n+            let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_RANGE_CONTAINS,\n+                span,\n+                &format!(\"manual `{}::contains` implementation\", range_type),\n+                \"use\",\n+                format!(\"({}{}{}).contains(&{})\", lo, range_op, hi, name),\n+                applicability,\n+            );\n+        } else if !combine_and && ord == Some(lord) {\n+            // `!_.contains(_)`\n+            // order lower bound and upper bound\n+            let (l_span, u_span, l_inc, u_inc) = if lord == Ordering::Less {\n+                (lval_span, rval_span, linc, rinc)\n+            } else {\n+                (rval_span, lval_span, rinc, linc)\n+            };\n+            if l_inc {\n+                return;\n+            }\n+            let (range_type, range_op) = if u_inc {\n+                (\"Range\", \"..\")\n+            } else {\n+                (\"RangeInclusive\", \"..=\")\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n+            let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_RANGE_CONTAINS,\n+                span,\n+                &format!(\"manual `!{}::contains` implementation\", range_type),\n+                \"use\",\n+                format!(\"!({}{}{}).contains(&{})\", lo, range_op, hi, name),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n+    if let ExprKind::Binary(ref op, ref l, ref r) = ex.kind {\n+        let (inclusive, ordering) = match op.node {\n+            BinOpKind::Gt => (false, Ordering::Greater),\n+            BinOpKind::Ge => (true, Ordering::Greater),\n+            BinOpKind::Lt => (false, Ordering::Less),\n+            BinOpKind::Le => (true, Ordering::Less),\n+            _ => return None,\n+        };\n+        if let Some(id) = match_ident(l) {\n+            if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n+                return Some((c, id, l.span, r.span, ordering, inclusive));\n+            }\n+        } else if let Some(id) = match_ident(r) {\n+            if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n+                return Some((c, id, r.span, l.span, ordering.reverse(), inclusive));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n+    if let ExprKind::Path(ref qpath) = e.kind {\n+        if let Some(seg) = single_segment_path(qpath) {\n+            if seg.args.is_none() {\n+                return Some(seg.ident);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n+    let name = path.ident.as_str();\n+    if name == \"zip\" && args.len() == 2 {\n+        let iter = &args[0].kind;\n+        let zip_arg = &args[1];\n+        if_chain! {\n+            // `.iter()` call\n+            if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n+            if iter_path.ident.name == sym!(iter);\n+            // range expression in `.zip()` call: `0..x.len()`\n+            if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+            if is_integer_const(cx, start, 0);\n+            // `.len()` call\n+            if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n+            if len_path.ident.name == sym!(len) && len_args.len() == 1;\n+            // `.iter()` and `.len()` called on same `Path`\n+            if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n+            if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+            then {\n+                span_lint(cx,\n+                    RANGE_ZIP_WITH_LEN,\n+                    span,\n+                    &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                        snippet(cx, iter_args[0].span, \"_\"))\n+                );\n+            }\n+        }\n+    }\n+}\n+\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {"}, {"sha": "e90ea0fc200a9ab2177f98a9324eece30132094a", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/df855321126580ace6e3022372991c725d3e1b0a/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df855321126580ace6e3022372991c725d3e1b0a/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=df855321126580ace6e3022372991c725d3e1b0a", "patch": "@@ -1,183 +0,0 @@\n-use std::cmp;\n-\n-use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_ast::attr;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n-use rustc_target::abi::LayoutOf;\n-use rustc_target::spec::abi::Abi;\n-use rustc_target::spec::Target;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions taking arguments by reference, where\n-    /// the argument type is `Copy` and small enough to be more efficient to always\n-    /// pass by value.\n-    ///\n-    /// **Why is this bad?** In many calling conventions instances of structs will\n-    /// be passed through registers if they fit into two or less general purpose\n-    /// registers.\n-    ///\n-    /// **Known problems:** This lint is target register size dependent, it is\n-    /// limited to 32-bit to try and reduce portability problems between 32 and\n-    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n-    /// will be different.\n-    ///\n-    /// The configuration option `trivial_copy_size_limit` can be set to override\n-    /// this limit for a project.\n-    ///\n-    /// This lint attempts to allow passing arguments by reference if a reference\n-    /// to that argument is returned. This is implemented by comparing the lifetime\n-    /// of the argument and return value for equality. However, this can cause\n-    /// false positives in cases involving multiple lifetimes that are bounded by\n-    /// each other.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn foo(v: &u32) {}\n-    /// ```\n-    ///\n-    /// ```rust\n-    /// // Better\n-    /// fn foo(v: u32) {}\n-    /// ```\n-    pub TRIVIALLY_COPY_PASS_BY_REF,\n-    pedantic,\n-    \"functions taking small copyable arguments by reference\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct TriviallyCopyPassByRef {\n-    limit: u64,\n-}\n-\n-impl<'tcx> TriviallyCopyPassByRef {\n-    pub fn new(limit: Option<u64>, target: &Target) -> Self {\n-        let limit = limit.unwrap_or_else(|| {\n-            let bit_width = u64::from(target.pointer_width);\n-            // Cap the calculated bit width at 32-bits to reduce\n-            // portability problems between 32 and 64-bit targets\n-            let bit_width = cmp::min(bit_width, 32);\n-            #[allow(clippy::integer_division)]\n-            let byte_width = bit_width / 8;\n-            // Use a limit of 2 times the register byte width\n-            byte_width * 2\n-        });\n-        Self { limit }\n-    }\n-\n-    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n-        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n-\n-        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n-        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n-\n-        // Use lifetimes to determine if we're returning a reference to the\n-        // argument. In that case we can't switch to pass-by-value as the\n-        // argument will not live long enough.\n-        let output_lts = match *fn_sig.output().kind() {\n-            ty::Ref(output_lt, _, _) => vec![output_lt],\n-            ty::Adt(_, substs) => substs.regions().collect(),\n-            _ => vec![],\n-        };\n-\n-        for (input, &ty) in decl.inputs.iter().zip(fn_sig.inputs()) {\n-            // All spans generated from a proc-macro invocation are the same...\n-            match span {\n-                Some(s) if s == input.span => return,\n-                _ => (),\n-            }\n-\n-            if_chain! {\n-                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind();\n-                if !output_lts.contains(&input_lt);\n-                if is_copy(cx, ty);\n-                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n-                if size <= self.limit;\n-                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n-                then {\n-                    let value_type = if is_self_ty(decl_ty) {\n-                        \"self\".into()\n-                    } else {\n-                        snippet(cx, decl_ty.span, \"_\").into()\n-                    };\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TRIVIALLY_COPY_PASS_BY_REF,\n-                        input.span,\n-                        &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.limit),\n-                        \"consider passing by value instead\",\n-                        value_type,\n-                        Applicability::Unspecified,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(TriviallyCopyPassByRef => [TRIVIALLY_COPY_PASS_BY_REF]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if item.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n-        }\n-    }\n-\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        _body: &'tcx Body<'_>,\n-        span: Span,\n-        hir_id: HirId,\n-    ) {\n-        if span.from_expansion() {\n-            return;\n-        }\n-\n-        match kind {\n-            FnKind::ItemFn(.., header, _, attrs) => {\n-                if header.abi != Abi::Rust {\n-                    return;\n-                }\n-                for a in attrs {\n-                    if let Some(meta_items) = a.meta_item_list() {\n-                        if a.has_name(sym!(proc_macro_derive))\n-                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n-                        {\n-                            return;\n-                        }\n-                    }\n-                }\n-            },\n-            FnKind::Method(..) => (),\n-            FnKind::Closure(..) => return,\n-        }\n-\n-        // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-                ItemKind::Trait(..))\n-            {\n-                return;\n-            }\n-        }\n-\n-        self.check_poly_fn(cx, hir_id, decl, Some(span));\n-    }\n-}"}, {"sha": "6a33aaaaab204f660f1cda1aae0f158599561ec5", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind,\n+    ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind,\n     TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -1224,7 +1224,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for casts to the same type.\n+    /// **What it does:** Checks for casts to the same type, casts of int literals to integer types\n+    /// and casts of float literals to float types.\n     ///\n     /// **Why is this bad?** It's just unnecessary.\n     ///\n@@ -1233,6 +1234,14 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let _ = 2i32 as i32;\n+    /// let _ = 0.5 as f32;\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// let _ = 2_i32;\n+    /// let _ = 0.5_f32;\n     /// ```\n     pub UNNECESSARY_CAST,\n     complexity,\n@@ -1598,7 +1607,9 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n         if let ExprKind::Cast(ref ex, _) = expr.kind {\n             let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n-            if let ExprKind::Lit(ref lit) = ex.kind {\n+            if let Some(lit) = get_numeric_literal(ex) {\n+                let literal_str = snippet_opt(cx, ex.span).unwrap_or_default();\n+\n                 if_chain! {\n                     if let LitKind::Int(n, _) = lit.node;\n                     if let Some(src) = snippet_opt(cx, lit.span);\n@@ -1608,19 +1619,19 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                     let to_nbits = fp_ty_mantissa_nbits(cast_to);\n                     if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n                     then {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            UNNECESSARY_CAST,\n-                            expr.span,\n-                            &format!(\"casting integer literal to `{}` is unnecessary\", cast_to),\n-                            \"try\",\n-                            format!(\"{}_{}\", n, cast_to),\n-                            Applicability::MachineApplicable,\n-                        );\n+                        let literal_str = if is_unary_neg(ex) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n+                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n                         return;\n                     }\n                 }\n+\n                 match lit.node {\n+                    LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n+                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                    },\n+                    LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n+                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                    },\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n                     _ => {\n                         if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n@@ -1646,6 +1657,37 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n     }\n }\n \n+fn is_unary_neg(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Unary(UnOp::UnNeg, _))\n+}\n+\n+fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n+    match expr.kind {\n+        ExprKind::Lit(ref lit) => Some(lit),\n+        ExprKind::Unary(UnOp::UnNeg, e) => {\n+            if let ExprKind::Lit(ref lit) = e.kind {\n+                Some(lit)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn show_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n+    span_lint_and_sugg(\n+        cx,\n+        UNNECESSARY_CAST,\n+        expr.span,\n+        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n+        \"try\",\n+        format!(\"{}_{}\", literal_str, cast_to),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n fn lint_numeric_casts<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &Expr<'tcx>,"}, {"sha": "5443f1601fcbb083c8fcef94219a56a26d67cc5c", "filename": "clippy_lints/src/undropped_manually_drops.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,50 @@\n+use crate::utils::{is_type_lang_item, match_function_call, paths, span_lint_and_help};\n+use rustc_hir::{lang_items, Expr};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Prevents the safe `std::mem::drop` function from being called on `std::mem::ManuallyDrop`.\n+    ///\n+    /// **Why is this bad?** The safe `drop` function does not drop the inner value of a `ManuallyDrop`.\n+    ///\n+    /// **Known problems:** Does not catch cases if the user binds `std::mem::drop`\n+    /// to a different name and calls it that way.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct S;\n+    /// drop(std::mem::ManuallyDrop::new(S));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct S;\n+    /// unsafe {\n+    ///     std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n+    /// }\n+    /// ```\n+    pub UNDROPPED_MANUALLY_DROPS,\n+    correctness,\n+    \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\"\n+}\n+\n+declare_lint_pass!(UndroppedManuallyDrops => [UNDROPPED_MANUALLY_DROPS]);\n+\n+impl LateLintPass<'tcx> for UndroppedManuallyDrops {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some(ref args) = match_function_call(cx, expr, &paths::DROP) {\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if is_type_lang_item(cx, ty, lang_items::LangItem::ManuallyDrop) {\n+                span_lint_and_help(\n+                    cx,\n+                    UNDROPPED_MANUALLY_DROPS,\n+                    expr.span,\n+                    \"the inner value of this ManuallyDrop will not be dropped\",\n+                    None,\n+                    \"to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "0ac8fff69f05742f241109b52959341813bb2922", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -150,6 +150,8 @@ define_Conf! {\n     (literal_representation_threshold, \"literal_representation_threshold\": u64, 16384),\n     /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n     (trivial_copy_size_limit, \"trivial_copy_size_limit\": Option<u64>, None),\n+    /// Lint: LARGE_TYPE_PASS_BY_MOVE. The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n+    (pass_by_value_size_limit, \"pass_by_value_size_limit\": u64, 256),\n     /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n     (too_many_lines_threshold, \"too_many_lines_threshold\": u64, 100),\n     /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS. The maximum allowed size for arrays on the stack"}, {"sha": "8297b9d128dde9b863c03e62b36c61f779cce849", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -299,7 +299,7 @@ pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -\n         hir::QPath::Resolved(_, path) => path.res,\n         hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n             if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n-                cx.tcx.typeck(id.owner.to_def_id().expect_local()).qpath_res(qpath, id)\n+                cx.tcx.typeck(id.owner).qpath_res(qpath, id)\n             } else {\n                 Res::Err\n             }"}, {"sha": "cd9b92efe58373bf7996d0fdd8d9b63233289089", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -93,6 +93,8 @@ pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n+pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n+pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];"}, {"sha": "8b327b2d4675e54c0b9970c4afe204b32063a879", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -19,12 +19,11 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n         used_mutably: FxHashSet::default(),\n         skip: false,\n     };\n-    let def_id = expr.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         ExprUseVisitor::new(\n             &mut delegate,\n             &infcx,\n-            def_id.expect_local(),\n+            expr.hir_id.owner,\n             cx.param_env,\n             cx.typeck_results(),\n         )"}, {"sha": "4bf77dae6377097d2186756af597cb73f9749488", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -62,10 +62,17 @@ vec![\n     },\n     Lint {\n         name: \"await_holding_lock\",\n-        group: \"pedantic\",\n+        group: \"correctness\",\n         desc: \"Inside an async function, holding a MutexGuard while calling await\",\n         deprecation: None,\n-        module: \"await_holding_lock\",\n+        module: \"await_holding_invalid\",\n+    },\n+    Lint {\n+        name: \"await_holding_refcell_ref\",\n+        group: \"correctness\",\n+        desc: \"Inside an async function, holding a RefCell ref while calling await\",\n+        deprecation: None,\n+        module: \"await_holding_invalid\",\n     },\n     Lint {\n         name: \"bad_bit_mask\",\n@@ -1061,6 +1068,13 @@ vec![\n         deprecation: None,\n         module: \"large_stack_arrays\",\n     },\n+    Lint {\n+        name: \"large_types_passed_by_value\",\n+        group: \"pedantic\",\n+        desc: \"functions taking large arguments by value\",\n+        deprecation: None,\n+        module: \"pass_by_ref_or_value\",\n+    },\n     Lint {\n         name: \"len_without_is_empty\",\n         group: \"style\",\n@@ -1159,6 +1173,13 @@ vec![\n         deprecation: None,\n         module: \"manual_non_exhaustive\",\n     },\n+    Lint {\n+        name: \"manual_range_contains\",\n+        group: \"style\",\n+        desc: \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\",\n@@ -1183,7 +1204,7 @@ vec![\n     Lint {\n         name: \"manual_unwrap_or\",\n         group: \"complexity\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\",\n         deprecation: None,\n         module: \"manual_unwrap_or\",\n     },\n@@ -1488,6 +1509,13 @@ vec![\n         deprecation: None,\n         module: \"mut_mut\",\n     },\n+    Lint {\n+        name: \"mut_mutex_lock\",\n+        group: \"style\",\n+        desc: \"`&mut Mutex::lock` does unnecessary locking\",\n+        deprecation: None,\n+        module: \"mut_mutex_lock\",\n+    },\n     Lint {\n         name: \"mut_range_bound\",\n         group: \"complexity\",\n@@ -2125,6 +2153,13 @@ vec![\n         deprecation: None,\n         module: \"single_component_path_imports\",\n     },\n+    Lint {\n+        name: \"single_element_loop\",\n+        group: \"complexity\",\n+        desc: \"there is no reason to have a single element loop\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n     Lint {\n         name: \"single_match\",\n         group: \"style\",\n@@ -2389,7 +2424,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"functions taking small copyable arguments by reference\",\n         deprecation: None,\n-        module: \"trivially_copy_pass_by_ref\",\n+        module: \"pass_by_ref_or_value\",\n     },\n     Lint {\n         name: \"try_err\",\n@@ -2412,6 +2447,13 @@ vec![\n         deprecation: None,\n         module: \"trait_bounds\",\n     },\n+    Lint {\n+        name: \"undropped_manually_drops\",\n+        group: \"correctness\",\n+        desc: \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\",\n+        deprecation: None,\n+        module: \"undropped_manually_drops\",\n+    },\n     Lint {\n         name: \"unicode_not_nfc\",\n         group: \"pedantic\","}, {"sha": "a58e7e918e2f85a6301c5f2d062f1fbce0bc892b", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "88841597bb60bf5bc8a8bff346fdfc9391a40cfe", "filename": "tests/ui/await_holding_refcell_ref.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,86 @@\n+// edition:2018\n+#![warn(clippy::await_holding_refcell_ref)]\n+\n+use std::cell::RefCell;\n+\n+async fn bad(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow();\n+    baz().await\n+}\n+\n+async fn bad_mut(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow_mut();\n+    baz().await\n+}\n+\n+async fn good(x: &RefCell<u32>) -> u32 {\n+    {\n+        let b = x.borrow_mut();\n+        let y = *b + 1;\n+    }\n+    baz().await;\n+    let b = x.borrow_mut();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn less_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    drop(b);\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let b = x.borrow_mut();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let b = x.borrow_mut();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let rc = RefCell::new(100);\n+    good(&rc);\n+    bad(&rc);\n+    bad_mut(&rc);\n+    also_bad(&rc);\n+    less_bad(&rc);\n+    not_good(&rc);\n+    block_bad(&rc);\n+}"}, {"sha": "b504f0454913634969cb11a6ced5b3fc5e9fb2f9", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,95 @@\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:7:9\n+   |\n+LL |     let b = x.borrow();\n+   |         ^\n+   |\n+   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:7:5\n+   |\n+LL | /     let b = x.borrow();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:12:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:12:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:33:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:33:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:45:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:45:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:60:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:60:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:72:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:72:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "5a012ff4d27ab184ff758cf1f1492246a51e47c1", "filename": "tests/ui/bool_comparison.fixed", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fbool_comparison.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fbool_comparison.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_comparison.fixed?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n-#[warn(clippy::bool_comparison)]\n+#![warn(clippy::bool_comparison)]\n+\n fn main() {\n     let x = true;\n     if x {\n@@ -127,3 +128,40 @@ fn issue4983() {\n     if b == a {};\n     if !b == !a {};\n }\n+\n+macro_rules! m {\n+    ($func:ident) => {\n+        $func()\n+    };\n+}\n+\n+fn func() -> bool {\n+    true\n+}\n+\n+#[allow(dead_code)]\n+fn issue3973() {\n+    // ok, don't lint on `cfg` invocation\n+    if false == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == false {}\n+    if true == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == true {}\n+\n+    // lint, could be simplified\n+    if !m!(func) {}\n+    if !m!(func) {}\n+    if m!(func) {}\n+    if m!(func) {}\n+\n+    // no lint with a variable\n+    let is_debug = false;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+    let is_debug = true;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+}"}, {"sha": "c534bc25c20f1105ea497f9405d24a5334c3f7b9", "filename": "tests/ui/bool_comparison.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fbool_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fbool_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_comparison.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n-#[warn(clippy::bool_comparison)]\n+#![warn(clippy::bool_comparison)]\n+\n fn main() {\n     let x = true;\n     if x == true {\n@@ -127,3 +128,40 @@ fn issue4983() {\n     if b == a {};\n     if !b == !a {};\n }\n+\n+macro_rules! m {\n+    ($func:ident) => {\n+        $func()\n+    };\n+}\n+\n+fn func() -> bool {\n+    true\n+}\n+\n+#[allow(dead_code)]\n+fn issue3973() {\n+    // ok, don't lint on `cfg` invocation\n+    if false == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == false {}\n+    if true == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == true {}\n+\n+    // lint, could be simplified\n+    if false == m!(func) {}\n+    if m!(func) == false {}\n+    if true == m!(func) {}\n+    if m!(func) == true {}\n+\n+    // no lint with a variable\n+    let is_debug = false;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+    let is_debug = true;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+}"}, {"sha": "31522d4a525199e23c9ec51da602c2b2ee2495ac", "filename": "tests/ui/bool_comparison.stderr", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fbool_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fbool_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_comparison.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,112 +1,136 @@\n error: equality checks against true are unnecessary\n-  --> $DIR/bool_comparison.rs:6:8\n+  --> $DIR/bool_comparison.rs:7:8\n    |\n LL |     if x == true {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n    |\n    = note: `-D clippy::bool-comparison` implied by `-D warnings`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:11:8\n+  --> $DIR/bool_comparison.rs:12:8\n    |\n LL |     if x == false {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/bool_comparison.rs:16:8\n+  --> $DIR/bool_comparison.rs:17:8\n    |\n LL |     if true == x {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:21:8\n+  --> $DIR/bool_comparison.rs:22:8\n    |\n LL |     if false == x {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: inequality checks against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:26:8\n+  --> $DIR/bool_comparison.rs:27:8\n    |\n LL |     if x != true {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: inequality checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:31:8\n+  --> $DIR/bool_comparison.rs:32:8\n    |\n LL |     if x != false {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: inequality checks against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:36:8\n+  --> $DIR/bool_comparison.rs:37:8\n    |\n LL |     if true != x {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: inequality checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:41:8\n+  --> $DIR/bool_comparison.rs:42:8\n    |\n LL |     if false != x {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: less than comparison against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:46:8\n+  --> $DIR/bool_comparison.rs:47:8\n    |\n LL |     if x < true {\n    |        ^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: greater than checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:51:8\n+  --> $DIR/bool_comparison.rs:52:8\n    |\n LL |     if false < x {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: greater than checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:56:8\n+  --> $DIR/bool_comparison.rs:57:8\n    |\n LL |     if x > false {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: less than comparison against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:61:8\n+  --> $DIR/bool_comparison.rs:62:8\n    |\n LL |     if true > x {\n    |        ^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: order comparisons between booleans can be simplified\n-  --> $DIR/bool_comparison.rs:67:8\n+  --> $DIR/bool_comparison.rs:68:8\n    |\n LL |     if x < y {\n    |        ^^^^^ help: try simplifying it as shown: `!x & y`\n \n error: order comparisons between booleans can be simplified\n-  --> $DIR/bool_comparison.rs:72:8\n+  --> $DIR/bool_comparison.rs:73:8\n    |\n LL |     if x > y {\n    |        ^^^^^ help: try simplifying it as shown: `x & !y`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:120:8\n+  --> $DIR/bool_comparison.rs:121:8\n    |\n LL |     if a == !b {};\n    |        ^^^^^^^ help: try simplifying it as shown: `a != b`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:121:8\n+  --> $DIR/bool_comparison.rs:122:8\n    |\n LL |     if !a == b {};\n    |        ^^^^^^^ help: try simplifying it as shown: `a != b`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:125:8\n+  --> $DIR/bool_comparison.rs:126:8\n    |\n LL |     if b == !a {};\n    |        ^^^^^^^ help: try simplifying it as shown: `b != a`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:126:8\n+  --> $DIR/bool_comparison.rs:127:8\n    |\n LL |     if !b == a {};\n    |        ^^^^^^^ help: try simplifying it as shown: `b != a`\n \n-error: aborting due to 18 previous errors\n+error: equality checks against false can be replaced by a negation\n+  --> $DIR/bool_comparison.rs:151:8\n+   |\n+LL |     if false == m!(func) {}\n+   |        ^^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `!m!(func)`\n+\n+error: equality checks against false can be replaced by a negation\n+  --> $DIR/bool_comparison.rs:152:8\n+   |\n+LL |     if m!(func) == false {}\n+   |        ^^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `!m!(func)`\n+\n+error: equality checks against true are unnecessary\n+  --> $DIR/bool_comparison.rs:153:8\n+   |\n+LL |     if true == m!(func) {}\n+   |        ^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `m!(func)`\n+\n+error: equality checks against true are unnecessary\n+  --> $DIR/bool_comparison.rs:154:8\n+   |\n+LL |     if m!(func) == true {}\n+   |        ^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `m!(func)`\n+\n+error: aborting due to 22 previous errors\n "}, {"sha": "140676a5ffcfc82ad79dadf0f18d9c7d79390ae7", "filename": "tests/ui/cast_size_32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fcast_size_32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fcast_size_32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_size_32bit.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -124,7 +124,7 @@ error: casting integer literal to `f64` is unnecessary\n   --> $DIR/cast_size_32bit.rs:34:5\n    |\n LL |     3_999_999_999usize as f64;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `3999999999_f64`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `3_999_999_999_f64`\n    |\n    = note: `-D clippy::unnecessary-cast` implied by `-D warnings`\n "}, {"sha": "bb03ce4035533a4b19a8bb0cb99e8cfb1b43fe47", "filename": "tests/ui/crashes/ice-360.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fcrashes%2Fice-360.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fcrashes%2Fice-360.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-360.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -12,13 +12,14 @@ LL | |     }\n    |\n    = note: `-D clippy::while-let-loop` implied by `-D warnings`\n \n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/ice-360.rs:10:9\n    |\n LL |         loop {}\n    |         ^^^^^^^\n    |\n    = note: `-D clippy::empty-loop` implied by `-D warnings`\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fd3979f259a145c6ea6a917fb2876a7119d7f3f8", "filename": "tests/ui/empty_loop.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fempty_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fempty_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_loop.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,22 +1,27 @@\n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:9:5\n    |\n LL |     loop {}\n    |     ^^^^^^^\n    |\n    = note: `-D clippy::empty-loop` implied by `-D warnings`\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:11:9\n    |\n LL |         loop {}\n    |         ^^^^^^^\n+   |\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:15:9\n    |\n LL |         'inner: loop {}\n    |         ^^^^^^^^^^^^^^^\n+   |\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n error: aborting due to 3 previous errors\n "}, {"sha": "879d1d5d916e439bf219fef4e343ab0320c13d51", "filename": "tests/ui/empty_loop_no_std.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fempty_loop_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fempty_loop_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_loop_no_std.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "previous_filename": "tests/ui/issue-3746.rs"}, {"sha": "4e09d19ea214572f70adbeba6142268609c7a2f7", "filename": "tests/ui/eq_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -6,6 +6,7 @@\n #[allow(clippy::no_effect, unused_variables, clippy::unnecessary_operation, clippy::short_circuit_statement)]\n #[allow(clippy::nonminimal_bool)]\n #[allow(unused)]\n+#[allow(clippy::unnecessary_cast)]\n fn main() {\n     // simple values and comparisons\n     1 == 1;"}, {"sha": "ad81b35a766493c9e81e61bca13a8540ef1e6f91", "filename": "tests/ui/eq_op.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,163 +1,163 @@\n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:11:5\n+  --> $DIR/eq_op.rs:12:5\n    |\n LL |     1 == 1;\n    |     ^^^^^^\n    |\n    = note: `-D clippy::eq-op` implied by `-D warnings`\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:12:5\n+  --> $DIR/eq_op.rs:13:5\n    |\n LL |     \"no\" == \"no\";\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:14:5\n+  --> $DIR/eq_op.rs:15:5\n    |\n LL |     false != false;\n    |     ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:15:5\n+  --> $DIR/eq_op.rs:16:5\n    |\n LL |     1.5 < 1.5;\n    |     ^^^^^^^^^\n \n error: equal expressions as operands to `>=`\n-  --> $DIR/eq_op.rs:16:5\n+  --> $DIR/eq_op.rs:17:5\n    |\n LL |     1u64 >= 1u64;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:19:5\n+  --> $DIR/eq_op.rs:20:5\n    |\n LL |     (1 as u64) & (1 as u64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `^`\n-  --> $DIR/eq_op.rs:20:5\n+  --> $DIR/eq_op.rs:21:5\n    |\n LL |     1 ^ ((((((1))))));\n    |     ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:23:5\n+  --> $DIR/eq_op.rs:24:5\n    |\n LL |     (-(2) < -(2));\n    |     ^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:24:5\n+  --> $DIR/eq_op.rs:25:5\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:24:6\n+  --> $DIR/eq_op.rs:25:6\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |      ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:24:27\n+  --> $DIR/eq_op.rs:25:27\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |                           ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:25:5\n+  --> $DIR/eq_op.rs:26:5\n    |\n LL |     (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:28:5\n+  --> $DIR/eq_op.rs:29:5\n    |\n LL |     ([1] != [1]);\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:29:5\n+  --> $DIR/eq_op.rs:30:5\n    |\n LL |     ((1, 2) != (1, 2));\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:33:5\n+  --> $DIR/eq_op.rs:34:5\n    |\n LL |     1 + 1 == 2;\n    |     ^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:34:5\n+  --> $DIR/eq_op.rs:35:5\n    |\n LL |     1 - 1 == 0;\n    |     ^^^^^^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:34:5\n+  --> $DIR/eq_op.rs:35:5\n    |\n LL |     1 - 1 == 0;\n    |     ^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:36:5\n+  --> $DIR/eq_op.rs:37:5\n    |\n LL |     1 - 1;\n    |     ^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:37:5\n+  --> $DIR/eq_op.rs:38:5\n    |\n LL |     1 / 1;\n    |     ^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:38:5\n+  --> $DIR/eq_op.rs:39:5\n    |\n LL |     true && true;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `||`\n-  --> $DIR/eq_op.rs:40:5\n+  --> $DIR/eq_op.rs:41:5\n    |\n LL |     true || true;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:46:5\n+  --> $DIR/eq_op.rs:47:5\n    |\n LL |     a == b && b == a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:47:5\n+  --> $DIR/eq_op.rs:48:5\n    |\n LL |     a != b && b != a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:48:5\n+  --> $DIR/eq_op.rs:49:5\n    |\n LL |     a < b && b > a;\n    |     ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:49:5\n+  --> $DIR/eq_op.rs:50:5\n    |\n LL |     a <= b && b >= a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:52:5\n+  --> $DIR/eq_op.rs:53:5\n    |\n LL |     a == a;\n    |     ^^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:62:20\n+  --> $DIR/eq_op.rs:63:20\n    |\n LL |     const D: u32 = A / A;\n    |                    ^^^^^"}, {"sha": "8d54f75b5d19f297d7f4e56be4f5659dc81b1a31", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -3,7 +3,8 @@\n     clippy::blacklisted_name,\n     clippy::collapsible_if,\n     clippy::ifs_same_cond,\n-    clippy::needless_return\n+    clippy::needless_return,\n+    clippy::single_element_loop\n )]\n \n fn if_same_then_else2() -> Result<&'static str, ()> {"}, {"sha": "da2be6c8aa5acb4078b1787fca8aac2234dbcbe0", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,5 +1,5 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:19:12\n+  --> $DIR/if_same_then_else2.rs:20:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -13,7 +13,7 @@ LL | |     }\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:10:13\n+  --> $DIR/if_same_then_else2.rs:11:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -26,7 +26,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:33:12\n+  --> $DIR/if_same_then_else2.rs:34:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:31:13\n+  --> $DIR/if_same_then_else2.rs:32:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -45,7 +45,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:40:12\n+  --> $DIR/if_same_then_else2.rs:41:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -55,7 +55,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:38:13\n+  --> $DIR/if_same_then_else2.rs:39:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -64,7 +64,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:90:12\n+  --> $DIR/if_same_then_else2.rs:91:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:88:21\n+  --> $DIR/if_same_then_else2.rs:89:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -83,7 +83,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:97:12\n+  --> $DIR/if_same_then_else2.rs:98:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -93,7 +93,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:95:13\n+  --> $DIR/if_same_then_else2.rs:96:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -102,7 +102,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:122:12\n+  --> $DIR/if_same_then_else2.rs:123:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -112,7 +112,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:119:20\n+  --> $DIR/if_same_then_else2.rs:120:20\n    |\n LL |       } else if true {\n    |  ____________________^"}, {"sha": "e4a2e9df4d7ba71d6ad41d0f9faa75d3f7ced853", "filename": "tests/ui/large_types_passed_by_value.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Flarge_types_passed_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Flarge_types_passed_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_types_passed_by_value.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,66 @@\n+// normalize-stderr-test \"\\(\\d+ byte\\)\" -> \"(N byte)\"\n+// normalize-stderr-test \"\\(limit: \\d+ byte\\)\" -> \"(limit: N byte)\"\n+\n+#![warn(clippy::large_types_passed_by_value)]\n+\n+pub struct Large([u8; 2048]);\n+\n+#[derive(Clone, Copy)]\n+pub struct LargeAndCopy([u8; 2048]);\n+\n+pub struct Small([u8; 4]);\n+\n+#[derive(Clone, Copy)]\n+pub struct SmallAndCopy([u8; 4]);\n+\n+fn small(a: Small, b: SmallAndCopy) {}\n+fn not_copy(a: Large) {}\n+fn by_ref(a: &Large, b: &LargeAndCopy) {}\n+fn mutable(mut a: LargeAndCopy) {}\n+fn bad(a: LargeAndCopy) {}\n+pub fn bad_but_pub(a: LargeAndCopy) {}\n+\n+impl LargeAndCopy {\n+    fn self_is_ok(self) {}\n+    fn other_is_not_ok(self, other: LargeAndCopy) {}\n+    fn unless_other_can_change(self, mut other: LargeAndCopy) {}\n+    pub fn or_were_in_public(self, other: LargeAndCopy) {}\n+}\n+\n+trait LargeTypeDevourer {\n+    fn devoure_array(&self, array: [u8; 6666]);\n+    fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy));\n+    fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+}\n+\n+pub trait PubLargeTypeDevourer {\n+    fn devoure_array_in_public(&self, array: [u8; 6666]);\n+}\n+\n+struct S {}\n+impl LargeTypeDevourer for S {\n+    fn devoure_array(&self, array: [u8; 6666]) {\n+        todo!();\n+    }\n+    fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy)) {\n+        todo!();\n+    }\n+    fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy)) {\n+        todo!();\n+    }\n+}\n+\n+#[inline(always)]\n+fn foo_always(x: LargeAndCopy) {\n+    todo!();\n+}\n+#[inline(never)]\n+fn foo_never(x: LargeAndCopy) {\n+    todo!();\n+}\n+#[inline]\n+fn foo(x: LargeAndCopy) {\n+    todo!();\n+}\n+\n+fn main() {}"}, {"sha": "5f42dcfb9b5218e43238f9d3bf26777e8aa630a0", "filename": "tests/ui/large_types_passed_by_value.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Flarge_types_passed_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Flarge_types_passed_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_types_passed_by_value.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,52 @@\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:20:11\n+   |\n+LL | fn bad(a: LargeAndCopy) {}\n+   |           ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+   |\n+   = note: `-D clippy::large-types-passed-by-value` implied by `-D warnings`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:25:37\n+   |\n+LL |     fn other_is_not_ok(self, other: LargeAndCopy) {}\n+   |                                     ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:31:36\n+   |\n+LL |     fn devoure_array(&self, array: [u8; 6666]);\n+   |                                    ^^^^^^^^^^ help: consider passing by reference instead: `&[u8; 6666]`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:32:34\n+   |\n+LL |     fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy));\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider passing by reference instead: `&(LargeAndCopy, LargeAndCopy)`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:33:50\n+   |\n+LL |     fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+   |                                                  ^^^^^^^^^^ help: consider passing by reference instead: `&[u8; 6666]`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:33:67\n+   |\n+LL |     fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider passing by reference instead: `&(LargeAndCopy, LargeAndCopy)`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:58:17\n+   |\n+LL | fn foo_never(x: LargeAndCopy) {\n+   |                 ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:62:11\n+   |\n+LL | fn foo(x: LargeAndCopy) {\n+   |           ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "5aa5a43cb92cf672da6888096fed8bd4ceb9db3b", "filename": "tests/ui/manual_unwrap_or.fixed", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.fixed?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,7 +1,8 @@\n // run-rustfix\n #![allow(dead_code)]\n+#![allow(unused_variables)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     Some(1).unwrap_or(42);\n \n@@ -65,4 +66,74 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    Ok::<i32, &str>(1).unwrap_or(42);\n+\n+    // int case, scrutinee is a binding\n+    let a = Ok::<i32, &str>(1);\n+    a.unwrap_or(42);\n+\n+    // int case, suggestion must surround Result expr with parenthesis\n+    (Ok(1) as Result<i32, &str>).unwrap_or(42);\n+\n+    // method call case, suggestion must not surround Result expr `s.method()` with parenthesis\n+    struct S {}\n+    impl S {\n+        fn method(self) -> Option<i32> {\n+            Some(42)\n+        }\n+    }\n+    let s = S {};\n+    s.method().unwrap_or(42);\n+\n+    // int case reversed\n+    Ok::<i32, &str>(1).unwrap_or(42);\n+\n+    // richer none expr\n+    Ok::<i32, &str>(1).unwrap_or(1 + 42);\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    Ok::<i32, &str>(1).unwrap_or({\n+        42 + 42\n+            + 42 + 42 + 42\n+            + 42 + 42 + 42\n+    });\n+\n+    // string case\n+    Ok::<&str, &str>(\"Bob\").unwrap_or(\"Alice\");\n+\n+    // don't lint\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+\n+    // don't lint, Err value is used\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => s,\n+    };\n+    // could lint, but unused_variables takes care of it\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => \"Bob\",\n+    };\n+}\n+\n fn main() {}"}, {"sha": "df534031f54c32c83991357f07cb3826f021323c", "filename": "tests/ui/manual_unwrap_or.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,7 +1,8 @@\n // run-rustfix\n #![allow(dead_code)]\n+#![allow(unused_variables)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     match Some(1) {\n         Some(i) => i,\n@@ -80,4 +81,98 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case, scrutinee is a binding\n+    let a = Ok::<i32, &str>(1);\n+    match a {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case, suggestion must surround Result expr with parenthesis\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // method call case, suggestion must not surround Result expr `s.method()` with parenthesis\n+    struct S {}\n+    impl S {\n+        fn method(self) -> Option<i32> {\n+            Some(42)\n+        }\n+    }\n+    let s = S {};\n+    match s.method() {\n+        Some(i) => i,\n+        None => 42,\n+    };\n+\n+    // int case reversed\n+    match Ok::<i32, &str>(1) {\n+        Err(_) => 42,\n+        Ok(i) => i,\n+    };\n+\n+    // richer none expr\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => 1 + 42,\n+    };\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => {\n+            42 + 42\n+                + 42 + 42 + 42\n+                + 42 + 42 + 42\n+        }\n+    };\n+\n+    // string case\n+    match Ok::<&str, &str>(\"Bob\") {\n+        Ok(i) => i,\n+        Err(_) => \"Alice\",\n+    };\n+\n+    // don't lint\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+\n+    // don't lint, Err value is used\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => s,\n+    };\n+    // could lint, but unused_variables takes care of it\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => \"Bob\",\n+    };\n+}\n+\n fn main() {}"}, {"sha": "fc174c4c2705dc3c6d7ea4b6df6b889b7b881c8c", "filename": "tests/ui/manual_unwrap_or.stderr", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmanual_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmanual_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,5 +1,5 @@\n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:6:5\n+  --> $DIR/manual_unwrap_or.rs:7:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -10,7 +10,7 @@ LL | |     };\n    = note: `-D clippy::manual-unwrap-or` implied by `-D warnings`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:12:5\n+  --> $DIR/manual_unwrap_or.rs:13:5\n    |\n LL | /     match Some(1) {\n LL | |         None => 42,\n@@ -19,7 +19,7 @@ LL | |     };\n    | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:18:5\n+  --> $DIR/manual_unwrap_or.rs:19:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -28,7 +28,7 @@ LL | |     };\n    | |_____^ help: replace with: `Some(1).unwrap_or(1 + 42)`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:25:5\n+  --> $DIR/manual_unwrap_or.rs:26:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -49,13 +49,97 @@ LL |     });\n    |\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:35:5\n+  --> $DIR/manual_unwrap_or.rs:36:5\n    |\n LL | /     match Some(\"Bob\") {\n LL | |         Some(i) => i,\n LL | |         None => \"Alice\",\n LL | |     };\n    | |_____^ help: replace with: `Some(\"Bob\").unwrap_or(\"Alice\")`\n \n-error: aborting due to 5 previous errors\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:86:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:93:5\n+   |\n+LL | /     match a {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `a.unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:99:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(1) as Result<i32, &str>).unwrap_or(42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:112:5\n+   |\n+LL | /     match s.method() {\n+LL | |         Some(i) => i,\n+LL | |         None => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `s.method().unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:118:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Err(_) => 42,\n+LL | |         Ok(i) => i,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:124:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 1 + 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(1 + 42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:131:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => {\n+LL | |             42 + 42\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     Ok::<i32, &str>(1).unwrap_or({\n+LL |         42 + 42\n+LL |             + 42 + 42 + 42\n+LL |             + 42 + 42 + 42\n+LL |     });\n+   |\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:141:5\n+   |\n+LL | /     match Ok::<&str, &str>(\"Bob\") {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => \"Alice\",\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<&str, &str>(\"Bob\").unwrap_or(\"Alice\")`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "36bc52e3374e1a9747ddfdcad7da7306963bb092", "filename": "tests/ui/mut_mutex_lock.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmut_mutex_lock.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmut_mutex_lock.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_mutex_lock.fixed?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![allow(dead_code, unused_mut)]\n+#![warn(clippy::mut_mutex_lock)]\n+\n+use std::sync::{Arc, Mutex};\n+\n+fn mut_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+\n+    let mut value = value_mutex.get_mut().unwrap();\n+    *value += 1;\n+}\n+\n+fn no_owned_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let mut value = value_rc.lock().unwrap();\n+    *value += 1;\n+}\n+\n+fn main() {}"}, {"sha": "ea60df5ae1bbc92cda19453e4756aefea50833b3", "filename": "tests/ui/mut_mutex_lock.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_mutex_lock.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![allow(dead_code, unused_mut)]\n+#![warn(clippy::mut_mutex_lock)]\n+\n+use std::sync::{Arc, Mutex};\n+\n+fn mut_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+\n+    let mut value = value_mutex.lock().unwrap();\n+    *value += 1;\n+}\n+\n+fn no_owned_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let mut value = value_rc.lock().unwrap();\n+    *value += 1;\n+}\n+\n+fn main() {}"}, {"sha": "21c1b3486cacf5f2a23a90c16e02e268b8ff0f6b", "filename": "tests/ui/mut_mutex_lock.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmut_mutex_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fmut_mutex_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_mutex_lock.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,10 @@\n+error: calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\n+  --> $DIR/mut_mutex_lock.rs:11:33\n+   |\n+LL |     let mut value = value_mutex.lock().unwrap();\n+   |                                 ^^^^ help: change this to: `get_mut`\n+   |\n+   = note: `-D clippy::mut-mutex-lock` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "6001ef37eb781cbb497397e1cbbdb74fd0d7bcb6", "filename": "tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -357,4 +357,15 @@ mod nested_elision_sites {\n     }\n }\n \n+mod issue6159 {\n+    use std::ops::Deref;\n+    pub fn apply_deref<'a, T, F, R>(x: &'a T, f: F) -> R\n+    where\n+        T: Deref,\n+        F: FnOnce(&'a T::Target) -> R,\n+    {\n+        f(x.deref())\n+    }\n+}\n+\n fn main() {}"}, {"sha": "632a6592a28b84b6831c29dd4e65bb90143d0dbb", "filename": "tests/ui/range_contains.fixed", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Frange_contains.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Frange_contains.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.fixed?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#[warn(clippy::manual_range_contains)]\n+#[allow(unused)]\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+fn main() {\n+    let x = 9_u32;\n+\n+    // order shouldn't matter\n+    (8..12).contains(&x);\n+    (21..42).contains(&x);\n+    (1..100).contains(&x);\n+\n+    // also with inclusive ranges\n+    (9..=99).contains(&x);\n+    (1..=33).contains(&x);\n+    (1..=999).contains(&x);\n+\n+    // and the outside\n+    !(8..12).contains(&x);\n+    !(21..42).contains(&x);\n+    !(1..100).contains(&x);\n+\n+    // also with the outside of inclusive ranges\n+    !(9..=99).contains(&x);\n+    !(1..=33).contains(&x);\n+    !(1..=999).contains(&x);\n+\n+    // not a range.contains\n+    x > 8 && x < 12; // lower bound not inclusive\n+    x < 8 && x <= 12; // same direction\n+    x >= 12 && 12 >= x; // same bounds\n+    x < 8 && x > 12; // wrong direction\n+\n+    x <= 8 || x >= 12;\n+    x >= 8 || x >= 12;\n+    x < 12 || 12 < x;\n+    x >= 8 || x <= 12;\n+}"}, {"sha": "6af0d034ef617b25576507cf407b79a59879ba70", "filename": "tests/ui/range_contains.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Frange_contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Frange_contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#[warn(clippy::manual_range_contains)]\n+#[allow(unused)]\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+fn main() {\n+    let x = 9_u32;\n+\n+    // order shouldn't matter\n+    x >= 8 && x < 12;\n+    x < 42 && x >= 21;\n+    100 > x && 1 <= x;\n+\n+    // also with inclusive ranges\n+    x >= 9 && x <= 99;\n+    x <= 33 && x >= 1;\n+    999 >= x && 1 <= x;\n+\n+    // and the outside\n+    x < 8 || x >= 12;\n+    x >= 42 || x < 21;\n+    100 <= x || 1 > x;\n+\n+    // also with the outside of inclusive ranges\n+    x < 9 || x > 99;\n+    x > 33 || x < 1;\n+    999 < x || 1 > x;\n+\n+    // not a range.contains\n+    x > 8 && x < 12; // lower bound not inclusive\n+    x < 8 && x <= 12; // same direction\n+    x >= 12 && 12 >= x; // same bounds\n+    x < 8 && x > 12; // wrong direction\n+\n+    x <= 8 || x >= 12;\n+    x >= 8 || x >= 12;\n+    x < 12 || 12 < x;\n+    x >= 8 || x <= 12;\n+}"}, {"sha": "69b009eafc30ab589f603f5d9c166072e560d173", "filename": "tests/ui/range_contains.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Frange_contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Frange_contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,76 @@\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:12:5\n+   |\n+LL |     x >= 8 && x < 12;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `(8..12).contains(&x)`\n+   |\n+   = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n+\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:13:5\n+   |\n+LL |     x < 42 && x >= 21;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(21..42).contains(&x)`\n+\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:14:5\n+   |\n+LL |     100 > x && 1 <= x;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(1..100).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:17:5\n+   |\n+LL |     x >= 9 && x <= 99;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(9..=99).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:18:5\n+   |\n+LL |     x <= 33 && x >= 1;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(1..=33).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:19:5\n+   |\n+LL |     999 >= x && 1 <= x;\n+   |     ^^^^^^^^^^^^^^^^^^ help: use: `(1..=999).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:22:5\n+   |\n+LL |     x < 8 || x >= 12;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `!(8..12).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:23:5\n+   |\n+LL |     x >= 42 || x < 21;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `!(21..42).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:24:5\n+   |\n+LL |     100 <= x || 1 > x;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `!(1..100).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:27:5\n+   |\n+LL |     x < 9 || x > 99;\n+   |     ^^^^^^^^^^^^^^^ help: use: `!(9..=99).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:28:5\n+   |\n+LL |     x > 33 || x < 1;\n+   |     ^^^^^^^^^^^^^^^ help: use: `!(1..=33).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:29:5\n+   |\n+LL |     999 < x || 1 > x;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `!(1..=999).contains(&x)`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "8ca068293a611455cd246bd1d5a16b73456027c7", "filename": "tests/ui/single_element_loop.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fsingle_element_loop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fsingle_element_loop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_element_loop.fixed?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+// Tests from for_loop.rs that don't have suggestions\n+\n+#[warn(clippy::single_element_loop)]\n+fn main() {\n+    let item1 = 2;\n+    {\n+        let item = &item1;\n+        println!(\"{}\", item);\n+    }\n+}"}, {"sha": "57e9336a31fcf6c3d775273f7c7a78bedee5c0cf", "filename": "tests/ui/single_element_loop.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_element_loop.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+// Tests from for_loop.rs that don't have suggestions\n+\n+#[warn(clippy::single_element_loop)]\n+fn main() {\n+    let item1 = 2;\n+    for item in &[item1] {\n+        println!(\"{}\", item);\n+    }\n+}"}, {"sha": "90be1dc328371f6bc611cc236bd14b31f600d6e1", "filename": "tests/ui/single_element_loop.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fsingle_element_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fsingle_element_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_element_loop.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,19 @@\n+error: for loop over a single element\n+  --> $DIR/single_element_loop.rs:7:5\n+   |\n+LL | /     for item in &[item1] {\n+LL | |         println!(\"{}\", item);\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::single-element-loop` implied by `-D warnings`\n+help: try\n+   |\n+LL |     {\n+LL |         let item = &item1;\n+LL |         println!(\"{}\", item);\n+LL |     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "f4cfc92e1cd0259eddc426dce698b54ee4c7b61d", "filename": "tests/ui/undropped_manually_drops.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundropped_manually_drops.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,26 @@\n+#![warn(clippy::undropped_manually_drops)]\n+\n+struct S;\n+\n+fn main() {\n+    let f = std::mem::drop;\n+    let g = std::mem::ManuallyDrop::drop;\n+    let mut manual1 = std::mem::ManuallyDrop::new(S);\n+    let mut manual2 = std::mem::ManuallyDrop::new(S);\n+    let mut manual3 = std::mem::ManuallyDrop::new(S);\n+    let mut manual4 = std::mem::ManuallyDrop::new(S);\n+\n+    // These lines will not drop `S` and should be linted\n+    drop(std::mem::ManuallyDrop::new(S));\n+    drop(manual1);\n+\n+    // FIXME: this line is not linted, though it should be\n+    f(manual2);\n+\n+    // These lines will drop `S` and should be okay.\n+    unsafe {\n+        std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n+        std::mem::ManuallyDrop::drop(&mut manual3);\n+        g(&mut manual4);\n+    }\n+}"}, {"sha": "2ac0fe98697efce7dfe01155e2637e51fe4e53fb", "filename": "tests/ui/undropped_manually_drops.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fundropped_manually_drops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Fundropped_manually_drops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundropped_manually_drops.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -0,0 +1,19 @@\n+error: the inner value of this ManuallyDrop will not be dropped\n+  --> $DIR/undropped_manually_drops.rs:14:5\n+   |\n+LL |     drop(std::mem::ManuallyDrop::new(S));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::undropped-manually-drops` implied by `-D warnings`\n+   = help: to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\n+\n+error: the inner value of this ManuallyDrop will not be dropped\n+  --> $DIR/undropped_manually_drops.rs:15:5\n+   |\n+LL |     drop(manual1);\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "350da4965d11d9323433b7cf33631f1fd7e3e0a7", "filename": "tests/ui/unnecessary_cast_fixable.fixed", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Funnecessary_cast_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Funnecessary_cast_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.fixed?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -8,16 +8,31 @@ fn main() {\n     100_f32;\n     100_f64;\n     100_f64;\n+    let _ = -100_f32;\n+    let _ = -100_f64;\n+    let _ = -100_f64;\n     // Should not trigger\n     #[rustfmt::skip]\n     let v = vec!(1);\n     &v as &[i32];\n-    1.0 as f64;\n-    1 as u64;\n     0x10 as f32;\n     0o10 as f32;\n     0b10 as f32;\n     0x11 as f64;\n     0o11 as f64;\n     0b11 as f64;\n+\n+    1_u32;\n+    0x10_i32;\n+    0b10_usize;\n+    0o73_u16;\n+    1_000_000_000_u32;\n+\n+    1.0_f64;\n+    0.5_f32;\n+\n+    1.0 as u16;\n+\n+    let _ = -1_i32;\n+    let _ = -1.0_f32;\n }"}, {"sha": "ad2fb2e628921477fad7cf24c73e87a00b681898", "filename": "tests/ui/unnecessary_cast_fixable.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Funnecessary_cast_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Funnecessary_cast_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.rs?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -8,16 +8,31 @@ fn main() {\n     100 as f32;\n     100 as f64;\n     100_i32 as f64;\n+    let _ = -100 as f32;\n+    let _ = -100 as f64;\n+    let _ = -100_i32 as f64;\n     // Should not trigger\n     #[rustfmt::skip]\n     let v = vec!(1);\n     &v as &[i32];\n-    1.0 as f64;\n-    1 as u64;\n     0x10 as f32;\n     0o10 as f32;\n     0b10 as f32;\n     0x11 as f64;\n     0o11 as f64;\n     0b11 as f64;\n+\n+    1 as u32;\n+    0x10 as i32;\n+    0b10 as usize;\n+    0o73 as u16;\n+    1_000_000_000 as u32;\n+\n+    1.0 as f64;\n+    0.5 as f32;\n+\n+    1.0 as u16;\n+\n+    let _ = -1 as i32;\n+    let _ = -1.0 as f32;\n }"}, {"sha": "5a210fc89097bcdc7f5c93260b08ae89709849ed", "filename": "tests/ui/unnecessary_cast_fixable.stderr", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Funnecessary_cast_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77746b906071b17a6ce3634b91b60ec085fb268f/tests%2Fui%2Funnecessary_cast_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.stderr?ref=77746b906071b17a6ce3634b91b60ec085fb268f", "patch": "@@ -18,5 +18,77 @@ error: casting integer literal to `f64` is unnecessary\n LL |     100_i32 as f64;\n    |     ^^^^^^^^^^^^^^ help: try: `100_f64`\n \n-error: aborting due to 3 previous errors\n+error: casting integer literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:11:13\n+   |\n+LL |     let _ = -100 as f32;\n+   |             ^^^^^^^^^^^ help: try: `-100_f32`\n+\n+error: casting integer literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:12:13\n+   |\n+LL |     let _ = -100 as f64;\n+   |             ^^^^^^^^^^^ help: try: `-100_f64`\n+\n+error: casting integer literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:13:13\n+   |\n+LL |     let _ = -100_i32 as f64;\n+   |             ^^^^^^^^^^^^^^^ help: try: `-100_f64`\n+\n+error: casting integer literal to `u32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:25:5\n+   |\n+LL |     1 as u32;\n+   |     ^^^^^^^^ help: try: `1_u32`\n+\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:26:5\n+   |\n+LL |     0x10 as i32;\n+   |     ^^^^^^^^^^^ help: try: `0x10_i32`\n+\n+error: casting integer literal to `usize` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:27:5\n+   |\n+LL |     0b10 as usize;\n+   |     ^^^^^^^^^^^^^ help: try: `0b10_usize`\n+\n+error: casting integer literal to `u16` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:28:5\n+   |\n+LL |     0o73 as u16;\n+   |     ^^^^^^^^^^^ help: try: `0o73_u16`\n+\n+error: casting integer literal to `u32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:29:5\n+   |\n+LL |     1_000_000_000 as u32;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: try: `1_000_000_000_u32`\n+\n+error: casting float literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:31:5\n+   |\n+LL |     1.0 as f64;\n+   |     ^^^^^^^^^^ help: try: `1.0_f64`\n+\n+error: casting float literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:32:5\n+   |\n+LL |     0.5 as f32;\n+   |     ^^^^^^^^^^ help: try: `0.5_f32`\n+\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:36:13\n+   |\n+LL |     let _ = -1 as i32;\n+   |             ^^^^^^^^^ help: try: `-1_i32`\n+\n+error: casting float literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:37:13\n+   |\n+LL |     let _ = -1.0 as f32;\n+   |             ^^^^^^^^^^^ help: try: `-1.0_f32`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "319de217e0d90170c1bcf7545aef25e1caff11d5", "filename": "util/dev", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df855321126580ace6e3022372991c725d3e1b0a/util%2Fdev", "raw_url": "https://github.com/rust-lang/rust/raw/df855321126580ace6e3022372991c725d3e1b0a/util%2Fdev", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fdev?ref=df855321126580ace6e3022372991c725d3e1b0a", "patch": "@@ -1,7 +0,0 @@\n-#!/bin/sh\n-CARGO_TARGET_DIR=$(pwd)/target/\n-export CARGO_TARGET_DIR\n-\n-echo 'Deprecated! `util/dev` usage is deprecated, please use `cargo dev` instead.'\n-\n-cd clippy_dev && cargo run -- \"$@\""}]}