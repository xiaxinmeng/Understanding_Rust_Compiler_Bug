{"sha": "e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNmRiYjc4ODg1MDRlZjVkMGRlMGMxNDQ5M2ZjOGVjYzQ5MmVlMzA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-05T21:58:42Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-05T22:37:01Z"}, "message": "Demode some code using by-mutbl-ref; warn about by-mutbl-ref\n\nThe parser now warns about use of mutbl-ref mode, though it's kind\nof a lie since this commit doesn't remove support for the mode.\n\nChanged move_val_init to have stage0 and stage1/2 versions, the latter of\nwhich is demoded.\n\nChanged the type that the typechecker expects the move_val_init\nintrinsic to have. After this is pushed, I can make a new snapshot,\nwhich will remove the need for the stage0 versions.", "tree": {"sha": "80c1bde3c3f3b0cf47993dfe769418cc2ac55323", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80c1bde3c3f3b0cf47993dfe769418cc2ac55323"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "html_url": "https://github.com/rust-lang/rust/commit/e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3cb70fa8a6f9163352f26ae2614ab4c9a261838", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3cb70fa8a6f9163352f26ae2614ab4c9a261838", "html_url": "https://github.com/rust-lang/rust/commit/e3cb70fa8a6f9163352f26ae2614ab4c9a261838"}], "stats": {"total": 227, "additions": 204, "deletions": 23}, "files": [{"sha": "8c023a7cb4c0d9680eaf20f251e2dbba3f220cbd", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -21,7 +21,11 @@ extern mod rustrt {\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n+    #[cfg(stage0)]\n     fn move_val_init<T>(&dst: T, -src: T);\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n@@ -176,7 +180,9 @@ pub mod raw {\n             push_slow(v, move initval);\n         }\n     }\n+\n     // This doesn't bother to make sure we have space.\n+    #[cfg(stage0)]\n     #[inline(always)] // really pretty please\n     pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n@@ -186,6 +192,18 @@ pub mod raw {\n         let p = ptr::offset(p, fill) as *mut T;\n         rusti::move_val_init(*p, move initval);\n     }\n+    // This doesn't bother to make sure we have space.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[inline(always)] // really pretty please\n+    pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n+        let fill = (**repr).unboxed.fill;\n+        (**repr).unboxed.fill += sys::size_of::<T>();\n+        let p = addr_of(&((**repr).unboxed.data));\n+        let p = ptr::offset(p, fill) as *mut T;\n+        rusti::move_val_init(&mut(*p), move initval);\n+    }\n \n     pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n         reserve_at_least(v, v.len() + 1u);"}, {"sha": "ce1193aa730ec7f582a877d89dc4872d354d0a89", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -18,9 +18,14 @@ extern mod rustrt {\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n+    #[cfg(stage0)]\n     fn move_val_init<T>(&dst: T, -src: T);\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n+\n /// Returns true if a vector contains no elements\n pub pure fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n@@ -98,6 +103,7 @@ pub pure fn len<T>(v: &[const T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n+#[cfg(stage0)]\n pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n@@ -112,6 +118,22 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n         return move v;\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n+    unsafe {\n+        let mut v = with_capacity(n_elts);\n+        do as_mut_buf(v) |p, _len| {\n+            let mut i: uint = 0u;\n+            while i < n_elts {\n+                rusti::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n+                i += 1u;\n+            }\n+        }\n+        raw::set_len(&mut v, n_elts);\n+        return move v;\n+    }\n+}\n \n /**\n  * Creates and initializes an immutable vector.\n@@ -481,6 +503,7 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n     }\n }\n \n+#[cfg(stage0)]\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n@@ -491,6 +514,18 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     let p = ptr::offset(p, fill) as *mut T;\n     rusti::move_val_init(*p, move initval);\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+// This doesn't bother to make sure we have space.\n+#[inline(always)] // really pretty please\n+unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n+    let repr: **raw::VecRepr = ::cast::transmute(v);\n+    let fill = (**repr).unboxed.fill;\n+    (**repr).unboxed.fill += sys::size_of::<T>();\n+    let p = addr_of(&((**repr).unboxed.data));\n+    let p = ptr::offset(p, fill) as *mut T;\n+    rusti::move_val_init(&mut(*p), move initval);\n+}\n \n #[inline(never)]\n fn push_slow<T>(v: &mut ~[T], initval: T) {\n@@ -1758,6 +1793,18 @@ pub mod raw {\n         as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n+    #[cfg(stage0)]\n+    #[inline(always)]\n+    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n+        let mut box = Some(move val);\n+        do as_mut_buf(v) |p, _len| {\n+            let mut box2 = None;\n+            box2 <-> box;\n+            rusti::move_val_init(*ptr::mut_offset(p, i),\n+                                 option::unwrap(move box2));\n+        }\n+    }\n+    #[cfg(stage1)]\n     /**\n      * Unchecked vector index assignment.  Does not drop the\n      * old value and hence is only suitable when the vector\n@@ -1769,7 +1816,7 @@ pub mod raw {\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n             box2 <-> box;\n-            rusti::move_val_init(*ptr::mut_offset(p, i),\n+            rusti::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                  option::unwrap(move box2));\n         }\n     }"}, {"sha": "69478b3e731f79cf12132e71ea31b3236a0d0be6", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -31,9 +31,14 @@ use libc::size_t;\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n+    #[cfg(stage0)]\n     fn move_val_init<T>(&dst: T, -src: T);\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n     fn needs_drop<T>() -> bool;\n }\n+\n extern mod rustrt {\n     #[rust_stack]\n     fn rust_call_tydesc_glue(root: *u8, tydesc: *TypeDesc, field: size_t);\n@@ -127,6 +132,8 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (reinterpret_cast(&(p & !1)), p & 1 == 1)\n }\n \n+// tjc: Can get rid of the duplication post-snapshot\n+#[cfg(stage0)]\n // The duplication between the POD and non-POD functions is annoying.\n impl &Arena {\n     // Functions for the POD part of the arena\n@@ -234,6 +241,114 @@ impl &Arena {\n         } else { self.alloc_nonpod(op) }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl &Arena {\n+    // Functions for the POD part of the arena\n+    fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n+        // Allocate a new chunk.\n+        let chunk_size = at_vec::capacity(self.pod_head.data);\n+        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n+        self.chunks = @Cons(copy self.pod_head, self.chunks);\n+        self.pod_head =\n+            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n+\n+        return self.alloc_pod_inner(n_bytes, align);\n+    }\n+\n+    #[inline(always)]\n+    fn alloc_pod_inner(n_bytes: uint, align: uint) -> *u8 {\n+        let head = &mut self.pod_head;\n+\n+        let start = round_up_to(head.fill, align);\n+        let end = start + n_bytes;\n+        if end > at_vec::capacity(head.data) {\n+            return self.alloc_pod_grow(n_bytes, align);\n+        }\n+        head.fill = end;\n+\n+        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+        //       start, n_bytes, align, head.fill);\n+\n+        unsafe {\n+            ptr::offset(vec::raw::to_ptr(head.data), start)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn alloc_pod<T>(op: fn() -> T) -> &self/T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n+            let ptr: *mut T = reinterpret_cast(&ptr);\n+            rusti::move_val_init(&mut (*ptr), op());\n+            return reinterpret_cast(&ptr);\n+        }\n+    }\n+\n+    // Functions for the non-POD part of the arena\n+    fn alloc_nonpod_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+        // Allocate a new chunk.\n+        let chunk_size = at_vec::capacity(self.head.data);\n+        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n+        self.chunks = @Cons(copy self.head, self.chunks);\n+        self.head =\n+            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n+\n+        return self.alloc_nonpod_inner(n_bytes, align);\n+    }\n+\n+    #[inline(always)]\n+    fn alloc_nonpod_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+        let head = &mut self.head;\n+\n+        let tydesc_start = head.fill;\n+        let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n+        let start = round_up_to(after_tydesc, align);\n+        let end = start + n_bytes;\n+        if end > at_vec::capacity(head.data) {\n+            return self.alloc_nonpod_grow(n_bytes, align);\n+        }\n+        head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n+\n+        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+        //       start, n_bytes, align, head.fill);\n+\n+        unsafe {\n+            let buf = vec::raw::to_ptr(head.data);\n+            return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn alloc_nonpod<T>(op: fn() -> T) -> &self/T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let (ty_ptr, ptr) =\n+                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n+            let ty_ptr: *mut uint = reinterpret_cast(&ty_ptr);\n+            let ptr: *mut T = reinterpret_cast(&ptr);\n+            // Write in our tydesc along with a bit indicating that it\n+            // has *not* been initialized yet.\n+            *ty_ptr = reinterpret_cast(&tydesc);\n+            // Actually initialize it\n+            rusti::move_val_init(&mut(*ptr), op());\n+            // Now that we are done, update the tydesc to indicate that\n+            // the object is there.\n+            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n+\n+            return reinterpret_cast(&ptr);\n+        }\n+    }\n+\n+    // The external interface\n+    #[inline(always)]\n+    fn alloc<T>(op: fn() -> T) -> &self/T {\n+        if !rusti::needs_drop::<T>() {\n+            self.alloc_pod(op)\n+        } else { self.alloc_nonpod(op) }\n+    }\n+}\n \n #[test]\n fn test_arena_destructors() {"}, {"sha": "1a87d7fed6953fb6979dd469079ab7cfb1b1817a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -570,6 +570,7 @@ impl parser {\n \n     fn parse_arg_mode() -> mode {\n         if self.eat(token::BINOP(token::AND)) {\n+            self.warn(~\"Obsolete syntax has no effect\");\n             expl(by_mutbl_ref)\n         } else if self.eat(token::BINOP(token::MINUS)) {\n             expl(by_move)"}, {"sha": "7cc2c8b0ad767a9d898942cbe561b6e0cccea2df", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -2601,7 +2601,9 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"addr_of\" => (1u, ~[arg(ast::by_ref, param(ccx, 0u))],\n                       ty::mk_imm_ptr(tcx, param(ccx, 0u))),\n       ~\"move_val\" | ~\"move_val_init\" => {\n-        (1u, ~[arg(ast::by_mutbl_ref, param(ccx, 0u)),\n+          (1u, ~[arg(ast::by_copy,\n+                     ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n+                                     param(ccx, 0u))),\n                arg(ast::by_move, param(ccx, 0u))],\n          ty::mk_nil(tcx))\n       }"}, {"sha": "79f52b93612a4755538053e85ef916fe1c0dce78", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -4,8 +4,8 @@ fn borrow_from_arg_imm_ref(&&v: ~int) {\n     borrow(v);\n }\n \n-fn borrow_from_arg_mut_ref(&v: ~int) {\n-    borrow(v); //~ ERROR illegal borrow unless pure\n+fn borrow_from_arg_mut_ref(v: &mut ~int) {\n+    borrow(*v); //~ ERROR illegal borrow unless pure\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "2c20e604f502f6c327d9566b89d7bcb5d359807e", "filename": "src/test/compile-fail/deprecated-mode-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fdeprecated-mode-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fdeprecated-mode-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-mode-fn-arg.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -1,9 +1,11 @@\n #[forbid(deprecated_mode)];\n \n fn foo(_f: fn(&i: int)) { //~ ERROR explicit mode\n+    //~^ WARNING Obsolete syntax has no effect\n }\n \n type Bar = fn(&i: int); //~ ERROR explicit mode\n+    //~^ WARNING Obsolete syntax has no effect\n \n fn main() {\n }\n\\ No newline at end of file"}, {"sha": "02a3082dc10dd9fa2ba6cd2b82e6d7716500efee", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -1,11 +1,11 @@\n extern mod std;\n use cmp::Eq;\n \n-fn f<T:Eq>(&o: Option<T>) {\n-    assert o == option::None;\n+fn f<T:Eq>(o: &mut Option<T>) {\n+    assert *o == option::None;\n }\n \n fn main() {\n-    f::<int>(option::None);\n+    f::<int>(&mut option::None);\n     //~^ ERROR illegal borrow: creating mutable alias to static item\n }"}, {"sha": "834457940bec1e961c63dea6e022c611bf6467cd", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -1,5 +1,5 @@\n-fn f1(&x: int) {\n-    x = 1; // no error\n+fn f1(x: &mut int) {\n+    *x = 1; // no error\n }\n \n fn f2() {"}, {"sha": "27e9d3b60dc9d28ab801d7cc464ead39cb84fa6b", "filename": "src/test/compile-fail/liveness-move-from-args.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -4,10 +4,6 @@ fn from_by_value_arg(++x: int) {\n     take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n }\n \n-fn from_by_mut_ref_arg(&x: int) {\n-    take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n-}\n-\n fn from_by_ref_arg(&&x: int) {\n     take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n }"}, {"sha": "8b2fef7cd350353f67e2f06f97fb7cce3e4758d6", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -2,7 +2,7 @@ fn f1(x: int) {\n     //~^ WARNING unused variable: `x`\n }\n \n-fn f1b(&x: int) {\n+fn f1b(x: &mut int) {\n     //~^ WARNING unused variable: `x`\n }\n "}, {"sha": "d84c9401e2577104bf8b2310d32cba437912b4d9", "filename": "src/test/compile-fail/mutable-arguments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -1,28 +1,28 @@\n // Note: it would be nice to give fewer warnings in these cases.\n \n-fn mutate_by_mut_ref(&x: uint) {\n-    x = 0u;\n+fn mutate_by_mut_ref(x: &mut uint) {\n+    *x = 0;\n }\n \n fn mutate_by_ref(&&x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n }\n \n fn mutate_by_val(++x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n }\n \n fn mutate_by_copy(+x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n     //~^ WARNING value assigned to `x` is never read\n }\n \n fn mutate_by_move(-x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n     //~^ WARNING value assigned to `x` is never read\n }\n "}, {"sha": "683321aac3d09fd82c1946c13271cfe3ac10fc76", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb7888504ef5d0de0c14493fc8ecc492ee30/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=e16dbb7888504ef5d0de0c14493fc8ecc492ee30", "patch": "@@ -1,13 +1,13 @@\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    fn move_val_init<T>(&dst: T, -src: T);\n-    fn move_val<T>(&dst: T, -src: T);\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n+    fn move_val<T>(dst: &mut T, -src: T);\n }\n \n fn main() {\n     let mut x = @1;\n     let mut y = @2;\n-    rusti::move_val(y, x);\n+    rusti::move_val(&mut y, x);\n     assert *y == 1;\n }\n\\ No newline at end of file"}]}