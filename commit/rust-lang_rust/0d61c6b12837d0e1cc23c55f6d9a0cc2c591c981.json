{"sha": "0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNjFjNmIxMjgzN2QwZTFjYzIzYzU1ZjZkOWEwY2MyYzU5MWM5ODE=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-18T14:19:38Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-24T08:32:14Z"}, "message": "Fill in example code for HashMap.\n\nAdd an example showing how to use the map with a custom type. Fill in\nexamples for methods in the hashmap file without ones.\n\nAlso move pop_equiv next to related public methods, to not create a\nduplicate trait implementation in the docs.", "tree": {"sha": "c4fe17ee634d57c0fe159d94a251b96a26a6a4bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4fe17ee634d57c0fe159d94a251b96a26a6a4bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981", "html_url": "https://github.com/rust-lang/rust/commit/0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e2bb9d67bb47b9a3a6c7389efa45cefc33206a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e2bb9d67bb47b9a3a6c7389efa45cefc33206a6", "html_url": "https://github.com/rust-lang/rust/commit/9e2bb9d67bb47b9a3a6c7389efa45cefc33206a6"}], "stats": {"total": 312, "additions": 293, "deletions": 19}, "files": [{"sha": "05c636d47aa117c803b740808188417e2990089b", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 293, "deletions": 19, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=0d61c6b12837d0e1cc23c55f6d9a0cc2c591c981", "patch": "@@ -729,6 +729,30 @@ impl DefaultResizePolicy {\n ///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n /// }\n /// ```\n+///\n+/// The easiest way to use `HashMap` with a custom type is to derive `Eq` and `Hash`.\n+/// We must also derive `PartialEq`, this will in the future be implied by `Eq`.\n+///\n+/// ```rust\n+/// use std::collections::HashMap;\n+///\n+/// #[deriving(Hash, Eq, PartialEq, Show)]\n+/// struct Viking<'a> {\n+///     name: &'a str,\n+///     power: uint,\n+/// }\n+///\n+/// let mut vikings = HashMap::new();\n+///\n+/// vikings.insert(\"Norway\", Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(\"Denmark\", Viking { name: \"Olaf\", power: 4u });\n+/// vikings.insert(\"Iceland\", Viking { name: \"Harald\", power: 8u });\n+///\n+/// // Use derived implementation to print the vikings.\n+/// for (land, viking) in vikings.iter() {\n+///     println!(\"{} at {}\", viking, land);\n+/// }\n+/// ```\n #[deriving(Clone)]\n pub struct HashMap<K, V, H = RandomSipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n@@ -906,28 +930,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         // earlier.\n         return Some(retval);\n     }\n-\n-    /// Like `pop`, but can operate on any type that is equivalent to a key.\n-    #[experimental]\n-    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n-        if self.table.size() == 0 {\n-            return None\n-        }\n-\n-        let potential_new_size = self.table.size() - 1;\n-        self.make_some_room(potential_new_size);\n-\n-        let starting_index = match self.search_equiv(k) {\n-            Some(idx) => idx,\n-            None      => return None,\n-        };\n-\n-        self.pop_internal(starting_index)\n-    }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Collection for HashMap<K, V, H> {\n-    /// Return the number of elements in the map\n+    /// Return the number of elements in the map.\n     fn len(&self) -> uint { self.table.size() }\n }\n \n@@ -1032,12 +1038,26 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// Create an empty HashMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10u);\n+    /// ```\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n@@ -1049,6 +1069,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n     /// The creates map has the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut map = HashMap::with_hasher(h);\n+    /// map.insert(1i, 2u);\n+    /// ```\n     #[inline]\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n@@ -1061,6 +1092,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut map = HashMap::with_capacity_and_hasher(10u, h);\n+    /// map.insert(1i, 2u);\n+    /// ```\n     #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n         let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n@@ -1077,6 +1119,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// This function has no effect on the operational semantics of the\n     /// hashtable, only on performance.\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// map.reserve(10u);\n+    /// ```\n     pub fn reserve(&mut self, new_minimum_capacity: uint) {\n         let cap = num::next_power_of_two(\n             max(INITIAL_CAPACITY, new_minimum_capacity));\n@@ -1241,12 +1289,38 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// // Insert 1i with key \"a\"\n+    /// assert_eq!(*map.find_or_insert(\"a\", 1i), 1i);\n+    ///\n+    /// // Find the existing key\n+    /// assert_eq!(*map.find_or_insert(\"a\", -2i), 1i);\n+    /// ```\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n         self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// // Insert 10u with key 2i\n+    /// assert_eq!(*map.find_or_insert_with(2i, |&key| { 5 * key as uint }), 10u);\n+    ///\n+    /// // Find the existing key\n+    /// assert_eq!(*map.find_or_insert_with(2i, |&key| { key as uint }), 10u);\n+    /// ```\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n         self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n@@ -1255,6 +1329,20 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Insert a key-value pair into the map if the key is not already present.\n     /// Otherwise, modify the existing value for the key.\n     /// Returns the new or modified value for the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// // Insert 2u with key \"a\"\n+    /// assert_eq!(*map.insert_or_update_with(\"a\", 2u, |key, val| { *val = 3u; }), 2u);\n+    ///\n+    /// // Update and return the existing value\n+    /// assert_eq!(*map.insert_or_update_with(\"a\", 9u, |key, val| { *val = 7u; }), 7u);\n+    /// assert_eq!(map.get(&\"a\"), &7u);\n+    /// ```\n     pub fn insert_or_update_with<'a>(\n                                  &'a mut self,\n                                  k: K,\n@@ -1327,6 +1415,16 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n \n     /// Retrieves a value for the given key, failing if the key is not present.\n+    /// See `find` for a non-failing alternative.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// assert_eq!(map.get(&\"a\"), &1i);\n+    /// ```\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n@@ -1335,6 +1433,25 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n \n     /// Retrieves a (mutable) value for the given key, failing if the key is not present.\n+    /// See `find_mut` for a non-failing alternative.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// {\n+    ///     // val will freeze map to prevent usage during it's lifetime\n+    ///     let val = map.get_mut(&\"a\");\n+    ///     *val = 40i;\n+    /// }\n+    /// assert_eq!(map.get(&\"a\"), &40i);\n+    ///\n+    /// // A more direct way could be:\n+    /// *map.get_mut(&\"a\") = -2i;\n+    /// assert_eq!(map.get(&\"a\"), &-2i);\n+    /// ```\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n@@ -1344,12 +1461,16 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence.\n+    ///\n+    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n     pub fn contains_key_equiv<Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         self.search_equiv(key).is_some()\n     }\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence.\n+    ///\n+    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n     pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n@@ -1360,46 +1481,199 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n+    /// Like `pop`, but can operate on any type that is equivalent to a key.\n+    ///\n+    /// # Example\n+    ///\n+    /// This is a slightly silly example where we define the number's parity as\n+    /// the equivilance class. It is important that the values hash the same,\n+    /// which is why we override `Hash`.\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// use std::hash::Hash;\n+    /// use std::hash::sip::SipState;\n+    ///\n+    /// #[deriving(Eq, PartialEq)]\n+    /// struct EvenOrOdd {\n+    ///     num: uint\n+    /// };\n+    ///\n+    /// impl Hash for EvenOrOdd {\n+    ///     fn hash(&self, state: &mut SipState) {\n+    ///         let parity = self.num % 2;\n+    ///         parity.hash(state);\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n+    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n+    ///         self.num % 2 == other.num % 2\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(EvenOrOdd { num: 3u }, \"foo\");\n+    ///\n+    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1u }));\n+    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4u }));\n+    ///\n+    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5u }), Some(&\"foo\"));\n+    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2u }), None);\n+    ///\n+    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1u }), Some(\"foo\"));\n+    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2u }), None);\n+    ///\n+    /// ```\n+    #[experimental]\n+    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        let potential_new_size = self.table.size() - 1;\n+        self.make_some_room(potential_new_size);\n+\n+        let starting_index = match self.search_equiv(k) {\n+            Some(idx) => idx,\n+            None      => return None,\n+        };\n+\n+        self.pop_internal(starting_index)\n+    }\n+\n     /// An iterator visiting all keys in arbitrary order.\n     /// Iterator element type is &'a K.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2i);\n+    /// map.insert(\"c\", 3i);\n+    ///\n+    /// for key in map.keys() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n     /// Iterator element type is &'a V.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2i);\n+    /// map.insert(\"c\", 3i);\n+    ///\n+    /// for key in map.values() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// Iterator element type is (&'a K, &'a V).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2i);\n+    /// map.insert(\"c\", 3i);\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         self.table.iter()\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is (&'a K, &'a mut V).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2i);\n+    /// map.insert(\"c\", 3i);\n+    ///\n+    /// // Update all values\n+    /// for (_, val) in map.mut_iter() {\n+    ///     *val *= 2;\n+    /// }\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         self.table.mut_iter()\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2i);\n+    /// map.insert(\"c\", 3i);\n+    ///\n+    /// // Not possible with .iter()\n+    /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n+    /// ```\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n         self.table.move_iter().map(|(_, k, v)| (k, v))\n     }\n }\n \n impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Like `find`, but returns a copy of the value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map: HashMap<uint, String> = HashMap::new();\n+    /// map.insert(1u, \"foo\".to_string());\n+    /// let s: String = map.find_copy(&1u).unwrap();\n+    /// ```\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n     }\n \n     /// Like `get`, but returns a copy of the value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// let mut map: HashMap<uint, String> = HashMap::new();\n+    /// map.insert(1u, \"foo\".to_string());\n+    /// let s: String = map.get_copy(&1u);\n+    /// ```\n     pub fn get_copy(&self, k: &K) -> V {\n         (*self.get(k)).clone()\n     }"}]}