{"sha": "11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZTQxYjA1MmYxZjJlMDM2ZmM3MDQ3N2ZkNGM2MWQwYTBhMzA5OWI=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T05:10:07Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T22:32:13Z"}, "message": "Moved types starting with 'Generic' into generics.rs.", "tree": {"sha": "e256976802948fbf8e55a3a0f2288fa2a0f66488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e256976802948fbf8e55a3a0f2288fa2a0f66488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "html_url": "https://github.com/rust-lang/rust/commit/11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11e41b052f1f2e036fc70477fd4c61d0a0a3099b/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5375575717bf4a5e848402a936aaf5cc37fe9dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5375575717bf4a5e848402a936aaf5cc37fe9dbf", "html_url": "https://github.com/rust-lang/rust/commit/5375575717bf4a5e848402a936aaf5cc37fe9dbf"}], "stats": {"total": 507, "additions": 259, "deletions": 248}, "files": [{"sha": "79cd26f5668a13936cde730374aa78a7dbede1ae", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/11e41b052f1f2e036fc70477fd4c61d0a0a3099b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e41b052f1f2e036fc70477fd4c61d0a0a3099b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "patch": "@@ -0,0 +1,257 @@\n+use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use crate::ty;\n+use crate::ty::subst::{Subst, SubstsRef};\n+use rustc_ast as ast;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+\n+use super::{EarlyBoundRegion, InstantiatedPredicates, ParamConst, ParamTy, Predicate, TyCtxt};\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub enum GenericParamDefKind {\n+    Lifetime,\n+    Type {\n+        has_default: bool,\n+        object_lifetime_default: ObjectLifetimeDefault,\n+        synthetic: Option<hir::SyntheticTyParamKind>,\n+    },\n+    Const,\n+}\n+\n+impl GenericParamDefKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            GenericParamDefKind::Lifetime => \"lifetime\",\n+            GenericParamDefKind::Type { .. } => \"type\",\n+            GenericParamDefKind::Const => \"constant\",\n+        }\n+    }\n+    pub fn to_ord(&self, tcx: TyCtxt<'_>) -> ast::ParamKindOrd {\n+        match self {\n+            GenericParamDefKind::Lifetime => ast::ParamKindOrd::Lifetime,\n+            GenericParamDefKind::Type { .. } => ast::ParamKindOrd::Type,\n+            GenericParamDefKind::Const => {\n+                ast::ParamKindOrd::Const { unordered: tcx.features().const_generics }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct GenericParamDef {\n+    pub name: Symbol,\n+    pub def_id: DefId,\n+    pub index: u32,\n+\n+    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n+    /// on generic parameter `'a`/`T`, asserts data behind the parameter\n+    /// `'a`/`T` won't be accessed during the parent type's `Drop` impl.\n+    pub pure_wrt_drop: bool,\n+\n+    pub kind: GenericParamDefKind,\n+}\n+\n+impl GenericParamDef {\n+    pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n+        if let GenericParamDefKind::Lifetime = self.kind {\n+            ty::EarlyBoundRegion { def_id: self.def_id, index: self.index, name: self.name }\n+        } else {\n+            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct GenericParamCount {\n+    pub lifetimes: usize,\n+    pub types: usize,\n+    pub consts: usize,\n+}\n+\n+/// Information about the formal type/lifetime parameters associated\n+/// with an item or method. Analogous to `hir::Generics`.\n+///\n+/// The ordering of parameters is the same as in `Subst` (excluding child generics):\n+/// `Self` (optionally), `Lifetime` params..., `Type` params...\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct Generics {\n+    pub parent: Option<DefId>,\n+    pub parent_count: usize,\n+    pub params: Vec<GenericParamDef>,\n+\n+    /// Reverse map to the `index` field of each `GenericParamDef`.\n+    #[stable_hasher(ignore)]\n+    pub param_def_id_to_index: FxHashMap<DefId, u32>,\n+\n+    pub has_self: bool,\n+    pub has_late_bound_regions: Option<Span>,\n+}\n+\n+impl<'tcx> Generics {\n+    pub fn count(&self) -> usize {\n+        self.parent_count + self.params.len()\n+    }\n+\n+    pub fn own_counts(&self) -> GenericParamCount {\n+        // We could cache this as a property of `GenericParamCount`, but\n+        // the aim is to refactor this away entirely eventually and the\n+        // presence of this method will be a constant reminder.\n+        let mut own_counts = GenericParamCount::default();\n+\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n+                GenericParamDefKind::Type { .. } => own_counts.types += 1,\n+                GenericParamDefKind::Const => own_counts.consts += 1,\n+            }\n+        }\n+\n+        own_counts\n+    }\n+\n+    pub fn own_defaults(&self) -> GenericParamCount {\n+        let mut own_defaults = GenericParamCount::default();\n+\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => (),\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    own_defaults.types += has_default as usize;\n+                }\n+                GenericParamDefKind::Const => {\n+                    // FIXME(const_generics:defaults)\n+                }\n+            }\n+        }\n+\n+        own_defaults\n+    }\n+\n+    pub fn requires_monomorphization(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        if self.own_requires_monomorphization() {\n+            return true;\n+        }\n+\n+        if let Some(parent_def_id) = self.parent {\n+            let parent = tcx.generics_of(parent_def_id);\n+            parent.requires_monomorphization(tcx)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn own_requires_monomorphization(&self) -> bool {\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => return true,\n+                GenericParamDefKind::Lifetime => {}\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Returns the `GenericParamDef` with the given index.\n+    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        if let Some(index) = param_index.checked_sub(self.parent_count) {\n+            &self.params[index]\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n+                .param_at(param_index, tcx)\n+        }\n+    }\n+\n+    /// Returns the `GenericParamDef` associated with this `EarlyBoundRegion`.\n+    pub fn region_param(\n+        &'tcx self,\n+        param: &EarlyBoundRegion,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> &'tcx GenericParamDef {\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => param,\n+            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n+        }\n+    }\n+\n+    /// Returns the `GenericParamDef` associated with this `ParamTy`.\n+    pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Type { .. } => param,\n+            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n+        }\n+    }\n+\n+    /// Returns the `GenericParamDef` associated with this `ParamConst`.\n+    pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Const => param,\n+            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n+        }\n+    }\n+}\n+\n+/// Bounds on generics.\n+#[derive(Copy, Clone, Default, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct GenericPredicates<'tcx> {\n+    pub parent: Option<DefId>,\n+    pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n+}\n+\n+impl<'tcx> GenericPredicates<'tcx> {\n+    pub fn instantiate(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_into(tcx, &mut instantiated, substs);\n+        instantiated\n+    }\n+\n+    pub fn instantiate_own(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n+        InstantiatedPredicates {\n+            predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n+            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n+        }\n+    }\n+\n+    fn instantiate_into(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) {\n+        if let Some(def_id) = self.parent {\n+            tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n+        }\n+        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)));\n+        instantiated.spans.extend(self.predicates.iter().map(|(_, sp)| *sp));\n+    }\n+\n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'tcx>) -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_identity_into(tcx, &mut instantiated);\n+        instantiated\n+    }\n+\n+    fn instantiate_identity_into(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+    ) {\n+        if let Some(def_id) = self.parent {\n+            tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n+        }\n+        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n+        instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n+    }\n+}"}, {"sha": "88c6a2166df100512760ee8e8531f0fefff20e22", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 248, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/11e41b052f1f2e036fc70477fd4c61d0a0a3099b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e41b052f1f2e036fc70477fd4c61d0a0a3099b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "patch": "@@ -9,12 +9,12 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n-// ignore-tidy-filelength\n pub use self::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n+pub use generics::*;\n pub use upvar::*;\n \n use crate::hir::exports::ExportMap;\n@@ -23,7 +23,6 @@ use crate::hir::place::{\n };\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n-use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n@@ -112,6 +111,7 @@ mod consts;\n mod context;\n mod diagnostics;\n mod erase_regions;\n+mod generics;\n mod instance;\n mod list;\n mod structural_impls;\n@@ -698,252 +698,6 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub enum GenericParamDefKind {\n-    Lifetime,\n-    Type {\n-        has_default: bool,\n-        object_lifetime_default: ObjectLifetimeDefault,\n-        synthetic: Option<hir::SyntheticTyParamKind>,\n-    },\n-    Const,\n-}\n-\n-impl GenericParamDefKind {\n-    pub fn descr(&self) -> &'static str {\n-        match self {\n-            GenericParamDefKind::Lifetime => \"lifetime\",\n-            GenericParamDefKind::Type { .. } => \"type\",\n-            GenericParamDefKind::Const => \"constant\",\n-        }\n-    }\n-    pub fn to_ord(&self, tcx: TyCtxt<'_>) -> ast::ParamKindOrd {\n-        match self {\n-            GenericParamDefKind::Lifetime => ast::ParamKindOrd::Lifetime,\n-            GenericParamDefKind::Type { .. } => ast::ParamKindOrd::Type,\n-            GenericParamDefKind::Const => {\n-                ast::ParamKindOrd::Const { unordered: tcx.features().const_generics }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct GenericParamDef {\n-    pub name: Symbol,\n-    pub def_id: DefId,\n-    pub index: u32,\n-\n-    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n-    /// on generic parameter `'a`/`T`, asserts data behind the parameter\n-    /// `'a`/`T` won't be accessed during the parent type's `Drop` impl.\n-    pub pure_wrt_drop: bool,\n-\n-    pub kind: GenericParamDefKind,\n-}\n-\n-impl GenericParamDef {\n-    pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n-        if let GenericParamDefKind::Lifetime = self.kind {\n-            ty::EarlyBoundRegion { def_id: self.def_id, index: self.index, name: self.name }\n-        } else {\n-            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct GenericParamCount {\n-    pub lifetimes: usize,\n-    pub types: usize,\n-    pub consts: usize,\n-}\n-\n-/// Information about the formal type/lifetime parameters associated\n-/// with an item or method. Analogous to `hir::Generics`.\n-///\n-/// The ordering of parameters is the same as in `Subst` (excluding child generics):\n-/// `Self` (optionally), `Lifetime` params..., `Type` params...\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct Generics {\n-    pub parent: Option<DefId>,\n-    pub parent_count: usize,\n-    pub params: Vec<GenericParamDef>,\n-\n-    /// Reverse map to the `index` field of each `GenericParamDef`.\n-    #[stable_hasher(ignore)]\n-    pub param_def_id_to_index: FxHashMap<DefId, u32>,\n-\n-    pub has_self: bool,\n-    pub has_late_bound_regions: Option<Span>,\n-}\n-\n-impl<'tcx> Generics {\n-    pub fn count(&self) -> usize {\n-        self.parent_count + self.params.len()\n-    }\n-\n-    pub fn own_counts(&self) -> GenericParamCount {\n-        // We could cache this as a property of `GenericParamCount`, but\n-        // the aim is to refactor this away entirely eventually and the\n-        // presence of this method will be a constant reminder.\n-        let mut own_counts = GenericParamCount::default();\n-\n-        for param in &self.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n-                GenericParamDefKind::Type { .. } => own_counts.types += 1,\n-                GenericParamDefKind::Const => own_counts.consts += 1,\n-            }\n-        }\n-\n-        own_counts\n-    }\n-\n-    pub fn own_defaults(&self) -> GenericParamCount {\n-        let mut own_defaults = GenericParamCount::default();\n-\n-        for param in &self.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => (),\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    own_defaults.types += has_default as usize;\n-                }\n-                GenericParamDefKind::Const => {\n-                    // FIXME(const_generics:defaults)\n-                }\n-            }\n-        }\n-\n-        own_defaults\n-    }\n-\n-    pub fn requires_monomorphization(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        if self.own_requires_monomorphization() {\n-            return true;\n-        }\n-\n-        if let Some(parent_def_id) = self.parent {\n-            let parent = tcx.generics_of(parent_def_id);\n-            parent.requires_monomorphization(tcx)\n-        } else {\n-            false\n-        }\n-    }\n-\n-    pub fn own_requires_monomorphization(&self) -> bool {\n-        for param in &self.params {\n-            match param.kind {\n-                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => return true,\n-                GenericParamDefKind::Lifetime => {}\n-            }\n-        }\n-        false\n-    }\n-\n-    /// Returns the `GenericParamDef` with the given index.\n-    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        if let Some(index) = param_index.checked_sub(self.parent_count) {\n-            &self.params[index]\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .param_at(param_index, tcx)\n-        }\n-    }\n-\n-    /// Returns the `GenericParamDef` associated with this `EarlyBoundRegion`.\n-    pub fn region_param(\n-        &'tcx self,\n-        param: &EarlyBoundRegion,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx GenericParamDef {\n-        let param = self.param_at(param.index as usize, tcx);\n-        match param.kind {\n-            GenericParamDefKind::Lifetime => param,\n-            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n-        }\n-    }\n-\n-    /// Returns the `GenericParamDef` associated with this `ParamTy`.\n-    pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        let param = self.param_at(param.index as usize, tcx);\n-        match param.kind {\n-            GenericParamDefKind::Type { .. } => param,\n-            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n-        }\n-    }\n-\n-    /// Returns the `GenericParamDef` associated with this `ParamConst`.\n-    pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n-        let param = self.param_at(param.index as usize, tcx);\n-        match param.kind {\n-            GenericParamDefKind::Const => param,\n-            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n-        }\n-    }\n-}\n-\n-/// Bounds on generics.\n-#[derive(Copy, Clone, Default, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct GenericPredicates<'tcx> {\n-    pub parent: Option<DefId>,\n-    pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n-}\n-\n-impl<'tcx> GenericPredicates<'tcx> {\n-    pub fn instantiate(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        let mut instantiated = InstantiatedPredicates::empty();\n-        self.instantiate_into(tcx, &mut instantiated, substs);\n-        instantiated\n-    }\n-\n-    pub fn instantiate_own(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        InstantiatedPredicates {\n-            predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n-            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n-        }\n-    }\n-\n-    fn instantiate_into(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        instantiated: &mut InstantiatedPredicates<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) {\n-        if let Some(def_id) = self.parent {\n-            tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n-        }\n-        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)));\n-        instantiated.spans.extend(self.predicates.iter().map(|(_, sp)| *sp));\n-    }\n-\n-    pub fn instantiate_identity(&self, tcx: TyCtxt<'tcx>) -> InstantiatedPredicates<'tcx> {\n-        let mut instantiated = InstantiatedPredicates::empty();\n-        self.instantiate_identity_into(tcx, &mut instantiated);\n-        instantiated\n-    }\n-\n-    fn instantiate_identity_into(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        instantiated: &mut InstantiatedPredicates<'tcx>,\n-    ) {\n-        if let Some(def_id) = self.parent {\n-            tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n-        }\n-        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n-        instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n-    }\n-}\n-\n #[derive(Debug)]\n crate struct PredicateInner<'tcx> {\n     kind: Binder<PredicateKind<'tcx>>,"}]}