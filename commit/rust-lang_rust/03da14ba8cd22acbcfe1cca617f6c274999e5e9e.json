{"sha": "03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZGExNGJhOGNkMjJhY2JjZmUxY2NhNjE3ZjZjMjc0OTk5ZTVlOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T15:34:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T15:34:21Z"}, "message": "Auto merge of #52949 - Mark-Simulacrum:snap, r=alexcrichton\n\nSwitch to bootstrapping from 1.29 beta\n\nr? @alexcrichton", "tree": {"sha": "a33c2439348b38fceebbf1fc4604e06066c5e8a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a33c2439348b38fceebbf1fc4604e06066c5e8a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "html_url": "https://github.com/rust-lang/rust/commit/03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e92bf280b59fe0c187359743d7d430575fa30b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e92bf280b59fe0c187359743d7d430575fa30b1", "html_url": "https://github.com/rust-lang/rust/commit/5e92bf280b59fe0c187359743d7d430575fa30b1"}, {"sha": "683a3db01fcd00998a36e494ee39209b3105cfb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/683a3db01fcd00998a36e494ee39209b3105cfb9", "html_url": "https://github.com/rust-lang/rust/commit/683a3db01fcd00998a36e494ee39209b3105cfb9"}], "stats": {"total": 311, "additions": 34, "deletions": 277}, "files": [{"sha": "fa2b58fb2daa711714407124900514f49798d31b", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.29.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.30.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "ca1b7507b5e9b0dcc8062c632dd785883b7ae4c3", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -162,10 +162,7 @@ mod boxed {\n #[cfg(test)]\n mod boxed_test;\n pub mod collections;\n-#[cfg(any(\n-    all(stage0, target_has_atomic = \"ptr\"),\n-    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n-))]\n+#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "7a4eda21a601a61442dd1d4fbf6d68295cb29526", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -12,16 +12,10 @@\n \n pub use core::task::*;\n \n-#[cfg(any(\n-    all(stage0, target_has_atomic = \"ptr\"),\n-    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n-))]\n+#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n pub use self::if_arc::*;\n \n-#[cfg(any(\n-    all(stage0, target_has_atomic = \"ptr\"),\n-    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n-))]\n+#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n mod if_arc {\n     use super::*;\n     use core::marker::PhantomData;\n@@ -53,10 +47,7 @@ mod if_arc {\n         }\n     }\n \n-    #[cfg(any(\n-        all(stage0, target_has_atomic = \"ptr\"),\n-        all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n-    ))]\n+    #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n     struct ArcWrapped<T>(PhantomData<T>);\n \n     unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {"}, {"sha": "39ec5d6411c16c26b3161414426cc6722f18e809", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -19,10 +19,6 @@ use usize;\n use ptr::{self, NonNull};\n use num::NonZeroUsize;\n \n-#[unstable(feature = \"alloc_internals\", issue = \"0\")]\n-#[cfg(stage0)]\n-pub type Opaque = u8;\n-\n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n@@ -48,7 +44,7 @@ fn size_align<T>() -> (usize, usize) {\n /// use specific allocators with looser requirements.)\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-#[cfg_attr(not(stage0), lang = \"alloc_layout\")]\n+#[lang = \"alloc_layout\"]\n pub struct Layout {\n     // size of the requested block of memory, measured in bytes.\n     size_: usize,"}, {"sha": "9ddf902349dd2e633ae87aa2c03ebebb0e28e96f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -1087,11 +1087,9 @@ extern \"rust-intrinsic\" {\n \n     /// Perform a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n-    #[cfg(not(stage0))]\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Perform a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n-    #[cfg(not(stage0))]\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`"}, {"sha": "8643219cb61153307944351cb5ff60edb097564c", "filename": "src/libcore/manually_drop_stage0.rs", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/5e92bf280b59fe0c187359743d7d430575fa30b1/src%2Flibcore%2Fmanually_drop_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e92bf280b59fe0c187359743d7d430575fa30b1/src%2Flibcore%2Fmanually_drop_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanually_drop_stage0.rs?ref=5e92bf280b59fe0c187359743d7d430575fa30b1", "patch": "@@ -1,195 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n-///\n-/// This wrapper is 0-cost.\n-///\n-/// # Examples\n-///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n-///\n-/// ```rust\n-/// use std::mem::ManuallyDrop;\n-/// struct Peach;\n-/// struct Banana;\n-/// struct Melon;\n-/// struct FruitBox {\n-///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n-///     peach: ManuallyDrop<Peach>,\n-///     melon: Melon, // Field that\u2019s independent of the other two.\n-///     banana: ManuallyDrop<Banana>,\n-/// }\n-///\n-/// impl Drop for FruitBox {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // Explicit ordering in which field destructors are run specified in the intuitive\n-///             // location \u2013 the destructor of the structure containing the fields.\n-///             // Moreover, one can now reorder fields within the struct however much they want.\n-///             ManuallyDrop::drop(&mut self.peach);\n-///             ManuallyDrop::drop(&mut self.banana);\n-///         }\n-///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n-///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[allow(unions_with_drop_fields)]\n-#[derive(Copy)]\n-pub union ManuallyDrop<T>{ value: T }\n-\n-impl<T> ManuallyDrop<T> {\n-    /// Wrap a value to be manually dropped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// ManuallyDrop::new(Box::new(()));\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_manually_drop_new\")]\n-    #[inline]\n-    pub const fn new(value: T) -> ManuallyDrop<T> {\n-        ManuallyDrop { value: value }\n-    }\n-\n-    /// Extract the value from the ManuallyDrop container.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// let x = ManuallyDrop::new(Box::new(()));\n-    /// let _: Box<()> = ManuallyDrop::into_inner(x);\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n-        unsafe {\n-            slot.value\n-        }\n-    }\n-\n-    /// Manually drops the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T> Deref for ManuallyDrop<T> {\n-    type Target = T;\n-    #[inline]\n-    fn deref(&self) -> &Self::Target {\n-        unsafe {\n-            &self.value\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T> DerefMut for ManuallyDrop<T> {\n-    #[inline]\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        unsafe {\n-            &mut self.value\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n-    fn fmt(&self, fmt: &mut ::fmt::Formatter) -> ::fmt::Result {\n-        unsafe {\n-            fmt.debug_tuple(\"ManuallyDrop\").field(&self.value).finish()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Clone> Clone for ManuallyDrop<T> {\n-    fn clone(&self) -> Self {\n-        ManuallyDrop::new(self.deref().clone())\n-    }\n-\n-    fn clone_from(&mut self, source: &Self) {\n-        self.deref_mut().clone_from(source);\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Default> Default for ManuallyDrop<T> {\n-    fn default() -> Self {\n-        ManuallyDrop::new(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: PartialEq> PartialEq for ManuallyDrop<T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other)\n-    }\n-\n-    fn ne(&self, other: &Self) -> bool {\n-        self.deref().ne(other)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Eq> Eq for ManuallyDrop<T> {}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: PartialOrd> PartialOrd for ManuallyDrop<T> {\n-    fn partial_cmp(&self, other: &Self) -> Option<::cmp::Ordering> {\n-        self.deref().partial_cmp(other)\n-    }\n-\n-    fn lt(&self, other: &Self) -> bool {\n-        self.deref().lt(other)\n-    }\n-\n-    fn le(&self, other: &Self) -> bool {\n-        self.deref().le(other)\n-    }\n-\n-    fn gt(&self, other: &Self) -> bool {\n-        self.deref().gt(other)\n-    }\n-\n-    fn ge(&self, other: &Self) -> bool {\n-        self.deref().ge(other)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Ord> Ord for ManuallyDrop<T> {\n-    fn cmp(&self, other: &Self) -> ::cmp::Ordering {\n-        self.deref().cmp(other)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n-    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}"}, {"sha": "8a74e7c6f1cc66d628432457eee60f26acb62fa8", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -953,18 +953,13 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n ///     }\n /// }\n /// ```\n-#[cfg(not(stage0))]\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ManuallyDrop<T> {\n     value: T,\n }\n \n-#[cfg(stage0)]\n-include!(\"manually_drop_stage0.rs\");\n-\n-#[cfg(not(stage0))]\n impl<T> ManuallyDrop<T> {\n     /// Wrap a value to be manually dropped.\n     ///\n@@ -1010,7 +1005,6 @@ impl<T> ManuallyDrop<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n impl<T> Deref for ManuallyDrop<T> {\n     type Target = T;\n@@ -1020,7 +1014,6 @@ impl<T> Deref for ManuallyDrop<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n impl<T> DerefMut for ManuallyDrop<T> {\n     #[inline]"}, {"sha": "e98194c17c8851204520a0123b29722f25fba42d", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -373,7 +373,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -404,7 +404,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -450,7 +450,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -542,7 +542,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -574,7 +574,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -617,7 +617,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -648,7 +648,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -795,7 +795,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -825,7 +825,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -864,7 +864,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1151,7 +1151,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1184,7 +1184,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1238,7 +1238,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1693,7 +1693,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"cas\")]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -1730,7 +1730,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -1769,7 +1769,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,"}, {"sha": "4b69e3b6bc70db8d0db5ba99597f68e0b9f649d6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -3753,16 +3753,14 @@ impl<'a> LoweringContext<'a> {\n             }\n             // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n-                // FIXME: Use e.span directly after RangeInclusive::new() is stabilized in stage0.\n-                let span = self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n                 let id = self.next_id();\n                 let e1 = self.lower_expr(e1);\n                 let e2 = self.lower_expr(e2);\n-                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n-                let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n+                let ty_path = P(self.std_path(e.span, &[\"ops\", \"RangeInclusive\"], None, false));\n+                let ty = P(self.ty_path(id, e.span, hir::QPath::Resolved(None, ty_path)));\n                 let new_seg = P(hir::PathSegment::from_ident(Ident::from_str(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n-                let new = P(self.expr(span, hir::ExprKind::Path(new_path), ThinVec::new()));\n+                let new = P(self.expr(e.span, hir::ExprKind::Path(new_path), ThinVec::new()));\n                 hir::ExprKind::Call(new, hir_vec![e1, e2])\n             }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n@@ -3785,20 +3783,16 @@ impl<'a> LoweringContext<'a> {\n                     .chain(e2.iter().map(|e| (\"end\", e)))\n                     .map(|(s, e)| {\n                         let expr = P(self.lower_expr(&e));\n-                        let unstable_span =\n-                            self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n-                        let ident = Ident::new(Symbol::intern(s), unstable_span);\n-                        self.field(ident, expr, unstable_span)\n+                        let ident = Ident::new(Symbol::intern(s), e.span);\n+                        self.field(ident, expr, e.span)\n                     })\n                     .collect::<P<[hir::Field]>>();\n \n                 let is_unit = fields.is_empty();\n-                let unstable_span =\n-                    self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n                 let struct_path = iter::once(\"ops\")\n                     .chain(iter::once(path))\n                     .collect::<Vec<_>>();\n-                let struct_path = self.std_path(unstable_span, &struct_path, None, is_unit);\n+                let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n                 let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n@@ -3811,7 +3805,7 @@ impl<'a> LoweringContext<'a> {\n                     } else {\n                         hir::ExprKind::Struct(struct_path, fields, None)\n                     },\n-                    span: unstable_span,\n+                    span: e.span,\n                     attrs: e.attrs.clone(),\n                 };\n             }"}, {"sha": "2ab0124397bbb1b1a8749e153e5ef6057a77f9a2", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -409,7 +409,6 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n     Async,\n-    DotFill,\n     QuestionMark,\n     ExistentialReturnType,\n     ForLoop,"}, {"sha": "b9aba1e9cab321d979430c921d3960cfacf38ac3", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -125,8 +125,7 @@ fn default_alloc_error_hook(layout: Layout) {\n \n #[cfg(not(test))]\n #[doc(hidden)]\n-#[cfg_attr(stage0, lang = \"oom\")]\n-#[cfg_attr(not(stage0), alloc_error_handler)]\n+#[alloc_error_handler]\n #[unstable(feature = \"alloc_internals\", issue = \"0\")]\n pub fn rust_oom(layout: Layout) -> ! {\n     let hook = HOOK.load(Ordering::SeqCst);"}, {"sha": "a96e2ba21345b4f66b4b29c69cdb03eb0057aab0", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -157,12 +157,7 @@ macro_rules! print {\n macro_rules! println {\n     () => (print!(\"\\n\"));\n     ($($arg:tt)*) => ({\n-        #[cfg(not(stage0))] {\n-            ($crate::io::_print(format_args_nl!($($arg)*)));\n-        }\n-        #[cfg(stage0)] {\n-            print!(\"{}\\n\", format_args!($($arg)*))\n-        }\n+        $crate::io::_print(format_args_nl!($($arg)*));\n     })\n }\n \n@@ -221,12 +216,7 @@ macro_rules! eprint {\n macro_rules! eprintln {\n     () => (eprint!(\"\\n\"));\n     ($($arg:tt)*) => ({\n-        #[cfg(all(not(stage0), not(stage1)))] {\n-            ($crate::io::_eprint(format_args_nl!($($arg)*)));\n-        }\n-        #[cfg(any(stage0, stage1))] {\n-            eprint!(\"{}\\n\", format_args!($($arg)*))\n-        }\n+        $crate::io::_eprint(format_args_nl!($($arg)*));\n     })\n }\n "}, {"sha": "670fd5b872d92f96b5736378399c87333e14de0a", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -594,7 +594,6 @@ impl ExpnFormat {\n /// The kind of compiler desugaring.\n #[derive(Clone, Copy, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CompilerDesugaringKind {\n-    DotFill,\n     QuestionMark,\n     Catch,\n     /// Desugaring of an `impl Trait` in return type position\n@@ -609,7 +608,6 @@ impl CompilerDesugaringKind {\n     pub fn name(self) -> Symbol {\n         Symbol::intern(match self {\n             CompilerDesugaringKind::Async => \"async\",\n-            CompilerDesugaringKind::DotFill => \"...\",\n             CompilerDesugaringKind::QuestionMark => \"?\",\n             CompilerDesugaringKind::Catch => \"do catch\",\n             CompilerDesugaringKind::ExistentialReturnType => \"existential type\","}, {"sha": "a93b25607eb3ad2ab9da4555750dd4bbd533a7f4", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2018-07-27\n+date: 2018-08-01\n rustc: beta\n cargo: beta\n "}, {"sha": "4b716ff27446af9b000f699ff4928eb3a80f5240", "filename": "src/test/ui/macros/trace-macro.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03da14ba8cd22acbcfe1cca617f6c274999e5e9e/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr?ref=03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "patch": "@@ -5,8 +5,5 @@ LL |     println!(\"Hello, World!\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: expanding `println! { \"Hello, World!\" }`\n-   = note: to `{\n-           # [ cfg ( not ( stage0 ) ) ] {\n-           ( $crate :: io :: _print ( format_args_nl ! ( \"Hello, World!\" ) ) ) ; } # [\n-           cfg ( stage0 ) ] { print ! ( \"{}/n\" , format_args ! ( \"Hello, World!\" ) ) } }`\n+   = note: to `{ $crate :: io :: _print ( format_args_nl ! ( \"Hello, World!\" ) ) ; }`\n "}]}