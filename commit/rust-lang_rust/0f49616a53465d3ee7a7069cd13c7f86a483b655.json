{"sha": "0f49616a53465d3ee7a7069cd13c7f86a483b655", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNDk2MTZhNTM0NjVkM2VlN2E3MDY5Y2QxM2M3Zjg2YTQ4M2I2NTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-28T06:21:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-28T06:21:23Z"}, "message": "Auto merge of #39305 - eddyb:synelide, r=nikomatsakis\n\nPerform lifetime elision (more) syntactically, before type-checking.\n\nThe *initial* goal of this patch was to remove the (contextual) `&RegionScope` argument passed around `rustc_typeck::astconv` and allow converting arbitrary (syntactic) `hir::Ty` to (semantic) `Ty`.\nI've tried to closely match the existing behavior while moving the logic to the earlier `resolve_lifetime` pass, and [the crater report](https://gist.github.com/eddyb/4ac5b8516f87c1bfa2de528ed2b7779a) suggests none of the changes broke real code, but I will try to list everything:\n\nThere are few cases in lifetime elision that could trip users up due to \"hidden knowledge\":\n```rust\ntype StaticStr = &'static str; // hides 'static\ntrait WithLifetime<'a> {\n    type Output; // can hide 'a\n}\n\n// This worked because the type of the first argument contains\n// 'static, although StaticStr doesn't even have parameters.\nfn foo(x: StaticStr) -> &str { x }\n\n// This worked because the compiler resolved the argument type\n// to <T as WithLifetime<'a>>::Output which has the hidden 'a.\nfn bar<'a, T: WithLifetime<'a>>(_: T::Output) -> &str { \"baz\" }\n```\n\nIn the two examples above, elision wasn't using lifetimes that were in the source, not even *needed* by paths in the source, but rather *happened* to be part of the semantic representation of the types.\nTo me, this suggests they should have never worked through elision (and they don't with this PR).\n\nNext we have an actual rule with a strange result, that is, the return type here elides to `&'x str`:\n```rust\nimpl<'a, 'b> Trait for Foo<'a, 'b> {\n    fn method<'x, 'y>(self: &'x Foo<'a, 'b>, _: Bar<'y>) -> &str {\n        &self.name\n    }\n}\n```\nAll 3 of `'a`, `'b` and `'y` are being ignored, because the `&self` elision rule only cares that the first argument is \"`self` by reference\". Due implementation considerations (elision running before typeck), I've limited it in this PR to a reference to a primitive/`struct`/`enum`/`union`, but not other types, but I am doing another crater run to assess the impact of limiting it to literally `&self` and `self: &Self` (they're identical in HIR).\n\nIt's probably ideal to keep an \"implicit `Self` for `self`\" type around and *only* apply the rule to `&self` itself, but that would result in more bikeshed, and #21400 suggests some people expect otherwise.\nAnother decent option is treating `self: X, ... -> Y` like `X -> Y` (one unique lifetime in `X` used for `Y`).\n\nThe remaining changes have to do with \"object lifetime defaults\" (see RFCs [599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and [1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md)):\n```rust\ntrait Trait {}\nstruct Ref2<'a, 'b, T: 'a+'b>(&'a T, &'b T);\n\n// These apply specifically within a (fn) body,\n// which allows type and lifetime inference:\nfn main() {\n    // Used to be &'a mut (Trait+'a) - where 'a is one\n    // inference variable - &'a mut (Trait+'b) in this PR.\n    let _: &mut Trait;\n\n    // Used to be an ambiguity error, but in this PR it's\n    // Ref2<'a, 'b, Trait+'c> (3 inference variables).\n    let _: Ref2<Trait>;\n}\n```\nWhat's happening here is that inference variables are created on the fly by typeck whenever a lifetime has no resolution attached to it - while it would be possible to alter the implementation to reuse inference variables based on decisions made early by `resolve_lifetime`, not doing that is more flexible and works better - it can compile all testcases from #38624 by not ending up with `&'static mut (Trait+'static)`.\n\nThe ambiguity specifically cannot be an early error, because this is only the \"default\" (typeck can still pick something better based on the definition of `Trait` and whether it has any lifetime bounds), and having an error at all doesn't help anyone, as we can perfectly infer an appropriate lifetime inside the `fn` body.\n\n**TODO**: write tests for the user-visible changes.\n\ncc @nikomatsakis @arielb1", "tree": {"sha": "8af6fb2747c61c50bead2da69a56af22bb2f799f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8af6fb2747c61c50bead2da69a56af22bb2f799f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f49616a53465d3ee7a7069cd13c7f86a483b655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f49616a53465d3ee7a7069cd13c7f86a483b655", "html_url": "https://github.com/rust-lang/rust/commit/0f49616a53465d3ee7a7069cd13c7f86a483b655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f49616a53465d3ee7a7069cd13c7f86a483b655/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "html_url": "https://github.com/rust-lang/rust/commit/0f8a296475d8bc27dfa48ec1053cec8fa2f73673"}, {"sha": "c0e474d9a6d11518e602b7e20ccf2bf36725f0ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e474d9a6d11518e602b7e20ccf2bf36725f0ad", "html_url": "https://github.com/rust-lang/rust/commit/c0e474d9a6d11518e602b7e20ccf2bf36725f0ad"}], "stats": {"total": 3655, "additions": 1799, "deletions": 1856}, "files": [{"sha": "b51a7d4104ab92865a5f76d3ba2c3f542a32f690", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -327,6 +327,69 @@ struct ListNode {\n This works because `Box` is a pointer, so its size is well-known.\n \"##,\n \n+E0106: r##\"\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```compile_fail,E0106\n+struct Foo { x: &bool }        // error\n+struct Foo<'a> { x: &'a bool } // correct\n+\n+enum Bar { A(u8), B(&bool), }        // error\n+enum Bar<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr = &str;        // error\n+type MyStr<'a> = &'a str; // correct\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```compile_fail,E0106\n+// error, no input lifetimes\n+fn foo() -> &str { }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { }\n+```\n+\n+Here's an example that is currently an error, but may work in a future version\n+of Rust:\n+\n+```compile_fail,E0106\n+struct Foo<'a>(&'a str);\n+\n+trait Quux { }\n+impl Quux for Foo { }\n+```\n+\n+Lifetime elision in implementation headers was part of the lifetime elision\n+RFC. It is, however, [currently unimplemented][iss15872].\n+\n+[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+[iss15872]: https://github.com/rust-lang/rust/issues/15872\n+\"##,\n+\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:"}, {"sha": "4b3e0d29101e4c33c42f57adee5a5fa339a50412", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -301,7 +301,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_variant_data(&mut self,\n@@ -421,7 +421,7 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v\n \n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n-                                  _modifier: &'v TraitBoundModifier)\n+                                  _modifier: TraitBoundModifier)\n     where V: Visitor<'v>\n {\n     walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n@@ -547,8 +547,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPtr(ref mutable_type) => {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref opt_lifetime, ref mutable_type) => {\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+        TyRptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n         TyNever => {},\n@@ -566,8 +566,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(length)\n         }\n-        TyTraitObject(ref bounds) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        TyTraitObject(ref bounds, ref lifetime) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n+            }\n+            visitor.visit_lifetime(lifetime);\n         }\n         TyImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n@@ -695,7 +698,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n \n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyParamBound) {\n     match *bound {\n-        TraitTyParamBound(ref typ, ref modifier) => {\n+        TraitTyParamBound(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {"}, {"sha": "8a4acb3d03880b57acd47ec2c2885892f71afe89", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 169, "deletions": 38, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -41,12 +41,12 @@\n // in the HIR, especially for multiple identifiers.\n \n use hir;\n-use hir::map::Definitions;\n+use hir::map::{Definitions, DefKey};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n-use util::nodemap::{NodeMap, FxHashMap};\n+use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -78,6 +78,8 @@ pub struct LoweringContext<'a> {\n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n+\n+    type_def_lifetime_params: DefIdMap<usize>,\n }\n \n pub trait Resolver {\n@@ -110,6 +112,7 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n \n@@ -123,24 +126,33 @@ enum ParamMode {\n \n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n-        self.lower_items(c);\n-        let module = self.lower_mod(&c.module);\n-        let attrs = self.lower_attrs(&c.attrs);\n-        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+        /// Full-crate AST visitor that inserts into a fresh\n+        /// `LoweringContext` any information that may be\n+        /// needed from arbitrary locations in the crate.\n+        /// E.g. The number of lifetime generic parameters\n+        /// declared for every type and trait definition.\n+        struct MiscCollector<'lcx, 'interner: 'lcx> {\n+            lctx: &'lcx mut LoweringContext<'interner>,\n+        }\n \n-        hir::Crate {\n-            module: module,\n-            attrs: attrs,\n-            span: c.span,\n-            exported_macros: exported_macros,\n-            items: self.items,\n-            trait_items: self.trait_items,\n-            impl_items: self.impl_items,\n-            bodies: self.bodies,\n+        impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &'lcx Item) {\n+                match item.node {\n+                    ItemKind::Struct(_, ref generics) |\n+                    ItemKind::Union(_, ref generics) |\n+                    ItemKind::Enum(_, ref generics) |\n+                    ItemKind::Ty(_, ref generics) |\n+                    ItemKind::Trait(_, ref generics, ..) => {\n+                        let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n+                        let count = generics.lifetimes.len();\n+                        self.lctx.type_def_lifetime_params.insert(def_id, count);\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_item(self, item);\n+            }\n         }\n-    }\n \n-    fn lower_items(&mut self, c: &Crate) {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n@@ -167,8 +179,23 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let mut item_lowerer = ItemLowerer { lctx: self };\n-        visit::walk_crate(&mut item_lowerer, c);\n+        visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n+        visit::walk_crate(&mut ItemLowerer { lctx: &mut self }, c);\n+\n+        let module = self.lower_mod(&c.module);\n+        let attrs = self.lower_attrs(&c.attrs);\n+        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+\n+        hir::Crate {\n+            module: module,\n+            attrs: attrs,\n+            span: c.span,\n+            exported_macros: exported_macros,\n+            items: self.items,\n+            trait_items: self.trait_items,\n+            impl_items: self.impl_items,\n+            bodies: self.bodies,\n+        }\n     }\n \n     fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>)\n@@ -232,6 +259,14 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn def_key(&mut self, id: DefId) -> DefKey {\n+        if id.is_local() {\n+            self.resolver.definitions().def_key(id.index)\n+        } else {\n+            self.sess.cstore.def_key(id)\n+        }\n+    }\n+\n     fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n@@ -279,7 +314,12 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n                 TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 TyKind::Rptr(ref region, ref mt) => {\n-                    hir::TyRptr(self.lower_opt_lifetime(region), self.lower_mt(mt))\n+                    let span = Span { hi: t.span.lo, ..t.span };\n+                    let lifetime = match *region {\n+                        Some(ref lt) => self.lower_lifetime(lt),\n+                        None => self.elided_lifetime(span)\n+                    };\n+                    hir::TyRptr(lifetime, self.lower_mt(mt))\n                 }\n                 TyKind::BareFn(ref f) => {\n                     hir::TyBareFn(P(hir::BareFnTy {\n@@ -297,7 +337,8 @@ impl<'a> LoweringContext<'a> {\n                     return self.lower_ty(ty);\n                 }\n                 TyKind::Path(ref qself, ref path) => {\n-                    hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n+                    let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n+                    return self.ty_path(t.id, t.span, qpath);\n                 }\n                 TyKind::ImplicitSelf => {\n                     hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n@@ -319,7 +360,23 @@ impl<'a> LoweringContext<'a> {\n                     hir::TyTypeof(self.record_body(expr, None))\n                 }\n                 TyKind::TraitObject(ref bounds) => {\n-                    hir::TyTraitObject(self.lower_bounds(bounds))\n+                    let mut lifetime_bound = None;\n+                    let bounds = bounds.iter().filter_map(|bound| {\n+                        match *bound {\n+                            TraitTyParamBound(ref ty, TraitBoundModifier::None) => {\n+                                Some(self.lower_poly_trait_ref(ty))\n+                            }\n+                            TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                            RegionTyParamBound(ref lifetime) => {\n+                                lifetime_bound = Some(self.lower_lifetime(lifetime));\n+                                None\n+                            }\n+                        }\n+                    }).collect();\n+                    let lifetime_bound = lifetime_bound.unwrap_or_else(|| {\n+                        self.elided_lifetime(t.span)\n+                    });\n+                    hir::TyTraitObject(bounds, lifetime_bound)\n                 }\n                 TyKind::ImplTrait(ref bounds) => {\n                     hir::TyImplTrait(self.lower_bounds(bounds))\n@@ -377,7 +434,40 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     _ => param_mode\n                 };\n-                self.lower_path_segment(segment, param_mode)\n+\n+                // Figure out if this is a type/trait segment,\n+                // which may need lifetime elision performed.\n+                let parent_def_id = |this: &mut Self, def_id: DefId| {\n+                    DefId {\n+                        krate: def_id.krate,\n+                        index: this.def_key(def_id).parent.expect(\"missing parent\")\n+                    }\n+                };\n+                let type_def_id = match resolution.base_def {\n+                    Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n+                        Some(parent_def_id(self, def_id))\n+                    }\n+                    Def::Variant(def_id) if i + 1 == proj_start => {\n+                        Some(parent_def_id(self, def_id))\n+                    }\n+                    Def::Struct(def_id) |\n+                    Def::Union(def_id) |\n+                    Def::Enum(def_id) |\n+                    Def::TyAlias(def_id) |\n+                    Def::Trait(def_id) if i + 1 == proj_start => Some(def_id),\n+                    _ => None\n+                };\n+\n+                let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                    if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                        return n;\n+                    }\n+                    assert!(!def_id.is_local());\n+                    let (n, _) = self.sess.cstore.item_generics_own_param_counts(def_id);\n+                    self.type_def_lifetime_params.insert(def_id, n);\n+                    n\n+                });\n+                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes)\n             }).collect(),\n             span: p.span,\n         });\n@@ -397,7 +487,8 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)))\n+            let new_id = self.next_id();\n+            self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -411,7 +502,7 @@ impl<'a> LoweringContext<'a> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(segment, param_mode));\n+            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -420,7 +511,8 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            ty = self.ty(p.span, hir::TyPath(qpath));\n+            let new_id = self.next_id();\n+            ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n         // Should've returned in the for loop above.\n@@ -443,7 +535,7 @@ impl<'a> LoweringContext<'a> {\n         hir::Path {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n-                self.lower_path_segment(segment, param_mode)\n+                self.lower_path_segment(p.span, segment, param_mode, 0)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n                     name: name,\n@@ -464,10 +556,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path_segment(&mut self,\n+                          path_span: Span,\n                           segment: &PathSegment,\n-                          param_mode: ParamMode)\n+                          param_mode: ParamMode,\n+                          expected_lifetimes: usize)\n                           -> hir::PathSegment {\n-        let parameters = if let Some(ref parameters) = segment.parameters {\n+        let mut parameters = if let Some(ref parameters) = segment.parameters {\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n                     let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n@@ -482,6 +576,14 @@ impl<'a> LoweringContext<'a> {\n             hir::AngleBracketedParameters(data)\n         };\n \n+        if let hir::AngleBracketedParameters(ref mut data) = parameters {\n+            if data.lifetimes.is_empty() {\n+                data.lifetimes = (0..expected_lifetimes).map(|_| {\n+                    self.elided_lifetime(path_span)\n+                }).collect();\n+            }\n+        }\n+\n         hir::PathSegment {\n             name: segment.identifier.name,\n             parameters: parameters,\n@@ -628,10 +730,6 @@ impl<'a> LoweringContext<'a> {\n         lts.iter().map(|l| self.lower_lifetime_def(l)).collect()\n     }\n \n-    fn lower_opt_lifetime(&mut self, o_lt: &Option<Lifetime>) -> Option<hir::Lifetime> {\n-        o_lt.as_ref().map(|lt| self.lower_lifetime(lt))\n-    }\n-\n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         let mut add_bounds = NodeMap();\n@@ -751,8 +849,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n+        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit) {\n+            hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n+            qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath)\n+        };\n         hir::TraitRef {\n-            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit, false),\n+            path: path,\n             ref_id: p.ref_id,\n         }\n     }\n@@ -2269,11 +2371,40 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn ty(&mut self, span: Span, node: hir::Ty_) -> P<hir::Ty> {\n-        P(hir::Ty {\n+    fn ty_path(&mut self, id: NodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n+        let mut id = id;\n+        let node = match qpath {\n+            hir::QPath::Resolved(None, path) => {\n+                // Turn trait object paths into `TyTraitObject` instead.\n+                if let Def::Trait(_) = path.def {\n+                    let principal = hir::PolyTraitRef {\n+                        bound_lifetimes: hir_vec![],\n+                        trait_ref: hir::TraitRef {\n+                            path: path.and_then(|path| path),\n+                            ref_id: id,\n+                        },\n+                        span,\n+                    };\n+\n+                    // The original ID is taken by the `PolyTraitRef`,\n+                    // so the `Ty` itself needs a different one.\n+                    id = self.next_id();\n+\n+                    hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n+                } else {\n+                    hir::TyPath(hir::QPath::Resolved(None, path))\n+                }\n+            }\n+            _ => hir::TyPath(qpath)\n+        };\n+        P(hir::Ty { id, node, span })\n+    }\n+\n+    fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+        hir::Lifetime {\n             id: self.next_id(),\n-            node: node,\n             span: span,\n-        })\n+            name: keywords::Invalid.name()\n+        }\n     }\n }"}, {"sha": "4ebe416e1bfe67c12300b0b9b7d6a62cf3b55019", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -77,6 +77,13 @@ pub mod svh;\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n+\n+    /// Either \"'a\", referring to a named lifetime definition,\n+    /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+    ///\n+    /// HIR lowering inserts these placeholders in type paths that\n+    /// refer to type definitions needing lifetime parameters,\n+    /// `&T` and `&mut T`, and trait objects without `... + 'a`.\n     pub name: Name,\n }\n \n@@ -89,6 +96,12 @@ impl fmt::Debug for Lifetime {\n     }\n }\n \n+impl Lifetime {\n+    pub fn is_elided(&self) -> bool {\n+        self.name == keywords::Invalid.name()\n+    }\n+}\n+\n /// A lifetime definition, eg `'a: 'b+'c+'d`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n@@ -165,30 +178,6 @@ impl PathParameters {\n         })\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => data.is_empty(),\n-\n-            // Even if the user supplied no types, something like\n-            // `X()` is equivalent to `X<(),()>`.\n-            ParenthesizedParameters(..) => false,\n-        }\n-    }\n-\n-    pub fn has_lifetimes(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n-            ParenthesizedParameters(_) => false,\n-        }\n-    }\n-\n-    pub fn has_types(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n-            ParenthesizedParameters(..) => true,\n-        }\n-    }\n-\n     /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n     /// parameters in the parenthesized case.\n     pub fn types(&self) -> HirVec<&P<Ty>> {\n@@ -245,12 +234,6 @@ pub struct AngleBracketedParameterData {\n     pub bindings: HirVec<TypeBinding>,\n }\n \n-impl AngleBracketedParameterData {\n-    fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n-    }\n-}\n-\n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ParenthesizedParameterData {\n@@ -1208,7 +1191,7 @@ pub enum Ty_ {\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n-    TyRptr(Option<Lifetime>, MutTy),\n+    TyRptr(Lifetime, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// The never type (`!`)\n@@ -1222,7 +1205,7 @@ pub enum Ty_ {\n     TyPath(QPath),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TyTraitObject(TyParamBounds),\n+    TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// An `impl Bound1 + Bound2 + Bound3` type\n     /// where `Bound` is a trait or a lifetime.\n     TyImplTrait(TyParamBounds),"}, {"sha": "e058c48c59149b2995a5d8393e0887423d504e35", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -26,6 +26,7 @@ use syntax_pos::{self, BytePos};\n use hir;\n use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, RangeEnd};\n \n+use std::cell::Cell;\n use std::io::{self, Write, Read};\n \n pub enum AnnNode<'a> {\n@@ -359,9 +360,9 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_opt_lifetime(&mut self, lifetime: &Option<hir::Lifetime>) -> io::Result<()> {\n-        if let Some(l) = *lifetime {\n-            self.print_lifetime(&l)?;\n+    pub fn print_opt_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n+        if !lifetime.is_elided() {\n+            self.print_lifetime(lifetime)?;\n             self.nbsp()?;\n         }\n         Ok(())\n@@ -415,8 +416,21 @@ impl<'a> State<'a> {\n             hir::TyPath(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n             }\n-            hir::TyTraitObject(ref bounds) => {\n-                self.print_bounds(\"\", &bounds[..])?;\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                let mut first = true;\n+                for bound in bounds {\n+                    self.nbsp()?;\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        self.word_space(\"+\")?;\n+                    }\n+                    self.print_poly_trait_ref(bound)?;\n+                }\n+                if !lifetime.is_elided() {\n+                    self.word_space(\"+\")?;\n+                    self.print_lifetime(lifetime)?;\n+                }\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n@@ -1553,65 +1567,49 @@ impl<'a> State<'a> {\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        if parameters.is_empty() {\n-            let infer_types = match *parameters {\n-                hir::AngleBracketedParameters(ref data) => data.infer_types,\n-                hir::ParenthesizedParameters(_) => false\n-            };\n-\n-            // FIXME(eddyb) See the comment below about infer_types.\n-            if !(infer_types && false) {\n-                return Ok(());\n-            }\n-        }\n-\n-        if colons_before_params {\n-            word(&mut self.s, \"::\")?\n-        }\n-\n         match *parameters {\n             hir::AngleBracketedParameters(ref data) => {\n-                word(&mut self.s, \"<\")?;\n+                let start = if colons_before_params { \"::<\" } else { \"<\" };\n+                let empty = Cell::new(true);\n+                let start_or_comma = |this: &mut Self| {\n+                    if empty.get() {\n+                        empty.set(false);\n+                        word(&mut this.s, start)\n+                    } else {\n+                        this.word_space(\",\")\n+                    }\n+                };\n \n-                let mut comma = false;\n-                for lifetime in &data.lifetimes {\n-                    if comma {\n-                        self.word_space(\",\")?\n+                if !data.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                    for lifetime in &data.lifetimes {\n+                        start_or_comma(self)?;\n+                        self.print_lifetime(lifetime)?;\n                     }\n-                    self.print_lifetime(lifetime)?;\n-                    comma = true;\n                 }\n \n                 if !data.types.is_empty() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty))?;\n-                    comma = true;\n                 }\n \n                 // FIXME(eddyb) This would leak into error messages, e.g.:\n                 // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n                 if data.infer_types && false {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     word(&mut self.s, \"..\")?;\n-                    comma = true;\n                 }\n \n                 for binding in data.bindings.iter() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     self.print_name(binding.name)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n-                    comma = true;\n                 }\n \n-                word(&mut self.s, \">\")?\n+                if !empty.get() {\n+                    word(&mut self.s, \">\")?\n+                }\n             }\n \n             hir::ParenthesizedParameters(ref data) => {"}, {"sha": "0ff9626ae11a884ada089c11b03a01df8da554ba", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -29,7 +29,9 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(field_init_shorthand)]\n #![feature(libc)]\n+#![feature(loop_break_value)]\n #![feature(nonzero)]\n #![feature(pub_restricted)]\n #![feature(quote)]"}, {"sha": "d11e6e3fc72bd415c31910243845b9a6bccae566", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -28,6 +28,7 @@ use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n+use middle::resolve_lifetime::ObjectLifetimeDefault;\n use ty::{self, Ty, TyCtxt};\n use mir::Mir;\n use session::Session;\n@@ -182,6 +183,9 @@ pub trait CrateStore<'tcx> {\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize);\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n@@ -331,6 +335,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize)\n+        { bug!(\"item_generics_own_param_counts\") }\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault>\n+        { bug!(\"item_generics_object_lifetime_defaults\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }"}, {"sha": "88ef2c69a04dce975ab907a9ee7b1a1e97bee033", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1011, "deletions": 316, "changes": 1327, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -15,55 +15,156 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore we break lifetime name resolution into a separate pass.\n \n-pub use self::DefRegion::*;\n-use self::ScopeChain::*;\n-\n use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::region;\n use ty;\n+\n+use std::cell::Cell;\n use std::mem::replace;\n use syntax::ast;\n+use syntax::attr;\n+use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use util::nodemap::NodeMap;\n+use errors::DiagnosticBuilder;\n+use util::nodemap::{NodeMap, FxHashSet, FxHashMap, DefIdMap};\n+use rustc_back::slice;\n \n-use rustc_data_structures::fx::FxHashSet;\n use hir;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n-pub enum DefRegion {\n-    DefStaticRegion,\n-    DefEarlyBoundRegion(/* index */ u32,\n-                        /* lifetime decl */ ast::NodeId),\n-    DefLateBoundRegion(ty::DebruijnIndex,\n-                       /* lifetime decl */ ast::NodeId),\n-    DefFreeRegion(region::CallSiteScopeData,\n-                  /* lifetime decl */ ast::NodeId),\n+pub enum Region {\n+    Static,\n+    EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n+    LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n+    LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n+    Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n }\n \n+impl Region {\n+    fn early(index: &mut u32, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+        let i = *index;\n+        *index += 1;\n+        (def.lifetime.name, Region::EarlyBound(i, def.lifetime.id))\n+    }\n+\n+    fn late(def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+        let depth = ty::DebruijnIndex::new(1);\n+        (def.lifetime.name, Region::LateBound(depth, def.lifetime.id))\n+    }\n+\n+    fn late_anon(index: &Cell<u32>) -> Region {\n+        let i = index.get();\n+        index.set(i + 1);\n+        let depth = ty::DebruijnIndex::new(1);\n+        Region::LateBoundAnon(depth, i)\n+    }\n+\n+    fn id(&self) -> Option<ast::NodeId> {\n+        match *self {\n+            Region::Static |\n+            Region::LateBoundAnon(..) => None,\n+\n+            Region::EarlyBound(_, id) |\n+            Region::LateBound(_, id) |\n+            Region::Free(_, id) => Some(id)\n+        }\n+    }\n+\n+    fn shifted(self, amount: u32) -> Region {\n+        match self {\n+            Region::LateBound(depth, id) => {\n+                Region::LateBound(depth.shifted(amount), id)\n+            }\n+            Region::LateBoundAnon(depth, index) => {\n+                Region::LateBoundAnon(depth.shifted(amount), index)\n+            }\n+            _ => self\n+        }\n+    }\n+\n+    fn from_depth(self, depth: u32) -> Region {\n+        match self {\n+            Region::LateBound(debruijn, id) => {\n+                Region::LateBound(ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1)\n+                }, id)\n+            }\n+            Region::LateBoundAnon(debruijn, index) => {\n+                Region::LateBoundAnon(ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1)\n+                }, index)\n+            }\n+            _ => self\n+        }\n+    }\n+\n+    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap)\n+             -> Option<Region> {\n+        if let Region::EarlyBound(index, _) = self {\n+            params.get(index as usize).and_then(|lifetime| {\n+                map.defs.get(&lifetime.id).cloned()\n+            })\n+        } else {\n+            Some(self)\n+        }\n+    }\n+}\n+\n+/// A set containing, at most, one known element.\n+/// If two distinct values are inserted into a set, then it\n+/// becomes `Many`, which can be used to detect ambiguities.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+pub enum Set1<T> {\n+    Empty,\n+    One(T),\n+    Many\n+}\n+\n+impl<T: PartialEq> Set1<T> {\n+    pub fn insert(&mut self, value: T) {\n+        if let Set1::Empty = *self {\n+            *self = Set1::One(value);\n+            return;\n+        }\n+        if let Set1::One(ref old) = *self {\n+            if *old == value {\n+                return;\n+            }\n+        }\n+        *self = Set1::Many;\n+    }\n+}\n+\n+pub type ObjectLifetimeDefault = Set1<Region>;\n+\n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n pub struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n-    // `DefRegion` describing how that region is bound\n-    pub defs: NodeMap<DefRegion>,\n+    // `Region` describing how that region is bound\n+    pub defs: NodeMap<Region>,\n \n     // the set of lifetime def ids that are late-bound; late-bound ids\n     // are named regions appearing in fn arguments that do not appear\n     // in where-clauses\n     pub late_bound: NodeMap<ty::Issue32330>,\n+\n+    // For each type and trait definition, maps type parameters\n+    // to the trait object lifetime defaults computed from them.\n+    pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n     sess: &'a Session,\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n-    scope: Scope<'a>,\n+    scope: ScopeRef<'a>,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -83,28 +184,75 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n \n     // List of labels in the function/method currently under analysis.\n     labels_in_fn: Vec<(ast::Name, Span)>,\n+\n+    // Cache for cross-crate per-definition object lifetime defaults.\n+    xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n+}\n+\n+#[derive(Debug)]\n+enum Scope<'a> {\n+    /// Declares lifetimes, and each can be early-bound or late-bound.\n+    /// The `DebruijnIndex` of late-bound lifetimes starts at `1` and\n+    /// it should be shifted by the number of `Binder`s in between the\n+    /// declaration `Binder` and the location it's referenced from.\n+    Binder {\n+        lifetimes: FxHashMap<ast::Name, Region>,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n+    /// if this is a fn body, otherwise the original definitions are used.\n+    /// Unspecified lifetimes are inferred, unless an elision scope is nested,\n+    /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n+    Body {\n+        id: hir::BodyId,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// A scope which either determines unspecified lifetimes or errors\n+    /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n+    Elision {\n+        elide: Elide,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// Use a specific lifetime (if `Some`) or leave it unset (to be\n+    /// inferred in a function body or potentially error outside one),\n+    /// for the default choice of lifetime in a trait object type.\n+    ObjectLifetimeDefault {\n+        lifetime: Option<Region>,\n+        s: ScopeRef<'a>\n+    },\n+\n+    Root\n+}\n+\n+#[derive(Clone, Debug)]\n+enum Elide {\n+    /// Use a fresh anonymous late-bound lifetime each time, by\n+    /// incrementing the counter to generate sequential indices.\n+    FreshLateAnon(Cell<u32>),\n+    /// Always use this one lifetime.\n+    Exact(Region),\n+    /// Like `Exact(Static)` but requires `#![feature(static_in_const)]`.\n+    Static,\n+    /// Less or more than one lifetime were found, error on unspecified.\n+    Error(Vec<ElisionFailureInfo>)\n }\n \n-#[derive(PartialEq, Debug)]\n-enum ScopeChain<'a> {\n-    /// EarlyScope(['a, 'b, ...], start, s) extends s with early-bound\n-    /// lifetimes, with consecutive parameter indices from `start`.\n-    /// That is, 'a has index `start`, 'b has index `start + 1`, etc.\n-    /// Indices before `start` correspond to other generic parameters\n-    /// of a parent item (trait/impl of a method), or `Self` in traits.\n-    EarlyScope(&'a [hir::LifetimeDef], u32, Scope<'a>),\n-    /// LateScope(['a, 'b, ...], s) extends s with late-bound\n-    /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n-\n-    /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n-    FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n-    RootScope\n+#[derive(Clone, Debug)]\n+struct ElisionFailureInfo {\n+    /// Where we can find the argument pattern.\n+    parent: Option<hir::BodyId>,\n+    /// The index of the argument in the original definition.\n+    index: usize,\n+    lifetime_count: usize,\n+    have_bound_regions: bool\n }\n \n-type Scope<'a> = &'a ScopeChain<'a>;\n+type ScopeRef<'a> = &'a Scope<'a>;\n \n-static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n+const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn krate(sess: &Session,\n              hir_map: &Map)\n@@ -114,178 +262,197 @@ pub fn krate(sess: &Session,\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeMap(),\n+        object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n     };\n     sess.track_errors(|| {\n-        intravisit::walk_crate(&mut LifetimeContext {\n+        let mut visitor = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: &mut map,\n-            scope: &ROOT_SCOPE,\n+            scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n-        }, krate);\n+            xcrate_object_lifetime_defaults: DefIdMap(),\n+        };\n+        for (_, item) in &krate.items {\n+            visitor.visit_item(item);\n+        }\n     })?;\n     Ok(map)\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    // Override the nested functions -- lifetimes follow lexical scope,\n-    // so it's convenient to walk the tree in lexical order.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.hir_map)\n+        NestedVisitorMap::All(self.hir_map)\n+    }\n+\n+    // We want to nest trait/impl items in their parent, but nothing else.\n+    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        // Each body has their own set of labels, save labels.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+        let body = self.hir_map.body(body);\n+        extract_labels(self, body);\n+        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n+            this.visit_body(body);\n+        });\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        // Save labels for nested items.\n-        let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n-\n-        // Items always introduce a new root scope\n-        self.with(RootScope, |_, this| {\n-            match item.node {\n-                hir::ItemFn(..) => {\n-                    // Fn lifetimes get added in visit_fn below:\n+        match item.node {\n+            hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+                self.visit_early_late(item.id, None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n-                }\n-                hir::ItemExternCrate(_) |\n-                hir::ItemUse(..) |\n-                hir::ItemMod(..) |\n-                hir::ItemDefaultImpl(..) |\n-                hir::ItemForeignMod(..) |\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) => {\n-                    // These sorts of items have no lifetime parameters at all.\n+                });\n+            }\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemForeignMod(..) => {\n+                // These sorts of items have no lifetime parameters at all.\n+                intravisit::walk_item(self, item);\n+            }\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) => {\n+                // No lifetime parameters, but implied 'static.\n+                let scope = Scope::Elision {\n+                    elide: Elide::Static,\n+                    s: ROOT_SCOPE\n+                };\n+                self.with(scope, |_, this| intravisit::walk_item(this, item));\n+            }\n+            hir::ItemTy(_, ref generics) |\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) |\n+            hir::ItemTrait(_, ref generics, ..) |\n+            hir::ItemImpl(_, _, ref generics, ..) => {\n+                // These kinds of items have only early bound lifetime parameters.\n+                let mut index = if let hir::ItemTrait(..) = item.node {\n+                    1 // Self comes before lifetimes\n+                } else {\n+                    0\n+                };\n+                let lifetimes = generics.lifetimes.iter().map(|def| {\n+                    Region::early(&mut index, def)\n+                }).collect();\n+                let scope = Scope::Binder {\n+                    lifetimes: lifetimes,\n+                    s: ROOT_SCOPE\n+                };\n+                self.with(scope, |old_scope, this| {\n+                    this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                     intravisit::walk_item(this, item);\n-                }\n-                hir::ItemTy(_, ref generics) |\n-                hir::ItemEnum(_, ref generics) |\n-                hir::ItemStruct(_, ref generics) |\n-                hir::ItemUnion(_, ref generics) |\n-                hir::ItemTrait(_, ref generics, ..) |\n-                hir::ItemImpl(_, _, ref generics, ..) => {\n-                    // These kinds of items have only early bound lifetime parameters.\n-                    let lifetimes = &generics.lifetimes;\n-                    let start = if let hir::ItemTrait(..) = item.node {\n-                        1 // Self comes before lifetimes\n-                    } else {\n-                        0\n-                    };\n-                    this.with(EarlyScope(lifetimes, start, &ROOT_SCOPE), |old_scope, this| {\n-                        this.check_lifetime_defs(old_scope, lifetimes);\n-                        intravisit::walk_item(this, item);\n-                    });\n-                }\n+                });\n             }\n-        });\n-\n-        // Done traversing the item; remove any labels it created\n-        self.labels_in_fn = saved_labels_in_fn;\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        // Items save/restore the set of labels. This way inner items\n-        // can freely reuse names, be they loop labels or lifetimes.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n-\n-        // Items always introduce a new root scope\n-        self.with(RootScope, |_, this| {\n-            match item.node {\n-                hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                    this.visit_early_late(item.id, decl, generics, |this| {\n-                        intravisit::walk_foreign_item(this, item);\n-                    })\n-                }\n-                hir::ForeignItemStatic(..) => {\n+        match item.node {\n+            hir::ForeignItemFn(ref decl, _, ref generics) => {\n+                self.visit_early_late(item.id, None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n-                }\n-            }\n-        });\n-\n-        // Done traversing the item; restore saved set of labels.\n-        replace(&mut self.labels_in_fn, saved);\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, fn_id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                self.visit_early_late(fn_id,decl, generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n-            FnKind::Method(_, sig, ..) => {\n-                self.visit_early_late(\n-                    fn_id,\n-                    decl,\n-                    &sig.generics,\n-                    |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n-            }\n-            FnKind::Closure(_) => {\n-                // Closures have their own set of labels, save labels just\n-                // like for foreign items above.\n-                let saved = replace(&mut self.labels_in_fn, vec![]);\n-                let result = self.add_scope_and_walk_fn(fk, decl, b, s, fn_id);\n-                replace(&mut self.labels_in_fn, saved);\n-                result\n+            hir::ForeignItemStatic(..) => {\n+                intravisit::walk_foreign_item(self, item);\n             }\n         }\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n-                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n+                let scope = Scope::Binder {\n+                    lifetimes: c.lifetimes.iter().map(Region::late).collect(),\n+                    s: self.scope\n+                };\n+                self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n                     this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n-                // if this path references a trait, then this will resolve to\n-                // a trait ref, which introduces a binding scope.\n-                match path.def {\n-                    Def::Trait(..) => {\n-                        self.with(LateScope(&[], self.scope), |_, this| {\n-                            this.visit_path(path, ty.id);\n-                        });\n-                    }\n-                    _ => {\n-                        intravisit::walk_ty(self, ty);\n-                    }\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                for bound in bounds {\n+                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                }\n+                if lifetime.is_elided() {\n+                    self.resolve_object_lifetime_default(lifetime)\n+                } else {\n+                    self.visit_lifetime(lifetime);\n                 }\n             }\n+            hir::TyRptr(ref lifetime_ref, ref mt) => {\n+                self.visit_lifetime(lifetime_ref);\n+                let scope = Scope::ObjectLifetimeDefault {\n+                    lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n+                    s: self.scope\n+                };\n+                self.with(scope, |_, this| this.visit_ty(&mt.ty));\n+            }\n             _ => {\n                 intravisit::walk_ty(self, ty)\n             }\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        // We reset the labels on every trait item, so that different\n-        // methods in an impl can reuse label names.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n-\n-        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) =\n-                trait_item.node {\n+        if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n                 trait_item.id,\n+                Some(self.hir_map.get_parent(trait_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n         }\n+    }\n \n-        replace(&mut self.labels_in_fn, saved);\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+            self.visit_early_late(\n+                impl_item.id,\n+                Some(self.hir_map.get_parent(impl_item.id)),\n+                &sig.decl, &sig.generics,\n+                |this| intravisit::walk_impl_item(this, impl_item))\n+        } else {\n+            intravisit::walk_impl_item(self, impl_item);\n+        }\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        if lifetime_ref.is_elided() {\n+            self.resolve_elided_lifetimes(slice::ref_slice(lifetime_ref));\n+            return;\n+        }\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n-            self.insert_lifetime(lifetime_ref, DefStaticRegion);\n+            self.insert_lifetime(lifetime_ref, Region::Static);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            let depth = path.segments.len() - i - 1;\n+            self.visit_segment_parameters(path.def, depth, &segment.parameters);\n+        }\n+    }\n+\n+    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n+        let output = match fd.output {\n+            hir::DefaultReturn(_) => None,\n+            hir::Return(ref ty) => Some(ty)\n+        };\n+        self.visit_fn_like_elision(&fd.inputs, output);\n+    }\n+\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n@@ -301,8 +468,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                                                                .. }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n-                        let result = self.with(LateScope(bound_lifetimes, self.scope),\n-                                               |old_scope, this| {\n+                        let scope = Scope::Binder {\n+                            lifetimes: bound_lifetimes.iter().map(Region::late).collect(),\n+                            s: self.scope\n+                        };\n+                        let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n@@ -335,20 +505,24 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(&mut self,\n                             trait_ref: &'tcx hir::PolyTraitRef,\n-                            _modifier: &'tcx hir::TraitBoundModifier) {\n+                            _modifier: hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n                 span_err!(self.sess, trait_ref.span, E0316,\n                           \"nested quantification of lifetimes\");\n             }\n-            self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+            let scope = Scope::Binder {\n+                lifetimes: trait_ref.bound_lifetimes.iter().map(Region::late).collect(),\n+                s: self.scope\n+            };\n+            self.with(scope, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n                 }\n-                intravisit::walk_path(this, &trait_ref.trait_ref.path)\n+                this.visit_trait_ref(&trait_ref.trait_ref)\n             })\n         } else {\n             self.visit_trait_ref(&trait_ref.trait_ref)\n@@ -367,8 +541,8 @@ fn original_label(span: Span) -> Original {\n fn shadower_label(span: Span) -> Shadower {\n     Shadower { kind: ShadowKind::Label, span: span }\n }\n-fn original_lifetime(l: &hir::Lifetime) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span: l.span }\n+fn original_lifetime(span: Span) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span: span }\n }\n fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: l.span }\n@@ -406,33 +580,28 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n-    struct GatherLabels<'a> {\n+fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n+    struct GatherLabels<'a, 'tcx: 'a> {\n         sess: &'a Session,\n-        scope: Scope<'a>,\n+        hir_map: &'a Map<'tcx>,\n+        scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n     let mut gather = GatherLabels {\n         sess: ctxt.sess,\n+        hir_map: ctxt.hir_map,\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_body(ctxt.hir_map.body(b));\n-    return;\n+    gather.visit_body(body);\n \n-    impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+    impl<'v, 'a, 'tcx> Visitor<'v> for GatherLabels<'a, 'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n             NestedVisitorMap::None\n         }\n \n-        fn visit_expr(&mut self, ex: &'v hir::Expr) {\n-            // do not recurse into closures defined in the block\n-            // since they are treated as separate fns from the POV of\n-            // labels_in_fn\n-            if let hir::ExprClosure(..) = ex.node {\n-                return\n-            }\n+        fn visit_expr(&mut self, ex: &hir::Expr) {\n             if let Some((label, label_span)) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n@@ -445,6 +614,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n                 }\n \n                 check_if_label_shadows_lifetime(self.sess,\n+                                                self.hir_map,\n                                                 self.scope,\n                                                 label,\n                                                 label_span);\n@@ -453,10 +623,6 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n             }\n             intravisit::walk_expr(self, ex)\n         }\n-\n-        fn visit_item(&mut self, _: &hir::Item) {\n-            // do not recurse into items defined in the block\n-        }\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n@@ -468,26 +634,27 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     }\n \n     fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n-                                           mut scope: Scope<'a>,\n+                                           hir_map: &Map,\n+                                           mut scope: ScopeRef<'a>,\n                                            label: ast::Name,\n                                            label_span: Span) {\n         loop {\n             match *scope {\n-                FnScope { s, .. } => { scope = s; }\n-                RootScope => { return; }\n-\n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n-                    for lifetime_def in lifetimes {\n-                        // FIXME (#24278): non-hygienic comparison\n-                        if label == lifetime_def.lifetime.name {\n-                            signal_shadowing_problem(\n-                                sess,\n-                                label,\n-                                original_lifetime(&lifetime_def.lifetime),\n-                                shadower_label(label_span));\n-                            return;\n-                        }\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => { scope = s; }\n+\n+                Scope::Root => { return; }\n+\n+                Scope::Binder { ref lifetimes, s } => {\n+                    // FIXME (#24278): non-hygienic comparison\n+                    if let Some(def) = lifetimes.get(&label) {\n+                        signal_shadowing_problem(\n+                            sess,\n+                            label,\n+                            original_lifetime(hir_map.span(def.id().unwrap())),\n+                            shadower_label(label_span));\n+                        return;\n                     }\n                     scope = s;\n                 }\n@@ -496,57 +663,132 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    fn add_scope_and_walk_fn(&mut self,\n-                             fk: FnKind<'tcx>,\n-                             fd: &'tcx hir::FnDecl,\n-                             fb: hir::BodyId,\n-                             _span: Span,\n-                             fn_id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                intravisit::walk_fn_decl(self, fd);\n-                self.visit_generics(generics);\n-            }\n-            FnKind::Method(_, sig, ..) => {\n-                intravisit::walk_fn_decl(self, fd);\n-                self.visit_generics(&sig.generics);\n+fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n+                                    -> NodeMap<Vec<ObjectLifetimeDefault>> {\n+    let mut map = NodeMap();\n+    for item in hir_map.krate().items.values() {\n+        match item.node {\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) |\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemTy(_, ref generics) |\n+            hir::ItemTrait(_, ref generics, ..) => {\n+                let result = object_lifetime_defaults_for_item(hir_map, generics);\n+\n+                // Debugging aid.\n+                if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n+                    let object_lifetime_default_reprs: String =\n+                        result.iter().map(|set| {\n+                            match *set {\n+                                Set1::Empty => \"BaseDefault\".to_string(),\n+                                Set1::One(Region::Static) => \"'static\".to_string(),\n+                                Set1::One(Region::EarlyBound(i, _)) => {\n+                                    generics.lifetimes[i as usize].lifetime.name.to_string()\n+                                }\n+                                Set1::One(_) => bug!(),\n+                                Set1::Many => \"Ambiguous\".to_string(),\n+                            }\n+                        }).collect::<Vec<String>>().join(\",\");\n+                    sess.span_err(item.span, &object_lifetime_default_reprs);\n+                }\n+\n+                map.insert(item.id, result);\n             }\n-            FnKind::Closure(_) => {\n-                intravisit::walk_fn_decl(self, fd);\n+            _ => {}\n+        }\n+    }\n+    map\n+}\n+\n+/// Scan the bounds and where-clauses on parameters to extract bounds\n+/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n+/// for each type parameter.\n+fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n+                                     -> Vec<ObjectLifetimeDefault> {\n+    fn add_bounds(set: &mut Set1<ast::Name>, bounds: &[hir::TyParamBound]) {\n+        for bound in bounds {\n+            if let hir::RegionTyParamBound(ref lifetime) = *bound {\n+                set.insert(lifetime.name);\n             }\n         }\n+    }\n \n-        // After inpsecting the decl, add all labels from the body to\n-        // `self.labels_in_fn`.\n-        extract_labels(self, fb);\n+    generics.ty_params.iter().map(|param| {\n+        let mut set = Set1::Empty;\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n-                  |_old_scope, this| this.visit_nested_body(fb))\n-    }\n+        add_bounds(&mut set, &param.bounds);\n+\n+        let param_def_id = hir_map.local_def_id(param.id);\n+        for predicate in &generics.where_clause.predicates {\n+            // Look for `type: ...` where clauses.\n+            let data = match *predicate {\n+                hir::WherePredicate::BoundPredicate(ref data) => data,\n+                _ => continue\n+            };\n+\n+            // Ignore `for<'a> type: ...` as they can change what\n+            // lifetimes mean (although we could \"just\" handle it).\n+            if !data.bound_lifetimes.is_empty() {\n+                continue;\n+            }\n+\n+            let def = match data.bounded_ty.node {\n+                hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                _ => continue\n+            };\n \n+            if def == Def::TyParam(param_def_id) {\n+                add_bounds(&mut set, &data.bounds);\n+            }\n+        }\n+\n+        match set {\n+            Set1::Empty => Set1::Empty,\n+            Set1::One(name) => {\n+                if name == keywords::StaticLifetime.name() {\n+                    Set1::One(Region::Static)\n+                } else {\n+                    generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n+                        def.lifetime.name == name\n+                    }).map_or(Set1::Many, |(i, def)| {\n+                        Set1::One(Region::EarlyBound(i as u32, def.lifetime.id))\n+                    })\n+                }\n+            }\n+            Set1::Many => Set1::Many\n+        }\n+    }).collect()\n+}\n+\n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // FIXME(#37666) this works around a limitation in the region inferencer\n     fn hack<F>(&mut self, f: F) where\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         f(self)\n     }\n \n-    fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: for<'b> FnOnce(Scope, &mut LifetimeContext<'b, 'tcx>),\n+    fn with<F>(&mut self, wrap_scope: Scope, f: F) where\n+        F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n+        let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n+        let xcrate_object_lifetime_defaults =\n+            replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n         let mut this = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n-            labels_in_fn: self.labels_in_fn.clone(),\n+            labels_in_fn: labels_in_fn,\n+            xcrate_object_lifetime_defaults: xcrate_object_lifetime_defaults,\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n         debug!(\"exiting scope {:?}\", this.scope);\n+        self.labels_in_fn = this.labels_in_fn;\n+        self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -569,6 +811,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n+                           parent_id: Option<ast::NodeId>,\n                            decl: &'tcx hir::FnDecl,\n                            generics: &'tcx hir::Generics,\n                            walk: F) where\n@@ -580,156 +823,618 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     decl,\n                                     generics);\n \n-        let (late, early): (Vec<_>, _) =\n-            generics.lifetimes\n-                    .iter()\n-                    .cloned()\n-                    .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n-\n         // Find the start of nested early scopes, e.g. in methods.\n-        let mut start = 0;\n-        if let EarlyScope(..) = *self.scope {\n-            let parent = self.hir_map.expect_item(self.hir_map.get_parent(fn_id));\n+        let mut index = 0;\n+        if let Some(parent_id) = parent_id {\n+            let parent = self.hir_map.expect_item(parent_id);\n             if let hir::ItemTrait(..) = parent.node {\n-                start += 1; // Self comes first.\n+                index += 1; // Self comes first.\n             }\n             match parent.node {\n                 hir::ItemTrait(_, ref generics, ..) |\n                 hir::ItemImpl(_, _, ref generics, ..) => {\n-                    start += generics.lifetimes.len() + generics.ty_params.len();\n+                    index += (generics.lifetimes.len() + generics.ty_params.len()) as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n-        self.with(EarlyScope(&early, start as u32, self.scope), move |old_scope, this| {\n-            this.with(LateScope(&late, this.scope), move |_, this| {\n-                this.check_lifetime_defs(old_scope, &generics.lifetimes);\n-                this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n-            });\n+        let lifetimes = generics.lifetimes.iter().map(|def| {\n+            if self.map.late_bound.contains_key(&def.lifetime.id) {\n+                Region::late(def)\n+            } else {\n+                Region::early(&mut index, def)\n+            }\n+        }).collect();\n+\n+        let scope = Scope::Binder {\n+            lifetimes: lifetimes,\n+            s: self.scope\n+        };\n+        self.with(scope, move |old_scope, this| {\n+            this.check_lifetime_defs(old_scope, &generics.lifetimes);\n+            this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n         });\n     }\n \n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n-        // given name or we run out of scopes. If we encounter a code\n-        // block, then the lifetime is not bound but free, so switch\n-        // over to `resolve_free_lifetime_ref()` to complete the\n+        // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        loop {\n+        let mut outermost_body = None;\n+        let result = loop {\n             match *scope {\n-                FnScope {fn_id, body_id, s } => {\n-                    return self.resolve_free_lifetime_ref(\n-                        region::CallSiteScopeData { fn_id: fn_id, body_id: body_id },\n-                        lifetime_ref,\n-                        s);\n+                Scope::Body { id, s } => {\n+                    outermost_body = Some(id);\n+                    scope = s;\n                 }\n \n-                RootScope => {\n-                    break;\n+                Scope::Root => {\n+                    break None;\n                 }\n \n-                EarlyScope(lifetimes, start, s) => {\n-                    match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, lifetime_def)) => {\n-                            let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(start + index, decl_id);\n-                            self.insert_lifetime(lifetime_ref, def);\n-                            return;\n-                        }\n-                        None => {\n+                Scope::Binder { ref lifetimes, s } => {\n+                    if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n+                        break Some(def.shifted(late_depth));\n+                    } else {\n+                        late_depth += 1;\n+                        scope = s;\n+                    }\n+                }\n+\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        };\n+\n+        if let Some(mut def) = result {\n+            if let Some(body_id) = outermost_body {\n+                let fn_id = self.hir_map.body_owner(body_id);\n+                let scope_data = region::CallSiteScopeData {\n+                    fn_id: fn_id, body_id: body_id.node_id\n+                };\n+                match self.hir_map.get(fn_id) {\n+                    hir::map::NodeItem(&hir::Item {\n+                        node: hir::ItemFn(..), ..\n+                    }) |\n+                    hir::map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(..), ..\n+                    }) |\n+                    hir::map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(..), ..\n+                    }) => {\n+                        def = Region::Free(scope_data, def.id().unwrap());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            self.insert_lifetime(lifetime_ref, def);\n+        } else {\n+            struct_span_err!(self.sess, lifetime_ref.span, E0261,\n+                \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n+                .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n+                .emit();\n+        }\n+    }\n+\n+    fn visit_segment_parameters(&mut self,\n+                                def: Def,\n+                                depth: usize,\n+                                params: &'tcx hir::PathParameters) {\n+        let data = match *params {\n+            hir::ParenthesizedParameters(ref data) => {\n+                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n+                return;\n+            }\n+            hir::AngleBracketedParameters(ref data) => data\n+        };\n+\n+        if data.lifetimes.iter().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(&data.lifetimes);\n+        } else {\n+            for l in &data.lifetimes { self.visit_lifetime(l); }\n+        }\n+\n+        // Figure out if this is a type/trait segment,\n+        // which requires object lifetime defaults.\n+        let parent_def_id = |this: &mut Self, def_id: DefId| {\n+            let def_key = if def_id.is_local() {\n+                this.hir_map.def_key(def_id)\n+            } else {\n+                this.sess.cstore.def_key(def_id)\n+            };\n+            DefId {\n+                krate: def_id.krate,\n+                index: def_key.parent.expect(\"missing parent\")\n+            }\n+        };\n+        let type_def_id = match def {\n+            Def::AssociatedTy(def_id) if depth == 1 => {\n+                Some(parent_def_id(self, def_id))\n+            }\n+            Def::Variant(def_id) if depth == 0 => {\n+                Some(parent_def_id(self, def_id))\n+            }\n+            Def::Struct(def_id) |\n+            Def::Union(def_id) |\n+            Def::Enum(def_id) |\n+            Def::TyAlias(def_id) |\n+            Def::Trait(def_id) if depth == 0 => Some(def_id),\n+            _ => None\n+        };\n+\n+        let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n+            let in_body = {\n+                let mut scope = self.scope;\n+                loop {\n+                    match *scope {\n+                        Scope::Root => break false,\n+\n+                        Scope::Body { .. } => break true,\n+\n+                        Scope::Binder { s, .. } |\n+                        Scope::Elision { s, .. } |\n+                        Scope::ObjectLifetimeDefault { s, .. } => {\n                             scope = s;\n                         }\n                     }\n                 }\n+            };\n+\n+            let map = &self.map;\n+            let unsubst = if let Some(id) = self.hir_map.as_local_node_id(def_id) {\n+                &map.object_lifetime_defaults[&id]\n+            } else {\n+                let cstore = &self.sess.cstore;\n+                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n+                    cstore.item_generics_object_lifetime_defaults(def_id)\n+                })\n+            };\n+            unsubst.iter().map(|set| {\n+                match *set {\n+                    Set1::Empty => {\n+                        if in_body {\n+                            None\n+                        } else {\n+                            Some(Region::Static)\n+                        }\n+                    }\n+                    Set1::One(r) => r.subst(&data.lifetimes, map),\n+                    Set1::Many => None\n+                }\n+            }).collect()\n+        });\n+\n+        for (i, ty) in data.types.iter().enumerate() {\n+            if let Some(&lt) = object_lifetime_defaults.get(i) {\n+                let scope = Scope::ObjectLifetimeDefault {\n+                    lifetime: lt,\n+                    s: self.scope\n+                };\n+                self.with(scope, |_, this| this.visit_ty(ty));\n+            } else {\n+                self.visit_ty(ty);\n+            }\n+        }\n+\n+        for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+    }\n+\n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n+                             output: Option<&'tcx P<hir::Ty>>) {\n+        let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n+        let arg_scope = Scope::Elision {\n+            elide: arg_elide.clone(),\n+            s: self.scope\n+        };\n+        self.with(arg_scope, |_, this| {\n+            for input in inputs {\n+                this.visit_ty(input);\n+            }\n+            match *this.scope {\n+                Scope::Elision { ref elide, .. } => {\n+                    arg_elide = elide.clone();\n+                }\n+                _ => bug!()\n+            }\n+        });\n+\n+        let output = match output {\n+            Some(ty) => ty,\n+            None => return\n+        };\n+\n+        // Figure out if there's a body we can get argument names from,\n+        // and whether there's a `self` argument (treated specially).\n+        let mut assoc_item_kind = None;\n+        let mut impl_self = None;\n+        let parent = self.hir_map.get_parent_node(output.id);\n+        let body = match self.hir_map.get(parent) {\n+            // `fn` definitions and methods.\n+            hir::map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(.., body), ..\n+            })  => Some(body),\n+\n+            hir::map::NodeTraitItem(&hir::TraitItem {\n+                node: hir::TraitItemKind::Method(_, ref m), ..\n+            }) => {\n+                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                    hir::ItemTrait(.., ref trait_items) => {\n+                        assoc_item_kind = trait_items.iter().find(|ti| ti.id.node_id == parent)\n+                                                            .map(|ti| ti.kind);\n+                    }\n+                    _ => {}\n+                }\n+                match *m {\n+                    hir::TraitMethod::Required(_) => None,\n+                    hir::TraitMethod::Provided(body) => Some(body),\n+                }\n+            }\n+\n+            hir::map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(_, body), ..\n+            }) => {\n+                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                    hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n+                        impl_self = Some(self_ty);\n+                        assoc_item_kind = impl_items.iter().find(|ii| ii.id.node_id == parent)\n+                                                           .map(|ii| ii.kind);\n+                    }\n+                    _ => {}\n+                }\n+                Some(body)\n+            }\n+\n+            // `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n+            hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n+\n+            // Foreign `fn` decls are terrible because we messed up,\n+            // and their return types get argument type elision.\n+            // And now too much code out there is abusing this rule.\n+            hir::map::NodeForeignItem(_) => {\n+                let arg_scope = Scope::Elision {\n+                    elide: arg_elide,\n+                    s: self.scope\n+                };\n+                self.with(arg_scope, |_, this| this.visit_ty(output));\n+                return;\n+            }\n+\n+            // Everything else (only closures?) doesn't\n+            // actually enjoy elision in return types.\n+            _ => {\n+                self.visit_ty(output);\n+                return;\n+            }\n+        };\n+\n+        let has_self = match assoc_item_kind {\n+            Some(hir::AssociatedItemKind::Method { has_self }) => has_self,\n+            _ => false\n+        };\n+\n+        // In accordance with the rules for lifetime elision, we can determine\n+        // what region to use for elision in the output type in two ways.\n+        // First (determined here), if `self` is by-reference, then the\n+        // implied output region is the region of the self parameter.\n+        if has_self {\n+            // Look for `self: &'a Self` - also desugared from `&'a self`,\n+            // and if that matches, use it for elision and return early.\n+            let is_self_ty = |def: Def| {\n+                if let Def::SelfTy(..) = def {\n+                    return true;\n+                }\n+\n+                // Can't always rely on literal (or implied) `Self` due\n+                // to the way elision rules were originally specified.\n+                let impl_self = impl_self.map(|ty| &ty.node);\n+                if let Some(&hir::TyPath(hir::QPath::Resolved(None, ref path))) = impl_self {\n+                    match path.def {\n+                        // Whitelist the types that unambiguously always\n+                        // result in the same type constructor being used\n+                        // (it can't differ between `Self` and `self`).\n+                        Def::Struct(_) |\n+                        Def::Union(_) |\n+                        Def::Enum(_) |\n+                        Def::PrimTy(_) => return def == path.def,\n+                        _ => {}\n+                    }\n+                }\n \n-                LateScope(lifetimes, s) => {\n-                    match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((_index, lifetime_def)) => {\n-                            let decl_id = lifetime_def.id;\n-                            let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n-                            let def = DefLateBoundRegion(debruijn, decl_id);\n-                            self.insert_lifetime(lifetime_ref, def);\n+                false\n+            };\n+\n+            if let hir::TyRptr(lifetime_ref, ref mt) = inputs[0].node {\n+                if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n+                    if is_self_ty(path.def) {\n+                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                            let scope = Scope::Elision {\n+                                elide: Elide::Exact(lifetime),\n+                                s: self.scope\n+                            };\n+                            self.with(scope, |_, this| this.visit_ty(output));\n                             return;\n                         }\n+                    }\n+                }\n+            }\n+        }\n \n-                        None => {\n-                            late_depth += 1;\n-                            scope = s;\n+        // Second, if there was exactly one lifetime (either a substitution or a\n+        // reference) in the arguments, then any anonymous regions in the output\n+        // have that lifetime.\n+        let mut possible_implied_output_region = None;\n+        let mut lifetime_count = 0;\n+        let arg_lifetimes = inputs.iter().enumerate().skip(has_self as usize).map(|(i, input)| {\n+            let mut gather = GatherLifetimes {\n+                map: self.map,\n+                binder_depth: 1,\n+                have_bound_regions: false,\n+                lifetimes: FxHashSet()\n+            };\n+            gather.visit_ty(input);\n+\n+            lifetime_count += gather.lifetimes.len();\n+\n+            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n+                // there's a chance that the unique lifetime of this\n+                // iteration will be the appropriate lifetime for output\n+                // parameters, so lets store it.\n+                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n+            }\n+\n+            ElisionFailureInfo {\n+                parent: body,\n+                index: i,\n+                lifetime_count: gather.lifetimes.len(),\n+                have_bound_regions: gather.have_bound_regions\n+            }\n+        }).collect();\n+\n+        let elide = if lifetime_count == 1 {\n+            Elide::Exact(possible_implied_output_region.unwrap())\n+        } else {\n+            Elide::Error(arg_lifetimes)\n+        };\n+\n+        let scope = Scope::Elision {\n+            elide: elide,\n+            s: self.scope\n+        };\n+        self.with(scope, |_, this| this.visit_ty(output));\n+\n+        struct GatherLifetimes<'a> {\n+            map: &'a NamedRegionMap,\n+            binder_depth: u32,\n+            have_bound_regions: bool,\n+            lifetimes: FxHashSet<Region>,\n+        }\n+\n+        impl<'v, 'a> Visitor<'v> for GatherLifetimes<'a> {\n+            fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_ty(&mut self, ty: &hir::Ty) {\n+                if let hir::TyBareFn(_) = ty.node {\n+                    self.binder_depth += 1;\n+                }\n+                if let hir::TyTraitObject(ref bounds, ref lifetime) = ty.node {\n+                    for bound in bounds {\n+                        self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                    }\n+\n+                    // Stay on the safe side and don't include the object\n+                    // lifetime default (which may not end up being used).\n+                    if !lifetime.is_elided() {\n+                        self.visit_lifetime(lifetime);\n+                    }\n+                } else {\n+                    intravisit::walk_ty(self, ty);\n+                }\n+                if let hir::TyBareFn(_) = ty.node {\n+                    self.binder_depth -= 1;\n+                }\n+            }\n+\n+            fn visit_poly_trait_ref(&mut self,\n+                                    trait_ref: &hir::PolyTraitRef,\n+                                    modifier: hir::TraitBoundModifier) {\n+                self.binder_depth += 1;\n+                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+                self.binder_depth -= 1;\n+            }\n+\n+            fn visit_lifetime_def(&mut self, lifetime_def: &hir::LifetimeDef) {\n+                for l in &lifetime_def.bounds { self.visit_lifetime(l); }\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                    match lifetime {\n+                        Region::LateBound(debruijn, _) |\n+                        Region::LateBoundAnon(debruijn, _)\n+                                if debruijn.depth < self.binder_depth => {\n+                            self.have_bound_regions = true;\n+                        }\n+                        _ => {\n+                            self.lifetimes.insert(lifetime.from_depth(self.binder_depth));\n                         }\n                     }\n                 }\n             }\n         }\n \n-        self.unresolved_lifetime_ref(lifetime_ref);\n     }\n \n-    fn resolve_free_lifetime_ref(&mut self,\n-                                 scope_data: region::CallSiteScopeData,\n-                                 lifetime_ref: &hir::Lifetime,\n-                                 scope: Scope) {\n-        debug!(\"resolve_free_lifetime_ref \\\n-                scope_data: {:?} lifetime_ref: {:?} scope: {:?}\",\n-               scope_data, lifetime_ref, scope);\n+    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[hir::Lifetime]) {\n+        if lifetime_refs.is_empty() {\n+            return;\n+        }\n \n-        // Walk up the scope chain, tracking the outermost free scope,\n-        // until we encounter a scope that contains the named lifetime\n-        // or we run out of scopes.\n-        let mut scope_data = scope_data;\n-        let mut scope = scope;\n-        let mut search_result = None;\n-        loop {\n-            debug!(\"resolve_free_lifetime_ref \\\n-                    scope_data: {:?} scope: {:?} search_result: {:?}\",\n-                   scope_data, scope, search_result);\n+        let span = lifetime_refs[0].span;\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let error = loop {\n             match *scope {\n-                FnScope { fn_id, body_id, s } => {\n-                    scope_data = region::CallSiteScopeData {\n-                        fn_id: fn_id, body_id: body_id\n-                    };\n+                // Do not assign any resolution, it will be inferred.\n+                Scope::Body { .. } => return,\n+\n+                Scope::Root => break None,\n+\n+                Scope::Binder { s, .. } => {\n+                    late_depth += 1;\n                     scope = s;\n                 }\n \n-                RootScope => {\n-                    break;\n+                Scope::Elision { ref elide, .. } => {\n+                    let lifetime = match *elide {\n+                        Elide::FreshLateAnon(ref counter) => {\n+                            for lifetime_ref in lifetime_refs {\n+                                let lifetime = Region::late_anon(counter).shifted(late_depth);\n+                                self.insert_lifetime(lifetime_ref, lifetime);\n+                            }\n+                            return;\n+                        }\n+                        Elide::Exact(l) => l.shifted(late_depth),\n+                        Elide::Static => {\n+                            if !self.sess.features.borrow().static_in_const {\n+                                self.sess\n+                                    .struct_span_err(span,\n+                                                     \"this needs a `'static` lifetime or the \\\n+                                                      `static_in_const` feature, see #35897\")\n+                                    .emit();\n+                            }\n+                            Region::Static\n+                        }\n+                        Elide::Error(ref e) => break Some(e)\n+                    };\n+                    for lifetime_ref in lifetime_refs {\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    return;\n                 }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n-                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n-                    if search_result.is_some() {\n-                        break;\n-                    }\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n                     scope = s;\n                 }\n             }\n-        }\n+        };\n \n-        match search_result {\n-            Some((_depth, lifetime)) => {\n-                let def = DefFreeRegion(scope_data, lifetime.id);\n-                self.insert_lifetime(lifetime_ref, def);\n+        let mut err = struct_span_err!(self.sess, span, E0106,\n+            \"missing lifetime specifier{}\",\n+            if lifetime_refs.len() > 1 { \"s\" } else { \"\" });\n+        let msg = if lifetime_refs.len() > 1 {\n+            format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n+        } else {\n+            format!(\"expected lifetime parameter\")\n+        };\n+        err.span_label(span, &msg);\n+\n+        if let Some(params) = error {\n+            if lifetime_refs.len() == 1 {\n+                self.report_elision_failure(&mut err, params);\n             }\n+        }\n+        err.emit();\n+    }\n \n-            None => {\n-                self.unresolved_lifetime_ref(lifetime_ref);\n+    fn report_elision_failure(&mut self,\n+                              db: &mut DiagnosticBuilder,\n+                              params: &[ElisionFailureInfo]) {\n+        let mut m = String::new();\n+        let len = params.len();\n+\n+        let elided_params: Vec<_> = params.iter().cloned()\n+                                          .filter(|info| info.lifetime_count > 0)\n+                                          .collect();\n+\n+        let elided_len = elided_params.len();\n+\n+        for (i, info) in elided_params.into_iter().enumerate() {\n+            let ElisionFailureInfo {\n+                parent, index, lifetime_count: n, have_bound_regions\n+            } = info;\n+\n+            let help_name = if let Some(body) = parent {\n+                let arg = &self.hir_map.body(body).arguments[index];\n+                format!(\"`{}`\", self.hir_map.node_to_pretty_string(arg.pat.id))\n+            } else {\n+                format!(\"argument {}\", index + 1)\n+            };\n+\n+            m.push_str(&(if n == 1 {\n+                help_name\n+            } else {\n+                format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n+                        if have_bound_regions { \"free \" } else { \"\" } )\n+            })[..]);\n+\n+            if elided_len == 2 && i == 0 {\n+                m.push_str(\" or \");\n+            } else if i + 2 == elided_len {\n+                m.push_str(\", or \");\n+            } else if i != elided_len - 1 {\n+                m.push_str(\", \");\n             }\n+\n         }\n \n+        if len == 0 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   there is no value for it to be borrowed from\");\n+            help!(db,\n+                  \"consider giving it a 'static lifetime\");\n+        } else if elided_len == 0 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value with \\\n+                   an elided lifetime, but the lifetime cannot be derived from \\\n+                   the arguments\");\n+            help!(db,\n+                  \"consider giving it an explicit bounded or 'static \\\n+                   lifetime\");\n+        } else if elided_len == 1 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   the signature does not say which {} it is borrowed from\",\n+                  m);\n+        } else {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   the signature does not say whether it is borrowed from {}\",\n+                  m);\n+        }\n     }\n \n-    fn unresolved_lifetime_ref(&self, lifetime_ref: &hir::Lifetime) {\n-        struct_span_err!(self.sess, lifetime_ref.span, E0261,\n-            \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n-            .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n-            .emit();\n+    fn resolve_object_lifetime_default(&mut self, lifetime_ref: &hir::Lifetime) {\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let lifetime = loop {\n+            match *scope {\n+                Scope::Binder { s, .. } => {\n+                    late_depth += 1;\n+                    scope = s;\n+                }\n+\n+                Scope::Root |\n+                Scope::Elision { .. } => break Region::Static,\n+\n+                Scope::Body { .. } |\n+                Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n+\n+                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l\n+            }\n+        };\n+        self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &[hir::LifetimeDef]) {\n+    fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -770,7 +1475,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: Scope,\n+                                        mut old_scope: ScopeRef,\n                                         lifetime: &hir::Lifetime)\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n@@ -786,21 +1491,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         loop {\n             match *old_scope {\n-                FnScope { s, .. } => {\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n                     old_scope = s;\n                 }\n \n-                RootScope => {\n+                Scope::Root => {\n                     return;\n                 }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n-                    if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n+                Scope::Binder { ref lifetimes, s } => {\n+                    if let Some(&def) = lifetimes.get(&lifetime.name) {\n                         signal_shadowing_problem(\n                             self.sess,\n                             lifetime.name,\n-                            original_lifetime(&lifetime_def),\n+                            original_lifetime(self.hir_map.span(def.id().unwrap())),\n                             shadower_lifetime(&lifetime));\n                         return;\n                     }\n@@ -813,7 +1519,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     fn insert_lifetime(&mut self,\n                        lifetime_ref: &hir::Lifetime,\n-                       def: DefRegion) {\n+                       def: Region) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n             span_bug!(lifetime_ref.span,\n                       \"lifetime reference not renumbered, \\\n@@ -828,17 +1534,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n-                    lifetime_ref: &hir::Lifetime)\n-                    -> Option<(u32, &'a hir::Lifetime)> {\n-    for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n-        if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i as u32, &lifetime_decl.lifetime));\n-        }\n-    }\n-    return None;\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n /// Detects late-bound lifetimes and inserts them into"}, {"sha": "702f3681a020cc1a656ca63e134fabf55fac1eb0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -592,53 +592,33 @@ pub enum IntVarValue {\n     UintType(ast::UintTy),\n }\n \n-/// Default region to use for the bound of objects that are\n-/// supplied as the value for this type parameter. This is derived\n-/// from `T:'a` annotations appearing in the type definition.  If\n-/// this is `None`, then the default is inherited from the\n-/// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum ObjectLifetimeDefault<'tcx> {\n-    /// Require an explicit annotation. Occurs when multiple\n-    /// `T:'a` constraints are found.\n-    Ambiguous,\n-\n-    /// Use the base default, typically 'static, but in a fn body it is a fresh variable\n-    BaseDefault,\n-\n-    /// Use the given region as the default.\n-    Specific(&'tcx Region),\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n-    pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `T`, asserts data behind the parameter\n     /// `T` won't be accessed during the parent type's `Drop` impl.\n     pub pure_wrt_drop: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct RegionParameterDef<'tcx> {\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub struct RegionParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub bounds: Vec<&'tcx ty::Region>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `'a`, asserts data of lifetime `'a`\n     /// won't be accessed during the parent type's `Drop` impl.\n     pub pure_wrt_drop: bool,\n }\n \n-impl<'tcx> RegionParameterDef<'tcx> {\n+impl RegionParameterDef {\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n             index: self.index,\n@@ -659,7 +639,7 @@ pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n     pub parent_types: u32,\n-    pub regions: Vec<RegionParameterDef<'tcx>>,\n+    pub regions: Vec<RegionParameterDef>,\n     pub types: Vec<TypeParameterDef<'tcx>>,\n     pub has_self: bool,\n }\n@@ -677,7 +657,7 @@ impl<'tcx> Generics<'tcx> {\n         self.parent_count() + self.own_count()\n     }\n \n-    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef<'tcx> {\n+    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef {\n         &self.regions[param.index as usize - self.has_self as usize]\n     }\n "}, {"sha": "06ba1b2a1fafc74a47abf190a8e974bd89e42bd5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -353,7 +353,7 @@ macro_rules! CopyImpls {\n     }\n }\n \n-CopyImpls! { (), hir::Unsafety, abi::Abi }\n+CopyImpls! { (), hir::Unsafety, abi::Abi, ty::RegionParameterDef }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n@@ -726,52 +726,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             index: self.index,\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n-            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n             pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.default.visit_with(visitor) ||\n-            self.object_lifetime_default.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                ty::ObjectLifetimeDefault::Ambiguous,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                ty::ObjectLifetimeDefault::BaseDefault,\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Specific(r) => r.visit_with(visitor),\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::RegionParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            index: self.index,\n-            bounds: self.bounds.fold_with(folder),\n-            pure_wrt_drop: self.pure_wrt_drop,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.bounds.visit_with(visitor)\n+        self.default.visit_with(visitor)\n     }\n }\n "}, {"sha": "74e27f84fddc24868db13580a413298ee7db1d4e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -336,13 +336,12 @@ impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::RegionParameterDef<'tcx> {\n+impl fmt::Debug for ty::RegionParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {:?}, {}, {:?})\",\n+        write!(f, \"RegionParameterDef({}, {:?}, {})\",\n                self.name,\n                self.def_id,\n-               self.index,\n-               self.bounds)\n+               self.index)\n     }\n }\n \n@@ -523,16 +522,6 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n-            ty::ObjectLifetimeDefault::BaseDefault => write!(f, \"BaseDefault\"),\n-            ty::ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n-        }\n-    }\n-}\n-\n impl fmt::Display for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {"}, {"sha": "46179b31d5cb45bc2c212baad7a898355109e9e0", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -939,12 +939,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n     fn suggest_mut_for_immutable(&self, pty: &hir::Ty) -> Option<String> {\n         // Check wether the argument is an immutable reference\n-        if let hir::TyRptr(opt_lifetime, hir::MutTy {\n+        if let hir::TyRptr(lifetime, hir::MutTy {\n             mutbl: hir::Mutability::MutImmutable,\n             ref ty\n         }) = pty.node {\n             // Account for existing lifetimes when generating the message\n-            if let Some(lifetime) = opt_lifetime {\n+            if !lifetime.is_elided() {\n                 if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(ty.span) {\n                     if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n                         .span_to_snippet(lifetime.span) {"}, {"sha": "c7512f2971b33990269ddf68a317f637b6b45eb4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -828,7 +828,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_ty_param_bound(self, bounds)\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: &'tcx TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n         SawPolyTraitRef.hash(self.st);\n         m.hash(self.st);"}, {"sha": "05ba262ef90c08eae406ba8ebe6f3b6642cb3afc", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -377,8 +377,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Def::Const(..) = path.def {\n+            if let Def::Const(..) = path.def {\n+                if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n                                                           path.segments[0].name,"}, {"sha": "39581a46960887069faecd871888335f49a89c95", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternC\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -110,6 +111,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_generics(def.index, tcx)\n     }\n \n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize) {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).generics_own_param_counts(def.index)\n+    }\n+\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).generics_object_lifetime_defaults(def.index)\n+    }\n+\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));"}, {"sha": "dd44ef202dc2733bcf7185dae4a2dd968c7f4dd2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -20,6 +20,7 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -598,7 +599,26 @@ impl<'a, 'tcx> CrateMetadata {\n                         item_id: DefIndex,\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                         -> ty::Generics<'tcx> {\n-        self.entry(item_id).generics.unwrap().decode((self, tcx))\n+        let g = self.entry(item_id).generics.unwrap().decode(self);\n+        ty::Generics {\n+            parent: g.parent,\n+            parent_regions: g.parent_regions,\n+            parent_types: g.parent_types,\n+            regions: g.regions.decode((self, tcx)).collect(),\n+            types: g.types.decode((self, tcx)).collect(),\n+            has_self: g.has_self,\n+        }\n+    }\n+\n+    pub fn generics_own_param_counts(&self, item_id: DefIndex) -> (usize, usize) {\n+        let g = self.entry(item_id).generics.unwrap().decode(self);\n+        (g.regions.len, g.types.len)\n+    }\n+\n+    pub fn generics_object_lifetime_defaults(&self, item_id: DefIndex)\n+                                             -> Vec<ObjectLifetimeDefault> {\n+        self.entry(item_id).generics.unwrap().decode(self)\n+                           .object_lifetime_defaults.decode(self).collect()\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {"}, {"sha": "028555d1df848c9e2346f8532674a806d1f3f716", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -417,9 +417,26 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n+    fn encode_generics(&mut self, def_id: DefId) -> Lazy<Generics<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(tcx.item_generics(def_id))\n+        let g = tcx.item_generics(def_id);\n+        let regions = self.lazy_seq_ref(&g.regions);\n+        let types = self.lazy_seq_ref(&g.types);\n+        let mut object_lifetime_defaults = LazySeq::empty();\n+        if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+            if let Some(o) = tcx.named_region_map.object_lifetime_defaults.get(&id) {\n+                object_lifetime_defaults = self.lazy_seq_ref(o);\n+            }\n+        }\n+        self.lazy(&Generics {\n+            parent: g.parent,\n+            parent_regions: g.parent_regions,\n+            parent_types: g.parent_types,\n+            regions: regions,\n+            types: types,\n+            has_self: g.has_self,\n+            object_lifetime_defaults: object_lifetime_defaults,\n+        })\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {"}, {"sha": "d9c639f2bc573dbc4d853e32b62d8c27fb165730", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc_back::PanicStrategy;\n@@ -213,7 +214,7 @@ pub struct Entry<'tcx> {\n     pub ty: Option<Lazy<Ty<'tcx>>>,\n     pub inherent_impls: LazySeq<DefIndex>,\n     pub variances: LazySeq<ty::Variance>,\n-    pub generics: Option<Lazy<ty::Generics<'tcx>>>,\n+    pub generics: Option<Lazy<Generics<'tcx>>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n@@ -247,6 +248,20 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer),\n }\n \n+/// A copy of `ty::Generics` which allows lazy decoding of\n+/// `regions` and `types` (e.g. knowing the number of type\n+/// and lifetime parameters before `TyCtxt` is created).\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Generics<'tcx> {\n+    pub parent: Option<DefId>,\n+    pub parent_regions: u32,\n+    pub parent_types: u32,\n+    pub regions: LazySeq<ty::RegionParameterDef>,\n+    pub types: LazySeq<ty::TypeParameterDef<'tcx>>,\n+    pub has_self: bool,\n+    pub object_lifetime_defaults: LazySeq<ObjectLifetimeDefault>,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export>,"}, {"sha": "0933fdfd357cd7e82cccce429b23f57b39a2a7a4", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -144,6 +144,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n             }\n             TyKind::TraitObject(ref bounds) => {\n+                let mut any_lifetime_bounds = false;\n+                for bound in bounds {\n+                    if let RegionTyParamBound(ref lifetime) = *bound {\n+                        if any_lifetime_bounds {\n+                            span_err!(self.session, lifetime.span, E0226,\n+                                      \"only a single explicit lifetime bound is permitted\");\n+                            break;\n+                        }\n+                        any_lifetime_bounds = true;\n+                    }\n+                }\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n             TyKind::ImplTrait(ref bounds) => {"}, {"sha": "ef871959176af088e534eda9b70c54b451c30392", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -244,6 +244,7 @@ match 5u32 {\n }\n \n register_diagnostics! {\n+    E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target\n     E0561, // patterns aren't allowed in function pointer types\n     E0571, // `break` with a value in a non-`loop`-loop"}, {"sha": "56de539cbfe99d5031073e362277b49a68e650a8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 194, "deletions": 604, "changes": 798, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -10,7 +10,7 @@\n \n //! Conversion from AST representation of types to the ty.rs\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n-//! is parameterized by an instance of `AstConv` and a `RegionScope`.\n+//! is parameterized by an instance of `AstConv`.\n //!\n //! The parameterization of `ast_ty_to_ty()` is because it behaves\n //! somewhat differently during the collect and check phases,\n@@ -22,31 +22,6 @@\n //! an error).  In the check phase, when the FnCtxt is used as the\n //! `AstConv`, `get_item_type()` just looks up the item type in\n //! `tcx.types` (using `TyCtxt::item_type`).\n-//!\n-//! The `RegionScope` trait controls what happens when the user does\n-//! not specify a region in some location where a region is required\n-//! (e.g., if the user writes `&Foo` as a type rather than `&'a Foo`).\n-//! See the `rscope` module for more details.\n-//!\n-//! Unlike the `AstConv` trait, the region scope can change as we descend\n-//! the type.  This is to accommodate the fact that (a) fn types are binding\n-//! scopes and (b) the default region may change.  To understand case (a),\n-//! consider something like:\n-//!\n-//!   type foo = { x: &a.int, y: |&a.int| }\n-//!\n-//! The type of `x` is an error because there is no region `a` in scope.\n-//! In the type of `y`, however, region `a` is considered a bound region\n-//! as it does not already appear in scope.\n-//!\n-//! Case (b) says that if you have a type:\n-//!   type foo<'a> = ...;\n-//!   type bar = fn(&foo, &a.foo)\n-//! The fully expanded version of type bar is:\n-//!   type bar = fn(&'foo &, &a.foo<'a>)\n-//! Note that the self region for the `foo` defaulted to `&` in the first\n-//! case but `&a` in the second.  Basically, defaults that appear inside\n-//! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -61,10 +36,6 @@ use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n-use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n-             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n-             ElisionFailureInfo, ElidedLifetime};\n-use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n@@ -74,7 +45,6 @@ use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -111,6 +81,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// See ParameterEnvironment::free_substs for more information.\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n \n+    /// What lifetime should we use when a lifetime is omitted (and not elided)?\n+    fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region>;\n+\n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n@@ -161,171 +135,71 @@ struct ConvertedBinding<'tcx> {\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n \n-pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            lifetime: &hir::Lifetime)\n-                                            -> &'tcx ty::Region {\n-    let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n-        None => {\n-            // should have been recorded by the `resolve_lifetime` pass\n-            span_bug!(lifetime.span, \"unresolved lifetime\");\n-        }\n+impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n+    pub fn ast_region_to_region(&self,\n+        lifetime: &hir::Lifetime,\n+        def: Option<&ty::RegionParameterDef>)\n+        -> &'tcx ty::Region\n+    {\n+        let tcx = self.tcx();\n+        let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n+            Some(&rl::Region::Static) => {\n+                tcx.mk_region(ty::ReStatic)\n+            }\n \n-        Some(&rl::DefStaticRegion) => {\n-            ty::ReStatic\n-        }\n+            Some(&rl::Region::LateBound(debruijn, id)) => {\n+                // If this region is declared on a function, it will have\n+                // an entry in `late_bound`, but if it comes from\n+                // `for<'a>` in some type or something, it won't\n+                // necessarily have one. In that case though, we won't be\n+                // changed from late to early bound, so we can just\n+                // substitute false.\n+                let issue_32330 = tcx.named_region_map\n+                                     .late_bound\n+                                     .get(&id)\n+                                     .cloned()\n+                                     .unwrap_or(ty::Issue32330::WontChange);\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReLateBound(debruijn,\n+                    ty::BrNamed(tcx.hir.local_def_id(id), name, issue_32330)))\n+            }\n \n-        Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            // If this region is declared on a function, it will have\n-            // an entry in `late_bound`, but if it comes from\n-            // `for<'a>` in some type or something, it won't\n-            // necessarily have one. In that case though, we won't be\n-            // changed from late to early bound, so we can just\n-            // substitute false.\n-            let issue_32330 = tcx.named_region_map\n-                                 .late_bound\n-                                 .get(&id)\n-                                 .cloned()\n-                                 .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReLateBound(debruijn, ty::BrNamed(tcx.hir.local_def_id(id),\n-                                                  lifetime.name,\n-                                                  issue_32330))\n-        }\n+            Some(&rl::Region::LateBoundAnon(debruijn, index)) => {\n+                tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n+            }\n \n-        Some(&rl::DefEarlyBoundRegion(index, _)) => {\n-            ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                index: index,\n-                name: lifetime.name\n-            })\n-        }\n+            Some(&rl::Region::EarlyBound(index, id)) => {\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    index: index,\n+                    name: name\n+                }))\n+            }\n \n-        Some(&rl::DefFreeRegion(scope, id)) => {\n-            // As in DefLateBoundRegion above, could be missing for some late-bound\n-            // regions, but also for early-bound regions.\n-            let issue_32330 = tcx.named_region_map\n-                                 .late_bound\n-                                 .get(&id)\n-                                 .cloned()\n-                                 .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReFree(ty::FreeRegion {\n+            Some(&rl::Region::Free(scope, id)) => {\n+                // As in Region::LateBound above, could be missing for some late-bound\n+                // regions, but also for early-bound regions.\n+                let issue_32330 = tcx.named_region_map\n+                                     .late_bound\n+                                     .get(&id)\n+                                     .cloned()\n+                                     .unwrap_or(ty::Issue32330::WontChange);\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope: scope.to_code_extent(&tcx.region_maps),\n-                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id),\n-                                              lifetime.name,\n-                                              issue_32330)\n-            })\n-\n-                // (*) -- not late-bound, won't change\n-        }\n-    };\n-\n-    debug!(\"ast_region_to_region(lifetime={:?} id={}) yields {:?}\",\n-           lifetime,\n-           lifetime.id,\n-           r);\n+                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name, issue_32330)\n+                }))\n \n-    tcx.mk_region(r)\n-}\n-\n-fn report_elision_failure(\n-    tcx: TyCtxt,\n-    db: &mut DiagnosticBuilder,\n-    params: Vec<ElisionFailureInfo>)\n-{\n-    let mut m = String::new();\n-    let len = params.len();\n-\n-    let elided_params: Vec<_> = params.into_iter()\n-                                       .filter(|info| info.lifetime_count > 0)\n-                                       .collect();\n-\n-    let elided_len = elided_params.len();\n-\n-    for (i, info) in elided_params.into_iter().enumerate() {\n-        let ElisionFailureInfo {\n-            parent, index, lifetime_count: n, have_bound_regions\n-        } = info;\n-\n-        let help_name = if let Some(body) = parent {\n-            let arg = &tcx.hir.body(body).arguments[index];\n-            format!(\"`{}`\", tcx.hir.node_to_pretty_string(arg.pat.id))\n-        } else {\n-            format!(\"argument {}\", index + 1)\n-        };\n-\n-        m.push_str(&(if n == 1 {\n-            help_name\n-        } else {\n-            format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n-                    if have_bound_regions { \"free \" } else { \"\" } )\n-        })[..]);\n-\n-        if elided_len == 2 && i == 0 {\n-            m.push_str(\" or \");\n-        } else if i + 2 == elided_len {\n-            m.push_str(\", or \");\n-        } else if i != elided_len - 1 {\n-            m.push_str(\", \");\n-        }\n-\n-    }\n-\n-    if len == 0 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    there is no value for it to be borrowed from\");\n-        help!(db,\n-                   \"consider giving it a 'static lifetime\");\n-    } else if elided_len == 0 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value with \\\n-                    an elided lifetime, but the lifetime cannot be derived from \\\n-                    the arguments\");\n-        help!(db,\n-                   \"consider giving it an explicit bounded or 'static \\\n-                    lifetime\");\n-    } else if elided_len == 1 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    the signature does not say which {} it is borrowed from\",\n-                   m);\n-    } else {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    the signature does not say whether it is borrowed from {}\",\n-                   m);\n-    }\n-}\n-\n-impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n-    pub fn opt_ast_region_to_region(&self,\n-        rscope: &RegionScope,\n-        default_span: Span,\n-        opt_lifetime: &Option<hir::Lifetime>) -> &'tcx ty::Region\n-    {\n-        let r = match *opt_lifetime {\n-            Some(ref lifetime) => {\n-                ast_region_to_region(self.tcx(), lifetime)\n+                    // (*) -- not late-bound, won't change\n             }\n \n-            None => self.tcx().mk_region(match rscope.anon_regions(default_span, 1) {\n-                Ok(rs) => rs[0],\n-                Err(params) => {\n-                    let ampersand_span = Span { hi: default_span.lo, ..default_span};\n-\n-                    let mut err = struct_span_err!(self.tcx().sess, ampersand_span, E0106,\n-                                                 \"missing lifetime specifier\");\n-                    err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n-\n-                    if let Some(params) = params {\n-                        report_elision_failure(self.tcx(), &mut err, params);\n-                    }\n-                    err.emit();\n-                    ty::ReStatic\n-                }\n-            })\n+            None => {\n+                self.re_infer(lifetime.span, def).expect(\"unelided lifetime in signature\")\n+            }\n         };\n \n-        debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n-                opt_lifetime,\n+        debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\",\n+                lifetime,\n                 r);\n \n         r\n@@ -334,7 +208,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n     /// returns an appropriate set of substitutions for this particular reference to `I`.\n     pub fn ast_path_substs_for_ty(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         def_id: DefId,\n         item_segment: &hir::PathSegment)\n@@ -359,8 +232,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_path(rscope,\n-                                            span,\n+            self.create_substs_for_ast_path(span,\n                                             def_id,\n                                             &item_segment.parameters,\n                                             None);\n@@ -376,7 +248,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n     fn create_substs_for_ast_path(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n@@ -409,23 +280,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n-        let regions = if expected_num_region_params == supplied_num_region_params {\n-            lifetimes.iter().map(|l| *ast_region_to_region(tcx, l)).collect()\n-        } else {\n-            let anon_regions =\n-                rscope.anon_regions(span, expected_num_region_params);\n-\n-            if supplied_num_region_params != 0 || anon_regions.is_err() {\n-                report_lifetime_number_error(tcx, span,\n-                                             supplied_num_region_params,\n-                                             expected_num_region_params);\n-            }\n-\n-            match anon_regions {\n-                Ok(anon_regions) => anon_regions,\n-                Err(_) => (0..expected_num_region_params).map(|_| ty::ReStatic).collect()\n-            }\n-        };\n+        if expected_num_region_params != supplied_num_region_params {\n+            report_lifetime_number_error(tcx, span,\n+                                         supplied_num_region_params,\n+                                         expected_num_region_params);\n+        }\n \n         // If a self-type was declared, one should be provided.\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n@@ -452,7 +311,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            tcx.mk_region(regions[i])\n+            if let Some(lifetime) = lifetimes.get(i) {\n+                self.ast_region_to_region(lifetime, Some(def))\n+            } else {\n+                tcx.mk_region(ty::ReStatic)\n+            }\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -466,12 +329,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // A provided type parameter.\n                 match *parameters {\n                     hir::AngleBracketedParameters(ref data) => {\n-                        self.ast_ty_arg_to_ty(rscope, Some(def), substs, &data.types[i])\n+                        self.ast_ty_to_ty(&data.types[i])\n                     }\n                     hir::ParenthesizedParameters(ref data) => {\n                         assert_eq!(i, 0);\n-                        let (ty, assoc) =\n-                            self.convert_parenthesized_parameters(rscope, substs, data);\n+                        let (ty, assoc) = self.convert_parenthesized_parameters(data);\n                         output_assoc_binding = Some(assoc);\n                         ty\n                     }\n@@ -516,7 +378,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 data.bindings.iter().map(|b| {\n                     ConvertedBinding {\n                         item_name: b.name,\n-                        ty: self.ast_ty_to_ty(rscope, &b.ty),\n+                        ty: self.ast_ty_to_ty(&b.ty),\n                         span: b.span\n                     }\n                 }).collect()\n@@ -525,7 +387,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 vec![output_assoc_binding.unwrap_or_else(|| {\n                     // This is an error condition, but we should\n                     // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(rscope, substs, data).1\n+                    self.convert_parenthesized_parameters(data).1\n                 })]\n             }\n         };\n@@ -536,92 +398,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (substs, assoc_bindings)\n     }\n \n-    /// Returns the appropriate lifetime to use for any output lifetimes\n-    /// (if one exists) and a vector of the (pattern, number of lifetimes)\n-    /// corresponding to each input type/pattern.\n-    fn find_implied_output_region<I>(&self,\n-                                     input_tys: &[Ty<'tcx>],\n-                                     parent: Option<hir::BodyId>,\n-                                     input_indices: I) -> ElidedLifetime\n-        where I: Iterator<Item=usize>\n-    {\n-        let tcx = self.tcx();\n-        let mut lifetimes_for_params = Vec::with_capacity(input_tys.len());\n-        let mut possible_implied_output_region = None;\n-        let mut lifetimes = 0;\n-\n-        for (input_type, index) in input_tys.iter().zip(input_indices) {\n-            let mut regions = FxHashSet();\n-            let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n-\n-            debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n-                    have_bound_regions={:?}\", &regions, input_type, have_bound_regions);\n-\n-            lifetimes += regions.len();\n-\n-            if lifetimes == 1 && regions.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = regions.iter().cloned().next();\n-            }\n-\n-            lifetimes_for_params.push(ElisionFailureInfo {\n-                parent: parent,\n-                index: index,\n-                lifetime_count: regions.len(),\n-                have_bound_regions: have_bound_regions\n-            });\n-        }\n-\n-        if lifetimes == 1 {\n-            Ok(*possible_implied_output_region.unwrap())\n-        } else {\n-            Err(Some(lifetimes_for_params))\n-        }\n-    }\n-\n-    fn convert_ty_with_lifetime_elision(&self,\n-                                        elided_lifetime: ElidedLifetime,\n-                                        ty: &hir::Ty,\n-                                        anon_scope: Option<AnonTypeScope>)\n-                                        -> Ty<'tcx>\n-    {\n-        match elided_lifetime {\n-            Ok(implied_output_region) => {\n-                let rb = ElidableRscope::new(implied_output_region);\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n-            }\n-            Err(param_lifetimes) => {\n-                // All regions must be explicitly specified in the output\n-                // if the lifetime elision rules do not apply. This saves\n-                // the user from potentially-confusing errors.\n-                let rb = UnelidableRscope::new(param_lifetimes);\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n-            }\n-        }\n-    }\n-\n     fn convert_parenthesized_parameters(&self,\n-                                        rscope: &RegionScope,\n-                                        region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n-        let anon_scope = rscope.anon_type_scope();\n-        let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n+            self.ast_ty_to_ty(a_t)\n         }));\n-        let input_params = 0..inputs.len();\n-        let implied_output_region = self.find_implied_output_region(&inputs, None, input_params);\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                       &output_ty,\n-                                                       anon_scope),\n-                 output_ty.span)\n+                (self.ast_ty_to_ty(output_ty), output_ty.span)\n             }\n             None => {\n                 (self.tcx().mk_nil(), data.span)\n@@ -637,39 +424,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (self.tcx().mk_ty(ty::TyTuple(inputs)), output_binding)\n     }\n \n-    pub fn instantiate_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        ast_trait_ref: &hir::PolyTraitRef,\n-        self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-        -> ty::PolyTraitRef<'tcx>\n-    {\n-        let trait_ref = &ast_trait_ref.trait_ref;\n-        let trait_def_id = self.trait_def_id(trait_ref);\n-        self.ast_path_to_poly_trait_ref(rscope,\n-                                        trait_ref.path.span,\n-                                        trait_def_id,\n-                                        self_ty,\n-                                        trait_ref.ref_id,\n-                                        trait_ref.path.segments.last().unwrap(),\n-                                        poly_projections)\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the def_id for the defining trait.\n     /// Fails if the type is a type other than a trait type.\n     ///\n     /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(&self,\n-        rscope: &RegionScope,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n-        self.ast_path_to_mono_trait_ref(rscope,\n-                                        trait_ref.path.span,\n+        self.ast_path_to_mono_trait_ref(trait_ref.path.span,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.path.segments.last().unwrap())\n@@ -689,57 +456,47 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn ast_path_to_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        trait_def_id: DefId,\n+    pub fn instantiate_poly_trait_ref(&self,\n+        ast_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        path_id: ast::NodeId,\n-        trait_segment: &hir::PathSegment,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n-        debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?})\", trait_segment);\n-        // The trait reference introduces a binding level here, so\n-        // we need to shift the `rscope`. It'd be nice if we could\n-        // do away with this rscope stuff and work this knowledge\n-        // into resolve_lifetimes, as we do with non-omitted\n-        // lifetimes. Oh well, not there yet.\n-        let shifted_rscope = &ShiftedRscope::new(rscope);\n+        let trait_ref = &ast_trait_ref.trait_ref;\n+        let trait_def_id = self.trait_def_id(trait_ref);\n+\n+        debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(shifted_rscope,\n-                                                 span,\n+            self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n                                                  trait_def_id,\n                                                  self_ty,\n-                                                 trait_segment);\n+                                                 trait_ref.path.segments.last().unwrap());\n         let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n         poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n-                self.ast_type_binding_to_poly_projection_predicate(path_id,\n+                self.ast_type_binding_to_poly_projection_predicate(trait_ref.ref_id,\n                                                                    poly_trait_ref,\n                                                                    binding);\n             predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n         }));\n \n-        debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?}, projections={:?}) -> {:?}\",\n-               trait_segment, poly_projections, poly_trait_ref);\n+        debug!(\"ast_path_to_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n+               trait_ref, poly_projections, poly_trait_ref);\n         poly_trait_ref\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n-                                  rscope: &RegionScope,\n                                   span: Span,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(rscope,\n-                                                 span,\n+            self.create_substs_for_ast_trait_ref(span,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -748,7 +505,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn create_substs_for_ast_trait_ref(&self,\n-                                       rscope: &RegionScope,\n                                        span: Span,\n                                        trait_def_id: DefId,\n                                        self_ty: Ty<'tcx>,\n@@ -792,8 +548,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         }\n \n-        self.create_substs_for_ast_path(rscope,\n-                                        span,\n+        self.create_substs_for_ast_path(span,\n                                         trait_def_id,\n                                         &trait_segment.parameters,\n                                         Some(self_ty))\n@@ -902,7 +657,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn ast_path_to_ty(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         did: DefId,\n         item_segment: &hir::PathSegment)\n@@ -916,8 +670,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        let substs = self.ast_path_substs_for_ty(rscope,\n-                                                 span,\n+        let substs = self.ast_path_substs_for_ty(span,\n                                                  did,\n                                                  item_segment);\n \n@@ -938,32 +691,27 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n-    fn trait_path_to_object_type(&self,\n-                                 rscope: &RegionScope,\n-                                 path_span: Span,\n-                                 trait_def_id: DefId,\n-                                 trait_path_ref_id: ast::NodeId,\n-                                 trait_segment: &hir::PathSegment,\n-                                 span: Span,\n-                                 partitioned_bounds: PartitionedBounds)\n-                                 -> Ty<'tcx> {\n+    fn conv_object_ty_poly_trait_ref(&self,\n+        span: Span,\n+        trait_bounds: &[hir::PolyTraitRef],\n+        lifetime: &hir::Lifetime)\n+        -> Ty<'tcx>\n+    {\n         let tcx = self.tcx();\n \n+        if trait_bounds.is_empty() {\n+            span_err!(tcx.sess, span, E0224,\n+                      \"at least one non-builtin trait is required for an object type\");\n+            return tcx.types.err;\n+        }\n+\n         let mut projection_bounds = vec![];\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n-        let principal = self.ast_path_to_poly_trait_ref(rscope,\n-                                                        path_span,\n-                                                        trait_def_id,\n+        let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n-                                                        trait_path_ref_id,\n-                                                        trait_segment,\n                                                         &mut projection_bounds);\n \n-        let PartitionedBounds { trait_bounds,\n-                                region_bounds } =\n-            partitioned_bounds;\n-\n-        let (auto_traits, trait_bounds) = split_auto_traits(tcx, trait_bounds);\n+        let (auto_traits, trait_bounds) = split_auto_traits(tcx, &trait_bounds[1..]);\n \n         if !trait_bounds.is_empty() {\n             let b = &trait_bounds[0];\n@@ -1038,23 +786,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         v.sort_by(|a, b| a.cmp(tcx, b));\n         let existential_predicates = ty::Binder(tcx.mk_existential_predicates(v.into_iter()));\n \n-        let region_bound = self.compute_object_lifetime_bound(span,\n-                                                              &region_bounds,\n-                                                              existential_predicates);\n \n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n-                tcx.mk_region(match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n+        // Explicitly specified region bound. Use that.\n+        let region_bound = if !lifetime.is_elided() {\n+            self.ast_region_to_region(lifetime, None)\n+        } else {\n+            self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n+                if tcx.named_region_map.defs.contains_key(&lifetime.id) {\n+                    self.ast_region_to_region(lifetime, None)\n+                } else {\n+                    self.re_infer(span, None).unwrap_or_else(|| {\n+                        span_err!(tcx.sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                })\n-            }\n+                        tcx.mk_region(ty::ReStatic)\n+                    })\n+                }\n+            })\n         };\n \n         debug!(\"region_bound: {:?}\", region_bound);\n@@ -1265,7 +1013,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn qpath_to_ty(&self,\n-                   rscope: &RegionScope,\n                    span: Span,\n                    opt_self_ty: Option<Ty<'tcx>>,\n                    trait_def_id: DefId,\n@@ -1290,8 +1037,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref = self.ast_path_to_mono_trait_ref(rscope,\n-                                                        span,\n+        let trait_ref = self.ast_path_to_mono_trait_ref(span,\n                                                         trait_def_id,\n                                                         self_ty,\n                                                         trait_segment);\n@@ -1301,41 +1047,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.projected_ty(span, trait_ref, item_segment.name)\n     }\n \n-    /// Convert a type supplied as value for a type argument from AST into our\n-    /// our internal representation. This is the same as `ast_ty_to_ty` but that\n-    /// it applies the object lifetime default.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// * `this`, `rscope`: the surrounding context\n-    /// * `def`: the type parameter being instantiated (if available)\n-    /// * `region_substs`: a partial substitution consisting of\n-    ///   only the region type parameters being supplied to this type.\n-    /// * `ast_ty`: the ast representation of the type being supplied\n-    fn ast_ty_arg_to_ty(&self,\n-                        rscope: &RegionScope,\n-                        def: Option<&ty::TypeParameterDef<'tcx>>,\n-                        region_substs: &[Kind<'tcx>],\n-                        ast_ty: &hir::Ty)\n-                        -> Ty<'tcx>\n-    {\n-        let tcx = self.tcx();\n-\n-        if let Some(def) = def {\n-            let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n-            let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n-            self.ast_ty_to_ty(rscope1, ast_ty)\n-        } else {\n-            self.ast_ty_to_ty(rscope, ast_ty)\n-        }\n-    }\n-\n     // Check a type Path and convert it to a Ty.\n     pub fn def_to_ty(&self,\n-                     rscope: &RegionScope,\n                      opt_self_ty: Option<Ty<'tcx>>,\n                      path: &hir::Path,\n-                     path_id: ast::NodeId,\n                      permit_variants: bool)\n                      -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -1345,33 +1060,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let span = path.span;\n         match path.def {\n-            Def::Trait(trait_def_id) => {\n-                // N.B. this case overlaps somewhat with\n-                // TyTraitObject, see that fn for details\n-\n-                assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-\n-                self.trait_path_to_object_type(rscope,\n-                                               span,\n-                                               trait_def_id,\n-                                               path_id,\n-                                               path.segments.last().unwrap(),\n-                                               span,\n-                                               partition_bounds(&[]))\n-            }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope, span, did, path.segments.last().unwrap())\n+                self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope,\n-                                    span,\n+                self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n@@ -1429,8 +1128,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::AssociatedTy(def_id) => {\n                 tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n-                self.qpath_to_ty(rscope,\n-                                 span,\n+                self.qpath_to_ty(span,\n                                  opt_self_ty,\n                                  trait_did,\n                                  &path.segments[path.segments.len()-2],\n@@ -1450,7 +1148,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n-    pub fn ast_ty_to_ty(&self, rscope: &RegionScope, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?})\",\n                ast_ty.id, ast_ty);\n \n@@ -1463,40 +1161,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let result_ty = match ast_ty.node {\n             hir::TySlice(ref ty) => {\n-                tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n+                tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n             hir::TyPtr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n-                    ty: self.ast_ty_to_ty(rscope, &mt.ty),\n+                    ty: self.ast_ty_to_ty(&mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n             hir::TyRptr(ref region, ref mt) => {\n-                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, region);\n+                let r = self.ast_region_to_region(region, None);\n                 debug!(\"TyRef r={:?}\", r);\n-                let rscope1 =\n-                    &ObjectLifetimeDefaultRscope::new(\n-                        rscope,\n-                        ty::ObjectLifetimeDefault::Specific(r));\n-                let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n+                let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n             hir::TyNever => {\n                 tcx.types.never\n             },\n             hir::TyTup(ref fields) => {\n-                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(rscope, &t)))\n+                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let anon_scope = rscope.anon_type_scope();\n-                let bare_fn_ty = self.ty_of_method_or_bare_fn(bf.unsafety,\n-                                                              bf.abi,\n-                                                              None,\n-                                                              &bf.decl,\n-                                                              None,\n-                                                              anon_scope,\n-                                                              anon_scope);\n+                let bare_fn_ty = self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1537,22 +1224,60 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n-            hir::TyTraitObject(ref bounds) => {\n-                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n \n+                // Figure out if we can allow an `impl Trait` here, by walking up\n+                // to a `fn` or inherent `impl` method, going only through `Ty`\n+                // or `TraitRef` nodes (as nothing else should be in types) and\n+                // ensuring that we reach the `fn`/method signature's return type.\n+                let mut node_id = ast_ty.id;\n+                let fn_decl = loop {\n+                    let parent = tcx.hir.get_parent_node(node_id);\n+                    match tcx.hir.get(parent) {\n+                        hir::map::NodeItem(&hir::Item {\n+                            node: hir::ItemFn(ref fn_decl, ..), ..\n+                        }) => break Some(fn_decl),\n+\n+                        hir::map::NodeImplItem(&hir::ImplItem {\n+                            node: hir::ImplItemKind::Method(ref sig, _), ..\n+                        }) => {\n+                            match tcx.hir.expect_item(tcx.hir.get_parent(parent)).node {\n+                                hir::ItemImpl(.., None, _, _) => {\n+                                    break Some(&sig.decl)\n+                                }\n+                                _ => break None\n+                            }\n+                        }\n+\n+                        hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => {}\n+\n+                        _ => break None\n+                    }\n+                    node_id = parent;\n+                };\n+                let allow = fn_decl.map_or(false, |fd| {\n+                    match fd.output {\n+                        hir::DefaultReturn(_) => false,\n+                        hir::Return(ref ty) => ty.id == node_id\n+                    }\n+                });\n+\n                 // Create the anonymized type.\n-                let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                if let Some(anon_scope) = rscope.anon_type_scope() {\n-                    let substs = anon_scope.fresh_substs(self, ast_ty.span);\n+                if allow {\n+                    let def_id = tcx.hir.local_def_id(ast_ty.id);\n+                    if let Err(ErrorReported) = self.get_generics(ast_ty.span, def_id) {\n+                        return tcx.types.err;\n+                    }\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n                     let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                     let bounds = compute_bounds(self, ty, bounds,\n                                                 SizedByDefault::Yes,\n-                                                Some(anon_scope),\n                                                 ast_ty.span);\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n@@ -1572,13 +1297,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                    self.ast_ty_to_ty(rscope, qself)\n+                    self.ast_ty_to_ty(qself)\n                 });\n-                self.def_to_ty(rscope, opt_self_ty, path, ast_ty.id, false)\n+                self.def_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n-                let ty = self.ast_ty_to_ty(rscope, qself);\n+                let ty = self.ast_ty_to_ty(qself);\n \n                 let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n@@ -1589,7 +1314,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyArray(ref ty, length) => {\n                 if let Ok(length) = eval_length(tcx.global_tcx(), length, \"array length\") {\n-                    tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n+                    tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n                 } else {\n                     self.tcx().types.err\n                 }\n@@ -1617,95 +1342,33 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     pub fn ty_of_arg(&self,\n-                     rscope: &RegionScope,\n                      ty: &hir::Ty,\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n             hir::TyInfer => self.ty_infer(ty.span),\n-            _ => self.ast_ty_to_ty(rscope, ty),\n+            _ => self.ast_ty_to_ty(ty),\n         }\n     }\n \n-    pub fn ty_of_method(&self,\n-                        sig: &hir::MethodSig,\n-                        opt_self_value_ty: Option<Ty<'tcx>>,\n-                        body: Option<hir::BodyId>,\n-                        anon_scope: Option<AnonTypeScope>)\n-                        -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(sig.unsafety,\n-                                     sig.abi,\n-                                     opt_self_value_ty,\n-                                     &sig.decl,\n-                                     body,\n-                                     None,\n-                                     anon_scope)\n-    }\n-\n-    pub fn ty_of_bare_fn(&self,\n-                         unsafety: hir::Unsafety,\n-                         abi: abi::Abi,\n-                         decl: &hir::FnDecl,\n-                         body: hir::BodyId,\n-                         anon_scope: Option<AnonTypeScope>)\n-                         -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, Some(body), None, anon_scope)\n-    }\n-\n-    fn ty_of_method_or_bare_fn(&self,\n-                               unsafety: hir::Unsafety,\n-                               abi: abi::Abi,\n-                               opt_self_value_ty: Option<Ty<'tcx>>,\n-                               decl: &hir::FnDecl,\n-                               body: Option<hir::BodyId>,\n-                               arg_anon_scope: Option<AnonTypeScope>,\n-                               ret_anon_scope: Option<AnonTypeScope>)\n-                               -> &'tcx ty::BareFnTy<'tcx>\n-    {\n-        debug!(\"ty_of_method_or_bare_fn\");\n-\n-        // New region names that appear inside of the arguments of the function\n-        // declaration are bound to that function type.\n-        let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n+    pub fn ty_of_fn(&self,\n+                    unsafety: hir::Unsafety,\n+                    abi: abi::Abi,\n+                    decl: &hir::FnDecl)\n+                    -> &'tcx ty::BareFnTy<'tcx> {\n+        debug!(\"ty_of_fn\");\n \n         let input_tys: Vec<Ty> =\n-            decl.inputs.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n-\n-        let has_self = opt_self_value_ty.is_some();\n-        let explicit_self = opt_self_value_ty.map(|self_value_ty| {\n-            ExplicitSelf::determine(self_value_ty, input_tys[0])\n-        });\n-\n-        let implied_output_region = match explicit_self {\n-            // `implied_output_region` is the region that will be assumed for any\n-            // region parameters in the return type. In accordance with the rules for\n-            // lifetime elision, we can determine it in two ways. First (determined\n-            // here), if self is by-reference, then the implied output region is the\n-            // region of the self parameter.\n-            Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n-\n-            // Second, if there was exactly one lifetime (either a substitution or a\n-            // reference) in the arguments, then any anonymous regions in the output\n-            // have that lifetime.\n-            _ => {\n-                let arg_tys = &input_tys[has_self as usize..];\n-                let arg_params = has_self as usize..input_tys.len();\n-                self.find_implied_output_region(arg_tys, body, arg_params)\n-\n-            }\n-        };\n+            decl.inputs.iter().map(|a| self.ty_of_arg(a, None)).collect();\n \n         let output_ty = match decl.output {\n-            hir::Return(ref output) =>\n-                self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                      &output,\n-                                                      ret_anon_scope),\n+            hir::Return(ref output) => self.ast_ty_to_ty(output),\n             hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n-        debug!(\"ty_of_method_or_bare_fn: output_ty={:?}\", output_ty);\n+        debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n         self.tcx().mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n@@ -1728,10 +1391,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_closure(expected_sig={:?})\",\n                expected_sig);\n \n-        // new region names that appear inside of the fn decl are bound to\n-        // that function type\n-        let rb = rscope::BindingRscope::new();\n-\n         let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n             let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n                 // no guarantee that the correct number of expected args\n@@ -1742,7 +1401,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     None\n                 }\n             });\n-            self.ty_of_arg(&rb, a, expected_arg_ty)\n+            self.ty_of_arg(a, expected_arg_ty)\n         });\n \n         let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n@@ -1758,7 +1417,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 expected_ret_ty.unwrap(),\n             _ if is_infer => self.ty_infer(decl.output.span()),\n             hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&rb, &output),\n+                self.ast_ty_to_ty(&output),\n             hir::DefaultReturn(..) => bug!(),\n         };\n \n@@ -1771,61 +1430,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn conv_object_ty_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        ast_bounds: &[hir::TyParamBound])\n-        -> Ty<'tcx>\n-    {\n-        let mut partitioned_bounds = partition_bounds(ast_bounds);\n-\n-        let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n-            partitioned_bounds.trait_bounds.remove(0)\n-        } else {\n-            span_err!(self.tcx().sess, span, E0224,\n-                      \"at least one non-builtin trait is required for an object type\");\n-            return self.tcx().types.err;\n-        };\n-\n-        let trait_ref = &trait_bound.trait_ref;\n-        let trait_def_id = self.trait_def_id(trait_ref);\n-        self.trait_path_to_object_type(rscope,\n-                                       trait_ref.path.span,\n-                                       trait_def_id,\n-                                       trait_ref.ref_id,\n-                                       trait_ref.path.segments.last().unwrap(),\n-                                       span,\n-                                       partitioned_bounds)\n-    }\n-\n     /// Given the bounds on an object, determines what single region bound (if any) we can\n     /// use to summarize this type. The basic idea is that we will use the bound the user\n     /// provided, if they provided one, and otherwise search the supertypes of trait bounds\n     /// for region bounds. It may be that we can derive no bound at all, in which case\n     /// we return `None`.\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n-        explicit_region_bounds: &[&hir::Lifetime],\n         existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-               existential_predicates={:?})\",\n-               explicit_region_bounds,\n+        debug!(\"compute_opt_region_bound(existential_predicates={:?})\",\n                existential_predicates);\n \n-        if explicit_region_bounds.len() > 1 {\n-            span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n-                \"only a single explicit lifetime bound is permitted\");\n-        }\n-\n-        if let Some(&r) = explicit_region_bounds.get(0) {\n-            // Explicitly specified region bound. Use that.\n-            return Some(ast_region_to_region(tcx, r));\n-        }\n-\n         if let Some(principal) = existential_predicates.principal() {\n             if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n                 return Some(tcx.mk_region(ty::ReStatic));\n@@ -1861,18 +1480,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n }\n \n-pub struct PartitionedBounds<'a> {\n-    pub trait_bounds: Vec<&'a hir::PolyTraitRef>,\n-    pub region_bounds: Vec<&'a hir::Lifetime>,\n-}\n-\n /// Divides a list of general trait bounds into two groups: builtin bounds (Sync/Send) and the\n /// remaining general trait bounds.\n fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         trait_bounds: Vec<&'b hir::PolyTraitRef>)\n+                                         trait_bounds: &'b [hir::PolyTraitRef])\n     -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n {\n-    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.into_iter().partition(|bound| {\n+    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.iter().partition(|bound| {\n         match bound.trait_ref.path.def {\n             Def::Trait(trait_did) => {\n                 // Checks whether `trait_did` refers to one of the builtin\n@@ -1909,30 +1523,6 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     (auto_traits, trait_bounds)\n }\n \n-/// Divides a list of bounds from the AST into two groups: general trait bounds and region bounds\n-pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(ast_bounds: &'b [hir::TyParamBound])\n-    -> PartitionedBounds<'b>\n-{\n-    let mut region_bounds = Vec::new();\n-    let mut trait_bounds = Vec::new();\n-    for ast_bound in ast_bounds {\n-        match *ast_bound {\n-            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                trait_bounds.push(b);\n-            }\n-            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n-            hir::RegionTyParamBound(ref l) => {\n-                region_bounds.push(l);\n-            }\n-        }\n-    }\n-\n-    PartitionedBounds {\n-        trait_bounds: trait_bounds,\n-        region_bounds: region_bounds,\n-    }\n-}\n-\n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                              ty_param_defs: &[ty::TypeParameterDef]) {\n     let accepted = ty_param_defs.len();"}, {"sha": "c2f32c2b52bbebbefbc1e452f855dffa67f0a118", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -80,7 +80,7 @@ pub use self::Expectation::*;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{AstConv, ast_region_to_region};\n+use astconv::AstConv;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n@@ -97,7 +97,6 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n-use rscope::{ElisionFailureInfo, RegionScope};\n use session::{Session, CompileResult};\n use CrateCtxt;\n use TypeAndSubsts;\n@@ -1410,6 +1409,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n+    fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region> {\n+        let v = match def {\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n+            None => infer::MiscVariable(span)\n+        };\n+        Some(self.next_region_var(v))\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n@@ -1450,30 +1458,6 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        // RFC #599 specifies that object lifetime defaults take\n-        // precedence over other defaults. But within a fn body we\n-        // don't have a *default* region, rather we use inference to\n-        // find the *correct* region, which is strictly more general\n-        // (and anyway, within a fn body the right region may not even\n-        // be something the user can write explicitly, since it might\n-        // be some expression).\n-        *self.next_region_var(infer::MiscVariable(span))\n-    }\n-\n-    fn anon_regions(&self, span: Span, count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        Ok((0..count).map(|_| {\n-            *self.next_region_var(infer::MiscVariable(span))\n-        }).collect())\n-    }\n-}\n-\n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n ///\n@@ -1830,7 +1814,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n-        let t = AstConv::ast_ty_to_ty(self, self, ast_t);\n+        let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n         t\n     }\n@@ -3974,7 +3958,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(ref maybe_qself, ref path) => {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::def_to_ty(self, self, opt_self_ty, path, node_id, true);\n+                let ty = AstConv::def_to_ty(self, opt_self_ty, path, true);\n                 (path.def, ty)\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -4406,10 +4390,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => &[]\n             };\n \n-            if let Some(ast_lifetime) = lifetimes.get(i) {\n-                ast_region_to_region(self.tcx, ast_lifetime)\n+            if let Some(lifetime) = lifetimes.get(i) {\n+                AstConv::ast_region_to_region(self, lifetime, Some(def))\n             } else {\n-                self.region_var_for_def(span, def)\n+                self.re_infer(span, Some(def)).unwrap()\n             }\n         }, |def, substs| {\n             let mut i = def.index as usize;"}, {"sha": "bbd0c8058151f2b6669efce9a17beb374c52330a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 188, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -57,7 +57,7 @@ There are some shortcomings in this design:\n \n */\n \n-use astconv::{AstConv, ast_region_to_region, Bounds, PartitionedBounds, partition_bounds};\n+use astconv::{AstConv, Bounds};\n use lint;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n@@ -68,10 +68,9 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n-use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeMap, FxHashMap};\n use CrateCtxt;\n \n use rustc_const_math::ConstInt;\n@@ -373,8 +372,8 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n }\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &hir::Ty) -> Ty<'tcx> {\n-        AstConv::ast_ty_to_ty(self, rs, ast_ty)\n+    fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+        AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n@@ -437,6 +436,11 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region> {\n+        None\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         struct_span_err!(\n             self.tcx().sess,\n@@ -626,7 +630,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            field: &hir::StructField,\n                            ty_f: &'tcx ty::FieldDef)\n {\n-    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n+    let tt = ccx.icx(struct_predicates).to_ty(&field.ty);\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.hir.local_def_id(field.id);\n@@ -636,30 +640,17 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            container: AssociatedItemContainer,\n                             id: ast::NodeId,\n                             sig: &hir::MethodSig,\n-                            untransformed_rcvr_ty: Ty<'tcx>,\n-                            body: Option<hir::BodyId>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n     let def_id = ccx.tcx.hir.local_def_id(id);\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n         ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n \n-    let anon_scope = match container {\n-        ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n-        TraitContainer(_) => None\n-    };\n-    let assoc_item = ccx.tcx.associated_item(def_id);\n-    let self_value_ty = if assoc_item.method_has_self_argument {\n-        Some(untransformed_rcvr_ty)\n-    } else {\n-        None\n-    };\n-    let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                    sig, self_value_ty, body, anon_scope);\n+    let fty = AstConv::ty_of_fn(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                sig.unsafety, sig.abi, &sig.decl);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.hir.span(id), def_id);\n@@ -765,7 +756,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n-                                                    &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     tcx.mk_self_type());\n \n@@ -787,12 +777,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&selfty);\n             tcx.item_types.borrow_mut().insert(def_id, selfty);\n \n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                    &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     selfty)\n             });\n@@ -858,8 +847,7 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n         hir::TraitItemKind::Const(ref ty, _) => {\n             let const_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n             generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&trait_predicates)\n-                        .to_ty(&ExplicitRscope, &ty);\n+            let ty = ccx.icx(&trait_predicates).to_ty(&ty);\n             tcx.item_types.borrow_mut().insert(const_def_id, ty);\n             convert_associated_const(ccx, TraitContainer(trait_def_id),\n                                      trait_item.id, ty);\n@@ -870,20 +858,14 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n             generics_of_def_id(ccx, type_def_id);\n \n             let typ = opt_ty.as_ref().map({\n-                |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n+                |ty| ccx.icx(&trait_predicates).to_ty(&ty)\n             });\n \n             convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n         }\n \n-        hir::TraitItemKind::Method(ref sig, ref method) => {\n-            let body = match *method {\n-                hir::TraitMethod::Required(_) => None,\n-                hir::TraitMethod::Provided(body) => Some(body)\n-            };\n-            convert_method(ccx, TraitContainer(trait_def_id),\n-                           trait_item.id, sig, tcx.mk_self_type(),\n-                           body, &trait_predicates);\n+        hir::TraitItemKind::Method(ref sig, _) => {\n+            convert_method(ccx, trait_item.id, sig, &trait_predicates);\n         }\n     }\n }\n@@ -896,14 +878,12 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n     let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n     let impl_predicates = tcx.item_predicates(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n-    let impl_self_ty = tcx.item_type(impl_def_id);\n \n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n             let const_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n             generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&impl_predicates)\n-                        .to_ty(&ExplicitRscope, &ty);\n+            let ty = ccx.icx(&impl_predicates).to_ty(&ty);\n             tcx.item_types.borrow_mut().insert(const_def_id, ty);\n             convert_associated_const(ccx, ImplContainer(impl_def_id),\n                                      impl_item.id, ty);\n@@ -918,15 +898,13 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n                           \"associated types are not allowed in inherent impls\");\n             }\n \n-            let typ = ccx.icx(&impl_predicates).to_ty(&ExplicitRscope, ty);\n+            let typ = ccx.icx(&impl_predicates).to_ty(ty);\n \n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n-        hir::ImplItemKind::Method(ref sig, body) => {\n-            convert_method(ccx, ImplContainer(impl_def_id),\n-                           impl_item.id, sig, impl_self_ty,\n-                           Some(body), &impl_predicates);\n+        hir::ImplItemKind::Method(ref sig, _) => {\n+            convert_method(ccx, impl_item.id, sig, &impl_predicates);\n         }\n     }\n }\n@@ -1197,7 +1175,6 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                                           self_param_ty,\n                                           bounds,\n                                           SizedByDefault::No,\n-                                          None,\n                                           item.span);\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n@@ -1334,7 +1311,6 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                         assoc_ty,\n                                         bounds,\n                                         SizedByDefault::Yes,\n-                                        None,\n                                         trait_item.span);\n \n             bounds.predicates(ccx.tcx, assoc_ty).into_iter()\n@@ -1429,7 +1405,6 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             def_id: tcx.hir.local_def_id(param_id),\n                             default_def_id: tcx.hir.local_def_id(parent),\n                             default: None,\n-                            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                             pure_wrt_drop: false,\n                         };\n                         tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n@@ -1471,9 +1446,6 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 name: l.lifetime.name,\n                 index: own_start + i as u32,\n                 def_id: tcx.hir.local_def_id(l.lifetime.id),\n-                bounds: l.bounds.iter().map(|l| {\n-                    ast_region_to_region(tcx, l)\n-                }).collect(),\n                 pure_wrt_drop: l.pure_wrt_drop,\n             }\n         }).collect::<Vec<_>>();\n@@ -1482,7 +1454,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let type_start = own_start + regions.len() as u32;\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n             let i = type_start + i as u32;\n-            get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n+            get_or_create_type_parameter_def(ccx, i, p, allow_defaults)\n         });\n         let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n \n@@ -1497,24 +1469,11 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     def_id: def_id,\n                     default_def_id: parent_def_id.unwrap(),\n                     default: None,\n-                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                     pure_wrt_drop: false,\n                }));\n             });\n         }\n \n-        // Debugging aid.\n-        if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n-            let object_lifetime_default_reprs: String =\n-                types.iter().map(|t| {\n-                    match t.object_lifetime_default {\n-                        ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n-                        d => format!(\"{:?}\", d),\n-                    }\n-                }).collect::<Vec<String>>().join(\",\");\n-            tcx.sess.span_err(tcx.hir.span(node_id), &object_lifetime_default_reprs);\n-        }\n-\n         tcx.alloc_generics(ty::Generics {\n             parent: parent_def_id,\n             parent_regions: parent_regions,\n@@ -1545,16 +1504,15 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&StaticRscope::new(&ccx.tcx), &t)\n+                        ccx.icx(&()).to_ty(&t)\n                     }\n-                    ItemFn(ref decl, unsafety, _, abi, ref generics, body) => {\n-                        let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                                          body, Some(AnonTypeScope::new(def_id)));\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                        let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n                     ItemTy(ref t, ref generics) => {\n-                        ccx.icx(generics).to_ty(&ExplicitRscope, &t)\n+                        ccx.icx(generics).to_ty(&t)\n                     }\n                     ItemEnum(ref ei, ref generics) => {\n                         let def = convert_enum_def(ccx, item, ei);\n@@ -1595,7 +1553,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             fn_decl, generics, abi)\n                     }\n                     ForeignItemStatic(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&ExplicitRscope, t)\n+                        ccx.icx(&()).to_ty(t)\n                     }\n                 }\n             }\n@@ -1765,7 +1723,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             name: param.lifetime.name\n         }));\n         for bound in &param.bounds {\n-            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let bound_region = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n             predicates.push(outlives.to_predicate());\n         }\n@@ -1781,7 +1739,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n-                                    None,\n                                     param.span);\n         predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n@@ -1792,7 +1749,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = AstConv::ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n-                                               &ExplicitRscope,\n                                                &bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n@@ -1803,7 +1759,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             let trait_ref =\n                                 AstConv::instantiate_poly_trait_ref(&ccx.icx(&(base_predicates,\n                                                                                ast_generics)),\n-                                                                    &ExplicitRscope,\n                                                                     poly_trait_ref,\n                                                                     ty,\n                                                                     &mut projections);\n@@ -1816,7 +1771,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(tcx, lifetime);\n+                            let region = AstConv::ast_region_to_region(&ccx.icx(&()),\n+                                                                       lifetime,\n+                                                                       None);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1825,9 +1782,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n \n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(tcx, &region_pred.lifetime);\n+                let r1 = AstConv::ast_region_to_region(&ccx.icx(&()), &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = ast_region_to_region(tcx, bound);\n+                    let r2 = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n@@ -1846,7 +1803,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                             ast_generics: &hir::Generics,\n                                              index: u32,\n                                              param: &hir::TyParam,\n                                              allow_defaults: bool)\n@@ -1859,11 +1815,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let default =\n-        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(&ExplicitRscope, def));\n-\n-    let object_lifetime_default =\n-        compute_object_lifetime_default(ccx, param.id,\n-                                        &param.bounds, &ast_generics.where_clause);\n+        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(def));\n \n     let parent = tcx.hir.get_parent(param.id);\n \n@@ -1884,7 +1836,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         def_id: ccx.tcx.hir.local_def_id(param.id),\n         default_def_id: ccx.tcx.hir.local_def_id(parent),\n         default: default,\n-        object_lifetime_default: object_lifetime_default,\n         pure_wrt_drop: param.pure_wrt_drop,\n     };\n \n@@ -1899,75 +1850,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     def\n }\n \n-/// Scan the bounds and where-clauses on a parameter to extract bounds\n-/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`.\n-/// This runs as part of computing the minimal type scheme, so we\n-/// intentionally avoid just asking astconv to convert all the where\n-/// clauses into a `ty::Predicate`. This is because that could induce\n-/// artificial cycles.\n-fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                            param_id: ast::NodeId,\n-                                            param_bounds: &[hir::TyParamBound],\n-                                            where_clause: &hir::WhereClause)\n-                                            -> ty::ObjectLifetimeDefault<'tcx>\n-{\n-    let inline_bounds = from_bounds(ccx, param_bounds);\n-    let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: FxHashSet<_> = inline_bounds.into_iter()\n-                                                .chain(where_bounds)\n-                                                .collect();\n-    return if all_bounds.len() > 1 {\n-        ty::ObjectLifetimeDefault::Ambiguous\n-    } else if all_bounds.len() == 0 {\n-        ty::ObjectLifetimeDefault::BaseDefault\n-    } else {\n-        ty::ObjectLifetimeDefault::Specific(\n-            all_bounds.into_iter().next().unwrap())\n-    };\n-\n-    fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                            bounds: &[hir::TyParamBound])\n-                            -> Vec<&'tcx ty::Region>\n-    {\n-        bounds.iter()\n-              .filter_map(|bound| {\n-                  match *bound {\n-                      hir::TraitTyParamBound(..) =>\n-                          None,\n-                      hir::RegionTyParamBound(ref lifetime) =>\n-                          Some(ast_region_to_region(ccx.tcx, lifetime)),\n-                  }\n-              })\n-              .collect()\n-    }\n-\n-    fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                param_id: ast::NodeId,\n-                                predicates: &[hir::WherePredicate])\n-                                -> Vec<&'tcx ty::Region>\n-    {\n-        predicates.iter()\n-                  .flat_map(|predicate| {\n-                      match *predicate {\n-                          hir::WherePredicate::BoundPredicate(ref data) => {\n-                              if data.bound_lifetimes.is_empty() &&\n-                                  is_param(ccx.tcx, &data.bounded_ty, param_id)\n-                              {\n-                                  from_bounds(ccx, &data.bounds).into_iter()\n-                              } else {\n-                                  Vec::new().into_iter()\n-                              }\n-                          }\n-                          hir::WherePredicate::RegionPredicate(..) |\n-                          hir::WherePredicate::EqPredicate(..) => {\n-                              Vec::new().into_iter()\n-                          }\n-                      }\n-                  })\n-                  .collect()\n-    }\n-}\n-\n pub enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n@@ -1977,28 +1859,33 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         param_ty: ty::Ty<'tcx>,\n                                         ast_bounds: &[hir::TyParamBound],\n                                         sized_by_default: SizedByDefault,\n-                                        anon_scope: Option<AnonTypeScope>,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n {\n-    let tcx = astconv.tcx();\n-    let PartitionedBounds {\n-        trait_bounds,\n-        region_bounds\n-    } = partition_bounds(&ast_bounds);\n+    let mut region_bounds = vec![];\n+    let mut trait_bounds = vec![];\n+    for ast_bound in ast_bounds {\n+        match *ast_bound {\n+            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n+                trait_bounds.push(b);\n+            }\n+            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n+            hir::RegionTyParamBound(ref l) => {\n+                region_bounds.push(l);\n+            }\n+        }\n+    }\n \n     let mut projection_bounds = vec![];\n \n-    let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        astconv.instantiate_poly_trait_ref(&rscope,\n-                                           bound,\n+        astconv.instantiate_poly_trait_ref(bound,\n                                            param_ty,\n                                            &mut projection_bounds)\n     }).collect();\n \n     let region_bounds = region_bounds.into_iter().map(|r| {\n-        ast_region_to_region(tcx, r)\n+        astconv.ast_region_to_region(r, None)\n     }).collect();\n \n     trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n@@ -2030,8 +1917,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match *bound {\n         hir::TraitTyParamBound(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n-                                                          tr,\n+            let pred = astconv.instantiate_poly_trait_ref(tr,\n                                                           param_ty,\n                                                           &mut projections);\n             projections.into_iter()\n@@ -2040,7 +1926,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                        .collect()\n         }\n         hir::RegionTyParamBound(ref lifetime) => {\n-            let region = ast_region_to_region(astconv.tcx(), lifetime);\n+            let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n             vec![ty::Predicate::TypeOutlives(pred)]\n         }\n@@ -2058,18 +1944,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     abi: abi::Abi)\n     -> Ty<'tcx>\n {\n-    let rb = BindingRscope::new();\n-    let input_tys = decl.inputs\n-                        .iter()\n-                        .map(|a| AstConv::ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n-                        .collect::<Vec<_>>();\n-\n-    let output = match decl.output {\n-        hir::Return(ref ty) =>\n-            AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty),\n-        hir::DefaultReturn(..) =>\n-            ccx.tcx.mk_nil(),\n-    };\n+    let fty = AstConv::ty_of_fn(&ccx.icx(ast_generics), hir::Unsafety::Unsafe, abi, decl);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n@@ -2085,27 +1960,23 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n                     .emit();\n             }\n         };\n-        for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n+        for (input, ty) in decl.inputs.iter().zip(*fty.sig.inputs().skip_binder()) {\n             check(&input, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&ty, output)\n+            check(&ty, *fty.sig.output().skip_binder())\n         }\n     }\n \n     let id = ccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.hir.span(id), def_id);\n-    ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n-        abi: abi,\n-        unsafety: hir::Unsafety::Unsafe,\n-        sig: ty::Binder(ccx.tcx.mk_fn_sig(input_tys.into_iter(), output, decl.variadic)),\n-    }))\n+    ccx.tcx.mk_fn_def(def_id, substs, fty)\n }\n \n-pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                        span: Span,\n-                                        def_id: DefId)\n-                                        -> &'tcx Substs<'tcx> {\n+fn mk_item_substs<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n+                        span: Span,\n+                        def_id: DefId)\n+                        -> &'tcx Substs<'tcx> {\n     let tcx = astconv.tcx();\n     // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n     if let Err(ErrorReported) = astconv.get_generics(span, def_id) {"}, {"sha": "c41d40b41e42ab53c8a9ca53a780e1766a8bfc82", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 70, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -1412,85 +1412,19 @@ fn main() {\n ```\n \"##,\n \n-E0106: r##\"\n-This error indicates that a lifetime is missing from a type. If it is an error\n-inside a function signature, the problem may be with failing to adhere to the\n-lifetime elision rules (see below).\n-\n-Here are some simple examples of where you'll run into this error:\n-\n-```compile_fail,E0106\n-struct Foo { x: &bool }        // error\n-struct Foo<'a> { x: &'a bool } // correct\n-\n-enum Bar { A(u8), B(&bool), }        // error\n-enum Bar<'a> { A(u8), B(&'a bool), } // correct\n-\n-type MyStr = &str;        // error\n-type MyStr<'a> = &'a str; // correct\n-```\n-\n-Lifetime elision is a special, limited kind of inference for lifetimes in\n-function signatures which allows you to leave out lifetimes in certain cases.\n-For more background on lifetime elision see [the book][book-le].\n-\n-The lifetime elision rules require that any function signature with an elided\n-output lifetime must either have\n-\n- - exactly one input lifetime\n- - or, multiple input lifetimes, but the function must also be a method with a\n-   `&self` or `&mut self` receiver\n-\n-In the first case, the output lifetime is inferred to be the same as the unique\n-input lifetime. In the second case, the lifetime is instead inferred to be the\n-same as the lifetime on `&self` or `&mut self`.\n-\n-Here are some examples of elision errors:\n-\n-```compile_fail,E0106\n-// error, no input lifetimes\n-fn foo() -> &str { }\n-\n-// error, `x` and `y` have distinct lifetimes inferred\n-fn bar(x: &str, y: &str) -> &str { }\n-\n-// error, `y`'s lifetime is inferred to be distinct from `x`'s\n-fn baz<'a>(x: &'a str, y: &str) -> &str { }\n-```\n-\n-[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n-\"##,\n-\n E0107: r##\"\n This error means that an incorrect number of lifetime parameters were provided\n-for a type (like a struct or enum) or trait.\n-\n-Some basic examples include:\n+for a type (like a struct or enum) or trait:\n \n ```compile_fail,E0107\n-struct Foo<'a>(&'a str);\n+struct Foo<'a, 'b>(&'a str, &'b str);\n enum Bar { A, B, C }\n \n struct Baz<'a> {\n-    foo: Foo,     // error: expected 1, found 0\n+    foo: Foo<'a>, // error: expected 2, found 1\n     bar: Bar<'a>, // error: expected 0, found 1\n }\n ```\n-\n-Here's an example that is currently an error, but may work in a future version\n-of Rust:\n-\n-```compile_fail,E0107\n-struct Foo<'a>(&'a str);\n-\n-trait Quux { }\n-impl Quux for Foo { } // error: expected 1, found 0\n-```\n-\n-Lifetime elision in implementation headers was part of the lifetime elision\n-RFC. It is, however, [currently unimplemented][iss15872].\n-\n-[iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n E0116: r##\"\n@@ -4162,7 +4096,6 @@ register_diagnostics! {\n //  E0222, // Error code E0045 (variadic function must have C calling\n            // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n-    E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n     E0231, // only named substitution parameters are allowed"}, {"sha": "4ed116b88f6d942622476e27fc0cbbf66c51cba1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -77,6 +77,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n+#![feature(loop_break_value)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -126,7 +127,6 @@ pub mod diagnostics;\n \n pub mod check;\n pub mod check_unused;\n-mod rscope;\n mod astconv;\n pub mod collect;\n mod constrained_type_params;"}, {"sha": "3f5e443a20a6854b575a7a57fdf197102483da43", "filename": "src/librustc_typeck/rscope.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -1,393 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty;\n-use rustc::ty::subst::Substs;\n-\n-use astconv::AstConv;\n-\n-use std::cell::Cell;\n-use syntax_pos::Span;\n-\n-#[derive(Clone)]\n-pub struct ElisionFailureInfo {\n-    /// Where we can find the argument pattern.\n-    pub parent: Option<hir::BodyId>,\n-    /// The index of the argument in the original definition.\n-    pub index: usize,\n-    pub lifetime_count: usize,\n-    pub have_bound_regions: bool\n-}\n-\n-pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n-\n-/// Defines strategies for handling regions that are omitted.  For\n-/// example, if one writes the type `&Foo`, then the lifetime of\n-/// this reference has been omitted. When converting this\n-/// type, the generic functions in astconv will invoke `anon_regions`\n-/// on the provided region-scope to decide how to translate this\n-/// omitted region.\n-///\n-/// It is not always legal to omit regions, therefore `anon_regions`\n-/// can return `Err(())` to indicate that this is not a scope in which\n-/// regions can legally be omitted.\n-pub trait RegionScope {\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>;\n-\n-    /// If an object omits any explicit lifetime bound, and none can\n-    /// be derived from the object traits, what should we use? If\n-    /// `None` is returned, an explicit annotation is required.\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;\n-\n-    /// The \"base\" default is the initial default for a scope. This is\n-    /// 'static except for in fn bodies, where it is a fresh inference\n-    /// variable. You shouldn't call this except for as part of\n-    /// computing `object_lifetime_default` (in particular, in legacy\n-    /// modes, it may not be relevant).\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n-\n-    /// If this scope allows anonymized types, return the generics in\n-    /// scope, that anonymized types will close over. For example,\n-    /// if you have a function like:\n-    ///\n-    ///     fn foo<'a, T>() -> impl Trait { ... }\n-    ///\n-    /// then, for the rscope that is used when handling the return type,\n-    /// `anon_type_scope()` would return a `Some(AnonTypeScope {...})`,\n-    /// on which `.fresh_substs(...)` can be used to obtain identity\n-    /// Substs for `'a` and `T`, to track them in `TyAnon`. This property\n-    /// is controlled by the region scope because it's fine-grained enough\n-    /// to allow restriction of anonymized types to the syntactical extent\n-    /// of a function's return type.\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        None\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct AnonTypeScope {\n-    enclosing_item: DefId\n-}\n-\n-impl<'gcx: 'tcx, 'tcx> AnonTypeScope {\n-    pub fn new(enclosing_item: DefId) -> AnonTypeScope {\n-        AnonTypeScope {\n-            enclosing_item: enclosing_item\n-        }\n-    }\n-\n-    pub fn fresh_substs(&self, astconv: &AstConv<'gcx, 'tcx>, span: Span)\n-                        -> &'tcx Substs<'tcx> {\n-        use collect::mk_item_substs;\n-\n-        mk_item_substs(astconv, span, self.enclosing_item)\n-    }\n-}\n-\n-/// A scope wrapper which optionally allows anonymized types.\n-#[derive(Copy, Clone)]\n-pub struct MaybeWithAnonTypes<R> {\n-    base_scope: R,\n-    anon_scope: Option<AnonTypeScope>\n-}\n-\n-impl<R: RegionScope> MaybeWithAnonTypes<R>  {\n-    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope>) -> Self {\n-        MaybeWithAnonTypes {\n-            base_scope: base_scope,\n-            anon_scope: anon_scope\n-        }\n-    }\n-}\n-\n-impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        self.base_scope.object_lifetime_default(span)\n-    }\n-\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        self.base_scope.anon_regions(span, count)\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        self.base_scope.base_object_lifetime_default(span)\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.anon_scope\n-    }\n-}\n-\n-// A scope in which all regions must be explicitly named. This is used\n-// for types that appear in structs and so on.\n-#[derive(Copy, Clone)]\n-pub struct ExplicitRscope;\n-\n-impl RegionScope for ExplicitRscope {\n-    fn anon_regions(&self,\n-                    _span: Span,\n-                    _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        Err(None)\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-// Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Option<Vec<ElisionFailureInfo>>);\n-\n-impl UnelidableRscope {\n-    pub fn new(v: Option<Vec<ElisionFailureInfo>>) -> UnelidableRscope {\n-        UnelidableRscope(v)\n-    }\n-}\n-\n-impl RegionScope for UnelidableRscope {\n-    fn anon_regions(&self,\n-                    _span: Span,\n-                    _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        let UnelidableRscope(ref v) = *self;\n-        Err(v.clone())\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-// A scope in which omitted anonymous region defaults to\n-// `default`. This is used after the `->` in function signatures. The\n-// latter use may go away. Note that object-lifetime defaults work a\n-// bit differently, as specified in RFC #599.\n-pub struct ElidableRscope {\n-    default: ty::Region,\n-}\n-\n-impl ElidableRscope {\n-    pub fn new(r: ty::Region) -> ElidableRscope {\n-        ElidableRscope { default: r }\n-    }\n-}\n-\n-impl RegionScope for ElidableRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        // Per RFC #599, object-lifetimes default to 'static unless\n-        // overridden by context, and this takes precedence over\n-        // lifetime elision.\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-\n-    fn anon_regions(&self,\n-                    _span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        Ok(vec![self.default; count])\n-    }\n-}\n-\n-/// A scope that behaves as an ElidabeRscope with a `'static` default region\n-/// that should also warn if the `static_in_const` feature is unset.\n-#[derive(Copy, Clone)]\n-pub struct StaticRscope<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> StaticRscope<'a, 'gcx, 'tcx> {\n-    /// create a new StaticRscope from a reference to the `TyCtxt`\n-    pub fn new(tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        StaticRscope { tcx: tcx }\n-    }\n-}\n-\n-impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> RegionScope for StaticRscope<'a, 'gcx, 'tcx> {\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        if !self.tcx.sess.features.borrow().static_in_const {\n-            self.tcx\n-                .sess\n-                .struct_span_err(span,\n-                                 \"this needs a `'static` lifetime or the \\\n-                                 `static_in_const` feature, see #35897\")\n-                .emit();\n-        }\n-        Ok(vec![ty::ReStatic; count])\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-/// A scope in which we generate anonymous, late-bound regions for\n-/// omitted regions. This occurs in function signatures.\n-pub struct BindingRscope {\n-    anon_bindings: Cell<u32>,\n-}\n-\n-impl BindingRscope {\n-    pub fn new() -> BindingRscope {\n-        BindingRscope {\n-            anon_bindings: Cell::new(0),\n-        }\n-    }\n-\n-    fn next_region(&self) -> ty::Region {\n-        let idx = self.anon_bindings.get();\n-        self.anon_bindings.set(idx + 1);\n-        ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(idx))\n-    }\n-}\n-\n-impl RegionScope for BindingRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        // Per RFC #599, object-lifetimes default to 'static unless\n-        // overridden by context, and this takes precedence over the\n-        // binding defaults in a fn signature.\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-\n-    fn anon_regions(&self,\n-                    _: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        Ok((0..count).map(|_| self.next_region()).collect())\n-    }\n-}\n-\n-/// A scope which overrides the default object lifetime but has no other effect.\n-pub struct ObjectLifetimeDefaultRscope<'r> {\n-    base_scope: &'r (RegionScope+'r),\n-    default: ty::ObjectLifetimeDefault<'r>,\n-}\n-\n-impl<'r> ObjectLifetimeDefaultRscope<'r> {\n-    pub fn new(base_scope: &'r (RegionScope+'r),\n-               default: ty::ObjectLifetimeDefault<'r>)\n-               -> ObjectLifetimeDefaultRscope<'r>\n-    {\n-        ObjectLifetimeDefaultRscope {\n-            base_scope: base_scope,\n-            default: default,\n-        }\n-    }\n-}\n-\n-impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        match self.default {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                None,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                // NB: This behavior changed in Rust 1.3.\n-                Some(self.base_object_lifetime_default(span)),\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                Some(*r),\n-        }\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        self.base_scope.base_object_lifetime_default(span)\n-    }\n-\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        self.base_scope.anon_regions(span, count)\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.base_scope.anon_type_scope()\n-    }\n-}\n-\n-/// A scope which simply shifts the Debruijn index of other scopes\n-/// to account for binding levels.\n-pub struct ShiftedRscope<'r> {\n-    base_scope: &'r (RegionScope+'r)\n-}\n-\n-impl<'r> ShiftedRscope<'r> {\n-    pub fn new(base_scope: &'r (RegionScope+'r)) -> ShiftedRscope<'r> {\n-        ShiftedRscope { base_scope: base_scope }\n-    }\n-}\n-\n-impl<'r> RegionScope for ShiftedRscope<'r> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        self.base_scope.object_lifetime_default(span)\n-            .map(|r| ty::fold::shift_region(r, 1))\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n-    }\n-\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        match self.base_scope.anon_regions(span, count) {\n-            Ok(mut v) => {\n-                for r in &mut v {\n-                    *r = ty::fold::shift_region(*r, 1);\n-                }\n-                Ok(v)\n-            }\n-            Err(errs) => {\n-                Err(errs)\n-            }\n-        }\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.base_scope.anon_type_scope()\n-    }\n-}"}, {"sha": "ba00f237684e6b6766dd29a5d89cd34082c4bb14", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.hir, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id)) => lifetime_decl_id,\n+            Some(&rl::Region::EarlyBound(_, lifetime_decl_id)) => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is"}, {"sha": "7591475c5d3fa12022d3fe800a68f90b371500ec", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -28,7 +28,7 @@ use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc::middle::privacy::AccessLevels;\n-use rustc::middle::resolve_lifetime::DefRegion::*;\n+use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -765,9 +765,9 @@ impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n         let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n         match def {\n-            Some(DefEarlyBoundRegion(_, node_id)) |\n-            Some(DefLateBoundRegion(_, node_id)) |\n-            Some(DefFreeRegion(_, node_id)) => {\n+            Some(rl::Region::EarlyBound(_, node_id)) |\n+            Some(rl::Region::LateBound(_, node_id)) |\n+            Some(rl::Region::Free(_, node_id)) => {\n                 if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n                     return lt;\n                 }\n@@ -794,7 +794,7 @@ impl Clean<Lifetime> for hir::LifetimeDef {\n     }\n }\n \n-impl<'tcx> Clean<Lifetime> for ty::RegionParameterDef<'tcx> {\n+impl Clean<Lifetime> for ty::RegionParameterDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n@@ -970,11 +970,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n                 Some(tp.clean(cx))\n             }\n         }).collect::<Vec<_>>();\n-        let stripped_lifetimes = gens.regions.iter().map(|rp| {\n-            let mut srp = rp.clone();\n-            srp.bounds = Vec::new();\n-            srp.clean(cx)\n-        }).collect::<Vec<_>>();\n \n         let mut where_predicates = preds.predicates.to_vec().clean(cx);\n \n@@ -1017,7 +1012,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n \n         Generics {\n             type_params: simplify::ty_params(stripped_typarams),\n-            lifetimes: stripped_lifetimes,\n+            lifetimes: gens.regions.clean(cx),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n     }\n@@ -1688,9 +1683,15 @@ impl Clean<Type> for hir::Ty {\n         match self.node {\n             TyNever => Never,\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n-            TyRptr(ref l, ref m) =>\n-                BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n-                             type_: box m.ty.clean(cx)},\n+            TyRptr(ref l, ref m) => {\n+                let lifetime = if l.is_elided() {\n+                    None\n+                } else {\n+                    Some(l.clean(cx))\n+                };\n+                BorrowedRef {lifetime: lifetime, mutability: m.mutbl.clean(cx),\n+                             type_: box m.ty.clean(cx)}\n+            }\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n             TyArray(ref ty, length) => {\n                 use rustc_const_eval::eval_length;\n@@ -1729,7 +1730,9 @@ impl Clean<Type> for hir::Ty {\n                     for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n                         if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n                                                                             .cloned() {\n-                            lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                            if !lt.is_elided() {\n+                                lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                            }\n                         }\n                     }\n                     return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n@@ -1768,20 +1771,20 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyTraitObject(ref bounds) => {\n-                let lhs_ty = bounds[0].clean(cx);\n-                match lhs_ty {\n-                    TraitBound(poly_trait, ..) => {\n-                        match poly_trait.trait_ {\n-                            ResolvedPath { path, typarams: None, did, is_generic } => {\n-                                ResolvedPath {\n-                                    path: path,\n-                                    typarams: Some(bounds[1..].clean(cx)),\n-                                    did: did,\n-                                    is_generic: is_generic,\n-                                }\n-                            }\n-                            _ => Infer // shouldn't happen\n+            TyTraitObject(ref bounds, ref lifetime) => {\n+                match bounds[0].clean(cx).trait_ {\n+                    ResolvedPath { path, typarams: None, did, is_generic } => {\n+                        let mut bounds: Vec<_> = bounds[1..].iter().map(|bound| {\n+                            TraitBound(bound.clean(cx), hir::TraitBoundModifier::None)\n+                        }).collect();\n+                        if !lifetime.is_elided() {\n+                            bounds.push(RegionBound(lifetime.clean(cx)));\n+                        }\n+                        ResolvedPath {\n+                            path: path,\n+                            typarams: Some(bounds),\n+                            did: did,\n+                            is_generic: is_generic,\n                         }\n                     }\n                     _ => Infer // shouldn't happen\n@@ -2242,7 +2245,11 @@ impl Clean<PathParameters> for hir::PathParameters {\n         match *self {\n             hir::AngleBracketedParameters(ref data) => {\n                 PathParameters::AngleBracketed {\n-                    lifetimes: data.lifetimes.clean(cx),\n+                    lifetimes: if data.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                        vec![]\n+                    } else {\n+                        data.lifetimes.clean(cx)\n+                    },\n                     types: data.types.clean(cx),\n                     bindings: data.bindings.clean(cx)\n                 }"}, {"sha": "d5644ab0608877a2fd5ad62d4f2fb768abcdaa03", "filename": "src/test/compile-fail/E0106.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2FE0106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2FE0106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0106.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -23,5 +23,17 @@ type MyStr = &str;\n         //~^ ERROR E0106\n         //~| NOTE expected lifetime parameter\n \n+struct Baz<'a>(&'a str);\n+struct Buzz<'a, 'b>(&'a str, &'b str);\n+\n+struct Quux {\n+    baz: Baz,\n+    //~^ ERROR E0106\n+    //~| expected lifetime parameter\n+    buzz: Buzz,\n+    //~^ ERROR E0106\n+    //~| expected 2 lifetime parameters\n+}\n+\n fn main() {\n }"}, {"sha": "16ebd3e9ca5f2abfa3d3b4f92a0a28a2e058479d", "filename": "src/test/compile-fail/E0107.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0107.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -18,9 +18,6 @@ enum Bar {\n }\n \n struct Baz<'a, 'b, 'c> {\n-    foo: Foo,\n-    //~^ ERROR E0107\n-    //~| expected 1 lifetime parameter\n     buzz: Buzz<'a>,\n     //~^ ERROR E0107\n     //~| expected 2 lifetime parameters"}, {"sha": "e6251a0d318a35321da6f640bada3adb1528adeb", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-struct.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -22,10 +22,11 @@ struct SomeStruct<I : for<'x> Foo<&'x isize>> {\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n-struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n-    field: <I as Foo<&isize>>::A\n-    //~^ ERROR missing lifetime specifier\n-}\n+// FIXME(eddyb) This one doesn't even compile because of the unsupported syntax.\n+\n+// struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n+//     field: <I as for<'y> Foo<&'y isize>>::A\n+// }\n \n struct YetAnotherStruct<'a, I : for<'x> Foo<&'x isize>> {\n     field: <I as Foo<&'a isize>>::A"}, {"sha": "0467c49b0311def45249af4a813e3eb2a18493f1", "filename": "src/test/compile-fail/impl-trait/disallowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -26,9 +26,9 @@ trait LazyToString {\n     //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n }\n \n-// Note that the following impl doesn't error, because the trait is invalid.\n impl LazyToString for String {\n     fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n         || self.clone()\n     }\n }"}, {"sha": "43371eb6340f434d89aa8b903fe5cf4e463586ef", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -38,4 +38,28 @@ fn i(_x: isize) -> &isize { //~ ERROR missing lifetime specifier\n     panic!()\n }\n \n+// Cases which used to work but now don't.\n+\n+type StaticStr = &'static str; // hides 'static\n+trait WithLifetime<'a> {\n+    type Output; // can hide 'a\n+}\n+\n+// This worked because the type of the first argument contains\n+// 'static, although StaticStr doesn't even have parameters.\n+fn j(_x: StaticStr) -> &isize { //~ ERROR missing lifetime specifier\n+//~^ HELP this function's return type contains a borrowed value\n+//~| HELP consider giving it an explicit bounded or 'static lifetime\n+    panic!()\n+}\n+\n+// This worked because the compiler resolved the argument type\n+// to <T as WithLifetime<'a>>::Output which has the hidden 'a.\n+fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n+//~^ ERROR missing lifetime specifier\n+//~| HELP this function's return type contains a borrowed value\n+//~| HELP consider giving it an explicit bounded or 'static lifetime\n+    panic!()\n+}\n+\n fn main() {}"}, {"sha": "503b577b1f1b4f3530392c3a714a14d800d69a31", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -18,7 +18,7 @@ trait SomeTrait { }\n \n // Bounds on object types:\n \n-struct Foo<'a,'b,'c> {\n+struct Foo<'a,'b,'c> { //~ ERROR parameter `'b` is never used\n     // All of these are ok, because we can derive exactly one bound:\n     a: Box<IsStatic>,\n     b: Box<Is<'static>>,\n@@ -28,7 +28,9 @@ struct Foo<'a,'b,'c> {\n     f: Box<SomeTrait>,   // OK, defaults to 'static due to RFC 599.\n     g: Box<SomeTrait+'a>,\n \n-    z: Box<Is<'a>+'b+'c>, //~ ERROR only a single explicit lifetime bound is permitted\n+    z: Box<Is<'a>+'b+'c>,\n+    //~^ ERROR only a single explicit lifetime bound is permitted\n+    //~| ERROR lifetime bound not satisfied\n }\n \n fn test<"}, {"sha": "93635e7fddea781c7b9f065c598abe20ee416f33", "filename": "src/test/compile-fail/rfc1623.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1623.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -15,8 +15,10 @@ fn non_elidable<'a, 'b>(a: &'a u8, b: &'b u8) -> &'a u8 {\n }\n \n // the boundaries of elision\n-static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 = &(non_elidable as fn(&u8, &u8) -> &u8);\n+static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 =\n //~^ ERROR missing lifetime specifier [E0106]\n+    &(non_elidable as fn(&u8, &u8) -> &u8);\n+    //~^ ERROR missing lifetime specifier [E0106]\n \n struct SomeStruct<'x, 'y, 'z: 'x> {\n     foo: &'x Foo<'z>,"}, {"sha": "18a1185d695f70ca0de33391fc4fadbc9843bbc5", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -38,9 +38,9 @@ fn test<'a,'b>() {\n }\n \n fn test2(x: &Foo<(isize,),Output=()>, y: &Foo(isize)) {\n+//~^ ERROR wrong number of lifetime parameters: expected 1, found 0\n     // Here, the omitted lifetimes are expanded to distinct things.\n-    same_type(x, y) //~ ERROR cannot infer\n-                    //~^ ERROR cannot infer\n+    same_type(x, y)\n }\n \n fn main() { }"}, {"sha": "e449a736c753a9360827d0a7e51563686af0dc7b", "filename": "src/test/compile-fail/where-equality-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fwhere-equality-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Fcompile-fail%2Fwhere-equality-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-equality-constraints.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -10,7 +10,7 @@\n \n fn f() where u8 = u16 {}\n //~^ ERROR equality constraints are not yet supported in where clauses\n-fn g() where for<'a> &(u8,) == u16, {}\n+fn g() where for<'a> &'static (u8,) == u16, {}\n //~^ ERROR equality constraints are not yet supported in where clauses\n \n fn main() {}"}, {"sha": "6aaf892097136b20af5c1c2ba690f0fd718c44ed", "filename": "src/test/run-pass/object-lifetime-default-from-ref-struct.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -15,6 +15,8 @@\n \n #![allow(dead_code)]\n \n+use std::fmt::Display;\n+\n trait Test {\n     fn foo(&self) { }\n }\n@@ -23,6 +25,11 @@ struct Ref<'a,T:'a+?Sized> {\n     r: &'a T\n }\n \n+struct Ref2<'a,'b,T:'a+'b+?Sized> {\n+    a: &'a T,\n+    b: &'b T\n+}\n+\n struct SomeStruct<'a> {\n     t: Ref<'a,Test>,\n     u: Ref<'a,Test+'a>,\n@@ -44,6 +51,17 @@ fn d<'a>(t: Ref<'a,Test+'a>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n+fn e<'a>(_: Ref<'a, Display+'static>) {}\n+fn g<'a, 'b>(_: Ref2<'a, 'b, Display+'static>) {}\n+\n \n fn main() {\n+    // Inside a function body, we can just infer all\n+    // lifetimes, to allow Ref<'tmp, Display+'static>\n+    // and Ref2<'tmp, 'tmp, Display+'static>.\n+    let x = &0 as &(Display+'static);\n+    let r: Ref<Display> = Ref { r: x };\n+    let r2: Ref2<Display> = Ref2 { a: x, b: x };\n+    e(r);\n+    g(r2);\n }"}, {"sha": "cbff0d4dbaa3cae02eaee650cdc9e5640ac34675", "filename": "src/test/run-pass/object-lifetime-default-from-rptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49616a53465d3ee7a7069cd13c7f86a483b655/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs?ref=0f49616a53465d3ee7a7069cd13c7f86a483b655", "patch": "@@ -15,6 +15,8 @@\n \n #![allow(dead_code)]\n \n+use std::fmt::Display;\n+\n trait Test {\n     fn foo(&self) { }\n }\n@@ -40,6 +42,10 @@ fn d<'a>(t: &'a (Test+'a), mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n+fn e<'a>(_: &'a (Display+'static)) {}\n \n fn main() {\n+    // Inside a function body, we can just infer both\n+    // lifetimes, to allow &'tmp (Display+'static).\n+    e(&0 as &Display);\n }"}]}