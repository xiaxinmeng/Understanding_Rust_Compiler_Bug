{"sha": "13bc0b5a48aff52e828b6b645b166ccfa56e7681", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYmMwYjVhNDhhZmY1MmU4MjhiNmI2NDViMTY2Y2NmYTU2ZTc2ODE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-13T15:24:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-14T04:06:50Z"}, "message": "rustc_resolve: also inject canaries to detect block scopes shadowing `uniform_paths` imports.", "tree": {"sha": "1e7fdb011323c7e175d76fa1a690386e06ffb274", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e7fdb011323c7e175d76fa1a690386e06ffb274"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13bc0b5a48aff52e828b6b645b166ccfa56e7681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13bc0b5a48aff52e828b6b645b166ccfa56e7681", "html_url": "https://github.com/rust-lang/rust/commit/13bc0b5a48aff52e828b6b645b166ccfa56e7681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13bc0b5a48aff52e828b6b645b166ccfa56e7681/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "html_url": "https://github.com/rust-lang/rust/commit/2ad865d601e57e3ab8b6842174f27fc68bcc44e8"}], "stats": {"total": 152, "additions": 118, "deletions": 34}, "files": [{"sha": "fa2af891f109b86770589ecda50eb36dbdac87b7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=13bc0b5a48aff52e828b6b645b166ccfa56e7681", "patch": "@@ -149,6 +149,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // import is injected as a \"canary\", and an error is emitted if it\n         // successfully resolves while an `x` external crate exists.\n         //\n+        // For each block scope around the `use` item, one special canary\n+        // import of the form `use x as _;` is also injected, having its\n+        // parent set to that scope; `resolve_imports` will only resolve\n+        // it within its appropriate scope; if any of them successfully\n+        // resolve, an ambiguity error is emitted, since the original\n+        // import can't see the item in the block scope (`self::x` only\n+        // looks in the enclosing module), but a non-`use` path could.\n+        //\n         // Additionally, the canary might be able to catch limitations of the\n         // current implementation, where `::x` may be chosen due to `self::x`\n         // not existing, but `self::x` could appear later, from macro expansion.\n@@ -173,33 +181,57 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.session.features_untracked().uniform_paths);\n \n             let source = module_path[0];\n-            let subclass = SingleImport {\n-                target: Ident {\n-                    name: keywords::Underscore.name().gensymed(),\n-                    span: source.span,\n-                },\n-                source,\n-                result: PerNS {\n-                    type_ns: Cell::new(Err(Undetermined)),\n-                    value_ns: Cell::new(Err(Undetermined)),\n-                    macro_ns: Cell::new(Err(Undetermined)),\n-                },\n-                type_ns_only: false,\n+            // Helper closure to emit a canary with the given base path.\n+            let emit = |this: &mut Self, base: Option<Ident>| {\n+                let subclass = SingleImport {\n+                    target: Ident {\n+                        name: keywords::Underscore.name().gensymed(),\n+                        span: source.span,\n+                    },\n+                    source,\n+                    result: PerNS {\n+                        type_ns: Cell::new(Err(Undetermined)),\n+                        value_ns: Cell::new(Err(Undetermined)),\n+                        macro_ns: Cell::new(Err(Undetermined)),\n+                    },\n+                    type_ns_only: false,\n+                };\n+                this.add_import_directive(\n+                    base.into_iter().collect(),\n+                    subclass.clone(),\n+                    source.span,\n+                    id,\n+                    root_use_tree.span,\n+                    root_id,\n+                    ty::Visibility::Invisible,\n+                    expansion,\n+                    true, // is_uniform_paths_canary\n+                );\n             };\n-            self.add_import_directive(\n-                vec![Ident {\n-                    name: keywords::SelfValue.name(),\n-                    span: source.span,\n-                }],\n-                subclass,\n-                source.span,\n-                id,\n-                root_use_tree.span,\n-                root_id,\n-                ty::Visibility::Invisible,\n-                expansion,\n-                true, // is_uniform_paths_canary\n-            );\n+\n+            // A single simple `self::x` canary.\n+            emit(self, Some(Ident {\n+                name: keywords::SelfValue.name(),\n+                span: source.span,\n+            }));\n+\n+            // One special unprefixed canary per block scope around\n+            // the import, to detect items unreachable by `self::x`.\n+            let orig_current_module = self.current_module;\n+            let mut span = source.span.modern();\n+            loop {\n+                match self.current_module.kind {\n+                    ModuleKind::Block(..) => emit(self, None),\n+                    ModuleKind::Def(..) => break,\n+                }\n+                match self.hygienic_lexical_parent(self.current_module, &mut span) {\n+                    Some(module) => {\n+                        self.current_module = module;\n+                    }\n+                    None => break,\n+                }\n+            }\n+            self.current_module = orig_current_module;\n \n             uniform_paths_canary_emitted = true;\n         }"}, {"sha": "1d8cc609f95ac6da1276ab59c97d2dc6818f2193", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=13bc0b5a48aff52e828b6b645b166ccfa56e7681", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n-use Namespace::{self, TypeNS, MacroNS};\n+use Namespace::{self, TypeNS, MacroNS, ValueNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n@@ -636,24 +636,32 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                     continue;\n                 }\n \n+                let is_explicit_self =\n+                    import.module_path.len() > 0 &&\n+                    import.module_path[0].name == keywords::SelfValue.name();\n                 let extern_crate_exists = self.extern_prelude.contains(&name);\n \n                 // A successful `self::x` is ambiguous with an `x` external crate.\n-                if !extern_crate_exists {\n+                if is_explicit_self && !extern_crate_exists {\n                     continue;\n                 }\n \n                 errors = true;\n \n                 let msg = format!(\"import from `{}` is ambiguous\", name);\n                 let mut err = self.session.struct_span_err(import.span, &msg);\n-                err.span_label(import.span,\n-                    format!(\"could refer to external crate `::{}`\", name));\n+                if extern_crate_exists {\n+                    err.span_label(import.span,\n+                        format!(\"could refer to external crate `::{}`\", name));\n+                }\n                 if let Some(result) = result {\n-                    err.span_label(result.span,\n-                        format!(\"could also refer to `self::{}`\", name));\n+                    if is_explicit_self {\n                         err.span_label(result.span,\n                             format!(\"could also refer to `self::{}`\", name));\n+                    } else {\n+                        err.span_label(result.span,\n+                            format!(\"shadowed by block-scoped `{}`\", name));\n+                    }\n                 }\n                 err.help(&format!(\"write `::{0}` or `self::{0}` explicitly instead\", name));\n                 err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n@@ -717,7 +725,11 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(\n-                Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n+                Some(if directive.is_uniform_paths_canary {\n+                    ModuleOrUniformRoot::Module(directive.parent)\n+                } else {\n+                    ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n+                }),\n                 &directive.module_path[..],\n                 None,\n                 false,\n@@ -792,7 +804,11 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let ImportDirective { ref module_path, span, .. } = *directive;\n \n         let module_result = self.resolve_path(\n-            Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n+            Some(if directive.is_uniform_paths_canary {\n+                ModuleOrUniformRoot::Module(directive.parent)\n+            } else {\n+                ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n+            }),\n             &module_path,\n             None,\n             true,"}, {"sha": "b8489c61dadeeba13bd14c19a4dd7a102e9dfbce", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs?ref=13bc0b5a48aff52e828b6b645b166ccfa56e7681", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+enum Foo { A, B }\n+\n+fn main() {\n+    enum Foo {}\n+    use Foo::*;\n+    //~^ ERROR import from `Foo` is ambiguous\n+\n+    let _ = (A, B);\n+}"}, {"sha": "656af91a8c7fef55aa6e4d715ea4ed3605fb996e", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13bc0b5a48aff52e828b6b645b166ccfa56e7681/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr?ref=13bc0b5a48aff52e828b6b645b166ccfa56e7681", "patch": "@@ -0,0 +1,13 @@\n+error: import from `Foo` is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:19:9\n+   |\n+LL |     enum Foo {}\n+   |     ----------- shadowed by block-scoped `Foo`\n+LL |     use Foo::*;\n+   |         ^^^\n+   |\n+   = help: write `::Foo` or `self::Foo` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}]}