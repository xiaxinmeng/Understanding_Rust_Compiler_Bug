{"sha": "5d8b694e14d9dd9ec04d65cba603f3ecc091bec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOGI2OTRlMTRkOWRkOWVjMDRkNjVjYmE2MDNmM2VjYzA5MWJlYzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-01T22:41:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-02T00:45:33Z"}, "message": "docs: More task tutorial", "tree": {"sha": "36f08cdea596306249e588b6f587fe7c3a950dcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36f08cdea596306249e588b6f587fe7c3a950dcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d8b694e14d9dd9ec04d65cba603f3ecc091bec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8b694e14d9dd9ec04d65cba603f3ecc091bec0", "html_url": "https://github.com/rust-lang/rust/commit/5d8b694e14d9dd9ec04d65cba603f3ecc091bec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d8b694e14d9dd9ec04d65cba603f3ecc091bec0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39f114d171859e2b3193a2fda997cb376bfac281", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f114d171859e2b3193a2fda997cb376bfac281", "html_url": "https://github.com/rust-lang/rust/commit/39f114d171859e2b3193a2fda997cb376bfac281"}], "stats": {"total": 225, "additions": 176, "deletions": 49}, "files": [{"sha": "35e8ffc16a4613c96d9823eb41b10b4ca609b67c", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 176, "deletions": 49, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/5d8b694e14d9dd9ec04d65cba603f3ecc091bec0/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d8b694e14d9dd9ec04d65cba603f3ecc091bec0/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=5d8b694e14d9dd9ec04d65cba603f3ecc091bec0", "patch": "@@ -2,12 +2,16 @@\n \n # Introduction\n \n-Rust supports concurrency and parallelism through lightweight tasks.\n-Rust tasks are significantly cheaper to create than traditional\n-threads, with a typical 32-bit system able to run hundreds of\n-thousands simultaneously. Tasks in Rust are what are often referred to\n-as _green threads_, cooperatively scheduled by the Rust runtime onto a\n-small number of operating system threads.\n+The Rust language is designed from the ground up to support pervasive\n+and safe concurrency through lightweight, memory-isolated tasks and\n+message passing.\n+\n+Rust tasks are not the same as traditional threads - they are what are\n+often referred to as _green threads_, cooperatively scheduled by the\n+Rust runtime onto a small number of operating system threads.  Being\n+significantly cheaper to create than traditional threads, Rust can\n+create hundreds of thousands of concurrent tasks on a typical 32-bit\n+system.\n \n Tasks provide failure isolation and recovery. When an exception occurs\n in rust code (either by calling `fail` explicitly or by otherwise performing\n@@ -16,11 +20,11 @@ to `catch` an exception as in other languages. Instead tasks may monitor\n each other to detect when failure has occurred.\n \n Rust tasks have dynamically sized stacks. When a task is first created\n-it starts off with a small amount of stack (in the hundreds to\n-low thousands of bytes, depending on plattform), and more stack is\n-added as needed. A Rust task will never run off the end of the stack as\n-is possible in many other languages, but they do have a stack budget,\n-and if a Rust task exceeds its stack budget then it will fail safely.\n+it starts off with a small amount of stack (currently in the low\n+thousands of bytes, depending on platform) and more stack is acquired as\n+needed. A Rust task will never run off the end of the stack as is\n+possible in many other languages, but they do have a stack budget, and\n+if a Rust task exceeds its stack budget then it will fail safely.\n \n Tasks make use of Rust's type system to provide strong memory safety\n guarantees, disallowing shared mutable state. Communication between\n@@ -32,12 +36,12 @@ explore some typical patterns in concurrent Rust code, and finally\n discuss some of the more exotic synchronization types in the standard\n library.\n \n-# A note about the libraries\n+## A note about the libraries\n \n While Rust's type system provides the building blocks needed for safe\n and efficient tasks, all of the task functionality itself is implemented\n in the core and standard libraries, which are still under development\n-and do not always present a nice programming interface.\n+and do not always present a consistent interface.\n \n In particular, there are currently two independent modules that provide\n a message passing interface to Rust code: `core::comm` and `core::pipes`.\n@@ -66,43 +70,96 @@ concurrency at the moment.\n [`std::arc`]: std/arc.html\n [`std::par`]: std/par.html\n \n-# Spawning a task\n+# Basics\n \n-Spawning a task is done using the various spawn functions in the\n-module `task`.  Let's begin with the simplest one, `task::spawn()`:\n+The programming interface for creating and managing tasks is contained\n+in the `task` module of the `core` library, making it available to all\n+Rust code by default. At it's simplest, creating a task is a matter of\n+calling the `spawn` function, passing a closure to run in the new\n+task.\n \n ~~~~\n+# use io::println;\n use task::spawn;\n-use io::println;\n \n-let some_value = 22;\n+// Print something profound in a different task using a named function\n+fn print_message() { println(\"I am running in a different task!\"); }\n+spawn(print_message);\n+\n+// Print something more profound in a different task using a lambda expression\n+spawn( || println(\"I am also running in a different task!\") );\n \n+// The canonical way to spawn is using `do` notation\n do spawn {\n-    println(~\"This executes in the child task.\");\n-    println(fmt!(\"%d\", some_value));\n+    println(\"I too am running in a different task!\");\n }\n ~~~~\n \n-The argument to `task::spawn()` is a [unique\n-closure](#unique-closures) of type `fn~()`, meaning that it takes no\n-arguments and generates no return value. The effect of `task::spawn()`\n-is to fire up a child task that will execute the closure in parallel\n-with the creator.\n+In Rust, there is nothing special about creating tasks - the language\n+itself doesn't know what a 'task' is. Instead, Rust provides in the\n+type system all the tools necessary to implement safe concurrency,\n+_owned types_ in particular, and leaves the dirty work up to the\n+core library.\n+\n+The `spawn` function has a very simple type signature: `fn spawn(f:\n+~fn())`. Because it accepts only owned closures, and owned closures\n+contained only owned data, `spawn` can safely move the entire closure\n+and all its associated state into an entirely different task for\n+execution. Like any closure, the function passed to spawn may capture\n+an environment that it carries across tasks.\n+\n+~~~\n+# use io::println;\n+# use task::spawn;\n+# fn generate_task_number() -> int { 0 }\n+// Generate some state locally\n+let child_task_number = generate_task_number();\n+\n+do spawn {\n+   // Capture it in the remote task\n+   println(fmt!(\"I am child number %d\", child_task_number));\n+}\n+~~~\n+\n+By default tasks will be multiplexed across the available cores, running\n+in parallel, thus on a multicore machine, running the following code\n+should interleave the output in vaguely random order.\n \n-# Communication\n+~~~\n+# use io::print;\n+# use task::spawn;\n \n-Now that we have spawned a child task, it would be nice if we could\n-communicate with it. This is done using *pipes*. Pipes are simply a\n-pair of endpoints, with one for sending messages and another for\n-receiving messages. The easiest way to create a pipe is to use\n-`pipes::stream`.  Imagine we wish to perform two expensive\n-computations in parallel.  We might write something like:\n+for int::range(0, 20) |child_task_number| {\n+    do spawn {\n+       print(fmt!(\"I am child number %d\\n\", child_task_number));\n+    }\n+}\n+~~~\n+\n+## Communication\n+\n+Now that we have spawned a new task, it would be nice if we could\n+communicate with it. Recall that Rust does not have shared mutable\n+state, so one task may not manipulate variables owned by another task.\n+Instead we use *pipes*.\n+\n+Pipes are simply a pair of endpoints, with one for sending messages\n+and another for receiving messages. Pipes are low-level communication\n+building-blocks and so come in a variety of forms, appropriate for\n+different use cases, but there are just a few varieties that are most\n+commonly used, which we will cover presently.\n+\n+The simplest way to create a pipe is to use the `pipes::stream`\n+function to create a `(Chan, Port)` pair. In Rust parlance a 'channel'\n+is a sending endpoint of a pipe, and a 'port' is the recieving\n+endpoint. Consider the following example of performing two calculations\n+concurrently.\n \n ~~~~\n use task::spawn;\n use pipes::{stream, Port, Chan};\n \n-let (chan, port) = stream();\n+let (chan, port): (Chan<int>, Port<int>) = stream();\n \n do spawn {\n     let result = some_expensive_computation();\n@@ -116,17 +173,19 @@ let result = port.recv();\n # fn some_other_expensive_computation() {}\n ~~~~\n \n-Let's walk through this code line-by-line.  The first line creates a\n-stream for sending and receiving integers:\n+Let's examine this example in detail. The `let` statement first creates a\n+stream for sending and receiving integers (recall that `let` can be\n+used for destructuring patterns, in this case separating a tuple into\n+its component parts).\n \n-~~~~ {.ignore}\n-# use pipes::stream;\n-let (chan, port) = stream();\n+~~~~\n+# use pipes::{stream, Chan, Port};\n+let (chan, port): (Chan<int>, Port<int>) = stream();\n ~~~~\n \n-This port is where we will receive the message from the child task\n-once it is complete.  The channel will be used by the child to send a\n-message to the port.  The next statement actually spawns the child:\n+The channel will be used by the child task to send data to the parent task,\n+which will wait to recieve the data on the port. The next statement\n+spawns the child task.\n \n ~~~~\n # use task::{spawn};\n@@ -140,14 +199,15 @@ do spawn {\n }\n ~~~~\n \n-This child will perform the expensive computation send the result\n-over the channel.  (Under the hood, `chan` was captured by the\n-closure that forms the body of the child task.  This capture is\n-allowed because channels are sendable.)\n+Notice that `chan` was transferred to the child task implicitly by\n+capturing it in the task closure. Both `Chan` and `Port` are sendable\n+types and may be captured into tasks or otherwise transferred between\n+them. In the example, the child task performs an expensive computation\n+then sends the result over the captured channel.\n \n-Finally, the parent continues by performing\n-some other expensive computation and then waiting for the child's result\n-to arrive on the port:\n+Finally, the parent continues by performing some other expensive\n+computation and then waiting for the child's result to arrive on the\n+port:\n \n ~~~~\n # use pipes::{stream, Port, Chan};\n@@ -158,7 +218,73 @@ some_other_expensive_computation();\n let result = port.recv();\n ~~~~\n \n-# Creating a task with a bi-directional communication path\n+The `Port` and `Chan` pair created by `stream` enable efficient\n+communication between a single sender and a single receiver, but\n+multiple senders cannot use a single `Chan`, nor can multiple\n+receivers use a single `Port`. What if our example needed to\n+perform multiple computations across a number of tasks? In that\n+case we might use a `SharedChan`, a type that allows a single\n+`Chan` to be used by multiple senders.\n+\n+~~~\n+# use task::spawn;\n+use pipes::{stream, SharedChan};\n+\n+let (chan, port) = stream();\n+let chan = SharedChan(move chan);\n+\n+for uint::range(0, 3) |init_val| {\n+    // Create a new channel handle to distribute to the child task\n+    let child_chan = chan.clone();\n+    do spawn {\n+        child_chan.send(some_expensive_computation(init_val));\n+    }\n+}\n+\n+let result = port.recv() + port.recv() + port.recv();\n+# fn some_expensive_computation(_i: uint) -> int { 42 }\n+~~~\n+\n+Here we transfer ownership of the channel into a new `SharedChan`\n+value.  Like `Chan`, `SharedChan` is a non-copyable, owned type\n+(sometimes also referred to as an 'affine' or 'linear' type). Unlike\n+`Chan` though, `SharedChan` may be duplicated with the `clone()`\n+method.  A cloned `SharedChan` produces a new handle to the same\n+channel, allowing multiple tasks to send data to a single port.\n+Between `spawn`, `stream` and `SharedChan` we have enough tools\n+to implement many useful concurrency patterns.\n+\n+Note that the above `SharedChan` example is somewhat contrived since\n+you could also simply use three `stream` pairs, but it serves to\n+illustrate the point. For reference, written with multiple streams it\n+might look like the example below.\n+\n+~~~\n+# use task::spawn;\n+# use pipes::{stream, Port, Chan};\n+\n+let ports = do vec::from_fn(3) |init_val| {\n+    let (chan, port) = stream();\n+\n+    do spawn {\n+        chan.send(some_expensive_computation(init_val));\n+    }\n+\n+    port\n+};\n+\n+// Wait on each port, accumulating the results\n+let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n+# fn some_expensive_computation(_i: uint) -> int { 42 }\n+~~~\n+\n+# Unfinished notes\n+\n+## Actor patterns\n+\n+## Linearity, option dancing, owned closures\n+\n+## Creating a task with a bi-directional communication path\n \n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each other. The\n@@ -227,3 +353,4 @@ assert from_child.recv() == ~\"0\";\n \n The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n and child can send and receive data to and from the other.\n+"}]}