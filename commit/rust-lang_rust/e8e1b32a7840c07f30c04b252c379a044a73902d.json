{"sha": "e8e1b32a7840c07f30c04b252c379a044a73902d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZTFiMzJhNzg0MGMwN2YzMGMwNGIyNTJjMzc5YTA0NGE3MzkwMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-10T22:37:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-10T22:37:57Z"}, "message": "Auto merge of #87923 - JohnTitor:rollup-id54fyz, r=JohnTitor\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #86840 (Constify implementations of `(Try)From` for int types)\n - #87582 (Implement `Printer` for `&mut SymbolPrinter`)\n - #87636 (Added the `Option::unzip()` method)\n - #87700 (Expand explanation of E0530)\n - #87811 (Do not ICE on HIR based WF check when involving lifetimes)\n - #87848 (removed references to parent/child from std::thread documentation)\n - #87854 (correctly handle enum variants in `opt_const_param_of`)\n - #87861 (Fix heading colours in Ayu theme)\n - #87865 (Clarify terms in rustdoc book)\n - #87876 (add `windows` count test)\n - #87880 (Remove duplicate trait bounds in `rustc_data_structures::graph`)\n - #87881 (Proper table row formatting in platform support)\n - #87889 (Use smaller spans when suggesting method call disambiguation)\n - #87895 (typeck: don't suggest inaccessible fields in struct literals and suggest ignoring inaccessible fields in struct patterns)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8415580fac07c5c95c8b24c4ff6874187f52d5cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8415580fac07c5c95c8b24c4ff6874187f52d5cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8e1b32a7840c07f30c04b252c379a044a73902d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e1b32a7840c07f30c04b252c379a044a73902d", "html_url": "https://github.com/rust-lang/rust/commit/e8e1b32a7840c07f30c04b252c379a044a73902d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8e1b32a7840c07f30c04b252c379a044a73902d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae90dcf0207c57c3034f00b07048d63f8b2363c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae90dcf0207c57c3034f00b07048d63f8b2363c8", "html_url": "https://github.com/rust-lang/rust/commit/ae90dcf0207c57c3034f00b07048d63f8b2363c8"}, {"sha": "4be63b2b5c6503129950b040ed39feec3064bf47", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be63b2b5c6503129950b040ed39feec3064bf47", "html_url": "https://github.com/rust-lang/rust/commit/4be63b2b5c6503129950b040ed39feec3064bf47"}], "stats": {"total": 531, "additions": 399, "deletions": 132}, "files": [{"sha": "dff22855629a8e4b9f93f6b7e7041a56b415ba2b", "filename": "compiler/rustc_data_structures/src/graph/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -60,18 +60,13 @@ pub trait WithStartNode: DirectedGraph {\n }\n \n pub trait ControlFlowGraph:\n-    DirectedGraph + WithStartNode + WithPredecessors + WithStartNode + WithSuccessors + WithNumNodes\n+    DirectedGraph + WithStartNode + WithPredecessors + WithSuccessors + WithNumNodes\n {\n     // convenient trait\n }\n \n impl<T> ControlFlowGraph for T where\n-    T: DirectedGraph\n-        + WithStartNode\n-        + WithPredecessors\n-        + WithStartNode\n-        + WithSuccessors\n-        + WithNumNodes\n+    T: DirectedGraph + WithStartNode + WithPredecessors + WithSuccessors + WithNumNodes\n {\n }\n "}, {"sha": "60fa711cbed363b458208cae42228331f7936e7f", "filename": "compiler/rustc_error_codes/src/error_codes/E0530.md", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0530.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0530.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0530.md?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -1,32 +1,57 @@\n A binding shadowed something it shouldn't.\n \n-Erroneous code example:\n+A match arm or a variable has a name that is already used by\n+something else, e.g.\n+\n+* struct name\n+* enum variant\n+* static\n+* associated constant\n+\n+This error may also happen when an enum variant *with fields* is used\n+in a pattern, but without its fields.\n+\n+```compile_fail\n+enum Enum {\n+    WithField(i32)\n+}\n+\n+use Enum::*;\n+match WithField(1) {\n+    WithField => {} // error: missing (_)\n+}\n+```\n+\n+Match bindings cannot shadow statics:\n \n ```compile_fail,E0530\n static TEST: i32 = 0;\n \n-let r: (i32, i32) = (0, 0);\n+let r = 123;\n match r {\n-    TEST => {} // error: match bindings cannot shadow statics\n+    TEST => {} // error: name of a static\n }\n ```\n \n-To fix this error, just change the binding's name in order to avoid shadowing\n-one of the following:\n+Fixed examples:\n \n-* struct name\n-* struct/enum variant\n-* static\n-* const\n-* associated const\n+```\n+static TEST: i32 = 0;\n \n-Fixed example:\n+let r = 123;\n+match r {\n+    some_value => {} // ok!\n+}\n+```\n+\n+or\n \n ```\n-static TEST: i32 = 0;\n+const TEST: i32 = 0; // const, not static\n \n-let r: (i32, i32) = (0, 0);\n+let r = 123;\n match r {\n-    something => {} // ok!\n+    TEST => {} // const is ok!\n+    other_values => {}\n }\n ```"}, {"sha": "1b4e6b4e38177bf658afb1a8907098323df6ae05", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -55,7 +55,8 @@ pub(super) fn mangle(\n \n     let hash = get_symbol_hash(tcx, instance, instance_ty, instantiating_crate);\n \n-    let mut printer = SymbolPrinter { tcx, path: SymbolPath::new(), keep_within_component: false }\n+    let mut printer = SymbolPrinter { tcx, path: SymbolPath::new(), keep_within_component: false };\n+    printer\n         .print_def_path(\n             def_id,\n             if let ty::InstanceDef::DropGlue(_, _) = instance.def {\n@@ -198,7 +199,7 @@ struct SymbolPrinter<'tcx> {\n // `PrettyPrinter` aka pretty printing of e.g. types in paths,\n // symbol names should have their own printing machinery.\n \n-impl Printer<'tcx> for SymbolPrinter<'tcx> {\n+impl Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n@@ -242,7 +243,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n         Ok(self)\n     }\n \n-    fn print_const(mut self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+    fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // only print integers\n         if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int { .. })) = ct.val {\n             if ct.ty.is_integral() {\n@@ -253,7 +254,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n         Ok(self)\n     }\n \n-    fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n+    fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n         self.write_str(&self.tcx.crate_name(cnum).as_str())?;\n         Ok(self)\n     }\n@@ -344,7 +345,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     }\n }\n \n-impl PrettyPrinter<'tcx> for SymbolPrinter<'tcx> {\n+impl PrettyPrinter<'tcx> for &mut SymbolPrinter<'tcx> {\n     fn region_should_not_be_omitted(&self, _region: ty::Region<'_>) -> bool {\n         false\n     }"}, {"sha": "ac07cc1f03439a360ee0ecff4d13ca356382d0d8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -245,9 +245,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let ObligationCauseCode::WellFormed(Some(wf_loc)) =\n                     root_obligation.cause.code.peel_derives()\n                 {\n-                    if let Some(cause) =\n-                        self.tcx.diagnostic_hir_wf_check((obligation.predicate, wf_loc.clone()))\n-                    {\n+                    if let Some(cause) = self.tcx.diagnostic_hir_wf_check((\n+                        tcx.erase_regions(obligation.predicate),\n+                        wf_loc.clone(),\n+                    )) {\n                         obligation.cause = cause;\n                         span = obligation.cause.span;\n                     }"}, {"sha": "a5362856511024e957b2bb129389ce91498d5b97", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -1313,15 +1313,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .emit();\n             }\n         } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n-            let no_accessible_remaining_fields = remaining_fields\n-                .iter()\n-                .find(|(_, (_, field))| {\n-                    field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)\n-                })\n-                .is_none();\n+            let inaccessible_remaining_fields = remaining_fields.iter().any(|(_, (_, field))| {\n+                !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)\n+            });\n \n-            if no_accessible_remaining_fields {\n-                self.report_no_accessible_fields(adt_ty, span);\n+            if inaccessible_remaining_fields {\n+                self.report_inaccessible_fields(adt_ty, span);\n             } else {\n                 self.report_missing_fields(adt_ty, span, remaining_fields);\n             }\n@@ -1398,7 +1395,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         .emit();\n     }\n \n-    /// Report an error for a struct field expression when there are no visible fields.\n+    /// Report an error for a struct field expression when there are invisible fields.\n     ///\n     /// ```text\n     /// error: cannot construct `Foo` with struct literal syntax due to inaccessible fields\n@@ -1409,7 +1406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// error: aborting due to previous error\n     /// ```\n-    fn report_no_accessible_fields(&self, adt_ty: Ty<'tcx>, span: Span) {\n+    fn report_inaccessible_fields(&self, adt_ty: Ty<'tcx>, span: Span) {\n         self.tcx.sess.span_err(\n             span,\n             &format!("}, {"sha": "c7a7462668aa52b82ddada4789a41f01603ea129", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -1695,8 +1695,8 @@ fn print_disambiguation_help(\n     source_map: &source_map::SourceMap,\n ) {\n     let mut applicability = Applicability::MachineApplicable;\n-    let sugg_args = if let (ty::AssocKind::Fn, Some(args)) = (kind, args) {\n-        format!(\n+    let (span, sugg) = if let (ty::AssocKind::Fn, Some(args)) = (kind, args) {\n+        let args = format!(\n             \"({}{})\",\n             if rcvr_ty.is_region_ptr() {\n                 if rcvr_ty.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n@@ -1710,12 +1710,12 @@ fn print_disambiguation_help(\n                 }))\n                 .collect::<Vec<_>>()\n                 .join(\", \"),\n-        )\n+        );\n+        (span, format!(\"{}::{}{}\", trait_name, item_name, args))\n     } else {\n-        String::new()\n+        (span.with_hi(item_name.span.lo()), format!(\"{}::\", trait_name))\n     };\n-    let sugg = format!(\"{}::{}{}\", trait_name, item_name, sugg_args);\n-    err.span_suggestion(\n+    err.span_suggestion_verbose(\n         span,\n         &format!(\n             \"disambiguate the {} for {}\","}, {"sha": "dae574bb7bf0fa04123ddf7b9647e7af7bbdc050", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -1250,15 +1250,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n         } else if !etc && !unmentioned_fields.is_empty() {\n-            let no_accessible_unmentioned_fields = !unmentioned_fields.iter().any(|(field, _)| {\n-                field.vis.is_accessible_from(tcx.parent_module(pat.hir_id).to_def_id(), tcx)\n-            });\n+            let accessible_unmentioned_fields: Vec<_> = unmentioned_fields\n+                .iter()\n+                .copied()\n+                .filter(|(field, _)| {\n+                    field.vis.is_accessible_from(tcx.parent_module(pat.hir_id).to_def_id(), tcx)\n+                })\n+                .collect();\n \n-            if no_accessible_unmentioned_fields {\n+            if accessible_unmentioned_fields.is_empty() {\n                 unmentioned_err = Some(self.error_no_accessible_fields(pat, &fields));\n             } else {\n-                unmentioned_err =\n-                    Some(self.error_unmentioned_fields(pat, &unmentioned_fields, &fields));\n+                unmentioned_err = Some(self.error_unmentioned_fields(\n+                    pat,\n+                    &accessible_unmentioned_fields,\n+                    accessible_unmentioned_fields.len() != unmentioned_fields.len(),\n+                    &fields,\n+                ));\n             }\n         }\n         match (inexistent_fields_err, unmentioned_err) {\n@@ -1583,17 +1591,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'_>,\n         unmentioned_fields: &[(&ty::FieldDef, Ident)],\n+        have_inaccessible_fields: bool,\n         fields: &'tcx [hir::PatField<'tcx>],\n     ) -> DiagnosticBuilder<'tcx> {\n+        let inaccessible = if have_inaccessible_fields { \" and inaccessible fields\" } else { \"\" };\n         let field_names = if unmentioned_fields.len() == 1 {\n-            format!(\"field `{}`\", unmentioned_fields[0].1)\n+            format!(\"field `{}`{}\", unmentioned_fields[0].1, inaccessible)\n         } else {\n             let fields = unmentioned_fields\n                 .iter()\n                 .map(|(_, name)| format!(\"`{}`\", name))\n                 .collect::<Vec<String>>()\n                 .join(\", \");\n-            format!(\"fields {}\", fields)\n+            format!(\"fields {}{}\", fields, inaccessible)\n         };\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n@@ -1624,17 +1634,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.span_suggestion(\n             sp,\n             &format!(\n-                \"include the missing field{} in the pattern\",\n+                \"include the missing field{} in the pattern{}\",\n                 if len == 1 { \"\" } else { \"s\" },\n+                if have_inaccessible_fields { \" and ignore the inaccessible fields\" } else { \"\" }\n             ),\n             format!(\n-                \"{}{}{}\",\n+                \"{}{}{}{}\",\n                 prefix,\n                 unmentioned_fields\n                     .iter()\n                     .map(|(_, name)| name.to_string())\n                     .collect::<Vec<_>>()\n                     .join(\", \"),\n+                if have_inaccessible_fields { \", ..\" } else { \"\" },\n                 postfix,\n             ),\n             Applicability::MachineApplicable,"}, {"sha": "b9483d6f987602c665b5867facaccbd1b12851e8", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -190,8 +190,12 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                 // Try to use the segment resolution if it is valid, otherwise we\n                 // default to the path resolution.\n                 let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+                use def::CtorOf;\n                 let generics = match res {\n-                    Res::Def(DefKind::Ctor(..), def_id) => {\n+                    Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx.generics_of(\n+                        tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap(),\n+                    ),\n+                    Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n                         tcx.generics_of(tcx.parent(def_id).unwrap())\n                     }\n                     // Other `DefKind`s don't have generics and would ICE when calling\n@@ -200,7 +204,6 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                         DefKind::Struct\n                         | DefKind::Union\n                         | DefKind::Enum\n-                        | DefKind::Variant\n                         | DefKind::Trait\n                         | DefKind::OpaqueTy\n                         | DefKind::TyAlias"}, {"sha": "75ef873abc965f40f2bf53258d1e4ab352de5565", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -45,7 +45,8 @@ impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n macro_rules! impl_from {\n     ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n         #[$attr]\n-        impl From<$Small> for $Large {\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n+        impl const From<$Small> for $Large {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]\n@@ -172,7 +173,8 @@ impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n+        impl const TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -190,7 +192,8 @@ macro_rules! try_from_unbounded {\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n+        impl const TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -212,7 +215,8 @@ macro_rules! try_from_lower_bounded {\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n+        impl const TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -234,7 +238,8 @@ macro_rules! try_from_upper_bounded {\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n+        impl const TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source"}, {"sha": "37c3f8d4c16abfbe12370ead005d77639c839858", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -99,6 +99,7 @@\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_swap)]\n+#![feature(const_trait_impl)]\n #![feature(const_type_id)]\n #![feature(const_type_name)]\n #![feature(const_unreachable_unchecked)]"}, {"sha": "3f9f04606b36a5f669b8cc999af47342f294ad68", "filename": "library/core/src/option.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -1399,6 +1399,33 @@ impl<T> Option<T> {\n     }\n }\n \n+impl<T, U> Option<(T, U)> {\n+    /// Unzips an option containing a tuple of two options\n+    ///\n+    /// If `self` is `Some((a, b))` this method returns `(Some(a), Some(b))`.\n+    /// Otherwise, `(None, None)` is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unzip_option)]\n+    ///\n+    /// let x = Some((1, \"hi\"));\n+    /// let y = None::<(u8, u32)>;\n+    ///\n+    /// assert_eq!(x.unzip(), (Some(1), Some(\"hi\")));\n+    /// assert_eq!(y.unzip(), (None, None));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"unzip_option\", issue = \"87800\", reason = \"recently added\")]\n+    pub const fn unzip(self) -> (Option<T>, Option<U>) {\n+        match self {\n+            Some((a, b)) => (Some(a), Some(b)),\n+            None => (None, None),\n+        }\n+    }\n+}\n+\n impl<T: Copy> Option<&T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n     /// option."}, {"sha": "13f483f19b770fcbc54a2e2fb1a644b5fb45205b", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -13,6 +13,8 @@\n #![feature(const_ptr_read)]\n #![feature(const_ptr_write)]\n #![feature(const_ptr_offset)]\n+#![feature(const_trait_impl)]\n+#![feature(const_num_from_num)]\n #![feature(core_intrinsics)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n@@ -66,6 +68,7 @@\n #![feature(slice_group_by)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n+#![feature(unzip_option)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "aca18ef39de1ac456cfd262a12e956e922356b78", "filename": "library/core/tests/num/const_from.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Fnum%2Fconst_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Fnum%2Fconst_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fconst_from.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,25 @@\n+#[test]\n+fn from() {\n+    use core::convert::TryFrom;\n+    use core::num::TryFromIntError;\n+\n+    // From\n+    const FROM: i64 = i64::from(1i32);\n+    assert_eq!(FROM, 1i64);\n+\n+    // From int to float\n+    const FROM_F64: f64 = f64::from(42u8);\n+    assert_eq!(FROM_F64, 42f64);\n+\n+    // Upper bounded\n+    const U8_FROM_U16: Result<u8, TryFromIntError> = u8::try_from(1u16);\n+    assert_eq!(U8_FROM_U16, Ok(1u8));\n+\n+    // Both bounded\n+    const I8_FROM_I16: Result<i8, TryFromIntError> = i8::try_from(1i16);\n+    assert_eq!(I8_FROM_I16, Ok(1i8));\n+\n+    // Lower bounded\n+    const I16_FROM_U16: Result<i16, TryFromIntError> = i16::try_from(1u16);\n+    assert_eq!(I16_FROM_U16, Ok(1i16));\n+}"}, {"sha": "37b5e9127d5b0b0645e4a5dde48f80fc7d6ee515", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -27,6 +27,8 @@ mod u64;\n mod u8;\n \n mod bignum;\n+\n+mod const_from;\n mod dec2flt;\n mod flt2dec;\n mod int_log;"}, {"sha": "cd8fdebe36a05a1620ee90daf9417f1e45575afd", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -399,11 +399,43 @@ fn test_unwrap_drop() {\n }\n \n #[test]\n-pub fn option_ext() {\n+fn option_ext() {\n     let thing = \"{{ f }}\";\n     let f = thing.find(\"{{\");\n \n     if f.is_none() {\n         println!(\"None!\");\n     }\n }\n+\n+#[test]\n+fn zip_options() {\n+    let x = Some(10);\n+    let y = Some(\"foo\");\n+    let z: Option<usize> = None;\n+\n+    assert_eq!(x.zip(y), Some((10, \"foo\")));\n+    assert_eq!(x.zip(z), None);\n+    assert_eq!(z.zip(x), None);\n+}\n+\n+#[test]\n+fn unzip_options() {\n+    let x = Some((10, \"foo\"));\n+    let y = None::<(bool, i32)>;\n+\n+    assert_eq!(x.unzip(), (Some(10), Some(\"foo\")));\n+    assert_eq!(y.unzip(), (None, None));\n+}\n+\n+#[test]\n+fn zip_unzip_roundtrip() {\n+    let x = Some(10);\n+    let y = Some(\"foo\");\n+\n+    let z = x.zip(y);\n+    assert_eq!(z, Some((10, \"foo\")));\n+\n+    let a = z.unzip();\n+    assert_eq!(a, (x, y));\n+}"}, {"sha": "43e2af3eb18d262403b9788e5db808a113ee1a64", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -739,6 +739,10 @@ fn test_array_windows_count() {\n     let v3: &[i32] = &[];\n     let c3 = v3.array_windows::<2>();\n     assert_eq!(c3.count(), 0);\n+\n+    let v4: &[()] = &[(); usize::MAX];\n+    let c4 = v4.array_windows::<1>();\n+    assert_eq!(c4.count(), usize::MAX);\n }\n \n #[test]\n@@ -1050,6 +1054,10 @@ fn test_windows_count() {\n     let v3: &[i32] = &[];\n     let c3 = v3.windows(2);\n     assert_eq!(c3.count(), 0);\n+\n+    let v4 = &[(); usize::MAX];\n+    let c4 = v4.windows(1);\n+    assert_eq!(c4.count(), usize::MAX);\n }\n \n #[test]"}, {"sha": "f44df845bf4dd56fc2b25a8fdcede67796195647", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -28,7 +28,7 @@\n //! When the main thread of a Rust program terminates, the entire program shuts\n //! down, even if other threads are still running. However, this module provides\n //! convenient facilities for automatically waiting for the termination of a\n-//! child thread (i.e., join).\n+//! thread (i.e., join).\n //!\n //! ## Spawning a thread\n //!\n@@ -42,38 +42,43 @@\n //! });\n //! ```\n //!\n-//! In this example, the spawned thread is \"detached\" from the current\n-//! thread. This means that it can outlive its parent (the thread that spawned\n-//! it), unless this parent is the main thread.\n+//! In this example, the spawned thread is \"detached,\" which means that there is\n+//! no way for the program to learn when the spawned thread completes or otherwise\n+//! terminates.\n //!\n-//! The parent thread can also wait on the completion of the child\n-//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n-//! a `join` method for waiting:\n+//! To learn when a thread completes, it is necessary to capture the [`JoinHandle`]\n+//! object that is returned by the call to [`spawn`], which provides\n+//! a `join` method that allows the caller to wait for the completion of the\n+//! spawned thread:\n //!\n //! ```rust\n //! use std::thread;\n //!\n-//! let child = thread::spawn(move || {\n+//! let thread_join_handle = thread::spawn(move || {\n //!     // some work here\n //! });\n //! // some work here\n-//! let res = child.join();\n+//! let res = thread_join_handle.join();\n //! ```\n //!\n //! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\n-//! value produced by the child thread, or [`Err`] of the value given to\n-//! a call to [`panic!`] if the child panicked.\n+//! value produced by the spawned thread, or [`Err`] of the value given to\n+//! a call to [`panic!`] if the thread panicked.\n+//!\n+//! Note that there is no parent/child relationship between a thread that spawns a\n+//! new thread and the thread being spawned.  In particular, the spawned thread may or\n+//! may not outlive the spawning thread, unless the spawning thread is the main thread.\n //!\n //! ## Configuring threads\n //!\n //! A new thread can be configured before it is spawned via the [`Builder`] type,\n-//! which currently allows you to set the name and stack size for the child thread:\n+//! which currently allows you to set the name and stack size for the thread:\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n //! use std::thread;\n //!\n-//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n+//! thread::Builder::new().name(\"thread1\".to_string()).spawn(move || {\n //!     println!(\"Hello, world!\");\n //! });\n //! ```\n@@ -344,7 +349,7 @@ impl Builder {\n     /// The spawned thread may outlive the caller (unless the caller thread\n     /// is the main thread; the whole process is terminated when the main\n     /// thread finishes). The join handle can be used to block on\n-    /// termination of the child thread, including recovering its panics.\n+    /// termination of the spawned thread, including recovering its panics.\n     ///\n     /// For a more complete documentation see [`thread::spawn`][`spawn`].\n     ///\n@@ -389,7 +394,7 @@ impl Builder {\n     /// The spawned thread may outlive the caller (unless the caller thread\n     /// is the main thread; the whole process is terminated when the main\n     /// thread finishes). The join handle can be used to block on\n-    /// termination of the child thread, including recovering its panics.\n+    /// termination of the spawned thread, including recovering its panics.\n     ///\n     /// This method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\n     /// except for the relaxed lifetime bounds, which render it unsafe.\n@@ -516,15 +521,16 @@ impl Builder {\n \n /// Spawns a new thread, returning a [`JoinHandle`] for it.\n ///\n-/// The join handle will implicitly *detach* the child thread upon being\n-/// dropped. In this case, the child thread may outlive the parent (unless\n-/// the parent thread is the main thread; the whole process is terminated when\n-/// the main thread finishes). Additionally, the join handle provides a [`join`]\n-/// method that can be used to join the child thread. If the child thread\n-/// panics, [`join`] will return an [`Err`] containing the argument given to\n-/// [`panic!`].\n+/// The join handle provides a [`join`] method that can be used to join the spawned\n+/// thread. If the spawned thread panics, [`join`] will return an [`Err`] containing\n+/// the argument given to [`panic!`].\n+///\n+/// If the join handle is dropped, the spawned thread will implicitly be *detached*.\n+/// In this case, the spawned thread may no longer be joined.\n+/// (It is the responsibility of the program to either eventually join threads it\n+/// creates or detach them; otherwise, a resource leak will result.)\n ///\n-/// This will create a thread using default parameters of [`Builder`], if you\n+/// This call will create a thread using default parameters of [`Builder`], if you\n /// want to specify the stack size or the name of the thread, use this API\n /// instead.\n ///\n@@ -533,8 +539,8 @@ impl Builder {\n ///\n /// - The `'static` constraint means that the closure and its return value\n ///   must have a lifetime of the whole program execution. The reason for this\n-///   is that threads can `detach` and outlive the lifetime they have been\n-///   created in.\n+///   is that threads can outlive the lifetime they have been created in.\n+///\n ///   Indeed if the thread, and by extension its return value, can outlive their\n ///   caller, we need to make sure that they will be valid afterwards, and since\n ///   we *can't* know when it will return we need to have them valid as long as\n@@ -1236,10 +1242,10 @@ impl fmt::Debug for Thread {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n \n-// This packet is used to communicate the return value between the child thread\n-// and the parent thread. Memory is shared through the `Arc` within and there's\n+// This packet is used to communicate the return value between the spawned thread\n+// and the rest of the program. Memory is shared through the `Arc` within and there's\n // no need for a mutex here because synchronization happens with `join()` (the\n-// parent thread never reads this packet until the child has exited).\n+// caller will never read this packet until the thread has exited).\n //\n // This packet itself is then stored into a `JoinInner` which in turns is placed\n // in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n@@ -1303,7 +1309,7 @@ impl<T> JoinInner<T> {\n /// }).unwrap();\n /// ```\n ///\n-/// Child being detached and outliving its parent:\n+/// A thread being detached and outliving the thread that spawned it:\n ///\n /// ```no_run\n /// use std::thread;\n@@ -1361,12 +1367,15 @@ impl<T> JoinHandle<T> {\n \n     /// Waits for the associated thread to finish.\n     ///\n+    /// This function will return immediately if the associated thread has already finished.\n+    ///\n     /// In terms of [atomic memory orderings],  the completion of the associated\n     /// thread synchronizes with this function returning. In other words, all\n-    /// operations performed by that thread are ordered before all\n+    /// operations performed by that thread [happen\n+    /// before](https://doc.rust-lang.org/nomicon/atomics.html#data-accesses) all\n     /// operations that happen after `join` returns.\n     ///\n-    /// If the child thread panics, [`Err`] is returned with the parameter given\n+    /// If the associated thread panics, [`Err`] is returned with the parameter given\n     /// to [`panic!`].\n     ///\n     /// [`Err`]: crate::result::Result::Err"}, {"sha": "5718a18393f9cec330351d8af919443e7fc6c865", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -115,6 +115,7 @@ The `std` column in the table below has the following meanings:\n target | std | notes\n -------|:---:|-------\n `aarch64-apple-ios` | \u2713 | ARM64 iOS\n+[`aarch64-apple-ios-sim`](platform-support/aarch64-apple-ios-sim.md) | \u2713 | Apple iOS Simulator on ARM64\n `aarch64-fuchsia` | \u2713 | ARM64 Fuchsia\n `aarch64-linux-android` | \u2713 | ARM64 Android\n `aarch64-unknown-none-softfloat` | * | Bare ARM64, softfloat\n@@ -165,7 +166,6 @@ target | std | notes\n `wasm32-unknown-unknown` | \u2713 | WebAssembly\n `wasm32-wasi` | \u2713 | WebAssembly with WASI\n `x86_64-apple-ios` | \u2713 | 64-bit x86 iOS\n-[`aarch64-apple-ios-sim`](platform-support/aarch64-apple-ios-sim.md) | \u2713 |  | Apple iOS Simulator on ARM64\n `x86_64-fortanix-unknown-sgx` | \u2713 | [Fortanix ABI] for 64-bit Intel SGX\n `x86_64-fuchsia` | \u2713 | 64-bit Fuchsia\n `x86_64-linux-android` | \u2713 | 64-bit x86 Android"}, {"sha": "70900a0bab942fa514533aec0fc3f884c8ab89e2", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -297,20 +297,23 @@ we can add the `#[macro_use]` attribute. Second, we\u2019ll need to add our own\n \n ## Attributes\n \n-There are a few annotations that are useful to help `rustdoc` do the right\n+Code blocks can be annotated with attributes that help `rustdoc` do the right\n thing when testing your code:\n \n+The `ignore` attribute tells Rust to ignore your code. This is almost never\n+what you want as it's the most generic. Instead, consider annotating it\n+with `text` if it's not code or using `#`s to get a working example that\n+only shows the part you care about.\n+\n ```rust\n /// ```ignore\n /// fn foo() {\n /// ```\n # fn foo() {}\n ```\n \n-The `ignore` directive tells Rust to ignore your code. This is almost never\n-what you want, as it's the most generic. Instead, consider annotating it\n-with `text` if it's not code, or using `#`s to get a working example that\n-only shows the part you care about.\n+`should_panic` tells `rustdoc` that the code should compile correctly but\n+panic during execution. If the code doesn't panic, the test will fail.\n \n ```rust\n /// ```should_panic\n@@ -319,8 +322,10 @@ only shows the part you care about.\n # fn foo() {}\n ```\n \n-`should_panic` tells `rustdoc` that the code should compile correctly, but\n-not actually pass as a test.\n+The `no_run` attribute will compile your code but not run it. This is\n+important for examples such as \"Here's how to retrieve a web page,\"\n+which you would want to ensure compiles, but might be run in a test\n+environment that has no network access.\n \n ```rust\n /// ```no_run\n@@ -331,24 +336,24 @@ not actually pass as a test.\n # fn foo() {}\n ```\n \n-The `no_run` attribute will compile your code, but not run it. This is\n-important for examples such as \"Here's how to retrieve a web page,\"\n-which you would want to ensure compiles, but might be run in a test\n-environment that has no network access.\n+`compile_fail` tells `rustdoc` that the compilation should fail. If it\n+compiles, then the test will fail. However, please note that code failing\n+with the current Rust release may work in a future release, as new features\n+are added.\n \n-```text\n+```rust\n /// ```compile_fail\n /// let x = 5;\n /// x += 2; // shouldn't compile!\n /// ```\n+# fn foo() {}\n ```\n \n-`compile_fail` tells `rustdoc` that the compilation should fail. If it\n-compiles, then the test will fail. However please note that code failing\n-with the current Rust release may work in a future release, as new features\n-are added.\n+`edition2018` tells `rustdoc` that the code sample should be compiled using\n+the 2018 edition of Rust. Similarly, you can specify `edition2015` to compile\n+the code with the 2015 edition.\n \n-```text\n+```rust\n /// Only runs on the 2018 edition.\n ///\n /// ```edition2018\n@@ -358,12 +363,9 @@ are added.\n ///         + \"3\".parse::<i32>()?\n /// };\n /// ```\n+# fn foo() {}\n ```\n \n-`edition2018` tells `rustdoc` that the code sample should be compiled using\n-the 2018 edition of Rust. Similarly, you can specify `edition2015` to compile\n-the code with the 2015 edition.\n-\n ## Syntax reference\n \n The *exact* syntax for code blocks, including the edge cases, can be found\n@@ -385,7 +387,7 @@ section.\n \n However, it's preferable to use fenced code blocks over indented code blocks.\n Not only are fenced code blocks considered more idiomatic for Rust code,\n-but there is no way to use directives such as `ignore` or `should_panic` with\n+but there is no way to use attributes such as `ignore` or `should_panic` with\n indented code blocks.\n \n ### Include items only when collecting doctests"}, {"sha": "8dd7b2b3edc4015008e96b92a9db6063cde5cc29", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -37,7 +37,7 @@ h4 {\n .docblock code {\n \tcolor: #ffb454;\n }\n-h3 > code, h4 > code, h5 > code {\n+.code-header {\n \tcolor: #e6e1cf;\n }\n pre > code {"}, {"sha": "fc94ef2ff887238c6986fd20d0d8374992ca3927", "filename": "src/test/ui/associated-consts/associated-const-ambiguity-report.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-ambiguity-report.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-ambiguity-report.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-ambiguity-report.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -17,11 +17,11 @@ LL |     const ID: i32 = 3;\n help: disambiguate the associated constant for candidate #1\n    |\n LL | const X: i32 = Foo::ID;\n-   |                ^^^^^^^\n+   |                ^^^^^\n help: disambiguate the associated constant for candidate #2\n    |\n LL | const X: i32 = Bar::ID;\n-   |                ^^^^^^^\n+   |                ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "5c6c4a8efac155cad375fd5fde59df1e926e6ae7", "filename": "src/test/ui/const-generics/enum-variants.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fconst-generics%2Fenum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fconst-generics%2Fenum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fenum-variants.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+enum Foo<const N: usize> {\n+    Variant,\n+    Variant2(),\n+    Variant3{},\n+}\n+\n+struct Bar<const N: usize>;\n+struct Bar2<const N: usize>();\n+struct Bar3<const N: usize> {}\n+\n+fn main() {\n+    let _ = Foo::Variant::<1>;\n+    let _ = Foo::Variant2::<1>();\n+    let _ = Foo::Variant3::<1>{};\n+\n+    let _ = Foo::<1>::Variant;\n+    let _ = Foo::<1>::Variant2();\n+    let _ = Foo::<1>::Variant3{};\n+\n+    let _ = Bar::<1>;\n+    let _ = Bar2::<1>();\n+    let _ = Bar3::<1>{};\n+}"}, {"sha": "55119857d8f834f027eae80d2e94803055dab7f2", "filename": "src/test/ui/error-codes/E0034.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -17,11 +17,11 @@ LL |     fn foo() {}\n help: disambiguate the associated function for candidate #1\n    |\n LL |     Trait1::foo()\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^\n help: disambiguate the associated function for candidate #2\n    |\n LL |     Trait2::foo()\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "33cf76d777bb6666087273d749f08b58489da3f0", "filename": "src/test/ui/issues/issue-18446.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fissues%2Fissue-18446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fissues%2Fissue-18446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18446.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -2,10 +2,7 @@ error[E0034]: multiple applicable items in scope\n   --> $DIR/issue-18446.rs:18:7\n    |\n LL |     x.foo();\n-   |     --^^^--\n-   |     | |\n-   |     | multiple `foo` found\n-   |     help: disambiguate the associated function for candidate #2: `T::foo(&x)`\n+   |       ^^^ multiple `foo` found\n    |\n note: candidate #1 is defined in an impl for the type `(dyn T + 'a)`\n   --> $DIR/issue-18446.rs:9:5\n@@ -17,6 +14,10 @@ note: candidate #2 is defined in the trait `T`\n    |\n LL |     fn foo(&self);\n    |     ^^^^^^^^^^^^^^\n+help: disambiguate the associated function for candidate #2\n+   |\n+LL |     T::foo(&x);\n+   |     ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7bfb8baa0c643b34c2f0936f01c3fb2d12a6f185", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -17,11 +17,11 @@ LL |     fn foo() {}\n help: disambiguate the associated function for candidate #1\n    |\n LL |     A::foo();\n-   |     ^^^^^^\n+   |     ^^^\n help: disambiguate the associated function for candidate #2\n    |\n LL |     B::foo();\n-   |     ^^^^^^\n+   |     ^^^\n \n error: aborting due to previous error\n "}, {"sha": "f789441378fe4d24792e52cb1bc853b24d2bc830", "filename": "src/test/ui/span/issue-7575.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -61,10 +61,7 @@ error[E0599]: no method named `is_str` found for type parameter `T` in the curre\n   --> $DIR/issue-7575.rs:70:7\n    |\n LL |     t.is_str()\n-   |     --^^^^^^--\n-   |     | |\n-   |     | this is an associated function, not a method\n-   |     help: disambiguate the associated function for the candidate: `ManyImplTrait::is_str(t)`\n+   |       ^^^^^^ this is an associated function, not a method\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n note: the candidate is defined in the trait `ManyImplTrait`\n@@ -73,6 +70,10 @@ note: the candidate is defined in the trait `ManyImplTrait`\n LL |     fn is_str() -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: disambiguate the associated function for the candidate\n+   |\n+LL |     ManyImplTrait::is_str(t)\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3176144133760d9937ca4b0c0a9e2ec2def1d6b3", "filename": "src/test/ui/typeck/issue-87872-missing-inaccessible-field-literal.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-literal.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,11 @@\n+pub mod foo {\n+    pub struct Foo {\n+        pub you_can_use_this_field: bool,\n+        you_cant_use_this_field: bool,\n+    }\n+}\n+\n+fn main() {\n+    foo::Foo {};\n+    //~^ ERROR cannot construct `Foo` with struct literal syntax due to inaccessible fields\n+}"}, {"sha": "81b73c00e8600e1c385beba6e7e759c15e53541a", "filename": "src/test/ui/typeck/issue-87872-missing-inaccessible-field-literal.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-literal.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,8 @@\n+error: cannot construct `Foo` with struct literal syntax due to inaccessible fields\n+  --> $DIR/issue-87872-missing-inaccessible-field-literal.rs:9:5\n+   |\n+LL |     foo::Foo {};\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d28e17559d879bf7bc5e8f2268aae5be60d847fb", "filename": "src/test/ui/typeck/issue-87872-missing-inaccessible-field-pattern.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-pattern.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,11 @@\n+#![allow(dead_code, unused_variables)]\n+\n+pub mod foo {\n+    #[derive(Default)]\n+    pub struct Foo { pub visible: bool, invisible: bool, }\n+}\n+\n+fn main() {\n+    let foo::Foo {} = foo::Foo::default();\n+    //~^ ERROR pattern does not mention field `visible` and inaccessible fields\n+}"}, {"sha": "51b8e39b101a3ec1e102206cccec426a5ba9a8a6", "filename": "src/test/ui/typeck/issue-87872-missing-inaccessible-field-pattern.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87872-missing-inaccessible-field-pattern.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,18 @@\n+error[E0027]: pattern does not mention field `visible` and inaccessible fields\n+  --> $DIR/issue-87872-missing-inaccessible-field-pattern.rs:9:9\n+   |\n+LL |     let foo::Foo {} = foo::Foo::default();\n+   |         ^^^^^^^^^^^ missing field `visible` and inaccessible fields\n+   |\n+help: include the missing field in the pattern and ignore the inaccessible fields\n+   |\n+LL |     let foo::Foo { visible, .. } = foo::Foo::default();\n+   |                  ^^^^^^^^^^^^^^^\n+help: if you don't care about this missing field, you can explicitly ignore it\n+   |\n+LL |     let foo::Foo { .. } = foo::Foo::default();\n+   |                  ^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0027`."}, {"sha": "bb398e5698a8018797877601ccd9596c4f9564f5", "filename": "src/test/ui/wf/hir-wf-check-erase-regions.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.rs?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for #87549.\n+// compile-flags: -C incremental=tmp/wf/hir-wf-check-erase-regions\n+\n+pub struct Table<T, const N: usize>([Option<T>; N]);\n+\n+impl<'a, T, const N: usize> IntoIterator for &'a Table<T, N> {\n+    type IntoIter = std::iter::Flatten<std::slice::Iter<'a, T>>; //~ ERROR `&T` is not an iterator\n+    type Item = &'a T;\n+\n+    fn into_iter(self) -> Self::IntoIter { //~ ERROR `&T` is not an iterator\n+        unimplemented!()\n+    }\n+}\n+fn main() {}"}, {"sha": "a704754e82a9210f53a765c2e42cb8f14b2ca34c", "filename": "src/test/ui/wf/hir-wf-check-erase-regions.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8e1b32a7840c07f30c04b252c379a044a73902d/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr?ref=e8e1b32a7840c07f30c04b252c379a044a73902d", "patch": "@@ -0,0 +1,31 @@\n+error[E0277]: `&T` is not an iterator\n+  --> $DIR/hir-wf-check-erase-regions.rs:7:5\n+   |\n+LL |     type IntoIter = std::iter::Flatten<std::slice::Iter<'a, T>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&T` is not an iterator\n+   |\n+  ::: $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n+   |\n+LL | pub struct Flatten<I: Iterator<Item: IntoIterator>> {\n+   |                                      ------------ required by this bound in `Flatten`\n+   |\n+   = help: the trait `Iterator` is not implemented for `&T`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n+\n+error[E0277]: `&T` is not an iterator\n+  --> $DIR/hir-wf-check-erase-regions.rs:10:27\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter {\n+   |                           ^^^^^^^^^^^^^^ `&T` is not an iterator\n+   |\n+  ::: $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n+   |\n+LL | pub struct Flatten<I: Iterator<Item: IntoIterator>> {\n+   |                                      ------------ required by this bound in `Flatten`\n+   |\n+   = help: the trait `Iterator` is not implemented for `&T`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}