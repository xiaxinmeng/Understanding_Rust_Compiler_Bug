{"sha": "a5563e173e705fcc03c5bcc91a7c0ff620fc7b57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTYzZTE3M2U3MDVmY2MwM2M1YmNjOTFhN2MwZmY2MjBmYzdiNTc=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-16T19:02:50Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-16T19:21:49Z"}, "message": "Clean up whitespace oddities perpetrated by pretty-printer.", "tree": {"sha": "02dcc23bba6cd2fd3e8606888912e1192e153221", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02dcc23bba6cd2fd3e8606888912e1192e153221"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5563e173e705fcc03c5bcc91a7c0ff620fc7b57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5563e173e705fcc03c5bcc91a7c0ff620fc7b57", "html_url": "https://github.com/rust-lang/rust/commit/a5563e173e705fcc03c5bcc91a7c0ff620fc7b57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5563e173e705fcc03c5bcc91a7c0ff620fc7b57/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efc55b2a3d56b67723b2b562c88f1811b5a6c0ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc55b2a3d56b67723b2b562c88f1811b5a6c0ba", "html_url": "https://github.com/rust-lang/rust/commit/efc55b2a3d56b67723b2b562c88f1811b5a6c0ba"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "e0305d91b4fb007ff1d2f0b4a95e8fec85b213af", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5563e173e705fcc03c5bcc91a7c0ff620fc7b57/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5563e173e705fcc03c5bcc91a7c0ff620fc7b57/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a5563e173e705fcc03c5bcc91a7c0ff620fc7b57", "patch": "@@ -7086,40 +7086,39 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n         // there's not much to do.\n \n         // Store null into pair, if no args or typarams.\n-\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         // Otherwise, we have to synthesize a big structural type for the\n         // object body.\n-\n         let vec[ty::t] obj_fields = [];\n         for (ty::arg a in arg_tys) { vec::push[ty::t](obj_fields, a.ty); }\n-        // Tuple type for fields: [field, ...]\n \n+        // Tuple type for fields: [field, ...]\n         let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n-        // Tuple type for typarams: [typaram, ...]\n \n         auto tydesc_ty = ty::mk_type(ccx.tcx);\n         let vec[ty::t] tps = [];\n         for (ast::ty_param tp in ty_params) {\n             vec::push[ty::t](tps, tydesc_ty);\n         }\n+\n+        // Tuple type for typarams: [typaram, ...]\n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n-        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n \n+        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n         let ty::t body_ty =\n             ty::mk_imm_tup(ccx.tcx, [tydesc_ty, typarams_ty, fields_ty]);\n+\n         // Hand this type we've synthesized off to trans_malloc_boxed, which\n         // allocates a box, including space for a refcount.\n-\n         auto box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n+\n         // mk_imm_box throws a refcount into the type we're synthesizing, so\n         // that it looks like: [rc, [tydesc_ty, [typaram, ...], [field, ...]]]\n-\n         let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n-        // Grab onto the refcount and body parts of the box we allocated.\n \n+        // Grab onto the refcount and body parts of the box we allocated.\n         auto rc =\n             GEP_tup_like(bcx, boxed_body_ty, box.val,\n                          [0, abi::box_rc_field_refcnt]);\n@@ -7129,6 +7128,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n                          [0, abi::box_rc_field_body]);\n         bcx = body.bcx;\n         bcx.build.Store(C_int(1), rc.val);\n+\n         // Put together a tydesc for the body, so that the object can later be\n         // freed by calling through its tydesc.\n \n@@ -7148,6 +7148,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;\n         bcx.build.Store(body_td.val, body_tydesc.val);\n+\n         // Copy the object's type parameters and fields into the space we\n         // allocated for the object body.  (This is something like saving the\n         // lexical environment of a function in its closure: the \"captured\n@@ -7156,7 +7157,6 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n         // Likewise for the object's fields.)\n \n         // Copy typarams into captured typarams.\n-\n         auto body_typarams =\n             GEP_tup_like(bcx, body_ty, body.val,\n                          [0, abi::obj_body_elt_typarams]);\n@@ -7170,8 +7170,8 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n             bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n             i += 1;\n         }\n-        // Copy args into body fields.\n \n+        // Copy args into body fields.\n         auto body_fields =\n             GEP_tup_like(bcx, body_ty, body.val,\n                          [0, abi::obj_body_elt_fields]);\n@@ -7186,14 +7186,14 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n             bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n             i += 1;\n         }\n-        // Store box ptr in outer pair.\n \n+        // Store box ptr in outer pair.\n         auto p = bcx.build.PointerCast(box.val, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n     bcx.build.RetVoid();\n-    // Insert the mandatory first few basic blocks before lltop.\n \n+    // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n }\n "}]}