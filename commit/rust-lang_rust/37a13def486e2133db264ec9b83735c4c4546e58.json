{"sha": "37a13def486e2133db264ec9b83735c4c4546e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YTEzZGVmNDg2ZTIxMzNkYjI2NGVjOWI4MzczNWM0YzQ1NDZlNTg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-27T13:51:25Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-17T17:41:08Z"}, "message": "Encode ExpnId using ExpnHash for incr. comp.", "tree": {"sha": "2b597e294490890ad3aeb59454ed0bb34dbc8898", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b597e294490890ad3aeb59454ed0bb34dbc8898"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a13def486e2133db264ec9b83735c4c4546e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a13def486e2133db264ec9b83735c4c4546e58", "html_url": "https://github.com/rust-lang/rust/commit/37a13def486e2133db264ec9b83735c4c4546e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a13def486e2133db264ec9b83735c4c4546e58/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "html_url": "https://github.com/rust-lang/rust/commit/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf"}], "stats": {"total": 282, "additions": 161, "deletions": 121}, "files": [{"sha": "388a8bd22fb32bb48af4aaeb1609cb8a9d4510e0", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=37a13def486e2133db264ec9b83735c4c4546e58", "patch": "@@ -79,6 +79,8 @@ crate struct CrateMetadata {\n     /// `DefIndex`. See `raw_def_id_to_def_id` for more details about how\n     /// this is used.\n     def_path_hash_map: OnceCell<UnhashMap<DefPathHash, DefIndex>>,\n+    /// Likewise for ExpnHash.\n+    expn_hash_map: OnceCell<UnhashMap<ExpnHash, ExpnIndex>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     alloc_decoding_state: AllocDecodingState,\n     /// Caches decoded `DefKey`s.\n@@ -1619,6 +1621,41 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.def_path_hash_unlocked(index, &mut def_path_hashes)\n     }\n \n+    fn expn_hash_to_expn_id(&self, index_guess: u32, hash: ExpnHash) -> ExpnId {\n+        debug_assert_eq!(ExpnId::from_hash(hash), None);\n+        let index_guess = ExpnIndex::from_u32(index_guess);\n+        let old_hash = self.root.expn_hashes.get(self, index_guess).map(|lazy| lazy.decode(self));\n+\n+        let index = if old_hash == Some(hash) {\n+            // Fast path: the expn and its index is unchanged from the\n+            // previous compilation session. There is no need to decode anything\n+            // else.\n+            index_guess\n+        } else {\n+            // Slow path: We need to find out the new `DefIndex` of the provided\n+            // `DefPathHash`, if its still exists. This requires decoding every `DefPathHash`\n+            // stored in this crate.\n+            let map = self.cdata.expn_hash_map.get_or_init(|| {\n+                let end_id = self.root.expn_hashes.size() as u32;\n+                let mut map =\n+                    UnhashMap::with_capacity_and_hasher(end_id as usize, Default::default());\n+                for i in 0..end_id {\n+                    let i = ExpnIndex::from_u32(i);\n+                    if let Some(hash) = self.root.expn_hashes.get(self, i) {\n+                        map.insert(hash.decode(self), i);\n+                    } else {\n+                        panic!(\"Missing expn_hash entry for {:?}\", i);\n+                    }\n+                }\n+                map\n+            });\n+            map[&hash]\n+        };\n+\n+        let data = self.root.expn_data.get(self, index).unwrap().decode(self);\n+        rustc_span::hygiene::register_expn_id(data, hash)\n+    }\n+\n     /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n@@ -1857,6 +1894,7 @@ impl CrateMetadata {\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n             def_path_hash_map: Default::default(),\n+            expn_hash_map: Default::default(),\n             alloc_decoding_state,\n             cnum,\n             cnum_map,"}, {"sha": "41839c58021ab335c7b2e4c4391d9631544b2834", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=37a13def486e2133db264ec9b83735c4c4546e58", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n-use rustc_span::hygiene::{ExpnData, ExpnHash, ExpnId};\n+use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::Symbol;\n \n@@ -494,23 +494,6 @@ impl CrateStore for CStore {\n     fn as_any(&self) -> &dyn Any {\n         self\n     }\n-    fn decode_expn_data(&self, sess: &Session, expn_id: ExpnId) -> (ExpnData, ExpnHash) {\n-        let crate_data = self.get_crate_data(expn_id.krate);\n-        (\n-            crate_data\n-                .root\n-                .expn_data\n-                .get(&crate_data, expn_id.local_id)\n-                .unwrap()\n-                .decode((&crate_data, sess)),\n-            crate_data\n-                .root\n-                .expn_hashes\n-                .get(&crate_data, expn_id.local_id)\n-                .unwrap()\n-                .decode((&crate_data, sess)),\n-        )\n-    }\n \n     fn crate_name(&self, cnum: CrateNum) -> Symbol {\n         self.get_crate_data(cnum).root.name\n@@ -545,6 +528,10 @@ impl CrateStore for CStore {\n         self.get_crate_data(cnum).def_path_hash_to_def_id(cnum, index_guess, hash)\n     }\n \n+    fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId {\n+        self.get_crate_data(cnum).expn_hash_to_expn_id(index_guess, hash)\n+    }\n+\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }"}, {"sha": "4c35b49bcefd73079d808d96a449e144e339ec65", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=37a13def486e2133db264ec9b83735c4c4546e58", "patch": "@@ -11,8 +11,7 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_macros::HashStable;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n-use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnData, ExpnHash, ExpnId};\n+use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::spec::Target;\n@@ -188,7 +187,6 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// during resolve)\n pub trait CrateStore: std::fmt::Debug {\n     fn as_any(&self) -> &dyn Any;\n-    fn decode_expn_data(&self, sess: &Session, expn_id: ExpnId) -> (ExpnData, ExpnHash);\n \n     // Foreign definitions.\n     // This information is safe to access, since it's hashed as part of the DefPathHash, which incr.\n@@ -209,6 +207,7 @@ pub trait CrateStore: std::fmt::Debug {\n         index_guess: u32,\n         hash: DefPathHash,\n     ) -> Option<DefId>;\n+    fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId;\n \n     // utility functions\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata;"}, {"sha": "03e3ca5ec6b8b0e7294f9c96d29811ee8d8d1144", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=37a13def486e2133db264ec9b83735c4c4546e58", "patch": "@@ -83,14 +83,16 @@ pub struct OnDiskCache<'sess> {\n     // `ExpnData` (e.g `ExpnData.krate` may not be `LOCAL_CRATE`). Alternatively,\n     // we could look up the `ExpnData` from the metadata of foreign crates,\n     // but it seemed easier to have `OnDiskCache` be independent of the `CStore`.\n-    expn_data: FxHashMap<u32, AbsoluteBytePos>,\n+    expn_data: UnhashMap<ExpnHash, AbsoluteBytePos>,\n     // Additional information used when decoding hygiene data.\n     hygiene_context: HygieneDecodeContext,\n     // Maps `DefPathHash`es to their `RawDefId`s from the *previous*\n     // compilation session. This is used as an initial 'guess' when\n     // we try to map a `DefPathHash` to its `DefId` in the current compilation\n     // session.\n     foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n+    // Likewise for ExpnId.\n+    foreign_expn_data: UnhashMap<ExpnHash, u32>,\n \n     // The *next* compilation sessison's `foreign_def_path_hashes` - at\n     // the end of our current compilation session, this will get written\n@@ -118,8 +120,9 @@ struct Footer {\n     // See `OnDiskCache.syntax_contexts`\n     syntax_contexts: FxHashMap<u32, AbsoluteBytePos>,\n     // See `OnDiskCache.expn_data`\n-    expn_data: FxHashMap<u32, AbsoluteBytePos>,\n+    expn_data: UnhashMap<ExpnHash, AbsoluteBytePos>,\n     foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n+    foreign_expn_data: UnhashMap<ExpnHash, u32>,\n }\n \n pub type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n@@ -217,6 +220,7 @@ impl<'sess> OnDiskCache<'sess> {\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n             syntax_contexts: footer.syntax_contexts,\n             expn_data: footer.expn_data,\n+            foreign_expn_data: footer.foreign_expn_data,\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: footer.foreign_def_path_hashes,\n             latest_foreign_def_path_hashes: Default::default(),\n@@ -236,7 +240,8 @@ impl<'sess> OnDiskCache<'sess> {\n             prev_diagnostics_index: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n             syntax_contexts: FxHashMap::default(),\n-            expn_data: FxHashMap::default(),\n+            expn_data: UnhashMap::default(),\n+            foreign_expn_data: UnhashMap::default(),\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: Default::default(),\n             latest_foreign_def_path_hashes: Default::default(),\n@@ -350,7 +355,8 @@ impl<'sess> OnDiskCache<'sess> {\n             };\n \n             let mut syntax_contexts = FxHashMap::default();\n-            let mut expn_ids = FxHashMap::default();\n+            let mut expn_data = UnhashMap::default();\n+            let mut foreign_expn_data = UnhashMap::default();\n \n             // Encode all hygiene data (`SyntaxContextData` and `ExpnData`) from the current\n             // session.\n@@ -363,13 +369,14 @@ impl<'sess> OnDiskCache<'sess> {\n                     syntax_contexts.insert(index, pos);\n                     Ok(())\n                 },\n-                |encoder, index, expn_data, hash| -> FileEncodeResult {\n-                    if index.krate == LOCAL_CRATE {\n+                |encoder, expn_id, data, hash| -> FileEncodeResult {\n+                    if expn_id.krate == LOCAL_CRATE {\n                         let pos = AbsoluteBytePos::new(encoder.position());\n-                        encoder.encode_tagged(TAG_EXPN_DATA, &(expn_data, hash))?;\n-                        expn_ids.insert(index.local_id.as_u32(), pos);\n+                        encoder.encode_tagged(TAG_EXPN_DATA, &data)?;\n+                        expn_data.insert(hash, pos);\n+                    } else {\n+                        foreign_expn_data.insert(hash, expn_id.local_id.as_u32());\n                     }\n-                    // TODO Handle foreign expansions.\n                     Ok(())\n                 },\n             )?;\n@@ -387,7 +394,8 @@ impl<'sess> OnDiskCache<'sess> {\n                     diagnostics_index,\n                     interpret_alloc_index,\n                     syntax_contexts,\n-                    expn_data: expn_ids,\n+                    expn_data,\n+                    foreign_expn_data,\n                     foreign_def_path_hashes,\n                 },\n             )?;\n@@ -549,6 +557,7 @@ impl<'sess> OnDiskCache<'sess> {\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n             syntax_contexts: &self.syntax_contexts,\n             expn_data: &self.expn_data,\n+            foreign_expn_data: &self.foreign_expn_data,\n             hygiene_context: &self.hygiene_context,\n         };\n         f(&mut decoder)\n@@ -643,7 +652,8 @@ pub struct CacheDecoder<'a, 'tcx> {\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n     syntax_contexts: &'a FxHashMap<u32, AbsoluteBytePos>,\n-    expn_data: &'a FxHashMap<u32, AbsoluteBytePos>,\n+    expn_data: &'a UnhashMap<ExpnHash, AbsoluteBytePos>,\n+    foreign_expn_data: &'a UnhashMap<ExpnHash, u32>,\n     hygiene_context: &'a HygieneDecodeContext,\n }\n \n@@ -794,27 +804,43 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n-        let krate = CrateNum::decode(decoder)?;\n-        let index = u32::decode(decoder)?;\n-\n-        let expn_data = decoder.expn_data;\n-        let tcx = decoder.tcx;\n-        rustc_span::hygiene::decode_expn_id_incrcomp(\n-            krate,\n-            index,\n-            decoder.hygiene_context,\n-            |index| -> Result<(ExpnData, ExpnHash), _> {\n-                // This closure is invoked if we haven't already decoded the data for the `ExpnId` we are deserializing.\n-                // We look up the position of the associated `ExpnData` and decode it.\n-                let pos = expn_data\n-                    .get(&index)\n-                    .unwrap_or_else(|| panic!(\"Bad index {:?} (map {:?})\", index, expn_data));\n-\n-                decoder\n-                    .with_position(pos.to_usize(), |decoder| decode_tagged(decoder, TAG_EXPN_DATA))\n-            },\n-            |expn_id| tcx.untracked_resolutions.cstore.decode_expn_data(tcx.sess, expn_id),\n-        )\n+        let hash = ExpnHash::decode(decoder)?;\n+        if hash.is_root() {\n+            return Ok(ExpnId::root());\n+        }\n+\n+        if let Some(expn_id) = ExpnId::from_hash(hash) {\n+            return Ok(expn_id);\n+        }\n+\n+        let krate = decoder.cnum_map[&hash.stable_crate_id()];\n+\n+        let expn_id = if krate == LOCAL_CRATE {\n+            // We look up the position of the associated `ExpnData` and decode it.\n+            let pos = decoder\n+                .expn_data\n+                .get(&hash)\n+                .unwrap_or_else(|| panic!(\"Bad hash {:?} (map {:?})\", hash, decoder.expn_data));\n+\n+            let data: ExpnData = decoder\n+                .with_position(pos.to_usize(), |decoder| decode_tagged(decoder, TAG_EXPN_DATA))?;\n+            rustc_span::hygiene::register_local_expn_id(data, hash)\n+        } else {\n+            let index_guess = decoder.foreign_expn_data[&hash];\n+            decoder.tcx.untracked_resolutions.cstore.expn_hash_to_expn_id(krate, index_guess, hash)\n+        };\n+\n+        #[cfg(debug_assertions)]\n+        {\n+            use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+            let mut hcx = decoder.tcx.create_stable_hashing_context();\n+            let mut hasher = StableHasher::new();\n+            expn_id.expn_data().hash_stable(&mut hcx, &mut hasher);\n+            let local_hash: u64 = hasher.finish();\n+            debug_assert_eq!(hash.local_hash(), local_hash);\n+        }\n+\n+        Ok(expn_id)\n     }\n }\n \n@@ -990,8 +1016,7 @@ where\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         s.hygiene_context.schedule_expn_data_for_encoding(*self);\n-        self.krate.encode(s)?;\n-        self.local_id.as_u32().encode(s)\n+        self.expn_hash().encode(s)\n     }\n }\n "}, {"sha": "64baf94cc00631047475a4c5443751b23d209e62", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=37a13def486e2133db264ec9b83735c4c4546e58", "patch": "@@ -136,7 +136,7 @@ impl Borrow<Fingerprint> for DefPathHash {\n /// further trouble.\n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n-pub struct StableCrateId(u64);\n+pub struct StableCrateId(pub(crate) u64);\n \n impl StableCrateId {\n     pub fn to_u64(self) -> u64 {"}, {"sha": "a6d77852c06a9867a195c95d6e4a9b9ef0a0a8c1", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 56, "deletions": 65, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a13def486e2133db264ec9b83735c4c4546e58/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=37a13def486e2133db264ec9b83735c4c4546e58", "patch": "@@ -29,7 +29,7 @@ use crate::symbol::{kw, sym, Symbol};\n use crate::with_session_globals;\n use crate::{HashStableContext, Span, DUMMY_SP};\n \n-use crate::def_id::{CrateNum, DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use crate::def_id::{CrateNum, DefId, StableCrateId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -92,6 +92,34 @@ rustc_index::newtype_index! {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct ExpnHash(Fingerprint);\n \n+impl ExpnHash {\n+    /// Returns the [StableCrateId] identifying the crate this [ExpnHash]\n+    /// originates from.\n+    #[inline]\n+    pub fn stable_crate_id(self) -> StableCrateId {\n+        StableCrateId(self.0.as_value().0)\n+    }\n+\n+    /// Returns the crate-local part of the [ExpnHash].\n+    ///\n+    /// Used for tests.\n+    #[inline]\n+    pub fn local_hash(self) -> u64 {\n+        self.0.as_value().1\n+    }\n+\n+    #[inline]\n+    pub fn is_root(self) -> bool {\n+        self.0 == Fingerprint::ZERO\n+    }\n+\n+    /// Builds a new [ExpnHash] with the given [StableCrateId] and\n+    /// `local_hash`, where `local_hash` must be unique within its crate.\n+    fn new(stable_crate_id: StableCrateId, local_hash: u64) -> ExpnHash {\n+        ExpnHash(Fingerprint::new(stable_crate_id.0, local_hash))\n+    }\n+}\n+\n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, Encodable, Decodable)]\n@@ -268,12 +296,12 @@ pub struct HygieneData {\n     expn_hash_to_expn_id: UnhashMap<ExpnHash, ExpnId>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n-    /// Maps the `Fingerprint` of an `ExpnData` to the next disambiguator value.\n+    /// Maps the `local_hash` of an `ExpnData` to the next disambiguator value.\n     /// This is used by `update_disambiguator` to keep track of which `ExpnData`s\n     /// would have collisions without a disambiguator.\n     /// The keys of this map are always computed with `ExpnData.disambiguator`\n     /// set to 0.\n-    expn_data_disambiguators: FxHashMap<Fingerprint, u32>,\n+    expn_data_disambiguators: FxHashMap<u64, u32>,\n }\n \n impl HygieneData {\n@@ -981,7 +1009,7 @@ impl ExpnData {\n     }\n \n     #[inline]\n-    fn hash_expn(&self, ctx: &mut impl HashStableContext) -> Fingerprint {\n+    fn hash_expn(&self, ctx: &mut impl HashStableContext) -> u64 {\n         let mut hasher = StableHasher::new();\n         self.hash_stable(ctx, &mut hasher);\n         hasher.finish()\n@@ -1191,75 +1219,46 @@ pub struct HygieneDecodeContext {\n     // so that multiple occurrences of the same serialized id are decoded to the same\n     // `SyntaxContext`\n     remapped_ctxts: Lock<Vec<Option<SyntaxContext>>>,\n-    // The same as `remapepd_ctxts`, but for `ExpnId`s\n-    remapped_expns: Lock<Vec<Option<LocalExpnId>>>,\n }\n \n-pub fn decode_expn_id_incrcomp<E>(\n-    krate: CrateNum,\n-    index: u32,\n-    context: &HygieneDecodeContext,\n-    decode_data: impl FnOnce(u32) -> Result<(ExpnData, ExpnHash), E>,\n-    decode_foreign: impl FnOnce(ExpnId) -> (ExpnData, ExpnHash),\n-) -> Result<ExpnId, E> {\n-    // Do this after decoding, so that we decode a `CrateNum`\n-    // if necessary\n-    if index == 0 {\n-        debug!(\"decode_expn_id: deserialized root\");\n-        return Ok(ExpnId::root());\n-    }\n-\n-    if krate != LOCAL_CRATE {\n-        let expn_id = decode_expn_id(krate, index, decode_foreign);\n-        return Ok(expn_id);\n-    }\n-\n-    let outer_expns = &context.remapped_expns;\n-\n-    // Ensure that the lock() temporary is dropped early\n-    {\n-        if let Some(expn_id) = outer_expns.lock().get(index as usize).copied().flatten() {\n-            return Ok(expn_id.to_expn_id());\n-        }\n-    }\n-\n-    // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n-    // other ExpnIds\n-    let (mut expn_data, hash) = decode_data(index)?;\n-    debug_assert_eq!(krate, expn_data.krate);\n-\n-    let expn_id = HygieneData::with(|hygiene_data| {\n-        if let Some(expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n-            return *expn_id;\n-        }\n-\n+/// Register an expansion which has been decoded from the on-disk-cache for the local crate.\n+pub fn register_local_expn_id(mut data: ExpnData, hash: ExpnHash) -> ExpnId {\n+    HygieneData::with(|hygiene_data| {\n         // If we just deserialized an `ExpnData` owned by\n         // the local crate, its `orig_id` will be stale,\n         // so we need to update it to its own value.\n         // This only happens when we deserialize the incremental cache,\n         // since a crate will never decode its own metadata.\n         let expn_id = hygiene_data.local_expn_data.next_index();\n-        expn_data.orig_id = Some(expn_id.as_u32());\n-        hygiene_data.local_expn_data.push(Some(expn_data));\n+        data.orig_id = Some(expn_id.as_u32());\n+        hygiene_data.local_expn_data.push(Some(data));\n         let _eid = hygiene_data.local_expn_hashes.push(hash);\n         debug_assert_eq!(expn_id, _eid);\n \n-        let mut expns = outer_expns.lock();\n-        let new_len = index as usize + 1;\n-        if expns.len() < new_len {\n-            expns.resize(new_len, None);\n-        }\n-        expns[index as usize] = Some(expn_id);\n-        drop(expns);\n         let expn_id = expn_id.to_expn_id();\n \n         let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n         debug_assert!(_old_id.is_none());\n         expn_id\n+    })\n+}\n+\n+/// Register an expansion which has been decoded from the metadata of a foreign crate.\n+pub fn register_expn_id(data: ExpnData, hash: ExpnHash) -> ExpnId {\n+    let expn_id =\n+        ExpnId { krate: data.krate, local_id: ExpnIndex::from_u32(data.orig_id.unwrap()) };\n+    HygieneData::with(|hygiene_data| {\n+        let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, data);\n+        debug_assert!(_old_data.is_none());\n+        let _old_hash = hygiene_data.foreign_expn_hashes.insert(expn_id, hash);\n+        debug_assert!(_old_hash.is_none());\n+        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n     });\n-    Ok(expn_id)\n+    expn_id\n }\n \n+/// Decode an expansion from the metadata of a foreign crate.\n pub fn decode_expn_id(\n     krate: CrateNum,\n     index: u32,\n@@ -1287,16 +1286,7 @@ pub fn decode_expn_id(\n     debug_assert_eq!(krate, expn_data.krate);\n     debug_assert_eq!(Some(index.as_u32()), expn_data.orig_id);\n \n-    HygieneData::with(|hygiene_data| {\n-        let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, expn_data);\n-        debug_assert!(_old_data.is_none());\n-        let _old_hash = hygiene_data.foreign_expn_hashes.insert(expn_id, hash);\n-        debug_assert!(_old_hash.is_none());\n-        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n-        debug_assert!(_old_id.is_none());\n-    });\n-\n-    expn_id\n+    register_expn_id(expn_data, hash)\n }\n \n // Decodes `SyntaxContext`, using the provided `HygieneDecodeContext`\n@@ -1493,7 +1483,8 @@ fn update_disambiguator(expn_id: LocalExpnId, mut ctx: impl HashStableContext) {\n         });\n     }\n \n-    let expn_hash = ExpnHash(expn_hash);\n+    let expn_hash =\n+        ExpnHash::new(ctx.def_path_hash(LOCAL_CRATE.as_def_id()).stable_crate_id(), expn_hash);\n     HygieneData::with(|data| {\n         data.local_expn_data[expn_id].as_mut().unwrap().disambiguator = disambiguator;\n         debug_assert_eq!(data.local_expn_hashes[expn_id].0, Fingerprint::ZERO);"}]}