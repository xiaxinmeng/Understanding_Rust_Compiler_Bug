{"sha": "a6b64be8b51d680ca8185e519be81937c1a98ed0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YjY0YmU4YjUxZDY4MGNhODE4NWU1MTliZTgxOTM3YzFhOThlZDA=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-10-22T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-10-26T09:33:39Z"}, "message": "simplify-locals: Unify use count visitors\n\nThe simplify locals implementation uses two different visitors to update\nthe locals use counts. The DeclMarker calculates the initial use counts.\nThe StatementDeclMarker updates the use counts as statements are being\nremoved from the block.\n\nReplace them with a single visitor that can operate in either mode,\nensuring consistency of behaviour.\n\nAdditionally use exhaustive match to clarify what is being optimized.\n\nNo functional changes intended.", "tree": {"sha": "43204d3b708d77a6f994cc7e1603a98d324798dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43204d3b708d77a6f994cc7e1603a98d324798dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6b64be8b51d680ca8185e519be81937c1a98ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b64be8b51d680ca8185e519be81937c1a98ed0", "html_url": "https://github.com/rust-lang/rust/commit/a6b64be8b51d680ca8185e519be81937c1a98ed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6b64be8b51d680ca8185e519be81937c1a98ed0/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11269536e294a497b9991382cc9afda1b6ab9de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/11269536e294a497b9991382cc9afda1b6ab9de0", "html_url": "https://github.com/rust-lang/rust/commit/11269536e294a497b9991382cc9afda1b6ab9de0"}], "stats": {"total": 224, "additions": 111, "deletions": 113}, "files": [{"sha": "f4ba297b5702c94cb67752fc7d0af188769415a3", "filename": "compiler/rustc_mir/src/transform/simplify.rs", "status": "modified", "additions": 111, "deletions": 113, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/a6b64be8b51d680ca8185e519be81937c1a98ed0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b64be8b51d680ca8185e519be81937c1a98ed0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs?ref=a6b64be8b51d680ca8185e519be81937c1a98ed0", "patch": "@@ -35,6 +35,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use smallvec::SmallVec;\n use std::borrow::Cow;\n+use std::convert::TryInto;\n \n pub struct SimplifyCfg {\n     label: String,\n@@ -322,23 +323,15 @@ impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n         trace!(\"running SimplifyLocals on {:?}\", body.source);\n \n         // First, we're going to get a count of *actual* uses for every `Local`.\n-        // Take a look at `DeclMarker::visit_local()` to see exactly what is ignored.\n-        let mut used_locals = {\n-            let mut marker = DeclMarker::new(body);\n-            marker.visit_body(&body);\n-\n-            marker.local_counts\n-        };\n-\n-        let arg_count = body.arg_count;\n+        let mut used_locals = UsedLocals::new(body);\n \n         // Next, we're going to remove any `Local` with zero actual uses. When we remove those\n         // `Locals`, we're also going to subtract any uses of other `Locals` from the `used_locals`\n         // count. For example, if we removed `_2 = discriminant(_1)`, then we'll subtract one from\n         // `use_counts[_1]`. That in turn might make `_1` unused, so we loop until we hit a\n         // fixedpoint where there are no more unused locals.\n         loop {\n-            let mut remove_statements = RemoveStatements::new(&mut used_locals, arg_count, tcx);\n+            let mut remove_statements = RemoveStatements::new(&mut used_locals, tcx);\n             remove_statements.visit_body(body);\n \n             if !remove_statements.modified {\n@@ -347,7 +340,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n         }\n \n         // Finally, we'll actually do the work of shrinking `body.local_decls` and remapping the `Local`s.\n-        let map = make_local_map(&mut body.local_decls, used_locals, arg_count);\n+        let map = make_local_map(&mut body.local_decls, &used_locals);\n \n         // Only bother running the `LocalUpdater` if we actually found locals to remove.\n         if map.iter().any(Option::is_none) {\n@@ -363,14 +356,14 @@ impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n fn make_local_map<V>(\n     local_decls: &mut IndexVec<Local, V>,\n-    used_locals: IndexVec<Local, u32>,\n-    arg_count: usize,\n+    used_locals: &UsedLocals,\n ) -> IndexVec<Local, Option<Local>> {\n     let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*local_decls);\n     let mut used = Local::new(0);\n-    for (alive_index, count) in used_locals.iter_enumerated() {\n-        // The `RETURN_PLACE` and arguments are always live.\n-        if alive_index.as_usize() > arg_count && *count == 0 {\n+\n+    for alive_index in local_decls.indices() {\n+        // `is_used` treats the `RETURN_PLACE` and arguments as used.\n+        if !used_locals.is_used(alive_index) {\n             continue;\n         }\n \n@@ -384,115 +377,125 @@ fn make_local_map<V>(\n     map\n }\n \n-struct DeclMarker<'a, 'tcx> {\n-    pub local_counts: IndexVec<Local, u32>,\n-    pub body: &'a Body<'tcx>,\n+/// Keeps track of used & unused locals.\n+struct UsedLocals {\n+    increment: bool,\n+    arg_count: u32,\n+    use_count: IndexVec<Local, u32>,\n }\n \n-impl<'a, 'tcx> DeclMarker<'a, 'tcx> {\n-    pub fn new(body: &'a Body<'tcx>) -> Self {\n-        Self { local_counts: IndexVec::from_elem(0, &body.local_decls), body }\n+impl UsedLocals {\n+    /// Determines which locals are used & unused in the given body.\n+    fn new(body: &Body<'_>) -> Self {\n+        let mut this = Self {\n+            increment: true,\n+            arg_count: body.arg_count.try_into().unwrap(),\n+            use_count: IndexVec::from_elem(0, &body.local_decls),\n+        };\n+        this.visit_body(body);\n+        this\n     }\n-}\n \n-impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n-    fn visit_local(&mut self, local: &Local, ctx: PlaceContext, location: Location) {\n-        // Ignore storage markers altogether, they get removed along with their otherwise unused\n-        // decls.\n-        // FIXME: Extend this to all non-uses.\n-        if ctx.is_storage_marker() {\n-            return;\n-        }\n+    /// Checks if local is used.\n+    ///\n+    /// Return place and arguments are always considered used.\n+    fn is_used(&self, local: Local) -> bool {\n+        trace!(\"is_used({:?}): use_count: {:?}\", local, self.use_count[local]);\n+        local.as_u32() <= self.arg_count || self.use_count[local] != 0\n+    }\n \n-        // Ignore stores of constants because `ConstProp` and `CopyProp` can remove uses of many\n-        // of these locals. However, if the local is still needed, then it will be referenced in\n-        // another place and we'll mark it as being used there.\n-        if ctx == PlaceContext::MutatingUse(MutatingUseContext::Store)\n-            || ctx == PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-        {\n-            let block = &self.body.basic_blocks()[location.block];\n-            if location.statement_index != block.statements.len() {\n-                let stmt = &block.statements[location.statement_index];\n-\n-                if let StatementKind::Assign(box (dest, rvalue)) = &stmt.kind {\n-                    if !dest.is_indirect() && dest.local == *local {\n-                        let can_skip = match rvalue {\n-                            Rvalue::Use(_)\n-                            | Rvalue::Discriminant(_)\n-                            | Rvalue::BinaryOp(_, _, _)\n-                            | Rvalue::CheckedBinaryOp(_, _, _)\n-                            | Rvalue::Repeat(_, _)\n-                            | Rvalue::AddressOf(_, _)\n-                            | Rvalue::Len(_)\n-                            | Rvalue::UnaryOp(_, _)\n-                            | Rvalue::Aggregate(_, _) => true,\n-\n-                            _ => false,\n-                        };\n-\n-                        if can_skip {\n-                            trace!(\"skipping store of {:?} to {:?}\", rvalue, dest);\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+    /// Updates the use counts to reflect the removal of given statement.\n+    fn statement_removed(&mut self, statement: &Statement<'tcx>) {\n+        self.increment = false;\n \n-        self.local_counts[*local] += 1;\n+        // The location of the statement is irrelevant.\n+        let location = Location { block: START_BLOCK, statement_index: 0 };\n+        self.visit_statement(statement, location);\n     }\n-}\n-\n-struct StatementDeclMarker<'a, 'tcx> {\n-    used_locals: &'a mut IndexVec<Local, u32>,\n-    statement: &'a Statement<'tcx>,\n-}\n \n-impl<'a, 'tcx> StatementDeclMarker<'a, 'tcx> {\n-    pub fn new(\n-        used_locals: &'a mut IndexVec<Local, u32>,\n-        statement: &'a Statement<'tcx>,\n-    ) -> Self {\n-        Self { used_locals, statement }\n+    /// Visits a left-hand side of an assignment.\n+    fn visit_lhs(&mut self, place: &Place<'tcx>, location: Location) {\n+        if place.is_indirect() {\n+            // A use, not a definition.\n+            self.visit_place(place, PlaceContext::MutatingUse(MutatingUseContext::Store), location);\n+        } else {\n+            // A definition. Although, it still might use other locals for indexing.\n+            self.super_projection(\n+                place.local,\n+                &place.projection,\n+                PlaceContext::MutatingUse(MutatingUseContext::Projection),\n+                location,\n+            );\n+        }\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for StatementDeclMarker<'a, 'tcx> {\n-    fn visit_local(&mut self, local: &Local, context: PlaceContext, _location: Location) {\n-        // Skip the lvalue for assignments\n-        if let StatementKind::Assign(box (p, _)) = self.statement.kind {\n-            if p.local == *local && context.is_place_assignment() {\n-                return;\n+impl Visitor<'_> for UsedLocals {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match statement.kind {\n+            StatementKind::LlvmInlineAsm(..)\n+            | StatementKind::SetDiscriminant { .. } // FIXME: Try to remove those as well.\n+            | StatementKind::Retag(..)\n+            | StatementKind::Coverage(..)\n+            | StatementKind::FakeRead(..)\n+            | StatementKind::AscribeUserType(..) => {\n+                self.super_statement(statement, location);\n+            }\n+\n+            StatementKind::Nop => {}\n+\n+            StatementKind::StorageLive(_local) | StatementKind::StorageDead(_local) => {}\n+\n+            StatementKind::Assign(box (ref place, ref rvalue)) => {\n+                let can_skip = match rvalue {\n+                    Rvalue::Use(_)\n+                    | Rvalue::Discriminant(_)\n+                    | Rvalue::BinaryOp(_, _, _)\n+                    | Rvalue::CheckedBinaryOp(_, _, _)\n+                    | Rvalue::Repeat(_, _)\n+                    | Rvalue::AddressOf(_, _)\n+                    | Rvalue::Len(_)\n+                    | Rvalue::UnaryOp(_, _)\n+                    | Rvalue::Aggregate(_, _) => true,\n+\n+                    Rvalue::Ref(..)\n+                    | Rvalue::ThreadLocalRef(..)\n+                    | Rvalue::Cast(..)\n+                    | Rvalue::NullaryOp(..) => false,\n+                };\n+                if can_skip {\n+                    self.visit_lhs(place, location);\n+                } else {\n+                    self.visit_place(\n+                        place,\n+                        PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                        location,\n+                    );\n+                }\n+                self.visit_rvalue(rvalue, location);\n             }\n         }\n+    }\n \n-        let use_count = &mut self.used_locals[*local];\n-        // If this is the local we're removing...\n-        if *use_count != 0 {\n-            *use_count -= 1;\n+    fn visit_local(&mut self, local: &Local, _ctx: PlaceContext, _location: Location) {\n+        if self.increment {\n+            self.use_count[*local] += 1;\n+        } else {\n+            assert_ne!(self.use_count[*local], 0);\n+            self.use_count[*local] -= 1;\n         }\n     }\n }\n \n struct RemoveStatements<'a, 'tcx> {\n-    used_locals: &'a mut IndexVec<Local, u32>,\n-    arg_count: usize,\n+    used_locals: &'a mut UsedLocals,\n     tcx: TyCtxt<'tcx>,\n     modified: bool,\n }\n \n impl<'a, 'tcx> RemoveStatements<'a, 'tcx> {\n-    fn new(\n-        used_locals: &'a mut IndexVec<Local, u32>,\n-        arg_count: usize,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Self {\n-        Self { used_locals, arg_count, tcx, modified: false }\n-    }\n-\n-    fn keep_local(&self, l: Local) -> bool {\n-        trace!(\"keep_local({:?}): count: {:?}\", l, self.used_locals[l]);\n-        l.as_usize() <= self.arg_count || self.used_locals[l] != 0\n+    fn new(used_locals: &'a mut UsedLocals, tcx: TyCtxt<'tcx>) -> Self {\n+        Self { used_locals, tcx, modified: false }\n     }\n }\n \n@@ -503,26 +506,21 @@ impl<'a, 'tcx> MutVisitor<'tcx> for RemoveStatements<'a, 'tcx> {\n \n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n-        let mut i = 0usize;\n-        data.statements.retain(|stmt| {\n-            let keep = match &stmt.kind {\n-                StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n-                    self.keep_local(*l)\n+        data.statements.retain(|statement| {\n+            let keep = match &statement.kind {\n+                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+                    self.used_locals.is_used(*local)\n                 }\n-                StatementKind::Assign(box (place, _)) => self.keep_local(place.local),\n+                StatementKind::Assign(box (place, _)) => self.used_locals.is_used(place.local),\n                 _ => true,\n             };\n \n             if !keep {\n-                trace!(\"removing statement {:?}\", stmt);\n+                trace!(\"removing statement {:?}\", statement);\n                 self.modified = true;\n-\n-                let mut visitor = StatementDeclMarker::new(self.used_locals, stmt);\n-                visitor.visit_statement(stmt, Location { block, statement_index: i });\n+                self.used_locals.statement_removed(statement);\n             }\n \n-            i += 1;\n-\n             keep\n         });\n "}]}