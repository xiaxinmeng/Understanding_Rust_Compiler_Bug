{"sha": "047bec69b9ec54d400b1e255c8757bff8a5a854d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0N2JlYzY5YjllYzU0ZDQwMGIxZTI1NWM4NzU3YmZmOGE1YTg1NGQ=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-03-03T22:44:06Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-03-09T18:53:35Z"}, "message": "mir dataflow: change graphviz output\n\nThe new output format is perhaps a little more readable. As a bonus, we get\nlabels on the outgoing edges to more easily corroborate the dataflow with the\nplain MIR graphviz output.", "tree": {"sha": "08b1913ea9a61727a5b1cbd4ef271825a96f737e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b1913ea9a61727a5b1cbd4ef271825a96f737e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/047bec69b9ec54d400b1e255c8757bff8a5a854d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/047bec69b9ec54d400b1e255c8757bff8a5a854d", "html_url": "https://github.com/rust-lang/rust/commit/047bec69b9ec54d400b1e255c8757bff8a5a854d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/047bec69b9ec54d400b1e255c8757bff8a5a854d/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "138365368a71a04ff9539704f478b014379b7ee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/138365368a71a04ff9539704f478b014379b7ee5", "html_url": "https://github.com/rust-lang/rust/commit/138365368a71a04ff9539704f478b014379b7ee5"}], "stats": {"total": 291, "additions": 149, "deletions": 142}, "files": [{"sha": "d8c366d2413d9cf15975eb67bf64feb49b5de58f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/047bec69b9ec54d400b1e255c8757bff8a5a854d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047bec69b9ec54d400b1e255c8757bff8a5a854d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=047bec69b9ec54d400b1e255c8757bff8a5a854d", "patch": "@@ -711,6 +711,12 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n+impl<'a> IntoCow<'a, str> for Cow<'a, str> {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        self\n+    }\n+}\n+\n impl<'a, T: Clone> IntoCow<'a, [T]> for Vec<T> {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)"}, {"sha": "0305e4c93b6a0374bb832e1e8782e56b5f584db0", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 143, "deletions": 142, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/047bec69b9ec54d400b1e255c8757bff8a5a854d/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047bec69b9ec54d400b1e255c8757bff8a5a854d/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=047bec69b9ec54d400b1e255c8757bff8a5a854d", "patch": "@@ -20,12 +20,9 @@ use dot::IntoCow;\n \n use std::fs;\n use std::io;\n-use std::io::prelude::*;\n use std::marker::PhantomData;\n use std::path::Path;\n \n-use util;\n-\n use super::{BitDenotation, DataflowState};\n use super::DataflowBuilder;\n use super::DebugFormatted;\n@@ -98,157 +95,161 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     }\n \n     fn node_label(&self, n: &Node) -> dot::LabelText {\n-        // A standard MIR label, as generated by write_node_label, is\n-        // presented in a single column in a table.\n-        //\n-        // The code below does a bunch of formatting work to format a\n-        // node (i.e. MIR basic-block) label with extra\n-        // dataflow-enriched information.  In particular, the goal is\n-        // to add extra columns that present the three dataflow\n-        // bitvectors, and the data those bitvectors represent.\n-        //\n-        // It presents it in the following format (where I am\n-        // presenting the table rendering via ASCII art, one line per\n-        // row of the table, and a chunk size of 3 rather than 5):\n-        //\n-        // ------  -----------------------  ------------  --------------------\n-        //                    [e1, e3, e4]\n-        //             [e8, e9] \"= ENTRY:\"  <ENTRY-BITS>\n-        // ------  -----------------------  ------------  --------------------\n-        // Left\n-        // Most\n-        // Column\n-        // Is\n-        // Just\n-        // Normal\n-        // Series\n-        // Of\n-        // MIR\n-        // Stmts\n-        // ------  -----------------------  ------------  --------------------\n-        //           [g1, g4, g5] \"= GEN:\"  <GEN-BITS>\n-        // ------  -----------------------  ------------  --------------------\n-        //                         \"KILL:\"  <KILL-BITS>   \"=\" [k1, k3, k8]\n-        //                                                [k9]\n-        // ------  -----------------------  ------------  --------------------\n-        //\n-        // (In addition, the added dataflow is rendered with a colored\n-        // background just so it will stand out compared to the\n-        // statements.)\n+        // Node label is something like this:\n+        // +---------+----------------------------------+------------------+------------------+\n+        // | ENTRY   | MIR                              | GEN              | KILL             |\n+        // +---------+----------------------------------+------------------+------------------+\n+        // |         |  0: StorageLive(_7)              | bb3[2]: reserved | bb2[0]: reserved |\n+        // |         |  1: StorageLive(_8)              | bb3[2]: active   | bb2[0]: active   |\n+        // |         |  2: _8 = &mut _1                 |                  | bb4[2]: reserved |\n+        // |         |                                  |                  | bb4[2]: active   |\n+        // |         |                                  |                  | bb9[0]: reserved |\n+        // |         |                                  |                  | bb9[0]: active   |\n+        // |         |                                  |                  | bb10[0]: reserved|\n+        // |         |                                  |                  | bb10[0]: active  |\n+        // |         |                                  |                  | bb11[0]: reserved|\n+        // |         |                                  |                  | bb11[0]: active  |\n+        // +---------+----------------------------------+------------------+------------------+\n+        // | [00-00] | _7 = const Foo::twiddle(move _8) | [0c-00]          | [f3-0f]          |\n+        // +---------+----------------------------------+------------------+------------------+ \n         let mut v = Vec::new();\n+        self.node_label_internal(n, &mut v, *n, self.mbcx.mir()).unwrap();\n+        dot::LabelText::html(String::from_utf8(v).unwrap())\n+    }\n+\n+\n+    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+\n+    fn edge_label(&'a self, e: &Edge) -> dot::LabelText<'a> {\n+        let term = self.mbcx.mir()[e.source].terminator();\n+        let label = &term.kind.fmt_successor_labels()[e.index];\n+        dot::LabelText::label(label.clone())\n+    }\n+}\n+\n+impl<'a, 'tcx, MWF, P> Graph<'a, 'tcx, MWF, P>\n+where MWF: MirWithFlowState<'tcx>,\n+      P: Fn(&MWF::BD, <MWF::BD as BitDenotation>::Idx) -> DebugFormatted,\n+{\n+    /// Generate the node label\n+    fn node_label_internal<W: io::Write>(&self,\n+                                         n: &Node,\n+                                         w: &mut W,\n+                                         block: BasicBlock,\n+                                         mir: &Mir) -> io::Result<()> {\n+        // Header rows\n+        const HDRS: [&'static str; 4] = [\"ENTRY\", \"MIR\", \"GEN\", \"KILL\"];\n+        const HDR_FMT: &'static str = \"bgcolor=\\\"grey\\\"\";\n+        write!(w, \"<table><tr><td rowspan=\\\"{}\\\">\", HDRS.len())?;\n+        write!(w, \"{:?}\", block.index())?;\n+        write!(w, \"</td></tr><tr>\")?;\n+        for hdr in &HDRS {\n+            write!(w, \"<td {}>{}</td>\", HDR_FMT, hdr)?;\n+        }\n+        write!(w, \"</tr>\")?;\n+\n+        // Data row\n+        self.node_label_verbose_row(n, w, block, mir)?;\n+        self.node_label_final_row(n, w, block, mir)?;\n+        write!(w, \"</table>\")?;\n+\n+        Ok(())\n+    }\n+\n+    /// Build the verbose row: full MIR data, and detailed gen/kill/entry sets\n+    fn node_label_verbose_row<W: io::Write>(&self,\n+                                            n: &Node,\n+                                            w: &mut W,\n+                                            block: BasicBlock,\n+                                            mir: &Mir)\n+                                            -> io::Result<()> {\n         let i = n.index();\n-        let chunk_size = 5;\n-        const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n-        const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n-        const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n-        fn chunked_present_left<W:io::Write>(w: &mut W,\n-                                             interpreted: &[DebugFormatted],\n-                                             chunk_size: usize)\n-                                             -> io::Result<()>\n-        {\n-            // This function may emit a sequence of <tr>'s, but it\n-            // always finishes with an (unfinished)\n-            // <tr><td></td><td>\n-            //\n-            // Thus, after being called, one should finish both the\n-            // pending <td> as well as the <tr> itself.\n-            let mut seen_one = false;\n-            for c in interpreted.chunks(chunk_size) {\n-                if seen_one {\n-                    // if not the first row, finish off the previous row\n-                    write!(w, \"</td><td></td><td></td></tr>\")?;\n+\n+        macro_rules! dump_set_for {\n+            ($set:ident) => {\n+                write!(w, \"<td>\")?;\n+\n+                let flow = self.mbcx.flow_state();\n+                let entry_interp = flow.interpret_set(&flow.operator,\n+                                                      flow.sets.$set(i),\n+                                                      &self.render_idx);\n+                for e in &entry_interp {\n+                    write!(w, \"{:?}<br/>\", e)?;\n                 }\n-                write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT,\n-                       objs = c)?;\n-                seen_one = true;\n+                write!(w, \"</td>\")?;\n             }\n-            if !seen_one {\n-                write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT)?;\n+        }\n+\n+        write!(w, \"<tr>\")?;\n+        // Entry\n+        dump_set_for!(on_entry_set_for);\n+\n+        // MIR statements\n+        write!(w, \"<td>\")?;\n+        {\n+            let data = &mir[block];\n+            for (i, statement) in data.statements.iter().enumerate() {\n+                write!(w, \"{}<br align=\\\"left\\\"/>\",\n+                       dot::escape_html(&format!(\"{:3}: {:?}\", i, statement)))?;\n             }\n-            Ok(())\n         }\n-        util::write_graphviz_node_label(\n-            *n, self.mbcx.mir(), &mut v, 4,\n-            |w| {\n-                let flow = self.mbcx.flow_state();\n-                let entry_interp = flow.interpret_set(&flow.operator,\n-                                                      flow.sets.on_entry_set_for(i),\n-                                                      &self.render_idx);\n-                chunked_present_left(w, &entry_interp[..], chunk_size)?;\n-                let bits_per_block = flow.sets.bits_per_block();\n-                let entry = flow.sets.on_entry_set_for(i);\n-                debug!(\"entry set for i={i} bits_per_block: {bpb} entry: {e:?} interp: {ei:?}\",\n-                       i=i, e=entry, bpb=bits_per_block, ei=entry_interp);\n-                write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n-                                        <td></td></tr>\",\n-                       bg = BG_FLOWCONTENT,\n-                       face = FACE_MONOSPACE,\n-                       entrybits=bits_to_string(entry.words(), bits_per_block))\n-            },\n-            |w| {\n+        write!(w, \"</td>\")?;\n+\n+        // Gen\n+        dump_set_for!(gen_set_for);\n+\n+        // Kill\n+        dump_set_for!(kill_set_for);\n+\n+        write!(w, \"</tr>\")?;\n+\n+        Ok(())\n+    }\n+\n+    /// Build the summary row: terminator, gen/kill/entry bit sets\n+    fn node_label_final_row<W: io::Write>(&self,\n+                                          n: &Node,\n+                                          w: &mut W,\n+                                          block: BasicBlock,\n+                                          mir: &Mir)\n+                                          -> io::Result<()> {\n+        let i = n.index();\n+\n+        macro_rules! dump_set_for {\n+            ($set:ident) => {\n                 let flow = self.mbcx.flow_state();\n-                let gen_interp =\n-                    flow.interpret_set(&flow.operator, flow.sets.gen_set_for(i), &self.render_idx);\n-                let kill_interp =\n-                    flow.interpret_set(&flow.operator, flow.sets.kill_set_for(i), &self.render_idx);\n-                chunked_present_left(w, &gen_interp[..], chunk_size)?;\n                 let bits_per_block = flow.sets.bits_per_block();\n-                {\n-                    let gen = flow.sets.gen_set_for(i);\n-                    debug!(\"gen set for i={i} bits_per_block: {bpb} gen: {g:?} interp: {gi:?}\",\n-                           i=i, g=gen, bpb=bits_per_block, gi=gen_interp);\n-                    write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n-                                           <td></td></tr>\",\n-                           bg = BG_FLOWCONTENT,\n-                           face = FACE_MONOSPACE,\n-                           genbits=bits_to_string(gen.words(), bits_per_block))?;\n-                }\n+                let set = flow.sets.$set(i);\n+                write!(w, \"<td>{:?}</td>\",\n+                       dot::escape_html(&bits_to_string(set.words(), bits_per_block)))?;\n+            }\n+        }\n \n-                {\n-                    let kill = flow.sets.kill_set_for(i);\n-                    debug!(\"kill set for i={i} bits_per_block: {bpb} kill: {k:?} interp: {ki:?}\",\n-                           i=i, k=kill, bpb=bits_per_block, ki=kill_interp);\n-                    write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n-                                            <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n-                           bg = BG_FLOWCONTENT,\n-                           align = ALIGN_RIGHT,\n-                           face = FACE_MONOSPACE,\n-                           killbits=bits_to_string(kill.words(), bits_per_block))?;\n-                }\n+        write!(w, \"<tr>\")?;\n+        // Entry\n+        dump_set_for!(on_entry_set_for);\n \n-                // (chunked_present_right)\n-                let mut seen_one = false;\n-                for k in kill_interp.chunks(chunk_size) {\n-                    if !seen_one {\n-                        // continuation of row; this is fourth <td>\n-                        write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n-                               bg = BG_FLOWCONTENT,\n-                               kill=k)?;\n-                    } else {\n-                        // new row, with indent of three <td>'s\n-                        write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n-                               bg = BG_FLOWCONTENT,\n-                               kill=k)?;\n-                    }\n-                    seen_one = true;\n-                }\n-                if !seen_one {\n-                    write!(w, \"<td {bg}>= []</td></tr>\",\n-                           bg = BG_FLOWCONTENT)?;\n-                }\n+        // Terminator\n+        write!(w, \"<td>\")?;\n+        {\n+            let data = &mir[block];\n+            let mut terminator_head = String::new();\n+            data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n+            write!(w, \"{}\", dot::escape_html(&terminator_head))?;\n+        }\n+        write!(w, \"</td>\")?;\n \n-                Ok(())\n-            })\n-            .unwrap();\n-        dot::LabelText::html(String::from_utf8(v).unwrap())\n-    }\n+        // Gen\n+        dump_set_for!(gen_set_for);\n \n-    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n-        Some(dot::LabelText::label(\"none\"))\n+        // Kill\n+        dump_set_for!(kill_set_for);\n+\n+        write!(w, \"</tr>\")?;\n+\n+        Ok(())\n     }\n }\n "}]}