{"sha": "58e15d12e4211306273b0128cb4a80b552889543", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZTE1ZDEyZTQyMTEzMDYyNzNiMDEyOGNiNGE4MGI1NTI4ODk1NDM=", "commit": {"author": {"name": "Dmitry", "email": "mamhigtt@gmail.com", "date": "2020-02-16T17:36:48Z"}, "committer": {"name": "Dmitry", "email": "mamhigtt@gmail.com", "date": "2020-02-16T17:36:48Z"}, "message": "Merge remote-tracking branch 'origin/master'", "tree": {"sha": "70e129b7cd76c55d5cb86f9b084db001f73a2003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70e129b7cd76c55d5cb86f9b084db001f73a2003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58e15d12e4211306273b0128cb4a80b552889543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58e15d12e4211306273b0128cb4a80b552889543", "html_url": "https://github.com/rust-lang/rust/commit/58e15d12e4211306273b0128cb4a80b552889543", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58e15d12e4211306273b0128cb4a80b552889543/comments", "author": {"login": "godcodehunter", "id": 22272886, "node_id": "MDQ6VXNlcjIyMjcyODg2", "avatar_url": "https://avatars.githubusercontent.com/u/22272886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/godcodehunter", "html_url": "https://github.com/godcodehunter", "followers_url": "https://api.github.com/users/godcodehunter/followers", "following_url": "https://api.github.com/users/godcodehunter/following{/other_user}", "gists_url": "https://api.github.com/users/godcodehunter/gists{/gist_id}", "starred_url": "https://api.github.com/users/godcodehunter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/godcodehunter/subscriptions", "organizations_url": "https://api.github.com/users/godcodehunter/orgs", "repos_url": "https://api.github.com/users/godcodehunter/repos", "events_url": "https://api.github.com/users/godcodehunter/events{/privacy}", "received_events_url": "https://api.github.com/users/godcodehunter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "godcodehunter", "id": 22272886, "node_id": "MDQ6VXNlcjIyMjcyODg2", "avatar_url": "https://avatars.githubusercontent.com/u/22272886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/godcodehunter", "html_url": "https://github.com/godcodehunter", "followers_url": "https://api.github.com/users/godcodehunter/followers", "following_url": "https://api.github.com/users/godcodehunter/following{/other_user}", "gists_url": "https://api.github.com/users/godcodehunter/gists{/gist_id}", "starred_url": "https://api.github.com/users/godcodehunter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/godcodehunter/subscriptions", "organizations_url": "https://api.github.com/users/godcodehunter/orgs", "repos_url": "https://api.github.com/users/godcodehunter/repos", "events_url": "https://api.github.com/users/godcodehunter/events{/privacy}", "received_events_url": "https://api.github.com/users/godcodehunter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b446384956243ce6bdcef2a869123a2605e597ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b446384956243ce6bdcef2a869123a2605e597ed", "html_url": "https://github.com/rust-lang/rust/commit/b446384956243ce6bdcef2a869123a2605e597ed"}, {"sha": "742b3b5744fbca1a5587e2898cd5b74d55853a47", "url": "https://api.github.com/repos/rust-lang/rust/commits/742b3b5744fbca1a5587e2898cd5b74d55853a47", "html_url": "https://github.com/rust-lang/rust/commit/742b3b5744fbca1a5587e2898cd5b74d55853a47"}], "stats": {"total": 2678, "additions": 1415, "deletions": 1263}, "files": [{"sha": "eae4fbcb5f26f52f5045576304af7c7b50143f98", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -190,4 +190,4 @@ jobs:\n       - name: Publish Extension\n         working-directory: ./editors/code\n         # token from https://dev.azure.com/rust-analyzer/\n-        run: ./node_modules/vsce/out/vsce publish 0.1.$(date +%Y%m%d) --pat ${{ secrets.MARKETPLACE_TOKEN }}\n+        run: npx vsce publish 0.1.$(date +%Y%m%d) --pat ${{ secrets.MARKETPLACE_TOKEN }}"}, {"sha": "f44e514dd184d02f12d921d14b59dd1ed7e18315", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -1015,6 +1015,7 @@ name = \"ra_cli\"\n version = \"0.1.0\"\n dependencies = [\n  \"env_logger\",\n+ \"itertools\",\n  \"pico-args\",\n  \"ra_batch\",\n  \"ra_db\",\n@@ -1024,6 +1025,7 @@ dependencies = [\n  \"ra_ide\",\n  \"ra_prof\",\n  \"ra_syntax\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]\n@@ -1174,7 +1176,6 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n- \"rand 0.7.3\",\n  \"rayon\",\n  \"rustc-hash\",\n  \"superslice\","}, {"sha": "c034e24244e0bab26c76b40c6280a17665c3c739", "filename": "Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -31,3 +31,8 @@ opt-level = 0\n \n [patch.'crates-io']\n # rowan = { path = \"../rowan\" }\n+\n+[patch.'https://github.com/rust-lang/chalk.git']\n+# chalk-solve = { path = \"../chalk/chalk-solve\" }\n+# chalk-rust-ir = { path = \"../chalk/chalk-rust-ir\" }\n+# chalk-ir = { path = \"../chalk/chalk-ir\" }"}, {"sha": "53d4876f643c0d826d5266fe3d731b6c09886afd", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -6,8 +6,10 @@ authors = [\"rust-analyzer developers\"]\n publish = false\n \n [dependencies]\n+itertools = \"0.8.0\"\n pico-args = \"0.3.0\"\n env_logger = { version = \"0.7.1\", default-features = false }\n+rand = { version = \"0.7.0\", features = [\"small_rng\"] }\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide = { path = \"../ra_ide\" }"}, {"sha": "764df6b9efd60ce610d743cab93ef6040eab2e07", "filename": "crates/ra_cli/src/analysis_bench.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2Fsrc%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2Fsrc%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_bench.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -20,6 +20,8 @@ pub(crate) enum Op {\n }\n \n pub(crate) fn run(verbose: bool, path: &Path, op: Op) -> Result<()> {\n+    ra_prof::init();\n+\n     let start = Instant::now();\n     eprint!(\"loading: \");\n     let (mut host, roots) = ra_batch::load_cargo(path)?;"}, {"sha": "6d2dd34c64829c1b612b47517d0c8f7d851e34bf", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -2,6 +2,9 @@\n \n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n+use itertools::Itertools;\n+use rand::{seq::SliceRandom, thread_rng};\n+\n use hir::{\n     db::{DefDatabase, HirDatabase},\n     AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n@@ -19,6 +22,7 @@ pub fn run(\n     path: &Path,\n     only: Option<&str>,\n     with_deps: bool,\n+    randomize: bool,\n ) -> Result<()> {\n     let db_load_time = Instant::now();\n     let (mut host, roots) = ra_batch::load_cargo(path)?;\n@@ -41,7 +45,11 @@ pub fn run(\n             })\n             .collect::<HashSet<_>>();\n \n-    for krate in Crate::all(db) {\n+    let mut krates = Crate::all(db);\n+    if randomize {\n+        krates.shuffle(&mut thread_rng());\n+    }\n+    for krate in krates {\n         let module = krate.root_module(db).expect(\"crate without root module\");\n         let file_id = module.definition_source(db).file_id;\n         if members.contains(&db.file_source_root(file_id.original_file(db))) {\n@@ -50,6 +58,10 @@ pub fn run(\n         }\n     }\n \n+    if randomize {\n+        visit_queue.shuffle(&mut thread_rng());\n+    }\n+\n     println!(\"Crates in this dir: {}\", num_crates);\n     let mut num_decls = 0;\n     let mut funcs = Vec::new();\n@@ -79,10 +91,14 @@ pub fn run(\n     println!(\"Total functions: {}\", funcs.len());\n     println!(\"Item Collection: {:?}, {}\", analysis_time.elapsed(), ra_prof::memory_usage());\n \n+    if randomize {\n+        funcs.shuffle(&mut thread_rng());\n+    }\n+\n     let inference_time = Instant::now();\n     let mut bar = match verbosity {\n-        Verbosity::Verbose | Verbosity::Normal => ProgressReport::new(funcs.len() as u64),\n-        Verbosity::Quiet => ProgressReport::hidden(),\n+        Verbosity::Quiet | Verbosity::Spammy => ProgressReport::hidden(),\n+        _ => ProgressReport::new(funcs.len() as u64),\n     };\n \n     bar.tick();\n@@ -92,23 +108,36 @@ pub fn run(\n     let mut num_type_mismatches = 0;\n     for f in funcs {\n         let name = f.name(db);\n-        let mut msg = format!(\"processing: {}\", name);\n+        let full_name = f\n+            .module(db)\n+            .path_to_root(db)\n+            .into_iter()\n+            .rev()\n+            .filter_map(|it| it.name(db))\n+            .chain(Some(f.name(db)))\n+            .join(\"::\");\n+        if let Some(only_name) = only {\n+            if name.to_string() != only_name && full_name != only_name {\n+                continue;\n+            }\n+        }\n+        let mut msg = format!(\"processing: {}\", full_name);\n         if verbosity.is_verbose() {\n             let src = f.source(db);\n             let original_file = src.file_id.original_file(db);\n             let path = db.file_relative_path(original_file);\n             let syntax_range = src.value.syntax().text_range();\n             write!(msg, \" ({:?} {})\", path, syntax_range).unwrap();\n         }\n-        bar.set_message(&msg);\n-        if let Some(only_name) = only {\n-            if name.to_string() != only_name {\n-                continue;\n-            }\n+        if verbosity.is_spammy() {\n+            bar.println(format!(\"{}\", msg));\n         }\n+        bar.set_message(&msg);\n         let f_id = FunctionId::from(f);\n         let body = db.body(f_id.into());\n         let inference_result = db.infer(f_id.into());\n+        let (previous_exprs, previous_unknown, previous_partially_unknown) =\n+            (num_exprs, num_exprs_unknown, num_exprs_partially_unknown);\n         for (expr_id, _) in body.exprs.iter() {\n             let ty = &inference_result[expr_id];\n             num_exprs += 1;\n@@ -125,6 +154,33 @@ pub fn run(\n                     num_exprs_partially_unknown += 1;\n                 }\n             }\n+            if only.is_some() && verbosity.is_spammy() {\n+                // in super-verbose mode for just one function, we print every single expression\n+                let (_, sm) = db.body_with_source_map(f_id.into());\n+                let src = sm.expr_syntax(expr_id);\n+                if let Some(src) = src {\n+                    let original_file = src.file_id.original_file(db);\n+                    let line_index = host.analysis().file_line_index(original_file).unwrap();\n+                    let text_range = src.value.either(\n+                        |it| it.syntax_node_ptr().range(),\n+                        |it| it.syntax_node_ptr().range(),\n+                    );\n+                    let (start, end) = (\n+                        line_index.line_col(text_range.start()),\n+                        line_index.line_col(text_range.end()),\n+                    );\n+                    bar.println(format!(\n+                        \"{}:{}-{}:{}: {}\",\n+                        start.line + 1,\n+                        start.col_utf16,\n+                        end.line + 1,\n+                        end.col_utf16,\n+                        ty.display(db)\n+                    ));\n+                } else {\n+                    bar.println(format!(\"unknown location: {}\", ty.display(db)));\n+                }\n+            }\n             if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n                 num_type_mismatches += 1;\n                 if verbosity.is_verbose() {\n@@ -164,6 +220,15 @@ pub fn run(\n                 }\n             }\n         }\n+        if verbosity.is_spammy() {\n+            bar.println(format!(\n+                \"In {}: {} exprs, {} unknown, {} partial\",\n+                full_name,\n+                num_exprs - previous_exprs,\n+                num_exprs_unknown - previous_unknown,\n+                num_exprs_partially_unknown - previous_partially_unknown\n+            ));\n+        }\n         bar.inc(1);\n     }\n     bar.finish_and_clear();"}, {"sha": "6a0e447b96786bb379788353103bcaeccdc569ba", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -16,6 +16,7 @@ type Result<T> = std::result::Result<T, Box<dyn Error + Send + Sync>>;\n \n #[derive(Clone, Copy)]\n pub enum Verbosity {\n+    Spammy,\n     Verbose,\n     Normal,\n     Quiet,\n@@ -24,7 +25,13 @@ pub enum Verbosity {\n impl Verbosity {\n     fn is_verbose(self) -> bool {\n         match self {\n-            Verbosity::Verbose => true,\n+            Verbosity::Verbose | Verbosity::Spammy => true,\n+            _ => false,\n+        }\n+    }\n+    fn is_spammy(self) -> bool {\n+        match self {\n+            Verbosity::Spammy => true,\n             _ => false,\n         }\n     }\n@@ -86,14 +93,18 @@ fn main() -> Result<()> {\n                 return Ok(());\n             }\n             let verbosity = match (\n+                matches.contains([\"-vv\", \"--spammy\"]),\n                 matches.contains([\"-v\", \"--verbose\"]),\n                 matches.contains([\"-q\", \"--quiet\"]),\n             ) {\n-                (false, false) => Verbosity::Normal,\n-                (false, true) => Verbosity::Quiet,\n-                (true, false) => Verbosity::Verbose,\n-                (true, true) => Err(\"Invalid flags: -q conflicts with -v\")?,\n+                (true, _, true) => Err(\"Invalid flags: -q conflicts with -vv\")?,\n+                (true, _, false) => Verbosity::Spammy,\n+                (false, false, false) => Verbosity::Normal,\n+                (false, false, true) => Verbosity::Quiet,\n+                (false, true, false) => Verbosity::Verbose,\n+                (false, true, true) => Err(\"Invalid flags: -q conflicts with -v\")?,\n             };\n+            let randomize = matches.contains(\"--randomize\");\n             let memory_usage = matches.contains(\"--memory-usage\");\n             let only: Option<String> = matches.opt_value_from_str([\"-o\", \"--only\"])?;\n             let with_deps: bool = matches.contains(\"--with-deps\");\n@@ -111,6 +122,7 @@ fn main() -> Result<()> {\n                 path.as_ref(),\n                 only.as_ref().map(String::as_ref),\n                 with_deps,\n+                randomize,\n             )?;\n         }\n         \"analysis-bench\" => {"}, {"sha": "b1f3f525dd1d36d5f94d8d0b90460c71c0745458", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -146,7 +146,7 @@ where\n                 ReachedFixedPoint::Yes => break,\n                 ReachedFixedPoint::No => i += 1,\n             }\n-            if i == 1000 {\n+            if i == 10000 {\n                 log::error!(\"name resolution is stuck\");\n                 break;\n             }"}, {"sha": "e2b228e80d3854280688886cb3ff2301423b3414", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -542,11 +542,7 @@ impl Resolver {\n \n     fn push_generic_params_scope(self, db: &impl DefDatabase, def: GenericDefId) -> Resolver {\n         let params = db.generic_params(def);\n-        if params.types.is_empty() {\n-            self\n-        } else {\n-            self.push_scope(Scope::GenericParams { def, params })\n-        }\n+        self.push_scope(Scope::GenericParams { def, params })\n     }\n \n     fn push_impl_block_scope(self, impl_block: ImplId) -> Resolver {"}, {"sha": "14e089cf4f437a5c6e304e7d4e0f9b703a6174d4", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 372, "deletions": 1, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -2,7 +2,12 @@\n \n use std::fmt;\n \n-use crate::db::HirDatabase;\n+use crate::{\n+    db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n+    Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+};\n+use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n+use hir_expand::name::Name;\n \n pub struct HirFormatter<'a, 'b, DB> {\n     pub db: &'a DB,\n@@ -97,3 +102,369 @@ where\n         })\n     }\n }\n+\n+const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n+\n+impl HirDisplay for &Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for ApplicationTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self.ctor {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}]\", t.display(f.db))?;\n+            }\n+            TypeCtor::Array => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}; _]\", t.display(f.db))?;\n+            }\n+            TypeCtor::RawPtr(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n+            }\n+            TypeCtor::Ref(m) => {\n+                let t = self.parameters.as_single();\n+                let ty_display = if f.omit_verbose_types() {\n+                    t.display_truncated(f.db, f.max_size)\n+                } else {\n+                    t.display(f.db)\n+                };\n+                write!(f, \"&{}{}\", m.as_keyword_for_ref(), ty_display)?;\n+            }\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple { .. } => {\n+                let ts = &self.parameters;\n+                if ts.len() == 1 {\n+                    write!(f, \"({},)\", ts[0].display(f.db))?;\n+                } else {\n+                    write!(f, \"(\")?;\n+                    f.write_joined(&*ts.0, \", \")?;\n+                    write!(f, \")\")?;\n+                }\n+            }\n+            TypeCtor::FnPtr { .. } => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n+                write!(f, \"fn(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::FnDef(def) => {\n+                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n+                let name = match def {\n+                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n+                    CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n+                    CallableDef::EnumVariantId(e) => {\n+                        let enum_data = f.db.enum_data(e.parent);\n+                        enum_data.variants[e.local_id].name.clone()\n+                    }\n+                };\n+                match def {\n+                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n+                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n+                        write!(f, \"{}\", name)?\n+                    }\n+                }\n+                if self.parameters.len() > 0 {\n+                    let generics = generics(f.db, def.into());\n+                    let (parent_params, self_param, type_params, _impl_trait_params) =\n+                        generics.provenance_split();\n+                    let total_len = parent_params + self_param + type_params;\n+                    // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n+                    if total_len > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n+                        write!(f, \">\")?;\n+                    }\n+                }\n+                write!(f, \"(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::Adt(def_id) => {\n+                let name = match def_id {\n+                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                };\n+                write!(f, \"{}\", name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+\n+                    let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n+                    let parameters_to_write = if f.omit_verbose_types() {\n+                        match self\n+                            .ctor\n+                            .as_generic_def()\n+                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .filter(|defaults| !defaults.is_empty())\n+                        {\n+                            Option::None => self.parameters.0.as_ref(),\n+                            Option::Some(default_parameters) => {\n+                                for (i, parameter) in self.parameters.iter().enumerate() {\n+                                    match (parameter, default_parameters.get(i)) {\n+                                        (&Ty::Unknown, _) | (_, None) => {\n+                                            non_default_parameters.push(parameter.clone())\n+                                        }\n+                                        (_, Some(default_parameter))\n+                                            if parameter != default_parameter =>\n+                                        {\n+                                            non_default_parameters.push(parameter.clone())\n+                                        }\n+                                        _ => (),\n+                                    }\n+                                }\n+                                &non_default_parameters\n+                            }\n+                        }\n+                    } else {\n+                        self.parameters.0.as_ref()\n+                    };\n+\n+                    f.write_joined(parameters_to_write, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_ = match type_alias.lookup(f.db).container {\n+                    AssocContainerId::TraitId(it) => it,\n+                    _ => panic!(\"not an associated type\"),\n+                };\n+                let trait_name = f.db.trait_data(trait_).name.clone();\n+                let name = f.db.type_alias_data(type_alias).name.clone();\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::Closure { .. } => {\n+                let sig = self.parameters[0]\n+                    .callable_sig(f.db)\n+                    .expect(\"first closure parameter should contain signature\");\n+                let return_type_hint = sig.ret().display(f.db);\n+                if sig.params().is_empty() {\n+                    write!(f, \"|| -> {}\", return_type_hint)?;\n+                } else if f.omit_verbose_types() {\n+                    write!(f, \"|{}| -> {}\", TYPE_HINT_TRUNCATION, return_type_hint)?;\n+                } else {\n+                    write!(f, \"|\")?;\n+                    f.write_joined(sig.params(), \", \")?;\n+                    write!(f, \"| -> {}\", return_type_hint)?;\n+                };\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for ProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        let trait_name = f.db.trait_data(self.trait_(f.db)).name.clone();\n+        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self {\n+            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n+            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n+            Ty::Placeholder(id) => {\n+                let generics = generics(f.db, id.parent);\n+                let param_data = &generics.params.types[id.local_id];\n+                match param_data.provenance {\n+                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n+                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n+                    }\n+                    TypeParamProvenance::ArgumentImplTrait => {\n+                        write!(f, \"impl \")?;\n+                        let bounds = f.db.generic_predicates_for_param(*id);\n+                        let substs = Substs::type_params_for_generics(&generics);\n+                        write_bounds_like_dyn_trait(\n+                            &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),\n+                            f,\n+                        )?;\n+                    }\n+                }\n+            }\n+            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                match self {\n+                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n+                    Ty::Opaque(_) => write!(f, \"impl \")?,\n+                    _ => unreachable!(),\n+                };\n+                write_bounds_like_dyn_trait(&predicates, f)?;\n+            }\n+            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n+            Ty::Infer(..) => write!(f, \"_\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn write_bounds_like_dyn_trait(\n+    predicates: &[GenericPredicate],\n+    f: &mut HirFormatter<impl HirDatabase>,\n+) -> fmt::Result {\n+    // Note: This code is written to produce nice results (i.e.\n+    // corresponding to surface Rust) for types that can occur in\n+    // actual Rust. It will have weird results if the predicates\n+    // aren't as expected (i.e. self types = $0, projection\n+    // predicates for a certain trait come after the Implemented\n+    // predicate for that trait).\n+    let mut first = true;\n+    let mut angle_open = false;\n+    for p in predicates.iter() {\n+        match p {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+                if !first {\n+                    write!(f, \" + \")?;\n+                }\n+                // We assume that the self type is $0 (i.e. the\n+                // existential) here, which is the only thing that's\n+                // possible in actual Rust, and hence don't print it\n+                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n+                if trait_ref.substs.len() > 1 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                    // there might be assoc type bindings, so we leave the angle brackets open\n+                    angle_open = true;\n+                }\n+            }\n+            GenericPredicate::Projection(projection_pred) => {\n+                // in types in actual Rust, these will always come\n+                // after the corresponding Implemented predicate\n+                if angle_open {\n+                    write!(f, \", \")?;\n+                } else {\n+                    write!(f, \"<\")?;\n+                    angle_open = true;\n+                }\n+                let name =\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n+                write!(f, \"{} = \", name)?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n+            GenericPredicate::Error => {\n+                if angle_open {\n+                    // impl Trait<X, {error}>\n+                    write!(f, \", \")?;\n+                } else if !first {\n+                    // impl Trait + {error}\n+                    write!(f, \" + \")?;\n+                }\n+                p.hir_fmt(f)?;\n+            }\n+        }\n+        first = false;\n+    }\n+    if angle_open {\n+        write!(f, \">\")?;\n+    }\n+    Ok(())\n+}\n+\n+impl TraitRef {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        self.substs[0].hir_fmt(f)?;\n+        if use_as {\n+            write!(f, \" as \")?;\n+        } else {\n+            write!(f, \": \")?;\n+        }\n+        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone())?;\n+        if self.substs.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.substs[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TraitRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        self.hir_fmt_ext(f, false)\n+    }\n+}\n+\n+impl HirDisplay for &GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Projection(projection_pred) => {\n+                write!(f, \"<\")?;\n+                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n+                write!(\n+                    f,\n+                    \">::{} = {}\",\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n+                    projection_pred.ty.display(f.db)\n+                )?;\n+            }\n+            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Obligation {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+            Obligation::Projection(proj) => write!(\n+                f,\n+                \"Normalize({} => {})\",\n+                proj.projection_ty.display(f.db),\n+                proj.ty.display(f.db)\n+            ),\n+        }\n+    }\n+}"}, {"sha": "1dc842f40ec4e0ee74a430284a453d614e6e5c73", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -249,6 +249,8 @@ impl InferenceTable {\n         match (ty1, ty2) {\n             (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n \n+            (Ty::Placeholder(p1), Ty::Placeholder(p2)) if *p1 == *p2 => true,\n+\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n             | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))"}, {"sha": "571579cc44b4a37394bea0639cb5a670fb9ef240", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 8, "deletions": 375, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -41,21 +41,20 @@ mod marks;\n \n use std::ops::Deref;\n use std::sync::Arc;\n-use std::{fmt, iter, mem};\n+use std::{iter, mem};\n \n use hir_def::{\n-    expr::ExprId, generics::TypeParamProvenance, type_ref::Mutability, AdtId, AssocContainerId,\n-    DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n+    HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n-use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy, Uncertain},\n     utils::{generics, make_mut_slice, Generics},\n };\n-use display::{HirDisplay, HirFormatter};\n+use display::HirDisplay;\n \n pub use autoderef::autoderef;\n pub use infer::{do_infer_query, InferTy, InferenceResult};\n@@ -291,7 +290,7 @@ pub enum Ty {\n     /// {}` when we're type-checking the body of that function. In this\n     /// situation, we know this stands for *some* type, but don't know the exact\n     /// type.\n-    Param(TypeParamId),\n+    Placeholder(TypeParamId),\n \n     /// A bound type variable. This is used in various places: when representing\n     /// some polymorphic type like the type of function `fn f<T>`, the type\n@@ -365,7 +364,7 @@ impl Substs {\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n     pub(crate) fn type_params_for_generics(generic_params: &Generics) -> Substs {\n-        Substs(generic_params.iter().map(|(id, _)| Ty::Param(id)).collect())\n+        Substs(generic_params.iter().map(|(id, _)| Ty::Placeholder(id)).collect())\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n@@ -813,7 +812,7 @@ impl TypeWalk for Ty {\n                     p.walk(f);\n                 }\n             }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+            Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n     }\n@@ -831,374 +830,8 @@ impl TypeWalk for Ty {\n                     p.walk_mut_binders(f, binders + 1);\n                 }\n             }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+            Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self, binders);\n     }\n }\n-\n-const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n-\n-impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self.ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{}]\", t.display(f.db))?;\n-            }\n-            TypeCtor::Array => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{}; _]\", t.display(f.db))?;\n-            }\n-            TypeCtor::RawPtr(m) => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n-            }\n-            TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n-                let ty_display = if f.omit_verbose_types() {\n-                    t.display_truncated(f.db, f.max_size)\n-                } else {\n-                    t.display(f.db)\n-                };\n-                write!(f, \"&{}{}\", m.as_keyword_for_ref(), ty_display)?;\n-            }\n-            TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple { .. } => {\n-                let ts = &self.parameters;\n-                if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0].display(f.db))?;\n-                } else {\n-                    write!(f, \"(\")?;\n-                    f.write_joined(&*ts.0, \", \")?;\n-                    write!(f, \")\")?;\n-                }\n-            }\n-            TypeCtor::FnPtr { .. } => {\n-                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n-                write!(f, \"fn(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n-                let name = match def {\n-                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n-                    CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n-                    CallableDef::EnumVariantId(e) => {\n-                        let enum_data = f.db.enum_data(e.parent);\n-                        enum_data.variants[e.local_id].name.clone()\n-                    }\n-                };\n-                match def {\n-                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n-                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n-                        write!(f, \"{}\", name)?\n-                    }\n-                }\n-                if self.parameters.len() > 0 {\n-                    let generics = generics(f.db, def.into());\n-                    let (parent_params, self_param, type_params, _impl_trait_params) =\n-                        generics.provenance_split();\n-                    let total_len = parent_params + self_param + type_params;\n-                    // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n-                    if total_len > 0 {\n-                        write!(f, \"<\")?;\n-                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n-                        write!(f, \">\")?;\n-                    }\n-                }\n-                write!(f, \"(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-\n-                    let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n-                    let parameters_to_write = if f.omit_verbose_types() {\n-                        match self\n-                            .ctor\n-                            .as_generic_def()\n-                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n-                            .filter(|defaults| !defaults.is_empty())\n-                        {\n-                            Option::None => self.parameters.0.as_ref(),\n-                            Option::Some(default_parameters) => {\n-                                for (i, parameter) in self.parameters.iter().enumerate() {\n-                                    match (parameter, default_parameters.get(i)) {\n-                                        (&Ty::Unknown, _) | (_, None) => {\n-                                            non_default_parameters.push(parameter.clone())\n-                                        }\n-                                        (_, Some(default_parameter))\n-                                            if parameter != default_parameter =>\n-                                        {\n-                                            non_default_parameters.push(parameter.clone())\n-                                        }\n-                                        _ => (),\n-                                    }\n-                                }\n-                                &non_default_parameters\n-                            }\n-                        }\n-                    } else {\n-                        self.parameters.0.as_ref()\n-                    };\n-\n-                    f.write_joined(parameters_to_write, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let trait_ = match type_alias.lookup(f.db).container {\n-                    AssocContainerId::TraitId(it) => it,\n-                    _ => panic!(\"not an associated type\"),\n-                };\n-                let trait_name = f.db.trait_data(trait_).name.clone();\n-                let name = f.db.type_alias_data(type_alias).name.clone();\n-                write!(f, \"{}::{}\", trait_name, name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::Closure { .. } => {\n-                let sig = self.parameters[0]\n-                    .callable_sig(f.db)\n-                    .expect(\"first closure parameter should contain signature\");\n-                let return_type_hint = sig.ret().display(f.db);\n-                if sig.params().is_empty() {\n-                    write!(f, \"|| -> {}\", return_type_hint)?;\n-                } else if f.omit_verbose_types() {\n-                    write!(f, \"|{}| -> {}\", TYPE_HINT_TRUNCATION, return_type_hint)?;\n-                } else {\n-                    write!(f, \"|\")?;\n-                    f.write_joined(sig.params(), \", \")?;\n-                    write!(f, \"| -> {}\", return_type_hint)?;\n-                };\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        let trait_name = f.db.trait_data(self.trait_(f.db)).name.clone();\n-        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n-        if self.parameters.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.parameters[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self {\n-            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n-            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Param(id) => {\n-                let generics = generics(f.db, id.parent);\n-                let param_data = &generics.params.types[id.local_id];\n-                match param_data.provenance {\n-                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n-                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n-                    }\n-                    TypeParamProvenance::ArgumentImplTrait => {\n-                        write!(f, \"impl \")?;\n-                        let bounds = f.db.generic_predicates_for_param(*id);\n-                        let substs = Substs::type_params_for_generics(&generics);\n-                        write_bounds_like_dyn_trait(\n-                            &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),\n-                            f,\n-                        )?;\n-                    }\n-                }\n-            }\n-            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                match self {\n-                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n-                    Ty::Opaque(_) => write!(f, \"impl \")?,\n-                    _ => unreachable!(),\n-                };\n-                write_bounds_like_dyn_trait(&predicates, f)?;\n-            }\n-            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n-            Ty::Infer(..) => write!(f, \"_\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn write_bounds_like_dyn_trait(\n-    predicates: &[GenericPredicate],\n-    f: &mut HirFormatter<impl HirDatabase>,\n-) -> fmt::Result {\n-    // Note: This code is written to produce nice results (i.e.\n-    // corresponding to surface Rust) for types that can occur in\n-    // actual Rust. It will have weird results if the predicates\n-    // aren't as expected (i.e. self types = $0, projection\n-    // predicates for a certain trait come after the Implemented\n-    // predicate for that trait).\n-    let mut first = true;\n-    let mut angle_open = false;\n-    for p in predicates.iter() {\n-        match p {\n-            GenericPredicate::Implemented(trait_ref) => {\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n-                if !first {\n-                    write!(f, \" + \")?;\n-                }\n-                // We assume that the self type is $0 (i.e. the\n-                // existential) here, which is the only thing that's\n-                // possible in actual Rust, and hence don't print it\n-                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n-                if trait_ref.substs.len() > 1 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                    // there might be assoc type bindings, so we leave the angle brackets open\n-                    angle_open = true;\n-                }\n-            }\n-            GenericPredicate::Projection(projection_pred) => {\n-                // in types in actual Rust, these will always come\n-                // after the corresponding Implemented predicate\n-                if angle_open {\n-                    write!(f, \", \")?;\n-                } else {\n-                    write!(f, \"<\")?;\n-                    angle_open = true;\n-                }\n-                let name =\n-                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n-                write!(f, \"{} = \", name)?;\n-                projection_pred.ty.hir_fmt(f)?;\n-            }\n-            GenericPredicate::Error => {\n-                if angle_open {\n-                    // impl Trait<X, {error}>\n-                    write!(f, \", \")?;\n-                } else if !first {\n-                    // impl Trait + {error}\n-                    write!(f, \" + \")?;\n-                }\n-                p.hir_fmt(f)?;\n-            }\n-        }\n-        first = false;\n-    }\n-    if angle_open {\n-        write!(f, \">\")?;\n-    }\n-    Ok(())\n-}\n-\n-impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        self.substs[0].hir_fmt(f)?;\n-        if use_as {\n-            write!(f, \" as \")?;\n-        } else {\n-            write!(f, \": \")?;\n-        }\n-        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone())?;\n-        if self.substs.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.substs[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        self.hir_fmt_ext(f, false)\n-    }\n-}\n-\n-impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n-            GenericPredicate::Projection(projection_pred) => {\n-                write!(f, \"<\")?;\n-                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n-                write!(\n-                    f,\n-                    \">::{} = {}\",\n-                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n-                    projection_pred.ty.display(f.db)\n-                )?;\n-            }\n-            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n-            Obligation::Projection(proj) => write!(\n-                f,\n-                \"Normalize({} => {})\",\n-                proj.projection_ty.display(f.db),\n-                proj.ty.display(f.db)\n-            ),\n-        }\n-    }\n-}"}, {"sha": "6a2aded021c2952343cf15c759b9f4adb9d0fc9c", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -14,9 +14,9 @@ use hir_def::{\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n-    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n-    VariantId,\n+    AdtId, AssocContainerId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n+    ImplId, LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n+    UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -152,7 +152,7 @@ impl Ty {\n                                     data.provenance == TypeParamProvenance::ArgumentImplTrait\n                                 })\n                                 .nth(idx as usize)\n-                                .map_or(Ty::Unknown, |(id, _)| Ty::Param(id));\n+                                .map_or(Ty::Unknown, |(id, _)| Ty::Placeholder(id));\n                             param\n                         } else {\n                             Ty::Unknown\n@@ -270,7 +270,7 @@ impl Ty {\n                 let generics =\n                     generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n                 match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n                     TypeParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id).expect(\"matching generics\");\n                         Ty::Bound(idx)\n@@ -339,7 +339,7 @@ impl Ty {\n             None => return Ty::Unknown, // this can't actually happen\n         };\n         let param_id = match self_ty {\n-            Ty::Param(id) if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => id,\n+            Ty::Placeholder(id) if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => id,\n             Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => {\n                 let generics = generics(ctx.db, def);\n                 let param_id = if let Some((id, _)) = generics.iter().nth(idx as usize) {\n@@ -544,7 +544,7 @@ impl GenericPredicate {\n                 let generics = generics(ctx.db, generic_def);\n                 let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n                 match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n                     TypeParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id).expect(\"matching generics\");\n                         Ty::Bound(idx)\n@@ -672,11 +672,35 @@ impl TraitEnvironment {\n     pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n         let ctx = TyLoweringContext::new(db, &resolver)\n             .with_type_param_mode(TypeParamLoweringMode::Placeholder);\n-        let predicates = resolver\n+        let mut predicates = resolver\n             .where_predicates_in_scope()\n             .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n             .collect::<Vec<_>>();\n \n+        if let Some(def) = resolver.generic_def() {\n+            let container: Option<AssocContainerId> = match def {\n+                // FIXME: is there a function for this?\n+                GenericDefId::FunctionId(f) => Some(f.lookup(db).container),\n+                GenericDefId::AdtId(_) => None,\n+                GenericDefId::TraitId(_) => None,\n+                GenericDefId::TypeAliasId(t) => Some(t.lookup(db).container),\n+                GenericDefId::ImplId(_) => None,\n+                GenericDefId::EnumVariantId(_) => None,\n+                GenericDefId::ConstId(c) => Some(c.lookup(db).container),\n+            };\n+            if let Some(AssocContainerId::TraitId(trait_id)) = container {\n+                // add `Self: Trait<T1, T2, ...>` to the environment in trait\n+                // function default implementations (and hypothetical code\n+                // inside consts or type aliases)\n+                test_utils::tested_by!(trait_self_implements_self);\n+                let substs = Substs::type_params(db, trait_id);\n+                let trait_ref = TraitRef { trait_: trait_id, substs };\n+                let pred = GenericPredicate::Implemented(trait_ref);\n+\n+                predicates.push(pred);\n+            }\n+        }\n+\n         Arc::new(TraitEnvironment { predicates })\n     }\n }"}, {"sha": "de5cb1d6bcb8581b76ec4f76f2d8ea560934812a", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -4,6 +4,8 @@ test_utils::marks!(\n     type_var_cycles_resolve_completely\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var\n+    impl_self_type_match_without_receiver\n     match_ergonomics_ref\n     coerce_merge_fail_fallback\n+    trait_self_implements_self\n );"}, {"sha": "4f8c524336b32ef0dc5ad003eaefa0218ba450b0", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -425,6 +425,15 @@ fn iterate_inherent_methods<T>(\n                 if !is_valid_candidate(db, name, receiver_ty, item, self_ty) {\n                     continue;\n                 }\n+                // we have to check whether the self type unifies with the type\n+                // that the impl is for. If we have a receiver type, this\n+                // already happens in `is_valid_candidate` above; if not, we\n+                // check it here\n+                if receiver_ty.is_none() && inherent_impl_substs(db, impl_block, self_ty).is_none()\n+                {\n+                    test_utils::tested_by!(impl_self_type_match_without_receiver);\n+                    continue;\n+                }\n                 if let Some(result) = callback(&self_ty.value, item) {\n                     return Some(result);\n                 }"}, {"sha": "42330b269f1a91792a7ddbbb67341132eb7d126d", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -526,3 +526,25 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn coerce_placeholder_ref() {\n+    // placeholders should unify, even behind references\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+struct S<T> { t: T }\n+impl<TT> S<TT> {\n+    fn get(&self) -> &TT {\n+        &self.t\n+    }\n+}\n+\"#, true),\n+        @r###\"\n+    [51; 55) 'self': &S<TT>\n+    [64; 87) '{     ...     }': &TT\n+    [74; 81) '&self.t': &TT\n+    [75; 79) 'self': &S<TT>\n+    [75; 81) 'self.t': TT\n+    \"###\n+    );\n+}"}, {"sha": "1f767d324f5505a7bf6669ddf90c300ff20a32ce", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -963,6 +963,38 @@ fn test() { S2.into()<|>; }\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn method_resolution_overloaded_method() {\n+    test_utils::covers!(impl_self_type_match_without_receiver);\n+    let t = type_at(\n+        r#\"\n+//- main.rs\n+struct Wrapper<T>(T);\n+struct Foo<T>(T);\n+struct Bar<T>(T);\n+\n+impl<T> Wrapper<Foo<T>> {\n+    pub fn new(foo_: T) -> Self {\n+        Wrapper(Foo(foo_))\n+    }\n+}\n+\n+impl<T> Wrapper<Bar<T>> {\n+    pub fn new(bar_: T) -> Self {\n+        Wrapper(Bar(bar_))\n+    }\n+}\n+\n+fn main() {\n+    let a = Wrapper::<Foo<f32>>::new(1.0);\n+    let b = Wrapper::<Bar<f32>>::new(1.0);\n+    (a, b)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"(Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\")\n+}\n+\n #[test]\n fn method_resolution_encountering_fn_type() {\n     type_at("}, {"sha": "aa2018944cee5ae5aac2153a611e69971416f92b", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -299,6 +299,54 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn trait_default_method_self_bound_implements_trait() {\n+    test_utils::covers!(trait_self_implements_self);\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    fn foo(&self) -> i64;\n+    fn bar(&self) -> {\n+        let x = self.foo();\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [27; 31) 'self': &Self\n+    [53; 57) 'self': &Self\n+    [62; 97) '{     ...     }': ()\n+    [76; 77) 'x': i64\n+    [80; 84) 'self': &Self\n+    [80; 90) 'self.foo()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn trait_default_method_self_bound_implements_super_trait() {\n+    test_utils::covers!(trait_self_implements_self);\n+    assert_snapshot!(\n+        infer(r#\"\n+trait SuperTrait {\n+    fn foo(&self) -> i64;\n+}\n+trait Trait: SuperTrait {\n+    fn bar(&self) -> {\n+        let x = self.foo();\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [32; 36) 'self': &Self\n+    [86; 90) 'self': &Self\n+    [95; 130) '{     ...     }': ()\n+    [109; 110) 'x': i64\n+    [113; 117) 'self': &Self\n+    [113; 123) 'self.foo()': i64\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_project_associated_type() {\n     // y, z, a don't yet work because of https://github.com/rust-lang/chalk/issues/234"}, {"sha": "ff8e75b48eecd626bb60e1f493a8c2aa91940a8b", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -60,6 +60,9 @@ impl TraitSolver {\n                     context.0.db.check_canceled();\n                     let remaining = fuel.get();\n                     fuel.set(remaining - 1);\n+                    if remaining == 0 {\n+                        log::debug!(\"fuel exhausted\");\n+                    }\n                     remaining > 0\n                 })\n             }"}, {"sha": "882160fa8aa67ba6e61427916fd6fac236210db3", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -142,7 +142,7 @@ impl ToChalk for Ty {\n                 let substitution = proj_ty.parameters.to_chalk(db);\n                 chalk_ir::AliasTy { associated_ty_id, substitution }.cast().intern()\n             }\n-            Ty::Param(id) => {\n+            Ty::Placeholder(id) => {\n                 let interned_id = db.intern_type_param_id(id);\n                 PlaceholderIndex {\n                     ui: UniverseIndex::ROOT,\n@@ -184,7 +184,7 @@ impl ToChalk for Ty {\n                 let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n                     crate::salsa::InternId::from(idx.idx),\n                 );\n-                Ty::Param(db.lookup_intern_type_param_id(interned_id))\n+                Ty::Placeholder(db.lookup_intern_type_param_id(interned_id))\n             }\n             chalk_ir::TyData::Alias(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);"}, {"sha": "a02dbaf2fe91bf18fb3958f19f487fc22e5abaae", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -16,6 +16,7 @@\n .literal            { color: #BFEBBF; }\n .literal\\.numeric  { color: #6A8759; }\n .macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n .variable\\.mut     { color: #DCDCCC; text-decoration: underline; }\n "}, {"sha": "95f038f00011a7c2556dd5e2c9dc7f3f8c12d695", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -16,6 +16,7 @@\n .literal            { color: #BFEBBF; }\n .literal\\.numeric  { color: #6A8759; }\n .macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n .variable\\.mut     { color: #DCDCCC; text-decoration: underline; }\n "}, {"sha": "20c414ca1b70b2c0e9ef1da5f4b578bf36373bd5", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -365,6 +365,7 @@ pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padd\n .literal            { color: #BFEBBF; }\n .literal\\\\.numeric  { color: #6A8759; }\n .macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n .variable\\\\.mut     { color: #DCDCCC; text-decoration: underline; }\n "}, {"sha": "495fffb5af46d1daa8565f2e6a3058c0851d68fa", "filename": "crates/ra_ide_db/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -22,7 +22,6 @@ fst = { version = \"0.3.1\", default-features = false }\n rustc-hash = \"1.0\"\n unicase = \"2.2.0\"\n superslice = \"1.0.0\"\n-rand = { version = \"0.7.0\", features = [\"small_rng\"] }\n once_cell = \"1.2.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "ed2eaabd4ca96b488b140f82b3622b783f091cc5", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -15,13 +15,8 @@ fn main() -> Result<()> {\n \n fn setup_logging() -> Result<()> {\n     std::env::set_var(\"RUST_BACKTRACE\", \"short\");\n-\n     env_logger::try_init()?;\n-\n-    ra_prof::set_filter(match std::env::var(\"RA_PROFILE\") {\n-        Ok(spec) => ra_prof::Filter::from_spec(&spec),\n-        Err(_) => ra_prof::Filter::disabled(),\n-    });\n+    ra_prof::init();\n     Ok(())\n }\n "}, {"sha": "c0bfbc2ee1415efa1d14682624f7fc7f1b2e1507", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -26,6 +26,13 @@ pub use crate::memory_usage::{Bytes, MemoryUsage};\n #[global_allocator]\n static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n+pub fn init() {\n+    set_filter(match std::env::var(\"RA_PROFILE\") {\n+        Ok(spec) => Filter::from_spec(&spec),\n+        Err(_) => Filter::disabled(),\n+    });\n+}\n+\n /// Set profiling filter. It specifies descriptions allowed to profile.\n /// This is helpful when call stack has too many nested profiling scopes.\n /// Additionally filter can specify maximum depth of profiling scopes nesting."}, {"sha": "250255813ecd8899e0735108039e9ec6b0096a79", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -418,8 +418,10 @@ pub fn get_rustc_cfg_options() -> CfgOptions {\n     // Some nightly-only cfgs, which are required for stdlib\n     {\n         cfg_options.insert_atom(\"target_thread_local\".into());\n-        for &target_has_atomic in [\"16\", \"32\", \"64\", \"8\", \"cas\", \"ptr\"].iter() {\n-            cfg_options.insert_key_value(\"target_has_atomic\".into(), target_has_atomic.into())\n+        for &target_has_atomic in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n+            cfg_options.insert_key_value(\"target_has_atomic\".into(), target_has_atomic.into());\n+            cfg_options\n+                .insert_key_value(\"target_has_atomic_load_store\".into(), target_has_atomic.into());\n         }\n     }\n "}, {"sha": "14ca6fd64257aac2be1c57605a6b5f49061798e3", "filename": "docs/user/README.md", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/b446384956243ce6bdcef2a869123a2605e597ed/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b446384956243ce6bdcef2a869123a2605e597ed/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=b446384956243ce6bdcef2a869123a2605e597ed", "patch": "@@ -1,280 +0,0 @@\n-[github-releases]: https://github.com/rust-analyzer/rust-analyzer/releases\n-\n-The main interface to rust-analyzer is the\n-[LSP](https://microsoft.github.io/language-server-protocol/) implementation. To\n-install lsp server, you have three options:\n-\n-* **Preferred and default:** install the plugin/extension for your IDE and it will ask your permission to automatically download the latest lsp server for you from [GitHub releases][github-releases]. (See docs to find out whether this is implemented for your editor below).\n-* Manually download prebuilt binaries from [GitHub releases][github-releases]\n-    * `ra_lsp_server-linux` for Linux\n-    * `ra_lsp_server-mac` for Mac\n-    * `ra_lsp_server-windows.exe` for Windows\n-* Clone the repository and build from sources\n-```bash\n-$ git clone git@github.com:rust-analyzer/rust-analyzer && cd rust-analyzer\n-$ cargo xtask install --server # or cargo install --path ./crates/ra_lsp_server\n-```\n-\n-This way you will get a binary named `ra_lsp_server` (with os suffix for prebuilt binaries)\n-which you should be able to use with any LSP-compatible editor.\n-\n-We make use of custom extensions to LSP, so special client-side support is required to take full\n-advantage of rust-analyzer. This repository contains support code for VS Code.\n-\n-Rust Analyzer needs sources of rust standard library to work, so\n-you might also need to execute\n-\n-```\n-$ rustup component add rust-src\n-```\n-\n-See [./features.md](./features.md) document for a list of features that are available.\n-\n-## VS Code\n-\n-### Prerequisites\n-\n-You will need the most recent version of VS Code: we don't try to\n-maintain compatibility with older versions yet.\n-\n-### Installation from prebuilt binaries\n-\n-We ship prebuilt binaries for Linux, Mac and Windows via\n-[GitHub releases][github-releases].\n-In order to use them you need to install the client VSCode extension.\n-\n-Publishing to VS Code marketplace is currently WIP. Thus, you need to manually download\n-`rust-analyzer-0.1.0.vsix` file from latest [GitHub release][github-releases].\n-\n-After you downloaded the `.vsix` file you can install it from the terminal\n-\n-```\n-$ code --install-extension rust-analyzer-0.1.0.vsix\n-```\n-\n-Or open VS Code, press <kbd>Ctrl+Shift+P</kbd>, and search for the following command:\n-\n-<img width=\"500px\" alt=\"Install from VSIX command\" src=\"https://user-images.githubusercontent.com/36276403/74108225-c0c11d80-4b80-11ea-9b2a-0a43f09e29af.png\">\n-\n-Press <kbd>Enter</kbd> and go to `rust-analyzer-0.1.0.vsix` file through the file explorer.\n-\n-Then open some Rust project and you should\n-see an info message pop-up.\n-\n-<img height=\"140px\" src=\"https://user-images.githubusercontent.com/36276403/74103174-a40df100-4b52-11ea-81f4-372c70797924.png\" alt=\"Download now message\"/>\n-\n-\n-Click `Download now`, wait until the progress is 100% and you are ready to go.\n-\n-For updates you need to remove installed binary\n-```\n-rm -rf ${HOME}/.config/Code/User/globalStorage/matklad.rust-analyzer\n-```\n-\n-`\"Download latest language server\"` command for VSCode and automatic updates detection is currently WIP.\n-\n-\n-### Installation from sources\n-\n-In order to build the VS Code plugin from sources, you need to have node.js and npm with\n-a minimum version of 12 installed. Please refer to\n-[node.js and npm documentation](https://nodejs.org) for installation instructions.\n-\n-The experimental VS Code plugin can be built and installed by executing the\n-following commands:\n-\n-```\n-$ git clone https://github.com/rust-analyzer/rust-analyzer.git --depth 1\n-$ cd rust-analyzer\n-$ cargo xtask install\n-```\n-\n-After that you need to amend your `settings.json` file to explicitly specify the\n-path to `ra_lsp_server` that you've just built.\n-```json\n-{\n-    \"rust-analyzer.raLspServerPath\": \"ra_lsp_server\"\n-}\n-```\n-This should work on all platforms, otherwise if installed `ra_lsp_server` is not available through your `$PATH` then see how to configure it [here](#setting-up-the-PATH-variable).\n-\n-\n-The automatic installation is expected to *just work* for common cases, if it\n-doesn't, report bugs!\n-\n-**Note** [#1831](https://github.com/rust-analyzer/rust-analyzer/issues/1831): If you are using the popular\n-[Vim emulation plugin](https://github.com/VSCodeVim/Vim), you will likely\n-need to turn off the `rust-analyzer.enableEnhancedTyping` setting.\n-(// TODO: This configuration is no longer available, enhanced typing shoud be disabled via removing Enter key binding, [see this issue](https://github.com/rust-analyzer/rust-analyzer/issues/3051))\n-\n-If you have an unusual setup (for example, `code` is not in the `PATH`), you\n-should adapt these manual installation instructions:\n-\n-```\n-$ git clone https://github.com/rust-analyzer/rust-analyzer.git --depth 1\n-$ cd rust-analyzer\n-$ cargo install --path ./crates/ra_lsp_server/ --force --locked\n-$ cd ./editors/code\n-$ npm install\n-$ npm run package\n-$ code --install-extension ./rust-analyzer-0.1.0.vsix\n-```\n-\n-It's better to remove existing Rust plugins to avoid interference.\n-\n-Beyond basic LSP features, there are some extension commands which you can\n-invoke via <kbd>Ctrl+Shift+P</kbd> or bind to a shortcut. See [./features.md](./features.md)\n-for details.\n-\n-For updates, pull the latest changes from the master branch, run `cargo xtask install` again, and **restart** VS Code instance.\n-See [microsoft/vscode#72308](https://github.com/microsoft/vscode/issues/72308) for why a full restart is needed.\n-\n-### VS Code Remote\n-\n-You can also use `rust-analyzer` with the Visual Studio Code Remote extensions\n-(Remote SSH, Remote WSL, Remote Containers). In this case, however, you have to\n-manually install the `.vsix` package:\n-\n-1. Build the extension on the remote host using the instructions above (ignore the\n-   error if `code` cannot be found in your PATH: VSCode doesn't need to be installed\n-   on the remote host).\n-2. In Visual Studio Code open a connection to the remote host.\n-3. Open the Extensions View (`View > Extensions`, keyboard shortcut: `Ctrl+Shift+X`).\n-4. From the top-right kebab menu (`\u00b7\u00b7\u00b7`) select `Install from VSIX...`\n-5. Inside the `rust-analyzer` directory find the `editors/code` subdirectory and choose\n-   the `rust-analyzer-0.1.0.vsix` file.\n-6. Restart Visual Studio Code and re-establish the connection to the remote host.\n-\n-In case of errors please make sure that `~/.cargo/bin` is in your `PATH` on the remote\n-host.\n-\n-### Settings\n-\n-* `rust-analyzer.highlightingOn`: enables experimental syntax highlighting.\n-  Colors can be configured via `editor.tokenColorCustomizations`.\n-  As an example, [Pale Fire](https://github.com/matklad/pale-fire/) color scheme tweaks rust colors.\n-* `rust-analyzer.enableEnhancedTyping`: by default, rust-analyzer intercepts the\n-  `Enter` key to make it easier to continue comments. Note that it may conflict with VIM emulation plugin.\n-* `rust-analyzer.raLspServerPath`: path to `ra_lsp_server` executable, when absent or `null` defaults to prebuilt binary path\n-* `rust-analyzer.enableCargoWatchOnStartup`: prompt to install & enable `cargo\n-  watch` for live error highlighting (note, this **does not** use rust-analyzer)\n-* `rust-analyzer.excludeGlobs`: a list of glob-patterns for exclusion (see globset [docs](https://docs.rs/globset) for syntax).\n-  Note: glob patterns are applied to all Cargo packages and a rooted at a package root.\n-  This is not very intuitive and a limitation of a current implementation.\n-* `rust-analyzer.useClientWatching`: use client provided file watching instead\n-  of notify watching.\n-* `rust-analyzer.cargo-watch.command`: `cargo-watch` command. (e.g: `clippy` will run as `cargo watch -x clippy` )\n-* `rust-analyzer.cargo-watch.arguments`: cargo-watch check arguments.\n-  (e.g: `--features=\"shumway,pdf\"` will run as `cargo watch -x \"check --features=\"shumway,pdf\"\"` )\n-* `rust-analyzer.cargo-watch.ignore`: list of patterns for cargo-watch to ignore (will be passed as `--ignore`)\n-* `rust-analyzer.trace.server`: enables internal logging\n-* `rust-analyzer.trace.cargo-watch`: enables cargo-watch logging\n-* `RUST_SRC_PATH`: environment variable that overwrites the sysroot\n-* `rust-analyzer.featureFlags` -- a JSON object to tweak fine-grained behavior:\n-   ```jsonc\n-   {\n-       // Show diagnostics produced by rust-analyzer itself.\n-       \"lsp.diagnostics\": true,\n-       // Automatically insert `()` and `<>` when completing functions and types.\n-       \"completion.insertion.add-call-parenthesis\": true,\n-       // Enable completions like `.if`, `.match`, etc.\n-       \"completion.enable-postfix\": true,\n-       // Show notification when workspace is fully loaded\n-       \"notifications.workspace-loaded\": true,\n-       // Show error when no Cargo.toml was found\n-       \"notifications.cargo-toml-not-found\": true,\n-   }\n-   ```\n-\n-\n-## Emacs\n-\n-* install recent version of `emacs-lsp` package by following the instructions [here][emacs-lsp]\n-* set `lsp-rust-server` to `'rust-analyzer`\n-* run `lsp` in a Rust buffer\n-* (Optionally) bind commands like `lsp-rust-analyzer-join-lines`, `lsp-extend-selection` and `lsp-rust-analyzer-expand-macro` to keys\n-\n-[emacs-lsp]: https://github.com/emacs-lsp/lsp-mode\n-\n-\n-## Vim and NeoVim (coc-rust-analyzer)\n-\n-* Install coc.nvim by following the instructions at [coc.nvim][] (nodejs required)\n-* Run `:CocInstall coc-rust-analyzer` to install [coc-rust-analyzer], this extension implements _most_ of the features supported in the VSCode extension:\n-  - same configurations as VSCode extension, `rust-analyzer.raLspServerPath`, `rust-analyzer.enableCargoWatchOnStartup` etc.\n-  - same commands too, `rust-analyzer.analyzerStatus`, `rust-analyzer.startCargoWatch` etc.\n-  - highlighting and inlay_hints are not implemented yet\n-\n-[coc.nvim]: https://github.com/neoclide/coc.nvim\n-[coc-rust-analyzer]: https://github.com/fannheyward/coc-rust-analyzer\n-\n-## Vim and NeoVim (LanguageClient-neovim)\n-\n-* Install LanguageClient-neovim by following the instructions [here][lang-client-neovim]\n-  - The github project wiki has extra tips on configuration\n-\n-* Configure by adding this to your vim/neovim config file (replacing the existing rust specific line if it exists):\n-\n-```vim\n-let g:LanguageClient_serverCommands = {\n-\\ 'rust': ['ra_lsp_server'],\n-\\ }\n-```\n-\n-[lang-client-neovim]: https://github.com/autozimu/LanguageClient-neovim\n-\n-## NeoVim (nvim-lsp)\n-\n-NeoVim 0.5 (not yet released) has built in language server support. For a quick start configuration\n-of rust-analyzer, use [neovim/nvim-lsp](https://github.com/neovim/nvim-lsp#rust_analyzer).\n-Once `neovim/nvim-lsp` is installed, use `lua require'nvim_lsp'.rust_analyzer.setup({})` in your `init.vim`.\n-\n-\n-## Sublime Text 3\n-\n-Prequisites:\n-\n-`LSP` package.\n-\n-Installation:\n-\n-* Invoke the command palette with <kbd>Ctrl+Shift+P</kbd>\n-* Type `LSP Settings` to open the LSP preferences editor\n-* Add the following LSP client definition to your settings:\n-\n-```json\n-\"rust-analyzer\": {\n-    \"command\": [\"ra_lsp_server\"],\n-    \"languageId\": \"rust\",\n-    \"scopes\": [\"source.rust\"],\n-    \"syntaxes\": [\n-        \"Packages/Rust/Rust.sublime-syntax\",\n-        \"Packages/Rust Enhanced/RustEnhanced.sublime-syntax\"\n-    ],\n-    \"initializationOptions\": {\n-      \"featureFlags\": {\n-      }\n-    },\n-}\n-```\n-\n-* You can now invoke the command palette and type LSP enable to locally/globally enable the rust-analyzer LSP (type LSP enable, then choose either locally or globally, then select rust-analyzer)\n-\n-\n-<!-- Update links to this header when changing it! -->\n-### Setting up the `PATH` variable\n-\n-On Unix systems, `rustup` adds `~/.cargo/bin` to `PATH` by modifying the shell's\n-startup file. Depending on your configuration, your Desktop Environment might not\n-actually load it. If you find that `rust-analyzer` only runs when starting the\n-editor from the terminal, you will have to set up your `PATH` variable manually.\n-\n-There are a couple of ways to do that:\n-\n-- for Code, set `rust-analyzer.raLspServerPath` to `~/.cargo/bin` (the `~` is\n-  automatically resolved by the extension)\n-- copy the binary to a location that is already in `PATH`, e.g. `/usr/local/bin`\n-- on Linux, use PAM to configure the `PATH` variable, by e.g. putting\n-  `PATH DEFAULT=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:@{HOME}/.cargo/bin:@{HOME}/.local/bin`\n-  in your `~/.pam_environment` file; note that this might interfere with other\n-  defaults set by the system administrator via `/etc/environment`."}, {"sha": "553687e7899d65bd3c09bf18792cc92d8065b3f9", "filename": "docs/user/readme.adoc", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -0,0 +1,154 @@\n+= User Manual\n+:toc: preamble\n+:sectanchors:\n+:page-layout: post\n+\n+\n+// Master copy of this document lives in the https://github.com/rust-analyzer/rust-analyzer repository\n+\n+At it's core, rust-analyzer is a *library* for semantic analysis of the Rust code as it changes over time.\n+This manual focuses on a specific usage of the library -- the implementation of\n+https://microsoft.github.io/language-server-protocol/[Language Server Protocol].\n+LSP allows various code editors, like VS Code, Emacs or Vim, to implement semantic feature like completion or goto definition by talking to an external language server process.\n+\n+To improve this document, send a pull request against\n+https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/readme.adoc[this file].\n+\n+== Installation\n+\n+In theory, one should be able to just install the server binary and have it automatically work with any editor.\n+We are not there yet, so some editor specific setup is required.\n+\n+=== VS Code\n+\n+This the best supported editor at the moment.\n+rust-analyzer plugin for VS Code is maintained\n+https://github.com/rust-analyzer/rust-analyzer/tree/master/editors/code[in tree].\n+\n+You can install the latest release of the plugin from\n+https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer[the marketplace].\n+By default, the plugin will download the matching version of the server as well.\n+\n+// FIXME: update the image (its text has changed)\n+image::https://user-images.githubusercontent.com/36276403/74103174-a40df100-4b52-11ea-81f4-372c70797924.png[]\n+\n+The server binary is stored in `~/.config/Code/User/globalStorage/matklad.rust-analyzer`.\n+\n+Note that we only support the latest version of VS Code.\n+\n+==== Updates\n+\n+The extension will be updated automatically as new versions become available. It will ask your permission to download the matching language server version binary if needed.\n+\n+==== Building From Source\n+\n+Alternatively, both the server and the plugin can be installed from source:\n+\n+[source]\n+----\n+$ git clone https://github.com/rust-analyzer/rust-analyzer.git && cd rust-analyzer\n+$ cargo xtask install\n+----\n+\n+You'll need Cargo, nodejs and npm for this.\n+To make VS Code use the freshly build server, add this to the settings:\n+\n+[source,json]\n+----\n+{ \"rust-analyzer.raLspServerPath\": \"ra_lsp_server\" }\n+----\n+\n+Note that installing via `xtask install` does not work for VS Code Remote, instead you'll need to install the `.vsix` manually.\n+\n+=== Language Server Binary\n+\n+Other editors generally require `ra_lsp_server` binary to be in `$PATH`.\n+You can download pre-build binary from\n+https://github.com/rust-analyzer/rust-analyzer/releases[relases]\n+page, or you can install it from source using the following command:\n+\n+[source,bash]\n+----\n+$ cargo xtask install --server\n+----\n+\n+=== Emacs\n+\n+Emacs support is maintained https://github.com/emacs-lsp/lsp-mode/blob/master/lsp-rust.el[upstream].\n+\n+1. Install recent version of `emacs-lsp` package by following the instructions https://github.com/emacs-lsp/lsp-mode[here].\n+2. Set `lsp-rust-server` to `'rust-analyzer`.\n+3. Run `lsp` in a Rust buffer.\n+4. (Optionally) bind commands like `lsp-rust-analyzer-join-lines`, `lsp-extend-selection` and `lsp-rust-analyzer-expand-macro` to keys.\n+\n+=== Vim\n+\n+The are several LSP client implementations for vim:\n+\n+==== coc-rust-analyzer\n+\n+1. Install coc.nvim by following the instructions at\n+   https://github.com/neoclide/coc.nvim[coc.nvim]\n+   (nodejs required)\n+2. Run `:CocInstall coc-rust-analyzer` to install\n+   https://github.com/fannheyward/coc-rust-analyzer[coc-rust-analyzer],\n+   this extension implements _most_ of the features supported in the VSCode extension:\n+   * same configurations as VSCode extension, `rust-analyzer.raLspServerPath`, `rust-analyzer.enableCargoWatchOnStartup` etc.\n+   * same commands too, `rust-analyzer.analyzerStatus`, `rust-analyzer.startCargoWatch` etc.\n+   * highlighting and inlay_hints are not implemented yet\n+\n+==== LanguageClient-neovim\n+\n+1. Install LanguageClient-neovim by following the instructions\n+   https://github.com/autozimu/LanguageClient-neovim[here]\n+   * The github project wiki has extra tips on configuration\n+\n+2. Configure by adding this to your vim/neovim config file (replacing the existing rust specific line if it exists):\n++\n+[source,vim]\n+----\n+let g:LanguageClient_serverCommands = {\n+\\ 'rust': ['ra_lsp_server'],\n+\\ }\n+----\n+\n+==== nvim-lsp\n+\n+NeoVim 0.5 (not yet released) has built in language server support.\n+For a quick start configuration of rust-analyzer, use https://github.com/neovim/nvim-lsp#rust_analyzer[neovim/nvim-lsp].\n+Once `neovim/nvim-lsp` is installed, use `lua require'nvim_lsp'.rust_analyzer.setup({})` in your `init.vim`.\n+\n+=== Sublime Text 3\n+\n+Prerequisites:\n+\n+`LSP` package.\n+\n+Installation:\n+\n+1. Invoke the command palette with <kbd>Ctrl+Shift+P</kbd>\n+2. Type `LSP Settings` to open the LSP preferences editor\n+3. Add the following LSP client definition to your settings:\n++\n+[source,json]\n+----\n+\"rust-analyzer\": {\n+    \"command\": [\"ra_lsp_server\"],\n+    \"languageId\": \"rust\",\n+    \"scopes\": [\"source.rust\"],\n+    \"syntaxes\": [\n+        \"Packages/Rust/Rust.sublime-syntax\",\n+        \"Packages/Rust Enhanced/RustEnhanced.sublime-syntax\"\n+    ],\n+    \"initializationOptions\": {\n+      \"featureFlags\": {\n+      }\n+    },\n+}\n+----\n+\n+4. You can now invoke the command palette and type LSP enable to locally/globally enable the rust-analyzer LSP (type LSP enable, then choose either locally or globally, then select rust-analyzer)\n+\n+== Usage\n+\n+See https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/features.md[features.md]."}, {"sha": "c740787359256b037851108b93a8f7ba4e1264c4", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -1,6 +1,6 @@\n {\n     \"name\": \"rust-analyzer\",\n-    \"version\": \"0.1.0\",\n+    \"version\": \"0.2.0-dev\",\n     \"lockfileVersion\": 1,\n     \"requires\": true,\n     \"dependencies\": {\n@@ -107,9 +107,9 @@\n             \"dev\": true\n         },\n         \"@types/vscode\": {\n-            \"version\": \"1.41.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@types/vscode/-/vscode-1.41.0.tgz\",\n-            \"integrity\": \"sha512-7SfeY5u9jgiELwxyLB3z7l6l/GbN9CqpCQGkcRlB7tKRFBxzbz2PoBfGrLxI1vRfUCIq5+hg5vtDHExwq5j3+A==\",\n+            \"version\": \"1.42.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/vscode/-/vscode-1.42.0.tgz\",\n+            \"integrity\": \"sha512-ds6TceMsh77Fs0Mq0Vap6Y72JbGWB8Bay4DrnJlf5d9ui2RSe1wis13oQm+XhguOeH1HUfLGzaDAoupTUtgabw==\",\n             \"dev\": true\n         },\n         \"acorn\": {\n@@ -662,9 +662,9 @@\n             }\n         },\n         \"readable-stream\": {\n-            \"version\": \"3.4.0\",\n-            \"resolved\": \"https://registry.npmjs.org/readable-stream/-/readable-stream-3.4.0.tgz\",\n-            \"integrity\": \"sha512-jItXPLmrSR8jmTRmRWJXCnGJsfy85mB3Wd/uINMXA65yrnFo0cPClFIUWzo2najVNSl+mx7/4W8ttlLWJe99pQ==\",\n+            \"version\": \"3.6.0\",\n+            \"resolved\": \"https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz\",\n+            \"integrity\": \"sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"inherits\": \"^2.0.3\",\n@@ -860,9 +860,9 @@\n             \"dev\": true\n         },\n         \"vsce\": {\n-            \"version\": \"1.71.0\",\n-            \"resolved\": \"https://registry.npmjs.org/vsce/-/vsce-1.71.0.tgz\",\n-            \"integrity\": \"sha512-7k+LPC4oJYPyyxs0a5nh4A8CleQ6+2EMPiAiX/bDyN+PmwJFm2FFPqLRxdIsIWfFnkW4ZMQBf10+W62dCRd9kQ==\",\n+            \"version\": \"1.73.0\",\n+            \"resolved\": \"https://registry.npmjs.org/vsce/-/vsce-1.73.0.tgz\",\n+            \"integrity\": \"sha512-6W37Ebbkj3uF3WhT+SCfRtsneRQEFcGvf/XYz+b6OAgDCj4gPurWyDVrqw/HLsbP1WflGIyUfVZ8t5M7kQp6Uw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"azure-devops-node-api\": \"^7.2.0\","}, {"sha": "ed1cae2ab27baee12996865c4eebe4d2c276f8b7", "filename": "editors/code/package.json", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -5,7 +5,8 @@\n     \"preview\": true,\n     \"private\": true,\n     \"icon\": \"icon.png\",\n-    \"version\": \"0.1.0\",\n+    \"//\": \"The real version is in release.yaml, this one just needs to be bigger\",\n+    \"version\": \"0.2.20200211-dev\",\n     \"publisher\": \"matklad\",\n     \"repository\": {\n         \"url\": \"https://github.com/rust-analyzer/rust-analyzer.git\",\n@@ -15,7 +16,7 @@\n         \"Other\"\n     ],\n     \"engines\": {\n-        \"vscode\": \"^1.41.0\"\n+        \"vscode\": \"^1.42.0\"\n     },\n     \"scripts\": {\n         \"vscode:prepublish\": \"tsc && rollup -c\",\n@@ -35,13 +36,13 @@\n         \"@types/node\": \"^12.12.25\",\n         \"@types/node-fetch\": \"^2.5.4\",\n         \"@types/throttle-debounce\": \"^2.1.0\",\n-        \"@types/vscode\": \"^1.41.0\",\n+        \"@types/vscode\": \"^1.42.0\",\n         \"rollup\": \"^1.31.0\",\n         \"tslib\": \"^1.10.0\",\n         \"tslint\": \"^5.20.1\",\n         \"typescript\": \"^3.7.5\",\n         \"typescript-formatter\": \"^7.2.2\",\n-        \"vsce\": \"^1.71.0\"\n+        \"vsce\": \"^1.73.0\"\n     },\n     \"activationEvents\": [\n         \"onLanguage:rust\",\n@@ -181,6 +182,9 @@\n                 },\n                 \"rust-analyzer.excludeGlobs\": {\n                     \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    },\n                     \"default\": [],\n                     \"description\": \"Paths to exclude from analysis\"\n                 },\n@@ -196,6 +200,9 @@\n                 },\n                 \"rust-analyzer.cargo-watch.arguments\": {\n                     \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    },\n                     \"description\": \"`cargo-watch` arguments. (e.g: `--features=\\\"shumway,pdf\\\"` will run as `cargo watch -x \\\"check --features=\\\"shumway,pdf\\\"\\\"` )\",\n                     \"default\": []\n                 },\n@@ -226,11 +233,10 @@\n                     \"description\": \"Trace requests to the ra_lsp_server\"\n                 },\n                 \"rust-analyzer.lruCapacity\": {\n-                    \"type\": [\n-                        \"number\",\n-                        \"null\"\n-                    ],\n+                    \"type\": [ \"null\", \"integer\" ],\n                     \"default\": null,\n+                    \"minimum\": 0,\n+                    \"exclusiveMinimum\": true,\n                     \"description\": \"Number of syntax trees rust-analyzer keeps in memory\"\n                 },\n                 \"rust-analyzer.displayInlayHints\": {\n@@ -239,8 +245,10 @@\n                     \"description\": \"Display additional type and parameter information in the editor\"\n                 },\n                 \"rust-analyzer.maxInlayHintLength\": {\n-                    \"type\": \"number\",\n+                    \"type\": [ \"null\", \"integer\" ],\n                     \"default\": 20,\n+                    \"minimum\": 0,\n+                    \"exclusiveMinimum\": true,\n                     \"description\": \"Maximum length for inlay hints\"\n                 },\n                 \"rust-analyzer.cargoFeatures.noDefaultFeatures\": {\n@@ -255,6 +263,9 @@\n                 },\n                 \"rust-analyzer.cargoFeatures.features\": {\n                     \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    },\n                     \"default\": [],\n                     \"description\": \"List of features to activate\"\n                 }"}, {"sha": "337385a2458e37025400f782179af277b0feb40f", "filename": "editors/code/rollup.config.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Frollup.config.js", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Frollup.config.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Frollup.config.js?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -18,6 +18,7 @@ export default {\n     external: [...nodeBuiltins, 'vscode'],\n     output: {\n         file: './out/main.js',\n-        format: 'cjs'\n+        format: 'cjs',\n+        exports: 'named'\n     }\n };"}, {"sha": "efef820abfaf609fd0497b5a7f804922d339e36b", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -1,39 +1,42 @@\n import * as lc from 'vscode-languageclient';\n+import * as vscode from 'vscode';\n \n-import { window, workspace } from 'vscode';\n import { Config } from './config';\n-import { ensureLanguageServerBinary } from './installation/language_server';\n+import { ensureServerBinary } from './installation/server';\n+import { CallHierarchyFeature } from 'vscode-languageclient/lib/callHierarchy.proposed';\n \n export async function createClient(config: Config): Promise<null | lc.LanguageClient> {\n     // '.' Is the fallback if no folder is open\n     // TODO?: Workspace folders support Uri's (eg: file://test.txt).\n     // It might be a good idea to test if the uri points to a file.\n-    const workspaceFolderPath = workspace.workspaceFolders?.[0]?.uri.fsPath ?? '.';\n+    const workspaceFolderPath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath ?? '.';\n \n-    const raLspServerPath = await ensureLanguageServerBinary(config.langServerSource);\n-    if (!raLspServerPath) return null;\n+    const serverPath = await ensureServerBinary(config.serverSource);\n+    if (!serverPath) return null;\n \n     const run: lc.Executable = {\n-        command: raLspServerPath,\n+        command: serverPath,\n         options: { cwd: workspaceFolderPath },\n     };\n     const serverOptions: lc.ServerOptions = {\n         run,\n         debug: run,\n     };\n-    const traceOutputChannel = window.createOutputChannel(\n+    const traceOutputChannel = vscode.window.createOutputChannel(\n         'Rust Analyzer Language Server Trace',\n     );\n+    const cargoWatchOpts = config.cargoWatchOptions;\n+\n     const clientOptions: lc.LanguageClientOptions = {\n         documentSelector: [{ scheme: 'file', language: 'rust' }],\n         initializationOptions: {\n             publishDecorations: true,\n             lruCapacity: config.lruCapacity,\n             maxInlayHintLength: config.maxInlayHintLength,\n-            cargoWatchEnable: config.cargoWatchOptions.enable,\n-            cargoWatchArgs: config.cargoWatchOptions.arguments,\n-            cargoWatchCommand: config.cargoWatchOptions.command,\n-            cargoWatchAllTargets: config.cargoWatchOptions.allTargets,\n+            cargoWatchEnable: cargoWatchOpts.enable,\n+            cargoWatchArgs: cargoWatchOpts.arguments,\n+            cargoWatchCommand: cargoWatchOpts.command,\n+            cargoWatchAllTargets: cargoWatchOpts.allTargets,\n             excludeGlobs: config.excludeGlobs,\n             useClientWatching: config.useClientWatching,\n             featureFlags: config.featureFlags,\n@@ -78,6 +81,10 @@ export async function createClient(config: Config): Promise<null | lc.LanguageCl\n             }\n         },\n     };\n-    res.registerProposedFeatures();\n+\n+    // To turn on all proposed features use: res.registerProposedFeatures();\n+    // Here we want to just enable CallHierarchyFeature since it is available on stable.\n+    // Note that while the CallHierarchyFeature is stable the LSP protocol is not.\n+    res.registerFeature(new CallHierarchyFeature(res));\n     return res;\n }"}, {"sha": "70cb0a612a07f917223fbbebf38faf494bffa88d", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 91, "deletions": 203, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -16,45 +16,62 @@ export interface CargoFeatures {\n     allFeatures: boolean;\n     features: string[];\n }\n-\n export class Config {\n-    langServerSource!: null | BinarySource;\n-\n-    highlightingOn = true;\n-    rainbowHighlightingOn = false;\n-    enableEnhancedTyping = true;\n-    lruCapacity: null | number = null;\n-    displayInlayHints = true;\n-    maxInlayHintLength: null | number = null;\n-    excludeGlobs: string[] = [];\n-    useClientWatching = true;\n-    featureFlags: Record<string, boolean> = {};\n-    // for internal use\n-    withSysroot: null | boolean = null;\n-    cargoWatchOptions: CargoWatchOptions = {\n-        enable: true,\n-        arguments: [],\n-        command: '',\n-        allTargets: true,\n-    };\n-    cargoFeatures: CargoFeatures = {\n-        noDefaultFeatures: false,\n-        allFeatures: true,\n-        features: [],\n-    };\n-\n-    private prevEnhancedTyping: null | boolean = null;\n-    private prevCargoFeatures: null | CargoFeatures = null;\n-    private prevCargoWatchOptions: null | CargoWatchOptions = null;\n-\n-    constructor(ctx: vscode.ExtensionContext) {\n-        vscode.workspace.onDidChangeConfiguration(_ => this.refresh(ctx), null, ctx.subscriptions);\n-        this.refresh(ctx);\n+    private static readonly rootSection = \"rust-analyzer\";\n+    private static readonly requiresReloadOpts = [\n+        \"cargoFeatures\",\n+        \"cargo-watch\",\n+    ]\n+    .map(opt => `${Config.rootSection}.${opt}`);\n+\n+    private static readonly extensionVersion: string = (() => {\n+        const packageJsonVersion = vscode\n+            .extensions\n+            .getExtension(\"matklad.rust-analyzer\")!\n+            .packageJSON\n+            .version as string; // n.n.YYYYMMDD\n+\n+        const realVersionRegexp = /^\\d+\\.\\d+\\.(\\d{4})(\\d{2})(\\d{2})/;\n+        const [, yyyy, mm, dd] = packageJsonVersion.match(realVersionRegexp)!;\n+\n+        return `${yyyy}-${mm}-${dd}`;\n+    })();\n+\n+    private cfg!: vscode.WorkspaceConfiguration;\n+\n+    constructor(private readonly ctx: vscode.ExtensionContext) {\n+        vscode.workspace.onDidChangeConfiguration(this.onConfigChange, this, ctx.subscriptions);\n+        this.refreshConfig();\n+    }\n+\n+\n+    private refreshConfig() {\n+        this.cfg = vscode.workspace.getConfiguration(Config.rootSection);\n+        console.log(\"Using configuration:\", this.cfg);\n     }\n \n-    private static expandPathResolving(path: string) {\n-        if (path.startsWith('~/')) {\n-            return path.replace('~', os.homedir());\n+    private async onConfigChange(event: vscode.ConfigurationChangeEvent) {\n+        this.refreshConfig();\n+\n+        const requiresReloadOpt = Config.requiresReloadOpts.find(\n+            opt => event.affectsConfiguration(opt)\n+        );\n+\n+        if (!requiresReloadOpt) return;\n+\n+        const userResponse = await vscode.window.showInformationMessage(\n+            `Changing \"${requiresReloadOpt}\" requires a reload`,\n+            \"Reload now\"\n+        );\n+\n+        if (userResponse === \"Reload now\") {\n+            vscode.commands.executeCommand(\"workbench.action.reloadWindow\");\n+        }\n+    }\n+\n+    private static replaceTildeWithHomeDir(path: string) {\n+        if (path.startsWith(\"~/\")) {\n+            return os.homedir() + path.slice(\"~\".length);\n         }\n         return path;\n     }\n@@ -64,17 +81,14 @@ export class Config {\n      * `platform` on GitHub releases. (It is also stored under the same name when\n      * downloaded by the extension).\n      */\n-    private static prebuiltLangServerFileName(\n-        platform: NodeJS.Platform,\n-        arch: string\n-    ): null | string {\n+    get prebuiltServerFileName(): null | string {\n         // See possible `arch` values here:\n         // https://nodejs.org/api/process.html#process_process_arch\n \n-        switch (platform) {\n+        switch (process.platform) {\n \n             case \"linux\": {\n-                switch (arch) {\n+                switch (process.arch) {\n                     case \"arm\":\n                     case \"arm64\": return null;\n \n@@ -97,188 +111,62 @@ export class Config {\n         }\n     }\n \n-    private static langServerBinarySource(\n-        ctx: vscode.ExtensionContext,\n-        config: vscode.WorkspaceConfiguration\n-    ): null | BinarySource {\n-        const langServerPath = RA_LSP_DEBUG ?? config.get<null | string>(\"raLspServerPath\");\n+    get serverSource(): null | BinarySource {\n+        const serverPath = RA_LSP_DEBUG ?? this.cfg.get<null | string>(\"raLspServerPath\");\n \n-        if (langServerPath) {\n+        if (serverPath) {\n             return {\n                 type: BinarySource.Type.ExplicitPath,\n-                path: Config.expandPathResolving(langServerPath)\n+                path: Config.replaceTildeWithHomeDir(serverPath)\n             };\n         }\n \n-        const prebuiltBinaryName = Config.prebuiltLangServerFileName(\n-            process.platform, process.arch\n-        );\n+        const prebuiltBinaryName = this.prebuiltServerFileName;\n \n         if (!prebuiltBinaryName) return null;\n \n         return {\n             type: BinarySource.Type.GithubRelease,\n-            dir: ctx.globalStoragePath,\n+            dir:  this.ctx.globalStoragePath,\n             file: prebuiltBinaryName,\n+            storage: this.ctx.globalState,\n+            version: Config.extensionVersion,\n             repo: {\n                 name: \"rust-analyzer\",\n                 owner: \"rust-analyzer\",\n             }\n         };\n     }\n \n+    // We don't do runtime config validation here for simplicity. More on stackoverflow:\n+    // https://stackoverflow.com/questions/60135780/what-is-the-best-way-to-type-check-the-configuration-for-vscode-extension\n \n-    // FIXME: revisit the logic for `if (.has(...)) config.get(...)` set default\n-    // values only in one place (i.e. remove default values from non-readonly members declarations)\n-    private refresh(ctx: vscode.ExtensionContext) {\n-        const config = vscode.workspace.getConfiguration('rust-analyzer');\n-\n-        let requireReloadMessage = null;\n-\n-        if (config.has('highlightingOn')) {\n-            this.highlightingOn = config.get('highlightingOn') as boolean;\n-        }\n-\n-        if (config.has('rainbowHighlightingOn')) {\n-            this.rainbowHighlightingOn = config.get(\n-                'rainbowHighlightingOn',\n-            ) as boolean;\n-        }\n-\n-        if (config.has('enableEnhancedTyping')) {\n-            this.enableEnhancedTyping = config.get(\n-                'enableEnhancedTyping',\n-            ) as boolean;\n-\n-            if (this.prevEnhancedTyping === null) {\n-                this.prevEnhancedTyping = this.enableEnhancedTyping;\n-            }\n-        } else if (this.prevEnhancedTyping === null) {\n-            this.prevEnhancedTyping = this.enableEnhancedTyping;\n-        }\n-\n-        if (this.prevEnhancedTyping !== this.enableEnhancedTyping) {\n-            requireReloadMessage =\n-                'Changing enhanced typing setting requires a reload';\n-            this.prevEnhancedTyping = this.enableEnhancedTyping;\n-        }\n-\n-        this.langServerSource = Config.langServerBinarySource(ctx, config);\n-\n-        if (config.has('cargo-watch.enable')) {\n-            this.cargoWatchOptions.enable = config.get<boolean>(\n-                'cargo-watch.enable',\n-                true,\n-            );\n-        }\n-\n-        if (config.has('cargo-watch.arguments')) {\n-            this.cargoWatchOptions.arguments = config.get<string[]>(\n-                'cargo-watch.arguments',\n-                [],\n-            );\n-        }\n-\n-        if (config.has('cargo-watch.command')) {\n-            this.cargoWatchOptions.command = config.get<string>(\n-                'cargo-watch.command',\n-                '',\n-            );\n-        }\n-\n-        if (config.has('cargo-watch.allTargets')) {\n-            this.cargoWatchOptions.allTargets = config.get<boolean>(\n-                'cargo-watch.allTargets',\n-                true,\n-            );\n-        }\n-\n-        if (config.has('lruCapacity')) {\n-            this.lruCapacity = config.get('lruCapacity') as number;\n-        }\n-\n-        if (config.has('displayInlayHints')) {\n-            this.displayInlayHints = config.get('displayInlayHints') as boolean;\n-        }\n-        if (config.has('maxInlayHintLength')) {\n-            this.maxInlayHintLength = config.get(\n-                'maxInlayHintLength',\n-            ) as number;\n-        }\n-        if (config.has('excludeGlobs')) {\n-            this.excludeGlobs = config.get('excludeGlobs') || [];\n-        }\n-        if (config.has('useClientWatching')) {\n-            this.useClientWatching = config.get('useClientWatching') || true;\n-        }\n-        if (config.has('featureFlags')) {\n-            this.featureFlags = config.get('featureFlags') || {};\n-        }\n-        if (config.has('withSysroot')) {\n-            this.withSysroot = config.get('withSysroot') || false;\n-        }\n+    get highlightingOn()        { return this.cfg.get(\"highlightingOn\") as boolean; }\n+    get rainbowHighlightingOn() { return this.cfg.get(\"rainbowHighlightingOn\") as boolean; }\n+    get lruCapacity()           { return this.cfg.get(\"lruCapacity\") as null | number; }\n+    get displayInlayHints()     { return this.cfg.get(\"displayInlayHints\") as boolean; }\n+    get maxInlayHintLength()    { return this.cfg.get(\"maxInlayHintLength\") as number; }\n+    get excludeGlobs()          { return this.cfg.get(\"excludeGlobs\") as string[]; }\n+    get useClientWatching()     { return this.cfg.get(\"useClientWatching\") as boolean; }\n+    get featureFlags()          { return this.cfg.get(\"featureFlags\") as Record<string, boolean>; }\n \n-        if (config.has('cargoFeatures.noDefaultFeatures')) {\n-            this.cargoFeatures.noDefaultFeatures = config.get(\n-                'cargoFeatures.noDefaultFeatures',\n-                false,\n-            );\n-        }\n-        if (config.has('cargoFeatures.allFeatures')) {\n-            this.cargoFeatures.allFeatures = config.get(\n-                'cargoFeatures.allFeatures',\n-                true,\n-            );\n-        }\n-        if (config.has('cargoFeatures.features')) {\n-            this.cargoFeatures.features = config.get(\n-                'cargoFeatures.features',\n-                [],\n-            );\n-        }\n+    get cargoWatchOptions(): CargoWatchOptions {\n+        return {\n+            enable:     this.cfg.get(\"cargo-watch.enable\") as boolean,\n+            arguments:  this.cfg.get(\"cargo-watch.arguments\") as string[],\n+            allTargets: this.cfg.get(\"cargo-watch.allTargets\") as boolean,\n+            command:    this.cfg.get(\"cargo-watch.command\") as string,\n+        };\n+    }\n \n-        if (\n-            this.prevCargoFeatures !== null &&\n-            (this.cargoFeatures.allFeatures !==\n-                this.prevCargoFeatures.allFeatures ||\n-                this.cargoFeatures.noDefaultFeatures !==\n-                this.prevCargoFeatures.noDefaultFeatures ||\n-                this.cargoFeatures.features.length !==\n-                this.prevCargoFeatures.features.length ||\n-                this.cargoFeatures.features.some(\n-                    (v, i) => v !== this.prevCargoFeatures!.features[i],\n-                ))\n-        ) {\n-            requireReloadMessage = 'Changing cargo features requires a reload';\n-        }\n-        this.prevCargoFeatures = { ...this.cargoFeatures };\n-\n-        if (this.prevCargoWatchOptions !== null) {\n-            const changed =\n-                this.cargoWatchOptions.enable !== this.prevCargoWatchOptions.enable ||\n-                this.cargoWatchOptions.command !== this.prevCargoWatchOptions.command ||\n-                this.cargoWatchOptions.allTargets !== this.prevCargoWatchOptions.allTargets ||\n-                this.cargoWatchOptions.arguments.length !== this.prevCargoWatchOptions.arguments.length ||\n-                this.cargoWatchOptions.arguments.some(\n-                    (v, i) => v !== this.prevCargoWatchOptions!.arguments[i],\n-                );\n-            if (changed) {\n-                requireReloadMessage = 'Changing cargo-watch options requires a reload';\n-            }\n-        }\n-        this.prevCargoWatchOptions = { ...this.cargoWatchOptions };\n-\n-        if (requireReloadMessage !== null) {\n-            const reloadAction = 'Reload now';\n-            vscode.window\n-                .showInformationMessage(requireReloadMessage, reloadAction)\n-                .then(selectedAction => {\n-                    if (selectedAction === reloadAction) {\n-                        vscode.commands.executeCommand(\n-                            'workbench.action.reloadWindow',\n-                        );\n-                    }\n-                });\n-        }\n+    get cargoFeatures(): CargoFeatures {\n+        return {\n+            noDefaultFeatures: this.cfg.get(\"cargoFeatures.noDefaultFeatures\") as boolean,\n+            allFeatures:       this.cfg.get(\"cargoFeatures.allFeatures\") as boolean,\n+            features:          this.cfg.get(\"cargoFeatures.features\") as string[],\n+        };\n     }\n+\n+    // for internal use\n+    get withSysroot() { return this.cfg.get(\"withSysroot\", true) as boolean; }\n }"}, {"sha": "9fcf2ec3826eda09743c2fcdbb910a5d7c1487b4", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -60,6 +60,10 @@ export class Ctx {\n         this.pushCleanup(d);\n     }\n \n+    get globalState(): vscode.Memento {\n+        return this.extCtx.globalState;\n+    }\n+\n     get subscriptions(): Disposable[] {\n         return this.extCtx.subscriptions;\n     }"}, {"sha": "de655f8f4b798fa0cb05a89ba4ea81352d3f4b9d", "filename": "editors/code/src/installation/download_artifact.ts", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Fdownload_artifact.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Fdownload_artifact.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Fdownload_artifact.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -0,0 +1,58 @@\n+import * as vscode from \"vscode\";\n+import * as path from \"path\";\n+import { promises as fs } from \"fs\";\n+import { strict as assert } from \"assert\";\n+\n+import { ArtifactReleaseInfo } from \"./interfaces\";\n+import { downloadFile } from \"./download_file\";\n+import { throttle } from \"throttle-debounce\";\n+\n+/**\n+ * Downloads artifact from given `downloadUrl`.\n+ * Creates `installationDir` if it is not yet created and put the artifact under\n+ * `artifactFileName`.\n+ * Displays info about the download progress in an info message printing the name\n+ * of the artifact as `displayName`.\n+ */\n+export async function downloadArtifact(\n+    {downloadUrl, releaseName}: ArtifactReleaseInfo,\n+    artifactFileName: string,\n+    installationDir: string,\n+    displayName: string,\n+) {\n+    await fs.mkdir(installationDir).catch(err => assert.strictEqual(\n+        err?.code,\n+        \"EEXIST\",\n+        `Couldn't create directory \"${installationDir}\" to download `+\n+        `${artifactFileName} artifact: ${err.message}`\n+    ));\n+\n+    const installationPath = path.join(installationDir, artifactFileName);\n+\n+    console.time(`Downloading ${artifactFileName}`);\n+    await vscode.window.withProgress(\n+        {\n+            location: vscode.ProgressLocation.Notification,\n+            cancellable: false, // FIXME: add support for canceling download?\n+            title: `Downloading ${displayName} (${releaseName})`\n+        },\n+        async (progress, _cancellationToken) => {\n+            let lastPrecentage = 0;\n+            const filePermissions = 0o755; // (rwx, r_x, r_x)\n+            await downloadFile(downloadUrl, installationPath, filePermissions, throttle(\n+                200,\n+                /* noTrailing: */ true,\n+                (readBytes, totalBytes) => {\n+                    const newPercentage = (readBytes / totalBytes) * 100;\n+                    progress.report({\n+                        message: newPercentage.toFixed(0) + \"%\",\n+                        increment: newPercentage - lastPrecentage\n+                    });\n+\n+                    lastPrecentage = newPercentage;\n+                })\n+            );\n+        }\n+    );\n+    console.timeEnd(`Downloading ${artifactFileName}`);\n+}"}, {"sha": "7d497057aa4787ce05644e1f127e2ebfb2b4be76", "filename": "editors/code/src/installation/fetch_artifact_release_info.ts", "status": "renamed", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Ffetch_artifact_release_info.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Ffetch_artifact_release_info.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Ffetch_artifact_release_info.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -1,26 +1,32 @@\n import fetch from \"node-fetch\";\n-import { GithubRepo, ArtifactMetadata } from \"./interfaces\";\n+import { GithubRepo, ArtifactReleaseInfo } from \"./interfaces\";\n \n const GITHUB_API_ENDPOINT_URL = \"https://api.github.com\";\n \n+\n /**\n- * Fetches the latest release from GitHub `repo` and returns metadata about\n- * `artifactFileName` shipped with this release or `null` if no such artifact was published.\n+ * Fetches the release with `releaseTag` (or just latest release when not specified)\n+ * from GitHub `repo` and returns metadata about `artifactFileName` shipped with\n+ * this release or `null` if no such artifact was published.\n  */\n-export async function fetchLatestArtifactMetadata(\n-    repo: GithubRepo, artifactFileName: string\n-): Promise<null | ArtifactMetadata> {\n+export async function fetchArtifactReleaseInfo(\n+    repo: GithubRepo, artifactFileName: string, releaseTag?: string\n+): Promise<null | ArtifactReleaseInfo> {\n \n     const repoOwner = encodeURIComponent(repo.owner);\n     const repoName  = encodeURIComponent(repo.name);\n \n-    const apiEndpointPath = `/repos/${repoOwner}/${repoName}/releases/latest`;\n+    const apiEndpointPath = releaseTag\n+        ? `/repos/${repoOwner}/${repoName}/releases/tags/${releaseTag}`\n+        : `/repos/${repoOwner}/${repoName}/releases/latest`;\n+\n     const requestUrl = GITHUB_API_ENDPOINT_URL + apiEndpointPath;\n \n     // We skip runtime type checks for simplicity (here we cast from `any` to `GithubRelease`)\n \n     console.log(\"Issuing request for released artifacts metadata to\", requestUrl);\n \n+    // FIXME: handle non-ok response\n     const response: GithubRelease = await fetch(requestUrl, {\n             headers: { Accept: \"application/vnd.github.v3+json\" }\n         })", "previous_filename": "editors/code/src/installation/fetch_latest_artifact_metadata.ts"}, {"sha": "e40839e4b2ba4fc36cd74c73cc444f35483565d0", "filename": "editors/code/src/installation/interfaces.ts", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Finterfaces.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Finterfaces.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Finterfaces.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -1,3 +1,5 @@\n+import * as vscode from \"vscode\";\n+\n export interface GithubRepo {\n     name: string;\n     owner: string;\n@@ -6,7 +8,7 @@ export interface GithubRepo {\n /**\n  * Metadata about particular artifact retrieved from GitHub releases.\n  */\n-export interface ArtifactMetadata {\n+export interface ArtifactReleaseInfo {\n     releaseName: string;\n     downloadUrl: string;\n }\n@@ -50,6 +52,17 @@ export namespace BinarySource {\n          * and in local `.dir`.\n          */\n         file: string;\n+\n+        /**\n+         * Tag of github release that denotes a version required by this extension.\n+         */\n+        version: string;\n+\n+        /**\n+         * Object that provides `get()/update()` operations to store metadata\n+         * about the actual binary, e.g. its actual version.\n+         */\n+        storage: vscode.Memento;\n     }\n \n }"}, {"sha": "4797c3f01adb857e514194bcb2c1ef4ea193c9c9", "filename": "editors/code/src/installation/language_server.ts", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b446384956243ce6bdcef2a869123a2605e597ed/editors%2Fcode%2Fsrc%2Finstallation%2Flanguage_server.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b446384956243ce6bdcef2a869123a2605e597ed/editors%2Fcode%2Fsrc%2Finstallation%2Flanguage_server.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Flanguage_server.ts?ref=b446384956243ce6bdcef2a869123a2605e597ed", "patch": "@@ -1,148 +0,0 @@\n-import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { strict as assert } from \"assert\";\n-import { promises as fs } from \"fs\";\n-import { promises as dns } from \"dns\";\n-import { spawnSync } from \"child_process\";\n-import { throttle } from \"throttle-debounce\";\n-\n-import { BinarySource } from \"./interfaces\";\n-import { fetchLatestArtifactMetadata } from \"./fetch_latest_artifact_metadata\";\n-import { downloadFile } from \"./download_file\";\n-\n-export async function downloadLatestLanguageServer(\n-    {file: artifactFileName, dir: installationDir, repo}: BinarySource.GithubRelease\n-) {\n-    const { releaseName, downloadUrl } = (await fetchLatestArtifactMetadata(\n-        repo, artifactFileName\n-    ))!;\n-\n-    await fs.mkdir(installationDir).catch(err => assert.strictEqual(\n-        err?.code,\n-        \"EEXIST\",\n-        `Couldn't create directory \"${installationDir}\" to download `+\n-        `language server binary: ${err.message}`\n-    ));\n-\n-    const installationPath = path.join(installationDir, artifactFileName);\n-\n-    console.time(\"Downloading ra_lsp_server\");\n-    await vscode.window.withProgress(\n-        {\n-            location: vscode.ProgressLocation.Notification,\n-            cancellable: false, // FIXME: add support for canceling download?\n-            title: `Downloading language server (${releaseName})`\n-        },\n-        async (progress, _cancellationToken) => {\n-            let lastPrecentage = 0;\n-            const filePermissions = 0o755; // (rwx, r_x, r_x)\n-            await downloadFile(downloadUrl, installationPath, filePermissions, throttle(\n-                200,\n-                /* noTrailing: */ true,\n-                (readBytes, totalBytes) => {\n-                    const newPercentage = (readBytes / totalBytes) * 100;\n-                    progress.report({\n-                        message: newPercentage.toFixed(0) + \"%\",\n-                        increment: newPercentage - lastPrecentage\n-                    });\n-\n-                    lastPrecentage = newPercentage;\n-                })\n-            );\n-        }\n-    );\n-    console.timeEnd(\"Downloading ra_lsp_server\");\n-}\n-export async function ensureLanguageServerBinary(\n-    langServerSource: null | BinarySource\n-): Promise<null | string> {\n-\n-    if (!langServerSource) {\n-        vscode.window.showErrorMessage(\n-            \"Unfortunately we don't ship binaries for your platform yet. \" +\n-            \"You need to manually clone rust-analyzer repository and \" +\n-            \"run `cargo xtask install --server` to build the language server from sources. \" +\n-            \"If you feel that your platform should be supported, please create an issue \" +\n-            \"about that [here](https://github.com/rust-analyzer/rust-analyzer/issues) and we \" +\n-            \"will consider it.\"\n-        );\n-        return null;\n-    }\n-\n-    switch (langServerSource.type) {\n-        case BinarySource.Type.ExplicitPath: {\n-            if (isBinaryAvailable(langServerSource.path)) {\n-                return langServerSource.path;\n-            }\n-\n-            vscode.window.showErrorMessage(\n-                `Unable to run ${langServerSource.path} binary. ` +\n-                `To use the pre-built language server, set \"rust-analyzer.raLspServerPath\" ` +\n-                \"value to `null` or remove it from the settings to use it by default.\"\n-            );\n-            return null;\n-        }\n-        case BinarySource.Type.GithubRelease: {\n-            const prebuiltBinaryPath = path.join(langServerSource.dir, langServerSource.file);\n-\n-            if (isBinaryAvailable(prebuiltBinaryPath)) {\n-                return prebuiltBinaryPath;\n-            }\n-\n-            const userResponse = await vscode.window.showInformationMessage(\n-                \"Language server binary for rust-analyzer was not found. \" +\n-                \"Do you want to download it now?\",\n-                \"Download now\", \"Cancel\"\n-            );\n-            if (userResponse !== \"Download now\") return null;\n-\n-            try {\n-                await downloadLatestLanguageServer(langServerSource);\n-            } catch (err) {\n-                vscode.window.showErrorMessage(\n-                    `Failed to download language server from ${langServerSource.repo.name} ` +\n-                    `GitHub repository: ${err.message}`\n-                );\n-\n-                console.error(err);\n-\n-                dns.resolve('example.com').then(\n-                    addrs => console.log(\"DNS resolution for example.com was successful\", addrs),\n-                    err => {\n-                        console.error(\n-                            \"DNS resolution for example.com failed, \" +\n-                            \"there might be an issue with Internet availability\"\n-                        );\n-                        console.error(err);\n-                    }\n-                );\n-\n-                return null;\n-            }\n-\n-            if (!isBinaryAvailable(prebuiltBinaryPath)) assert(false,\n-                `Downloaded language server binary is not functional.` +\n-                `Downloaded from: ${JSON.stringify(langServerSource)}`\n-            );\n-\n-\n-            vscode.window.showInformationMessage(\n-                \"Rust analyzer language server was successfully installed \ud83e\udd80\"\n-            );\n-\n-            return prebuiltBinaryPath;\n-        }\n-    }\n-\n-    function isBinaryAvailable(binaryPath: string) {\n-        const res = spawnSync(binaryPath, [\"--version\"]);\n-\n-        // ACHTUNG! `res` type declaration is inherently wrong, see\n-        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/42221\n-\n-        console.log(\"Checked binary availablity via --version\", res);\n-        console.log(binaryPath, \"--version output:\", res.output?.map(String));\n-\n-        return res.status === 0;\n-    }\n-}"}, {"sha": "80cb719e3674431ea78394fd8795d4282453b564", "filename": "editors/code/src/installation/server.ts", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Finstallation%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Fserver.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -0,0 +1,124 @@\n+import * as vscode from \"vscode\";\n+import * as path from \"path\";\n+import { strict as assert } from \"assert\";\n+import { promises as dns } from \"dns\";\n+import { spawnSync } from \"child_process\";\n+\n+import { BinarySource } from \"./interfaces\";\n+import { fetchArtifactReleaseInfo } from \"./fetch_artifact_release_info\";\n+import { downloadArtifact } from \"./download_artifact\";\n+\n+export async function ensureServerBinary(source: null | BinarySource): Promise<null | string> {\n+    if (!source) {\n+        vscode.window.showErrorMessage(\n+            \"Unfortunately we don't ship binaries for your platform yet. \" +\n+            \"You need to manually clone rust-analyzer repository and \" +\n+            \"run `cargo xtask install --server` to build the language server from sources. \" +\n+            \"If you feel that your platform should be supported, please create an issue \" +\n+            \"about that [here](https://github.com/rust-analyzer/rust-analyzer/issues) and we \" +\n+            \"will consider it.\"\n+        );\n+        return null;\n+    }\n+\n+    switch (source.type) {\n+        case BinarySource.Type.ExplicitPath: {\n+            if (isBinaryAvailable(source.path)) {\n+                return source.path;\n+            }\n+\n+            vscode.window.showErrorMessage(\n+                `Unable to run ${source.path} binary. ` +\n+                `To use the pre-built language server, set \"rust-analyzer.raLspServerPath\" ` +\n+                \"value to `null` or remove it from the settings to use it by default.\"\n+            );\n+            return null;\n+        }\n+        case BinarySource.Type.GithubRelease: {\n+            const prebuiltBinaryPath = path.join(source.dir, source.file);\n+\n+            const installedVersion: null | string = getServerVersion(source.storage);\n+            const requiredVersion: string = source.version;\n+\n+            console.log(\"Installed version:\", installedVersion, \"required:\", requiredVersion);\n+\n+            if (isBinaryAvailable(prebuiltBinaryPath) && installedVersion == requiredVersion) {\n+                // FIXME: check for new releases and notify the user to update if possible\n+                return prebuiltBinaryPath;\n+            }\n+\n+            const userResponse = await vscode.window.showInformationMessage(\n+                `Language server version ${source.version} for rust-analyzer is not installed. ` +\n+                \"Do you want to download it now?\",\n+                \"Download now\", \"Cancel\"\n+            );\n+            if (userResponse !== \"Download now\") return null;\n+\n+            if (!await downloadServer(source)) return null;\n+\n+            return prebuiltBinaryPath;\n+        }\n+    }\n+}\n+\n+async function downloadServer(source: BinarySource.GithubRelease): Promise<boolean> {\n+    try {\n+        const releaseInfo = (await fetchArtifactReleaseInfo(source.repo, source.file, source.version))!;\n+\n+        await downloadArtifact(releaseInfo, source.file, source.dir, \"language server\");\n+        await setServerVersion(source.storage, releaseInfo.releaseName);\n+    } catch (err) {\n+        vscode.window.showErrorMessage(\n+            `Failed to download language server from ${source.repo.name} ` +\n+            `GitHub repository: ${err.message}`\n+        );\n+\n+        console.error(err);\n+\n+        dns.resolve('example.com').then(\n+            addrs => console.log(\"DNS resolution for example.com was successful\", addrs),\n+            err => {\n+                console.error(\n+                    \"DNS resolution for example.com failed, \" +\n+                    \"there might be an issue with Internet availability\"\n+                );\n+                console.error(err);\n+            }\n+        );\n+        return false;\n+    }\n+\n+    if (!isBinaryAvailable(path.join(source.dir, source.file))) assert(false,\n+        `Downloaded language server binary is not functional.` +\n+        `Downloaded from: ${JSON.stringify(source, null, 4)}`\n+    );\n+\n+    vscode.window.showInformationMessage(\n+        \"Rust analyzer language server was successfully installed \ud83e\udd80\"\n+    );\n+\n+    return true;\n+}\n+\n+function isBinaryAvailable(binaryPath: string): boolean {\n+    const res = spawnSync(binaryPath, [\"--version\"]);\n+\n+    // ACHTUNG! `res` type declaration is inherently wrong, see\n+    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/42221\n+\n+    console.log(\"Checked binary availablity via --version\", res);\n+    console.log(binaryPath, \"--version output:\", res.output?.map(String));\n+\n+    return res.status === 0;\n+}\n+\n+function getServerVersion(storage: vscode.Memento): null | string {\n+    const version = storage.get<null | string>(\"server-version\", null);\n+    console.log(\"Get server-version:\", version);\n+    return version;\n+}\n+\n+async function setServerVersion(storage: vscode.Memento, version: string): Promise<void> {\n+    console.log(\"Set server-version:\", version);\n+    await storage.update(\"server-version\", version.toString());\n+}"}, {"sha": "993e79d70360f274ebd303ee4ff64aed611b8bca", "filename": "editors/code/src/status_display.ts", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fstatus_display.ts", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/editors%2Fcode%2Fsrc%2Fstatus_display.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fstatus_display.ts?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -66,9 +66,9 @@ class StatusDisplay implements Disposable {\n \n     refreshLabel() {\n         if (this.packageName) {\n-            this.statusBarItem!.text = `${spinnerFrames[this.i]} cargo ${this.command} [${this.packageName}]`;\n+            this.statusBarItem.text = `${spinnerFrames[this.i]} cargo ${this.command} [${this.packageName}]`;\n         } else {\n-            this.statusBarItem!.text = `${spinnerFrames[this.i]} cargo ${this.command}`;\n+            this.statusBarItem.text = `${spinnerFrames[this.i]} cargo ${this.command}`;\n         }\n     }\n "}, {"sha": "37497fb7458b688d7f90ea974142c92392ee1d63", "filename": "xtask/src/cmd.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b446384956243ce6bdcef2a869123a2605e597ed/xtask%2Fsrc%2Fcmd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b446384956243ce6bdcef2a869123a2605e597ed/xtask%2Fsrc%2Fcmd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcmd.rs?ref=b446384956243ce6bdcef2a869123a2605e597ed", "patch": "@@ -1,56 +0,0 @@\n-use std::process::{Command, Output, Stdio};\n-\n-use anyhow::{Context, Result};\n-\n-use crate::project_root;\n-\n-pub struct Cmd<'a> {\n-    pub unix: &'a str,\n-    pub windows: &'a str,\n-    pub work_dir: &'a str,\n-}\n-\n-impl Cmd<'_> {\n-    pub fn run(self) -> Result<()> {\n-        if cfg!(windows) {\n-            run(self.windows, self.work_dir)\n-        } else {\n-            run(self.unix, self.work_dir)\n-        }\n-    }\n-    pub fn run_with_output(self) -> Result<String> {\n-        if cfg!(windows) {\n-            run_with_output(self.windows, self.work_dir)\n-        } else {\n-            run_with_output(self.unix, self.work_dir)\n-        }\n-    }\n-}\n-\n-pub fn run(cmdline: &str, dir: &str) -> Result<()> {\n-    do_run(cmdline, dir, &mut |c| {\n-        c.stdout(Stdio::inherit());\n-    })\n-    .map(|_| ())\n-}\n-\n-pub fn run_with_output(cmdline: &str, dir: &str) -> Result<String> {\n-    let output = do_run(cmdline, dir, &mut |_| {})?;\n-    let stdout = String::from_utf8(output.stdout)?;\n-    let stdout = stdout.trim().to_string();\n-    Ok(stdout)\n-}\n-\n-fn do_run(cmdline: &str, dir: &str, f: &mut dyn FnMut(&mut Command)) -> Result<Output> {\n-    eprintln!(\"\\nwill run: {}\", cmdline);\n-    let proj_dir = project_root().join(dir);\n-    let mut args = cmdline.split_whitespace();\n-    let exec = args.next().unwrap();\n-    let mut cmd = Command::new(exec);\n-    f(cmd.args(args).current_dir(proj_dir).stderr(Stdio::inherit()));\n-    let output = cmd.output().with_context(|| format!(\"running `{}`\", cmdline))?;\n-    if !output.status.success() {\n-        anyhow::bail!(\"`{}` exited with {}\", cmdline, output.status);\n-    }\n-    Ok(output)\n-}"}, {"sha": "00bbabce431cb41323b85e986020ad1867642597", "filename": "xtask/src/install.rs", "status": "modified", "additions": 46, "deletions": 72, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Finstall.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -2,9 +2,9 @@\n \n use std::{env, path::PathBuf, str};\n \n-use anyhow::{Context, Result};\n+use anyhow::{bail, format_err, Context, Result};\n \n-use crate::cmd::{run, run_with_output, Cmd};\n+use crate::not_bash::{ls, pushd, rm, run};\n \n // Latest stable, feel free to send a PR if this lags behind.\n const REQUIRED_RUST_VERSION: u32 = 41;\n@@ -55,7 +55,7 @@ fn fix_path_for_mac() -> Result<()> {\n         const ROOT_DIR: &str = \"\";\n         let home_dir = match env::var(\"HOME\") {\n             Ok(home) => home,\n-            Err(e) => anyhow::bail!(\"Failed getting HOME from environment with error: {}.\", e),\n+            Err(e) => bail!(\"Failed getting HOME from environment with error: {}.\", e),\n         };\n \n         [ROOT_DIR, &home_dir]\n@@ -69,7 +69,7 @@ fn fix_path_for_mac() -> Result<()> {\n     if !vscode_path.is_empty() {\n         let vars = match env::var_os(\"PATH\") {\n             Some(path) => path,\n-            None => anyhow::bail!(\"Could not get PATH variable from env.\"),\n+            None => bail!(\"Could not get PATH variable from env.\"),\n         };\n \n         let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n@@ -82,84 +82,61 @@ fn fix_path_for_mac() -> Result<()> {\n }\n \n fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n-    let npm_version = Cmd {\n-        unix: r\"npm --version\",\n-        windows: r\"cmd.exe /c npm --version\",\n-        work_dir: \"./editors/code\",\n-    }\n-    .run();\n-\n-    if npm_version.is_err() {\n-        eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n-    }\n+    let _dir = pushd(\"./editors/code\");\n \n-    Cmd { unix: r\"npm install\", windows: r\"cmd.exe /c npm install\", work_dir: \"./editors/code\" }\n-        .run()?;\n-    Cmd {\n-        unix: r\"npm run package --scripts-prepend-node-path\",\n-        windows: r\"cmd.exe /c npm run package\",\n-        work_dir: \"./editors/code\",\n-    }\n-    .run()?;\n+    let find_code = |f: fn(&str) -> bool| -> Result<&'static str> {\n+        [\"code\", \"code-insiders\", \"codium\", \"code-oss\"]\n+            .iter()\n+            .copied()\n+            .find(|bin| f(bin))\n+            .ok_or_else(|| {\n+                format_err!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\")\n+            })\n+    };\n \n-    let code_binary = [\"code\", \"code-insiders\", \"codium\", \"code-oss\"].iter().find(|bin| {\n-        Cmd {\n-            unix: &format!(\"{} --version\", bin),\n-            windows: &format!(\"cmd.exe /c {}.cmd --version\", bin),\n-            work_dir: \"./editors/code\",\n-        }\n-        .run()\n-        .is_ok()\n-    });\n+    let installed_extensions;\n+    if cfg!(unix) {\n+        run!(\"npm --version\").context(\"`npm` is required to build the VS Code plugin\")?;\n+        run!(\"npm install\")?;\n \n-    let code_binary = match code_binary {\n-        Some(it) => it,\n-        None => anyhow::bail!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\"),\n-    };\n+        let vsix_pkg = {\n+            rm(\"*.vsix\")?;\n+            run!(\"npm run package --scripts-prepend-node-path\")?;\n+            ls(\"*.vsix\")?.pop().unwrap()\n+        };\n \n-    Cmd {\n-        unix: &format!(r\"{} --install-extension ./rust-analyzer-0.1.0.vsix --force\", code_binary),\n-        windows: &format!(\n-            r\"cmd.exe /c {}.cmd --install-extension ./rust-analyzer-0.1.0.vsix --force\",\n-            code_binary\n-        ),\n-        work_dir: \"./editors/code\",\n-    }\n-    .run()?;\n+        let code = find_code(|bin| run!(\"{} --version\", bin).is_ok())?;\n+        run!(\"{} --install-extension {} --force\", code, vsix_pkg.display())?;\n+        installed_extensions = run!(\"{} --list-extensions\", code; echo = false)?;\n+    } else {\n+        run!(\"cmd.exe /c npm --version\")\n+            .context(\"`npm` is required to build the VS Code plugin\")?;\n+        run!(\"cmd.exe /c npm install\")?;\n+\n+        let vsix_pkg = {\n+            rm(\"*.vsix\")?;\n+            run!(\"cmd.exe /c npm run package\")?;\n+            ls(\"*.vsix\")?.pop().unwrap()\n+        };\n \n-    let installed_extensions = Cmd {\n-        unix: &format!(r\"{} --list-extensions\", code_binary),\n-        windows: &format!(r\"cmd.exe /c {}.cmd --list-extensions\", code_binary),\n-        work_dir: \".\",\n+        let code = find_code(|bin| run!(\"cmd.exe /c {}.cmd --version\", bin).is_ok())?;\n+        run!(r\"cmd.exe /c {}.cmd --install-extension {} --force\", code, vsix_pkg.display())?;\n+        installed_extensions = run!(\"cmd.exe /c {}.cmd --list-extensions\", code; echo = false)?;\n     }\n-    .run_with_output()?;\n \n     if !installed_extensions.contains(\"rust-analyzer\") {\n-        anyhow::bail!(\n+        bail!(\n             \"Could not install the Visual Studio Code extension. \\\n-             Please make sure you have at least NodeJS 10.x together with the latest version of VS Code installed and try again.\"\n+             Please make sure you have at least NodeJS 12.x together with the latest version of VS Code installed and try again.\"\n         );\n     }\n \n-    if installed_extensions.contains(\"ra-lsp\") {\n-        Cmd {\n-            unix: &format!(r\"{} --uninstall-extension matklad.ra-lsp\", code_binary),\n-            windows: &format!(\n-                r\"cmd.exe /c {}.cmd --uninstall-extension matklad.ra-lsp\",\n-                code_binary\n-            ),\n-            work_dir: \"./editors/code\",\n-        }\n-        .run()?;\n-    }\n-\n     Ok(())\n }\n \n fn install_server(opts: ServerOpt) -> Result<()> {\n     let mut old_rust = false;\n-    if let Ok(stdout) = run_with_output(\"cargo --version\", \".\") {\n-        println!(\"{}\", stdout);\n+    if let Ok(stdout) = run!(\"cargo --version\") {\n         if !check_version(&stdout, REQUIRED_RUST_VERSION) {\n             old_rust = true;\n         }\n@@ -172,20 +149,17 @@ fn install_server(opts: ServerOpt) -> Result<()> {\n         )\n     }\n \n-    let res = if opts.jemalloc {\n-        run(\"cargo install --path crates/ra_lsp_server --locked --force --features jemalloc\", \".\")\n-    } else {\n-        run(\"cargo install --path crates/ra_lsp_server --locked --force\", \".\")\n-    };\n+    let jemalloc = if opts.jemalloc { \"--features jemalloc\" } else { \"\" };\n+    let res = run!(\"cargo install --path crates/ra_lsp_server --locked --force {}\", jemalloc);\n \n     if res.is_err() && old_rust {\n         eprintln!(\n             \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n             REQUIRED_RUST_VERSION,\n-        )\n+        );\n     }\n \n-    res\n+    res.map(drop)\n }\n \n fn check_version(version_output: &str, min_minor_version: u32) -> bool {"}, {"sha": "2bcd76d60b0bfcdb07b52424175ac9b3e057f2ce", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-mod cmd;\n+pub mod not_bash;\n pub mod install;\n pub mod pre_commit;\n \n@@ -9,15 +9,15 @@ mod ast_src;\n \n use anyhow::Context;\n use std::{\n-    env, fs,\n+    env,\n     io::Write,\n     path::{Path, PathBuf},\n     process::{Command, Stdio},\n };\n \n use crate::{\n-    cmd::{run, run_with_output},\n     codegen::Mode,\n+    not_bash::{fs2, pushd, rm_rf, run},\n };\n \n pub use anyhow::Result;\n@@ -38,9 +38,9 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     ensure_rustfmt()?;\n \n     if mode == Mode::Verify {\n-        run(&format!(\"rustup run {} -- cargo fmt -- --check\", TOOLCHAIN), \".\")?;\n+        run!(\"rustup run {} -- cargo fmt -- --check\", TOOLCHAIN)?;\n     } else {\n-        run(&format!(\"rustup run {} -- cargo fmt\", TOOLCHAIN), \".\")?;\n+        run!(\"rustup run {} -- cargo fmt\", TOOLCHAIN)?;\n     }\n     Ok(())\n }\n@@ -70,8 +70,9 @@ fn ensure_rustfmt() -> Result<()> {\n         Ok(status) if status.success() => return Ok(()),\n         _ => (),\n     };\n-    run(&format!(\"rustup toolchain install {}\", TOOLCHAIN), \".\")?;\n-    run(&format!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN), \".\")\n+    run!(\"rustup toolchain install {}\", TOOLCHAIN)?;\n+    run!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN)?;\n+    Ok(())\n }\n \n pub fn run_clippy() -> Result<()> {\n@@ -92,34 +93,28 @@ pub fn run_clippy() -> Result<()> {\n         \"clippy::nonminimal_bool\",\n         \"clippy::redundant_pattern_matching\",\n     ];\n-    run(\n-        &format!(\n-            \"rustup run {} -- cargo clippy --all-features --all-targets -- -A {}\",\n-            TOOLCHAIN,\n-            allowed_lints.join(\" -A \")\n-        ),\n-        \".\",\n+    run!(\n+        \"rustup run {} -- cargo clippy --all-features --all-targets -- -A {}\",\n+        TOOLCHAIN,\n+        allowed_lints.join(\" -A \")\n     )?;\n     Ok(())\n }\n \n fn install_clippy() -> Result<()> {\n-    run(&format!(\"rustup toolchain install {}\", TOOLCHAIN), \".\")?;\n-    run(&format!(\"rustup component add clippy --toolchain {}\", TOOLCHAIN), \".\")\n+    run!(\"rustup toolchain install {}\", TOOLCHAIN)?;\n+    run!(\"rustup component add clippy --toolchain {}\", TOOLCHAIN)?;\n+    Ok(())\n }\n \n pub fn run_fuzzer() -> Result<()> {\n-    match Command::new(\"cargo\")\n-        .args(&[\"fuzz\", \"--help\"])\n-        .stderr(Stdio::null())\n-        .stdout(Stdio::null())\n-        .status()\n-    {\n-        Ok(status) if status.success() => (),\n-        _ => run(\"cargo install cargo-fuzz\", \".\")?,\n+    let _d = pushd(\"./crates/ra_syntax\");\n+    if run!(\"cargo fuzz --help\").is_err() {\n+        run!(\"cargo install cargo-fuzz\")?;\n     };\n \n-    run(\"rustup run nightly -- cargo fuzz run parser\", \"./crates/ra_syntax\")\n+    run!(\"rustup run nightly -- cargo fuzz run parser\")?;\n+    Ok(())\n }\n \n /// Cleans the `./target` dir after the build such that only\n@@ -141,7 +136,7 @@ pub fn run_pre_cache() -> Result<()> {\n         }\n     }\n \n-    fs::remove_file(\"./target/.rustc_info.json\")?;\n+    fs2::remove_file(\"./target/.rustc_info.json\")?;\n     let to_delete = [\"ra_\", \"heavy_test\"];\n     for &dir in [\"./target/debug/deps\", \"target/debug/.fingerprint\"].iter() {\n         for entry in Path::new(dir).read_dir()? {\n@@ -155,22 +150,20 @@ pub fn run_pre_cache() -> Result<()> {\n     Ok(())\n }\n \n-fn rm_rf(path: &Path) -> Result<()> {\n-    if path.is_file() { fs::remove_file(path) } else { fs::remove_dir_all(path) }\n-        .with_context(|| format!(\"failed to remove {:?}\", path))\n-}\n-\n-pub fn run_release() -> Result<()> {\n-    run(\"git switch release\", \".\")?;\n-    run(\"git fetch upstream\", \".\")?;\n-    run(\"git reset --hard upstream/master\", \".\")?;\n-    run(\"git push\", \".\")?;\n+pub fn run_release(dry_run: bool) -> Result<()> {\n+    if !dry_run {\n+        run!(\"git switch release\")?;\n+        run!(\"git fetch upstream\")?;\n+        run!(\"git reset --hard upstream/master\")?;\n+        run!(\"git push\")?;\n+    }\n \n-    let changelog_dir = project_root().join(\"../rust-analyzer.github.io/thisweek/_posts\");\n+    let website_root = project_root().join(\"../rust-analyzer.github.io\");\n+    let changelog_dir = website_root.join(\"./thisweek/_posts\");\n \n-    let today = run_with_output(\"date --iso\", \".\")?;\n-    let commit = run_with_output(\"git rev-parse HEAD\", \".\")?;\n-    let changelog_n = fs::read_dir(changelog_dir.as_path())?.count();\n+    let today = run!(\"date --iso\")?;\n+    let commit = run!(\"git rev-parse HEAD\")?;\n+    let changelog_n = fs2::read_dir(changelog_dir.as_path())?.count();\n \n     let contents = format!(\n         \"\\\n@@ -193,7 +186,9 @@ Release: release:{}[]\n     );\n \n     let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n-    fs::write(&path, &contents)?;\n+    fs2::write(&path, &contents)?;\n+\n+    fs2::copy(project_root().join(\"./docs/user/readme.adoc\"), website_root.join(\"manual.adoc\"))?;\n \n     Ok(())\n }"}, {"sha": "a7dffe2cc87162c2af4f595da206123e3980537c", "filename": "xtask/src/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -93,8 +93,9 @@ FLAGS:\n             run_pre_cache()\n         }\n         \"release\" => {\n+            let dry_run = args.contains(\"--dry-run\");\n             args.finish()?;\n-            run_release()\n+            run_release(dry_run)\n         }\n         _ => {\n             eprintln!("}, {"sha": "3e30e7279ff4a75bc79e925c44cf7c646de358bb", "filename": "xtask/src/not_bash.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Fnot_bash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Fnot_bash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fnot_bash.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -0,0 +1,165 @@\n+//! A bad shell -- small cross platform module for writing glue code\n+use std::{\n+    cell::RefCell,\n+    env,\n+    ffi::OsStr,\n+    fs,\n+    path::{Path, PathBuf},\n+    process::{Command, Stdio},\n+};\n+\n+use anyhow::{bail, Context, Result};\n+\n+pub mod fs2 {\n+    use std::{fs, path::Path};\n+\n+    use anyhow::{Context, Result};\n+\n+    pub fn read_dir<P: AsRef<Path>>(path: P) -> Result<fs::ReadDir> {\n+        let path = path.as_ref();\n+        fs::read_dir(path).with_context(|| format!(\"Failed to read {}\", path.display()))\n+    }\n+\n+    pub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> Result<()> {\n+        let path = path.as_ref();\n+        fs::write(path, contents).with_context(|| format!(\"Failed to write {}\", path.display()))\n+    }\n+\n+    pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> Result<u64> {\n+        let from = from.as_ref();\n+        let to = to.as_ref();\n+        fs::copy(from, to)\n+            .with_context(|| format!(\"Failed to copy {} to {}\", from.display(), to.display()))\n+    }\n+\n+    pub fn remove_file<P: AsRef<Path>>(path: P) -> Result<()> {\n+        let path = path.as_ref();\n+        fs::remove_file(path).with_context(|| format!(\"Failed to remove file {}\", path.display()))\n+    }\n+\n+    pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> Result<()> {\n+        let path = path.as_ref();\n+        fs::remove_dir_all(path).with_context(|| format!(\"Failed to remove dir {}\", path.display()))\n+    }\n+}\n+\n+macro_rules! _run {\n+    ($($expr:expr),*) => {\n+        run!($($expr),*; echo = true)\n+    };\n+    ($($expr:expr),* ; echo = $echo:expr) => {\n+        $crate::not_bash::run_process(format!($($expr),*), $echo)\n+    };\n+}\n+pub(crate) use _run as run;\n+\n+pub struct Pushd {\n+    _p: (),\n+}\n+\n+pub fn pushd(path: impl Into<PathBuf>) -> Pushd {\n+    Env::with(|env| env.pushd(path.into()));\n+    Pushd { _p: () }\n+}\n+\n+impl Drop for Pushd {\n+    fn drop(&mut self) {\n+        Env::with(|env| env.popd())\n+    }\n+}\n+\n+pub fn rm(glob: &str) -> Result<()> {\n+    let cwd = Env::with(|env| env.cwd());\n+    ls(glob)?.into_iter().try_for_each(|it| fs::remove_file(cwd.join(it)))?;\n+    Ok(())\n+}\n+\n+pub fn rm_rf(path: impl AsRef<Path>) -> Result<()> {\n+    let path = path.as_ref();\n+    if path.is_file() {\n+        fs2::remove_file(path)\n+    } else {\n+        fs2::remove_dir_all(path)\n+    }\n+}\n+\n+pub fn ls(glob: &str) -> Result<Vec<PathBuf>> {\n+    let cwd = Env::with(|env| env.cwd());\n+    let mut res = Vec::new();\n+    for entry in fs::read_dir(&cwd)? {\n+        let entry = entry?;\n+        if matches(&entry.file_name(), glob) {\n+            let path = entry.path();\n+            let path = path.strip_prefix(&cwd).unwrap();\n+            res.push(path.to_path_buf())\n+        }\n+    }\n+    return Ok(res);\n+\n+    fn matches(file_name: &OsStr, glob: &str) -> bool {\n+        assert!(glob.starts_with('*'));\n+        file_name.to_string_lossy().ends_with(&glob[1..])\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub fn run_process(cmd: String, echo: bool) -> Result<String> {\n+    run_process_inner(&cmd, echo).with_context(|| format!(\"process `{}` failed\", cmd))\n+}\n+\n+fn run_process_inner(cmd: &str, echo: bool) -> Result<String> {\n+    let cwd = Env::with(|env| env.cwd());\n+    let mut args = shelx(cmd);\n+    let binary = args.remove(0);\n+\n+    if echo {\n+        println!(\"> {}\", cmd)\n+    }\n+\n+    let output = Command::new(binary)\n+        .args(args)\n+        .current_dir(cwd)\n+        .stdin(Stdio::null())\n+        .stderr(Stdio::inherit())\n+        .output()?;\n+    let stdout = String::from_utf8(output.stdout)?;\n+\n+    if echo {\n+        print!(\"{}\", stdout)\n+    }\n+\n+    if !output.status.success() {\n+        bail!(\"{}\", output.status)\n+    }\n+\n+    Ok(stdout.trim().to_string())\n+}\n+\n+// FIXME: some real shell lexing here\n+fn shelx(cmd: &str) -> Vec<String> {\n+    cmd.split_whitespace().map(|it| it.to_string()).collect()\n+}\n+\n+#[derive(Default)]\n+struct Env {\n+    pushd_stack: Vec<PathBuf>,\n+}\n+\n+impl Env {\n+    fn with<F: FnOnce(&mut Env) -> T, T>(f: F) -> T {\n+        thread_local! {\n+            static ENV: RefCell<Env> = Default::default();\n+        }\n+        ENV.with(|it| f(&mut *it.borrow_mut()))\n+    }\n+\n+    fn pushd(&mut self, dir: PathBuf) {\n+        self.pushd_stack.push(dir)\n+    }\n+    fn popd(&mut self) {\n+        self.pushd_stack.pop().unwrap();\n+    }\n+    fn cwd(&self) -> PathBuf {\n+        self.pushd_stack.last().cloned().unwrap_or_else(|| env::current_dir().unwrap())\n+    }\n+}"}, {"sha": "056f34acfb82ee4562900f9e98a565f3df11d53c", "filename": "xtask/src/pre_commit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Fpre_commit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e15d12e4211306273b0128cb4a80b552889543/xtask%2Fsrc%2Fpre_commit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpre_commit.rs?ref=58e15d12e4211306273b0128cb4a80b552889543", "patch": "@@ -4,18 +4,18 @@ use std::{fs, path::PathBuf};\n \n use anyhow::{bail, Result};\n \n-use crate::{cmd::run_with_output, project_root, run, run_rustfmt, Mode};\n+use crate::{not_bash::run, project_root, run_rustfmt, Mode};\n \n // FIXME: if there are changed `.ts` files, also reformat TypeScript (by\n // shelling out to `npm fmt`).\n pub fn run_hook() -> Result<()> {\n     run_rustfmt(Mode::Overwrite)?;\n \n-    let diff = run_with_output(\"git diff --diff-filter=MAR --name-only --cached\", \".\")?;\n+    let diff = run!(\"git diff --diff-filter=MAR --name-only --cached\")?;\n \n     let root = project_root();\n     for line in diff.lines() {\n-        run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;\n+        run!(\"git update-index --add {}\", root.join(line).display())?;\n     }\n \n     Ok(())"}]}