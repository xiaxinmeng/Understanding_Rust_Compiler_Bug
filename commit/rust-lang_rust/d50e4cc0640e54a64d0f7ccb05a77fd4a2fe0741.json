{"sha": "d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MGU0Y2MwNjQwZTU0YTY0ZDBmN2NjYjA1YTc3ZmQ0YTJmZTA3NDE=", "commit": {"author": {"name": "Yamakaky", "email": "yamakaky@yamaworld.fr", "date": "2016-12-04T21:38:27Z"}, "committer": {"name": "Yamakaky", "email": "yamakaky@yamaworld.fr", "date": "2017-02-15T19:24:37Z"}, "message": "Improve backtrace formating while panicking.\n\n- `RUST_BACKTRACE=full` prints all the informations (old behaviour)\n- `RUST_BACKTRACE=(0|no)` disables the backtrace.\n- `RUST_BACKTRACE=<everything else>` (including `1`) shows a simplified\n  backtrace, without the function addresses and with cleaned filenames\n  and symbols. Also removes some unneded frames at the beginning and the\n  end.\n\nFixes #37783.\n\nPR is #38165.", "tree": {"sha": "2c403c3c5fb8e02b5d5bbe493eec5375c47fd137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c403c3c5fb8e02b5d5bbe493eec5375c47fd137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEEt/Y5vtxe1Ue5GFKSH1EgxmwLZPcFAlikqvcWHHlhbWFrYWt5\nQHlhbWF3b3JsZC5mcgAKCRAfUSDGbAtk952eCACv+tvdoCFKnZqDECUTSRHKJgFW\npS6CLJUdBLb9KQw4JLqq5FzhTYVWW+E0ARFlYZkO+ufkiiU1xpTsNKC3+S/PzqOy\nkb8MhGpw+PGPEVD8cozzLy8z0lO6lXsiK5V8p02+Vk0XT9gOdVw18moVkX4v2G0r\n54jIf4aekvUKNyOfva05tobxRmOG7F1Dh3/8qdP1jTzs7wNzDlB8uc/JfIfXGrjF\nPiHlVn33xtkA9BcHrgYVodmovODu3KJ3HT5xwb0VPrIDSdaEJadqTyD3XMrJv5Gu\nkicnyRRzL7ecloscQ+Zzf+r5uII72FEkOAgml06t3Z6cQ9+9LXo1QiisUYDa\n=tMN9\n-----END PGP SIGNATURE-----", "payload": "tree 2c403c3c5fb8e02b5d5bbe493eec5375c47fd137\nparent e0044bd3896456afb346d06e91a97ac515930ccf\nauthor Yamakaky <yamakaky@yamaworld.fr> 1480887507 -0500\ncommitter Yamakaky <yamakaky@yamaworld.fr> 1487186677 -0500\n\nImprove backtrace formating while panicking.\n\n- `RUST_BACKTRACE=full` prints all the informations (old behaviour)\n- `RUST_BACKTRACE=(0|no)` disables the backtrace.\n- `RUST_BACKTRACE=<everything else>` (including `1`) shows a simplified\n  backtrace, without the function addresses and with cleaned filenames\n  and symbols. Also removes some unneded frames at the beginning and the\n  end.\n\nFixes #37783.\n\nPR is #38165.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "html_url": "https://github.com/rust-lang/rust/commit/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/comments", "author": {"login": "Yamakaky", "id": 1327378, "node_id": "MDQ6VXNlcjEzMjczNzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1327378?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yamakaky", "html_url": "https://github.com/Yamakaky", "followers_url": "https://api.github.com/users/Yamakaky/followers", "following_url": "https://api.github.com/users/Yamakaky/following{/other_user}", "gists_url": "https://api.github.com/users/Yamakaky/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yamakaky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yamakaky/subscriptions", "organizations_url": "https://api.github.com/users/Yamakaky/orgs", "repos_url": "https://api.github.com/users/Yamakaky/repos", "events_url": "https://api.github.com/users/Yamakaky/events{/privacy}", "received_events_url": "https://api.github.com/users/Yamakaky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Yamakaky", "id": 1327378, "node_id": "MDQ6VXNlcjEzMjczNzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1327378?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yamakaky", "html_url": "https://github.com/Yamakaky", "followers_url": "https://api.github.com/users/Yamakaky/followers", "following_url": "https://api.github.com/users/Yamakaky/following{/other_user}", "gists_url": "https://api.github.com/users/Yamakaky/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yamakaky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yamakaky/subscriptions", "organizations_url": "https://api.github.com/users/Yamakaky/orgs", "repos_url": "https://api.github.com/users/Yamakaky/repos", "events_url": "https://api.github.com/users/Yamakaky/events{/privacy}", "received_events_url": "https://api.github.com/users/Yamakaky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0044bd3896456afb346d06e91a97ac515930ccf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0044bd3896456afb346d06e91a97ac515930ccf", "html_url": "https://github.com/rust-lang/rust/commit/e0044bd3896456afb346d06e91a97ac515930ccf"}], "stats": {"total": 1316, "additions": 797, "deletions": 519}, "files": [{"sha": "96c8e9f5d683423aca4aafef93b7c9aec840ff19", "filename": "src/doc/book/src/functions.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Fdoc%2Fbook%2Fsrc%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Fdoc%2Fbook%2Fsrc%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ffunctions.md?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -230,6 +230,19 @@ If you want more information, you can get a backtrace by setting the\n ```text\n $ RUST_BACKTRACE=1 ./diverges\n thread 'main' panicked at 'This function never returns!', hello.rs:2\n+Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n+stack backtrace:\n+  hello::diverges\n+        at ./hello.rs:2\n+  hello::main\n+        at ./hello.rs:6\n+```\n+\n+If you want the complete backtrace and filenames:\n+\n+```text\n+$ RUST_BACKTRACE=full ./diverges\n+thread 'main' panicked at 'This function never returns!', hello.rs:2\n stack backtrace:\n    1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n    2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n@@ -262,7 +275,7 @@ note: Run with `RUST_BACKTRACE=1` for a backtrace.\n `RUST_BACKTRACE` also works with Cargo\u2019s `run` command:\n \n ```text\n-$ RUST_BACKTRACE=1 cargo run\n+$ RUST_BACKTRACE=full cargo run\n      Running `target/debug/diverges`\n thread 'main' panicked at 'This function never returns!', hello.rs:2\n stack backtrace:"}, {"sha": "3b5a1cffc7a2203dd7b7c8b9a52c720652396166", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -320,7 +320,11 @@ fn default_hook(info: &PanicInfo) {\n     let log_backtrace = {\n         let panics = update_panic_count(0);\n \n-        panics >= 2 || backtrace::log_enabled()\n+        if panics >= 2 {\n+            Some(backtrace::PrintFormat::Full)\n+        } else {\n+            backtrace::log_enabled()\n+        }\n     };\n \n     let file = info.location.file;\n@@ -347,8 +351,8 @@ fn default_hook(info: &PanicInfo) {\n \n             static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n-            if log_backtrace {\n-                let _ = backtrace::write(err);\n+            if let Some(format) = log_backtrace {\n+                let _ = backtrace::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n                 let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` for a backtrace.\");\n             }"}, {"sha": "961148fb6b4a8f11544f494b181f6ae4df33b6cd", "filename": "src/libstd/sys/redox/backtrace.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -10,9 +10,14 @@\n \n use libc;\n use io;\n-use sys_common::backtrace::output;\n+use sys_common::backtrace::Frame;\n+\n+pub use sys_common::gnu::libbacktrace::*;\n+pub struct BacktraceContext;\n \n #[inline(never)]\n-pub fn write(w: &mut io::Write) -> io::Result<()> {\n-    output(w, 0, 0 as *mut libc::c_void, None)\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    Ok((0, BacktraceContext))\n }"}, {"sha": "29d4012dcdf9890150e8e9f50d09f117b2ddffeb", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -83,7 +83,8 @@\n /// to symbols. This is a bit of a hokey implementation as-is, but it works for\n /// all unix platforms we support right now, so it at least gets the job done.\n \n-pub use self::tracing::write;\n+pub use self::tracing::unwind_backtrace;\n+pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n \n // tracing impls:\n mod tracing;\n@@ -100,3 +101,5 @@ pub mod gnu {\n         Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n     }\n }\n+\n+pub struct BacktraceContext;"}, {"sha": "05a071a79783841072bd20c7bf505e5197cf8b1b", "filename": "src/libstd/sys/unix/backtrace/printing/dladdr.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -9,33 +9,45 @@\n // except according to those terms.\n \n use io;\n-use io::prelude::*;\n+use intrinsics;\n+use ffi::CStr;\n use libc;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n \n-pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-             _symaddr: *mut libc::c_void) -> io::Result<()> {\n-    use sys_common::backtrace::{output};\n-    use intrinsics;\n-    use ffi::CStr;\n-\n-    #[repr(C)]\n-    struct Dl_info {\n-        dli_fname: *const libc::c_char,\n-        dli_fbase: *mut libc::c_void,\n-        dli_sname: *const libc::c_char,\n-        dli_saddr: *mut libc::c_void,\n-    }\n-    extern {\n-        fn dladdr(addr: *const libc::c_void,\n-                  info: *mut Dl_info) -> libc::c_int;\n+pub fn resolve_symname<F>(frame: Frame,\n+                          callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    unsafe {\n+        let mut info: Dl_info = intrinsics::init();\n+        let symname = if dladdr(frame.exact_position, &mut info) == 0 {\n+            None\n+        } else {\n+            CStr::from_ptr(info.dli_sname).to_str().ok()\n+        };\n+        callback(symname)\n     }\n+}\n \n-    let mut info: Dl_info = unsafe { intrinsics::init() };\n-    if unsafe { dladdr(addr, &mut info) == 0 } {\n-        output(w, idx,addr, None)\n-    } else {\n-        output(w, idx, addr, Some(unsafe {\n-            CStr::from_ptr(info.dli_sname).to_bytes()\n-        }))\n-    }\n+pub fn foreach_symbol_fileline<F>(_symbol_addr: Frame,\n+                                  _f: F,\n+                                  _: &BacktraceContext) -> io::Result<bool>\n+    where F: FnMut(&[u8], libc::c_int) -> io::Result<()>\n+{\n+    Ok(false)\n+}\n+\n+#[repr(C)]\n+struct Dl_info {\n+    dli_fname: *const libc::c_char,\n+    dli_fbase: *mut libc::c_void,\n+    dli_sname: *const libc::c_char,\n+    dli_saddr: *mut libc::c_void,\n+}\n+\n+extern {\n+    fn dladdr(addr: *const libc::c_void,\n+              info: *mut Dl_info) -> libc::c_int;\n }"}, {"sha": "1ae82e01100169e5cd451f317ce4eb944547e4b7", "filename": "src/libstd/sys/unix/backtrace/printing/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::imp::print;\n+pub use self::imp::{foreach_symbol_fileline, resolve_symname};\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n           target_os = \"emscripten\"))]\n@@ -17,5 +17,6 @@ mod imp;\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\",\n               target_os = \"emscripten\")))]\n-#[path = \"gnu.rs\"]\n-mod imp;\n+mod imp {\n+    pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n+}"}, {"sha": "fd46b8b9cf06e4463f342ec280df26d5b1b91be2", "filename": "src/libstd/sys/unix/backtrace/tracing/backtrace_fn.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -18,39 +18,32 @@\n /// simple to use it should be used only on iOS devices as the only viable\n /// option.\n \n-use io::prelude::*;\n use io;\n use libc;\n use mem;\n-use sys::mutex::Mutex;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n \n-use super::super::printing::print;\n-\n-#[inline(never)]\n-pub fn write(w: &mut Write) -> io::Result<()> {\n-    extern {\n-        fn backtrace(buf: *mut *mut libc::c_void,\n-                     sz: libc::c_int) -> libc::c_int;\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    const FRAME_LEN: usize = 100;\n+    assert!(FRAME_LEN >= frames.len());\n+    let mut raw_frames = [::std::ptr::null_mut(); FRAME_LEN];\n+    let nb_frames = unsafe {\n+        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n+    } as usize;\n+    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n+        *to = Frame {\n+            exact_position: *from,\n+            symbol_addr: *from,\n+        };\n     }\n+    Ok((nb_frames as usize, BacktraceContext))\n+}\n \n-    // while it doesn't requires lock for work as everything is\n-    // local, it still displays much nicer backtraces when a\n-    // couple of threads panic simultaneously\n-    static LOCK: Mutex = Mutex::new();\n-    unsafe {\n-        LOCK.lock();\n-\n-        writeln!(w, \"stack backtrace:\")?;\n-        // 100 lines should be enough\n-        const SIZE: usize = 100;\n-        let mut buf: [*mut libc::c_void; SIZE] = mem::zeroed();\n-        let cnt = backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as usize;\n-\n-        // skipping the first one as it is write itself\n-        for i in 1..cnt {\n-            print(w, i as isize, buf[i], buf[i])?\n-        }\n-        LOCK.unlock();\n-    }\n-    Ok(())\n+extern {\n+    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n }"}, {"sha": "8691fe55e7cebdd56f48604707b334803f9abc93", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "modified", "additions": 77, "deletions": 82, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -8,102 +8,97 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use error::Error;\n use io;\n-use io::prelude::*;\n use libc;\n-use mem;\n-use sys_common::mutex::Mutex;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n \n-use super::super::printing::print;\n use unwind as uw;\n \n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn write(w: &mut Write) -> io::Result<()> {\n-    struct Context<'a> {\n-        idx: isize,\n-        writer: &'a mut (Write+'a),\n-        last_error: Option<io::Error>,\n-    }\n+struct Context<'a> {\n+    idx: usize,\n+    frames: &'a mut [Frame],\n+}\n \n-    // When using libbacktrace, we use some necessary global state, so we\n-    // need to prevent more than one thread from entering this block. This\n-    // is semi-reasonable in terms of printing anyway, and we know that all\n-    // I/O done here is blocking I/O, not green I/O, so we don't have to\n-    // worry about this being a native vs green mutex.\n-    static LOCK: Mutex = Mutex::new();\n-    unsafe {\n-        LOCK.lock();\n+#[derive(Debug)]\n+struct UnwindError(uw::_Unwind_Reason_Code);\n \n-        writeln!(w, \"stack backtrace:\")?;\n+impl Error for UnwindError {\n+    fn description(&self) -> &'static str {\n+        \"unexpected return value while unwinding\"\n+    }\n+}\n \n-        let mut cx = Context { writer: w, last_error: None, idx: 0 };\n-        let ret = match {\n-            uw::_Unwind_Backtrace(trace_fn,\n-                                  &mut cx as *mut Context as *mut libc::c_void)\n-        } {\n-            uw::_URC_NO_REASON => {\n-                match cx.last_error {\n-                    Some(err) => Err(err),\n-                    None => Ok(())\n-                }\n-            }\n-            _ => Ok(()),\n-        };\n-        LOCK.unlock();\n-        return ret\n+impl ::fmt::Display for UnwindError {\n+    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        write!(f, \"{}: {:?}\", self.description(), self.0)\n     }\n+}\n \n-    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                       arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-        let cx: &mut Context = unsafe { mem::transmute(arg) };\n-        let mut ip_before_insn = 0;\n-        let mut ip = unsafe {\n-            uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n-        };\n-        if !ip.is_null() && ip_before_insn == 0 {\n-            // this is a non-signaling frame, so `ip` refers to the address\n-            // after the calling instruction. account for that.\n-            ip = (ip as usize - 1) as *mut _;\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    let mut cx = Context {\n+        idx: 0,\n+        frames: frames,\n+    };\n+    let result_unwind = unsafe {\n+        uw::_Unwind_Backtrace(trace_fn,\n+                              &mut cx as *mut Context\n+                              as *mut libc::c_void)\n+    };\n+    // See libunwind:src/unwind/Backtrace.c for the return values.\n+    // No, there is no doc.\n+    match result_unwind {\n+        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR => {\n+            Ok((cx.idx, BacktraceContext))\n         }\n-\n-        // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-        // it appears to work fine without it, so we only use\n-        // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-        // slightly more accurate stack trace in the process.\n-        //\n-        // This is often because panic involves the last instruction of a\n-        // function being \"call std::rt::begin_unwind\", with no ret\n-        // instructions after it. This means that the return instruction\n-        // pointer points *outside* of the calling function, and by\n-        // unwinding it we go back to the original function.\n-        let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-            ip\n-        } else {\n-            unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-        };\n-\n-        // Don't print out the first few frames (they're not user frames)\n-        cx.idx += 1;\n-        if cx.idx <= 0 { return uw::_URC_NO_REASON }\n-        // Don't print ginormous backtraces\n-        if cx.idx > 100 {\n-            match write!(cx.writer, \" ... <frames omitted>\\n\") {\n-                Ok(()) => {}\n-                Err(e) => { cx.last_error = Some(e); }\n-            }\n-            return uw::_URC_FAILURE\n+        _ => {\n+            Err(io::Error::new(io::ErrorKind::Other,\n+                               UnwindError(result_unwind)))\n         }\n+    }\n+}\n \n-        // Once we hit an error, stop trying to print more frames\n-        if cx.last_error.is_some() { return uw::_URC_FAILURE }\n+extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n+    let cx = unsafe { &mut *(arg as *mut Context) };\n+    let mut ip_before_insn = 0;\n+    let mut ip = unsafe {\n+        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n+    };\n+    if !ip.is_null() && ip_before_insn == 0 {\n+        // this is a non-signaling frame, so `ip` refers to the address\n+        // after the calling instruction. account for that.\n+        ip = (ip as usize - 1) as *mut _;\n+    }\n \n-        match print(cx.writer, cx.idx, ip, symaddr) {\n-            Ok(()) => {}\n-            Err(e) => { cx.last_error = Some(e); }\n-        }\n+    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+    // it appears to work fine without it, so we only use\n+    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+    // slightly more accurate stack trace in the process.\n+    //\n+    // This is often because panic involves the last instruction of a\n+    // function being \"call std::rt::begin_unwind\", with no ret\n+    // instructions after it. This means that the return instruction\n+    // pointer points *outside* of the calling function, and by\n+    // unwinding it we go back to the original function.\n+    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+        ip\n+    } else {\n+        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+    };\n \n-        // keep going\n-        uw::_URC_NO_REASON\n+    if cx.idx < cx.frames.len() {\n+        cx.frames[cx.idx] = Frame {\n+            symbol_addr: symaddr,\n+            exact_position: ip,\n+        };\n+        cx.idx += 1;\n     }\n+\n+    uw::_URC_NO_REASON\n }"}, {"sha": "f0d29dd4178d125acff38545459c05752030a757", "filename": "src/libstd/sys/windows/backtrace/backtrace_gnu.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fbacktrace_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fbacktrace_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fbacktrace_gnu.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "previous_filename": "src/libstd/sys/windows/backtrace_gnu.rs"}, {"sha": "3c3fd8d3e4a9ccca29e159d64fbbbadf3d224509", "filename": "src/libstd/sys/windows/backtrace/mod.rs", "status": "renamed", "additions": 72, "deletions": 79, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -24,37 +24,87 @@\n \n #![allow(deprecated)] // dynamic_lib\n \n-use io::prelude::*;\n-\n use io;\n use libc::c_void;\n use mem;\n use ptr;\n use sys::c;\n use sys::dynamic_lib::DynamicLibrary;\n-use sys::mutex::Mutex;\n+use sys_common::backtrace::Frame;\n \n macro_rules! sym {\n     ($lib:expr, $e:expr, $t:ident) => (\n-        match $lib.symbol($e) {\n-            Ok(f) => $crate::mem::transmute::<usize, $t>(f),\n-            Err(..) => return Ok(())\n-        }\n+        $lib.symbol($e).map(|f| unsafe {\n+            $crate::mem::transmute::<usize, $t>(f)\n+        })\n     )\n }\n \n-#[cfg(target_env = \"msvc\")]\n-#[path = \"printing/msvc.rs\"]\n-mod printing;\n-\n-#[cfg(target_env = \"gnu\")]\n-#[path = \"printing/gnu.rs\"]\n mod printing;\n \n #[cfg(target_env = \"gnu\")]\n #[path = \"backtrace_gnu.rs\"]\n pub mod gnu;\n \n+pub use self::printing::{resolve_symname, foreach_symbol_fileline};\n+\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    let dbghelp = DynamicLibrary::open(\"dbghelp.dll\")?;\n+\n+    // Fetch the symbols necessary from dbghelp.dll\n+    let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn)?;\n+    let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn)?;\n+    let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn)?;\n+\n+    // Allocate necessary structures for doing the stack walk\n+    let process = unsafe { c::GetCurrentProcess() };\n+    let thread = unsafe { c::GetCurrentThread() };\n+    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n+    unsafe { c::RtlCaptureContext(&mut context) };\n+    let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n+    let image = init_frame(&mut frame, &context);\n+\n+    let backtrace_context = BacktraceContext {\n+        handle: process,\n+        SymCleanup: SymCleanup,\n+        dbghelp: dbghelp,\n+    };\n+\n+    // Initialize this process's symbols\n+    let ret = unsafe { SymInitialize(process, ptr::null_mut(), c::TRUE) };\n+    if ret != c::TRUE {\n+        return Ok((0, backtrace_context))\n+    }\n+\n+    // And now that we're done with all the setup, do the stack walking!\n+    // Start from -1 to avoid printing this stack frame, which will\n+    // always be exactly the same.\n+    let mut i = 0;\n+    unsafe {\n+        while i < frames.len() &&\n+              StackWalk64(image, process, thread, &mut frame, &mut context,\n+                          ptr::null_mut(),\n+                          ptr::null_mut(),\n+                          ptr::null_mut(),\n+                          ptr::null_mut()) == c::TRUE\n+        {\n+            let addr = frame.AddrPC.Offset;\n+            if addr == frame.AddrReturn.Offset || addr == 0 ||\n+               frame.AddrReturn.Offset == 0 { break }\n+\n+            frames[i] = Frame {\n+                symbol_addr: (addr - 1) as *const c_void,\n+                exact_position: (addr - 1) as *const c_void,\n+            };\n+            i += 1;\n+        }\n+    }\n+\n+    Ok((i, backtrace_context))\n+}\n+\n type SymInitializeFn =\n     unsafe extern \"system\" fn(c::HANDLE, *mut c_void,\n                               c::BOOL) -> c::BOOL;\n@@ -68,8 +118,8 @@ type StackWalk64Fn =\n                               *mut c_void, *mut c_void) -> c::BOOL;\n \n #[cfg(target_arch = \"x86\")]\n-pub fn init_frame(frame: &mut c::STACKFRAME64,\n-                  ctx: &c::CONTEXT) -> c::DWORD {\n+fn init_frame(frame: &mut c::STACKFRAME64,\n+              ctx: &c::CONTEXT) -> c::DWORD {\n     frame.AddrPC.Offset = ctx.Eip as u64;\n     frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n     frame.AddrStack.Offset = ctx.Esp as u64;\n@@ -80,8 +130,8 @@ pub fn init_frame(frame: &mut c::STACKFRAME64,\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-pub fn init_frame(frame: &mut c::STACKFRAME64,\n-                  ctx: &c::CONTEXT) -> c::DWORD {\n+fn init_frame(frame: &mut c::STACKFRAME64,\n+              ctx: &c::CONTEXT) -> c::DWORD {\n     frame.AddrPC.Offset = ctx.Rip as u64;\n     frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n     frame.AddrStack.Offset = ctx.Rsp as u64;\n@@ -91,73 +141,16 @@ pub fn init_frame(frame: &mut c::STACKFRAME64,\n     c::IMAGE_FILE_MACHINE_AMD64\n }\n \n-struct Cleanup {\n+pub struct BacktraceContext {\n     handle: c::HANDLE,\n     SymCleanup: SymCleanupFn,\n+    // Only used in printing for msvc and not gnu\n+    #[allow(dead_code)]\n+    dbghelp: DynamicLibrary,\n }\n \n-impl Drop for Cleanup {\n+impl Drop for BacktraceContext {\n     fn drop(&mut self) {\n         unsafe { (self.SymCleanup)(self.handle); }\n     }\n }\n-\n-pub fn write(w: &mut Write) -> io::Result<()> {\n-    // According to windows documentation, all dbghelp functions are\n-    // single-threaded.\n-    static LOCK: Mutex = Mutex::new();\n-    unsafe {\n-        LOCK.lock();\n-        let res = _write(w);\n-        LOCK.unlock();\n-        return res\n-    }\n-}\n-\n-unsafe fn _write(w: &mut Write) -> io::Result<()> {\n-    let dbghelp = match DynamicLibrary::open(\"dbghelp.dll\") {\n-        Ok(lib) => lib,\n-        Err(..) => return Ok(()),\n-    };\n-\n-    // Fetch the symbols necessary from dbghelp.dll\n-    let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn);\n-    let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn);\n-    let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n-\n-    // Allocate necessary structures for doing the stack walk\n-    let process = c::GetCurrentProcess();\n-    let thread = c::GetCurrentThread();\n-    let mut context: c::CONTEXT = mem::zeroed();\n-    c::RtlCaptureContext(&mut context);\n-    let mut frame: c::STACKFRAME64 = mem::zeroed();\n-    let image = init_frame(&mut frame, &context);\n-\n-    // Initialize this process's symbols\n-    let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n-    if ret != c::TRUE { return Ok(()) }\n-    let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n-\n-    // And now that we're done with all the setup, do the stack walking!\n-    // Start from -1 to avoid printing this stack frame, which will\n-    // always be exactly the same.\n-    let mut i = -1;\n-    write!(w, \"stack backtrace:\\n\")?;\n-    while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                      ptr::null_mut(),\n-                      ptr::null_mut(),\n-                      ptr::null_mut(),\n-                      ptr::null_mut()) == c::TRUE {\n-        let addr = frame.AddrPC.Offset;\n-        if addr == frame.AddrReturn.Offset || addr == 0 ||\n-           frame.AddrReturn.Offset == 0 { break }\n-\n-        i += 1;\n-\n-        if i >= 0 {\n-            printing::print(w, i, addr - 1, process, &dbghelp)?;\n-        }\n-    }\n-\n-    Ok(())\n-}", "previous_filename": "src/libstd/sys/windows/backtrace.rs"}, {"sha": "3e566f6e2bd5c54b8d62ed7d96b27b902ffe606d", "filename": "src/libstd/sys/windows/backtrace/printing/mod.rs", "status": "renamed", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -8,4 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use sys_common::gnu::libbacktrace::print;\n+#[cfg(target_env = \"msvc\")]\n+#[path = \"msvc.rs\"]\n+mod printing;\n+\n+#[cfg(target_env = \"gnu\")]\n+mod printing {\n+    pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n+}\n+\n+pub use self::printing::{foreach_symbol_fileline, resolve_symname};", "previous_filename": "src/libstd/sys/unix/backtrace/printing/gnu.rs"}, {"sha": "3107d78432413ff04b2fbef9dfed39c0a010bceb", "filename": "src/libstd/sys/windows/backtrace/printing/msvc.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::CStr;\n+use io;\n+use libc::{c_ulong, c_int, c_char};\n+use mem;\n+use sys::c;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n+\n+type SymFromAddrFn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u64,\n+                              *mut c::SYMBOL_INFO) -> c::BOOL;\n+type SymGetLineFromAddr64Fn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u32,\n+                              *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n+\n+/// Converts a pointer to symbol to its string value.\n+pub fn resolve_symname<F>(frame: Frame,\n+                          callback: F,\n+                          context: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    let SymFromAddr = sym!(&context.dbghelp, \"SymFromAddr\", SymFromAddrFn)?;\n+\n+    unsafe {\n+        let mut info: c::SYMBOL_INFO = mem::zeroed();\n+        info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n+        // the struct size in C.  the value is different to\n+        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+        // due to struct alignment.\n+        info.SizeOfStruct = 88;\n+\n+        let mut displacement = 0u64;\n+        let ret = SymFromAddr(context.handle,\n+                              frame.symbol_addr as u64,\n+                              &mut displacement,\n+                              &mut info);\n+\n+        let symname = if ret == c::TRUE {\n+            let ptr = info.Name.as_ptr() as *const c_char;\n+            CStr::from_ptr(ptr).to_str().ok()\n+        } else {\n+            None\n+        };\n+        callback(symname)\n+    }\n+}\n+\n+pub fn foreach_symbol_fileline<F>(frame: Frame,\n+                                  mut f: F,\n+                                  context: &BacktraceContext)\n+    -> io::Result<bool>\n+    where F: FnMut(&[u8], c_int) -> io::Result<()>\n+{\n+    let SymGetLineFromAddr64 = sym!(&context.dbghelp,\n+                                    \"SymGetLineFromAddr64\",\n+                                    SymGetLineFromAddr64Fn)?;\n+\n+    unsafe {\n+        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n+        line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n+\n+        let mut displacement = 0u32;\n+        let ret = SymGetLineFromAddr64(context.handle,\n+                                       frame.exact_position as u64,\n+                                       &mut displacement,\n+                                       &mut line);\n+        if ret == c::TRUE {\n+            let name = CStr::from_ptr(line.Filename).to_bytes();\n+            f(name, line.LineNumber as c_int)?;\n+        }\n+        Ok(false)\n+    }\n+}"}, {"sha": "be2d5273c07283832abfbee5424f09482210cd70", "filename": "src/libstd/sys/windows/printing/gnu.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0044bd3896456afb346d06e91a97ac515930ccf/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0044bd3896456afb346d06e91a97ac515930ccf/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs?ref=e0044bd3896456afb346d06e91a97ac515930ccf", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use io::prelude::*;\n-use io;\n-use libc::c_void;\n-use sys::c;\n-use sys::dynamic_lib::DynamicLibrary;\n-use sys_common::gnu::libbacktrace;\n-\n-pub fn print(w: &mut Write,\n-             i: isize,\n-             addr: u64,\n-             _process: c::HANDLE,\n-             _dbghelp: &DynamicLibrary)\n-              -> io::Result<()> {\n-    let addr = addr as usize as *mut c_void;\n-    libbacktrace::print(w, i, addr, addr)\n-}"}, {"sha": "9c29ac4082a6b2e3f0b40fdb3fcfcfcb8dffec9e", "filename": "src/libstd/sys/windows/printing/msvc.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e0044bd3896456afb346d06e91a97ac515930ccf/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0044bd3896456afb346d06e91a97ac515930ccf/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs?ref=e0044bd3896456afb346d06e91a97ac515930ccf", "patch": "@@ -1,73 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ffi::CStr;\n-use io::prelude::*;\n-use io;\n-use libc::{c_ulong, c_int, c_char, c_void};\n-use mem;\n-use sys::c;\n-use sys::dynamic_lib::DynamicLibrary;\n-use sys_common::backtrace::{output, output_fileline};\n-\n-type SymFromAddrFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u64,\n-                              *mut c::SYMBOL_INFO) -> c::BOOL;\n-type SymGetLineFromAddr64Fn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u32,\n-                              *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n-\n-pub fn print(w: &mut Write,\n-             i: isize,\n-             addr: u64,\n-             process: c::HANDLE,\n-             dbghelp: &DynamicLibrary)\n-              -> io::Result<()> {\n-    unsafe {\n-        let SymFromAddr = sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn);\n-        let SymGetLineFromAddr64 = sym!(dbghelp,\n-                                        \"SymGetLineFromAddr64\",\n-                                        SymGetLineFromAddr64Fn);\n-\n-        let mut info: c::SYMBOL_INFO = mem::zeroed();\n-        info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n-        // the struct size in C.  the value is different to\n-        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-        // due to struct alignment.\n-        info.SizeOfStruct = 88;\n-\n-        let mut displacement = 0u64;\n-        let ret = SymFromAddr(process, addr, &mut displacement, &mut info);\n-\n-        let name = if ret == c::TRUE {\n-            let ptr = info.Name.as_ptr() as *const c_char;\n-            Some(CStr::from_ptr(ptr).to_bytes())\n-        } else {\n-            None\n-        };\n-\n-        output(w, i, addr as usize as *mut c_void, name)?;\n-\n-        // Now find out the filename and line number\n-        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n-        line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n-\n-        let mut displacement = 0u32;\n-        let ret = SymGetLineFromAddr64(process, addr, &mut displacement, &mut line);\n-        if ret == c::TRUE {\n-            output_fileline(w,\n-                            CStr::from_ptr(line.Filename).to_bytes(),\n-                            line.LineNumber as c_int,\n-                            false)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}"}, {"sha": "a19f7954e8f9dca643ff831e147c8ff026ed4add", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 227, "deletions": 26, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -10,60 +10,243 @@\n \n #![cfg_attr(target_os = \"nacl\", allow(dead_code))]\n \n+/// Common code for printing the backtrace in the same way across the different\n+/// supported platforms.\n+\n use env;\n use io::prelude::*;\n use io;\n use libc;\n use str;\n use sync::atomic::{self, Ordering};\n+use path::Path;\n+use sys::mutex::Mutex;\n+use ptr;\n \n-pub use sys::backtrace::write;\n+pub use sys::backtrace::{\n+    unwind_backtrace,\n+    resolve_symname,\n+    foreach_symbol_fileline,\n+    BacktraceContext\n+};\n \n #[cfg(target_pointer_width = \"64\")]\n pub const HEX_WIDTH: usize = 18;\n \n #[cfg(target_pointer_width = \"32\")]\n pub const HEX_WIDTH: usize = 10;\n \n+/// Represents an item in the backtrace list. See `unwind_backtrace` for how\n+/// it is created.\n+#[derive(Debug, Copy, Clone)]\n+pub struct Frame {\n+    /// Exact address of the call that failed.\n+    pub exact_position: *const libc::c_void,\n+    /// Address of the enclosing function.\n+    pub symbol_addr: *const libc::c_void,\n+}\n+\n+/// Max number of frames to print.\n+const MAX_NB_FRAMES: usize = 100;\n+\n+/// Prints the current backtrace.\n+pub fn print(w: &mut Write, format: PrintFormat) -> io::Result<()> {\n+    static LOCK: Mutex = Mutex::new();\n+\n+    // Use a lock to prevent mixed output in multithreading context.\n+    // Some platforms also requires it, like `SymFromAddr` on Windows.\n+    unsafe {\n+        LOCK.lock();\n+        let res = _print(w, format);\n+        LOCK.unlock();\n+        res\n+    }\n+}\n+\n+fn _print(w: &mut Write, format: PrintFormat) -> io::Result<()> {\n+    let mut frames = [Frame {\n+        exact_position: ptr::null(),\n+        symbol_addr: ptr::null(),\n+    }; MAX_NB_FRAMES];\n+    let (nb_frames, context) = unwind_backtrace(&mut frames)?;\n+    let (skipped_before, skipped_after) =\n+        filter_frames(&frames[..nb_frames], format, &context);\n+    if format == PrintFormat::Short {\n+        writeln!(w, \"note: Some details are omitted, \\\n+                     run with `RUST_BACKTRACE=full` for a verbose backtrace.\")?;\n+    }\n+    writeln!(w, \"stack backtrace:\")?;\n+\n+    let filtered_frames = &frames[..nb_frames - skipped_after];\n+    for (index, frame) in filtered_frames.iter().skip(skipped_before).enumerate() {\n+        resolve_symname(*frame, |symname| {\n+            output(w, index, *frame, symname, format)\n+        }, &context)?;\n+        let has_more_filenames = foreach_symbol_fileline(*frame, |file, line| {\n+            output_fileline(w, file, line, format)\n+        }, &context)?;\n+        if has_more_filenames {\n+            w.write_all(b\" <... and possibly more>\")?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn filter_frames(frames: &[Frame],\n+                 format: PrintFormat,\n+                 context: &BacktraceContext) -> (usize, usize)\n+{\n+    if format == PrintFormat::Full {\n+        return (0, 0);\n+    }\n+\n+    let mut skipped_before = 0;\n+    for (i, frame) in frames.iter().enumerate() {\n+        skipped_before = i;\n+        let mut skip = false;\n+\n+        let _ = resolve_symname(*frame, |symname| {\n+            if let Some(mangled_symbol_name) = symname {\n+                let magics_begin = [\n+                    \"_ZN3std3sys3imp9backtrace\",\n+                    \"_ZN3std10sys_common9backtrace\",\n+                    \"_ZN3std9panicking\",\n+                    \"_ZN4core9panicking\",\n+                    \"rust_begin_unwind\",\n+                    \"_ZN4core6result13unwrap_failed\",\n+                ];\n+                if !magics_begin.iter().any(|s| mangled_symbol_name.starts_with(s)) {\n+                    skip = true;\n+                }\n+            }\n+            Ok(())\n+        }, context);\n+\n+        if skip {\n+            break;\n+        }\n+    }\n+\n+    let mut skipped_after = 0;\n+    for (i, frame) in frames.iter().rev().enumerate() {\n+        let _ = resolve_symname(*frame, |symname| {\n+            if let Some(mangled_symbol_name) = symname {\n+                let magics_end = [\n+                    \"_ZN3std9panicking3try7do_call\",\n+                    \"__rust_maybe_catch_panic\",\n+                    \"__libc_start_main\",\n+                    \"__rust_try\",\n+                    \"_start\",\n+                ];\n+                if magics_end.iter().any(|s| mangled_symbol_name.starts_with(s)) {\n+                    skipped_after = i + 1;\n+                }\n+            }\n+            Ok(())\n+        }, context);\n+    }\n+\n+    (skipped_before, skipped_after)\n+}\n+\n+/// Controls how the backtrace should be formated.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub enum PrintFormat {\n+    /// Show all the frames with absolute path for files.\n+    Full = 2,\n+    /// Show only relevant data from the backtrace.\n+    Short = 3,\n+}\n+\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n-pub fn log_enabled() -> bool {\n+pub fn log_enabled() -> Option<PrintFormat> {\n     static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n     match ENABLED.load(Ordering::SeqCst) {\n-        1 => return false,\n-        2 => return true,\n-        _ => {}\n+        0 => {},\n+        1 => return None,\n+        2 => return Some(PrintFormat::Full),\n+        3 => return Some(PrintFormat::Short),\n+        _ => unreachable!(),\n     }\n \n     let val = match env::var_os(\"RUST_BACKTRACE\") {\n-        Some(x) => if &x == \"0\" { 1 } else { 2 },\n-        None => 1,\n+        Some(x) => if &x == \"0\" {\n+            None\n+        } else if &x == \"full\" {\n+            Some(PrintFormat::Full)\n+        } else {\n+            Some(PrintFormat::Short)\n+        },\n+        None => None,\n     };\n-    ENABLED.store(val, Ordering::SeqCst);\n-    val == 2\n+    ENABLED.store(match val {\n+        Some(v) => v as isize,\n+        None => 1,\n+    }, Ordering::SeqCst);\n+    val\n }\n \n-// These output functions should now be used everywhere to ensure consistency.\n-pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-              s: Option<&[u8]>) -> io::Result<()> {\n-    write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH)?;\n-    match s.and_then(|s| str::from_utf8(s).ok()) {\n-        Some(string) => demangle(w, string)?,\n-        None => write!(w, \"<unknown>\")?,\n+/// Print the symbol of the backtrace frame.\n+///\n+/// These output functions should now be used everywhere to ensure consistency.\n+/// You may want to also use `output_fileline`.\n+fn output(w: &mut Write, idx: usize, frame: Frame,\n+              s: Option<&str>, format: PrintFormat) -> io::Result<()> {\n+    // Remove the `17: 0x0 - <unknown>` line.\n+    if format == PrintFormat::Short && frame.exact_position == ptr::null() {\n+        return Ok(());\n+    }\n+    match format {\n+        PrintFormat::Full => write!(w,\n+                                    \"  {:2}: {:2$?} - \",\n+                                    idx,\n+                                    frame.exact_position,\n+                                    HEX_WIDTH)?,\n+        PrintFormat::Short => write!(w, \"  {:2}: \", idx)?,\n     }\n-    w.write_all(&['\\n' as u8])\n+    match s {\n+        Some(string) => demangle(w, string, format)?,\n+        None => w.write_all(b\"<unknown>\")?,\n+    }\n+    w.write_all(b\"\\n\")\n }\n \n+/// Print the filename and line number of the backtrace frame.\n+///\n+/// See also `output`.\n #[allow(dead_code)]\n-pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n-                       more: bool) -> io::Result<()> {\n-    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n+fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n+                       format: PrintFormat) -> io::Result<()> {\n     // prior line: \"  ##: {:2$} - func\"\n-    write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH)?;\n-    if more {\n-        write!(w, \" <... and possibly more>\")?;\n+    w.write_all(b\"\")?;\n+    match format {\n+        PrintFormat::Full => write!(w,\n+                                    \"           {:1$}\",\n+                                    \"\",\n+                                    HEX_WIDTH)?,\n+        PrintFormat::Short => write!(w, \"           \")?,\n     }\n-    w.write_all(&['\\n' as u8])\n+\n+    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n+    let file_path = Path::new(file);\n+    let mut already_printed = false;\n+    if format == PrintFormat::Short && file_path.is_absolute() {\n+        if let Ok(cwd) = env::current_dir() {\n+            if let Ok(stripped) = file_path.strip_prefix(&cwd) {\n+                if let Some(s) = stripped.to_str() {\n+                    write!(w, \"  at ./{}:{}\", s, line)?;\n+                    already_printed = true;\n+                }\n+            }\n+        }\n+    }\n+    if !already_printed {\n+        write!(w, \"  at {}:{}\", file, line)?;\n+    }\n+\n+    w.write_all(b\"\\n\")\n }\n \n \n@@ -84,7 +267,7 @@ pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n // Note that this demangler isn't quite as fancy as it could be. We have lots\n // of other information in our symbols like hashes, version, type information,\n // etc. Additionally, this doesn't handle glue symbols at all.\n-pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n+pub fn demangle(writer: &mut Write, s: &str, format: PrintFormat) -> io::Result<()> {\n     // First validate the symbol. If it doesn't look like anything we're\n     // expecting, we just print it literally. Note that we must handle non-rust\n     // symbols because we could have any function in the backtrace.\n@@ -123,6 +306,22 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n     if !valid {\n         writer.write_all(s.as_bytes())?;\n     } else {\n+        // remove the `::hfc2edb670e5eda97` part at the end of the symbol.\n+        if format == PrintFormat::Short {\n+            // The symbol in still mangled.\n+            let mut split = inner.rsplitn(2, \"17h\");\n+            match (split.next(), split.next()) {\n+                (Some(addr), rest) => {\n+                    if addr.len() == 16 &&\n+                       addr.chars().all(|c| c.is_digit(16))\n+                    {\n+                        inner = rest.unwrap_or(\"\");\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+\n         let mut first = true;\n         while !inner.is_empty() {\n             if !first {\n@@ -208,7 +407,9 @@ mod tests {\n     use sys_common;\n     macro_rules! t { ($a:expr, $b:expr) => ({\n         let mut m = Vec::new();\n-        sys_common::backtrace::demangle(&mut m, $a).unwrap();\n+        sys_common::backtrace::demangle(&mut m,\n+                                        $a,\n+                                        super::PrintFormat::Full).unwrap();\n         assert_eq!(String::from_utf8(m).unwrap(), $b);\n     }) }\n "}, {"sha": "1ea5cca44c7e40154f383bce344187a8b703a94e", "filename": "src/libstd/sys_common/gnu/libbacktrace.rs", "status": "modified", "additions": 181, "deletions": 163, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -8,186 +8,204 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io;\n-use io::prelude::*;\n use libc;\n-use sys_common::backtrace::{output, output_fileline};\n-\n-pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-             symaddr: *mut libc::c_void) -> io::Result<()> {\n-    use ffi::CStr;\n-    use mem;\n-    use ptr;\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // libbacktrace.h API\n-    ////////////////////////////////////////////////////////////////////////\n-    type backtrace_syminfo_callback =\n-        extern \"C\" fn(data: *mut libc::c_void,\n-                      pc: libc::uintptr_t,\n-                      symname: *const libc::c_char,\n-                      symval: libc::uintptr_t,\n-                      symsize: libc::uintptr_t);\n-    type backtrace_full_callback =\n-        extern \"C\" fn(data: *mut libc::c_void,\n-                      pc: libc::uintptr_t,\n-                      filename: *const libc::c_char,\n-                      lineno: libc::c_int,\n-                      function: *const libc::c_char) -> libc::c_int;\n-    type backtrace_error_callback =\n-        extern \"C\" fn(data: *mut libc::c_void,\n-                      msg: *const libc::c_char,\n-                      errnum: libc::c_int);\n-    enum backtrace_state {}\n-\n-    extern {\n-        fn backtrace_create_state(filename: *const libc::c_char,\n-                                  threaded: libc::c_int,\n-                                  error: backtrace_error_callback,\n-                                  data: *mut libc::c_void)\n-                                  -> *mut backtrace_state;\n-        fn backtrace_syminfo(state: *mut backtrace_state,\n-                             addr: libc::uintptr_t,\n-                             cb: backtrace_syminfo_callback,\n-                             error: backtrace_error_callback,\n-                             data: *mut libc::c_void) -> libc::c_int;\n-        fn backtrace_pcinfo(state: *mut backtrace_state,\n-                            addr: libc::uintptr_t,\n-                            cb: backtrace_full_callback,\n-                            error: backtrace_error_callback,\n-                            data: *mut libc::c_void) -> libc::c_int;\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // helper callbacks\n-    ////////////////////////////////////////////////////////////////////////\n-\n-    type FileLine = (*const libc::c_char, libc::c_int);\n-\n-    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n-                       _errnum: libc::c_int) {\n-        // do nothing for now\n-    }\n-    extern fn syminfo_cb(data: *mut libc::c_void,\n-                         _pc: libc::uintptr_t,\n-                         symname: *const libc::c_char,\n-                         _symval: libc::uintptr_t,\n-                         _symsize: libc::uintptr_t) {\n-        let slot = data as *mut *const libc::c_char;\n-        unsafe { *slot = symname; }\n-    }\n-    extern fn pcinfo_cb(data: *mut libc::c_void,\n-                        _pc: libc::uintptr_t,\n-                        filename: *const libc::c_char,\n-                        lineno: libc::c_int,\n-                        _function: *const libc::c_char) -> libc::c_int {\n-        if !filename.is_null() {\n-            let slot = data as *mut &mut [FileLine];\n-            let buffer = unsafe {ptr::read(slot)};\n-\n-            // if the buffer is not full, add file:line to the buffer\n-            // and adjust the buffer for next possible calls to pcinfo_cb.\n-            if !buffer.is_empty() {\n-                buffer[0] = (filename, lineno);\n-                unsafe { ptr::write(slot, &mut buffer[1..]); }\n-            }\n-        }\n-\n-        0\n-    }\n-\n-    // The libbacktrace API supports creating a state, but it does not\n-    // support destroying a state. I personally take this to mean that a\n-    // state is meant to be created and then live forever.\n-    //\n-    // I would love to register an at_exit() handler which cleans up this\n-    // state, but libbacktrace provides no way to do so.\n-    //\n-    // With these constraints, this function has a statically cached state\n-    // that is calculated the first time this is requested. Remember that\n-    // backtracing all happens serially (one global lock).\n-    //\n-    // Things don't work so well on not-Linux since libbacktrace can't track\n-    // down that executable this is. We at one point used env::current_exe but\n-    // it turns out that there are some serious security issues with that\n-    // approach.\n-    //\n-    // Specifically, on certain platforms like BSDs, a malicious actor can cause\n-    // an arbitrary file to be placed at the path returned by current_exe.\n-    // libbacktrace does not behave defensively in the presence of ill-formed\n-    // DWARF information, and has been demonstrated to segfault in at least one\n-    // case. There is no evidence at the moment to suggest that a more carefully\n-    // constructed file can't cause arbitrary code execution. As a result of all\n-    // of this, we don't hint libbacktrace with the path to the current process.\n-    unsafe fn init_state() -> *mut backtrace_state {\n-        static mut STATE: *mut backtrace_state = ptr::null_mut();\n-        if !STATE.is_null() { return STATE }\n-\n-        let filename = match ::sys::backtrace::gnu::get_executable_filename() {\n-            Ok((filename, file)) => {\n-                // filename is purposely leaked here since libbacktrace requires\n-                // it to stay allocated permanently, file is also leaked so that\n-                // the file stays locked\n-                let filename_ptr = filename.as_ptr();\n-                mem::forget(filename);\n-                mem::forget(file);\n-                filename_ptr\n-            },\n-            Err(_) => ptr::null(),\n-        };\n-\n-        STATE = backtrace_create_state(filename, 0, error_cb,\n-                                       ptr::null_mut());\n-        STATE\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // translation\n-    ////////////////////////////////////////////////////////////////////////\n-\n-    // backtrace errors are currently swept under the rug, only I/O\n-    // errors are reported\n-    let state = unsafe { init_state() };\n-    if state.is_null() {\n-        return output(w, idx, addr, None)\n-    }\n-    let mut data = ptr::null();\n-    let data_addr = &mut data as *mut *const libc::c_char;\n-    let ret = unsafe {\n-        backtrace_syminfo(state, symaddr as libc::uintptr_t,\n-                          syminfo_cb, error_cb,\n-                          data_addr as *mut libc::c_void)\n-    };\n-    if ret == 0 || data.is_null() {\n-        output(w, idx, addr, None)?;\n-    } else {\n-        output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() }))?;\n-    }\n \n+use ffi::CStr;\n+use io;\n+use mem;\n+use ptr;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n+\n+pub fn foreach_symbol_fileline<F>(frame: Frame,\n+                                  mut f: F,\n+                                  _: &BacktraceContext) -> io::Result<bool>\n+where F: FnMut(&[u8], libc::c_int) -> io::Result<()>\n+{\n     // pcinfo may return an arbitrary number of file:line pairs,\n     // in the order of stack trace (i.e. inlined calls first).\n     // in order to avoid allocation, we stack-allocate a fixed size of entries.\n     const FILELINE_SIZE: usize = 32;\n     let mut fileline_buf = [(ptr::null(), -1); FILELINE_SIZE];\n     let ret;\n-    let fileline_count;\n-    {\n+    let fileline_count = {\n+        let state = unsafe { init_state() };\n         let mut fileline_win: &mut [FileLine] = &mut fileline_buf;\n         let fileline_addr = &mut fileline_win as *mut &mut [FileLine];\n         ret = unsafe {\n-            backtrace_pcinfo(state, addr as libc::uintptr_t,\n-                             pcinfo_cb, error_cb,\n+            backtrace_pcinfo(state,\n+                             frame.exact_position as libc::uintptr_t,\n+                             pcinfo_cb,\n+                             error_cb,\n                              fileline_addr as *mut libc::c_void)\n         };\n-        fileline_count = FILELINE_SIZE - fileline_win.len();\n-    }\n+        FILELINE_SIZE - fileline_win.len()\n+    };\n     if ret == 0 {\n-        for (i, &(file, line)) in fileline_buf[..fileline_count].iter().enumerate() {\n+        for &(file, line) in &fileline_buf[..fileline_count] {\n             if file.is_null() { continue; } // just to be sure\n             let file = unsafe { CStr::from_ptr(file).to_bytes() };\n-            output_fileline(w, file, line, i == FILELINE_SIZE - 1)?;\n+            f(file, line)?;\n+        }\n+        Ok(fileline_count == FILELINE_SIZE)\n+    } else {\n+        Ok(false)\n+    }\n+}\n+\n+/// Converts a pointer to symbol to its string value.\n+pub fn resolve_symname<F>(frame: Frame,\n+                          callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    let symname = {\n+        let state = unsafe { init_state() };\n+        if state.is_null() {\n+            None\n+        } else {\n+            let mut data = ptr::null();\n+            let data_addr = &mut data as *mut *const libc::c_char;\n+            let ret = unsafe {\n+                backtrace_syminfo(state,\n+                                  frame.symbol_addr as libc::uintptr_t,\n+                                  syminfo_cb,\n+                                  error_cb,\n+                                  data_addr as *mut libc::c_void)\n+            };\n+            if ret == 0 || data.is_null() {\n+                None\n+            } else {\n+                unsafe {\n+                    CStr::from_ptr(data).to_str().ok()\n+                }\n+            }\n+        }\n+    };\n+    callback(symname)\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// libbacktrace.h API\n+////////////////////////////////////////////////////////////////////////\n+type backtrace_syminfo_callback =\n+extern \"C\" fn(data: *mut libc::c_void,\n+              pc: libc::uintptr_t,\n+              symname: *const libc::c_char,\n+              symval: libc::uintptr_t,\n+              symsize: libc::uintptr_t);\n+type backtrace_full_callback =\n+extern \"C\" fn(data: *mut libc::c_void,\n+              pc: libc::uintptr_t,\n+              filename: *const libc::c_char,\n+              lineno: libc::c_int,\n+              function: *const libc::c_char) -> libc::c_int;\n+type backtrace_error_callback =\n+extern \"C\" fn(data: *mut libc::c_void,\n+              msg: *const libc::c_char,\n+              errnum: libc::c_int);\n+enum backtrace_state {}\n+#[link(name = \"backtrace\", kind = \"static\")]\n+#[cfg(all(not(test), not(cargobuild)))]\n+extern {}\n+\n+extern {\n+    fn backtrace_create_state(filename: *const libc::c_char,\n+                              threaded: libc::c_int,\n+                              error: backtrace_error_callback,\n+                              data: *mut libc::c_void)\n+        -> *mut backtrace_state;\n+    fn backtrace_syminfo(state: *mut backtrace_state,\n+                         addr: libc::uintptr_t,\n+                         cb: backtrace_syminfo_callback,\n+                         error: backtrace_error_callback,\n+                         data: *mut libc::c_void) -> libc::c_int;\n+    fn backtrace_pcinfo(state: *mut backtrace_state,\n+                        addr: libc::uintptr_t,\n+                        cb: backtrace_full_callback,\n+                        error: backtrace_error_callback,\n+                        data: *mut libc::c_void) -> libc::c_int;\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// helper callbacks\n+////////////////////////////////////////////////////////////////////////\n+\n+type FileLine = (*const libc::c_char, libc::c_int);\n+\n+extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n+                   _errnum: libc::c_int) {\n+    // do nothing for now\n+}\n+extern fn syminfo_cb(data: *mut libc::c_void,\n+                     _pc: libc::uintptr_t,\n+                     symname: *const libc::c_char,\n+                     _symval: libc::uintptr_t,\n+                     _symsize: libc::uintptr_t) {\n+    let slot = data as *mut *const libc::c_char;\n+    unsafe { *slot = symname; }\n+}\n+extern fn pcinfo_cb(data: *mut libc::c_void,\n+                    _pc: libc::uintptr_t,\n+                    filename: *const libc::c_char,\n+                    lineno: libc::c_int,\n+                    _function: *const libc::c_char) -> libc::c_int {\n+    if !filename.is_null() {\n+        let slot = data as *mut &mut [FileLine];\n+        let buffer = unsafe {ptr::read(slot)};\n+\n+        // if the buffer is not full, add file:line to the buffer\n+        // and adjust the buffer for next possible calls to pcinfo_cb.\n+        if !buffer.is_empty() {\n+            buffer[0] = (filename, lineno);\n+            unsafe { ptr::write(slot, &mut buffer[1..]); }\n         }\n     }\n \n-    Ok(())\n+    0\n+}\n+\n+// The libbacktrace API supports creating a state, but it does not\n+// support destroying a state. I personally take this to mean that a\n+// state is meant to be created and then live forever.\n+//\n+// I would love to register an at_exit() handler which cleans up this\n+// state, but libbacktrace provides no way to do so.\n+//\n+// With these constraints, this function has a statically cached state\n+// that is calculated the first time this is requested. Remember that\n+// backtracing all happens serially (one global lock).\n+//\n+// Things don't work so well on not-Linux since libbacktrace can't track\n+// down that executable this is. We at one point used env::current_exe but\n+// it turns out that there are some serious security issues with that\n+// approach.\n+//\n+// Specifically, on certain platforms like BSDs, a malicious actor can cause\n+// an arbitrary file to be placed at the path returned by current_exe.\n+// libbacktrace does not behave defensively in the presence of ill-formed\n+// DWARF information, and has been demonstrated to segfault in at least one\n+// case. There is no evidence at the moment to suggest that a more carefully\n+// constructed file can't cause arbitrary code execution. As a result of all\n+// of this, we don't hint libbacktrace with the path to the current process.\n+unsafe fn init_state() -> *mut backtrace_state {\n+    static mut STATE: *mut backtrace_state = ptr::null_mut();\n+    if !STATE.is_null() { return STATE  }\n+\n+    let filename = match ::sys::backtrace::gnu::get_executable_filename() {\n+        Ok((filename, file)) => {\n+            // filename is purposely leaked here since libbacktrace requires\n+            // it to stay allocated permanently, file is also leaked so that\n+            // the file stays locked\n+            let filename_ptr = filename.as_ptr();\n+            mem::forget(filename);\n+            mem::forget(file);\n+            filename_ptr\n+        },\n+        Err(_) => ptr::null(),\n+    };\n+\n+    STATE = backtrace_create_state(filename, 0, error_cb,\n+                                   ptr::null_mut());\n+    STATE\n }"}, {"sha": "e22f6702672986091766db4b5f7aadd6ddce784e", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -18,7 +18,7 @@ macro_rules! cfg_if {\n use libc::{c_int, c_void, uintptr_t};\n \n #[repr(C)]\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Debug, Copy, Clone, PartialEq)]\n pub enum _Unwind_Reason_Code {\n     _URC_NO_REASON = 0,\n     _URC_FOREIGN_EXCEPTION_CAUGHT = 1,"}, {"sha": "88fee9ed25b8d5aa93cc54e2583e4a7a5a209b7b", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -141,12 +141,12 @@ fn run_test(me: &str) {\n     use std::process::Command;\n \n     let mut template = Command::new(me);\n-    template.env(\"RUST_BACKTRACE\", \"1\");\n+    template.env(\"RUST_BACKTRACE\", \"full\");\n \n     let mut i = 0;\n     loop {\n         let out = Command::new(me)\n-                          .env(\"RUST_BACKTRACE\", \"1\")\n+                          .env(\"RUST_BACKTRACE\", \"full\")\n                           .arg(i.to_string()).output().unwrap();\n         let output = str::from_utf8(&out.stdout).unwrap();\n         let error = str::from_utf8(&out.stderr).unwrap();"}, {"sha": "dcdf82682f3a5c9604e5c8e668d8071e99b28e6f", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=d50e4cc0640e54a64d0f7ccb05a77fd4a2fe0741", "patch": "@@ -47,7 +47,7 @@ fn template(me: &str) -> Command {\n }\n \n fn expected(fn_name: &str) -> String {\n-    format!(\" - backtrace::{}\", fn_name)\n+    format!(\" backtrace::{}\", fn_name)\n }\n \n fn runtest(me: &str) {\n@@ -59,6 +59,53 @@ fn runtest(me: &str) {\n     assert!(s.contains(\"stack backtrace\") && s.contains(&expected(\"foo\")),\n             \"bad output: {}\", s);\n \n+    // Make sure than the short version cleans the backtrace.\n+    let p = template(me).arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n+    let out = p.wait_with_output().unwrap();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(&out.stderr).unwrap();\n+    let removed_symbols = &[\n+        \"std::sys::imp::backtrace\",\n+        \"std::sys_common::backtrace\",\n+        \"std::panicking\",\n+        \"core::panicking\",\n+        \"rust_begin_unwind\",\n+        \"code::result::unwrap_failed\",\n+        \"std::panicking::try::do_call\",\n+        \"__rust_maybe_catch_panic\",\n+        \"__libc_start_main\",\n+        \"__rust_try\",\n+        \"_start\",\n+    ];\n+    for symbol in removed_symbols {\n+        assert!(!s.contains(symbol),\n+                \"{} should be removed from the backtrace\",\n+                symbol);\n+    }\n+    assert!(s.contains(\" 0:\"), \"the frame number should start at 0\");\n+\n+    // Only on linux for _start and __libc_start_main\n+    #[cfg(target_os=\"linux\")]\n+    {\n+        // Make sure than the short version cleans the backtrace.\n+        let p = template(me).arg(\"fail\").env(\"RUST_BACKTRACE\", \"full\").spawn().unwrap();\n+        let out = p.wait_with_output().unwrap();\n+        assert!(!out.status.success());\n+        let s = str::from_utf8(&out.stderr).unwrap();\n+        let should_be_present = &[\n+            \"std::panicking\",\n+            \"__rust_maybe_catch_panic\",\n+            \"__libc_start_main\",\n+            \"_start\",\n+        ];\n+        for symbol in should_be_present {\n+            // May give false positive due to inlining.\n+            assert!(s.contains(symbol),\n+            \"the full version of the backtrace should contain {}\",\n+            symbol);\n+        }\n+    }\n+\n     // Make sure the stack trace is *not* printed\n     // (Remove RUST_BACKTRACE from our own environment, in case developer\n     // is running `make check` with it on.)"}]}