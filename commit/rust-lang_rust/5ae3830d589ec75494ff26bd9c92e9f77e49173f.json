{"sha": "5ae3830d589ec75494ff26bd9c92e9f77e49173f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZTM4MzBkNTg5ZWM3NTQ5NGZmMjZiZDljOTJlOWY3N2U0OTE3M2Y=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-14T20:16:51Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-15T08:15:38Z"}, "message": "Give more `Idents` spans", "tree": {"sha": "f19445d87a85d724de3ca80d825e68c5c13456fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f19445d87a85d724de3ca80d825e68c5c13456fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ae3830d589ec75494ff26bd9c92e9f77e49173f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae3830d589ec75494ff26bd9c92e9f77e49173f", "html_url": "https://github.com/rust-lang/rust/commit/5ae3830d589ec75494ff26bd9c92e9f77e49173f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ae3830d589ec75494ff26bd9c92e9f77e49173f/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57a45e9cbd951efd8224c3535431890b7bef9e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/57a45e9cbd951efd8224c3535431890b7bef9e6a", "html_url": "https://github.com/rust-lang/rust/commit/57a45e9cbd951efd8224c3535431890b7bef9e6a"}], "stats": {"total": 140, "additions": 72, "deletions": 68}, "files": [{"sha": "58789a10609b7e84f1ef98407d3ee85a521def6c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -1316,7 +1316,7 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Universal(in_band_ty_params),\n                         );\n                         // Set the name to `impl Bound1 + Bound2`.\n-                        let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n+                        let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),"}, {"sha": "d3f6717ee875d1d67193103aac340b5ba819d8dd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -1081,8 +1081,8 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.ecfg.trace_mac = x\n     }\n-    pub fn ident_of(&self, st: &str) -> ast::Ident {\n-        ast::Ident::from_str(st)\n+    pub fn ident_of(&self, st: &str, sp: Span) -> ast::Ident {\n+        ast::Ident::from_str_and_span(st, sp)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n         let def_site = self.with_def_site_ctxt(DUMMY_SP);"}, {"sha": "f1d0e0b68f7359bd9b1a240180bf5af4746611cd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -525,7 +525,7 @@ impl<'a> ExtCtxt<'a> {\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let err_path = self.path_global(sp, err);\n \n-        let binding_variable = self.ident_of(\"__try_var\");\n+        let binding_variable = self.ident_of(\"__try_var\", sp);\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n "}, {"sha": "cf196645e4f7bac410c170a11d18be8a245f921c", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -1256,7 +1256,7 @@ impl<'a> Parser<'a> {\n             for part in idents {\n                 fixed_name.push_str(&format!(\"_{}\", part.name));\n             }\n-            ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n+            ident = Ident::from_str_and_span(&fixed_name, fixed_name_sp);\n \n             self.struct_span_err(fixed_name_sp, error_msg)\n                 .span_label(fixed_name_sp, \"dash-separated idents are not valid\")"}, {"sha": "13d63aaf2a80c987d50cd7397af34e18dfb2bb18", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -109,7 +109,7 @@ pub fn some_ordering_collapsed(\n         GtOp => \"gt\",\n         GeOp => \"ge\",\n     };\n-    cx.expr_method_call(span, lft, ast::Ident::from_str_and_span(op_str, span), vec![rgt])\n+    cx.expr_method_call(span, lft, cx.ident_of(op_str, span), vec![rgt])\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {"}, {"sha": "088b61be8b81b3b24a81ad58daea6dd53bfbc4fe", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = Ident::from_str_and_span(\"debug_trait_builder\", span);\n+    let builder = cx.ident_of(\"debug_trait_builder\", span);\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -72,7 +72,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant\n             let expr =\n-                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n+                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_tuple\", span), vec![name]);\n             stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n@@ -93,7 +93,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Struct(..) => {\n             // normal struct/struct variant\n             let expr =\n-                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n+                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_struct\", span), vec![name]);\n             stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n             for field in fields {\n@@ -113,7 +113,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         }\n     }\n \n-    let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, cx.ident_of(\"finish\", span), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "cde72abbdef6a7060c11e9f008452b2a81fb7710", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -66,10 +66,14 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                           krate: &str)\n                           -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n-    let recurse = vec![cx.ident_of(krate), cx.ident_of(\"Decodable\"), cx.ident_of(\"decode\")];\n+    let recurse = vec![\n+        cx.ident_of(krate, trait_span),\n+        cx.ident_of(\"Decodable\", trait_span),\n+        cx.ident_of(\"decode\", trait_span),\n+    ];\n     let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_d\");\n+    let blkarg = cx.ident_of(\"_d\", trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n     return match *substr.fields {\n@@ -78,7 +82,7 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                 Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n-            let read_struct_field = cx.ident_of(\"read_struct_field\");\n+            let read_struct_field = cx.ident_of(\"read_struct_field\", trait_span);\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n             let result =\n@@ -94,17 +98,17 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n             let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n-                                cx.ident_of(\"read_struct\"),\n+                                cx.ident_of(\"read_struct\", trait_span),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, nfields),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n-            let variant = cx.ident_of(\"i\");\n+            let variant = cx.ident_of(\"i\", trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n             let mut variants = Vec::with_capacity(fields.len());\n-            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n+            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\", trait_span);\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n                 variants.push(cx.expr_str(v_span, ident.name));\n@@ -132,11 +136,11 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n             let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n             let result = cx.expr_method_call(trait_span,\n                                              blkdecoder,\n-                                             cx.ident_of(\"read_enum_variant\"),\n+                                             cx.ident_of(\"read_enum_variant\", trait_span),\n                                              vec![variant_vec, lambda]);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n-                                cx.ident_of(\"read_enum\"),\n+                                cx.ident_of(\"read_enum\", trait_span),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }"}, {"sha": "655d3bb7c4ab8e3866b694aa7f9153d4e43cc941", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -153,16 +153,16 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n                           -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_e\");\n+    let blkarg = cx.ident_of(\"_e\", trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let fn_path = cx.expr_path(cx.path_global(trait_span,\n-                                              vec![cx.ident_of(krate),\n-                                                   cx.ident_of(\"Encodable\"),\n-                                                   cx.ident_of(\"encode\")]));\n+                                              vec![cx.ident_of(krate, trait_span),\n+                                                   cx.ident_of(\"Encodable\", trait_span),\n+                                                   cx.ident_of(\"encode\", trait_span)]));\n \n     return match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n+            let emit_struct_field = cx.ident_of(\"emit_struct_field\", trait_span);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -201,7 +201,7 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n \n             cx.expr_method_call(trait_span,\n                                 encoder,\n-                                cx.ident_of(\"emit_struct\"),\n+                                cx.ident_of(\"emit_struct\", trait_span),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, fields.len()),\n                                      blk])\n@@ -214,7 +214,7 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n+            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\", trait_span);\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -244,15 +244,15 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n             let name = cx.expr_str(trait_span, variant.ident.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n-                                           cx.ident_of(\"emit_enum_variant\"),\n+                                           cx.ident_of(\"emit_enum_variant\", trait_span),\n                                            vec![name,\n                                                 cx.expr_usize(trait_span, idx),\n                                                 cx.expr_usize(trait_span, fields.len()),\n                                                 blk]);\n             let blk = cx.lambda1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n-                                          cx.ident_of(\"emit_enum\"),\n+                                          cx.ident_of(\"emit_enum\", trait_span),\n                                           vec![cx.expr_str(trait_span ,substr.type_ident.name),\n                                                blk]);\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))"}, {"sha": "aceee62e89b0c02e9e8913bd24d4f9638e2af5f0", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -843,7 +843,7 @@ impl<'a> MethodDef<'a> {\n                                 -> P<Expr> {\n         let substructure = Substructure {\n             type_ident,\n-            method_ident: cx.ident_of(self.name),\n+            method_ident: cx.ident_of(self.name, trait_.span),\n             self_args,\n             nonself_args,\n             fields,\n@@ -890,7 +890,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = ast::Ident::from_str_and_span(name, trait_.span);\n+            let ident = cx.ident_of(name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -938,7 +938,7 @@ impl<'a> MethodDef<'a> {\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = cx.ident_of(self.name);\n+        let method_ident = cx.ident_of(self.name, trait_.span);\n         let fn_decl = cx.fn_decl(args, ast::FunctionRetTy::Ty(ret_type));\n         let body_block = cx.block_expr(body);\n \n@@ -1201,7 +1201,7 @@ impl<'a> MethodDef<'a> {\n             ).collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name| cx.ident_of(&name[..]))\n+            .map(|name| cx.ident_of(name, sp))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n@@ -1210,7 +1210,7 @@ impl<'a> MethodDef<'a> {\n         let vi_idents = self_arg_names.iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                ast::Ident::from_str_and_span(&vi_suffix[..], trait_.span)\n+                cx.ident_of(&vi_suffix[..], trait_.span)\n             })\n             .collect::<Vec<ast::Ident>>();\n \n@@ -1389,7 +1389,7 @@ impl<'a> MethodDef<'a> {\n \n                 let target_ty = cx.ty_ident(\n                     sp,\n-                    ast::Ident::from_str_and_span(target_type_name, sp),\n+                    cx.ident_of(target_type_name, sp),\n                 );\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n@@ -1591,7 +1591,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = ast::Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n+            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {"}, {"sha": "b341a076752069476ad3116834881eab4d1b5a54", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -72,7 +72,7 @@ impl<'a> Path<'a> {\n                    self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| Ident::from_str_and_span(*s, span)).collect();\n+        let mut idents = self.path.iter().map(|s| cx.ident_of(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -207,7 +207,7 @@ fn mk_ty_param(cx: &ExtCtxt<'_>,\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, ast::Ident::from_str_and_span(name, span), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, cx.ident_of(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {"}, {"sha": "3b0ddeeea2d95db0f905af515de52dd8aa84e421", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -23,13 +23,13 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     let sp = cx.with_legacy_ctxt(sp);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n-            let lt = cx.lifetime(sp, Ident::with_dummy_span(kw::StaticLifetime));\n+            let lt = cx.lifetime(sp, Ident::new(kw::StaticLifetime, sp));\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[sym::option, sym::Option, sym::None]),\n                                      vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp,\n-                                                                 Ident::with_dummy_span(sym::str)),\n+                                                                 Ident::new(sym::str, sp)),\n                                                      Some(lt),\n                                                      ast::Mutability::Immutable))],\n                                      vec![]))"}, {"sha": "46c7cbb83de9066b0f974ff885a69377c5865894", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n-            path.push(self.ecx.ident_of(c));\n+            path.push(self.ecx.ident_of(c, sp));\n             match arg {\n                 Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n                 None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n@@ -534,7 +534,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = {\n                     let pos = |c, arg| {\n                         let mut path = Context::rtpath(self.ecx, \"Position\");\n-                        path.push(self.ecx.ident_of(c));\n+                        path.push(self.ecx.ident_of(c, sp));\n                         match arg {\n                             Some(i) => {\n                                 let arg = self.ecx.expr_usize(sp, i);\n@@ -603,7 +603,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n                     let mut p = Context::rtpath(self.ecx, \"Alignment\");\n-                    p.push(self.ecx.ident_of(name));\n+                    p.push(self.ecx.ident_of(name, sp));\n                     self.ecx.path_global(sp, p)\n                 };\n                 let align = match arg.format.align {\n@@ -621,11 +621,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\", sp), fill),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\", sp), align),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\", sp), flags),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\", sp), prec),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\", sp), width),\n                     ],\n                 );\n \n@@ -634,8 +634,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                     sp,\n                                           path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\", sp), pos),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\", sp), fmt),\n                     ],\n                 ))\n             }\n@@ -653,7 +653,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| ast::Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n+            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled"}, {"sha": "c57e5eec0b6b8caf98985e9aea28124ca54fdde9", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -43,7 +43,7 @@ pub fn expand(\n     let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item =\n-        ecx.item_const(span, Ident::with_dummy_span(kw::Underscore), const_ty, const_body);\n+        ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n \n     // Return the original item and the new methods.\n     vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n@@ -61,7 +61,7 @@ impl AllocFnFactory<'_, '_> {\n         let mut abi_args = Vec::new();\n         let mut i = 0;\n         let ref mut mk = || {\n-            let name = Ident::from_str(&format!(\"arg{}\", i));\n+            let name = self.cx.ident_of(&format!(\"arg{}\", i), self.span);\n             i += 1;\n             name\n         };\n@@ -83,7 +83,7 @@ impl AllocFnFactory<'_, '_> {\n         );\n         let item = self.cx.item(\n             self.span,\n-            Ident::from_str(&self.kind.fn_name(method.name)),\n+            self.cx.ident_of(&self.kind.fn_name(method.name), self.span),\n             self.attrs(),\n             kind,\n         );\n@@ -119,7 +119,7 @@ impl AllocFnFactory<'_, '_> {\n     ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n+                let usize = self.cx.path_ident(self.span, Ident::new(sym::usize, self.span));\n                 let ty_usize = self.cx.ty_path(usize);\n                 let size = ident();\n                 let align = ident();\n@@ -177,12 +177,12 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n+        let usize = self.cx.path_ident(self.span, Ident::new(sym::usize, self.span));\n         self.cx.ty_path(usize)\n     }\n \n     fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::u8));\n+        let u8 = self.cx.path_ident(self.span, Ident::new(sym::u8, self.span));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }"}, {"sha": "a5dcfb9840aca5c4d9f4536c151843000117b5ec", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -340,12 +340,12 @@ fn mk_decls(\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let bridge = Ident::from_str_and_span(\"bridge\", span);\n-    let client = Ident::from_str_and_span(\"client\", span);\n-    let proc_macro_ty = Ident::from_str_and_span(\"ProcMacro\", span);\n-    let custom_derive = Ident::from_str_and_span(\"custom_derive\", span);\n-    let attr = Ident::from_str_and_span(\"attr\", span);\n-    let bang = Ident::from_str_and_span(\"bang\", span);\n+    let bridge = cx.ident_of(\"bridge\", span);\n+    let client = cx.ident_of(\"client\", span);\n+    let proc_macro_ty = cx.ident_of(\"ProcMacro\", span);\n+    let custom_derive = cx.ident_of(\"custom_derive\", span);\n+    let attr = cx.ident_of(\"attr\", span);\n+    let bang = cx.ident_of(\"bang\", span);\n \n     let decls = {\n         let local_path = |sp: Span, name| {\n@@ -378,7 +378,7 @@ fn mk_decls(\n \n     let decls_static = cx.item_static(\n         span,\n-        Ident::from_str_and_span(\"_DECLS\", span),\n+        cx.ident_of(\"_DECLS\", span),\n         cx.ty_rptr(span,\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,"}, {"sha": "0910c00a8a2a97ba6e55c85fe250cc9f71b50d78", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -98,20 +98,20 @@ pub fn expand_test_or_bench(\n \n     // creates test::$name\n     let test_path = |name| {\n-        cx.path(sp, vec![test_id, cx.ident_of(name)])\n+        cx.path(sp, vec![test_id, cx.ident_of(name, sp)])\n     };\n \n     // creates test::ShouldPanic::$name\n     let should_panic_path = |name| {\n-        cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\"), cx.ident_of(name)])\n+        cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\", sp), cx.ident_of(name, sp)])\n     };\n \n     // creates $name: $expr\n-    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name), expr);\n+    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name, sp), expr);\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = ast::Ident::from_str_and_span(\"b\", attr_sp);\n+        let b = cx.ident_of(\"b\", attr_sp);\n \n         cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n             // |b| self::test::assert_test_result("}, {"sha": "56de0c97f81c0b70c47ee1347c289beba09d35e8", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -250,7 +250,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![test_id, Ident::from_str_and_span(\"test_main_static\", sp)]));\n+        ecx.path(sp, vec![test_id, ecx.ident_of(\"test_main_static\", sp)]));\n \n     test_runner.span = sp;\n "}, {"sha": "597ae83572cee8d924ee35294f50b421482c13b4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae3830d589ec75494ff26bd9c92e9f77e49173f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=5ae3830d589ec75494ff26bd9c92e9f77e49173f", "patch": "@@ -765,7 +765,7 @@ impl Ident {\n         Ident::with_dummy_span(string.as_symbol())\n     }\n \n-    /// Maps a string to an identifier with an empty span.\n+    /// Maps a string to an identifier with a dummy span.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_dummy_span(Symbol::intern(string))\n     }"}]}