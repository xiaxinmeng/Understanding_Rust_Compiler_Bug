{"sha": "98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MDA3ZTJjZTZmMzczMWE5MzViMDU0MWQ2ZWY2M2YyOTJlZjdhYjk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-17T21:49:16Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-08-28T19:45:02Z"}, "message": "Drop the query result memmap before serializing it back.", "tree": {"sha": "3e1e5461a5a7e21cae171e1a3efa6d4f40e5461d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e1e5461a5a7e21cae171e1a3efa6d4f40e5461d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "html_url": "https://github.com/rust-lang/rust/commit/98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd", "html_url": "https://github.com/rust-lang/rust/commit/6b47e1ece87f8cb96709b772dbea1a2a979c1cbd"}], "stats": {"total": 70, "additions": 44, "deletions": 26}, "files": [{"sha": "572a4fc69717380aa6a8867a175425fd270da670", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "patch": "@@ -52,7 +52,10 @@ where\n     // Delete the old file, if any.\n     // Note: It's important that we actually delete the old file and not just\n     // truncate and overwrite it, since it might be a shared hard-link, the\n-    // underlying data of which we don't want to modify\n+    // underlying data of which we don't want to modify.\n+    //\n+    // We have to ensure we have dropped the memory maps to this file\n+    // before performing this removal.\n     match fs::remove_file(&path_buf) {\n         Ok(()) => {\n             debug!(\"save: remove old file\");\n@@ -114,6 +117,12 @@ pub fn read_file(\n         Err(err) if err.kind() == io::ErrorKind::NotFound => return Ok(None),\n         Err(err) => return Err(err),\n     };\n+    // SAFETY: This process must not modify nor remove the backing file while the memory map lives.\n+    // For the dep-graph and the work product index, it is as soon as the decoding is done.\n+    // For the query result cache, the memory map is dropped in save_dep_graph before calling\n+    // save_in and trying to remove the backing file.\n+    //\n+    // There is no way to prevent another process from modifying this file.\n     let mmap = unsafe { Mmap::map(file) }?;\n \n     let mut file = io::Cursor::new(&*mmap);"}, {"sha": "6c683058b12d668945278790ed3e26ed76e10168", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "patch": "@@ -42,6 +42,11 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         join(\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n+                    // Drop the memory map so that we can remove the file and write to it.\n+                    if let Some(odc) = &tcx.on_disk_cache {\n+                        odc.drop_serialized_data(tcx);\n+                    }\n+\n                     file_format::save_in(sess, query_cache_path, \"query cache\", |e| {\n                         encode_query_cache(tcx, e)\n                     });"}, {"sha": "dae82d2438ade624b28b4e433b88a491d8ed7404", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "patch": "@@ -101,6 +101,8 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     fn register_reused_dep_node(&self, tcx: TyCtxt<'tcx>, dep_node: &DepNode);\n     fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash);\n \n+    fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>);\n+\n     fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n }\n "}, {"sha": "c197962fabbefd9f390a2baf9ded08672c15ecff", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98007e2ce6f3731a935b0541d6ef63f292ef7ab9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=98007e2ce6f3731a935b0541d6ef63f292ef7ab9", "patch": "@@ -1,7 +1,7 @@\n use crate::QueryCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n+use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell, RwLock};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n@@ -43,7 +43,7 @@ const TAG_EXPN_DATA: u8 = 1;\n /// any side effects that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n     // The complete cache data in serialized form.\n-    serialized_data: Option<Mmap>,\n+    serialized_data: RwLock<Option<Mmap>>,\n \n     // Collects all `QuerySideEffects` created during the current compilation\n     // session.\n@@ -206,7 +206,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         };\n \n         Self {\n-            serialized_data: Some(data),\n+            serialized_data: RwLock::new(Some(data)),\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n             cnum_map: OnceCell::new(),\n@@ -227,7 +227,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n \n     fn new_empty(source_map: &'sess SourceMap) -> Self {\n         Self {\n-            serialized_data: None,\n+            serialized_data: RwLock::new(None),\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n             cnum_map: OnceCell::new(),\n@@ -246,7 +246,26 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         }\n     }\n \n-    fn serialize(&self, tcx: TyCtxt<'sess>, encoder: &mut FileEncoder) -> FileEncodeResult {\n+    fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>) {\n+        // Register any dep nodes that we reused from the previous session,\n+        // but didn't `DepNode::construct` in this session. This ensures\n+        // that their `DefPathHash` to `RawDefId` mappings are registered\n+        // in 'latest_foreign_def_path_hashes' if necessary, since that\n+        // normally happens in `DepNode::construct`.\n+        tcx.dep_graph.register_reused_dep_nodes(tcx);\n+\n+        // Load everything into memory so we can write it out to the on-disk\n+        // cache. The vast majority of cacheable query results should already\n+        // be in memory, so this should be a cheap operation.\n+        // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n+        // loading existing queries may cause us to create new DepNodes, which\n+        // may in turn end up invoking `store_foreign_def_id_hash`\n+        tcx.dep_graph.exec_cache_promotions(QueryCtxt::from_tcx(tcx));\n+\n+        *self.serialized_data.write() = None;\n+    }\n+\n+    fn serialize<'tcx>(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate `SourceFileIndex`es.\n@@ -268,21 +287,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 (file_to_file_index, file_index_to_stable_id)\n             };\n \n-            // Register any dep nodes that we reused from the previous session,\n-            // but didn't `DepNode::construct` in this session. This ensures\n-            // that their `DefPathHash` to `RawDefId` mappings are registered\n-            // in 'latest_foreign_def_path_hashes' if necessary, since that\n-            // normally happens in `DepNode::construct`.\n-            tcx.dep_graph.register_reused_dep_nodes(tcx);\n-\n-            // Load everything into memory so we can write it out to the on-disk\n-            // cache. The vast majority of cacheable query results should already\n-            // be in memory, so this should be a cheap operation.\n-            // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n-            // loading existing queries may cause us to create new DepNodes, which\n-            // may in turn end up invoking `store_foreign_def_id_hash`\n-            tcx.dep_graph.exec_cache_promotions(QueryCtxt::from_tcx(tcx));\n-\n             let latest_foreign_def_path_hashes = self.latest_foreign_def_path_hashes.lock().clone();\n             let hygiene_encode_context = HygieneEncodeContext::default();\n \n@@ -566,7 +570,7 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n-    fn with_decoder<'a, 'tcx, T, F: FnOnce(&mut CacheDecoder<'sess, 'tcx>) -> T>(\n+    fn with_decoder<'a, 'tcx, T, F: for<'s> FnOnce(&mut CacheDecoder<'s, 'tcx>) -> T>(\n         &'sess self,\n         tcx: TyCtxt<'tcx>,\n         pos: AbsoluteBytePos,\n@@ -577,12 +581,10 @@ impl<'sess> OnDiskCache<'sess> {\n     {\n         let cnum_map = self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx));\n \n+        let serialized_data = self.serialized_data.read();\n         let mut decoder = CacheDecoder {\n             tcx,\n-            opaque: opaque::Decoder::new(\n-                self.serialized_data.as_deref().unwrap_or(&[]),\n-                pos.to_usize(),\n-            ),\n+            opaque: opaque::Decoder::new(serialized_data.as_deref().unwrap_or(&[]), pos.to_usize()),\n             source_map: self.source_map,\n             cnum_map,\n             file_index_to_file: &self.file_index_to_file,"}]}