{"sha": "c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOThlZmM1M2YwOWY2ZTFhOGNiYTRlYzIyNTlmZmI5ZDg5ZjA1NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-18T11:23:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-18T11:23:44Z"}, "message": "Auto merge of #39271 - est31:add_float_bits, r=BurntSushi\n\nAdd functions to safely transmute float to int\n\nThe safe subset of Rust tries to be as powerful as possible. While it is very powerful already, its currently impossible to safely transmute integers to floats. While crates exist that provide a safe interface, most prominently the `iee754` crate (which also inspired naming of the added functions), they themselves only use the unsafe `mem::transmute` function to accomplish this task.\n\nAlso, including an entire crate for just two lines of unsafe code seems quite wasteful.\n\nThat's why this PR adds functions to safely transmute integers to floats and vice versa, currently gated by the newly added `float_bits_conv` feature.\n\nThe functions added are no niche case. Not just `ieee754` [currently implements](https://github.com/huonw/ieee754/blob/master/src/lib.rs#L441) float to int transmutation via unsafe code but also the [very popular `byteorder` crate](https://github.com/BurntSushi/byteorder/blob/1.0.0/src/lib.rs#L258). This functionality of byteorder is in turn used by higher level crates. I only give two examples out of many: [chor](https://github.com/pyfisch/cbor/blob/a7363ea9aaf372e3d24b52414b5c76552ecc91c8/src/ser.rs#L227) and [bincode](https://github.com/TyOverby/bincode/blob/f06a4cfcb5b194e54d4997c200c75b88b6c3fba4/src/serde/reader.rs#L218).\n\nOne alternative would be to manually use functions like pow or multiplication by 1 to get a similar result, but they only work in the int -> float direction, and are not bit exact, and much slower (also, most likely the optimizer will never optimize it to a transmute because the conversion is not bit exact while the transmute is).\n\nTracking issue: #40470", "tree": {"sha": "17060193776655170f41a7489ff173152172f1eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17060193776655170f41a7489ff173152172f1eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "html_url": "https://github.com/rust-lang/rust/commit/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e621e1c73f1487b4450446eafe6ccad3a99e3cd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e621e1c73f1487b4450446eafe6ccad3a99e3cd8", "html_url": "https://github.com/rust-lang/rust/commit/e621e1c73f1487b4450446eafe6ccad3a99e3cd8"}, {"sha": "0c148153f4de0c32206582ed9b51346f9769f10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c148153f4de0c32206582ed9b51346f9769f10c", "html_url": "https://github.com/rust-lang/rust/commit/0c148153f4de0c32206582ed9b51346f9769f10c"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "d492903f03f6c74ab6cd9f82330ec84470add7ee", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "patch": "@@ -72,6 +72,7 @@\n - [fd](fd.md)\n - [fd_read](fd-read.md)\n - [fixed_size_array](fixed-size-array.md)\n+- [float_bits_conv](float-bits-conv.md)\n - [float_extras](float-extras.md)\n - [flt2dec](flt2dec.md)\n - [fmt_flags_align](fmt-flags-align.md)"}, {"sha": "f519545ac78b5208bd2f0fa6e30690e896bae186", "filename": "src/doc/unstable-book/src/float-bits-conv.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Fdoc%2Funstable-book%2Fsrc%2Ffloat-bits-conv.md", "raw_url": "https://github.com/rust-lang/rust/raw/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Fdoc%2Funstable-book%2Fsrc%2Ffloat-bits-conv.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Ffloat-bits-conv.md?ref=c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "patch": "@@ -0,0 +1,7 @@\n+# `float_bits_conv`\n+\n+The tracking issue for this feature is: [#40470]\n+\n+[#40470]: https://github.com/rust-lang/rust/issues/40470\n+\n+------------------------"}, {"sha": "316e6841c4feabf562365d72fdda5b7159e1a749", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "patch": "@@ -1226,6 +1226,68 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n+\n+    /// Raw transmutation to `u32`.\n+    ///\n+    /// Converts the `f32` into its raw memory representation,\n+    /// similar to the `transmute` function.\n+    ///\n+    /// Note that this function is distinct from casting.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_bits_conv)]\n+    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n+    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n+    ///\n+    /// ```\n+    #[unstable(feature = \"float_bits_conv\", reason = \"recently added\", issue = \"40470\")]\n+    #[inline]\n+    pub fn to_bits(self) -> u32 {\n+        unsafe { ::mem::transmute(self) }\n+    }\n+\n+    /// Raw transmutation from `u32`.\n+    ///\n+    /// Converts the given `u32` containing the float's raw memory\n+    /// representation into the `f32` type, similar to the\n+    /// `transmute` function.\n+    ///\n+    /// There is only one difference to a bare `transmute`:\n+    /// Due to the implications onto Rust's safety promises being\n+    /// uncertain, if the representation of a signaling NaN \"sNaN\" float\n+    /// is passed to the function, the implementation is allowed to\n+    /// return a quiet NaN instead.\n+    ///\n+    /// Note that this function is distinct from casting.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_bits_conv)]\n+    /// use std::f32;\n+    /// let v = f32::from_bits(0x41480000);\n+    /// let difference = (v - 12.5).abs();\n+    /// assert!(difference <= 1e-5);\n+    /// // Example for a signaling NaN value:\n+    /// let snan = 0x7F800001;\n+    /// assert_ne!(f32::from_bits(snan).to_bits(), snan);\n+    /// ```\n+    #[unstable(feature = \"float_bits_conv\", reason = \"recently added\", issue = \"40470\")]\n+    #[inline]\n+    pub fn from_bits(mut v: u32) -> Self {\n+        const EXP_MASK: u32   = 0x7F800000;\n+        const QNAN_MASK: u32  = 0x00400000;\n+        const FRACT_MASK: u32 = 0x007FFFFF;\n+        if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n+            // If we have a NaN value, we\n+            // convert signaling NaN values to quiet NaN\n+            // by setting the the highest bit of the fraction\n+            v |= QNAN_MASK;\n+        }\n+        unsafe { ::mem::transmute(v) }\n+    }\n }\n \n #[cfg(test)]\n@@ -1870,4 +1932,31 @@ mod tests {\n         assert_approx_eq!(ln_2, 2f32.ln());\n         assert_approx_eq!(ln_10, 10f32.ln());\n     }\n+\n+    #[test]\n+    fn test_float_bits_conv() {\n+        assert_eq!((1f32).to_bits(), 0x3f800000);\n+        assert_eq!((12.5f32).to_bits(), 0x41480000);\n+        assert_eq!((1337f32).to_bits(), 0x44a72000);\n+        assert_eq!((-14.25f32).to_bits(), 0xc1640000);\n+        assert_approx_eq!(f32::from_bits(0x3f800000), 1.0);\n+        assert_approx_eq!(f32::from_bits(0x41480000), 12.5);\n+        assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n+        assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n+    }\n+    #[test]\n+    fn test_snan_masking() {\n+        let snan: u32 = 0x7F801337;\n+        const PAYLOAD_MASK: u32 = 0x003FFFFF;\n+        const QNAN_MASK: u32  = 0x00400000;\n+        let nan_masked_fl = f32::from_bits(snan);\n+        let nan_masked = nan_masked_fl.to_bits();\n+        // Ensure that signaling NaNs don't stay the same\n+        assert_ne!(nan_masked, snan);\n+        // Ensure that we have a quiet NaN\n+        assert_ne!(nan_masked & QNAN_MASK, 0);\n+        assert!(nan_masked_fl.is_nan());\n+        // Ensure the payload wasn't touched during conversion\n+        assert_eq!(nan_masked & PAYLOAD_MASK, snan & PAYLOAD_MASK);\n+    }\n }"}, {"sha": "be55cb80c92fa3b9f1396ba28ba91d1a9803f9ba", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "patch": "@@ -1118,6 +1118,68 @@ impl f64 {\n             }\n         }\n     }\n+\n+    /// Raw transmutation to `u64`.\n+    ///\n+    /// Converts the `f64` into its raw memory representation,\n+    /// similar to the `transmute` function.\n+    ///\n+    /// Note that this function is distinct from casting.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_bits_conv)]\n+    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n+    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n+    ///\n+    /// ```\n+    #[unstable(feature = \"float_bits_conv\", reason = \"recently added\", issue = \"40470\")]\n+    #[inline]\n+    pub fn to_bits(self) -> u64 {\n+        unsafe { ::mem::transmute(self) }\n+    }\n+\n+    /// Raw transmutation from `u64`.\n+    ///\n+    /// Converts the given `u64` containing the float's raw memory\n+    /// representation into the `f64` type, similar to the\n+    /// `transmute` function.\n+    ///\n+    /// There is only one difference to a bare `transmute`:\n+    /// Due to the implications onto Rust's safety promises being\n+    /// uncertain, if the representation of a signaling NaN \"sNaN\" float\n+    /// is passed to the function, the implementation is allowed to\n+    /// return a quiet NaN instead.\n+    ///\n+    /// Note that this function is distinct from casting.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_bits_conv)]\n+    /// use std::f64;\n+    /// let v = f64::from_bits(0x4029000000000000);\n+    /// let difference = (v - 12.5).abs();\n+    /// assert!(difference <= 1e-5);\n+    /// // Example for a signaling NaN value:\n+    /// let snan = 0x7FF0000000000001;\n+    /// assert_ne!(f64::from_bits(snan).to_bits(), snan);\n+    /// ```\n+    #[unstable(feature = \"float_bits_conv\", reason = \"recently added\", issue = \"40470\")]\n+    #[inline]\n+    pub fn from_bits(mut v: u64) -> Self {\n+        const EXP_MASK: u64   = 0x7FF0000000000000;\n+        const QNAN_MASK: u64  = 0x0001000000000000;\n+        const FRACT_MASK: u64 = 0x000FFFFFFFFFFFFF;\n+        if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n+            // If we have a NaN value, we\n+            // convert signaling NaN values to quiet NaN\n+            // by setting the the highest bit of the fraction\n+            v |= QNAN_MASK;\n+        }\n+        unsafe { ::mem::transmute(v) }\n+    }\n }\n \n #[cfg(test)]\n@@ -1755,4 +1817,16 @@ mod tests {\n         assert_approx_eq!(ln_2, 2f64.ln());\n         assert_approx_eq!(ln_10, 10f64.ln());\n     }\n+\n+    #[test]\n+    fn test_float_bits_conv() {\n+        assert_eq!((1f64).to_bits(), 0x3ff0000000000000);\n+        assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n+        assert_eq!((1337f64).to_bits(), 0x4094e40000000000);\n+        assert_eq!((-14.25f64).to_bits(), 0xc02c800000000000);\n+        assert_approx_eq!(f64::from_bits(0x3ff0000000000000), 1.0);\n+        assert_approx_eq!(f64::from_bits(0x4029000000000000), 12.5);\n+        assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n+        assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n+    }\n }"}, {"sha": "8de6e1a24f1f2d7f705bafb092255fea2389a7fe", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "patch": "@@ -321,6 +321,7 @@\n #![feature(zero_one)]\n #![cfg_attr(test, feature(update_panic_count))]\n #![cfg_attr(stage0, feature(pub_restricted))]\n+#![cfg_attr(test, feature(float_bits_conv))]\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute\n // to import the prelude implicitly when building crates that depend on std."}]}