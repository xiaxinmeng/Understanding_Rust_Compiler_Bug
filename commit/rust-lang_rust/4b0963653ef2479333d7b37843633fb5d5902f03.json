{"sha": "4b0963653ef2479333d7b37843633fb5d5902f03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMDk2MzY1M2VmMjQ3OTMzM2Q3YjM3ODQzNjMzZmI1ZDU5MDJmMDM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-25T02:10:00Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-25T02:10:00Z"}, "message": "When encountering move error on an `Option`, suggest using `as_ref`", "tree": {"sha": "ee24a0511f71efeba7173977a010ed11f6d9053a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee24a0511f71efeba7173977a010ed11f6d9053a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b0963653ef2479333d7b37843633fb5d5902f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0963653ef2479333d7b37843633fb5d5902f03", "html_url": "https://github.com/rust-lang/rust/commit/4b0963653ef2479333d7b37843633fb5d5902f03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b0963653ef2479333d7b37843633fb5d5902f03/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd", "html_url": "https://github.com/rust-lang/rust/commit/dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd"}], "stats": {"total": 215, "additions": 138, "deletions": 77}, "files": [{"sha": "19ad92a8275f96a00477b84e8abae68ceabf68e6", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 84, "deletions": 77, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=4b0963653ef2479333d7b37843633fb5d5902f03", "patch": "@@ -242,12 +242,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         let (mut err, err_span) = {\n             let (span, original_path, kind): (Span, &Place<'tcx>, &IllegalMoveOriginKind<'_>) =\n                 match error {\n-                    GroupedMoveError::MovesFromPlace {\n-                        span,\n-                        ref original_path,\n-                        ref kind,\n-                        ..\n-                    } |\n+                    GroupedMoveError::MovesFromPlace { span, ref original_path, ref kind, .. } |\n                     GroupedMoveError::MovesFromValue { span, ref original_path, ref kind, .. } |\n                     GroupedMoveError::OtherIllegalMove { span, ref original_path, ref kind } => {\n                         (span, original_path, kind)\n@@ -257,81 +252,93 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n                    self.is_upvar_field_projection(original_path));\n-            (\n-                match kind {\n-                    IllegalMoveOriginKind::Static => {\n-                        self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n-                    }\n-                    IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n-                        // Inspect the type of the content behind the\n-                        // borrow to provide feedback about why this\n-                        // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.infcx.tcx).ty;\n-                        let is_upvar_field_projection =\n-                            self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| self.is_upvar_field_projection(p).is_some());\n-                        debug!(\"report: ty={:?}\", ty);\n-                        match ty.sty {\n-                            ty::Array(..) | ty::Slice(..) =>\n-                                self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                                    span, ty, None, origin\n-                                ),\n-                            ty::Closure(def_id, closure_substs)\n-                                if def_id == self.mir_def_id && is_upvar_field_projection\n-                            => {\n-                                let closure_kind_ty =\n-                                    closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n-                                let closure_kind = closure_kind_ty.to_opt_closure_kind();\n-                                let place_description = match closure_kind {\n-                                    Some(ty::ClosureKind::Fn) => {\n-                                        \"captured variable in an `Fn` closure\"\n-                                    }\n-                                    Some(ty::ClosureKind::FnMut) => {\n-                                        \"captured variable in an `FnMut` closure\"\n-                                    }\n-                                    Some(ty::ClosureKind::FnOnce) => {\n-                                        bug!(\"closure kind does not match first argument type\")\n-                                    }\n-                                    None => bug!(\"closure kind not inferred by borrowck\"),\n-                                };\n-                                debug!(\"report: closure_kind_ty={:?} closure_kind={:?} \\\n-                                       place_description={:?}\", closure_kind_ty, closure_kind,\n-                                       place_description);\n-\n-                                let mut diag = self.infcx.tcx.cannot_move_out_of(\n-                                    span, place_description, origin);\n-\n-                                for prefix in self.prefixes(&original_path, PrefixSet::All) {\n-                                    if let Some(field) = self.is_upvar_field_projection(prefix) {\n-                                        let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n-                                        let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n-                                            upvar_hir_id);\n-                                        diag.span_label(upvar_span, \"captured outer variable\");\n-                                        break;\n-                                    }\n+            let err = match kind {\n+                IllegalMoveOriginKind::Static => {\n+                    self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n+                }\n+                IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n+                    // Inspect the type of the content behind the\n+                    // borrow to provide feedback about why this\n+                    // was a move rather than a copy.\n+                    let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+                    let is_upvar_field_projection =\n+                        self.prefixes(&original_path, PrefixSet::All)\n+                        .any(|p| self.is_upvar_field_projection(p).is_some());\n+                    debug!(\"report: ty={:?}\", ty);\n+                    let mut err = match ty.sty {\n+                        ty::Array(..) | ty::Slice(..) =>\n+                            self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                                span, ty, None, origin\n+                            ),\n+                        ty::Closure(def_id, closure_substs)\n+                            if def_id == self.mir_def_id && is_upvar_field_projection\n+                        => {\n+                            let closure_kind_ty =\n+                                closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n+                            let closure_kind = closure_kind_ty.to_opt_closure_kind();\n+                            let place_description = match closure_kind {\n+                                Some(ty::ClosureKind::Fn) => {\n+                                    \"captured variable in an `Fn` closure\"\n+                                }\n+                                Some(ty::ClosureKind::FnMut) => {\n+                                    \"captured variable in an `FnMut` closure\"\n+                                }\n+                                Some(ty::ClosureKind::FnOnce) => {\n+                                    bug!(\"closure kind does not match first argument type\")\n+                                }\n+                                None => bug!(\"closure kind not inferred by borrowck\"),\n+                            };\n+                            debug!(\"report: closure_kind_ty={:?} closure_kind={:?} \\\n+                                    place_description={:?}\", closure_kind_ty, closure_kind,\n+                                    place_description);\n+\n+                            let mut diag = self.infcx.tcx.cannot_move_out_of(\n+                                span, place_description, origin);\n+\n+                            for prefix in self.prefixes(&original_path, PrefixSet::All) {\n+                                if let Some(field) = self.is_upvar_field_projection(prefix) {\n+                                    let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n+                                    let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n+                                        upvar_hir_id);\n+                                    diag.span_label(upvar_span, \"captured outer variable\");\n+                                    break;\n                                 }\n-\n-                                diag\n                             }\n-                            _ => {\n-                                let source = self.borrowed_content_source(place);\n-                                self.infcx.tcx.cannot_move_out_of(\n-                                    span, &source.to_string(), origin\n-                                )\n-                            },\n+\n+                            diag\n                         }\n+                        _ => {\n+                            let source = self.borrowed_content_source(place);\n+                            self.infcx.tcx.cannot_move_out_of(\n+                                span, &source.to_string(), origin\n+                            )\n+                        },\n+                    };\n+                    let orig_path_ty = format!(\n+                        \"{:?}\",\n+                        original_path.ty(self.mir, self.infcx.tcx).ty,\n+                    );\n+                    let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n+                    if orig_path_ty.starts_with(\"std::option::Option\") {\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider borrowing the `Option`'s content\",\n+                            format!(\"{}.as_ref()\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n-                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        self.infcx.tcx\n-                            .cannot_move_out_of_interior_of_drop(span, ty, origin)\n-                    }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n-                        self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                            span, ty, Some(*is_index), origin\n-                        ),\n-                },\n-                span,\n-            )\n+                    err\n+                }\n+                IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                    self.infcx.tcx\n+                        .cannot_move_out_of_interior_of_drop(span, ty, origin)\n+                }\n+                IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n+                    self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                        span, ty, Some(*is_index), origin\n+                    ),\n+            };\n+            (err, span)\n         };\n \n         self.add_move_hints(error, &mut err, err_span);"}, {"sha": "7113de9f4148408fadeb2eb00fed546cd2bf18bc", "filename": "src/test/ui/suggestions/option-content-move.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.fixed?ref=4b0963653ef2479333d7b37843633fb5d5902f03", "patch": "@@ -0,0 +1,21 @@\n+//run-rustfix\n+\n+pub struct LipogramCorpora {\n+    selections: Vec<(char, Option<String>)>,\n+}\n+\n+impl LipogramCorpora {\n+    pub fn validate_all(&mut self) -> Result<(), char> {\n+        for selection in &self.selections {\n+            if selection.1.is_some() {\n+                if selection.1.as_ref().unwrap().contains(selection.0) {\n+                //~^ ERROR cannot move out of borrowed content\n+                    return Err(selection.0);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5a38376ffa601371d35594721b9d961f885e2f5a", "filename": "src/test/ui/suggestions/option-content-move.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.rs?ref=4b0963653ef2479333d7b37843633fb5d5902f03", "patch": "@@ -0,0 +1,21 @@\n+//run-rustfix\n+\n+pub struct LipogramCorpora {\n+    selections: Vec<(char, Option<String>)>,\n+}\n+\n+impl LipogramCorpora {\n+    pub fn validate_all(&mut self) -> Result<(), char> {\n+        for selection in &self.selections {\n+            if selection.1.is_some() {\n+                if selection.1.unwrap().contains(selection.0) {\n+                //~^ ERROR cannot move out of borrowed content\n+                    return Err(selection.0);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7f019c3b5b92549704f22487f1b2267694d3af1f", "filename": "src/test/ui/suggestions/option-content-move.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b0963653ef2479333d7b37843633fb5d5902f03/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr?ref=4b0963653ef2479333d7b37843633fb5d5902f03", "patch": "@@ -0,0 +1,12 @@\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/option-content-move.rs:11:20\n+   |\n+LL |                 if selection.1.unwrap().contains(selection.0) {\n+   |                    ^^^^^^^^^^^\n+   |                    |\n+   |                    cannot move out of borrowed content\n+   |                    help: consider borrowing the `Option`'s content: `selection.1.as_ref()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}]}