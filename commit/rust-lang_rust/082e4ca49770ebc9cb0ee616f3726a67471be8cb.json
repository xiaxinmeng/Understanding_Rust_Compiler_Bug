{"sha": "082e4ca49770ebc9cb0ee616f3726a67471be8cb", "node_id": "C_kwDOAAsO6NoAKDA4MmU0Y2E0OTc3MGViYzljYjBlZTYxNmYzNzI2YTY3NDcxYmU4Y2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-26T15:59:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-26T15:59:46Z"}, "message": "Auto merge of #96428 - GuillaumeGomez:rollup-4noqr33, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #94022 (Clarify that `Cow::into_owned` returns owned data)\n - #94703 (Fix codegen bug in \"ptx-kernel\" abi related to arg passing)\n - #95949 (Implement Default for AssertUnwindSafe)\n - #96361 (Switch JS code to ES6)\n - #96372 (Suggest calling method on nested field when struct is missing method)\n - #96386 (simplify `describe_field` func in borrowck's diagnostics part)\n - #96400 (Correct documentation for `Rvalue::ShallowInitBox`)\n - #96415 (Remove references to git.io)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d7c490a8e6e9673c21f17a440c7f756089bb4775", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7c490a8e6e9673c21f17a440c7f756089bb4775"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082e4ca49770ebc9cb0ee616f3726a67471be8cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082e4ca49770ebc9cb0ee616f3726a67471be8cb", "html_url": "https://github.com/rust-lang/rust/commit/082e4ca49770ebc9cb0ee616f3726a67471be8cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082e4ca49770ebc9cb0ee616f3726a67471be8cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d237ab52920924694f6fc3e47ee8588514bfa70", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d237ab52920924694f6fc3e47ee8588514bfa70", "html_url": "https://github.com/rust-lang/rust/commit/3d237ab52920924694f6fc3e47ee8588514bfa70"}, {"sha": "223f107b48510a117defa07931b13923a1a7c894", "url": "https://api.github.com/repos/rust-lang/rust/commits/223f107b48510a117defa07931b13923a1a7c894", "html_url": "https://github.com/rust-lang/rust/commit/223f107b48510a117defa07931b13923a1a7c894"}], "stats": {"total": 1005, "additions": 721, "deletions": 284}, "files": [{"sha": "b81360fd6aab401b8bc2c0c597b5235bb9c451ad", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -40,6 +40,7 @@ crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n crate use rustc_const_eval::util::CallKind;\n+use rustc_middle::mir::tcx::PlaceTy;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -329,30 +330,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// End-user visible description of the `field`nth field of `base`\n     fn describe_field(&self, place: PlaceRef<'tcx>, field: Field) -> String {\n-        // FIXME Place2 Make this work iteratively\n-        match place {\n-            PlaceRef { local, projection: [] } => {\n-                let local = &self.body.local_decls[local];\n-                self.describe_field_from_ty(local.ty, field, None)\n-            }\n+        let place_ty = match place {\n+            PlaceRef { local, projection: [] } => PlaceTy::from_ty(self.body.local_decls[local].ty),\n             PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n-                ProjectionElem::Deref => {\n-                    self.describe_field(PlaceRef { local, projection: proj_base }, field)\n-                }\n-                ProjectionElem::Downcast(_, variant_index) => {\n-                    let base_ty = place.ty(self.body, self.infcx.tcx).ty;\n-                    self.describe_field_from_ty(base_ty, field, Some(*variant_index))\n-                }\n-                ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(*field_type, field, None)\n-                }\n-                ProjectionElem::Index(..)\n+                ProjectionElem::Deref\n+                | ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {\n-                    self.describe_field(PlaceRef { local, projection: proj_base }, field)\n+                    PlaceRef { local, projection: proj_base }.ty(self.body, self.infcx.tcx)\n                 }\n+                ProjectionElem::Downcast(..) => place.ty(self.body, self.infcx.tcx),\n+                ProjectionElem::Field(_, field_type) => PlaceTy::from_ty(*field_type),\n             },\n-        }\n+        };\n+        self.describe_field_from_ty(place_ty.ty, field, place_ty.variant_index)\n     }\n \n     /// End-user visible description of the `field_index`nth field of `ty`"}, {"sha": "883fc72cd56c1867c5ebe68c24b5e5ceb8565bda", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -2581,8 +2581,6 @@ pub enum Rvalue<'tcx> {\n     /// This is different from a normal transmute because dataflow analysis will treat the box as\n     /// initialized but its content as uninitialized. Like other pointer casts, this in general\n     /// affects alias analysis.\n-    ///\n-    /// Disallowed after drop elaboration.\n     ShallowInitBox(Operand<'tcx>, Ty<'tcx>),\n }\n "}, {"sha": "cd4b23fca393282a40126213a1b24c35be53a042", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -2592,6 +2592,22 @@ where\n \n         pointee_info\n     }\n+\n+    fn is_adt(this: TyAndLayout<'tcx>) -> bool {\n+        matches!(this.ty.kind(), ty::Adt(..))\n+    }\n+\n+    fn is_never(this: TyAndLayout<'tcx>) -> bool {\n+        this.ty.kind() == &ty::Never\n+    }\n+\n+    fn is_tuple(this: TyAndLayout<'tcx>) -> bool {\n+        matches!(this.ty.kind(), ty::Tuple(..))\n+    }\n+\n+    fn is_unit(this: TyAndLayout<'tcx>) -> bool {\n+        matches!(this.ty.kind(), ty::Tuple(list) if list.len() == 0)\n+    }\n }\n \n impl<'tcx> ty::Instance<'tcx> {"}, {"sha": "197dc9205b4804d97fb79d07360afba35606ce72", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -61,6 +61,10 @@ impl<T> List<T> {\n         static EMPTY_SLICE: InOrder<usize, MaxAlign> = InOrder(0, MaxAlign);\n         unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n }\n \n impl<T: Copy> List<T> {"}, {"sha": "afce10ff1cbe8f36510626fd4696e1e46c22874c", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -696,7 +696,13 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"sparc\" => sparc::compute_abi_info(cx, self),\n             \"sparc64\" => sparc64::compute_abi_info(cx, self),\n             \"nvptx\" => nvptx::compute_abi_info(self),\n-            \"nvptx64\" => nvptx64::compute_abi_info(self),\n+            \"nvptx64\" => {\n+                if cx.target_spec().adjust_abi(abi) == spec::abi::Abi::PtxKernel {\n+                    nvptx64::compute_ptx_kernel_abi_info(cx, self)\n+                } else {\n+                    nvptx64::compute_abi_info(self)\n+                }\n+            }\n             \"hexagon\" => hexagon::compute_abi_info(self),\n             \"riscv32\" | \"riscv64\" => riscv::compute_abi_info(cx, self),\n             \"wasm32\" | \"wasm64\" => {"}, {"sha": "fc16f1c97a4522dc45d1e3680c66ac35728886bc", "filename": "compiler/rustc_target/src/abi/call/nvptx64.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -1,21 +1,35 @@\n-// Reference: PTX Writer's Guide to Interoperability\n-// https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n-\n-use crate::abi::call::{ArgAbi, FnAbi};\n+use crate::abi::call::{ArgAbi, FnAbi, PassMode, Reg, Size, Uniform};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n         ret.make_indirect();\n-    } else {\n-        ret.extend_integer_width_to(64);\n     }\n }\n \n fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n         arg.make_indirect();\n-    } else {\n-        arg.extend_integer_width_to(64);\n+    }\n+}\n+\n+fn classify_arg_kernel<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if matches!(arg.mode, PassMode::Pair(..)) && (arg.layout.is_adt() || arg.layout.is_tuple()) {\n+        let align_bytes = arg.layout.align.abi.bytes();\n+\n+        let unit = match align_bytes {\n+            1 => Reg::i8(),\n+            2 => Reg::i16(),\n+            4 => Reg::i32(),\n+            8 => Reg::i64(),\n+            16 => Reg::i128(),\n+            _ => unreachable!(\"Align is given as power of 2 no larger than 16 bytes\"),\n+        };\n+        arg.cast_to(Uniform { unit, total: Size::from_bytes(2 * align_bytes) });\n     }\n }\n \n@@ -31,3 +45,20 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_arg(arg);\n     }\n }\n+\n+pub fn compute_ptx_kernel_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if !fn_abi.ret.layout.is_unit() && !fn_abi.ret.layout.is_never() {\n+        panic!(\"Kernels should not return anything other than () or !\");\n+    }\n+\n+    for arg in &mut fn_abi.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_kernel(cx, arg);\n+    }\n+}"}, {"sha": "0e8fd9cc93fd120d97da310d45135688e0e01270", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -1355,6 +1355,10 @@ pub trait TyAbiInterface<'a, C>: Sized {\n         cx: &C,\n         offset: Size,\n     ) -> Option<PointeeInfo>;\n+    fn is_adt(this: TyAndLayout<'a, Self>) -> bool;\n+    fn is_never(this: TyAndLayout<'a, Self>) -> bool;\n+    fn is_tuple(this: TyAndLayout<'a, Self>) -> bool;\n+    fn is_unit(this: TyAndLayout<'a, Self>) -> bool;\n }\n \n impl<'a, Ty> TyAndLayout<'a, Ty> {\n@@ -1396,6 +1400,34 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             _ => false,\n         }\n     }\n+\n+    pub fn is_adt<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_adt(self)\n+    }\n+\n+    pub fn is_never<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_never(self)\n+    }\n+\n+    pub fn is_tuple<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_tuple(self)\n+    }\n+\n+    pub fn is_unit<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_unit(self)\n+    }\n }\n \n impl<'a, Ty> TyAndLayout<'a, Ty> {"}, {"sha": "4e7c2eb1bf88e65c39bd8c71d307d4ebd9197f28", "filename": "compiler/rustc_target/src/asm/mips.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -43,7 +43,8 @@ impl MipsInlineAsmRegClass {\n     }\n }\n \n-// The reserved registers are somewhat taken from <https://git.io/JUR1k#L150>.\n+// The reserved registers are somewhat taken from\n+// <https://github.com/llvm/llvm-project/blob/deb8f8bcf31540c657716ea5242183b0792702a1/llvm/lib/Target/Mips/MipsRegisterInfo.cpp#L150>.\n def_regs! {\n     Mips MipsInlineAsmReg MipsInlineAsmRegClass {\n         r2: reg = [\"$2\"],"}, {"sha": "480a5512249296d111bee1e8be320946e679e70c", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -2285,14 +2285,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n         if let Some((fields, substs)) = self.get_field_candidates(span, expr_t) {\n             for candidate_field in fields.iter() {\n-                if let Some(field_path) = self.check_for_nested_field(\n+                if let Some(mut field_path) = self.check_for_nested_field_satisfying(\n                     span,\n-                    field,\n+                    &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n                     candidate_field,\n                     substs,\n                     vec![],\n                     self.tcx.parent_module(id).to_def_id(),\n                 ) {\n+                    // field_path includes `field` that we're looking for, so pop it.\n+                    field_path.pop();\n+\n                     let field_path_str = field_path\n                         .iter()\n                         .map(|id| id.name.to_ident_string())\n@@ -2312,7 +2315,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n-    fn get_field_candidates(\n+    crate fn get_field_candidates(\n         &self,\n         span: Span,\n         base_t: Ty<'tcx>,\n@@ -2337,49 +2340,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// This method is called after we have encountered a missing field error to recursively\n     /// search for the field\n-    fn check_for_nested_field(\n+    crate fn check_for_nested_field_satisfying(\n         &self,\n         span: Span,\n-        target_field: Ident,\n+        matches: &impl Fn(&ty::FieldDef, Ty<'tcx>) -> bool,\n         candidate_field: &ty::FieldDef,\n         subst: SubstsRef<'tcx>,\n         mut field_path: Vec<Ident>,\n         id: DefId,\n     ) -> Option<Vec<Ident>> {\n         debug!(\n-            \"check_for_nested_field(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n+            \"check_for_nested_field_satisfying(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n             span, candidate_field, field_path\n         );\n \n-        if candidate_field.ident(self.tcx) == target_field {\n-            Some(field_path)\n-        } else if field_path.len() > 3 {\n+        if field_path.len() > 3 {\n             // For compile-time reasons and to avoid infinite recursion we only check for fields\n             // up to a depth of three\n             None\n         } else {\n             // recursively search fields of `candidate_field` if it's a ty::Adt\n-\n             field_path.push(candidate_field.ident(self.tcx).normalize_to_macros_2_0());\n             let field_ty = candidate_field.ty(self.tcx, subst);\n             if let Some((nested_fields, subst)) = self.get_field_candidates(span, field_ty) {\n                 for field in nested_fields.iter() {\n-                    let accessible = field.vis.is_accessible_from(id, self.tcx);\n-                    if accessible {\n-                        let ident = field.ident(self.tcx).normalize_to_macros_2_0();\n-                        if ident == target_field {\n+                    if field.vis.is_accessible_from(id, self.tcx) {\n+                        if matches(candidate_field, field_ty) {\n                             return Some(field_path);\n-                        }\n-                        let field_path = field_path.clone();\n-                        if let Some(path) = self.check_for_nested_field(\n+                        } else if let Some(field_path) = self.check_for_nested_field_satisfying(\n                             span,\n-                            target_field,\n+                            matches,\n                             field,\n                             subst,\n-                            field_path,\n+                            field_path.clone(),\n                             id,\n                         ) {\n-                            return Some(path);\n+                            return Some(field_path);\n                         }\n                     }\n                 }"}, {"sha": "88e0a4bada845255136d82d431e733ec311994d4", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -28,7 +28,7 @@ use rustc_trait_selection::traits::{\n use std::cmp::Ordering;\n use std::iter;\n \n-use super::probe::Mode;\n+use super::probe::{Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1129,6 +1129,46 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found();\n                 }\n \n+                if let SelfSource::MethodCall(expr) = source\n+                    && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+                {\n+                    let call_expr =\n+                        self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+                    for candidate_field in fields.iter() {\n+                        if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                            span,\n+                            &|_, field_ty| {\n+                                self.lookup_probe(\n+                                    span,\n+                                    item_name,\n+                                    field_ty,\n+                                    call_expr,\n+                                    ProbeScope::AllTraits,\n+                                )\n+                                .is_ok()\n+                            },\n+                            candidate_field,\n+                            substs,\n+                            vec![],\n+                            self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                        ) {\n+                            let field_path_str = field_path\n+                                .iter()\n+                                .map(|id| id.name.to_ident_string())\n+                                .collect::<Vec<String>>()\n+                                .join(\".\");\n+                            debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                            err.span_suggestion_verbose(\n+                                item_name.span.shrink_to_lo(),\n+                                \"one of the expressions' fields has a method of the same name\",\n+                                format!(\"{field_path_str}.\"),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+\n                 bound_spans.sort();\n                 bound_spans.dedup();\n                 for (span, msg) in bound_spans.into_iter() {"}, {"sha": "cb4e438f8bea22cbd34455f8aed2791f2bc5e856", "filename": "library/alloc/src/borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/library%2Falloc%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/library%2Falloc%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fborrow.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -292,8 +292,7 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     ///\n     /// # Examples\n     ///\n-    /// Calling `into_owned` on a `Cow::Borrowed` clones the underlying data\n-    /// and becomes a `Cow::Owned`:\n+    /// Calling `into_owned` on a `Cow::Borrowed` returns a clone of the borrowed data:\n     ///\n     /// ```\n     /// use std::borrow::Cow;\n@@ -307,7 +306,8 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     /// );\n     /// ```\n     ///\n-    /// Calling `into_owned` on a `Cow::Owned` is a no-op:\n+    /// Calling `into_owned` on a `Cow::Owned` returns the owned data. The data is moved out of the\n+    /// `Cow` without being cloned.\n     ///\n     /// ```\n     /// use std::borrow::Cow;"}, {"sha": "f2948aac3c235c5914cc878bf24dcdf774dc5a9f", "filename": "library/core/src/panic/unwind_safe.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -279,6 +279,13 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n     }\n }\n \n+#[stable(feature = \"assertunwindsafe_default\", since = \"1.62.0\")]\n+impl<T: Default> Default for AssertUnwindSafe<T> {\n+    fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;"}, {"sha": "bca1b65a7fc051862af3a3c8aeb432ea491acb83", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -35,7 +35,8 @@ cfg_if::cfg_if! {\n // Android with api less than 21 define sig* functions inline, so it is not\n // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n // to support older Android version (independent of libc version).\n-// The following implementations are based on https://git.io/vSkNf\n+// The following implementations are based on\n+// https://github.com/aosp-mirror/platform_bionic/blob/ad8dcd6023294b646e5a8288c0ed431b0845da49/libc/include/android/legacy_signal_inlines.h\n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"android\")] {\n         pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {"}, {"sha": "c4e74ea06578db01d49cd7049d29f022a2132f18", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 207, "deletions": 218, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -1,10 +1,13 @@\n+/* eslint-env es6 */\n+/* eslint no-var: \"error\" */\n+/* eslint prefer-const: \"error\" */\n /* global addClass, getNakedUrl, getSettingValue, hasOwnPropertyRustdoc, initSearch, onEach */\n /* global onEachLazy, removeClass, searchState, hasClass */\n \n (function() {\n // This mapping table should match the discriminants of\n // `rustdoc::formats::item_type::ItemType` type in Rust.\n-var itemTypes = [\n+const itemTypes = [\n     \"mod\",\n     \"externcrate\",\n     \"import\",\n@@ -34,15 +37,15 @@ var itemTypes = [\n ];\n \n // used for special search precedence\n-var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n-var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n+const TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n+const TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n \n // In the search display, allows to switch between tabs.\n function printTab(nb) {\n     if (nb === 0 || nb === 1 || nb === 2) {\n         searchState.currentTab = nb;\n     }\n-    var nb_copy = nb;\n+    let nb_copy = nb;\n     onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n         if (nb_copy === 0) {\n             addClass(elem, \"selected\");\n@@ -68,14 +71,15 @@ function printTab(nb) {\n  * This code is an unmodified version of the code written by Marco de Wit\n  * and was found at https://stackoverflow.com/a/18514751/745719\n  */\n-var levenshtein_row2 = [];\n+const levenshtein_row2 = [];\n function levenshtein(s1, s2) {\n     if (s1 === s2) {\n         return 0;\n     }\n-    var s1_len = s1.length, s2_len = s2.length;\n+    const s1_len = s1.length, s2_len = s2.length;\n     if (s1_len && s2_len) {\n-        var i1 = 0, i2 = 0, a, b, c, c2, row = levenshtein_row2;\n+        let i1 = 0, i2 = 0, a, b, c, c2;\n+        const row = levenshtein_row2;\n         while (i1 < s1_len) {\n             row[i1] = ++i1;\n         }\n@@ -97,24 +101,24 @@ function levenshtein(s1, s2) {\n }\n \n window.initSearch = function(rawSearchIndex) {\n-    var MAX_LEV_DISTANCE = 3;\n-    var MAX_RESULTS = 200;\n-    var GENERICS_DATA = 2;\n-    var NAME = 0;\n-    var INPUTS_DATA = 0;\n-    var OUTPUT_DATA = 1;\n-    var NO_TYPE_FILTER = -1;\n+    const MAX_LEV_DISTANCE = 3;\n+    const MAX_RESULTS = 200;\n+    const GENERICS_DATA = 2;\n+    const NAME = 0;\n+    const INPUTS_DATA = 0;\n+    const OUTPUT_DATA = 1;\n+    const NO_TYPE_FILTER = -1;\n     /**\n      *  @type {Array<Row>}\n      */\n-    var searchIndex;\n+    let searchIndex;\n     /**\n      *  @type {Array<string>}\n      */\n-    var searchWords;\n-    var currentResults;\n-    var ALIASES = {};\n-    var params = searchState.getQueryStringParams();\n+    let searchWords = [];\n+    let currentResults;\n+    const ALIASES = {};\n+    const params = searchState.getQueryStringParams();\n \n     // Populate search bar with query string search term when provided,\n     // but only if the input bar is empty. This avoid the obnoxious issue\n@@ -145,7 +149,7 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function itemTypeFromName(typename) {\n-        for (var i = 0, len = itemTypes.length; i < len; ++i) {\n+        for (let i = 0, len = itemTypes.length; i < len; ++i) {\n             if (itemTypes[i] === typename) {\n                 return i;\n             }\n@@ -176,8 +180,8 @@ window.initSearch = function(rawSearchIndex) {\n             throw new Error(\"Cannot use literal search when there is more than one element\");\n         }\n         parserState.pos += 1;\n-        var start = parserState.pos;\n-        var end = getIdentEndPosition(parserState);\n+        const start = parserState.pos;\n+        const end = getIdentEndPosition(parserState);\n         if (parserState.pos >= parserState.length) {\n             throw new Error(\"Unclosed `\\\"`\");\n         } else if (parserState.userQuery[end] !== \"\\\"\") {\n@@ -264,10 +268,10 @@ window.initSearch = function(rawSearchIndex) {\n         if (query.literalSearch && parserState.totalElems - parserState.genericsElems > 0) {\n             throw new Error(\"You cannot have more than one element if you use quotes\");\n         }\n-        var pathSegments = name.split(\"::\");\n+        const pathSegments = name.split(\"::\");\n         if (pathSegments.length > 1) {\n-            for (var i = 0, len = pathSegments.length; i < len; ++i) {\n-                var pathSegment = pathSegments[i];\n+            for (let i = 0, len = pathSegments.length; i < len; ++i) {\n+                const pathSegment = pathSegments[i];\n \n                 if (pathSegment.length === 0) {\n                     if (i === 0) {\n@@ -305,9 +309,9 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {integer}\n      */\n     function getIdentEndPosition(parserState) {\n-        var end = parserState.pos;\n+        let end = parserState.pos;\n         while (parserState.pos < parserState.length) {\n-            var c = parserState.userQuery[parserState.pos];\n+            const c = parserState.userQuery[parserState.pos];\n             if (!isIdentCharacter(c)) {\n                 if (isErrorCharacter(c)) {\n                     throw new Error(`Unexpected \\`${c}\\``);\n@@ -342,10 +346,10 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {boolean} isInGenerics\n      */\n     function getNextElem(query, parserState, elems, isInGenerics) {\n-        var generics = [];\n+        const generics = [];\n \n-        var start = parserState.pos;\n-        var end;\n+        let start = parserState.pos;\n+        let end;\n         // We handle the strings on their own mostly to make code easier to follow.\n         if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n             start += 1;\n@@ -393,10 +397,10 @@ window.initSearch = function(rawSearchIndex) {\n      *                                      character.\n      */\n     function getItemsBefore(query, parserState, elems, endChar) {\n-        var foundStopChar = true;\n+        let foundStopChar = true;\n \n         while (parserState.pos < parserState.length) {\n-            var c = parserState.userQuery[parserState.pos];\n+            const c = parserState.userQuery[parserState.pos];\n             if (c === endChar) {\n                 break;\n             } else if (isSeparatorCharacter(c)) {\n@@ -406,7 +410,7 @@ window.initSearch = function(rawSearchIndex) {\n             } else if (c === \":\" && isPathStart(parserState)) {\n                 throw new Error(\"Unexpected `::`: paths cannot start with `::`\");\n             } else if (c === \":\" || isEndCharacter(c)) {\n-                var extra = \"\";\n+                let extra = \"\";\n                 if (endChar === \">\") {\n                     extra = \"`<`\";\n                 } else if (endChar === \"\") {\n@@ -420,7 +424,7 @@ window.initSearch = function(rawSearchIndex) {\n                 }\n                 throw new Error(`Expected \\`,\\` or \\` \\`, found \\`${c}\\``);\n             }\n-            var posBefore = parserState.pos;\n+            const posBefore = parserState.pos;\n             getNextElem(query, parserState, elems, endChar === \">\");\n             // This case can be encountered if `getNextElem` encounted a \"stop character\" right from\n             // the start. For example if you have `,,` or `<>`. In this case, we simply move up the\n@@ -442,9 +446,9 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {ParserState} parserState\n      */\n     function checkExtraTypeFilterCharacters(parserState) {\n-        var query = parserState.userQuery;\n+        const query = parserState.userQuery;\n \n-        for (var pos = 0; pos < parserState.pos; ++pos) {\n+        for (let pos = 0; pos < parserState.pos; ++pos) {\n             if (!isIdentCharacter(query[pos]) && !isWhitespaceCharacter(query[pos])) {\n                 throw new Error(`Unexpected \\`${query[pos]}\\` in type filter`);\n             }\n@@ -459,8 +463,8 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {ParserState} parserState\n      */\n     function parseInput(query, parserState) {\n-        var c, before;\n-        var foundStopChar = true;\n+        let c, before;\n+        let foundStopChar = true;\n \n         while (parserState.pos < parserState.length) {\n             c = parserState.userQuery[parserState.pos];\n@@ -557,7 +561,7 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {string}\n      */\n     function buildUrl(search, filterCrates) {\n-        var extra = \"?search=\" + encodeURIComponent(search);\n+        let extra = \"?search=\" + encodeURIComponent(search);\n \n         if (filterCrates !== null) {\n             extra += \"&filter-crate=\" + encodeURIComponent(filterCrates);\n@@ -571,7 +575,7 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {string|null}\n      */\n     function getFilterCrates() {\n-        var elem = document.getElementById(\"crate-search\");\n+        const elem = document.getElementById(\"crate-search\");\n \n         if (elem &&\n             elem.value !== \"All crates\" &&\n@@ -650,7 +654,7 @@ window.initSearch = function(rawSearchIndex) {\n      */\n     function parseQuery(userQuery) {\n         userQuery = userQuery.trim();\n-        var parserState = {\n+        const parserState = {\n             length: userQuery.length,\n             pos: 0,\n             // Total number of elements (includes generics).\n@@ -659,12 +663,12 @@ window.initSearch = function(rawSearchIndex) {\n             typeFilter: null,\n             userQuery: userQuery.toLowerCase(),\n         };\n-        var query = newParsedQuery(userQuery);\n+        let query = newParsedQuery(userQuery);\n \n         try {\n             parseInput(query, parserState);\n             if (parserState.typeFilter !== null) {\n-                var typeFilter = parserState.typeFilter;\n+                let typeFilter = parserState.typeFilter;\n                 if (typeFilter === \"const\") {\n                     typeFilter = \"constant\";\n                 }\n@@ -715,19 +719,17 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {ResultsTable}\n      */\n     function execQuery(parsedQuery, searchWords, filterCrates) {\n-        var results_others = {}, results_in_args = {}, results_returned = {};\n+        const results_others = {}, results_in_args = {}, results_returned = {};\n \n         function transformResults(results) {\n-            var duplicates = {};\n-            var out = [];\n-\n-            for (var i = 0, len = results.length; i < len; ++i) {\n-                var result = results[i];\n+            const duplicates = {};\n+            const out = [];\n \n+            for (const result of results) {\n                 if (result.id > -1) {\n-                    var obj = searchIndex[result.id];\n+                    const obj = searchIndex[result.id];\n                     obj.lev = result.lev;\n-                    var res = buildHrefAndPath(obj);\n+                    const res = buildHrefAndPath(obj);\n                     obj.displayPath = pathSplitter(res[0]);\n                     obj.fullPath = obj.displayPath + obj.name;\n                     // To be sure than it some items aren't considered as duplicate.\n@@ -749,11 +751,11 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function sortResults(results, isType) {\n-            var userQuery = parsedQuery.userQuery;\n-            var ar = [];\n-            for (var entry in results) {\n+            const userQuery = parsedQuery.userQuery;\n+            const ar = [];\n+            for (const entry in results) {\n                 if (hasOwnPropertyRustdoc(results, entry)) {\n-                    var result = results[entry];\n+                    const result = results[entry];\n                     result.word = searchWords[result.id];\n                     result.item = searchIndex[result.id] || {};\n                     ar.push(result);\n@@ -766,7 +768,7 @@ window.initSearch = function(rawSearchIndex) {\n             }\n \n             results.sort(function(aaa, bbb) {\n-                var a, b;\n+                let a, b;\n \n                 // sort by exact match with regard to the last word (mismatch goes later)\n                 a = (aaa.word !== userQuery);\n@@ -832,20 +834,18 @@ window.initSearch = function(rawSearchIndex) {\n                 return 0;\n             });\n \n-            var nameSplit = null;\n+            let nameSplit = null;\n             if (parsedQuery.elems.length === 1) {\n-                var hasPath = typeof parsedQuery.elems[0].path === \"undefined\";\n+                const hasPath = typeof parsedQuery.elems[0].path === \"undefined\";\n                 nameSplit = hasPath ? null : parsedQuery.elems[0].path;\n             }\n \n-            for (var i = 0, len = results.length; i < len; ++i) {\n-                result = results[i];\n-\n+            for (const result of results) {\n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n                     continue;\n                 }\n-                var name = result.item.name.toLowerCase(),\n+                const name = result.item.name.toLowerCase(),\n                     path = result.item.path.toLowerCase(),\n                     parent = result.item.parent;\n \n@@ -877,15 +877,14 @@ window.initSearch = function(rawSearchIndex) {\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n-            var elem_name;\n+            let elem_name;\n             if (elem.generics.length > 0 && row[GENERICS_DATA].length >= elem.generics.length) {\n-                var elems = Object.create(null);\n-                for (var x = 0, length = row[GENERICS_DATA].length; x < length; ++x) {\n-                    elem_name = row[GENERICS_DATA][x][NAME];\n+                const elems = Object.create(null);\n+                for (const entry of row[GENERICS_DATA]) {\n+                    elem_name = entry[NAME];\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(\n-                                row[GENERICS_DATA][x], elem, MAX_LEV_DISTANCE + 1) !== 0) {\n+                        if (checkGenerics(entry, elem, MAX_LEV_DISTANCE + 1) !== 0) {\n                             return MAX_LEV_DISTANCE + 1;\n                         }\n                         continue;\n@@ -897,9 +896,8 @@ window.initSearch = function(rawSearchIndex) {\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n-                for (x = 0, length = elem.generics.length; x < length; ++x) {\n-                    var generic = elem.generics[x];\n-                    var match = null;\n+                for (const generic of elem.generics) {\n+                    let match = null;\n                     if (elems[generic.name]) {\n                         match = generic.name;\n                     } else {\n@@ -936,12 +934,12 @@ window.initSearch = function(rawSearchIndex) {\n           * @return {integer} - Returns a Levenshtein distance to the best match.\n           */\n         function checkIfInGenerics(row, elem) {\n-            var lev = MAX_LEV_DISTANCE + 1;\n-            for (var x = 0, length = row[GENERICS_DATA].length; x < length && lev !== 0; ++x) {\n-                lev = Math.min(\n-                    checkType(row[GENERICS_DATA][x], elem, true),\n-                    lev\n-                );\n+            let lev = MAX_LEV_DISTANCE + 1;\n+            for (const entry of row[GENERICS_DATA]) {\n+                lev = Math.min(checkType(entry, elem, true), lev);\n+                if (lev === 0) {\n+                    break;\n+                }\n             }\n             return lev;\n         }\n@@ -966,12 +964,12 @@ window.initSearch = function(rawSearchIndex) {\n                 return MAX_LEV_DISTANCE + 1;\n             }\n \n-            var lev = levenshtein(row[NAME], elem.name);\n+            let lev = levenshtein(row[NAME], elem.name);\n             if (literalSearch) {\n                 if (lev !== 0) {\n                     // The name didn't match, let's try to check if the generics do.\n                     if (elem.generics.length === 0) {\n-                        var checkGeneric = (row.length > GENERICS_DATA &&\n+                        const checkGeneric = (row.length > GENERICS_DATA &&\n                             row[GENERICS_DATA].length > 0);\n                         if (checkGeneric && row[GENERICS_DATA].findIndex(function(tmp_elem) {\n                             return tmp_elem[NAME] === elem.name;\n@@ -1004,7 +1002,7 @@ window.initSearch = function(rawSearchIndex) {\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    var tmp_lev = checkGenerics(row, elem, lev);\n+                    const tmp_lev = checkGenerics(row, elem, lev);\n                     if (tmp_lev > MAX_LEV_DISTANCE) {\n                         return MAX_LEV_DISTANCE + 1;\n                     }\n@@ -1032,16 +1030,14 @@ window.initSearch = function(rawSearchIndex) {\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n         function findArg(row, elem, typeFilter) {\n-            var lev = MAX_LEV_DISTANCE + 1;\n+            let lev = MAX_LEV_DISTANCE + 1;\n \n             if (row && row.type && row.type[INPUTS_DATA] && row.type[INPUTS_DATA].length > 0) {\n-                var length = row.type[INPUTS_DATA].length;\n-                for (var i = 0; i < length; i++) {\n-                    var tmp = row.type[INPUTS_DATA][i];\n-                    if (!typePassesFilter(typeFilter, tmp[1])) {\n+                for (const input of row.type[INPUTS_DATA]) {\n+                    if (!typePassesFilter(typeFilter, input[1])) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(lev, checkType(input, elem, parsedQuery.literalSearch));\n                     if (lev === 0) {\n                         return 0;\n                     }\n@@ -1061,19 +1057,18 @@ window.initSearch = function(rawSearchIndex) {\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n         function checkReturned(row, elem, typeFilter) {\n-            var lev = MAX_LEV_DISTANCE + 1;\n+            let lev = MAX_LEV_DISTANCE + 1;\n \n             if (row && row.type && row.type.length > OUTPUT_DATA) {\n-                var ret = row.type[OUTPUT_DATA];\n+                let ret = row.type[OUTPUT_DATA];\n                 if (typeof ret[0] === \"string\") {\n                     ret = [ret];\n                 }\n-                for (var x = 0, len = ret.length; x < len; ++x) {\n-                    var tmp = ret[x];\n-                    if (!typePassesFilter(typeFilter, tmp[1])) {\n+                for (const ret_ty of ret) {\n+                    if (!typePassesFilter(typeFilter, ret_ty[1])) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(lev, checkType(ret_ty, elem, parsedQuery.literalSearch));\n                     if (lev === 0) {\n                         return 0;\n                     }\n@@ -1086,26 +1081,26 @@ window.initSearch = function(rawSearchIndex) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n-            var ret_lev = MAX_LEV_DISTANCE + 1;\n-            var path = ty.path.split(\"::\");\n+            let ret_lev = MAX_LEV_DISTANCE + 1;\n+            const path = ty.path.split(\"::\");\n \n             if (ty.parent && ty.parent.name) {\n                 path.push(ty.parent.name.toLowerCase());\n             }\n \n-            var length = path.length;\n-            var clength = contains.length;\n+            const length = path.length;\n+            const clength = contains.length;\n             if (clength > length) {\n                 return MAX_LEV_DISTANCE + 1;\n             }\n-            for (var i = 0; i < length; ++i) {\n+            for (let i = 0; i < length; ++i) {\n                 if (i + clength > length) {\n                     break;\n                 }\n-                var lev_total = 0;\n-                var aborted = false;\n-                for (var x = 0; x < clength; ++x) {\n-                    var lev = levenshtein(path[i + x], contains[x]);\n+                let lev_total = 0;\n+                let aborted = false;\n+                for (let x = 0; x < clength; ++x) {\n+                    const lev = levenshtein(path[i + x], contains[x]);\n                     if (lev > MAX_LEV_DISTANCE) {\n                         aborted = true;\n                         break;\n@@ -1124,7 +1119,7 @@ window.initSearch = function(rawSearchIndex) {\n             if (filter <= NO_TYPE_FILTER || filter === type) return true;\n \n             // Match related items\n-            var name = itemTypes[type];\n+            const name = itemTypes[type];\n             switch (itemTypes[filter]) {\n                 case \"constant\":\n                     return name === \"associatedconstant\";\n@@ -1154,33 +1149,31 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function handleAliases(ret, query, filterCrates) {\n-            var lowerQuery = query.toLowerCase();\n+            const lowerQuery = query.toLowerCase();\n             // We separate aliases and crate aliases because we want to have current crate\n             // aliases to be before the others in the displayed results.\n-            var aliases = [];\n-            var crateAliases = [];\n+            const aliases = [];\n+            const crateAliases = [];\n             if (filterCrates !== null) {\n                 if (ALIASES[filterCrates] && ALIASES[filterCrates][lowerQuery]) {\n-                    var query_aliases = ALIASES[filterCrates][lowerQuery];\n-                    var len = query_aliases.length;\n-                    for (var i = 0; i < len; ++i) {\n-                        aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                    const query_aliases = ALIASES[filterCrates][lowerQuery];\n+                    for (const alias of query_aliases) {\n+                        aliases.push(createAliasFromItem(searchIndex[alias]));\n                     }\n                 }\n             } else {\n                 Object.keys(ALIASES).forEach(function(crate) {\n                     if (ALIASES[crate][lowerQuery]) {\n-                        var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                        var query_aliases = ALIASES[crate][lowerQuery];\n-                        var len = query_aliases.length;\n-                        for (var i = 0; i < len; ++i) {\n-                            pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                        const pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                        const query_aliases = ALIASES[crate][lowerQuery];\n+                        for (const alias of query_aliases) {\n+                            pushTo.push(createAliasFromItem(searchIndex[alias]));\n                         }\n                     }\n                 });\n             }\n \n-            var sortFunc = function(aaa, bbb) {\n+            const sortFunc = function(aaa, bbb) {\n                 if (aaa.path < bbb.path) {\n                     return 1;\n                 } else if (aaa.path === bbb.path) {\n@@ -1191,9 +1184,9 @@ window.initSearch = function(rawSearchIndex) {\n             crateAliases.sort(sortFunc);\n             aliases.sort(sortFunc);\n \n-            var pushFunc = function(alias) {\n+            const pushFunc = function(alias) {\n                 alias.alias = query;\n-                var res = buildHrefAndPath(alias);\n+                const res = buildHrefAndPath(alias);\n                 alias.displayPath = pathSplitter(res[0]);\n                 alias.fullPath = alias.displayPath + alias.name;\n                 alias.href = res[1];\n@@ -1230,7 +1223,7 @@ window.initSearch = function(rawSearchIndex) {\n         function addIntoResults(results, fullId, id, index, lev) {\n             if (lev === 0 || (!parsedQuery.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n                 if (results[fullId] !== undefined) {\n-                    var result = results[fullId];\n+                    const result = results[fullId];\n                     if (result.dontValidate || result.lev <= lev) {\n                         return;\n                     }\n@@ -1270,19 +1263,19 @@ window.initSearch = function(rawSearchIndex) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n-            var lev, lev_add = 0, index = -1;\n-            var fullId = row.id;\n+            let lev, lev_add = 0, index = -1;\n+            const fullId = row.id;\n \n-            var in_args = findArg(row, elem, parsedQuery.typeFilter);\n-            var returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n \n             addIntoResults(results_in_args, fullId, pos, index, in_args);\n             addIntoResults(results_returned, fullId, pos, index, returned);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n             }\n-            var searchWord = searchWords[pos];\n+            const searchWord = searchWords[pos];\n \n             if (parsedQuery.literalSearch) {\n                 if (searchWord === elem.name) {\n@@ -1352,16 +1345,14 @@ window.initSearch = function(rawSearchIndex) {\n                 return;\n             }\n \n-            var totalLev = 0;\n-            var nbLev = 0;\n-            var lev;\n+            let totalLev = 0;\n+            let nbLev = 0;\n \n             // If the result is too \"bad\", we return false and it ends this search.\n             function checkArgs(elems, callback) {\n-                for (var i = 0, len = elems.length; i < len; ++i) {\n-                    var elem = elems[i];\n+                for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    lev = callback(row, elem, NO_TYPE_FILTER);\n+                    const lev = callback(row, elem, NO_TYPE_FILTER);\n                     if (lev <= 1) {\n                         nbLev += 1;\n                         totalLev += lev;\n@@ -1381,12 +1372,12 @@ window.initSearch = function(rawSearchIndex) {\n             if (nbLev === 0) {\n                 return;\n             }\n-            lev = Math.round(totalLev / nbLev);\n+            const lev = Math.round(totalLev / nbLev);\n             addIntoResults(results, row.id, pos, 0, lev);\n         }\n \n         function innerRunQuery() {\n-            var elem, i, nSearchWords, in_returned, row;\n+            let elem, i, nSearchWords, in_returned, row;\n \n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n@@ -1413,7 +1404,7 @@ window.initSearch = function(rawSearchIndex) {\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n-                var container = results_others;\n+                let container = results_others;\n                 // In the special case where only a \"returned\" information is available, we want to\n                 // put the information into the \"results_returned\" dict.\n                 if (parsedQuery.returned.length !== 0 && parsedQuery.elems.length === 0) {\n@@ -1429,7 +1420,7 @@ window.initSearch = function(rawSearchIndex) {\n             innerRunQuery();\n         }\n \n-        var ret = createQueryResults(\n+        const ret = createQueryResults(\n             sortResults(results_in_args, true),\n             sortResults(results_returned, true),\n             sortResults(results_others, false),\n@@ -1462,26 +1453,26 @@ window.initSearch = function(rawSearchIndex) {\n         if (!keys || !keys.length) {\n             return true;\n         }\n-        for (var i = 0, len = keys.length; i < len; ++i) {\n+        for (const key of keys) {\n             // each check is for validation so we negate the conditions and invalidate\n             if (!(\n                 // check for an exact name match\n-                name.indexOf(keys[i]) > -1 ||\n+                name.indexOf(key) > -1 ||\n                 // then an exact path match\n-                path.indexOf(keys[i]) > -1 ||\n+                path.indexOf(key) > -1 ||\n                 // next if there is a parent, check for exact parent match\n                 (parent !== undefined && parent.name !== undefined &&\n-                    parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n+                    parent.name.toLowerCase().indexOf(key) > -1) ||\n                 // lastly check to see if the name was a levenshtein match\n-                levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n+                levenshtein(name, key) <= MAX_LEV_DISTANCE)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n     function nextTab(direction) {\n-        var next = (searchState.currentTab + direction + 3) % searchState.focusedByTab.length;\n+        const next = (searchState.currentTab + direction + 3) % searchState.focusedByTab.length;\n         searchState.focusedByTab[searchState.currentTab] = document.activeElement;\n         printTab(next);\n         focusSearchResult();\n@@ -1490,7 +1481,7 @@ window.initSearch = function(rawSearchIndex) {\n     // Focus the first search result on the active tab, or the result that\n     // was focused last time this tab was active.\n     function focusSearchResult() {\n-        var target = searchState.focusedByTab[searchState.currentTab] ||\n+        const target = searchState.focusedByTab[searchState.currentTab] ||\n             document.querySelectorAll(\".search-results.active a\").item(0) ||\n             document.querySelectorAll(\"#titles > button\").item(searchState.currentTab);\n         if (target) {\n@@ -1499,11 +1490,11 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function buildHrefAndPath(item) {\n-        var displayPath;\n-        var href;\n-        var type = itemTypes[item.ty];\n-        var name = item.name;\n-        var path = item.path;\n+        let displayPath;\n+        let href;\n+        const type = itemTypes[item.ty];\n+        const name = item.name;\n+        let path = item.path;\n \n         if (type === \"mod\") {\n             displayPath = path + \"::\";\n@@ -1517,19 +1508,19 @@ window.initSearch = function(rawSearchIndex) {\n             displayPath = \"\";\n             href = window.rootPath + name + \"/index.html\";\n         } else if (item.parent !== undefined) {\n-            var myparent = item.parent;\n-            var anchor = \"#\" + type + \".\" + name;\n-            var parentType = itemTypes[myparent.ty];\n-            var pageType = parentType;\n-            var pageName = myparent.name;\n+            const myparent = item.parent;\n+            let anchor = \"#\" + type + \".\" + name;\n+            const parentType = itemTypes[myparent.ty];\n+            let pageType = parentType;\n+            let pageName = myparent.name;\n \n             if (parentType === \"primitive\") {\n                 displayPath = myparent.name + \"::\";\n             } else if (type === \"structfield\" && parentType === \"variant\") {\n                 // Structfields belonging to variants are special: the\n                 // final path element is the enum name.\n-                var enumNameIdx = item.path.lastIndexOf(\"::\");\n-                var enumName = item.path.substr(enumNameIdx + 2);\n+                const enumNameIdx = item.path.lastIndexOf(\"::\");\n+                const enumName = item.path.substr(enumNameIdx + 2);\n                 path = item.path.substr(0, enumNameIdx);\n                 displayPath = path + \"::\" + enumName + \"::\" + myparent.name + \"::\";\n                 anchor = \"#variant.\" + myparent.name + \".field.\" + name;\n@@ -1551,13 +1542,13 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function escape(content) {\n-        var h1 = document.createElement(\"h1\");\n+        const h1 = document.createElement(\"h1\");\n         h1.textContent = content;\n         return h1.innerHTML;\n     }\n \n     function pathSplitter(path) {\n-        var tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n+        const tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n         if (tmp.endsWith(\"<span>\")) {\n             return tmp.slice(0, tmp.length - 6);\n         }\n@@ -1571,42 +1562,42 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {boolean}     display - True if this is the active tab\n      */\n     function addTab(array, query, display) {\n-        var extraClass = \"\";\n+        let extraClass = \"\";\n         if (display === true) {\n             extraClass = \" active\";\n         }\n \n-        var output = document.createElement(\"div\");\n-        var length = 0;\n+        const output = document.createElement(\"div\");\n+        let length = 0;\n         if (array.length > 0) {\n             output.className = \"search-results \" + extraClass;\n \n             array.forEach(function(item) {\n-                var name = item.name;\n-                var type = itemTypes[item.ty];\n+                const name = item.name;\n+                const type = itemTypes[item.ty];\n \n                 length += 1;\n \n-                var extra = \"\";\n+                let extra = \"\";\n                 if (type === \"primitive\") {\n                     extra = \" <i>(primitive type)</i>\";\n                 } else if (type === \"keyword\") {\n                     extra = \" <i>(keyword)</i>\";\n                 }\n \n-                var link = document.createElement(\"a\");\n+                const link = document.createElement(\"a\");\n                 link.className = \"result-\" + type;\n                 link.href = item.href;\n \n-                var wrapper = document.createElement(\"div\");\n-                var resultName = document.createElement(\"div\");\n+                const wrapper = document.createElement(\"div\");\n+                const resultName = document.createElement(\"div\");\n                 resultName.className = \"result-name\";\n \n                 if (item.is_alias) {\n-                    var alias = document.createElement(\"span\");\n+                    const alias = document.createElement(\"span\");\n                     alias.className = \"alias\";\n \n-                    var bold = document.createElement(\"b\");\n+                    const bold = document.createElement(\"b\");\n                     bold.innerText = item.alias;\n                     alias.appendChild(bold);\n \n@@ -1621,9 +1612,9 @@ window.initSearch = function(rawSearchIndex) {\n                     item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" + name + extra + \"</span>\");\n                 wrapper.appendChild(resultName);\n \n-                var description = document.createElement(\"div\");\n+                const description = document.createElement(\"div\");\n                 description.className = \"desc\";\n-                var spanDesc = document.createElement(\"span\");\n+                const spanDesc = document.createElement(\"span\");\n                 spanDesc.insertAdjacentHTML(\"beforeend\", item.desc);\n \n                 description.appendChild(spanDesc);\n@@ -1664,15 +1655,15 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {string} filterCrates\n      */\n     function showResults(results, go_to_first, filterCrates) {\n-        var search = searchState.outputElement();\n+        const search = searchState.outputElement();\n         if (go_to_first || (results.others.length === 1\n             && getSettingValue(\"go-to-only-result\") === \"true\"\n             // By default, the search DOM element is \"empty\" (meaning it has no children not\n             // text content). Once a search has been run, it won't be empty, even if you press\n             // ESC or empty the search input (which also \"cancels\" the search).\n             && (!search.firstChild || search.firstChild.innerText !== searchState.loadingText)))\n         {\n-            var elem = document.createElement(\"a\");\n+            const elem = document.createElement(\"a\");\n             elem.href = results.others[0].href;\n             removeClass(elem, \"active\");\n             // For firefox, we need the element to be in the DOM so it can be clicked.\n@@ -1686,14 +1677,14 @@ window.initSearch = function(rawSearchIndex) {\n \n         currentResults = results.query.userQuery;\n \n-        var ret_others = addTab(results.others, results.query, true);\n-        var ret_in_args = addTab(results.in_args, results.query, false);\n-        var ret_returned = addTab(results.returned, results.query, false);\n+        const ret_others = addTab(results.others, results.query, true);\n+        const ret_in_args = addTab(results.in_args, results.query, false);\n+        const ret_returned = addTab(results.returned, results.query, false);\n \n         // Navigate to the relevant tab if the current tab is empty, like in case users search\n         // for \"-> String\". If they had selected another tab previously, they have to click on\n         // it again.\n-        var currentTab = searchState.currentTab;\n+        let currentTab = searchState.currentTab;\n         if ((currentTab === 0 && ret_others[1] === 0) ||\n                 (currentTab === 1 && ret_in_args[1] === 0) ||\n                 (currentTab === 2 && ret_returned[1] === 0)) {\n@@ -1709,18 +1700,18 @@ window.initSearch = function(rawSearchIndex) {\n         let crates = \"\";\n         if (window.ALL_CRATES.length > 1) {\n             crates = ` in <select id=\"crate-search\"><option value=\"All crates\">All crates</option>`;\n-            for (let c of window.ALL_CRATES) {\n+            for (const c of window.ALL_CRATES) {\n                 crates += `<option value=\"${c}\" ${c == filterCrates && \"selected\"}>${c}</option>`;\n             }\n             crates += `</select>`;\n         }\n \n-        var typeFilter = \"\";\n+        let typeFilter = \"\";\n         if (results.query.typeFilter !== NO_TYPE_FILTER) {\n             typeFilter = \" (type: \" + escape(itemTypes[results.query.typeFilter]) + \")\";\n         }\n \n-        var output = `<div id=\"search-settings\">` +\n+        let output = `<div id=\"search-settings\">` +\n             `<h1 class=\"search-results-title\">Results for ${escape(results.query.userQuery)}` +\n             `${typeFilter}</h1> in ${crates} </div>`;\n         if (results.query.error !== null) {\n@@ -1732,22 +1723,22 @@ window.initSearch = function(rawSearchIndex) {\n             makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n             \"</div>\";\n \n-        var resultsElem = document.createElement(\"div\");\n+        const resultsElem = document.createElement(\"div\");\n         resultsElem.id = \"results\";\n         resultsElem.appendChild(ret_others[0]);\n         resultsElem.appendChild(ret_in_args[0]);\n         resultsElem.appendChild(ret_returned[0]);\n \n         search.innerHTML = output;\n-        let crateSearch = document.getElementById(\"crate-search\");\n+        const crateSearch = document.getElementById(\"crate-search\");\n         if (crateSearch) {\n             crateSearch.addEventListener(\"input\", updateCrate);\n         }\n         search.appendChild(resultsElem);\n         // Reset focused elements.\n         searchState.focusedByTab = [null, null, null];\n         searchState.showResults(search);\n-        var elems = document.getElementById(\"titles\").childNodes;\n+        const elems = document.getElementById(\"titles\").childNodes;\n         elems[0].onclick = function() { printTab(0); };\n         elems[1].onclick = function() { printTab(1); };\n         elems[2].onclick = function() { printTab(2); };\n@@ -1761,8 +1752,8 @@ window.initSearch = function(rawSearchIndex) {\n      * @param {boolean} [forced]\n      */\n     function search(e, forced) {\n-        var params = searchState.getQueryStringParams();\n-        var query = parseQuery(searchState.input.value.trim());\n+        const params = searchState.getQueryStringParams();\n+        const query = parseQuery(searchState.input.value.trim());\n \n         if (e) {\n             e.preventDefault();\n@@ -1775,7 +1766,7 @@ window.initSearch = function(rawSearchIndex) {\n             return;\n         }\n \n-        var filterCrates = getFilterCrates();\n+        let filterCrates = getFilterCrates();\n \n         // In case we have no information about the saved crate and there is a URL query parameter,\n         // we override it with the URL query parameter.\n@@ -1789,7 +1780,7 @@ window.initSearch = function(rawSearchIndex) {\n         // Because searching is incremental by character, only the most\n         // recent search query is added to the browser history.\n         if (searchState.browserSupportsHistoryApi()) {\n-            var newURL = buildUrl(query.original, filterCrates);\n+            const newURL = buildUrl(query.original, filterCrates);\n             if (!history.state && !params.search) {\n                 history.pushState(null, \"\", newURL);\n             } else {\n@@ -1808,17 +1799,17 @@ window.initSearch = function(rawSearchIndex) {\n         /**\n          * @type {Array<string>}\n          */\n-        var searchWords = [];\n-        var i, word;\n-        var currentIndex = 0;\n-        var id = 0;\n+        const searchWords = [];\n+        let i, word;\n+        let currentIndex = 0;\n+        let id = 0;\n \n-        for (var crate in rawSearchIndex) {\n+        for (const crate in rawSearchIndex) {\n             if (!hasOwnPropertyRustdoc(rawSearchIndex, crate)) {\n                 continue;\n             }\n \n-            var crateSize = 0;\n+            let crateSize = 0;\n \n             /**\n              * The raw search data for a given crate. `n`, `t`, `d`, and `q`, `i`, and `f`\n@@ -1850,13 +1841,13 @@ window.initSearch = function(rawSearchIndex) {\n              *   p: Array<Object>,\n              * }}\n              */\n-            var crateCorpus = rawSearchIndex[crate];\n+            const crateCorpus = rawSearchIndex[crate];\n \n             searchWords.push(crate);\n             // This object should have exactly the same set of fields as the \"row\"\n             // object defined below. Your JavaScript runtime will thank you.\n             // https://mathiasbynens.be/notes/shapes-ics\n-            var crateRow = {\n+            const crateRow = {\n                 crate: crate,\n                 ty: 1, // == ExternCrate\n                 name: crate,\n@@ -1872,26 +1863,26 @@ window.initSearch = function(rawSearchIndex) {\n             currentIndex += 1;\n \n             // an array of (Number) item types\n-            var itemTypes = crateCorpus.t;\n+            const itemTypes = crateCorpus.t;\n             // an array of (String) item names\n-            var itemNames = crateCorpus.n;\n+            const itemNames = crateCorpus.n;\n             // an array of (String) full paths (or empty string for previous path)\n-            var itemPaths = crateCorpus.q;\n+            const itemPaths = crateCorpus.q;\n             // an array of (String) descriptions\n-            var itemDescs = crateCorpus.d;\n+            const itemDescs = crateCorpus.d;\n             // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n-            var itemParentIdxs = crateCorpus.i;\n+            const itemParentIdxs = crateCorpus.i;\n             // an array of (Object | null) the type of the function, if any\n-            var itemFunctionSearchTypes = crateCorpus.f;\n+            const itemFunctionSearchTypes = crateCorpus.f;\n             // an array of [(Number) item type,\n             //              (String) name]\n-            var paths = crateCorpus.p;\n+            const paths = crateCorpus.p;\n             // an array of [(String) alias name\n             //             [Number] index to items]\n-            var aliases = crateCorpus.a;\n+            const aliases = crateCorpus.a;\n \n             // convert `rawPaths` entries into object form\n-            var len = paths.length;\n+            let len = paths.length;\n             for (i = 0; i < len; ++i) {\n                 paths[i] = {ty: paths[i][0], name: paths[i][1]};\n             }\n@@ -1904,7 +1895,7 @@ window.initSearch = function(rawSearchIndex) {\n             // all other search operations have access to this cached data for\n             // faster analysis operations\n             len = itemTypes.length;\n-            var lastPath = \"\";\n+            let lastPath = \"\";\n             for (i = 0; i < len; ++i) {\n                 // This object should have exactly the same set of fields as the \"crateRow\"\n                 // object defined above.\n@@ -1915,7 +1906,7 @@ window.initSearch = function(rawSearchIndex) {\n                     word = \"\";\n                     searchWords.push(\"\");\n                 }\n-                var row = {\n+                const row = {\n                     crate: crate,\n                     ty: itemTypes[i],\n                     name: itemNames[i],\n@@ -1934,18 +1925,16 @@ window.initSearch = function(rawSearchIndex) {\n \n             if (aliases) {\n                 ALIASES[crate] = {};\n-                var j, local_aliases;\n-                for (var alias_name in aliases) {\n+                for (const alias_name in aliases) {\n                     if (!hasOwnPropertyRustdoc(aliases, alias_name)) {\n                         continue;\n                     }\n \n                     if (!hasOwnPropertyRustdoc(ALIASES[crate], alias_name)) {\n                         ALIASES[crate][alias_name] = [];\n                     }\n-                    local_aliases = aliases[alias_name];\n-                    for (j = 0, len = local_aliases.length; j < len; ++j) {\n-                        ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n+                    for (const local_alias of aliases[alias_name]) {\n+                        ALIASES[crate][alias_name].push(local_alias + currentIndex);\n                     }\n                 }\n             }\n@@ -1965,11 +1954,11 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function putBackSearch() {\n-        var search_input = searchState.input;\n+        const search_input = searchState.input;\n         if (!searchState.input) {\n             return;\n         }\n-        var search = searchState.outputElement();\n+        const search = searchState.outputElement();\n         if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n             searchState.showResults(search);\n             if (searchState.browserSupportsHistoryApi()) {\n@@ -1981,7 +1970,7 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     function registerSearchEvents() {\n-        var searchAfter500ms = function() {\n+        const searchAfter500ms = function() {\n             searchState.clearInputTimeout();\n             if (searchState.input.value.length === 0) {\n                 if (searchState.browserSupportsHistoryApi()) {\n@@ -2019,19 +2008,19 @@ window.initSearch = function(rawSearchIndex) {\n             // up and down arrow select next/previous search result, or the\n             // search box if we're already at the top.\n             if (e.which === 38) { // up\n-                var previous = document.activeElement.previousElementSibling;\n+                const previous = document.activeElement.previousElementSibling;\n                 if (previous) {\n                     previous.focus();\n                 } else {\n                     searchState.focus();\n                 }\n                 e.preventDefault();\n             } else if (e.which === 40) { // down\n-                var next = document.activeElement.nextElementSibling;\n+                const next = document.activeElement.nextElementSibling;\n                 if (next) {\n                     next.focus();\n                 }\n-                var rect = document.activeElement.getBoundingClientRect();\n+                const rect = document.activeElement.getBoundingClientRect();\n                 if (window.innerHeight - rect.bottom < rect.height) {\n                     window.scrollBy(0, rect.height);\n                 }\n@@ -2064,10 +2053,10 @@ window.initSearch = function(rawSearchIndex) {\n         // history.\n         if (searchState.browserSupportsHistoryApi()) {\n             // Store the previous <title> so we can revert back to it later.\n-            var previousTitle = document.title;\n+            const previousTitle = document.title;\n \n             window.addEventListener(\"popstate\", function(e) {\n-                var params = searchState.getQueryStringParams();\n+                const params = searchState.getQueryStringParams();\n                 // Revert to the previous title manually since the History\n                 // API ignores the title parameter.\n                 document.title = previousTitle;\n@@ -2103,7 +2092,7 @@ window.initSearch = function(rawSearchIndex) {\n         // that try to sync state between the URL and the search input. To work around it,\n         // do a small amount of re-init on page show.\n         window.onpageshow = function(){\n-            var qSearch = searchState.getQueryStringParams().search;\n+            const qSearch = searchState.getQueryStringParams().search;\n             if (searchState.input.value === \"\" && qSearch) {\n                 searchState.input.value = qSearch;\n             }\n@@ -2114,8 +2103,8 @@ window.initSearch = function(rawSearchIndex) {\n     function updateCrate(ev) {\n         if (ev.target.value === \"All crates\") {\n             // If we don't remove it from the URL, it'll be picked up again by the search.\n-            var params = searchState.getQueryStringParams();\n-            var query = searchState.input.value.trim();\n+            const params = searchState.getQueryStringParams();\n+            const query = searchState.input.value.trim();\n             if (!history.state && !params.search) {\n                 history.pushState(null, \"\", buildUrl(query, null));\n             } else {"}, {"sha": "549d56450d8032698a50b582bc0373c3047494c0", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -1,4 +1,7 @@\n // Local js definitions:\n+/* eslint-env es6 */\n+/* eslint no-var: \"error\" */\n+/* eslint prefer-const: \"error\" */\n /* global getSettingValue, getVirtualKey, onEachLazy, updateLocalStorage, updateSystemTheme */\n /* global addClass, removeClass */\n \n@@ -55,9 +58,9 @@\n     function setEvents() {\n         updateLightAndDark();\n         onEachLazy(document.getElementsByClassName(\"slider\"), function(elem) {\n-            var toggle = elem.previousElementSibling;\n-            var settingId = toggle.id;\n-            var settingValue = getSettingValue(settingId);\n+            const toggle = elem.previousElementSibling;\n+            const settingId = toggle.id;\n+            const settingValue = getSettingValue(settingId);\n             if (settingValue !== null) {\n                 toggle.checked = settingValue === \"true\";\n             }\n@@ -68,9 +71,9 @@\n             toggle.onkeyrelease = handleKey;\n         });\n         onEachLazy(document.getElementsByClassName(\"select-wrapper\"), function(elem) {\n-            var select = elem.getElementsByTagName(\"select\")[0];\n-            var settingId = select.id;\n-            var settingValue = getSettingValue(settingId);\n+            const select = elem.getElementsByTagName(\"select\")[0];\n+            const settingId = select.id;\n+            const settingValue = getSettingValue(settingId);\n             if (settingValue !== null) {\n                 select.value = settingValue;\n             }"}, {"sha": "5bf44f949fdf666a4e346a1a046c062a48cceaf0", "filename": "src/test/assembly/nvptx-kernel-abi/nvptx-kernel-args-abi-v7.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fassembly%2Fnvptx-kernel-abi%2Fnvptx-kernel-args-abi-v7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fassembly%2Fnvptx-kernel-abi%2Fnvptx-kernel-args-abi-v7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fnvptx-kernel-abi%2Fnvptx-kernel-args-abi-v7.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -0,0 +1,254 @@\n+// assembly-output: ptx-linker\n+// compile-flags: --crate-type cdylib -C target-cpu=sm_86\n+// only-nvptx64\n+// ignore-nvptx64\n+\n+// The following ABI tests are made with nvcc 11.6 does.\n+//\n+// The PTX ABI stability is tied to major versions of the PTX ISA\n+// These tests assume major version 7\n+//\n+//\n+// The following correspondence between types are assumed:\n+// u<N> - uint<N>_t\n+// i<N> - int<N>_t\n+// [T, N] - std::array<T, N>\n+// &T - T const*\n+// &mut T - T*\n+\n+// CHECK: .version 7\n+\n+#![feature(abi_ptx, lang_items, no_core)]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+#[repr(C)]\n+pub struct SingleU8 {\n+    f: u8,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleU8 {\n+    f: u8,\n+    g: u8,\n+}\n+\n+#[repr(C)]\n+pub struct TripleU8 {\n+    f: u8,\n+    g: u8,\n+    h: u8,\n+}\n+\n+#[repr(C)]\n+pub struct TripleU16 {\n+    f: u16,\n+    g: u16,\n+    h: u16,\n+}\n+#[repr(C)]\n+pub struct TripleU32 {\n+    f: u32,\n+    g: u32,\n+    h: u32,\n+}\n+#[repr(C)]\n+pub struct TripleU64 {\n+    f: u64,\n+    g: u64,\n+    h: u64,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleFloat {\n+    f: f32,\n+    g: f32,\n+}\n+\n+#[repr(C)]\n+pub struct TripleFloat {\n+    f: f32,\n+    g: f32,\n+    h: f32,\n+}\n+\n+#[repr(C)]\n+pub struct TripleDouble {\n+    f: f64,\n+    g: f64,\n+    h: f64,\n+}\n+\n+#[repr(C)]\n+pub struct ManyIntegers {\n+    f: u8,\n+    g: u16,\n+    h: u32,\n+    i: u64,\n+}\n+\n+#[repr(C)]\n+pub struct ManyNumerics {\n+    f: u8,\n+    g: u16,\n+    h: u32,\n+    i: u64,\n+    j: f32,\n+    k: f64,\n+}\n+\n+// CHECK: .visible .entry f_u8_arg(\n+// CHECK: .param .u8 f_u8_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u8_arg(_a: u8) {}\n+\n+// CHECK: .visible .entry f_u16_arg(\n+// CHECK: .param .u16 f_u16_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u16_arg(_a: u16) {}\n+\n+// CHECK: .visible .entry f_u32_arg(\n+// CHECK: .param .u32 f_u32_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u32_arg(_a: u32) {}\n+\n+// CHECK: .visible .entry f_u64_arg(\n+// CHECK: .param .u64 f_u64_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u64_arg(_a: u64) {}\n+\n+// CHECK: .visible .entry f_u128_arg(\n+// CHECK: .param .align 16 .b8 f_u128_arg_param_0[16]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u128_arg(_a: u128) {}\n+\n+// CHECK: .visible .entry f_i8_arg(\n+// CHECK: .param .u8 f_i8_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i8_arg(_a: i8) {}\n+\n+// CHECK: .visible .entry f_i16_arg(\n+// CHECK: .param .u16 f_i16_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i16_arg(_a: i16) {}\n+\n+// CHECK: .visible .entry f_i32_arg(\n+// CHECK: .param .u32 f_i32_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i32_arg(_a: i32) {}\n+\n+// CHECK: .visible .entry f_i64_arg(\n+// CHECK: .param .u64 f_i64_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i64_arg(_a: i64) {}\n+\n+// CHECK: .visible .entry f_i128_arg(\n+// CHECK: .param .align 16 .b8 f_i128_arg_param_0[16]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i128_arg(_a: i128) {}\n+\n+// CHECK: .visible .entry f_f32_arg(\n+// CHECK: .param .f32 f_f32_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_f32_arg(_a: f32) {}\n+\n+// CHECK: .visible .entry f_f64_arg(\n+// CHECK: .param .f64 f_f64_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_f64_arg(_a: f64) {}\n+\n+// CHECK: .visible .entry f_single_u8_arg(\n+// CHECK: .param .align 1 .b8 f_single_u8_arg_param_0[1]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_single_u8_arg(_a: SingleU8) {}\n+\n+// CHECK: .visible .entry f_double_u8_arg(\n+// CHECK: .param .align 1 .b8 f_double_u8_arg_param_0[2]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_double_u8_arg(_a: DoubleU8) {}\n+\n+// CHECK: .visible .entry f_triple_u8_arg(\n+// CHECK: .param .align 1 .b8 f_triple_u8_arg_param_0[3]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u8_arg(_a: TripleU8) {}\n+\n+// CHECK: .visible .entry f_triple_u16_arg(\n+// CHECK: .param .align 2 .b8 f_triple_u16_arg_param_0[6]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u16_arg(_a: TripleU16) {}\n+\n+// CHECK: .visible .entry f_triple_u32_arg(\n+// CHECK: .param .align 4 .b8 f_triple_u32_arg_param_0[12]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u32_arg(_a: TripleU32) {}\n+\n+// CHECK: .visible .entry f_triple_u64_arg(\n+// CHECK: .param .align 8 .b8 f_triple_u64_arg_param_0[24]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u64_arg(_a: TripleU64) {}\n+\n+// CHECK: .visible .entry f_many_integers_arg(\n+// CHECK: .param .align 8 .b8 f_many_integers_arg_param_0[16]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_many_integers_arg(_a: ManyIntegers) {}\n+\n+// CHECK: .visible .entry f_double_float_arg(\n+// CHECK: .param .align 4 .b8 f_double_float_arg_param_0[8]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_double_float_arg(_a: DoubleFloat) {}\n+\n+// CHECK: .visible .entry f_triple_float_arg(\n+// CHECK: .param .align 4 .b8 f_triple_float_arg_param_0[12]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_float_arg(_a: TripleFloat) {}\n+\n+// CHECK: .visible .entry f_triple_double_arg(\n+// CHECK: .param .align 8 .b8 f_triple_double_arg_param_0[24]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_double_arg(_a: TripleDouble) {}\n+\n+// CHECK: .visible .entry f_many_numerics_arg(\n+// CHECK: .param .align 8 .b8 f_many_numerics_arg_param_0[32]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_many_numerics_arg(_a: ManyNumerics) {}\n+\n+// CHECK: .visible .entry f_byte_array_arg(\n+// CHECK: .param .align 1 .b8 f_byte_array_arg_param_0[5]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_byte_array_arg(_a: [u8; 5]) {}\n+\n+// CHECK: .visible .entry f_float_array_arg(\n+// CHECK: .param .align 4 .b8 f_float_array_arg_param_0[20]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_float_array_arg(_a: [f32; 5]) {}\n+\n+// CHECK: .visible .entry f_u128_array_arg(\n+// CHECK: .param .align 16 .b8 f_u128_array_arg_param_0[80]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u128_array_arg(_a: [u128; 5]) {}\n+\n+// CHECK: .visible .entry f_u32_slice_arg(\n+// CHECK: .param .u64 f_u32_slice_arg_param_0\n+// CHECK: .param .u64 f_u32_slice_arg_param_1\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u32_slice_arg(_a: &[u32]) {}\n+\n+// CHECK: .visible .entry f_tuple_u8_u8_arg(\n+// CHECK: .param .align 1 .b8 f_tuple_u8_u8_arg_param_0[2]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_tuple_u8_u8_arg(_a: (u8, u8)) {}\n+\n+// CHECK: .visible .entry f_tuple_u32_u32_arg(\n+// CHECK: .param .align 4 .b8 f_tuple_u32_u32_arg_param_0[8]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_tuple_u32_u32_arg(_a: (u32, u32)) {}\n+\n+\n+// CHECK: .visible .entry f_tuple_u8_u8_u32_arg(\n+// CHECK: .param .align 4 .b8 f_tuple_u8_u8_u32_arg_param_0[8]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_tuple_u8_u8_u32_arg(_a: (u8, u8, u32)) {}"}, {"sha": "7157b186fc8ad591967e48e829b074c9ebe3ec3b", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -18,6 +18,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let filter = map.stream.filterx(|x: &_| true);\n+   |                      +++++++\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:140:24\n@@ -39,6 +43,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let count = filter.stream.countx();\n+   |                        +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7157b186fc8ad591967e48e829b074c9ebe3ec3b", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -18,6 +18,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let filter = map.stream.filterx(|x: &_| true);\n+   |                      +++++++\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:140:24\n@@ -39,6 +43,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let count = filter.stream.countx();\n+   |                        +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "980000151e2f7f4ea468ef17e246a7523e998539", "filename": "src/test/ui/suggestions/field-has-method.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.rs?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -0,0 +1,23 @@\n+struct Kind;\n+\n+struct Ty {\n+    kind: Kind,\n+}\n+\n+impl Ty {\n+    fn kind(&self) -> Kind {\n+        todo!()\n+    }\n+}\n+\n+struct InferOk<T> {\n+    value: T,\n+    predicates: Vec<()>,\n+}\n+\n+fn foo(i: InferOk<Ty>) {\n+    let k = i.kind();\n+    //~^ no method named `kind` found for struct `InferOk` in the current scope\n+}\n+\n+fn main() {}"}, {"sha": "3a57436f200bab227bda5dc95b008c46cdcf70b5", "filename": "src/test/ui/suggestions/field-has-method.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.stderr?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -0,0 +1,17 @@\n+error[E0599]: no method named `kind` found for struct `InferOk` in the current scope\n+  --> $DIR/field-has-method.rs:19:15\n+   |\n+LL | struct InferOk<T> {\n+   | ----------------- method `kind` not found for this\n+...\n+LL |     let k = i.kind();\n+   |               ^^^^ method not found in `InferOk<Ty>`\n+   |\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let k = i.value.kind();\n+   |               ++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "98d0f5dc656c17ac0cd4359630e5aba742d9b121", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/082e4ca49770ebc9cb0ee616f3726a67471be8cb/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=082e4ca49770ebc9cb0ee616f3726a67471be8cb", "patch": "@@ -85,8 +85,11 @@ function extractFunction(content, functionName) {\n }\n \n // Stupid function extractor for array.\n-function extractArrayVariable(content, arrayName) {\n-    var splitter = \"var \" + arrayName;\n+function extractArrayVariable(content, arrayName, kind) {\n+    if (typeof kind === \"undefined\") {\n+        kind = \"let \";\n+    }\n+    var splitter = kind + arrayName;\n     while (true) {\n         var start = content.indexOf(splitter);\n         if (start === -1) {\n@@ -126,12 +129,18 @@ function extractArrayVariable(content, arrayName) {\n         }\n         content = content.slice(start + 1);\n     }\n+    if (kind === \"let \") {\n+        return extractArrayVariable(content, arrayName, \"const \");\n+    }\n     return null;\n }\n \n // Stupid function extractor for variable.\n-function extractVariable(content, varName) {\n-    var splitter = \"var \" + varName;\n+function extractVariable(content, varName, kind) {\n+    if (typeof kind === \"undefined\") {\n+        kind = \"let \";\n+    }\n+    var splitter = kind + varName;\n     while (true) {\n         var start = content.indexOf(splitter);\n         if (start === -1) {\n@@ -162,6 +171,9 @@ function extractVariable(content, varName) {\n         }\n         content = content.slice(start + 1);\n     }\n+    if (kind === \"let \") {\n+        return extractVariable(content, varName, \"const \");\n+    }\n     return null;\n }\n "}]}