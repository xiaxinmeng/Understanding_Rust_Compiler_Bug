{"sha": "09180d71fd382c8d0471ff342147d91def3a1595", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MTgwZDcxZmQzODJjOGQwNDcxZmYzNDIxNDdkOTFkZWYzYTE1OTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-16T12:31:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-16T12:31:09Z"}, "message": "make simd_size return a u64", "tree": {"sha": "545e49b62c798e7efbf08966e70d7bdfdeee552e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/545e49b62c798e7efbf08966e70d7bdfdeee552e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09180d71fd382c8d0471ff342147d91def3a1595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09180d71fd382c8d0471ff342147d91def3a1595", "html_url": "https://github.com/rust-lang/rust/commit/09180d71fd382c8d0471ff342147d91def3a1595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09180d71fd382c8d0471ff342147d91def3a1595/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44b68116c522ad8870f0a8627550ba1f5c8fc797", "url": "https://api.github.com/repos/rust-lang/rust/commits/44b68116c522ad8870f0a8627550ba1f5c8fc797", "html_url": "https://github.com/rust-lang/rust/commit/44b68116c522ad8870f0a8627550ba1f5c8fc797"}], "stats": {"total": 35, "additions": 19, "deletions": 16}, "files": [{"sha": "b9fc5f59b7bbc554f4813ad5ff39660d037e723c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=09180d71fd382c8d0471ff342147d91def3a1595", "patch": "@@ -697,7 +697,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             // SIMD vector types.\n             ty::Adt(def, ..) if def.repr.simd() => {\n                 let element = self.layout_of(ty.simd_type(tcx))?;\n-                let count = ty.simd_size(tcx) as u64;\n+                let count = ty.simd_size(tcx);\n                 assert!(count > 0);\n                 let scalar = match element.abi {\n                     Abi::Scalar(ref scalar) => scalar.clone(),"}, {"sha": "b7e645d55a5fcebbdd5970ca1d3efe1779f9e4fe", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=09180d71fd382c8d0471ff342147d91def3a1595", "patch": "@@ -1819,20 +1819,20 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn simd_size(&self, _tcx: TyCtxt<'tcx>) -> usize {\n+    pub fn simd_size(&self, _tcx: TyCtxt<'tcx>) -> u64 {\n         // Parameter currently unused, but probably needed in the future to\n         // allow `#[repr(simd)] struct Simd<T, const N: usize>([T; N]);`.\n         match self.kind {\n-            Adt(def, _) => def.non_enum_variant().fields.len(),\n+            Adt(def, _) => def.non_enum_variant().fields.len() as u64,\n             _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n \n-    pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (usize, Ty<'tcx>) {\n+    pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind {\n             Adt(def, substs) => {\n                 let variant = def.non_enum_variant();\n-                (variant.fields.len(), variant.fields[0].ty(tcx, substs))\n+                (variant.fields.len() as u64, variant.fields[0].ty(tcx, substs))\n             }\n             _ => bug!(\"simd_size_and_type called on invalid type\")\n         }"}, {"sha": "fb5f457bb3a1ceaf73e852fa2e308983732ba6bc", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=09180d71fd382c8d0471ff342147d91def3a1595", "patch": "@@ -28,6 +28,7 @@ use syntax_pos::Span;\n \n use std::cmp::Ordering;\n use std::{iter, i128, u128};\n+use std::convert::TryFrom;\n \n fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     let llvm_name = match name {\n@@ -1105,8 +1106,8 @@ fn generic_simd_intrinsic(\n         let m_len = match in_ty.kind {\n             // Note that this `.unwrap()` crashes for isize/usize, that's sort\n             // of intentional as there's not currently a use case for that.\n-            ty::Int(i) => i.bit_width().unwrap(),\n-            ty::Uint(i) => i.bit_width().unwrap(),\n+            ty::Int(i) => i.bit_width().unwrap() as u64,\n+            ty::Uint(i) => i.bit_width().unwrap() as u64,\n             _ => return_error!(\"`{}` is not an integral type\", in_ty),\n         };\n         require_simd!(arg_tys[1], \"argument\");\n@@ -1116,7 +1117,7 @@ fn generic_simd_intrinsic(\n                  m_len, v_len\n         );\n         let i1 = bx.type_i1();\n-        let i1xn = bx.type_vector(i1, m_len as u64);\n+        let i1xn = bx.type_vector(i1, m_len);\n         let m_i1s = bx.bitcast(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1166,7 +1167,7 @@ fn generic_simd_intrinsic(\n         require_simd!(ret_ty, \"return\");\n \n         let out_len = ret_ty.simd_size(tcx);\n-        require!(out_len == n,\n+        require!(out_len == n as u64,\n                  \"expected return type of length {}, found `{}` with length {}\",\n                  n, ret_ty, out_len);\n         require!(in_elem == ret_ty.simd_type(tcx),\n@@ -1251,7 +1252,7 @@ fn generic_simd_intrinsic(\n         // trailing bits.\n         let expected_int_bits = in_len.max(8);\n         match ret_ty.kind {\n-           ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n+           ty::Uint(i) if i.bit_width() == Some(expected_int_bits as usize) => (),\n             _ => return_error!(\n                 \"bitmask `{}`, expected `u{}`\",\n                 ret_ty, expected_int_bits\n@@ -1276,7 +1277,8 @@ fn generic_simd_intrinsic(\n \n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n         let shift_indices = vec![\n-            bx.cx.const_int(bx.type_ix(in_elem_bitwidth as _), (in_elem_bitwidth - 1) as _); in_len\n+            bx.cx.const_int(bx.type_ix(in_elem_bitwidth as _), (in_elem_bitwidth - 1) as _);\n+            in_len as _\n         ];\n         let i_xn_msb = bx.lshr(i_xn, bx.const_vector(shift_indices.as_slice()));\n         // Truncate vector to an <i1 x N>\n@@ -1291,7 +1293,7 @@ fn generic_simd_intrinsic(\n         name: &str,\n         in_elem: &::rustc::ty::TyS<'_>,\n         in_ty: &::rustc::ty::TyS<'_>,\n-        in_len: usize,\n+        in_len: u64,\n         bx: &mut Builder<'a, 'll, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, &'ll Value>],\n@@ -1506,11 +1508,12 @@ fn generic_simd_intrinsic(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = bx.type_i1();\n-            let i1xn = bx.type_vector(i1, in_len as u64);\n+            let i1xn = bx.type_vector(i1, in_len);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n         // Type of the vector of pointers:\n+        let in_len = usize::try_from(in_len).unwrap();\n         let llvm_pointer_vec_ty = llvm_vector_ty(bx, underlying_ty, in_len, pointer_count);\n         let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n \n@@ -1606,13 +1609,14 @@ fn generic_simd_intrinsic(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = bx.type_i1();\n-            let i1xn = bx.type_vector(i1, in_len as u64);\n+            let i1xn = bx.type_vector(i1, in_len);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n         let ret_t = bx.type_void();\n \n         // Type of the vector of pointers:\n+        let in_len = usize::try_from(in_len).unwrap();\n         let llvm_pointer_vec_ty = llvm_vector_ty(bx, underlying_ty, in_len, pointer_count);\n         let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n "}, {"sha": "23f7b1acb54d470f73c08386288aeca37538f675", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09180d71fd382c8d0471ff342147d91def3a1595/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=09180d71fd382c8d0471ff342147d91def3a1595", "patch": "@@ -306,7 +306,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = args[2];\n                 let input = args[0];\n                 let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx.tcx);\n-                let len = len as u64;\n                 assert!(\n                     index < len,\n                     \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n@@ -337,7 +336,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n                 assert!(\n-                    index < len as u64,\n+                    index < len,\n                     \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\",\n                     index, e_ty, len\n                 );"}]}