{"sha": "8ad7e5481f970ba8d1103b4cc20a71335aba466e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZDdlNTQ4MWY5NzBiYThkMTEwM2I0Y2MyMGE3MTMzNWFiYTQ2NmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-27T22:10:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-31T22:17:12Z"}, "message": "collections: Switch field privacy as necessary", "tree": {"sha": "1e14a9ea1add5a619f6ba64398627a27e68e36e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e14a9ea1add5a619f6ba64398627a27e68e36e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ad7e5481f970ba8d1103b4cc20a71335aba466e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad7e5481f970ba8d1103b4cc20a71335aba466e", "html_url": "https://github.com/rust-lang/rust/commit/8ad7e5481f970ba8d1103b4cc20a71335aba466e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ad7e5481f970ba8d1103b4cc20a71335aba466e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a3d04ae7629f6f273643b3a14f106726842be6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a3d04ae7629f6f273643b3a14f106726842be6a", "html_url": "https://github.com/rust-lang/rust/commit/9a3d04ae7629f6f273643b3a14f106726842be6a"}], "stats": {"total": 222, "additions": 112, "deletions": 110}, "files": [{"sha": "510e8908427c010a443fa0476d97c3edcc426d76", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -227,9 +227,9 @@ enum Op {Union, Intersect, Assign, Difference}\n #[deriving(Clone)]\n pub struct Bitv {\n     /// Internal representation of the bit vector (small or large)\n-    priv rep: BitvVariant,\n+    rep: BitvVariant,\n     /// The number of valid bits in the internal representation\n-    priv nbits: uint\n+    nbits: uint\n }\n \n fn die() -> ! {\n@@ -587,9 +587,9 @@ fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n \n /// An iterator for `Bitv`.\n pub struct Bits<'a> {\n-    priv bitv: &'a Bitv,\n-    priv next_idx: uint,\n-    priv end_idx: uint,\n+    bitv: &'a Bitv,\n+    next_idx: uint,\n+    end_idx: uint,\n }\n \n impl<'a> Iterator<bool> for Bits<'a> {\n@@ -648,12 +648,12 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// as a `uint`.\n #[deriving(Clone)]\n pub struct BitvSet {\n-    priv size: uint,\n+    size: uint,\n \n     // In theory this is a `Bitv` instead of always a `BigBitv`, but knowing that\n     // there's an array of storage makes our lives a whole lot easier when\n     // performing union/intersection/etc operations\n-    priv bitv: BigBitv\n+    bitv: BigBitv\n }\n \n impl BitvSet {\n@@ -912,8 +912,8 @@ impl BitvSet {\n }\n \n pub struct BitPositions<'a> {\n-    priv set: &'a BitvSet,\n-    priv next_idx: uint\n+    set: &'a BitvSet,\n+    next_idx: uint\n }\n \n impl<'a> Iterator<uint> for BitPositions<'a> {"}, {"sha": "b516997b81e77aefa15359d3c03d6a05ba740243", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -23,10 +23,10 @@ use std::fmt::Show;\n \n #[allow(missing_doc)]\n pub struct BTree<K, V> {\n-    priv root: Node<K, V>,\n-    priv len: uint,\n-    priv lower_bound: uint,\n-    priv upper_bound: uint\n+    root: Node<K, V>,\n+    len: uint,\n+    lower_bound: uint,\n+    upper_bound: uint\n }\n \n impl<K: TotalOrd, V> BTree<K, V> {"}, {"sha": "1c3a01a355d3cbb7461d96ce326ede071bd7c6bc", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -32,9 +32,9 @@ use deque::Deque;\n \n /// A doubly-linked list.\n pub struct DList<T> {\n-    priv length: uint,\n-    priv list_head: Link<T>,\n-    priv list_tail: Rawlink<Node<T>>,\n+    length: uint,\n+    list_head: Link<T>,\n+    list_tail: Rawlink<Node<T>>,\n }\n \n type Link<T> = Option<~Node<T>>;\n@@ -48,9 +48,9 @@ struct Node<T> {\n \n /// Double-ended DList iterator\n pub struct Items<'a, T> {\n-    priv head: &'a Link<T>,\n-    priv tail: Rawlink<Node<T>>,\n-    priv nelem: uint,\n+    head: &'a Link<T>,\n+    tail: Rawlink<Node<T>>,\n+    nelem: uint,\n }\n \n // FIXME #11820: the &'a Option<> of the Link stops clone working.\n@@ -60,16 +60,16 @@ impl<'a, T> Clone for Items<'a, T> {\n \n /// Double-ended mutable DList iterator\n pub struct MutItems<'a, T> {\n-    priv list: &'a mut DList<T>,\n-    priv head: Rawlink<Node<T>>,\n-    priv tail: Rawlink<Node<T>>,\n-    priv nelem: uint,\n+    list: &'a mut DList<T>,\n+    head: Rawlink<Node<T>>,\n+    tail: Rawlink<Node<T>>,\n+    nelem: uint,\n }\n \n /// DList consuming iterator\n #[deriving(Clone)]\n pub struct MoveItems<T> {\n-    priv list: DList<T>\n+    list: DList<T>\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer"}, {"sha": "83ba09ac68b6ce6c0e13b2ffed47a3af20950ad2", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -20,7 +20,7 @@ use std::num::Bitwise;\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n-    priv bits: uint\n+    bits: uint\n }\n \n /// An interface for casting C-like enum to uint and back.\n@@ -102,8 +102,8 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n \n /// An iterator over an EnumSet\n pub struct Items<E> {\n-    priv index: uint,\n-    priv bits: uint,\n+    index: uint,\n+    bits: uint,\n }\n \n impl<E:CLike> Items<E> {"}, {"sha": "47100559f44983b8339abb089b582a73f419b979", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -100,25 +100,25 @@ mod table {\n     /// this and going \"what? of course there are debug-only asserts!\", then\n     /// please make this use them!\n     pub struct RawTable<K, V> {\n-        priv capacity: uint,\n-        priv size:     uint,\n-        priv hashes:   *mut u64,\n-        priv keys:     *mut K,\n-        priv vals:     *mut V,\n+        capacity: uint,\n+        size:     uint,\n+        hashes:   *mut u64,\n+        keys:     *mut K,\n+        vals:     *mut V,\n     }\n \n     /// Represents an index into a `RawTable` with no key or value in it.\n     pub struct EmptyIndex {\n-        priv idx:   int,\n-        priv nocopy: marker::NoCopy,\n+        idx:   int,\n+        nocopy: marker::NoCopy,\n     }\n \n     /// Represents an index into a `RawTable` with a key, value, and hash\n     /// in it.\n     pub struct FullIndex {\n-        priv idx:   int,\n-        priv hash:  SafeHash,\n-        priv nocopy: marker::NoCopy,\n+        idx:   int,\n+        hash:  SafeHash,\n+        nocopy: marker::NoCopy,\n     }\n \n     impl FullIndex {\n@@ -142,7 +142,7 @@ mod table {\n     /// A hash that is not zero, since we use that to represent empty buckets.\n     #[deriving(Eq)]\n     pub struct SafeHash {\n-        priv hash: u64,\n+        hash: u64,\n     }\n \n     impl SafeHash {\n@@ -376,18 +376,18 @@ mod table {\n     }\n \n     pub struct Entries<'a, K, V> {\n-        priv table: &'a RawTable<K, V>,\n-        priv idx: uint,\n+        table: &'a RawTable<K, V>,\n+        idx: uint,\n     }\n \n     pub struct MutEntries<'a, K, V> {\n-        priv table: &'a mut RawTable<K, V>,\n-        priv idx: uint,\n+        table: &'a mut RawTable<K, V>,\n+        idx: uint,\n     }\n \n     pub struct MoveEntries<K, V> {\n-        priv table: RawTable<K, V>,\n-        priv idx: uint,\n+        table: RawTable<K, V>,\n+        idx: uint,\n     }\n \n     impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n@@ -675,19 +675,19 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n #[deriving(Clone)]\n pub struct HashMap<K, V, H = sip::SipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n-    priv hasher: H,\n+    hasher: H,\n \n     // When size == grow_at, we double the capacity.\n-    priv grow_at: uint,\n+    grow_at: uint,\n \n     // The capacity must never drop below this.\n-    priv minimum_capacity: uint,\n+    minimum_capacity: uint,\n \n-    priv table: table::RawTable<K, V>,\n+    table: table::RawTable<K, V>,\n \n     // We keep this at the end since it's 4-bytes, unlike everything else\n     // in this struct. Might as well save a word of padding!\n-    priv load_factor: Fraction,\n+    load_factor: Fraction,\n }\n \n /// Get the number of elements which will force the capacity to grow.\n@@ -1385,7 +1385,7 @@ pub type SetMoveItems<K> =\n /// requires that the elements implement the `Eq` and `Hash` traits.\n #[deriving(Clone)]\n pub struct HashSet<T, H = sip::SipHasher> {\n-    priv map: HashMap<T, (), H>\n+    map: HashMap<T, (), H>\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {"}, {"sha": "de8d1c999bd3c36e43221655e44f8a07925e7dd8", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -22,6 +22,8 @@\n \n #![feature(macro_rules, managed_boxes, default_type_params, phase)]\n \n+#![allow(visible_private_types)] // NOTE: remove after a stage0 snap\n+\n extern crate rand;\n \n #[cfg(test)] extern crate test;"}, {"sha": "bd40d183945557c05d84eca7f530fd44a0931e29", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -56,10 +56,10 @@ struct LruEntry<K, V> {\n \n /// An LRU Cache.\n pub struct LruCache<K, V> {\n-    priv map: HashMap<KeyRef<K>, ~LruEntry<K, V>>,\n-    priv max_size: uint,\n-    priv head: *mut LruEntry<K, V>,\n-    priv tail: *mut LruEntry<K, V>,\n+    map: HashMap<KeyRef<K>, ~LruEntry<K, V>>,\n+    max_size: uint,\n+    head: *mut LruEntry<K, V>,\n+    tail: *mut LruEntry<K, V>,\n }\n \n impl<S, K: Hash<S>> Hash<S> for KeyRef<K> {"}, {"sha": "8c7eb1c6033d081d3524ef77a23e6c08d4b3aa95", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -19,7 +19,7 @@ use std::slice;\n /// A priority queue implemented with a binary heap\n #[deriving(Clone)]\n pub struct PriorityQueue<T> {\n-    priv data: ~[T],\n+    data: ~[T],\n }\n \n impl<T:Ord> Container for PriorityQueue<T> {\n@@ -181,7 +181,7 @@ impl<T:Ord> PriorityQueue<T> {\n \n /// PriorityQueue iterator\n pub struct Items <'a, T> {\n-    priv iter: slice::Items<'a, T>,\n+    iter: slice::Items<'a, T>,\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {"}, {"sha": "705e0f7d3d486a15d8cd277ee69f70bae95c49dc", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -25,9 +25,9 @@ static MINIMUM_CAPACITY: uint = 2u;\n /// RingBuf is a circular buffer that implements Deque.\n #[deriving(Clone)]\n pub struct RingBuf<T> {\n-    priv nelts: uint,\n-    priv lo: uint,\n-    priv elts: ~[Option<T>]\n+    nelts: uint,\n+    lo: uint,\n+    elts: ~[Option<T>]\n }\n \n impl<T> Container for RingBuf<T> {\n@@ -230,10 +230,10 @@ impl<T> RingBuf<T> {\n \n /// RingBuf iterator\n pub struct Items<'a, T> {\n-    priv lo: uint,\n-    priv index: uint,\n-    priv rindex: uint,\n-    priv elts: &'a [Option<T>],\n+    lo: uint,\n+    index: uint,\n+    rindex: uint,\n+    elts: &'a [Option<T>],\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n@@ -285,9 +285,9 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// RingBuf mutable iterator\n pub struct MutItems<'a, T> {\n-    priv remaining1: &'a mut [Option<T>],\n-    priv remaining2: &'a mut [Option<T>],\n-    priv nelts: uint,\n+    remaining1: &'a mut [Option<T>],\n+    remaining2: &'a mut [Option<T>],\n+    nelts: uint,\n }\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {"}, {"sha": "db7fafe522b72bbd12c7eb6d94536cc4595e2a7a", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -21,7 +21,7 @@ use std::slice;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n-    priv v: ~[Option<T>],\n+    v: ~[Option<T>],\n }\n \n impl<V> Container for SmallIntMap<V> {\n@@ -234,19 +234,19 @@ macro_rules! double_ended_iterator {\n }\n \n pub struct Entries<'a, T> {\n-    priv front: uint,\n-    priv back: uint,\n-    priv iter: slice::Items<'a, Option<T>>\n+    front: uint,\n+    back: uint,\n+    iter: slice::Items<'a, Option<T>>\n }\n \n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n pub type RevEntries<'a, T> = Rev<Entries<'a, T>>;\n \n pub struct MutEntries<'a, T> {\n-    priv front: uint,\n-    priv back: uint,\n-    priv iter: slice::MutItems<'a, Option<T>>\n+    front: uint,\n+    back: uint,\n+    iter: slice::MutItems<'a, Option<T>>\n }\n \n iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)"}, {"sha": "0a5e653f8ebd69b9faa59c75529024ce49b682a6", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -36,8 +36,8 @@ use std::ptr;\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub struct TreeMap<K, V> {\n-    priv root: Option<~TreeNode<K, V>>,\n-    priv length: uint\n+    root: Option<~TreeNode<K, V>>,\n+    length: uint\n }\n \n impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n@@ -273,24 +273,24 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n /// Lazy forward iterator over a map\n pub struct Entries<'a, K, V> {\n-    priv stack: ~[&'a TreeNode<K, V>],\n+    stack: ~[&'a TreeNode<K, V>],\n     // See the comment on MutEntries; this is just to allow\n     // code-sharing (for this immutable-values iterator it *could* very\n     // well be Option<&'a TreeNode<K,V>>).\n-    priv node: *TreeNode<K, V>,\n-    priv remaining_min: uint,\n-    priv remaining_max: uint\n+    node: *TreeNode<K, V>,\n+    remaining_min: uint,\n+    remaining_max: uint\n }\n \n /// Lazy backward iterator over a map\n pub struct RevEntries<'a, K, V> {\n-    priv iter: Entries<'a, K, V>,\n+    iter: Entries<'a, K, V>,\n }\n \n /// Lazy forward iterator over a map that allows for the mutation of\n /// the values.\n pub struct MutEntries<'a, K, V> {\n-    priv stack: ~[&'a mut TreeNode<K, V>],\n+    stack: ~[&'a mut TreeNode<K, V>],\n     // Unfortunately, we require some unsafe-ness to get around the\n     // fact that we would be storing a reference *into* one of the\n     // nodes in the stack.\n@@ -310,14 +310,14 @@ pub struct MutEntries<'a, K, V> {\n     // it under control.\n     //\n     // (This field can legitimately be null.)\n-    priv node: *mut TreeNode<K, V>,\n-    priv remaining_min: uint,\n-    priv remaining_max: uint\n+    node: *mut TreeNode<K, V>,\n+    remaining_min: uint,\n+    remaining_max: uint\n }\n \n /// Lazy backward iterator over a map\n pub struct RevMutEntries<'a, K, V> {\n-    priv iter: MutEntries<'a, K, V>,\n+    iter: MutEntries<'a, K, V>,\n }\n \n \n@@ -482,8 +482,8 @@ fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n \n /// Lazy forward iterator over a map that consumes the map while iterating\n pub struct MoveEntries<K, V> {\n-    priv stack: ~[TreeNode<K, V>],\n-    priv remaining: uint\n+    stack: ~[TreeNode<K, V>],\n+    remaining: uint\n }\n \n impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n@@ -551,7 +551,7 @@ impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n /// `TotalOrd` trait.\n #[deriving(Clone)]\n pub struct TreeSet<T> {\n-    priv map: TreeMap<T, ()>\n+    map: TreeMap<T, ()>\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n@@ -703,36 +703,36 @@ impl<T: TotalOrd> TreeSet<T> {\n \n /// Lazy forward iterator over a set\n pub struct SetItems<'a, T> {\n-    priv iter: Entries<'a, T, ()>\n+    iter: Entries<'a, T, ()>\n }\n \n /// Lazy backward iterator over a set\n pub struct RevSetItems<'a, T> {\n-    priv iter: RevEntries<'a, T, ()>\n+    iter: RevEntries<'a, T, ()>\n }\n \n /// Lazy iterator producing elements in the set difference (in-order)\n pub struct DifferenceItems<'a, T> {\n-    priv a: Peekable<&'a T, SetItems<'a, T>>,\n-    priv b: Peekable<&'a T, SetItems<'a, T>>,\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set symmetric difference (in-order)\n pub struct SymDifferenceItems<'a, T> {\n-    priv a: Peekable<&'a T, SetItems<'a, T>>,\n-    priv b: Peekable<&'a T, SetItems<'a, T>>,\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct IntersectionItems<'a, T> {\n-    priv a: Peekable<&'a T, SetItems<'a, T>>,\n-    priv b: Peekable<&'a T, SetItems<'a, T>>,\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct UnionItems<'a, T> {\n-    priv a: Peekable<&'a T, SetItems<'a, T>>,\n-    priv b: Peekable<&'a T, SetItems<'a, T>>,\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None"}, {"sha": "740a36377003ea4ae2d73b080a82c57e77ed51e8", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad7e5481f970ba8d1103b4cc20a71335aba466e/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=8ad7e5481f970ba8d1103b4cc20a71335aba466e", "patch": "@@ -30,8 +30,8 @@ enum Child<T> {\n \n #[allow(missing_doc)]\n pub struct TrieMap<T> {\n-    priv root: TrieNode<T>,\n-    priv length: uint\n+    root: TrieNode<T>,\n+    length: uint\n }\n \n impl<T> Container for TrieMap<T> {\n@@ -278,7 +278,7 @@ impl<T> Extendable<(uint, T)> for TrieMap<T> {\n \n #[allow(missing_doc)]\n pub struct TrieSet {\n-    priv map: TrieMap<()>\n+    map: TrieMap<()>\n }\n \n impl Container for TrieSet {\n@@ -474,19 +474,19 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n /// Forward iterator over a map\n pub struct Entries<'a, T> {\n-    priv stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n-    priv length: uint,\n-    priv remaining_min: uint,\n-    priv remaining_max: uint\n+    stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n+    length: uint,\n+    remaining_min: uint,\n+    remaining_max: uint\n }\n \n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct MutEntries<'a, T> {\n-    priv stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n-    priv length: uint,\n-    priv remaining_min: uint,\n-    priv remaining_max: uint\n+    stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n+    length: uint,\n+    remaining_min: uint,\n+    remaining_max: uint\n }\n \n // FIXME #5846: see `addr!` above.\n@@ -605,7 +605,7 @@ iterator_impl! { MutEntries, iter = mut_iter, mutability = mut }\n \n /// Forward iterator over a set\n pub struct SetItems<'a> {\n-    priv iter: Entries<'a, ()>\n+    iter: Entries<'a, ()>\n }\n \n impl<'a> Iterator<uint> for SetItems<'a> {"}]}