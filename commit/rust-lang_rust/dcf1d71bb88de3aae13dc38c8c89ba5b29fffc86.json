{"sha": "dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "node_id": "C_kwDOAAsO6NoAKGRjZjFkNzFiYjg4ZGUzYWFlMTNkYzM4YzhjODliYTViMjlmZmZjODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-10T08:24:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-10T08:24:37Z"}, "message": "Auto merge of #13303 - jplatte:convert-named-struct-to-tuple-struct, r=Veykril\n\nAdd convert_named_struct_to_tuple_struct assist\n\nCloses #11643, since the assist for converting in the other direction is already there (I based most of the implementation and all of the tests on it).", "tree": {"sha": "c8e69a876c5bfcb1d35ec14b27e74f01a211ad23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8e69a876c5bfcb1d35ec14b27e74f01a211ad23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "html_url": "https://github.com/rust-lang/rust/commit/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a3f84002b67a67ef82971445468195108a2bb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a3f84002b67a67ef82971445468195108a2bb7", "html_url": "https://github.com/rust-lang/rust/commit/79a3f84002b67a67ef82971445468195108a2bb7"}, {"sha": "a3d79b517273e333127cb6edb7ea001153df800c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d79b517273e333127cb6edb7ea001153df800c", "html_url": "https://github.com/rust-lang/rust/commit/a3d79b517273e333127cb6edb7ea001153df800c"}], "stats": {"total": 866, "additions": 866, "deletions": 0}, "files": [{"sha": "8d11e0bac9413f24b8dcfbc72faff73e0bd602ef", "filename": "crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs", "status": "added", "additions": 822, "deletions": 0, "changes": 822, "blob_url": "https://github.com/rust-lang/rust/blob/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs?ref=dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "patch": "@@ -0,0 +1,822 @@\n+use either::Either;\n+use ide_db::defs::Definition;\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, HasGenericParams, HasVisibility},\n+    match_ast, SyntaxKind, SyntaxNode,\n+};\n+\n+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_named_struct_to_tuple_struct\n+//\n+// Converts struct with named fields to tuple struct, and analogously for enum variants with named\n+// fields.\n+//\n+// ```\n+// struct Point$0 { x: f32, y: f32 }\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point { x, y }\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.x\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.y\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Point(f32, f32);\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point(x, y)\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.0\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.1\n+//     }\n+// }\n+// ```\n+pub(crate) fn convert_named_struct_to_tuple_struct(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    let strukt = ctx\n+        .find_node_at_offset::<ast::Struct>()\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n+    let record_fields = match field_list {\n+        ast::FieldList::RecordFieldList(it) => it,\n+        ast::FieldList::TupleFieldList(_) => return None,\n+    };\n+    let strukt_def = match &strukt {\n+        Either::Left(s) => Either::Left(ctx.sema.to_def(s)?),\n+        Either::Right(v) => Either::Right(ctx.sema.to_def(v)?),\n+    };\n+    let target = strukt.as_ref().either(|s| s.syntax(), |v| v.syntax()).text_range();\n+\n+    acc.add(\n+        AssistId(\"convert_named_struct_to_tuple_struct\", AssistKind::RefactorRewrite),\n+        \"Convert to tuple struct\",\n+        target,\n+        |edit| {\n+            edit_field_references(ctx, edit, record_fields.fields());\n+            edit_struct_references(ctx, edit, strukt_def);\n+            edit_struct_def(ctx, edit, &strukt, record_fields);\n+        },\n+    )\n+}\n+\n+fn edit_struct_def(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    strukt: &Either<ast::Struct, ast::Variant>,\n+    record_fields: ast::RecordFieldList,\n+) {\n+    let tuple_fields = record_fields\n+        .fields()\n+        .filter_map(|f| Some(ast::make::tuple_field(f.visibility(), f.ty()?)));\n+    let tuple_fields = ast::make::tuple_field_list(tuple_fields);\n+    let record_fields_text_range = record_fields.syntax().text_range();\n+\n+    edit.edit_file(ctx.file_id());\n+    edit.replace(record_fields_text_range, tuple_fields.syntax().text());\n+\n+    if let Either::Left(strukt) = strukt {\n+        if let Some(w) = strukt.where_clause() {\n+            let mut where_clause = w.to_string();\n+            if where_clause.ends_with(',') {\n+                where_clause.pop();\n+            }\n+            where_clause.push(';');\n+\n+            edit.delete(w.syntax().text_range());\n+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());\n+            edit.insert(record_fields_text_range.end(), where_clause);\n+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());\n+\n+            if let Some(tok) = strukt\n+                .generic_param_list()\n+                .and_then(|l| l.r_angle_token())\n+                .and_then(|tok| tok.next_token())\n+                .filter(|tok| tok.kind() == SyntaxKind::WHITESPACE)\n+            {\n+                edit.delete(tok.text_range());\n+            }\n+        } else {\n+            edit.insert(record_fields_text_range.end(), \";\");\n+        }\n+    }\n+\n+    if let Some(tok) = record_fields\n+        .l_curly_token()\n+        .and_then(|tok| tok.prev_token())\n+        .filter(|tok| tok.kind() == SyntaxKind::WHITESPACE)\n+    {\n+        edit.delete(tok.text_range())\n+    }\n+}\n+\n+fn edit_struct_references(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    strukt: Either<hir::Struct, hir::Variant>,\n+) {\n+    let strukt_def = match strukt {\n+        Either::Left(s) => Definition::Adt(hir::Adt::Struct(s)),\n+        Either::Right(v) => Definition::Variant(v),\n+    };\n+    let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n+\n+    let edit_node = |edit: &mut SourceChangeBuilder, node: SyntaxNode| -> Option<()> {\n+        match_ast! {\n+            match node {\n+                ast::RecordPat(record_struct_pat) => {\n+                    edit.replace(\n+                        record_struct_pat.syntax().text_range(),\n+                        ast::make::tuple_struct_pat(\n+                            record_struct_pat.path()?,\n+                            record_struct_pat\n+                                .record_pat_field_list()?\n+                                .fields()\n+                                .filter_map(|pat| pat.pat())\n+                        )\n+                        .to_string()\n+                    );\n+                },\n+                ast::RecordExpr(record_expr) => {\n+                    let path = record_expr.path()?;\n+                    let args = record_expr\n+                        .record_expr_field_list()?\n+                        .fields()\n+                        .filter_map(|f| f.expr())\n+                        .join(\", \");\n+\n+                    edit.replace(record_expr.syntax().text_range(), format!(\"{path}({args})\"));\n+                },\n+                _ => return None,\n+            }\n+        }\n+        Some(())\n+    };\n+\n+    for (file_id, refs) in usages {\n+        edit.edit_file(file_id);\n+        for r in refs {\n+            for node in r.name.syntax().ancestors() {\n+                if edit_node(edit, node).is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn edit_field_references(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    fields: impl Iterator<Item = ast::RecordField>,\n+) {\n+    for (index, field) in fields.enumerate() {\n+        let field = match ctx.sema.to_def(&field) {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        let def = Definition::Field(field);\n+        let usages = def.usages(&ctx.sema).all();\n+        for (file_id, refs) in usages {\n+            edit.edit_file(file_id);\n+            for r in refs {\n+                if let Some(name_ref) = r.name.as_name_ref() {\n+                    // Only edit the field reference if it's part of a `.field` access\n+                    if name_ref.syntax().parent().and_then(ast::FieldExpr::cast).is_some() {\n+                        edit.replace(name_ref.syntax().text_range(), index.to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_other_than_record_struct() {\n+        check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#\"struct Foo$0(u32)\"#);\n+        check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#\"struct Foo$0;\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_struct() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A { inner }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A(inner)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_referenced_via_self_kw() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self { inner }\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self(inner)\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_struct() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A { inner: a } = self;\n+        a\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self { inner } = self;\n+        inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A(a) = self;\n+        a\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self(inner) = self;\n+        inner\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_visibility() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct A$0 {\n+    pub first: u32,\n+    pub(crate) second: u64\n+}\n+\n+impl A {\n+    fn new() -> A {\n+        A { first: 42, second: 42 }\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.first\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.second\n+    }\n+}\"#,\n+            r#\"\n+struct A(pub u32, pub(crate) u64);\n+\n+impl A {\n+    fn new() -> A {\n+        A(42, 42)\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.0\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_wrapped_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner$0 { uint: u32 }\n+struct Outer { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner { uint: 42 } }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner { uint: x } } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner(u32);\n+struct Outer { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner(42) }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.0\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner { uint: u32 }\n+struct Outer$0 { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner { uint: 42 } }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner { uint: x } } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner { uint: u32 }\n+struct Outer(Inner);\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self(Inner { uint: 42 })\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.0.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer(Inner { uint: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_multi_file_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A { inner: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A(Inner);\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A(Inner);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_where_clause() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Wrap$0<T>\n+where\n+    T: Display,\n+{ field1: T }\n+\"#,\n+            r#\"\n+struct Wrap<T>(T)\n+where\n+    T: Display;\n+\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_other_than_record_variant() {\n+        check_assist_not_applicable(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"enum Enum { Variant$0(usize) };\"#,\n+        );\n+        check_assist_not_applicable(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"enum Enum { Variant$0 }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_simple_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_referenced_via_self_kw() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant(first) = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_wrapped_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum Inner {\n+    $0Variant { field1: usize },\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant { field1: 42 })\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    $0Variant { field1: Inner },\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant { field1: Inner::Variant(42) }\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant { field1: Inner::Variant(x) } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_multi_file_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant { field1: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant(Inner);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_directly_used_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant { field1: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant(Inner);\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a07318cefad273dbdb4410b12a670f06f86107f9", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "patch": "@@ -121,6 +121,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_let_else_to_match;\n     mod convert_tuple_struct_to_named_struct;\n+    mod convert_named_struct_to_tuple_struct;\n     mod convert_to_guarded_return;\n     mod convert_two_arm_bool_match_to_matches_macro;\n     mod convert_while_to_loop;\n@@ -218,6 +219,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_let_else_to_match::convert_let_else_to_match,\n+            convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,"}, {"sha": "f7f2417d0745d7a4088ed75a11f7241875bb5663", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "patch": "@@ -232,6 +232,7 @@ fn assist_order_field_struct() {\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a mut getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a setter method\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Convert to tuple struct\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Add `#[derive]`\");\n }\n "}, {"sha": "2c4000efe0fa25a9f0c159d0c5f2f046ab04c9b5", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=dcf1d71bb88de3aae13dc38c8c89ba5b29fffc86", "patch": "@@ -407,6 +407,47 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_named_struct_to_tuple_struct() {\n+    check_doc_test(\n+        \"convert_named_struct_to_tuple_struct\",\n+        r#####\"\n+struct Point$0 { x: f32, y: f32 }\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point { x, y }\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.x\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.y\n+    }\n+}\n+\"#####,\n+        r#####\"\n+struct Point(f32, f32);\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point(x, y)\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.0\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.1\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_to_guarded_return() {\n     check_doc_test("}]}