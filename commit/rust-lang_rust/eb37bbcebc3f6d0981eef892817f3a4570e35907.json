{"sha": "eb37bbcebc3f6d0981eef892817f3a4570e35907", "node_id": "C_kwDOAAsO6NoAKGViMzdiYmNlYmMzZjZkMDk4MWVlZjg5MjgxN2YzYTQ1NzBlMzU5MDc", "commit": {"author": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2022-05-19T13:41:35Z"}, "committer": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2022-06-15T15:52:42Z"}, "message": "Document that `BorrowedFd` may be used to do a `dup`.", "tree": {"sha": "c99237a936396e781fc985c959cb59098816d822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c99237a936396e781fc985c959cb59098816d822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb37bbcebc3f6d0981eef892817f3a4570e35907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb37bbcebc3f6d0981eef892817f3a4570e35907", "html_url": "https://github.com/rust-lang/rust/commit/eb37bbcebc3f6d0981eef892817f3a4570e35907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb37bbcebc3f6d0981eef892817f3a4570e35907/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4cec9742b7e05c33c84cd75002cd56762f7e33b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cec9742b7e05c33c84cd75002cd56762f7e33b", "html_url": "https://github.com/rust-lang/rust/commit/a4cec9742b7e05c33c84cd75002cd56762f7e33b"}], "stats": {"total": 42, "additions": 29, "deletions": 13}, "files": [{"sha": "7556d3ad0b230d00353a23b81e6295db8e1e68ba", "filename": "library/std/src/os/unix/io/mod.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs?ref=eb37bbcebc3f6d0981eef892817f3a4570e35907", "patch": "@@ -26,20 +26,30 @@\n //! that they don't outlive the resource they point to. These are safe to\n //! use. `BorrowedFd` values may be used in APIs which provide safe access to\n //! any system call except for:\n+//!\n //!  - `close`, because that would end the dynamic lifetime of the resource\n //!    without ending the lifetime of the file descriptor.\n+//!\n //!  - `dup2`/`dup3`, in the second argument, because this argument is\n //!    closed and assigned a new resource, which may break the assumptions\n //!    other code using that file descriptor.\n-//! This list doesn't include `mmap`, since `mmap` does do a proper borrow of\n-//! its file descriptor argument. That said, `mmap` is unsafe for other\n-//! reasons: it operates on raw pointers, and it can have undefined behavior if\n-//! the underlying storage is mutated. Mutations may come from other processes,\n-//! or from the same process if the API provides `BorrowedFd` access, since as\n-//! mentioned earlier, `BorrowedFd` values may be used in APIs which provide\n-//! safe access to any system call. Consequently, code using `mmap` and\n-//! presenting a safe API must take full responsibility for ensuring that safe\n-//! Rust code cannot evoke undefined behavior through it.\n+//!\n+//! `BorrowedFd` values may be used in APIs which provide safe access to `dup`\n+//! system calls, so types implementing `AsFd` or `From<OwnedFd>` should not\n+//! assume they always have exclusive access to the underlying file\n+//! description.\n+//!\n+//! `BorrowedFd` values may also be used with `mmap`, since `mmap` uses the\n+//! provided file descriptor in a manner similar to `dup` and does not require\n+//! the `BorrowedFd` passed to it to live for the lifetime of the resulting\n+//! mapping. That said, `mmap` is unsafe for other reasons: it operates on raw\n+//! pointers, and it can have undefined behavior if the underlying storage is\n+//! mutated. Mutations may come from other processes, or from the same process\n+//! if the API provides `BorrowedFd` access, since as mentioned earlier,\n+//! `BorrowedFd` values may be used in APIs which provide safe access to any\n+//! system call. Consequently, code using `mmap` and presenting a safe API must\n+//! take full responsibility for ensuring that safe Rust code cannot evoke\n+//! undefined behavior through it.\n //!\n //! Like boxes, `OwnedFd` values conceptually own the resource they point to,\n //! and free (close) it when they are dropped."}, {"sha": "91b886c0888ee0e222d042420866470c5baac72e", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=eb37bbcebc3f6d0981eef892817f3a4570e35907", "patch": "@@ -189,15 +189,15 @@ impl OwnedHandle {\n         access: c::DWORD,\n         inherit: bool,\n         options: c::DWORD,\n-    ) -> io::Result<Self> {\n+    ) -> io::Result<OwnedHandle> {\n         let handle = self.as_raw_handle();\n \n         // `Stdin`, `Stdout`, and `Stderr` can all hold null handles, such as\n         // in a process with a detached console. `DuplicateHandle` would fail\n         // if we passed it a null handle, but we can treat null as a valid\n         // handle which doesn't do any I/O, and allow it to be duplicated.\n         if handle.is_null() {\n-            return unsafe { Ok(Self::from_raw_handle(handle)) };\n+            return unsafe { Ok(OwnedHandle::from_raw_handle(handle)) };\n         }\n \n         let mut ret = ptr::null_mut();\n@@ -213,7 +213,7 @@ impl OwnedHandle {\n                 options,\n             )\n         })?;\n-        unsafe { Ok(Self::from_raw_handle(ret)) }\n+        unsafe { Ok(OwnedHandle::from_raw_handle(ret)) }\n     }\n }\n "}, {"sha": "e2a401fb6962b5ca090c2198dafcd0b138442b5f", "filename": "library/std/src/os/windows/io/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs?ref=eb37bbcebc3f6d0981eef892817f3a4570e35907", "patch": "@@ -36,6 +36,12 @@\n //! dynamic lifetime of the resource without ending the lifetime of the\n //! handle or socket.\n //!\n+//! `BorrowedHandle` and `BorrowedSocket` values may be used in APIs which\n+//! provide safe access to `DuplicateHandle` and `WSADuplicateSocketW` and\n+//! related functions, so types implementing `AsHandle`, `AsSocket`,\n+//! `From<OwnedHandle>`, or `From<OwnedSocket>` should not assume they always\n+//! have exclusive access to the underlying object.\n+//!\n //! Like boxes, `OwnedHandle` and `OwnedSocket` values conceptually own the\n //! resource they point to, and free (close) it when they are dropped.\n //!"}, {"sha": "1e7b6e1eab03a29c4b0d7abdf54245c5beb0eee0", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb37bbcebc3f6d0981eef892817f3a4570e35907/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=eb37bbcebc3f6d0981eef892817f3a4570e35907", "patch": "@@ -218,7 +218,7 @@ impl Handle {\n         inherit: bool,\n         options: c::DWORD,\n     ) -> io::Result<Self> {\n-        Ok(Self(self.0.duplicate(access, inherit, options)?))\n+        Ok(Self(self.0.as_handle().duplicate(access, inherit, options)?))\n     }\n \n     /// Performs a synchronous read."}]}