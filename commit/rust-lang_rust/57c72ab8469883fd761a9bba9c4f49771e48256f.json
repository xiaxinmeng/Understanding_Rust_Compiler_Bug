{"sha": "57c72ab8469883fd761a9bba9c4f49771e48256f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YzcyYWI4NDY5ODgzZmQ3NjFhOWJiYTljNGY0OTc3MWU0ODI1NmY=", "commit": {"author": {"name": "Anders Kaseorg", "email": "andersk@mit.edu", "date": "2021-01-25T02:16:31Z"}, "committer": {"name": "Anders Kaseorg", "email": "andersk@mit.edu", "date": "2021-01-25T03:09:54Z"}, "message": "libtest: Wait for test threads to exit after they report completion\n\nOtherwise we can miss bugs where a test reports that it succeeded but\nthen panics within a TLS destructor.\n\nSigned-off-by: Anders Kaseorg <andersk@mit.edu>", "tree": {"sha": "619fdb31b751476fb07c6c72885a68bd7406a899", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/619fdb31b751476fb07c6c72885a68bd7406a899"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57c72ab8469883fd761a9bba9c4f49771e48256f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57c72ab8469883fd761a9bba9c4f49771e48256f", "html_url": "https://github.com/rust-lang/rust/commit/57c72ab8469883fd761a9bba9c4f49771e48256f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57c72ab8469883fd761a9bba9c4f49771e48256f/comments", "author": {"login": "andersk", "id": 26471, "node_id": "MDQ6VXNlcjI2NDcx", "avatar_url": "https://avatars.githubusercontent.com/u/26471?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersk", "html_url": "https://github.com/andersk", "followers_url": "https://api.github.com/users/andersk/followers", "following_url": "https://api.github.com/users/andersk/following{/other_user}", "gists_url": "https://api.github.com/users/andersk/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersk/subscriptions", "organizations_url": "https://api.github.com/users/andersk/orgs", "repos_url": "https://api.github.com/users/andersk/repos", "events_url": "https://api.github.com/users/andersk/events{/privacy}", "received_events_url": "https://api.github.com/users/andersk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andersk", "id": 26471, "node_id": "MDQ6VXNlcjI2NDcx", "avatar_url": "https://avatars.githubusercontent.com/u/26471?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersk", "html_url": "https://github.com/andersk", "followers_url": "https://api.github.com/users/andersk/followers", "following_url": "https://api.github.com/users/andersk/following{/other_user}", "gists_url": "https://api.github.com/users/andersk/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersk/subscriptions", "organizations_url": "https://api.github.com/users/andersk/orgs", "repos_url": "https://api.github.com/users/andersk/repos", "events_url": "https://api.github.com/users/andersk/events{/privacy}", "received_events_url": "https://api.github.com/users/andersk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3163e96553ae8cb1fca0e62084b124e8b98310b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3163e96553ae8cb1fca0e62084b124e8b98310b", "html_url": "https://github.com/rust-lang/rust/commit/d3163e96553ae8cb1fca0e62084b124e8b98310b"}], "stats": {"total": 59, "additions": 45, "deletions": 14}, "files": [{"sha": "f6b692404606da93e9383e2e4e48006d341ea8b7", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/57c72ab8469883fd761a9bba9c4f49771e48256f/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c72ab8469883fd761a9bba9c4f49771e48256f/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=57c72ab8469883fd761a9bba9c4f49771e48256f", "patch": "@@ -25,6 +25,7 @@\n #![feature(nll)]\n #![feature(available_concurrency)]\n #![feature(internal_output_capture)]\n+#![feature(option_unwrap_none)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n@@ -208,9 +209,15 @@ where\n     use std::collections::{self, HashMap};\n     use std::hash::BuildHasherDefault;\n     use std::sync::mpsc::RecvTimeoutError;\n+\n+    struct RunningTest {\n+        timeout: Instant,\n+        join_handle: Option<thread::JoinHandle<()>>,\n+    }\n+\n     // Use a deterministic hasher\n     type TestMap =\n-        HashMap<TestDesc, Instant, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n+        HashMap<TestDesc, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n \n     let tests_len = tests.len();\n \n@@ -260,7 +267,11 @@ where\n         let now = Instant::now();\n         let timed_out = running_tests\n             .iter()\n-            .filter_map(|(desc, timeout)| if &now >= timeout { Some(desc.clone()) } else { None })\n+            .filter_map(\n+                |(desc, running_test)| {\n+                    if now >= running_test.timeout { Some(desc.clone()) } else { None }\n+                },\n+            )\n             .collect();\n         for test in &timed_out {\n             running_tests.remove(test);\n@@ -269,9 +280,9 @@ where\n     }\n \n     fn calc_timeout(running_tests: &TestMap) -> Option<Duration> {\n-        running_tests.values().min().map(|next_timeout| {\n+        running_tests.values().map(|running_test| running_test.timeout).min().map(|next_timeout| {\n             let now = Instant::now();\n-            if *next_timeout >= now { *next_timeout - now } else { Duration::new(0, 0) }\n+            if next_timeout >= now { next_timeout - now } else { Duration::new(0, 0) }\n         })\n     }\n \n@@ -280,7 +291,8 @@ where\n             let test = remaining.pop().unwrap();\n             let event = TestEvent::TeWait(test.desc.clone());\n             notify_about_test_event(event)?;\n-            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n+            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No)\n+                .unwrap_none();\n             let completed_test = rx.recv().unwrap();\n \n             let event = TestEvent::TeResult(completed_test);\n@@ -291,11 +303,19 @@ where\n             while pending < concurrency && !remaining.is_empty() {\n                 let test = remaining.pop().unwrap();\n                 let timeout = time::get_default_test_timeout();\n-                running_tests.insert(test.desc.clone(), timeout);\n+                let desc = test.desc.clone();\n \n                 let event = TestEvent::TeWait(test.desc.clone());\n                 notify_about_test_event(event)?; //here no pad\n-                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n+                let join_handle = run_test(\n+                    opts,\n+                    !opts.run_tests,\n+                    test,\n+                    run_strategy,\n+                    tx.clone(),\n+                    Concurrent::Yes,\n+                );\n+                running_tests.insert(desc, RunningTest { timeout, join_handle });\n                 pending += 1;\n             }\n \n@@ -323,8 +343,16 @@ where\n                 }\n             }\n \n-            let completed_test = res.unwrap();\n-            running_tests.remove(&completed_test.desc);\n+            let mut completed_test = res.unwrap();\n+            let running_test = running_tests.remove(&completed_test.desc).unwrap();\n+            if let Some(join_handle) = running_test.join_handle {\n+                if let Err(_) = join_handle.join() {\n+                    if let TrOk = completed_test.result {\n+                        completed_test.result =\n+                            TrFailedMsg(\"panicked after reporting success\".to_string());\n+                    }\n+                }\n+            }\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -415,7 +443,7 @@ pub fn run_test(\n     strategy: RunStrategy,\n     monitor_ch: Sender<CompletedTest>,\n     concurrency: Concurrent,\n-) {\n+) -> Option<thread::JoinHandle<()>> {\n     let TestDescAndFn { desc, testfn } = test;\n \n     // Emscripten can catch panics but other wasm targets cannot\n@@ -426,7 +454,7 @@ pub fn run_test(\n     if force_ignore || desc.ignore || ignore_because_no_process_support {\n         let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n         monitor_ch.send(message).unwrap();\n-        return;\n+        return None;\n     }\n \n     struct TestRunOpts {\n@@ -441,7 +469,7 @@ pub fn run_test(\n         monitor_ch: Sender<CompletedTest>,\n         testfn: Box<dyn FnOnce() + Send>,\n         opts: TestRunOpts,\n-    ) {\n+    ) -> Option<thread::JoinHandle<()>> {\n         let concurrency = opts.concurrency;\n         let name = desc.name.clone();\n \n@@ -469,9 +497,10 @@ pub fn run_test(\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n         if concurrency == Concurrent::Yes && supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n-            cfg.spawn(runtest).unwrap();\n+            Some(cfg.spawn(runtest).unwrap())\n         } else {\n             runtest();\n+            None\n         }\n     }\n \n@@ -484,10 +513,12 @@ pub fn run_test(\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                 bencher.run(harness)\n             });\n+            None\n         }\n         StaticBenchFn(benchfn) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n+            None\n         }\n         DynTestFn(f) => {\n             match strategy {\n@@ -499,7 +530,7 @@ pub fn run_test(\n                 monitor_ch,\n                 Box::new(move || __rust_begin_short_backtrace(f)),\n                 test_run_opts,\n-            );\n+            )\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,"}]}