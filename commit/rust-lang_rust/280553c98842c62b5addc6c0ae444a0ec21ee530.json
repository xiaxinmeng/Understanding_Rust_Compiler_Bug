{"sha": "280553c98842c62b5addc6c0ae444a0ec21ee530", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MDU1M2M5ODg0MmM2MmI1YWRkYzZjMGFlNDQ0YTBlYzIxZWU1MzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-07T03:30:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-07T03:37:27Z"}, "message": "doc: Fix tests in pointer guide", "tree": {"sha": "428b8df23ad940e70993526a3c11a0f41be4d3df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/428b8df23ad940e70993526a3c11a0f41be4d3df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/280553c98842c62b5addc6c0ae444a0ec21ee530", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/280553c98842c62b5addc6c0ae444a0ec21ee530", "html_url": "https://github.com/rust-lang/rust/commit/280553c98842c62b5addc6c0ae444a0ec21ee530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/280553c98842c62b5addc6c0ae444a0ec21ee530/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f09d80f97457fd69fa736d71c491042b2c945df", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f09d80f97457fd69fa736d71c491042b2c945df", "html_url": "https://github.com/rust-lang/rust/commit/6f09d80f97457fd69fa736d71c491042b2c945df"}], "stats": {"total": 109, "additions": 58, "deletions": 51}, "files": [{"sha": "8777eb2e5774744b572ee6aac77e15292e4c0e0a", "filename": "doc/guide-pointers.md", "status": "modified", "additions": 58, "deletions": 51, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/280553c98842c62b5addc6c0ae444a0ec21ee530/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/280553c98842c62b5addc6c0ae444a0ec21ee530/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=280553c98842c62b5addc6c0ae444a0ec21ee530", "patch": "@@ -16,52 +16,53 @@ don't need them very often.\n \"But tutorial!\" you may cry. \"My co-worker wrote a function that looks like\n this:\n \n-```rust\n+~~~rust\n fn succ(x: &int) -> int { *x + 1 }\n-```\n+~~~\n \n So I wrote this code to try it out:\n \n-```rust\n+~~~rust {.xfail-test}\n fn main() {\n     let number = 5;\n     let succ_number = succ(number);\n     println!(\"{}\", succ_number);\n }\n-```\n+~~~\n \n And now I get an error:\n \n-```\n+~~~ {.notrust}\n error: mismatched types: expected `&int` but found `<VI0>` (expected &-ptr but found integral variable)\n-```\n+~~~\n \n What gives? It needs a pointer! Therefore I have to use pointers!\"\n \n Turns out, you don't. All you need is a reference. Try this on for size:\n \n-```rust\n+~~~rust\n+# fn succ(x: &int) -> int { *x + 1 }\n fn main() {\n     let number = 5;\n     let succ_number = succ(&number);\n     println!(\"{}\", succ_number);\n }\n-```\n+~~~\n \n It's that easy! One extra little `&` there. This code will run, and print `6`.\n \n That's all you need to know. Your co-worker could have written the function\n like this:\n \n-```rust\n+~~~rust\n fn succ(x: int) -> int { x + 1 }\n \n fn main() {\n     let number = 5;\n     let succ_number = succ(number);\n     println!(\"{}\", succ_number);\n }\n-```\n+~~~\n \n No pointers even needed. Then again, this is a simple example. I assume that\n your real-world `succ` function is more complicated, and maybe your co-worker\n@@ -100,7 +101,8 @@ passing things by reference, or passing things by pointer. In some langauges,\n like Java, you can't even have objects without a pointer to them. Therefore, if\n you were writing this Rust code:\n \n-```rust\n+~~~rust\n+# fn transform(p: Point) -> Point { p }\n struct Point {\n     x: int,\n     y: int,\n@@ -112,22 +114,27 @@ fn main() {\n     println!(\"{:?}\", p1);\n }\n \n-```\n+~~~\n \n I think you'd implement `transform` like this:\n \n-```rust\n+~~~rust\n+# struct Point {\n+#     x: int,\n+#     y: int,\n+# }\n+# let p0 = Point { x: 5, y: 10};\n fn transform(p: &Point) -> Point {\n     Point { x: p.x + 1, y: p.y + 1}\n }\n \n // and change this:\n let p1 = transform(&p0);\n-```\n+~~~\n \n This does work, but you don't need to create those references! The better way to write this is simply:\n \n-```rust\n+~~~rust\n struct Point {\n     x: int,\n     y: int,\n@@ -142,7 +149,7 @@ fn main() {\n     let p1 = transform(p0);\n     println!(\"{:?}\", p1);\n }\n-```\n+~~~\n \n But won't this be inefficent? Well, that's a complicated question, but it's\n important to know that Rust, like C and C++, store aggregate data types\n@@ -175,7 +182,7 @@ trait. Therefore, unboxed traits don't make any sense, and aren't allowed.\n \n Sometimes, you need a recursive data structure. The simplest is known as a 'cons list':\n \n-```rust\n+~~~rust\n enum List<T> {\n     Nil,\n     Cons(T, ~List<T>),\n@@ -185,13 +192,13 @@ fn main() {\n     let list: List<int> = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n     println!(\"{:?}\", list);\n }\n-```\n+~~~\n \n This prints:\n \n-```\n+~~~ {.notrust}\n Cons(1, ~Cons(2, ~Cons(3, ~Nil)))\n-```\n+~~~\n \n The inner lists _must_ be an owned pointer, becuase we can't know how many\n elements are in the list. Without knowing the length, we don't know the size,\n@@ -207,7 +214,7 @@ proved that it's an issue through benchmarks.\n \n For example, this will work:\n \n-```rust\n+~~~rust\n struct Point {\n     x: int,\n     y: int,\n@@ -219,12 +226,12 @@ fn main() {\n         println(a.x.to_str());\n     }\n }\n-```\n+~~~\n \n This struct is tiny, so it's fine. If `Point` were large, this would be more\n efficient:\n \n-```rust\n+~~~rust\n struct Point {\n     x: int,\n     y: int,\n@@ -236,7 +243,7 @@ fn main() {\n         println(a.x.to_str());\n     }\n }\n-```\n+~~~\n \n Now it'll be copying a pointer-sized chunk of memory rather than the whole\n struct.\n@@ -249,7 +256,7 @@ program is very large and complicated.\n \n For example, let's say you're using an owned pointer, and you want to do this:\n \n-```rust\n+~~~rust {.xfail-test}\n struct Point {\n     x: int,\n     y: int,\n@@ -261,22 +268,22 @@ fn main() {\n     println(b.x.to_str());\n     println(a.x.to_str());\n }\n-```\n+~~~\n \n You'll get this error:\n \n-```\n+~~~ {.notrust}\n test.rs:10:12: 10:13 error: use of moved value: `a`\n test.rs:10     println(a.x.to_str());\n                        ^\n test.rs:8:8: 8:9 note: `a` moved here because it has type `~Point`, which is moved by default (use `ref` to override)\n test.rs:8     let b = a;\n                   ^\n-```\n+~~~\n \n As the message says, owned pointers only allow for one owner at a time. When you assign `a` to `b`, `a` becomes invalid. Change your code to this, however:\n \n-```rust\n+~~~rust\n struct Point {\n     x: int,\n     y: int,\n@@ -288,14 +295,14 @@ fn main() {\n     println(b.x.to_str());\n     println(a.x.to_str());\n }\n-```\n+~~~\n \n And it works:\n \n-```\n+~~~ {.notrust}\n 10\n 10\n-```\n+~~~\n \n So why not just use managed pointers everywhere? There are two big drawbacks to\n managed pointers:\n@@ -315,15 +322,15 @@ data they're pointing to. They're just borrowing it for a while. So in that\n sense, they're simple: just keep whatever ownership the data already has. For\n example:\n \n-```rust\n+~~~rust\n use std::num::sqrt;\n \n struct Point {\n-    x: float,\n-    y: float,\n+    x: f32,\n+    y: f32,\n }\n \n-fn compute_distance(p1: &Point, p2: &Point) -> float {\n+fn compute_distance(p1: &Point, p2: &Point) -> f32 {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n \n@@ -336,7 +343,7 @@ fn main() {\n \n     println!(\"{:?}\", compute_distance(origin, p1));\n }\n-```\n+~~~\n \n This prints `5.83095189`. You can see that the `compute_distance` function\n takes in two borrowed pointers, but we give it a managed and unique pointer. Of\n@@ -353,19 +360,19 @@ This theory is called 'region pointers,' and involve a concept called\n 'lifetimes'. Here's the simple explanation: would you expect this code to\n compile?\n \n-```rust\n+~~~rust {.xfail-test}\n fn main() {\n     println(x.to_str());\n     let x = 5;\n }\n-```\n+~~~\n \n Probably not. That's becuase you know that the name `x` is valid from where\n it's declared to when it goes out of scope. In this case, that's the end of\n the `main` function. So you know this code will cause an error. We call this\n duration a 'lifetime'. Let's try a more complex example:\n \n-```rust\n+~~~rust\n fn main() {\n     let mut x = ~5;\n     if(*x < 10) {\n@@ -376,13 +383,13 @@ fn main() {\n     *x = *x - 1;\n     println!(\"Oh no: {:?}\", x);\n }\n-```\n+~~~\n \n Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however,\n is able to determine that that pointer will go out of scope without `x` being\n mutated, and therefore, lets us pass. This wouldn't work:\n \n-```rust\n+~~~rust {.xfail-test}\n fn main() {\n     let mut x = ~5;\n     if(*x < 10) {\n@@ -395,18 +402,18 @@ fn main() {\n     *x = *x - 1;\n     println!(\"Oh no: {:?}\", x);\n }\n-```\n+~~~\n \n It gives this error:\n \n-```\n+~~~ {.notrust}\n test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n test.rs:5         *x = *x - 1;\n                   ^~\n test.rs:4:16: 4:18 note: borrow of `*x` occurs here\n test.rs:4         let y = &x;\n                           ^~\n-```\n+~~~\n \n As you might guess, this kind of analysis is complex for a human, and therefore\n hard for a computer, too! There is an entire [tutorial devoted to borrowed\n@@ -421,7 +428,7 @@ managed pointer if you were given one in the first place.\n \n What does that mean? Don't do this:\n \n-```rust\n+~~~rust\n fn foo(x: ~int) -> ~int {\n     return ~*x;\n }\n@@ -430,11 +437,11 @@ fn main() {\n     let x = ~5;\n     let y = foo(x);\n }\n-```\n+~~~\n \n Do this:\n \n-```rust\n+~~~rust\n fn foo(x: ~int) -> int {\n     return *x;\n }\n@@ -443,12 +450,12 @@ fn main() {\n     let x = ~5;\n     let y = ~foo(x);\n }\n-```\n+~~~\n \n This gives you flexibility, without sacrificing performance. For example, this will\n also work:\n \n-```rust\n+~~~rust\n fn foo(x: ~int) -> int {\n     return *x;\n }\n@@ -457,7 +464,7 @@ fn main() {\n     let x = ~5;\n     let y = @foo(x);\n }\n-```\n+~~~\n \n You may think that this gives us terrible performance: return a value and then\n immediately box it up?!?! Isn't that the worst of both worlds? Rust is smarter"}]}