{"sha": "c640c2ea114f21bc6e4913dac38cdc451c41ceae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NDBjMmVhMTE0ZjIxYmM2ZTQ5MTNkYWMzOGNkYzQ1MWM0MWNlYWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-14T16:24:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-15T15:52:28Z"}, "message": "Make syntax highlighting linear", "tree": {"sha": "4e74764452cdc5ed3d6073d19a5171c074e86aed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e74764452cdc5ed3d6073d19a5171c074e86aed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c640c2ea114f21bc6e4913dac38cdc451c41ceae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c640c2ea114f21bc6e4913dac38cdc451c41ceae", "html_url": "https://github.com/rust-lang/rust/commit/c640c2ea114f21bc6e4913dac38cdc451c41ceae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c640c2ea114f21bc6e4913dac38cdc451c41ceae/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e70fc22a79ad2eb4deeb6465799f03e7580fee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e70fc22a79ad2eb4deeb6465799f03e7580fee1", "html_url": "https://github.com/rust-lang/rust/commit/7e70fc22a79ad2eb4deeb6465799f03e7580fee1"}], "stats": {"total": 135, "additions": 78, "deletions": 57}, "files": [{"sha": "00541dbe1201a43248382b3c2325c75fa8504090", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=c640c2ea114f21bc6e4913dac38cdc451c41ceae", "patch": "@@ -8,8 +8,8 @@ use hir_def::{\n     dyn_map::DynMap,\n     keys::{self, Key},\n     resolver::{HasResolver, Resolver},\n-    ConstId, DefWithBodyId, EnumId, FunctionId, ImplId, ModuleId, StaticId, StructId, TraitId,\n-    UnionId, VariantId,\n+    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, ImplId, ModuleId, StaticId,\n+    StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n use hir_expand::InFile;\n use ra_prof::profile;\n@@ -166,6 +166,8 @@ to_id_impls![\n     (FunctionId, ast::FnDef, keys::FUNCTION),\n     (StaticId, ast::StaticDef, keys::STATIC),\n     (ConstId, ast::ConstDef, keys::CONST),\n-    // (TypeAlias, TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n+    (TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n     (ImplId, ast::ImplBlock, keys::IMPL),\n+    (StructFieldId, ast::RecordFieldDef, keys::RECORD_FIELD),\n+    (EnumVariantId, ast::EnumVariant, keys::ENUM_VARIANT),\n ];"}, {"sha": "2b74d76538e4b6dcb927949984ade803556ea32b", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=c640c2ea114f21bc6e4913dac38cdc451c41ceae", "patch": "@@ -29,7 +29,7 @@ use crate::{\n };\n \n pub(crate) use self::{\n-    classify::{classify_name, classify_name_ref},\n+    classify::{classify_name, classify_name2, classify_name_ref, classify_name_ref2},\n     name_definition::{NameDefinition, NameKind},\n     rename::rename,\n };\n@@ -309,7 +309,7 @@ mod tests {\n     }\n     impl Foo {\n         fn f() -> i32 { 42 }\n-    }    \n+    }\n     fn main() {\n         let f: Foo;\n         f = Foo {a: Foo::f()};\n@@ -319,7 +319,7 @@ mod tests {\n         check_result(\n             refs,\n             \"Foo STRUCT_DEF FileId(1) [5; 39) [12; 15) Other\",\n-            &[\"FileId(1) [142; 145) StructLiteral\"],\n+            &[\"FileId(1) [138; 141) StructLiteral\"],\n         );\n     }\n "}, {"sha": "9778ca5365122958a0971556e17226c59708b0b0", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=c640c2ea114f21bc6e4913dac38cdc451c41ceae", "patch": "@@ -1,6 +1,6 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{FromSource, InFile, Module, ModuleSource, PathResolution, SourceAnalyzer};\n+use hir::{FromSource, InFile, Module, ModuleSource, PathResolution, SourceBinder};\n use ra_prof::profile;\n use ra_syntax::{ast, match_ast, AstNode};\n use test_utils::tested_by;\n@@ -12,97 +12,104 @@ use super::{\n use crate::db::RootDatabase;\n \n pub(crate) fn classify_name(db: &RootDatabase, name: InFile<&ast::Name>) -> Option<NameDefinition> {\n+    let mut sb = SourceBinder::new(db);\n+    classify_name2(&mut sb, name)\n+}\n+\n+pub(crate) fn classify_name2(\n+    sb: &mut SourceBinder<RootDatabase>,\n+    name: InFile<&ast::Name>,\n+) -> Option<NameDefinition> {\n     let _p = profile(\"classify_name\");\n     let parent = name.value.syntax().parent()?;\n \n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n                 let src = name.with_value(it);\n-                let local = hir::Local::from_source(db, src)?;\n+                let local = hir::Local::from_source(sb.db, src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: local.module(db),\n+                    container: local.module(sb.db),\n                     kind: NameKind::Local(local),\n                 })\n             },\n             ast::RecordFieldDef(it) => {\n-                let ast = hir::FieldSource::Named(it);\n-                let src = name.with_value(ast);\n-                let field = hir::StructField::from_source(db, src)?;\n-                Some(from_struct_field(db, field))\n+                let src = name.with_value(it);\n+                let field: hir::StructField = sb.to_def(src)?;\n+                Some(from_struct_field(sb.db, field))\n             },\n             ast::Module(it) => {\n                 let def = {\n                     if !it.has_semi() {\n                         let ast = hir::ModuleSource::Module(it);\n                         let src = name.with_value(ast);\n-                        hir::Module::from_definition(db, src)\n+                        hir::Module::from_definition(sb.db, src)\n                     } else {\n                         let src = name.with_value(it);\n-                        hir::Module::from_declaration(db, src)\n+                        hir::Module::from_declaration(sb.db, src)\n                     }\n                 }?;\n-                Some(from_module_def(db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::StructDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Struct::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Struct = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::EnumDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Enum::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Enum = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::TraitDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Trait::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Trait = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::StaticDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Static::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Static = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::EnumVariant(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::EnumVariant::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::EnumVariant = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::FnDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Function::from_source(db, src)?;\n+                let def: hir::Function = sb.to_def(src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(db, def.into()))\n+                    Some(from_assoc_item(sb.db, def.into()))\n                 } else {\n-                    Some(from_module_def(db, def.into(), None))\n+                    Some(from_module_def(sb.db, def.into(), None))\n                 }\n             },\n             ast::ConstDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Const::from_source(db, src)?;\n+                let def: hir::Const = sb.to_def(src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(db, def.into()))\n+                    Some(from_assoc_item(sb.db, def.into()))\n                 } else {\n-                    Some(from_module_def(db, def.into(), None))\n+                    Some(from_module_def(sb.db, def.into(), None))\n                 }\n             },\n             ast::TypeAliasDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::TypeAlias::from_source(db, src)?;\n+                let def: hir::TypeAlias = sb.to_def(src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(db, def.into()))\n+                    Some(from_assoc_item(sb.db, def.into()))\n                 } else {\n-                    Some(from_module_def(db, def.into(), None))\n+                    Some(from_module_def(sb.db, def.into(), None))\n                 }\n             },\n             ast::MacroCall(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::MacroDef::from_source(db, src.clone())?;\n+                let def = hir::MacroDef::from_source(sb.db, src.clone())?;\n \n-                let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n-                let module = Module::from_definition(db, src.with_value(module_src))?;\n+                let module_src = ModuleSource::from_child_node(sb.db, src.as_ref().map(|it| it.syntax()));\n+                let module = Module::from_definition(sb.db, src.with_value(module_src))?;\n \n                 Some(NameDefinition {\n                     visibility: None,\n@@ -112,10 +119,10 @@ pub(crate) fn classify_name(db: &RootDatabase, name: InFile<&ast::Name>) -> Opti\n             },\n             ast::TypeParam(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::TypeParam::from_source(db, src)?;\n+                let def = hir::TypeParam::from_source(sb.db, src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: def.module(db),\n+                    container: def.module(sb.db),\n                     kind: NameKind::TypeParam(def),\n                 })\n             },\n@@ -127,54 +134,64 @@ pub(crate) fn classify_name(db: &RootDatabase, name: InFile<&ast::Name>) -> Opti\n pub(crate) fn classify_name_ref(\n     db: &RootDatabase,\n     name_ref: InFile<&ast::NameRef>,\n+) -> Option<NameDefinition> {\n+    let mut sb = SourceBinder::new(db);\n+    classify_name_ref2(&mut sb, name_ref)\n+}\n+\n+pub(crate) fn classify_name_ref2(\n+    sb: &mut SourceBinder<RootDatabase>,\n+    name_ref: InFile<&ast::NameRef>,\n ) -> Option<NameDefinition> {\n     let _p = profile(\"classify_name_ref\");\n \n     let parent = name_ref.value.syntax().parent()?;\n-    let analyzer = SourceAnalyzer::new(db, name_ref.map(|it| it.syntax()), None);\n+    let analyzer = sb.analyze(name_ref.map(|it| it.syntax()), None);\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(from_assoc_item(db, func.into()));\n+            return Some(from_assoc_item(sb.db, func.into()));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_fields);\n         if let Some(field) = analyzer.resolve_field(&field_expr) {\n-            return Some(from_struct_field(db, field));\n+            return Some(from_struct_field(sb.db, field));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n         tested_by!(goto_def_for_record_fields);\n         tested_by!(goto_def_for_field_init_shorthand);\n         if let Some(field_def) = analyzer.resolve_record_field(&record_field) {\n-            return Some(from_struct_field(db, field_def));\n+            return Some(from_struct_field(sb.db, field_def));\n         }\n     }\n \n-    let ast = ModuleSource::from_child_node(db, name_ref.with_value(&parent));\n+    let ast = ModuleSource::from_child_node(sb.db, name_ref.with_value(&parent));\n     // FIXME: find correct container and visibility for each case\n-    let container = Module::from_definition(db, name_ref.with_value(ast))?;\n+    let container = Module::from_definition(sb.db, name_ref.with_value(ast))?;\n     let visibility = None;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n-        if let Some(macro_def) = analyzer.resolve_macro_call(db, name_ref.with_value(&macro_call)) {\n+        if let Some(macro_def) =\n+            analyzer.resolve_macro_call(sb.db, name_ref.with_value(&macro_call))\n+        {\n             let kind = NameKind::Macro(macro_def);\n             return Some(NameDefinition { kind, container, visibility });\n         }\n     }\n \n     let path = name_ref.value.syntax().ancestors().find_map(ast::Path::cast)?;\n-    let resolved = analyzer.resolve_path(db, &path)?;\n+    let resolved = analyzer.resolve_path(sb.db, &path)?;\n     match resolved {\n-        PathResolution::Def(def) => Some(from_module_def(db, def, Some(container))),\n-        PathResolution::AssocItem(item) => Some(from_assoc_item(db, item)),\n+        PathResolution::Def(def) => Some(from_module_def(sb.db, def, Some(container))),\n+        PathResolution::AssocItem(item) => Some(from_assoc_item(sb.db, item)),\n         PathResolution::Local(local) => {\n-            let container = local.module(db);\n+            let container = local.module(sb.db);\n             let kind = NameKind::Local(local);\n             Some(NameDefinition { kind, container, visibility: None })\n         }\n@@ -188,7 +205,7 @@ pub(crate) fn classify_name_ref(\n         }\n         PathResolution::SelfType(impl_block) => {\n             let kind = NameKind::SelfType(impl_block);\n-            let container = impl_block.module(db);\n+            let container = impl_block.module(sb.db);\n             Some(NameDefinition { kind, container, visibility })\n         }\n     }"}, {"sha": "fd422d07cc2a47c667918d3089287c0cc7d1f5dd", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c640c2ea114f21bc6e4913dac38cdc451c41ceae/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=c640c2ea114f21bc6e4913dac38cdc451c41ceae", "patch": "@@ -2,15 +2,15 @@\n \n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{InFile, Name};\n+use hir::{InFile, Name, SourceBinder};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n \n use crate::{\n     db::RootDatabase,\n     references::{\n-        classify_name, classify_name_ref,\n+        classify_name2, classify_name_ref2,\n         NameKind::{self, *},\n     },\n     FileId,\n@@ -84,6 +84,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n         hash((file_id, name, shadow_count))\n     }\n \n+    let mut sb = SourceBinder::new(db);\n+\n     // Visited nodes to handle highlighting priorities\n     // FIXME: retain only ranges here\n     let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n@@ -108,8 +110,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => continue,\n             NAME_REF => {\n                 let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n-                let name_kind =\n-                    classify_name_ref(db, InFile::new(file_id.into(), &name_ref)).map(|d| d.kind);\n+                let name_kind = classify_name_ref2(&mut sb, InFile::new(file_id.into(), &name_ref))\n+                    .map(|d| d.kind);\n                 match name_kind {\n                     Some(name_kind) => {\n                         if let Local(local) = &name_kind {\n@@ -129,7 +131,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             NAME => {\n                 let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n                 let name_kind =\n-                    classify_name(db, InFile::new(file_id.into(), &name)).map(|d| d.kind);\n+                    classify_name2(&mut sb, InFile::new(file_id.into(), &name)).map(|d| d.kind);\n \n                 if let Some(Local(local)) = &name_kind {\n                     if let Some(name) = local.name(db) {"}]}