{"sha": "ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOThjNTk1ZWFhMDcyNDllMmViYmYzN2M5MTIzYjMzZmM2YTg5MmY=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-10-24T04:38:01Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:31:35Z"}, "message": "Fix a large number of Body -> (ReadOnly)BodyCache type errors, add predecessor_locations fn to ReadOnlyBodyCache", "tree": {"sha": "f39badabf4198291c1899b4a4486f90146ab79f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f39badabf4198291c1899b4a4486f90146ab79f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "html_url": "https://github.com/rust-lang/rust/commit/ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eed90a621f40aa3a2d56eda16f25315d17c4ca8", "html_url": "https://github.com/rust-lang/rust/commit/2eed90a621f40aa3a2d56eda16f25315d17c4ca8"}], "stats": {"total": 390, "additions": 207, "deletions": 183}, "files": [{"sha": "c0c5f77fe6ea93fef0694d3b549719f2c3cef133", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -33,6 +33,41 @@ pub struct Cache {\n //    }\n //}\n \n+macro_rules! get_predecessors {\n+    (mut $self:ident, $block:expr, $body:expr) => {\n+        $self.predecessors_for($block, $body)\n+    };\n+    ($self:ident, $block:expr, $body:expr) => {\n+        $self.unwrap_predecessors_for($block)\n+    };\n+}\n+\n+macro_rules! impl_predecessor_locations {\n+    ( ( $($pub:ident)? )  $name:ident $($mutability:ident)?) => {\n+        $($pub)? fn $name<'a>(&'a $($mutability)? self, loc: Location, body: &'a Body<'a>) -> impl Iterator<Item = Location> + 'a {\n+            let if_zero_locations = if loc.statement_index == 0 {\n+                let predecessor_blocks = get_predecessors!($($mutability)? self, loc.block, body);\n+                let num_predecessor_blocks = predecessor_blocks.len();\n+                Some(\n+                    (0..num_predecessor_blocks)\n+                        .map(move |i| predecessor_blocks[i])\n+                        .map(move |bb| body.terminator_loc(bb)),\n+                )\n+            } else {\n+                None\n+            };\n+\n+            let if_not_zero_locations = if loc.statement_index == 0 {\n+                None\n+            } else {\n+                Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n+            };\n+\n+            if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n+        }\n+    };\n+}\n+\n impl Cache {\n     pub fn new() -> Self {\n         Self {\n@@ -80,27 +115,9 @@ impl Cache {\n     }\n \n     #[inline]\n-    pub fn predecessor_locations<'a>(&'a mut self, loc: Location, body: &'a Body<'a>) -> impl Iterator<Item = Location> + 'a {\n-        let if_zero_locations = if loc.statement_index == 0 {\n-            let predecessor_blocks = self.predecessors_for(loc.block, body);\n-            let num_predecessor_blocks = predecessor_blocks.len();\n-            Some(\n-                (0..num_predecessor_blocks)\n-                    .map(move |i| predecessor_blocks[i])\n-                    .map(move |bb| body.terminator_loc(bb)),\n-            )\n-        } else {\n-            None\n-        };\n-\n-        let if_not_zero_locations = if loc.statement_index == 0 {\n-            None\n-        } else {\n-            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n-        };\n-\n-        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n-    }\n+    impl_predecessor_locations!((pub) predecessor_locations mut);\n+\n+    impl_predecessor_locations!(() unwrap_predecessor_locations);\n \n     #[inline]\n     pub fn basic_blocks_mut<'a, 'tcx>(&mut self, body: &'a mut Body<'tcx>) -> &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n@@ -240,6 +257,11 @@ impl ReadOnlyBodyCache<'a, 'tcx> {\n         self.cache.unwrap_predecessors_for(bb)\n     }\n \n+    #[inline]\n+    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n+        self.cache.unwrap_predecessor_locations(loc, self.body)\n+    }\n+\n     #[inline]\n     pub fn body(&self) -> &'a Body<'tcx> {\n         self.body"}, {"sha": "6191a93d228789d221065b24119cfb43c2dee4f2", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -5,7 +5,7 @@ use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n use rustc::mir::visit::{PlaceContext, Visitor, NonUseContext, MutatingUseContext};\n-use rustc::mir::{self, Location, Body, Local};\n+use rustc::mir::{self, Location, Body, Local, ReadOnlyBodyCache};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_index::vec::IndexVec;\n@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        body: &Body<'tcx>,\n+        body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -106,8 +106,8 @@ impl LocalsStateAtExit {\n         if locals_are_invalidated_at_exit {\n             LocalsStateAtExit::AllAreInvalidated\n         } else {\n-            let mut has_storage_dead = HasStorageDead(BitSet::new_empty(body.local_decls.len()));\n-            has_storage_dead.visit_body(body);\n+            let mut has_storage_dead = HasStorageDead(BitSet::new_empty(body_cache.local_decls.len()));\n+            has_storage_dead.visit_body(body_cache);\n             let mut has_storage_dead_or_moved = has_storage_dead.0;\n             for move_out in &move_data.moves {\n                 if let Some(index) = move_data.base_local(move_out.path) {\n@@ -123,23 +123,23 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'tcx>,\n-        body: &Body<'tcx>,\n+        body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>,\n     ) -> Self {\n         let mut visitor = GatherBorrows {\n             tcx,\n-            body,\n+            body: body_cache.body(),\n             idx_vec: IndexVec::new(),\n             location_map: Default::default(),\n             activation_map: Default::default(),\n             local_map: Default::default(),\n             pending_activations: Default::default(),\n             locals_state_at_exit:\n-                LocalsStateAtExit::build(locals_are_invalidated_at_exit, body, move_data),\n+                LocalsStateAtExit::build(locals_are_invalidated_at_exit, body_cache, move_data),\n         };\n \n-        for (block, block_data) in traversal::preorder(body) {\n+        for (block, block_data) in traversal::preorder(body_cache) {\n             visitor.visit_basic_block_data(block, block_data);\n         }\n "}, {"sha": "b44ef1c1706a49249eca9842ff2c348264a2631d", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -206,7 +206,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             let ty =\n-                Place::ty_from(used_place.base, used_place.projection, self.body, self.infcx.tcx)\n+                Place::ty_from(used_place.base, used_place.projection, self.body_cache.body(), self.infcx.tcx)\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n@@ -222,7 +222,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(self.body, self.infcx.tcx).ty;\n+                let ty = place.ty(self.body_cache.body(), self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -314,7 +314,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         ).add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body_cache,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -356,7 +356,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n-                self.body,\n+                &self.body_cache,\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n@@ -578,7 +578,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body_cache,\n             &self.local_names,\n             &mut err,\n             first_borrow_desc,\n@@ -619,7 +619,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let union_ty = |place_base, place_projection| {\n-            let ty = Place::ty_from(place_base, place_projection, self.body, self.infcx.tcx).ty;\n+            let ty = Place::ty_from(place_base, place_projection, self.body_cache.body(), self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n         let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n@@ -738,7 +738,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         assert!(root_place.projection.is_empty());\n         let proper_span = match root_place.base {\n-            PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n+            PlaceBase::Local(local) => self.body_cache.local_decls[*local].source_info.span,\n             _ => drop_span,\n         };\n \n@@ -965,7 +965,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } else {\n                 explanation.add_explanation_to_diagnostic(\n                     self.infcx.tcx,\n-                    self.body,\n+                    &self.body_cache,\n                     &self.local_names,\n                     &mut err,\n                     \"\",\n@@ -991,7 +991,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n \n             explanation.add_explanation_to_diagnostic(\n-                self.infcx.tcx, self.body, &self.local_names, &mut err, \"\", None);\n+                self.infcx.tcx, &self.body_cache, &self.local_names, &mut err, \"\", None);\n         }\n \n         err\n@@ -1051,7 +1051,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body_cache,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -1138,7 +1138,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body_cache,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -1174,15 +1174,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         // FIXME use a better heuristic than Spans\n-        let reference_desc = if return_span == self.body.source_info(borrow.reserve_location).span {\n+        let reference_desc = if return_span == self.body_cache.source_info(borrow.reserve_location).span {\n             \"reference to\"\n         } else {\n             \"value referencing\"\n         };\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n-                match self.body.local_kind(local) {\n+                match self.body_cache.local_kind(local) {\n                     LocalKind::ReturnPointer\n                     | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n                     LocalKind::Var => \"local variable \",\n@@ -1215,7 +1215,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } else {\n                 bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n             };\n-            match self.body.local_kind(*local) {\n+            match self.body_cache.local_kind(*local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => (\n                     \"temporary value\".to_string(),\n                     \"temporary value created here\".to_string(),\n@@ -1372,10 +1372,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n-        let body = self.body;\n-\n         let mut stack = Vec::new();\n-        stack.extend(body.predecessor_locations(location).map(|predecessor| {\n+        stack.extend(self.body_cache.predecessor_locations(location).map(|predecessor| {\n             let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n@@ -1394,7 +1392,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             // check for moves\n-            let stmt_kind = body[location.block]\n+            let stmt_kind = self.body_cache[location.block]\n                 .statements\n                 .get(location.statement_index)\n                 .map(|s| &s.kind);\n@@ -1449,7 +1447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut any_match = false;\n             drop_flag_effects::for_location_inits(\n                 self.infcx.tcx,\n-                self.body,\n+                &self.body_cache,\n                 self.move_data,\n                 location,\n                 |m| {\n@@ -1462,7 +1460,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 continue 'dfs;\n             }\n \n-            stack.extend(body.predecessor_locations(location).map(|predecessor| {\n+            stack.extend(self.body_cache.predecessor_locations(location).map(|predecessor| {\n                 let back_edge = location.dominates(predecessor, &self.dominators);\n                 (predecessor, is_back_edge || back_edge)\n             }));\n@@ -1514,7 +1512,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.explain_why_borrow_contains_point(location, loan, None)\n             .add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n-                self.body,\n+                &self.body_cache,\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n@@ -1539,8 +1537,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         let (from_arg, local_decl, local_name) = match err_place.as_local() {\n             Some(local) => (\n-                self.body.local_kind(local) == LocalKind::Arg,\n-                Some(&self.body.local_decls[local]),\n+                self.body_cache.local_kind(local) == LocalKind::Arg,\n+                Some(&self.body_cache.local_decls[local]),\n                 self.local_names[local],\n             ),\n             None => (false, None, None),\n@@ -1625,15 +1623,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.base, proj_base, self.body, tcx).ty.is_box(),\n+                                Place::ty_from(&place.base, proj_base, self.body_cache.body(), tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, self.body_cache.body(), tcx).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1721,22 +1719,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location\n         );\n         if let Some(&Statement { kind: StatementKind::Assign(box(ref reservation, _)), ..})\n-             = &self.body[location.block].statements.get(location.statement_index)\n+             = &self.body_cache[location.block].statements.get(location.statement_index)\n         {\n             debug!(\n                 \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n                 reservation\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n             let mut target = match reservation.as_local() {\n-                Some(local) if self.body.local_kind(local) == LocalKind::Temp => local,\n+                Some(local) if self.body_cache.local_kind(local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n             // Next, look through the rest of the block, checking if we are assigning the\n             // `target` (that is, the place that contains our borrow) to anything.\n             let mut annotated_closure = None;\n-            for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n+            for stmt in &self.body_cache[location.block].statements[location.statement_index + 1..] {\n                 debug!(\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt\n@@ -1861,7 +1859,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             // Check the terminator if we didn't find anything in the statements.\n-            let terminator = &self.body[location.block].terminator();\n+            let terminator = &self.body_cache[location.block].terminator();\n             debug!(\n                 \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n                 target, terminator"}, {"sha": "8267e5c1c4bd20cc491e624a7c4b20277c95f550", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -39,7 +39,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n         let mut target = place.local_or_deref_local();\n-        for stmt in &self.body[location.block].statements[location.statement_index..] {\n+        for stmt in &self.body_cache[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n             if let StatementKind::Assign(box(into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n@@ -53,7 +53,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         // Check if we are attempting to call a closure after it has been invoked.\n-        let terminator = self.body[location.block].terminator();\n+        let terminator = self.body_cache[location.block].terminator();\n         debug!(\"add_moved_or_invoked_closure_note: terminator={:?}\", terminator);\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n@@ -76,7 +76,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 };\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n-                if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n+                if let ty::Closure(did, _) = self.body_cache.local_decls[closure].ty.kind {\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                     if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -99,7 +99,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n-            if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n+            if let ty::Closure(did, _) = self.body_cache.local_decls[target].ty.kind {\n                 let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                 if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -332,7 +332,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n     /// a name, or its name was generated by the compiler, then `Err` is returned\n     fn append_local_to_string(&self, local: Local, buf: &mut String) -> Result<(), ()> {\n-        let decl = &self.body.local_decls[local];\n+        let decl = &self.body_cache.local_decls[local];\n         match self.local_names[local] {\n             Some(name) if !decl.from_compiler_desugaring() => {\n                 buf.push_str(&name.as_str());\n@@ -350,7 +350,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n             } => {\n-                let local = &self.body.local_decls[*local];\n+                let local = &self.body_cache.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef {\n@@ -370,7 +370,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n-                        Place::ty_from(place.base, place.projection, self.body, self.infcx.tcx).ty;\n+                        Place::ty_from(place.base, place.projection, self.body_cache.body(), self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -481,7 +481,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         _ => continue,\n                     };\n \n-                    let bbd = &self.body[loc.block];\n+                    let bbd = &self.body_cache[loc.block];\n                     let is_terminator = bbd.statements.len() == loc.statement_index;\n                     debug!(\n                         \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n@@ -499,7 +499,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ..\n                     }) = bbd.terminator {\n                         if let Some(source)\n-                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n+                            = BorrowedContentSource::from_call(func.ty(self.body_cache.body(), tcx), tcx)\n                         {\n                             return source;\n                         }\n@@ -512,7 +512,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.base, deref_base.projection, self.body, tcx).ty;\n+        let base_ty = Place::ty_from(deref_base.base, deref_base.projection, self.body_cache.body(), tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {\n@@ -767,9 +767,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> UseSpans {\n         use self::UseSpans::*;\n \n-        let stmt = match self.body[location.block].statements.get(location.statement_index) {\n+        let stmt = match self.body_cache[location.block].statements.get(location.statement_index) {\n             Some(stmt) => stmt,\n-            None => return OtherUse(self.body.source_info(location).span),\n+            None => return OtherUse(self.body_cache.source_info(location).span),\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n@@ -807,7 +807,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         use self::UseSpans::*;\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n-        let target = match self.body[location.block]\n+        let target = match self.body_cache[location.block]\n             .statements\n             .get(location.statement_index)\n         {\n@@ -824,12 +824,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             _ => return OtherUse(use_span),\n         };\n \n-        if self.body.local_kind(target) != LocalKind::Temp {\n+        if self.body_cache.local_kind(target) != LocalKind::Temp {\n             // operands are always temporaries.\n             return OtherUse(use_span);\n         }\n \n-        for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n+        for stmt in &self.body_cache[location.block].statements[location.statement_index + 1..] {\n             if let StatementKind::Assign(\n                 box(_, Rvalue::Aggregate(ref kind, ref places))\n             ) = stmt.kind {\n@@ -901,7 +901,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n     pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans {\n-        let span = self.body.source_info(borrow.reserve_location).span;\n+        let span = self.body_cache.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }\n }"}, {"sha": "0c1b0c4e14eddaae099292cef6955f7b8532b3af", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -10,7 +10,7 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n     ClearCrossCrate, Local, Location, Body, BodyCache, Mutability, Operand, Place, PlaceBase,\n-    PlaceElem, PlaceRef, Static, StaticKind\n+    PlaceElem, PlaceRef, ReadOnlyBodyCache, Static, StaticKind\n };\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -163,16 +163,19 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n     let mut body: Body<'tcx> = input_body.clone();\n-    let mut promoted: IndexVec<Promoted, Body<'tcx>> = input_promoted.clone();\n+    // TODO(pfaria) this very likely won't work because\n+    let promoted: IndexVec<Promoted, Body<'tcx>> = input_promoted.clone();\n+    let mut promoted_cache: IndexVec<Promoted, BodyCache<&mut Body<'tcx>>> = promoted.iter_mut().map(|body| BodyCache::new(body)).collect();\n+    let mut body_cache = BodyCache::new(&mut body);\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body_cache, &mut promoted_cache);\n+    let body_cache = BodyCache::new(&body).read_only(); // no further changes\n \n-    let body_cache = &BodyCache::new(&body); // no further changes\n-    let location_table = &LocationTable::new(body_cache);\n+    let location_table = &LocationTable::new(&body_cache);\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(body_cache, tcx) {\n+        match MoveData::gather_moves(&body_cache, tcx) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -185,24 +188,24 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body_cache,\n+        &body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, body_cache, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, &body_cache, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n-            tcx, body_cache, locals_are_invalidated_at_exit, &mdpe.move_data));\n+            tcx, &body_cache, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n         infcx,\n         def_id,\n         free_regions,\n-        body_cache,\n+        &body_cache,\n         &promoted,\n         &local_names,\n         &upvars,\n@@ -223,29 +226,29 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body_cache,\n+        &body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, body_cache, param_env, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, &body_cache, param_env, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body_cache,\n+        &body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, body_cache, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, &body_cache, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body_cache,\n+        &body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, body_cache, &mdpe),\n+        EverInitializedPlaces::new(tcx, &body_cache, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n@@ -302,7 +305,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n \n         let scope = mbcx.body.source_info(location).scope;\n-        let lint_root = match &mbcx.body.source_scopes[scope].local_data {\n+        let lint_root = match &mbcx.body_cache.source_scopes[scope].local_data {\n             ClearCrossCrate::Set(data) => data.lint_root,\n             _ => id,\n         };\n@@ -324,21 +327,21 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n-        .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n+        .filter(|&local| !mbcx.body_cache.local_decls[*local].is_user_variable())\n         .cloned()\n         .collect();\n     // For the remaining unused locals that are marked as mutable, we avoid linting any that\n     // were never initialized. These locals may have been removed as unreachable code; or will be\n     // linted as unused variables.\n-    let unused_mut_locals = mbcx.body.mut_vars_iter()\n+    let unused_mut_locals = mbcx.body_cache.mut_vars_iter()\n         .filter(|local| !mbcx.used_mut.contains(local))\n         .collect();\n     mbcx.gather_used_muts(temporary_used_locals, unused_mut_locals);\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n     let used_mut = mbcx.used_mut;\n-    for local in mbcx.body.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {\n-        let local_decl = &mbcx.body.local_decls[local];\n+    for local in mbcx.body_cache.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {\n+        let local_decl = &mbcx.body_cache.local_decls[local];\n         let lint_root = match &mbcx.body.source_scopes[local_decl.source_info.scope].local_data {\n             ClearCrossCrate::Set(data) => data.lint_root,\n             _ => continue,\n@@ -399,7 +402,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    body_cache: BodyCache<&'cx Body<'tcx>>,\n+    body_cache: ReadOnlyBodyCache<'cx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     move_data: &'cx MoveData<'tcx>,\n@@ -490,7 +493,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     type FlowState = Flows<'cx, 'tcx>;\n \n     fn body(&self) -> &'cx Body<'tcx> {\n-        self.body_cache\n+        &self.body_cache\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n@@ -640,7 +643,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.body_cache, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(self.body_cache.body(), self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -984,7 +987,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n-        let body = self.body_cache;\n+        let body = self.body_cache.body();\n         let param_env = self.param_env;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n@@ -1150,7 +1153,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n         if let Some(local) = place_span.0.as_local() {\n-            if let Mutability::Not = self.body.local_decls[local].mutability {\n+            if let Mutability::Not = self.body+cache.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n@@ -1303,7 +1306,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 match place.as_local() {\n-                    Some(local) if !self.body.local_decls[local].is_user_variable() => {\n+                    Some(local) if !self.body_cache.local_decls[local].is_user_variable() => {\n                         if self.body.local_decls[local].ty.is_mutable_ptr() {\n                             // The variable will be marked as mutable by the borrow.\n                             return;\n@@ -1335,7 +1338,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => bug!(\"temporary initialized in arguments\"),\n                         };\n \n-                        let bbd = &self.body[loc.block];\n+                        let bbd = &self.body_cache[loc.block];\n                         let stmt = &bbd.statements[loc.statement_index];\n                         debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n@@ -1454,7 +1457,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if places_conflict::borrow_conflicts_with_place(\n             self.infcx.tcx,\n             self.param_env,\n-            self.body,\n+            &self.body_cache,\n             place,\n             borrow.kind,\n             root_place,\n@@ -1534,7 +1537,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(init_index) = self.is_local_ever_initialized(local, flow_state) {\n             // And, if so, report an error.\n             let init = &self.move_data.inits[init_index];\n-            let span = init.span(&self.body);\n+            let span = init.span(&self.body_cache);\n             self.report_illegal_reassignment(\n                 location, place_span, span, place_span.0\n             );\n@@ -1745,7 +1748,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body(), tcx).ty;\n                     match base_ty.kind {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n@@ -1852,12 +1855,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.base, base.projection, this.body, tcx).ty.kind\n+                    Place::ty_from(base.base, base.projection, this.body(), tcx).ty.kind\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n-                                location, this.body,\n+                                location, &this.body_cache,\n                             )\n                         }) {\n                             return;\n@@ -2061,7 +2064,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n             } => {\n-                let local = &self.body.local_decls[*local];\n+                let local = &self.body_cache.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n@@ -2122,7 +2125,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, proj_base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, proj_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind {\n@@ -2262,7 +2265,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place_projection {\n             [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, base, self.body, tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.base, base, self.body(), tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator()) &&\n                     (!by_ref || self.upvars[field.index()].by_ref) {"}, {"sha": "5907da09c671a13a74ce42ac3f3a38815e6cced0", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -90,13 +90,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n                     box(place, Rvalue::Use(Operand::Move(move_from)))\n-                )) = self.body.basic_blocks()[location.block]\n+                )) = self.body_cache.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)\n                 {\n                     if let Some(local) = place.as_local() {\n-                        let local_decl = &self.body.local_decls[local];\n+                        let local_decl = &self.body_cache.local_decls[local];\n                         // opt_match_place is the\n                         // match_span is the span of the expression being matched on\n                         // match *x.y { ... }        match_place is Some(*x.y)\n@@ -112,7 +112,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 pat_span: _,\n                             },\n                         ))) = local_decl.local_info {\n-                            let stmt_source_info = self.body.source_info(location);\n+                            let stmt_source_info = self.body_cache.source_info(location);\n                             self.append_binding_error(\n                                 grouped_errors,\n                                 kind,\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(self.body_cache.body(), self.infcx.tcx).ty;\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n@@ -318,7 +318,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             base: PlaceBase::Local(local),\n             projection: [],\n         } = deref_base {\n-            let decl = &self.body.local_decls[*local];\n+            let decl = &self.body_cache.local_decls[*local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of(\n                     span,\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         let move_ty = format!(\n             \"{:?}\",\n-            move_place.ty(self.body, self.infcx.tcx).ty,\n+            move_place.ty(self.body_cache.body(), self.infcx.tcx).ty,\n         );\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n             let is_option = move_ty.starts_with(\"std::option::Option\");\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(self.body_cache.body(), self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(self.body_cache.body(), self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),\n@@ -510,7 +510,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n-            let bind_to = &self.body.local_decls[*local];\n+            let bind_to = &self.body_cache.local_decls[*local];\n             if let LocalInfo::User(\n                 ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     pat_span,\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         binds_to: &[Local],\n     ) {\n         for (j, local) in binds_to.into_iter().enumerate() {\n-            let bind_to = &self.body.local_decls[*local];\n+            let bind_to = &self.body_cache.local_decls[*local];\n             let binding_span = bind_to.source_info.span;\n \n             if j == 0 {"}, {"sha": "654666882cca493e01477212a4c26eb8580e0131", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, proj_base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&the_place_err.base, proj_base, self.body_cache.body(), self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -106,12 +106,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     proj_base.is_empty() &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n+                    debug_assert!(self.body_cache.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n                             the_place_err.base,\n                             the_place_err.projection,\n-                            self.body,\n+                            self.body_cache.body(),\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, self.body_cache.body(), self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n             } if {\n-                self.body.local_decls.get(*local).map(|local_decl| {\n+                self.body_cache.local_decls.get(*local).map(|local_decl| {\n                     if let LocalInfo::User(ClearCrossCrate::Set(\n                         mir::BindingForm::ImplicitSelf(kind)\n                     )) = local_decl.local_info {\n@@ -277,12 +277,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n-            } if self.body.local_decls[*local].can_be_made_mutable() => {\n+            } if self.body_cache.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n                 // mutable).\n-                let local_decl = &self.body.local_decls[*local];\n+                let local_decl = &self.body_cache.local_decls[*local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, self.body_cache.body(), self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -346,7 +346,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_ref_for_guard() => {\n+            } if self.body_cache.local_decls[*local].is_ref_for_guard() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n@@ -363,7 +363,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [ProjectionElem::Deref],\n             } if self.body.local_decls[*local].is_user_variable() =>\n             {\n-                let local_decl = &self.body.local_decls[*local];\n+                let local_decl = &self.body_cache.local_decls[*local];\n                 let suggestion = match local_decl.local_info {\n                     LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n@@ -377,7 +377,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         },\n                     ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n-                        self.body,\n+                        &self.body_cache,\n                         *local,\n                         local_decl,\n                         opt_ty_info,\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n-                    self.body.span,\n+                    self.body_cache.span,\n                     \"consider changing this to accept closures that implement `FnMut`\"\n                 );\n             }"}, {"sha": "4097bfeeb359900cd4c56dd3949a21afcb7e0e87", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -237,7 +237,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n-        let body = self.body;\n+        let body = self.body_cache.body();\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n@@ -297,9 +297,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n-                            self.body,\n-                        &self.local_names,\n-                        &self.upvars,\n+                            &self.body_cache,\n+                            &self.local_names,\n+                            &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n                             borrow_region_vid,\n@@ -365,7 +365,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return outmost_back_edge;\n             }\n \n-            let block = &self.body.basic_blocks()[location.block];\n+            let block = &self.body_cache.basic_blocks()[location.block];\n \n             if location.statement_index < block.statements.len() {\n                 let successor = location.successor_within_block();\n@@ -427,7 +427,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.body.basic_blocks()[from.block];\n+            let block = &self.body_cache.basic_blocks()[from.block];\n \n             if from.statement_index < block.statements.len() {\n                 let successor = from.successor_within_block();\n@@ -475,7 +475,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n             UseSpans::OtherUse(span) => {\n-                let block = &self.body.basic_blocks()[location.block];\n+                let block = &self.body_cache.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n@@ -498,7 +498,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Operand::Copy(place) |\n                             Operand::Move(place) => {\n                                 if let Some(l) = place.as_local() {\n-                                    let local_decl = &self.body.local_decls[l];\n+                                    let local_decl = &self.body_cache.local_decls[l];\n                                     if self.local_names[l].is_none() {\n                                         local_decl.source_info.span\n                                     } else {\n@@ -528,7 +528,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n         // Start at the reserve location, find the place that we want to see cast to a trait object.\n         let location = borrow.reserve_location;\n-        let block = &self.body[location.block];\n+        let block = &self.body_cache[location.block];\n         let stmt = block.statements.get(location.statement_index);\n         debug!(\n             \"was_captured_by_trait_object: location={:?} stmt={:?}\",\n@@ -558,7 +558,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n         while let Some(current_location) = queue.pop() {\n             debug!(\"was_captured_by_trait: target={:?}\", target);\n-            let block = &self.body[current_location.block];\n+            let block = &self.body_cache[current_location.block];\n             // We need to check the current location to find out if it is a terminator.\n             let is_terminator = current_location.statement_index == block.statements.len();\n             if !is_terminator {"}, {"sha": "7cb5b839ceebd327a83c52e8e755955fa17d68fb", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -11,7 +11,7 @@ use crate::borrow_check::path_utils::*;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Body, Place, Rvalue};\n+use rustc::mir::{BasicBlock, Location, Body, Place, ReadOnlyBodyCache, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::TerminatorKind;\n use rustc::mir::{Operand, BorrowKind};\n@@ -22,7 +22,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    body: &Body<'tcx>,\n+    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -31,17 +31,17 @@ pub(super) fn generate_invalidates<'tcx>(\n     }\n \n     if let Some(all_facts) = all_facts {\n-        let dominators = body.dominators();\n+        let dominators = body_cache.dominators();\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,\n             param_env,\n             tcx,\n             location_table,\n-            body,\n+            body: body_cache.body(),\n             dominators,\n         };\n-        ig.visit_body(body);\n+        ig.visit_body(&body_cache);\n     }\n }\n "}, {"sha": "dac5815fada23bc6152b00d4815a50ac070205ce", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -12,7 +12,8 @@ use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements,\n-                 Local, Location, Body, LocalKind, BasicBlock, Promoted};\n+                 Local, Location, Body, BodyCache, LocalKind, BasicBlock,\n+                 Promoted, ReadOnlyBodyCache};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_index::vec::IndexVec;\n use rustc_errors::Diagnostic;\n@@ -54,19 +55,19 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &mut Body<'tcx>,\n-    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+    body_cache: &mut BodyCache<&mut Body<'tcx>>,\n+    promoted: &mut IndexVec<Promoted, BodyCache<&mut Body<'tcx>>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n     let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, body, promoted);\n+    renumber::renumber_mir(infcx, body_cache, promoted);\n \n     let source = MirSource::item(def_id);\n-    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body_cache, |_, _| Ok(()));\n \n     universal_regions\n }\n@@ -157,7 +158,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    body: &Body<'tcx>,\n+    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n     local_names: &IndexVec<Local, Option<Symbol>>,\n     upvars: &[Upvar],\n@@ -180,7 +181,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     let universal_regions = Rc::new(universal_regions);\n \n-    let elements = &Rc::new(RegionValueElements::new(body));\n+    let elements = &Rc::new(RegionValueElements::new(body_cache));\n \n     // Run the MIR type-checker.\n     let MirTypeckResults {\n@@ -189,7 +190,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     } = type_check::type_check(\n         infcx,\n         param_env,\n-        body,\n+        body_cache,\n         promoted,\n         def_id,\n         &universal_regions,\n@@ -205,7 +206,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n-        populate_polonius_move_facts(all_facts, move_data, location_table, body);\n+        populate_polonius_move_facts(all_facts, move_data, location_table, body_cache);\n     }\n \n     // Create the region inference context, taking ownership of the\n@@ -229,7 +230,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,\n-        &body,\n+        body_cache,\n         borrow_set,\n     );\n \n@@ -238,7 +239,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         universal_regions,\n         placeholder_indices,\n         universal_region_relations,\n-        body,\n+        body_cache,\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n@@ -253,7 +254,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         param_env,\n         &mut all_facts,\n         location_table,\n-        &body,\n+        body_cache,\n         borrow_set,\n     );\n \n@@ -283,21 +284,21 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, body, local_names, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, body_cache, local_names, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n         MirSource::item(def_id),\n-        &body,\n+        body_cache,\n         &regioncx,\n         &closure_region_requirements,\n     );\n \n     // We also have a `#[rustc_nll]` annotation that causes us to dump\n     // information\n-    dump_annotation(infcx, &body, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n+    dump_annotation(infcx, body_cache, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n \n     (regioncx, polonius_output, closure_region_requirements)\n }"}, {"sha": "5d1891c0bf64cb28bc35ab7ce99ea1bbeb0116cc", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{BasicBlock, Location, Body};\n+use rustc::mir::{BasicBlock, Location, Body, ReadOnlyBodyCache};\n use rustc::ty::{self, RegionVid};\n use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_data_structures::fx::FxHashMap;\n@@ -92,7 +92,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        body: &Body<'_>,\n+        body_cache: &ReadOnlyBodyCache<'_, '_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {\n@@ -104,9 +104,9 @@ impl RegionValueElements {\n             // If this is a basic block head, then the predecessors are\n             // the terminators of other basic blocks\n             stack.extend(\n-                body.predecessors_for(block)\n+                body_cache.predecessors_for(block)\n                     .iter()\n-                    .map(|&pred_bb| body.terminator_loc(pred_bb))\n+                    .map(|&pred_bb| body_cache.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),\n             );\n         } else {"}, {"sha": "57e977eacba15b5cd69c558a477f85dd7f80b579", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::mir::{Body, Location, PlaceElem, Promoted};\n+use rustc::mir::{Body, BodyCache, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_index::vec::IndexVec;\n@@ -9,19 +9,19 @@ use rustc_index::vec::IndexVec;\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    body: &mut Body<'tcx>,\n-    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+    body_cache: &mut BodyCache<&mut Body<'tcx>>,\n+    promoted: &mut IndexVec<Promoted, BodyCache<&mut Body<'tcx>>>,\n ) {\n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n+    debug!(\"renumber_mir: body.arg_count={:?}\", body_cache.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n \n     for body in promoted.iter_mut() {\n         visitor.visit_body(body);\n     }\n \n-    visitor.visit_body(body);\n+    visitor.visit_body(body_cache);\n }\n \n /// Replaces all regions appearing in `value` with fresh inference"}, {"sha": "2de9f0e12821b6bf1c59dcb9e4e86192fd78f8b6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -115,7 +115,7 @@ mod relate_tys;\n pub(crate) fn type_check<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &Body<'tcx>,\n+    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n@@ -161,15 +161,15 @@ pub(crate) fn type_check<'tcx>(\n         infcx,\n         mir_def_id,\n         param_env,\n-        body,\n+        body_cache,\n         promoted,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n         &universal_region_relations,\n         |mut cx| {\n-            cx.equate_inputs_and_outputs(body, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n+            cx.equate_inputs_and_outputs(body_cache, universal_regions, &normalized_inputs_and_output);\n+            liveness::generate(&mut cx, body_cache, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(cx.borrowck_context);\n         },\n@@ -185,7 +185,7 @@ fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n+    body_cache: &ReadOnlyBodyCache<'a, 'tcx>,\n     promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n@@ -195,7 +195,7 @@ fn type_check_internal<'a, 'tcx, R>(\n ) -> R where {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        body,\n+        body_cache,\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -204,14 +204,14 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n-        verifier.visit_body(body);\n+        let mut verifier = TypeVerifier::new(&mut checker, body_cache, promoted);\n+        verifier.visit_body(body_cache);\n         verifier.errors_reported\n     };\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(body);\n+        checker.typeck_mir(body_cache);\n     }\n \n     extra(&mut checker)\n@@ -385,7 +385,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_body(&mut self, body_cache: &BodyCache<&'_ Body<'tcx>>) {\n+    fn visit_body(&mut self, body_cache: &ReadOnlyBodyCache<'_, 'tcx>) {\n         self.sanitize_type(&\"return type\", body_cache.return_ty());\n         for local_decl in &body_cache.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);"}, {"sha": "aa02c0641e351bfdf4852a228665b5cc2091c45e", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         Prefixes {\n             next: Some(place_ref),\n             kind,\n-            body: self.body,\n+            body: &self.body_cache,\n             tcx: self.infcx.tcx,\n         }\n     }"}, {"sha": "430452efe422d6153ae6a0fa2061ffa3346d6f21", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab98c595eaa07249e2ebbf37c9123b33fc6a892f/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=ab98c595eaa07249e2ebbf37c9123b33fc6a892f", "patch": "@@ -32,7 +32,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 never_initialized_mut_locals: &mut never_initialized_mut_locals,\n                 mbcx: self,\n             };\n-            visitor.visit_body(visitor.mbcx.body);\n+            visitor.visit_body(&visitor.mbcx.body_cache);\n         }\n \n         // Take the union of the existed `used_mut` set with those variables we've found were"}]}