{"sha": "461c46052b86c330205b88fc0c02acae225588a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MWM0NjA1MmI4NmMzMzAyMDViODhmYzBjMDJhY2FlMjI1NTg4YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-08T20:15:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-08T20:15:53Z"}, "message": "Auto merge of #30036 - mitaa:doc_id, r=alexcrichton\n\nThis expands the code which generates unique IDs for Markdown headers within a single block to each rendered page.\n\nfixes #25001\nfixes #29449", "tree": {"sha": "fe7dcb0cb6d52c64da75e9d6cfc6aabd554ba28f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe7dcb0cb6d52c64da75e9d6cfc6aabd554ba28f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/461c46052b86c330205b88fc0c02acae225588a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/461c46052b86c330205b88fc0c02acae225588a8", "html_url": "https://github.com/rust-lang/rust/commit/461c46052b86c330205b88fc0c02acae225588a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/461c46052b86c330205b88fc0c02acae225588a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6941b2569ae1643335462da5a70f1429bad2f2fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6941b2569ae1643335462da5a70f1429bad2f2fb", "html_url": "https://github.com/rust-lang/rust/commit/6941b2569ae1643335462da5a70f1429bad2f2fb"}, {"sha": "fb7008c0a08264f42d44f010786edf15492c9bce", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7008c0a08264f42d44f010786edf15492c9bce", "html_url": "https://github.com/rust-lang/rust/commit/fb7008c0a08264f42d44f010786edf15492c9bce"}], "stats": {"total": 262, "additions": 203, "deletions": 59}, "files": [{"sha": "a5436886a7e8c62173070057d3e489646f889c11", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/461c46052b86c330205b88fc0c02acae225588a8/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461c46052b86c330205b88fc0c02acae225588a8/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=461c46052b86c330205b88fc0c02acae225588a8", "patch": "@@ -14,7 +14,7 @@\n //! (bundled into the rust runtime). This module self-contains the C bindings\n //! and necessary legwork to render markdown, and exposes all of the\n //! functionality through a unit-struct, `Markdown`, which has an implementation\n-//! of `fmt::String`. Example usage:\n+//! of `fmt::Display`. Example usage:\n //!\n //! ```rust,ignore\n //! use rustdoc::html::markdown::Markdown;\n@@ -29,19 +29,19 @@\n use libc;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n-use std::collections::HashMap;\n use std::default::Default;\n use std::ffi::CString;\n use std::fmt;\n use std::slice;\n use std::str;\n \n+use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n use html::escape::Escape;\n use test;\n \n-/// A unit struct which has the `fmt::String` trait implemented. When\n+/// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n pub struct Markdown<'a>(pub &'a str);\n@@ -210,10 +210,6 @@ fn collapse_whitespace(s: &str) -> String {\n     s.split_whitespace().collect::<Vec<_>>().join(\" \")\n }\n \n-thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, usize>> = {\n-    RefCell::new(HashMap::new())\n-});\n-\n thread_local!(pub static PLAYGROUND_KRATE: RefCell<Option<Option<String>>> = {\n     RefCell::new(None)\n });\n@@ -311,16 +307,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n         let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n \n-        // Make sure our hyphenated ID is unique for this page\n-        let id = USED_HEADER_MAP.with(|map| {\n-            let id = match map.borrow_mut().get_mut(&id) {\n-                None => id,\n-                Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n-            };\n-            map.borrow_mut().insert(id.clone(), 1);\n-            id\n-        });\n-\n+        let id = derive_id(id);\n \n         let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n             format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n@@ -335,8 +322,6 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n     }\n \n-    reset_headers();\n-\n     extern fn codespan(\n         ob: *mut hoedown_buffer,\n         text: *const hoedown_buffer,\n@@ -500,18 +485,6 @@ impl LangString {\n     }\n }\n \n-/// By default this markdown renderer generates anchors for each header in the\n-/// rendered document. The anchor name is the contents of the header separated\n-/// by hyphens, and a thread-local map is used to disambiguate among duplicate\n-/// headers (numbers are appended).\n-///\n-/// This method will reset the local table for these headers. This is typically\n-/// used at the beginning of rendering an entire HTML page to reset from the\n-/// previous state (if any).\n-pub fn reset_headers() {\n-    USED_HEADER_MAP.with(|s| s.borrow_mut().clear());\n-}\n-\n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *self;\n@@ -579,6 +552,7 @@ pub fn plain_summary_line(md: &str) -> String {\n mod tests {\n     use super::{LangString, Markdown};\n     use super::plain_summary_line;\n+    use html::render::reset_ids;\n \n     #[test]\n     fn test_lang_string_parse() {\n@@ -611,13 +585,15 @@ mod tests {\n     fn issue_17736() {\n         let markdown = \"# title\";\n         format!(\"{}\", Markdown(markdown));\n+        reset_ids();\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n             let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect);\n+            reset_ids();\n         }\n \n         t(\"# Foo bar\", \"\\n<h1 id='foo-bar' class='section-header'>\\\n@@ -634,6 +610,32 @@ mod tests {\n           <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n     }\n \n+    #[test]\n+    fn test_header_ids_multiple_blocks() {\n+        fn t(input: &str, expect: &str) {\n+            let output = format!(\"{}\", Markdown(input));\n+            assert_eq!(output, expect);\n+        }\n+\n+        let test = || {\n+            t(\"# Example\", \"\\n<h1 id='example' class='section-header'>\\\n+              <a href='#example'>Example</a></h1>\");\n+            t(\"# Panics\", \"\\n<h1 id='panics' class='section-header'>\\\n+              <a href='#panics'>Panics</a></h1>\");\n+            t(\"# Example\", \"\\n<h1 id='example-1' class='section-header'>\\\n+              <a href='#example-1'>Example</a></h1>\");\n+            t(\"# Main\", \"\\n<h1 id='main-1' class='section-header'>\\\n+              <a href='#main-1'>Main</a></h1>\");\n+            t(\"# Example\", \"\\n<h1 id='example-2' class='section-header'>\\\n+              <a href='#example-2'>Example</a></h1>\");\n+            t(\"# Panics\", \"\\n<h1 id='panics-1' class='section-header'>\\\n+              <a href='#panics-1'>Panics</a></h1>\");\n+        };\n+        test();\n+        reset_ids();\n+        test();\n+    }\n+\n     #[test]\n     fn test_plain_summary_line() {\n         fn t(input: &str, expect: &str) {"}, {"sha": "45969ed0c644d40da55040901ff628d4f7828ef9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 84, "deletions": 26, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/461c46052b86c330205b88fc0c02acae225588a8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461c46052b86c330205b88fc0c02acae225588a8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=461c46052b86c330205b88fc0c02acae225588a8", "patch": "@@ -342,6 +342,51 @@ impl fmt::Display for IndexItemFunctionType {\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n                     RefCell::new(Vec::new()));\n+thread_local!(static USED_ID_MAP: RefCell<HashMap<String, usize>> =\n+                    RefCell::new(init_ids()));\n+\n+fn init_ids() -> HashMap<String, usize> {\n+    [\n+     \"main\",\n+     \"search\",\n+     \"help\",\n+     \"TOC\",\n+     \"render-detail\",\n+     \"associated-types\",\n+     \"associated-const\",\n+     \"required-methods\",\n+     \"provided-methods\",\n+     \"implementors\",\n+     \"implementors-list\",\n+     \"methods\",\n+     \"deref-methods\",\n+     \"implementations\",\n+     \"derived_implementations\"\n+     ].into_iter().map(|id| (String::from(*id), 1)).collect::<HashMap<_, _>>()\n+}\n+\n+/// This method resets the local table of used ID attributes. This is typically\n+/// used at the beginning of rendering an entire HTML page to reset from the\n+/// previous state (if any).\n+pub fn reset_ids() {\n+    USED_ID_MAP.with(|s| *s.borrow_mut() = init_ids());\n+}\n+\n+pub fn derive_id(candidate: String) -> String {\n+    USED_ID_MAP.with(|map| {\n+        let id = match map.borrow_mut().get_mut(&candidate) {\n+            None => candidate,\n+            Some(a) => {\n+                let id = format!(\"{}-{}\", candidate, *a);\n+                *a += 1;\n+                id\n+            }\n+        };\n+\n+        map.borrow_mut().insert(id.clone(), 1);\n+        id\n+    })\n+}\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n@@ -1276,7 +1321,7 @@ impl Context {\n                 keywords: &keywords,\n             };\n \n-            markdown::reset_headers();\n+            reset_ids();\n \n             // We have a huge number of calls to write, so try to alleviate some\n             // of the pain by using a buffered writer instead of invoking the\n@@ -1698,10 +1743,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n                 ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n             };\n-            try!(write!(w,\n-                        \"<h2 id='{id}' class='section-header'>\\\n-                        <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                        id = short, name = name));\n+            try!(write!(w, \"<h2 id='{id}' class='section-header'>\\\n+                           <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n+                           id = derive_id(short.to_owned()), name = name));\n         }\n \n         match myitem.inner {\n@@ -1922,10 +1966,11 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item)\n                   -> fmt::Result {\n-        try!(write!(w, \"<h3 id='{ty}.{name}' class='method stab {stab}'><code>\",\n-                    ty = shortty(m),\n-                    name = *m.name.as_ref().unwrap(),\n-                    stab = m.stability_class()));\n+        let name = m.name.as_ref().unwrap();\n+        let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n+        try!(write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n+                       id = id,\n+                       stab = m.stability_class()));\n         try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, cx, m));\n@@ -2420,44 +2465,38 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     fn doctraititem(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n                     link: AssocItemLink, render_static: bool) -> fmt::Result {\n+        let name = item.name.as_ref().unwrap();\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static_method(item) || render_static {\n-                    try!(write!(w, \"<h4 id='method.{}' class='{}'><code>\",\n-                                *item.name.as_ref().unwrap(),\n-                                shortty(item)));\n+                    let id = derive_id(format!(\"method.{}\", name));\n+                    try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n                 try!(render_assoc_item(w, item, link));\n                     try!(write!(w, \"</code></h4>\\n\"));\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n-                let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n-                            *name,\n-                            shortty(item)));\n+                let id = derive_id(format!(\"assoc_type.{}\", name));\n+                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n-                            *name, shortty(item)));\n+                let id = derive_id(format!(\"assoc_const.{}\", name));\n+                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n                 try!(assoc_const(w, item, ty, default.as_ref()));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::ConstantItem(ref c) => {\n-                let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n-                            *name, shortty(item)));\n+                let id = derive_id(format!(\"assoc_const.{}\", name));\n+                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n                 try!(assoc_const(w, item, &c.type_, Some(&c.expr)));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n-                            *name,\n-                            shortty(item)));\n+                let id = derive_id(format!(\"assoc_type.{}\", name));\n+                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n                 try!(assoc_type(w, item, bounds, default));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n@@ -2671,3 +2710,22 @@ fn get_index_type_name(clean_type: &clean::Type) -> Option<String> {\n pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }\n+\n+#[cfg(test)]\n+#[test]\n+fn test_unique_id() {\n+    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n+                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n+                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n+    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n+                    \"method.into_iter-1\", \"foo-1\", \"main-1\", \"search-1\", \"methods-1\",\n+                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n+\n+    let test = || {\n+        let actual: Vec<String> = input.iter().map(|s| derive_id(s.to_string())).collect();\n+        assert_eq!(&actual[..], expected);\n+    };\n+    test();\n+    reset_ids();\n+    test();\n+}"}, {"sha": "ac64fd3bec0e75d81c2d248378928a53e9eb5072", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/461c46052b86c330205b88fc0c02acae225588a8/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461c46052b86c330205b88fc0c02acae225588a8/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=461c46052b86c330205b88fc0c02acae225588a8", "patch": "@@ -21,9 +21,10 @@ use rustc::session::search_paths::SearchPaths;\n \n use externalfiles::ExternalHtml;\n \n+use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, find_testable_code, reset_headers};\n+use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `%`.\n@@ -82,7 +83,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     }\n     let title = metadata[0];\n \n-    reset_headers();\n+    reset_ids();\n \n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))"}, {"sha": "e4d97828d50a08c860ef7474b1c2577f3974b8e8", "filename": "src/test/rustdoc/issue-25001.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/461c46052b86c330205b88fc0c02acae225588a8/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461c46052b86c330205b88fc0c02acae225588a8/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-25001.rs?ref=461c46052b86c330205b88fc0c02acae225588a8", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has issue_25001/struct.Foo.html\n+pub struct Foo<T>(T);\n+\n+pub trait Bar {\n+    type Item;\n+\n+    fn quux(self);\n+}\n+\n+impl<T> Foo<T> {\n+    // @has - '//*[@id=\"method.pass\"]//code' 'fn pass()'\n+    pub fn pass() {}\n+}\n+impl<T> Foo<T> {\n+    // @has - '//*[@id=\"method.pass-1\"]//code' 'fn pass() -> usize'\n+    pub fn pass() -> usize { 42 }\n+}\n+impl<T> Foo<T> {\n+    // @has - '//*[@id=\"method.pass-2\"]//code' 'fn pass() -> isize'\n+    pub fn pass() -> isize { 42 }\n+}\n+\n+impl<T> Bar for Foo<T> {\n+    // @has - '//*[@id=\"assoc_type.Item\"]//code' 'type Item = T'\n+    type Item=T;\n+\n+    // @has - '//*[@id=\"method.quux\"]//code' 'fn quux(self)'\n+    fn quux(self) {}\n+}\n+impl<'a, T> Bar for &'a Foo<T> {\n+    // @has - '//*[@id=\"assoc_type.Item-1\"]//code' \"type Item = &'a T\"\n+    type Item=&'a T;\n+\n+    // @has - '//*[@id=\"method.quux-1\"]//code' 'fn quux(self)'\n+    fn quux(self) {}\n+}\n+impl<'a, T> Bar for &'a mut Foo<T> {\n+    // @has - '//*[@id=\"assoc_type.Item-2\"]//code' \"type Item = &'a mut T\"\n+    type Item=&'a mut T;\n+\n+    // @has - '//*[@id=\"method.quux-2\"]//code' 'fn quux(self)'\n+    fn quux(self) {}\n+}"}, {"sha": "f296048e30b54d16d564f506ca8ddad3c8eac84e", "filename": "src/test/rustdoc/issue-29449.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/461c46052b86c330205b88fc0c02acae225588a8/src%2Ftest%2Frustdoc%2Fissue-29449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461c46052b86c330205b88fc0c02acae225588a8/src%2Ftest%2Frustdoc%2Fissue-29449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-29449.rs?ref=461c46052b86c330205b88fc0c02acae225588a8", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has issue_29449/struct.Foo.html\n+pub struct Foo;\n+\n+impl Foo {\n+    // @has - '//*[@id=\"examples\"]//a' 'Examples'\n+    // @has - '//*[@id=\"panics\"]//a' 'Panics'\n+    /// # Examples\n+    /// # Panics\n+    pub fn bar() {}\n+\n+    // @has - '//*[@id=\"examples-1\"]//a' 'Examples'\n+    /// # Examples\n+    pub fn bar_1() {}\n+\n+    // @has - '//*[@id=\"examples-2\"]//a' 'Examples'\n+    // @has - '//*[@id=\"panics-1\"]//a' 'Panics'\n+    /// # Examples\n+    /// # Panics\n+    pub fn bar_2() {}\n+}"}]}