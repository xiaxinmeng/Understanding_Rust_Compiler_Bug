{"sha": "5f6e0abe27aa6632f95492ad8864d8084c1bacef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNmUwYWJlMjdhYTY2MzJmOTU0OTJhZDg4NjRkODA4NGMxYmFjZWY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-20T18:31:29Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-20T18:31:29Z"}, "message": "clean up vec chapter of tarpl", "tree": {"sha": "809409b22e95367bf37733300ce5b38665927e13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/809409b22e95367bf37733300ce5b38665927e13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f6e0abe27aa6632f95492ad8864d8084c1bacef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6e0abe27aa6632f95492ad8864d8084c1bacef", "html_url": "https://github.com/rust-lang/rust/commit/5f6e0abe27aa6632f95492ad8864d8084c1bacef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f6e0abe27aa6632f95492ad8864d8084c1bacef/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42c2f107c120e9da046c9b26aa34238fcd6549b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c2f107c120e9da046c9b26aa34238fcd6549b6", "html_url": "https://github.com/rust-lang/rust/commit/42c2f107c120e9da046c9b26aa34238fcd6549b6"}], "stats": {"total": 369, "additions": 192, "deletions": 177}, "files": [{"sha": "d8b348760765f3f3c16a0b2c3446b5ea2a14f1d3", "filename": "src/doc/tarpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FSUMMARY.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -46,6 +46,7 @@\n \t* [Deref](vec-deref.md)\n \t* [Insert and Remove](vec-insert-remove.md)\n \t* [IntoIter](vec-into-iter.md)\n+\t* [RawVec](vec-raw.md)\n \t* [Drain](vec-drain.md)\n \t* [Handling Zero-Sized Types](vec-zsts.md)\n \t* [Final Code](vec-final.md)"}, {"sha": "14b9b462afc6328985289fdebac8db9ffceb6cda", "filename": "src/doc/tarpl/vec-alloc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-alloc.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -46,7 +46,7 @@ Okay, now we can write growing. Roughly, we want to have this logic:\n if cap == 0:\n     allocate()\n     cap = 1\n-else\n+else:\n     reallocate\n     cap *= 2\n ```"}, {"sha": "b767caa4912364e9ae52e7c543f8d3f625409d58", "filename": "src/doc/tarpl/vec-dealloc.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -2,13 +2,13 @@\n \n Next we should implement Drop so that we don't massively leak tons of resources.\n The easiest way is to just call `pop` until it yields None, and then deallocate\n-our buffer. Note that calling `pop` is uneeded if `T: !Drop`. In theory we can\n-ask Rust if T needs_drop and omit the calls to `pop`. However in practice LLVM\n-is *really* good at removing simple side-effect free code like this, so I wouldn't\n-bother unless you notice it's not being stripped (in this case it is).\n+our buffer. Note that calling `pop` is unneeded if `T: !Drop`. In theory we can\n+ask Rust if `T` `needs_drop` and omit the calls to `pop`. However in practice\n+LLVM is *really* good at removing simple side-effect free code like this, so I\n+wouldn't bother unless you notice it's not being stripped (in this case it is).\n \n-We must not call `heap::deallocate` when `self.cap == 0`, as in this case we haven't\n-actually allocated any memory.\n+We must not call `heap::deallocate` when `self.cap == 0`, as in this case we\n+haven't actually allocated any memory.\n \n \n ```rust,ignore"}, {"sha": "6460eab479bd42c5a0e50aa00eb3336ba6bd8a17", "filename": "src/doc/tarpl/vec-deref.md", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-deref.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-deref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-deref.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -1,13 +1,15 @@\n % Deref\n \n-Alright! We've got a decent minimal ArrayStack implemented. We can push, we can\n-pop, and we can clean up after ourselves. However there's a whole mess of functionality\n-we'd reasonably want. In particular, we have a proper array, but none of the slice\n-functionality. That's actually pretty easy to solve: we can implement `Deref<Target=[T]>`.\n-This will magically make our Vec coerce to and behave like a slice in all sorts of\n-conditions.\n+Alright! We've got a decent minimal stack implemented. We can push, we can\n+pop, and we can clean up after ourselves. However there's a whole mess of\n+functionality we'd reasonably want. In particular, we have a proper array, but\n+none of the slice functionality. That's actually pretty easy to solve: we can\n+implement `Deref<Target=[T]>`. This will magically make our Vec coerce to, and\n+behave like, a slice in all sorts of conditions.\n \n-All we need is `slice::from_raw_parts`.\n+All we need is `slice::from_raw_parts`. It will correctly handle empty slices\n+for us. Later once we set up zero-sized type support it will also Just Work\n+for those too.\n \n ```rust,ignore\n use std::ops::Deref;\n@@ -36,5 +38,5 @@ impl<T> DerefMut for Vec<T> {\n }\n ```\n \n-Now we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`, `iter_mut`,\n-and all other sorts of bells and whistles provided by slice. Sweet!\n+Now we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`,\n+`iter_mut`, and all other sorts of bells and whistles provided by slice. Sweet!"}, {"sha": "b6b2826660079698843e82386f32dc2ffc71cf8f", "filename": "src/doc/tarpl/vec-drain.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -2,7 +2,7 @@\n \n Let's move on to Drain. Drain is largely the same as IntoIter, except that\n instead of consuming the Vec, it borrows the Vec and leaves its allocation\n-free. For now we'll only implement the \"basic\" full-range version.\n+untouched. For now we'll only implement the \"basic\" full-range version.\n \n ```rust,ignore\n use std::marker::PhantomData;\n@@ -38,6 +38,9 @@ impl<T> RawValIter<T> {\n         RawValIter {\n             start: slice.as_ptr(),\n             end: if slice.len() == 0 {\n+                // if `len = 0`, then this is not actually allocated memory.\n+                // Need to avoid offsetting because that will give wrong\n+                // information to LLVM via GEP.\n                 slice.as_ptr()\n             } else {\n                 slice.as_ptr().offset(slice.len() as isize)\n@@ -137,5 +140,7 @@ impl<T> Vec<T> {\n }\n ```\n \n+For more details on the `mem::forget` problem, see the\n+[section on leaks][leaks].\n \n-\n+[leaks]: leaking.html"}, {"sha": "6f88a77b32a7537378f2576ca2f9218b9dc3eacf", "filename": "src/doc/tarpl/vec-insert-remove.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -1,12 +1,13 @@\n % Insert and Remove\n \n-Something *not* provided but slice is `insert` and `remove`, so let's do those next.\n+Something *not* provided by slice is `insert` and `remove`, so let's do those\n+next.\n \n Insert needs to shift all the elements at the target index to the right by one.\n To do this we need to use `ptr::copy`, which is our version of C's `memmove`.\n-This copies some chunk of memory from one location to another, correctly handling\n-the case where the source and destination overlap (which will definitely happen\n-here).\n+This copies some chunk of memory from one location to another, correctly\n+handling the case where the source and destination overlap (which will\n+definitely happen here).\n \n If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\n using the *old* len."}, {"sha": "566cad75b51247c9a7737d51b4ba070e59e18e6c", "filename": "src/doc/tarpl/vec-into-iter.md", "status": "modified", "additions": 14, "deletions": 145, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -11,19 +11,20 @@ allocation.\n IntoIter needs to be DoubleEnded as well, to enable reading from both ends.\n Reading from the back could just be implemented as calling `pop`, but reading\n from the front is harder. We could call `remove(0)` but that would be insanely\n-expensive. Instead we're going to just use ptr::read to copy values out of either\n-end of the Vec without mutating the buffer at all.\n+expensive. Instead we're going to just use ptr::read to copy values out of\n+either end of the Vec without mutating the buffer at all.\n \n To do this we're going to use a very common C idiom for array iteration. We'll\n-make two pointers; one that points to the start of the array, and one that points\n-to one-element past the end. When we want an element from one end, we'll read out\n-the value pointed to at that end and move the pointer over by one. When the two\n-pointers are equal, we know we're done.\n+make two pointers; one that points to the start of the array, and one that\n+points to one-element past the end. When we want an element from one end, we'll\n+read out the value pointed to at that end and move the pointer over by one. When\n+the two pointers are equal, we know we're done.\n \n Note that the order of read and offset are reversed for `next` and `next_back`\n For `next_back` the pointer is always *after* the element it wants to read next,\n while for `next` the pointer is always *at* the element it wants to read next.\n-To see why this is, consider the case where every element but one has been yielded.\n+To see why this is, consider the case where every element but one has been\n+yielded.\n \n The array looks like this:\n \n@@ -35,6 +36,10 @@ The array looks like this:\n If E pointed directly at the element it wanted to yield next, it would be\n indistinguishable from the case where there are no more elements to yield.\n \n+Although we don't actually care about it during iteration, we also need to hold\n+onto the Vec's allocation information in order to free it once IntoIter is\n+dropped.\n+\n So we're going to use the following struct:\n \n ```rust,ignore\n@@ -46,8 +51,8 @@ struct IntoIter<T> {\n }\n ```\n \n-One last subtle detail: if our Vec is empty, we want to produce an empty iterator.\n-This will actually technically fall out doing the naive thing of:\n+One last subtle detail: if our Vec is empty, we want to produce an empty\n+iterator. This will actually technically fall out doing the naive thing of:\n \n ```text\n start = ptr\n@@ -155,139 +160,3 @@ impl<T> Drop for IntoIter<T> {\n     }\n }\n ```\n-\n-We've actually reached an interesting situation here: we've duplicated the logic\n-for specifying a buffer and freeing its memory. Now that we've implemented it and\n-identified *actual* logic duplication, this is a good time to perform some logic\n-compression.\n-\n-We're going to abstract out the `(ptr, cap)` pair and give them the logic for\n-allocating, growing, and freeing:\n-\n-```rust,ignore\n-\n-struct RawVec<T> {\n-    ptr: Unique<T>,\n-    cap: usize,\n-}\n-\n-impl<T> RawVec<T> {\n-    fn new() -> Self {\n-        assert!(mem::size_of::<T>() != 0, \"TODO: implement ZST support\");\n-        unsafe {\n-            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: 0 }\n-        }\n-    }\n-\n-    // unchanged from Vec\n-    fn grow(&mut self) {\n-        unsafe {\n-            let align = mem::align_of::<T>();\n-            let elem_size = mem::size_of::<T>();\n-\n-            let (new_cap, ptr) = if self.cap == 0 {\n-                let ptr = heap::allocate(elem_size, align);\n-                (1, ptr)\n-            } else {\n-                let new_cap = 2 * self.cap;\n-                let ptr = heap::reallocate(*self.ptr as *mut _,\n-                                            self.cap * elem_size,\n-                                            new_cap * elem_size,\n-                                            align);\n-                (new_cap, ptr)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n-\n-            self.ptr = Unique::new(ptr as *mut _);\n-            self.cap = new_cap;\n-        }\n-    }\n-}\n-\n-\n-impl<T> Drop for RawVec<T> {\n-    fn drop(&mut self) {\n-        if self.cap != 0 {\n-            let align = mem::align_of::<T>();\n-            let elem_size = mem::size_of::<T>();\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-```\n-\n-And change vec as follows:\n-\n-```rust,ignore\n-pub struct Vec<T> {\n-    buf: RawVec<T>,\n-    len: usize,\n-}\n-\n-impl<T> Vec<T> {\n-    fn ptr(&self) -> *mut T { *self.buf.ptr }\n-\n-    fn cap(&self) -> usize { self.buf.cap }\n-\n-    pub fn new() -> Self {\n-        Vec { buf: RawVec::new(), len: 0 }\n-    }\n-\n-    // push/pop/insert/remove largely unchanged:\n-    // * `self.ptr -> self.ptr()`\n-    // * `self.cap -> self.cap()`\n-    // * `self.grow -> self.buf.grow()`\n-}\n-\n-impl<T> Drop for Vec<T> {\n-    fn drop(&mut self) {\n-        while let Some(_) = self.pop() {}\n-        // deallocation is handled by RawVec\n-    }\n-}\n-```\n-\n-And finally we can really simplify IntoIter:\n-\n-```rust,ignore\n-struct IntoIter<T> {\n-    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n-    start: *const T,\n-    end: *const T,\n-}\n-\n-// next and next_back literally unchanged since they never referred to the buf\n-\n-impl<T> Drop for IntoIter<T> {\n-    fn drop(&mut self) {\n-        // only need to ensure all our elements are read;\n-        // buffer will clean itself up afterwards.\n-        for _ in &mut *self {}\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            // need to use ptr::read to unsafely move the buf out since it's\n-            // not Copy.\n-            let buf = ptr::read(&self.buf);\n-            let len = self.len;\n-            mem::forget(self);\n-\n-            IntoIter {\n-                start: *buf.ptr,\n-                end: buf.ptr.offset(len as isize),\n-                _buf: buf,\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Much better."}, {"sha": "4e440846ec7df2c1743068ce93151046b6295990", "filename": "src/doc/tarpl/vec-layout.md", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-layout.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -13,15 +13,15 @@ pub struct Vec<T> {\n # fn main() {}\n ```\n \n-And indeed this would compile. Unfortunately, it would be incorrect. The compiler\n-will give us too strict variance, so e.g. an `&Vec<&'static str>` couldn't be used\n-where an `&Vec<&'a str>` was expected. More importantly, it will give incorrect\n-ownership information to dropck, as it will conservatively assume we don't own\n-any values of type `T`. See [the chapter on ownership and lifetimes]\n-(lifetimes.html) for details.\n+And indeed this would compile. Unfortunately, it would be incorrect. The\n+compiler will give us too strict variance, so e.g. an `&Vec<&'static str>`\n+couldn't be used where an `&Vec<&'a str>` was expected. More importantly, it\n+will give incorrect ownership information to dropck, as it will conservatively\n+assume we don't own any values of type `T`. See [the chapter on ownership and\n+lifetimes] (lifetimes.html) for details.\n \n-As we saw in the lifetimes chapter, we should use `Unique<T>` in place of `*mut T`\n-when we have a raw pointer to an allocation we own:\n+As we saw in the lifetimes chapter, we should use `Unique<T>` in place of\n+`*mut T` when we have a raw pointer to an allocation we own:\n \n \n ```rust\n@@ -40,9 +40,10 @@ pub struct Vec<T> {\n \n As a recap, Unique is a wrapper around a raw pointer that declares that:\n \n-* We own at least one value of type `T`\n+* We may own a value of type `T`\n * We are Send/Sync iff `T` is Send/Sync\n-* Our pointer is never null (and therefore `Option<Vec>` is null-pointer-optimized)\n+* Our pointer is never null (and therefore `Option<Vec>` is\n+  null-pointer-optimized)\n \n That last point is subtle. First, it makes `Unique::new` unsafe to call, because\n putting `null` inside of it is Undefined Behaviour. It also throws a"}, {"sha": "40de0196f29a3c2081974d58cb06125b5d1b665c", "filename": "src/doc/tarpl/vec-raw.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f6e0abe27aa6632f95492ad8864d8084c1bacef/src%2Fdoc%2Ftarpl%2Fvec-raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-raw.md?ref=5f6e0abe27aa6632f95492ad8864d8084c1bacef", "patch": "@@ -0,0 +1,136 @@\n+% RawVec\n+\n+We've actually reached an interesting situation here: we've duplicated the logic\n+for specifying a buffer and freeing its memory. Now that we've implemented it\n+and identified *actual* logic duplication, this is a good time to perform some\n+logic compression.\n+\n+We're going to abstract out the `(ptr, cap)` pair and give them the logic for\n+allocating, growing, and freeing:\n+\n+```rust,ignore\n+struct RawVec<T> {\n+    ptr: Unique<T>,\n+    cap: usize,\n+}\n+\n+impl<T> RawVec<T> {\n+    fn new() -> Self {\n+        assert!(mem::size_of::<T>() != 0, \"TODO: implement ZST support\");\n+        unsafe {\n+            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: 0 }\n+        }\n+    }\n+\n+    // unchanged from Vec\n+    fn grow(&mut self) {\n+        unsafe {\n+            let align = mem::align_of::<T>();\n+            let elem_size = mem::size_of::<T>();\n+\n+            let (new_cap, ptr) = if self.cap == 0 {\n+                let ptr = heap::allocate(elem_size, align);\n+                (1, ptr)\n+            } else {\n+                let new_cap = 2 * self.cap;\n+                let ptr = heap::reallocate(*self.ptr as *mut _,\n+                                            self.cap * elem_size,\n+                                            new_cap * elem_size,\n+                                            align);\n+                (new_cap, ptr)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+}\n+\n+\n+impl<T> Drop for RawVec<T> {\n+    fn drop(&mut self) {\n+        if self.cap != 0 {\n+            let align = mem::align_of::<T>();\n+            let elem_size = mem::size_of::<T>();\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+```\n+\n+And change vec as follows:\n+\n+```rust,ignore\n+pub struct Vec<T> {\n+    buf: RawVec<T>,\n+    len: usize,\n+}\n+\n+impl<T> Vec<T> {\n+    fn ptr(&self) -> *mut T { *self.buf.ptr }\n+\n+    fn cap(&self) -> usize { self.buf.cap }\n+\n+    pub fn new() -> Self {\n+        Vec { buf: RawVec::new(), len: 0 }\n+    }\n+\n+    // push/pop/insert/remove largely unchanged:\n+    // * `self.ptr -> self.ptr()`\n+    // * `self.cap -> self.cap()`\n+    // * `self.grow -> self.buf.grow()`\n+}\n+\n+impl<T> Drop for Vec<T> {\n+    fn drop(&mut self) {\n+        while let Some(_) = self.pop() {}\n+        // deallocation is handled by RawVec\n+    }\n+}\n+```\n+\n+And finally we can really simplify IntoIter:\n+\n+```rust,ignore\n+struct IntoIter<T> {\n+    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n+    start: *const T,\n+    end: *const T,\n+}\n+\n+// next and next_back literally unchanged since they never referred to the buf\n+\n+impl<T> Drop for IntoIter<T> {\n+    fn drop(&mut self) {\n+        // only need to ensure all our elements are read;\n+        // buffer will clean itself up afterwards.\n+        for _ in &mut *self {}\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            // need to use ptr::read to unsafely move the buf out since it's\n+            // not Copy, and Vec implements Drop (so we can't destructure it).\n+            let buf = ptr::read(&self.buf);\n+            let len = self.len;\n+            mem::forget(self);\n+\n+            IntoIter {\n+                start: *buf.ptr,\n+                end: buf.ptr.offset(len as isize),\n+                _buf: buf,\n+            }\n+        }\n+    }\n+}\n+```\n+\n+Much better."}]}