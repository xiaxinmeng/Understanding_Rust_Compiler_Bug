{"sha": "546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NmNiMjFmNTgwYWUzZDRlMGJmNDJjY2VjZmFkNGEzNGRlZmViZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-03T05:30:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-03T05:30:20Z"}, "message": "Auto merge of #59657 - Centril:rollup-w5p98mc, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #55448 (Add 'partition_at_index/_by/_by_key' for slices.)\n - #59186 (improve worst-case performance of BTreeSet intersection v3)\n - #59514 (Remove adt_def from projections and downcasts in MIR)\n - #59630 (Shrink `mir::Statement`.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d8bca65d580fe79d66b0d13f11621474a2cdcecb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8bca65d580fe79d66b0d13f11621474a2cdcecb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "html_url": "https://github.com/rust-lang/rust/commit/546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7641873f591dca86e2b31f60fc76b39553892631", "url": "https://api.github.com/repos/rust-lang/rust/commits/7641873f591dca86e2b31f60fc76b39553892631", "html_url": "https://github.com/rust-lang/rust/commit/7641873f591dca86e2b31f60fc76b39553892631"}, {"sha": "d31d80b7d468b4e0fc1fa4d87cfa4af7b0dcc626", "url": "https://api.github.com/repos/rust-lang/rust/commits/d31d80b7d468b4e0fc1fa4d87cfa4af7b0dcc626", "html_url": "https://github.com/rust-lang/rust/commit/d31d80b7d468b4e0fc1fa4d87cfa4af7b0dcc626"}], "stats": {"total": 1490, "additions": 1031, "deletions": 459}, "files": [{"sha": "6357ea3ea11bd8b99a1d75e759b75af0a8e4916e", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -3,86 +3,86 @@ use std::collections::BTreeSet;\n use rand::{thread_rng, Rng};\n use test::{black_box, Bencher};\n \n-fn random(n1: u32, n2: u32) -> [BTreeSet<usize>; 2] {\n+fn random(n: usize) -> BTreeSet<usize> {\n     let mut rng = thread_rng();\n-    let mut set1 = BTreeSet::new();\n-    let mut set2 = BTreeSet::new();\n-    for _ in 0..n1 {\n-        let i = rng.gen::<usize>();\n-        set1.insert(i);\n+    let mut set = BTreeSet::new();\n+    while set.len() < n {\n+        set.insert(rng.gen());\n     }\n-    for _ in 0..n2 {\n-        let i = rng.gen::<usize>();\n-        set2.insert(i);\n-    }\n-    [set1, set2]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn staggered(n1: u32, n2: u32) -> [BTreeSet<u32>; 2] {\n-    let mut even = BTreeSet::new();\n-    let mut odd = BTreeSet::new();\n-    for i in 0..n1 {\n-        even.insert(i * 2);\n-    }\n-    for i in 0..n2 {\n-        odd.insert(i * 2 + 1);\n+fn neg(n: usize) -> BTreeSet<i32> {\n+    let mut set = BTreeSet::new();\n+    for i in -(n as i32)..=-1 {\n+        set.insert(i);\n     }\n-    [even, odd]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn neg_vs_pos(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n-    let mut neg = BTreeSet::new();\n-    let mut pos = BTreeSet::new();\n-    for i in -(n1 as i32)..=-1 {\n-        neg.insert(i);\n-    }\n-    for i in 1..=(n2 as i32) {\n-        pos.insert(i);\n+fn pos(n: usize) -> BTreeSet<i32> {\n+    let mut set = BTreeSet::new();\n+    for i in 1..=(n as i32) {\n+        set.insert(i);\n     }\n-    [neg, pos]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn pos_vs_neg(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n-    let mut neg = BTreeSet::new();\n-    let mut pos = BTreeSet::new();\n-    for i in -(n1 as i32)..=-1 {\n-        neg.insert(i);\n-    }\n-    for i in 1..=(n2 as i32) {\n-        pos.insert(i);\n+\n+fn stagger(n1: usize, factor: usize) -> [BTreeSet<u32>; 2] {\n+    let n2 = n1 * factor;\n+    let mut sets = [BTreeSet::new(), BTreeSet::new()];\n+    for i in 0..(n1 + n2) {\n+        let b = i % (factor + 1) != 0;\n+        sets[b as usize].insert(i as u32);\n     }\n-    [pos, neg]\n+    assert_eq!(sets[0].len(), n1);\n+    assert_eq!(sets[1].len(), n2);\n+    sets\n }\n \n-macro_rules! set_intersection_bench {\n-    ($name: ident, $sets: expr) => {\n+macro_rules! set_bench {\n+    ($name: ident, $set_func: ident, $result_func: ident, $sets: expr) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             // setup\n             let sets = $sets;\n \n             // measure\n             b.iter(|| {\n-                let x = sets[0].intersection(&sets[1]).count();\n+                let x = sets[0].$set_func(&sets[1]).$result_func();\n                 black_box(x);\n             })\n         }\n     };\n }\n \n-set_intersection_bench! {intersect_random_100,          random(100, 100)}\n-set_intersection_bench! {intersect_random_10k,          random(10_000, 10_000)}\n-set_intersection_bench! {intersect_random_10_vs_10k,    random(10, 10_000)}\n-set_intersection_bench! {intersect_random_10k_vs_10,    random(10_000, 10)}\n-set_intersection_bench! {intersect_staggered_100,       staggered(100, 100)}\n-set_intersection_bench! {intersect_staggered_10k,       staggered(10_000, 10_000)}\n-set_intersection_bench! {intersect_staggered_10_vs_10k, staggered(10, 10_000)}\n-set_intersection_bench! {intersect_staggered_10k_vs_10, staggered(10_000, 10)}\n-set_intersection_bench! {intersect_neg_vs_pos_100,      neg_vs_pos(100, 100)}\n-set_intersection_bench! {intersect_neg_vs_pos_10k,      neg_vs_pos(10_000, 10_000)}\n-set_intersection_bench! {intersect_neg_vs_pos_10_vs_10k,neg_vs_pos(10, 10_000)}\n-set_intersection_bench! {intersect_neg_vs_pos_10k_vs_10,neg_vs_pos(10_000, 10)}\n-set_intersection_bench! {intersect_pos_vs_neg_100,      pos_vs_neg(100, 100)}\n-set_intersection_bench! {intersect_pos_vs_neg_10k,      pos_vs_neg(10_000, 10_000)}\n-set_intersection_bench! {intersect_pos_vs_neg_10_vs_10k,pos_vs_neg(10, 10_000)}\n-set_intersection_bench! {intersect_pos_vs_neg_10k_vs_10,pos_vs_neg(10_000, 10)}\n+set_bench! {intersection_100_neg_vs_100_pos, intersection, count, [neg(100), pos(100)]}\n+set_bench! {intersection_100_neg_vs_10k_pos, intersection, count, [neg(100), pos(10_000)]}\n+set_bench! {intersection_100_pos_vs_100_neg, intersection, count, [pos(100), neg(100)]}\n+set_bench! {intersection_100_pos_vs_10k_neg, intersection, count, [pos(100), neg(10_000)]}\n+set_bench! {intersection_10k_neg_vs_100_pos, intersection, count, [neg(10_000), pos(100)]}\n+set_bench! {intersection_10k_neg_vs_10k_pos, intersection, count, [neg(10_000), pos(10_000)]}\n+set_bench! {intersection_10k_pos_vs_100_neg, intersection, count, [pos(10_000), neg(100)]}\n+set_bench! {intersection_10k_pos_vs_10k_neg, intersection, count, [pos(10_000), neg(10_000)]}\n+set_bench! {intersection_random_100_vs_100, intersection, count, [random(100), random(100)]}\n+set_bench! {intersection_random_100_vs_10k, intersection, count, [random(100), random(10_000)]}\n+set_bench! {intersection_random_10k_vs_100, intersection, count, [random(10_000), random(100)]}\n+set_bench! {intersection_random_10k_vs_10k, intersection, count, [random(10_000), random(10_000)]}\n+set_bench! {intersection_staggered_100_vs_100, intersection, count, stagger(100, 1)}\n+set_bench! {intersection_staggered_10k_vs_10k, intersection, count, stagger(10_000, 1)}\n+set_bench! {intersection_staggered_100_vs_10k, intersection, count, stagger(100, 100)}\n+set_bench! {difference_random_100_vs_100, difference, count, [random(100), random(100)]}\n+set_bench! {difference_random_100_vs_10k, difference, count, [random(100), random(10_000)]}\n+set_bench! {difference_random_10k_vs_100, difference, count, [random(10_000), random(100)]}\n+set_bench! {difference_random_10k_vs_10k, difference, count, [random(10_000), random(10_000)]}\n+set_bench! {difference_staggered_100_vs_100, difference, count, stagger(100, 1)}\n+set_bench! {difference_staggered_10k_vs_10k, difference, count, stagger(10_000, 1)}\n+set_bench! {difference_staggered_100_vs_10k, difference, count, stagger(100, 100)}\n+set_bench! {is_subset_100_vs_100, is_subset, clone, [pos(100), pos(100)]}\n+set_bench! {is_subset_100_vs_10k, is_subset, clone, [pos(100), pos(10_000)]}\n+set_bench! {is_subset_10k_vs_100, is_subset, clone, [pos(10_000), pos(100)]}\n+set_bench! {is_subset_10k_vs_10k, is_subset, clone, [pos(10_000), pos(10_000)]}"}, {"sha": "e71767077ca5501a69d86bcc9176723ecd2a52d0", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 233, "deletions": 65, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -3,7 +3,7 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n-use core::cmp::{min, max};\n+use core::cmp::max;\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n@@ -118,17 +118,36 @@ pub struct Range<'a, T: 'a> {\n /// [`difference`]: struct.BTreeSet.html#method.difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n+    inner: DifferenceInner<'a, T>,\n+}\n+enum DifferenceInner<'a, T: 'a> {\n+    Stitch {\n+        self_iter: Iter<'a, T>,\n+        other_iter: Peekable<Iter<'a, T>>,\n+    },\n+    Search {\n+        self_iter: Iter<'a, T>,\n+        other_set: &'a BTreeSet<T>,\n+    },\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Difference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        match &self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter,\n+            } => f\n+                .debug_tuple(\"Difference\")\n+                .field(&self_iter)\n+                .field(&other_iter)\n+                .finish(),\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set: _,\n+            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n+        }\n     }\n }\n \n@@ -164,17 +183,36 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n /// [`intersection`]: struct.BTreeSet.html#method.intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n+    inner: IntersectionInner<'a, T>,\n+}\n+enum IntersectionInner<'a, T: 'a> {\n+    Stitch {\n+        small_iter: Iter<'a, T>, // for size_hint, should be the smaller of the sets\n+        other_iter: Iter<'a, T>,\n+    },\n+    Search {\n+        small_iter: Iter<'a, T>,\n+        large_set: &'a BTreeSet<T>,\n+    },\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Intersection\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        match &self.inner {\n+            IntersectionInner::Stitch {\n+                small_iter,\n+                other_iter,\n+            } => f\n+                .debug_tuple(\"Intersection\")\n+                .field(&small_iter)\n+                .field(&other_iter)\n+                .finish(),\n+            IntersectionInner::Search {\n+                small_iter,\n+                large_set: _,\n+            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n+        }\n     }\n }\n \n@@ -201,6 +239,14 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     }\n }\n \n+// This constant is used by functions that compare two sets.\n+// It estimates the relative size at which searching performs better\n+// than iterating, based on the benchmarks in\n+// https://github.com/ssomers/rust_bench_btreeset_intersection;\n+// It's used to divide rather than multiply sizes, to rule out overflow,\n+// and it's a power of two to make that division cheap.\n+const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n+\n impl<T: Ord> BTreeSet<T> {\n     /// Makes a new `BTreeSet` with a reasonable choice of B.\n     ///\n@@ -268,9 +314,24 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        Difference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n+        if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Self is bigger than or not much smaller than other set.\n+            // Iterate both sets jointly, spotting matches along the way.\n+            Difference {\n+                inner: DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n+            }\n+        } else {\n+            // Self is much smaller than other set, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            Difference {\n+                inner: DifferenceInner::Search {\n+                    self_iter: self.iter(),\n+                    other_set: other,\n+                },\n+            }\n         }\n     }\n \n@@ -326,9 +387,29 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        Intersection {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n+        let (small, other) = if self.len() <= other.len() {\n+            (self, other)\n+        } else {\n+            (other, self)\n+        };\n+        if small.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Small set is not much smaller than other set.\n+            // Iterate both sets jointly, spotting matches along the way.\n+            Intersection {\n+                inner: IntersectionInner::Stitch {\n+                    small_iter: small.iter(),\n+                    other_iter: other.iter(),\n+                },\n+            }\n+        } else {\n+            // Big difference in number of elements, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            Intersection {\n+                inner: IntersectionInner::Search {\n+                    small_iter: small.iter(),\n+                    large_set: other,\n+                },\n+            }\n         }\n     }\n \n@@ -462,28 +543,44 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n-        // Stolen from TreeMap\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n+        // Same result as self.difference(other).next().is_none()\n+        // but the 3 paths below are faster (in order: hugely, 20%, 5%).\n+        if self.len() > other.len() {\n+            false\n+        } else if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Self is not much smaller than other set.\n+            // Stolen from TreeMap\n+            let mut x = self.iter();\n+            let mut y = other.iter();\n+            let mut a = x.next();\n+            let mut b = y.next();\n+            while a.is_some() {\n+                if b.is_none() {\n+                    return false;\n+                }\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n \n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n+                match b1.cmp(a1) {\n+                    Less => (),\n+                    Greater => return false,\n+                    Equal => a = x.next(),\n+                }\n \n-            b = y.next();\n+                b = y.next();\n+            }\n+            true\n+        } else {\n+            // Big difference in number of elements, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            for next in self {\n+                if !other.contains(next) {\n+                    return false;\n+                }\n+            }\n+            true\n         }\n-        true\n     }\n \n     /// Returns `true` if the set is a superset of another,\n@@ -1001,8 +1098,22 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n         Difference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n+            inner: match &self.inner {\n+                DifferenceInner::Stitch {\n+                    self_iter,\n+                    other_iter,\n+                } => DifferenceInner::Stitch {\n+                    self_iter: self_iter.clone(),\n+                    other_iter: other_iter.clone(),\n+                },\n+                DifferenceInner::Search {\n+                    self_iter,\n+                    other_set,\n+                } => DifferenceInner::Search {\n+                    self_iter: self_iter.clone(),\n+                    other_set,\n+                },\n+            },\n         }\n     }\n }\n@@ -1011,24 +1122,52 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => {\n-                    self.b.next();\n+        match &mut self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter,\n+            } => {\n+                let mut self_next = self_iter.next()?;\n+                loop {\n+                    match other_iter\n+                        .peek()\n+                        .map_or(Less, |other_next| Ord::cmp(self_next, other_next))\n+                    {\n+                        Less => return Some(self_next),\n+                        Equal => {\n+                            self_next = self_iter.next()?;\n+                            other_iter.next();\n+                        }\n+                        Greater => {\n+                            other_iter.next();\n+                        }\n+                    }\n                 }\n             }\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set,\n+            } => loop {\n+                let self_next = self_iter.next()?;\n+                if !other_set.contains(&self_next) {\n+                    return Some(self_next);\n+                }\n+            },\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n-        (a_len.saturating_sub(b_len), Some(a_len))\n+        let (self_len, other_len) = match &self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter\n+            } => (self_iter.len(), other_iter.len()),\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set\n+            } => (self_iter.len(), other_set.len()),\n+        };\n+        (self_len.saturating_sub(other_len), Some(self_len))\n     }\n }\n \n@@ -1073,8 +1212,22 @@ impl<T: Ord> FusedIterator for SymmetricDifference<'_, T> {}\n impl<T> Clone for Intersection<'_, T> {\n     fn clone(&self) -> Self {\n         Intersection {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n+            inner: match &self.inner {\n+                IntersectionInner::Stitch {\n+                    small_iter,\n+                    other_iter,\n+                } => IntersectionInner::Stitch {\n+                    small_iter: small_iter.clone(),\n+                    other_iter: other_iter.clone(),\n+                },\n+                IntersectionInner::Search {\n+                    small_iter,\n+                    large_set,\n+                } => IntersectionInner::Search {\n+                    small_iter: small_iter.clone(),\n+                    large_set,\n+                },\n+            },\n         }\n     }\n }\n@@ -1083,24 +1236,39 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match Ord::cmp(self.a.peek()?, self.b.peek()?) {\n-                Less => {\n-                    self.a.next();\n-                }\n-                Equal => {\n-                    self.b.next();\n-                    return self.a.next();\n-                }\n-                Greater => {\n-                    self.b.next();\n+        match &mut self.inner {\n+            IntersectionInner::Stitch {\n+                small_iter,\n+                other_iter,\n+            } => {\n+                let mut small_next = small_iter.next()?;\n+                let mut other_next = other_iter.next()?;\n+                loop {\n+                    match Ord::cmp(small_next, other_next) {\n+                        Less => small_next = small_iter.next()?,\n+                        Greater => other_next = other_iter.next()?,\n+                        Equal => return Some(small_next),\n+                    }\n                 }\n             }\n+            IntersectionInner::Search {\n+                small_iter,\n+                large_set,\n+            } => loop {\n+                let small_next = small_iter.next()?;\n+                if large_set.contains(&small_next) {\n+                    return Some(small_next);\n+                }\n+            },\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(min(self.a.len(), self.b.len())))\n+        let min_len = match &self.inner {\n+            IntersectionInner::Stitch { small_iter, .. } => small_iter.len(),\n+            IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n+        };\n+        (0, Some(min_len))\n     }\n }\n "}, {"sha": "d52814118b3c7de7c74c47f1d8700a6299be55f6", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -69,6 +69,20 @@ fn test_intersection() {\n     check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n                        &[2, 11, 77, -9, -42, 5, 3],\n                        &[3, 5, 11, 77]);\n+    let large = (0..1000).collect::<Vec<_>>();\n+    check_intersection(&[], &large, &[]);\n+    check_intersection(&large, &[], &[]);\n+    check_intersection(&[-1], &large, &[]);\n+    check_intersection(&large, &[-1], &[]);\n+    check_intersection(&[0], &large, &[0]);\n+    check_intersection(&large, &[0], &[0]);\n+    check_intersection(&[999], &large, &[999]);\n+    check_intersection(&large, &[999], &[999]);\n+    check_intersection(&[1000], &large, &[]);\n+    check_intersection(&large, &[1000], &[]);\n+    check_intersection(&[11, 5000, 1, 3, 77, 8924, 103],\n+                       &large,\n+                       &[1, 3, 11, 77, 103]);\n }\n \n #[test]\n@@ -84,6 +98,18 @@ fn test_difference() {\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n+    let large = (0..1000).collect::<Vec<_>>();\n+    check_difference(&[], &large, &[]);\n+    check_difference(&[-1], &large, &[-1]);\n+    check_difference(&[0], &large, &[]);\n+    check_difference(&[999], &large, &[]);\n+    check_difference(&[1000], &large, &[1000]);\n+    check_difference(&[11, 5000, 1, 3, 77, 8924, 103],\n+                     &large,\n+                     &[5000, 8924]);\n+    check_difference(&large, &[], &large);\n+    check_difference(&large, &[-1], &large);\n+    check_difference(&large, &[1000], &large);\n }\n \n #[test]\n@@ -114,6 +140,41 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+// Only tests the simple function definition with respect to intersection\n+fn test_is_disjoint() {\n+    let one = [1].into_iter().collect::<BTreeSet<_>>();\n+    let two = [2].into_iter().collect::<BTreeSet<_>>();\n+    assert!(one.is_disjoint(&two));\n+}\n+\n+#[test]\n+// Also tests the trivial function definition of is_superset\n+fn test_is_subset() {\n+    fn is_subset(a: &[i32], b: &[i32]) -> bool {\n+        let set_a = a.iter().collect::<BTreeSet<_>>();\n+        let set_b = b.iter().collect::<BTreeSet<_>>();\n+        set_a.is_subset(&set_b)\n+    }\n+\n+    assert_eq!(is_subset(&[], &[]), true);\n+    assert_eq!(is_subset(&[], &[1, 2]), true);\n+    assert_eq!(is_subset(&[0], &[1, 2]), false);\n+    assert_eq!(is_subset(&[1], &[1, 2]), true);\n+    assert_eq!(is_subset(&[2], &[1, 2]), true);\n+    assert_eq!(is_subset(&[3], &[1, 2]), false);\n+    assert_eq!(is_subset(&[1, 2], &[1]), false);\n+    assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n+    assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n+    let large = (0..1000).collect::<Vec<_>>();\n+    assert_eq!(is_subset(&[], &large), true);\n+    assert_eq!(is_subset(&large, &[]), false);\n+    assert_eq!(is_subset(&[-1], &large), false);\n+    assert_eq!(is_subset(&[0], &large), true);\n+    assert_eq!(is_subset(&[1, 2], &large), true);\n+    assert_eq!(is_subset(&[999, 1000], &large), false);\n+}\n+\n #[test]\n fn test_zip() {\n     let mut x = BTreeSet::new();"}, {"sha": "122ef9c79c2764f258423526497621ecd0f473d3", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -1585,6 +1585,153 @@ impl<T> [T] {\n         sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Reorder the slice such that the element at `index` is at its final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n+    /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n+    /// (i.e. does not allocate), and `O(n)` worst-case. This function is also/ known as \"kth\n+    /// element\" in other libraries. It returns a triplet of the following values: all elements less\n+    /// than the one at the given index, the value at the given index, and all elements greater than\n+    /// the one at the given index.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Find the median\n+    /// v.partition_at_index(2);\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [-3, -5, 1, 2, 4] ||\n+    ///         v == [-5, -3, 1, 2, 4] ||\n+    ///         v == [-3, -5, 1, 4, 2] ||\n+    ///         v == [-5, -3, 1, 4, 2]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n+        where T: Ord\n+    {\n+        let mut f = |a: &T, b: &T| a.lt(b);\n+        sort::partition_at_index(self, index, &mut f)\n+    }\n+\n+    /// Reorder the slice with a comparator function such that the element at `index` is at its\n+    /// final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index` using the comparator function.\n+    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n+    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n+    /// values: all elements less than the one at the given index, the value at the given index,\n+    /// and all elements greater than the one at the given index, using the provided comparator\n+    /// function.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Find the median as if the slice were sorted in descending order.\n+    /// v.partition_at_index_by(2, |a, b| b.cmp(a));\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [2, 4, 1, -5, -3] ||\n+    ///         v == [2, 4, 1, -3, -5] ||\n+    ///         v == [4, 2, 1, -5, -3] ||\n+    ///         v == [4, 2, 1, -3, -5]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index_by<F>(&mut self, index: usize, mut compare: F)\n+                                    -> (&mut [T], &mut T, &mut [T])\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n+        let mut f = |a: &T, b: &T| compare(a, b) == Less;\n+        sort::partition_at_index(self, index, &mut f)\n+    }\n+\n+    /// Reorder the slice with a key extraction function such that the element at `index` is at its\n+    /// final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index` using the key extraction function.\n+    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n+    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n+    /// values: all elements less than the one at the given index, the value at the given index, and\n+    /// all elements greater than the one at the given index, using the provided key extraction\n+    /// function.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Return the median as if the array were sorted according to absolute value.\n+    /// v.partition_at_index_by_key(2, |a| a.abs());\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [1, 2, -3, 4, -5] ||\n+    ///         v == [1, 2, -3, -5, 4] ||\n+    ///         v == [2, 1, -3, 4, -5] ||\n+    ///         v == [2, 1, -3, -5, 4]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index_by_key<K, F>(&mut self, index: usize, mut f: F)\n+                                           -> (&mut [T], &mut T, &mut [T])\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        let mut g = |a: &T, b: &T| f(a).lt(&f(b));\n+        sort::partition_at_index(self, index, &mut g)\n+    }\n+\n     /// Moves all consecutive repeated elements to the end of the slice according to the\n     /// [`PartialEq`] trait implementation.\n     ///"}, {"sha": "68f1fb4b526adf902069592e1b57dab09730d612", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -691,3 +691,92 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n \n     recurse(v, &mut is_less, None, limit);\n }\n+\n+fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_less: &mut F\n+                                    , mut pred: Option<&'a T>) where F: FnMut(&T, &T) -> bool\n+{\n+    loop {\n+        // For slices of up to this length it's probably faster to simply sort them.\n+        const MAX_INSERTION: usize = 10;\n+        if v.len() <= MAX_INSERTION {\n+            insertion_sort(v, is_less);\n+            return;\n+        }\n+\n+        // Choose a pivot\n+        let (pivot, _) = choose_pivot(v, is_less);\n+\n+        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n+        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n+        // This case is usually hit when the slice contains many duplicate elements.\n+        if let Some(p) = pred {\n+            if !is_less(p, &v[pivot]) {\n+                let mid = partition_equal(v, pivot, is_less);\n+\n+                // If we've passed our index, then we're good.\n+                if mid > index {\n+                    return;\n+                }\n+\n+                // Otherwise, continue sorting elements greater than the pivot.\n+                v = &mut v[mid..];\n+                index = index - mid;\n+                pred = None;\n+                continue;\n+            }\n+        }\n+\n+        let (mid, _) = partition(v, pivot, is_less);\n+\n+        // Split the slice into `left`, `pivot`, and `right`.\n+        let (left, right) = {v}.split_at_mut(mid);\n+        let (pivot, right) = right.split_at_mut(1);\n+        let pivot = &pivot[0];\n+\n+        if mid < index {\n+            v = right;\n+            index = index - mid - 1;\n+            pred = Some(pivot);\n+        } else if mid > index {\n+            v = left;\n+        } else {\n+            // If mid == index, then we're done, since partition() guaranteed that all elements\n+            // after mid are greater than or equal to mid.\n+            return;\n+        }\n+    }\n+}\n+\n+pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n+                                -> (&mut [T], &mut T, &mut [T]) where F: FnMut(&T, &T) -> bool\n+{\n+    use cmp::Ordering::Less;\n+    use cmp::Ordering::Greater;\n+\n+    if index >= v.len() {\n+        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n+    }\n+\n+    if mem::size_of::<T>() == 0 {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n+    } else if index == v.len() - 1 {\n+        // Find max element and place it in the last position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (max_index, _) = v.iter().enumerate().max_by(\n+            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        v.swap(max_index, index);\n+    } else if index == 0 {\n+        // Find min element and place it in the first position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (min_index, _) = v.iter().enumerate().min_by(\n+            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        v.swap(min_index, index);\n+    } else {\n+        partition_at_index_loop(v, index, &mut is_less, None);\n+    }\n+\n+    let (left, right) = v.split_at_mut(index);\n+    let (pivot, right) = right.split_at_mut(1);\n+    let pivot = &mut pivot[0];\n+    (left, pivot, right)\n+}"}, {"sha": "392a0ffabe3d62b5cf74ac6f2e0bf3efe0ec5074", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -18,6 +18,7 @@\n #![feature(raw)]\n #![feature(slice_patterns)]\n #![feature(sort_internals)]\n+#![feature(slice_partition_at_index)]\n #![feature(specialization)]\n #![feature(step_trait)]\n #![feature(str_internals)]"}, {"sha": "007283b5f69c874201ce6bf3bd10626c4f3663e2", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -1093,6 +1093,124 @@ fn sort_unstable() {\n     assert!(v == [0xDEADBEEF]);\n }\n \n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(miri))] // Miri does not support entropy\n+fn partition_at_index() {\n+    use core::cmp::Ordering::{Equal, Greater, Less};\n+    use rand::rngs::SmallRng;\n+    use rand::seq::SliceRandom;\n+    use rand::{FromEntropy, Rng};\n+\n+    let mut rng = SmallRng::from_entropy();\n+\n+    for len in (2..21).chain(500..501) {\n+        let mut orig = vec![0; len];\n+\n+        for &modulus in &[5, 10, 1000] {\n+            for _ in 0..10 {\n+                for i in 0..len {\n+                    orig[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                let v_sorted = {\n+                    let mut v = orig.clone();\n+                    v.sort();\n+                    v\n+                };\n+\n+                // Sort in default order.\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    v.partition_at_index(pivot);\n+\n+                    assert_eq!(v_sorted[pivot], v[pivot]);\n+                    for i in 0..pivot {\n+                        for j in pivot..len {\n+                            assert!(v[i] <= v[j]);\n+                        }\n+                    }\n+                }\n+\n+                // Sort in ascending order.\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    let (left, pivot, right) = v.partition_at_index_by(pivot, |a, b| a.cmp(b));\n+\n+                    assert_eq!(left.len() + right.len(), len - 1);\n+\n+                    for l in left {\n+                        assert!(l <= pivot);\n+                        for r in right.iter_mut() {\n+                            assert!(l <= r);\n+                            assert!(pivot <= r);\n+                        }\n+                    }\n+                }\n+\n+                // Sort in descending order.\n+                let sort_descending_comparator = |a: &i32, b: &i32| b.cmp(a);\n+                let v_sorted_descending = {\n+                    let mut v = orig.clone();\n+                    v.sort_by(sort_descending_comparator);\n+                    v\n+                };\n+\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    v.partition_at_index_by(pivot, sort_descending_comparator);\n+\n+                    assert_eq!(v_sorted_descending[pivot], v[pivot]);\n+                    for i in 0..pivot {\n+                        for j in pivot..len {\n+                            assert!(v[j] <= v[i]);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort at index using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    let mut v = [0; 500];\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+\n+    for pivot in 0..v.len() {\n+        v.partition_at_index_by(pivot, |_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n+        v.sort();\n+        for i in 0..v.len() {\n+            assert_eq!(v[i], i as i32);\n+        }\n+    }\n+\n+    // Should not panic.\n+    [(); 10].partition_at_index(0);\n+    [(); 10].partition_at_index(5);\n+    [(); 10].partition_at_index(9);\n+    [(); 100].partition_at_index(0);\n+    [(); 100].partition_at_index(50);\n+    [(); 100].partition_at_index(99);\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.partition_at_index(0);\n+    assert!(v == [0xDEADBEEF]);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 0 greater than length of slice\")]\n+fn partition_at_index_zero_length() {\n+    [0i32; 0].partition_at_index(0);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 20 greater than length of slice\")]\n+fn partition_at_index_past_length() {\n+    [0i32; 10].partition_at_index(20);\n+}\n+\n pub mod memchr {\n     use core::slice::memchr::{memchr, memrchr};\n "}, {"sha": "8424c096e88c019d2907d05436dcfd12c07bdc7f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -4,7 +4,7 @@\n \n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n-use crate::hir::{self, HirId, InlineAsm};\n+use crate::hir::{self, HirId, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n@@ -25,7 +25,7 @@ use std::slice;\n use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::{self, Name};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{Subst, SubstsRef};\n@@ -772,7 +772,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n-    pub user_ty: UserTypeProjections<'tcx>,\n+    pub user_ty: UserTypeProjections,\n \n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n@@ -1735,7 +1735,7 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Statement<'_>>() == 56);\n+static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Statement<'_>>() == 48);\n \n impl<'tcx> Statement<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -1779,12 +1779,9 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Local),\n \n-    /// Executes a piece of inline Assembly.\n-    InlineAsm {\n-        asm: Box<InlineAsm>,\n-        outputs: Box<[Place<'tcx>]>,\n-        inputs: Box<[(Span, Operand<'tcx>)]>,\n-    },\n+    /// Executes a piece of inline Assembly. Stored in a Box to keep the size\n+    /// of `StatementKind` low.\n+    InlineAsm(Box<InlineAsm<'tcx>>),\n \n     /// Retag references in the given place, ensuring they got fresh tags. This is\n     /// part of the Stacked Borrows model. These statements are currently only interpreted\n@@ -1805,7 +1802,7 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection<'tcx>>),\n+    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1858,6 +1855,13 @@ pub enum FakeReadCause {\n     ForLet,\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct InlineAsm<'tcx> {\n+    pub asm: HirInlineAsm,\n+    pub outputs: Box<[Place<'tcx>]>,\n+    pub inputs: Box<[(Span, Operand<'tcx>)]>,\n+}\n+\n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n@@ -1880,11 +1884,8 @@ impl<'tcx> Debug for Statement<'tcx> {\n                 ref place,\n                 variant_index,\n             } => write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index),\n-            InlineAsm {\n-                ref asm,\n-                ref outputs,\n-                ref inputs,\n-            } => write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs),\n+            InlineAsm(ref asm) =>\n+                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs),\n             AscribeUserType(ref place, ref variance, ref c_ty) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n@@ -1939,14 +1940,14 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// `PlaceProjection` etc below.\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Projection<'tcx, B, V, T> {\n+pub struct Projection<B, V, T> {\n     pub base: B,\n-    pub elem: ProjectionElem<'tcx, V, T>,\n+    pub elem: ProjectionElem<V, T>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum ProjectionElem<'tcx, V, T> {\n+pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n     Index(V),\n@@ -1980,16 +1981,18 @@ pub enum ProjectionElem<'tcx, V, T> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(&'tcx AdtDef, VariantIdx),\n+    ///\n+    /// The included Symbol is the name of the variant, used for printing MIR.\n+    Downcast(Option<Symbol>, VariantIdx),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n+pub type PlaceProjection<'tcx> = Projection<Place<'tcx>, Local, Ty<'tcx>>;\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n+pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n // at least on 64 bit systems, `PlaceElem` should not be larger than two pointers\n static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n@@ -1998,7 +2001,7 @@ static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n-pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n+pub type ProjectionKind = ProjectionElem<(), ()>;\n \n newtype_index! {\n     pub struct Field {\n@@ -2019,7 +2022,9 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n+        self.elem(ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index))\n     }\n \n     pub fn index(self, index: Local) -> Place<'tcx> {\n@@ -2080,8 +2085,11 @@ impl<'tcx> Debug for Place<'tcx> {\n                 )\n             },\n             Projection(ref data) => match data.elem {\n-                ProjectionElem::Downcast(ref adt_def, index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \"({:?} as {})\", data.base, name)\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \"({:?} as variant#{:?})\", data.base, index)\n                 }\n                 ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n                 ProjectionElem::Field(field, ty) => {\n@@ -2542,36 +2550,36 @@ pub struct Constant<'tcx> {\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UserTypeProjections<'tcx> {\n-    pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n+pub struct UserTypeProjections {\n+    pub(crate) contents: Vec<(UserTypeProjection, Span)>,\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections<'tcx> {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections {\n         contents\n     }\n }\n \n-impl<'tcx> UserTypeProjections<'tcx> {\n+impl<'tcx> UserTypeProjections {\n     pub fn none() -> Self {\n         UserTypeProjections { contents: vec![] }\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection<'tcx>, Span)>) -> Self {\n+    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection, Span)>) -> Self {\n         UserTypeProjections { contents: projs.collect() }\n     }\n \n-    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection<'tcx>, Span)> {\n+    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection, Span)> {\n         self.contents.iter()\n     }\n \n-    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection<'tcx>> {\n+    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n \n     pub fn push_projection(\n         mut self,\n-        user_ty: &UserTypeProjection<'tcx>,\n+        user_ty: &UserTypeProjection,\n         span: Span,\n     ) -> Self {\n         self.contents.push((user_ty.clone(), span));\n@@ -2580,7 +2588,7 @@ impl<'tcx> UserTypeProjections<'tcx> {\n \n     fn map_projections(\n         mut self,\n-        mut f: impl FnMut(UserTypeProjection<'tcx>) -> UserTypeProjection<'tcx>\n+        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection\n     ) -> Self {\n         self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n         self\n@@ -2628,14 +2636,14 @@ impl<'tcx> UserTypeProjections<'tcx> {\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UserTypeProjection<'tcx> {\n+pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n-    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n+    pub projs: Vec<ProjectionElem<(), ()>>,\n }\n \n-impl<'tcx> Copy for ProjectionKind<'tcx> { }\n+impl Copy for ProjectionKind { }\n \n-impl<'tcx> UserTypeProjection<'tcx> {\n+impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n         self.projs.push(ProjectionElem::Index(()));\n         self\n@@ -2662,15 +2670,17 @@ impl<'tcx> UserTypeProjection<'tcx> {\n         variant_index: VariantIdx,\n         field: Field,\n     ) -> Self {\n-        self.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        self.projs.push(ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index));\n         self.projs.push(ProjectionElem::Field(field, ()));\n         self\n     }\n }\n \n-CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n+CloneTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n-impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n@@ -3140,13 +3150,21 @@ EnumTypeFoldableImpl! {\n         (StatementKind::SetDiscriminant) { place, variant_index },\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n-        (StatementKind::InlineAsm) { asm, outputs, inputs },\n+        (StatementKind::InlineAsm)(a),\n         (StatementKind::Retag)(kind, place),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),\n     }\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for InlineAsm<'tcx> {\n+        asm,\n+        outputs,\n+        inputs,\n+    }\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx, T> TypeFoldable<'tcx> for ClearCrossCrate<T> {\n         (ClearCrossCrate::Clear),\n@@ -3428,7 +3446,7 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n+impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<B, V, T>\n where\n     B: TypeFoldable<'tcx>,\n     V: TypeFoldable<'tcx>,"}, {"sha": "0eb37f0ac9e9604b6b71466ce1b2d95769bc13ba", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 43, "deletions": 76, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -4,21 +4,17 @@\n  */\n \n use crate::mir::*;\n-use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::layout::VariantIdx;\n use crate::hir;\n use crate::ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum PlaceTy<'tcx> {\n-    /// Normal type.\n-    Ty { ty: Ty<'tcx> },\n-\n-    /// Downcast to a particular variant of an enum.\n-    Downcast { adt_def: &'tcx AdtDef,\n-               substs: SubstsRef<'tcx>,\n-               variant_index: VariantIdx },\n+pub struct PlaceTy<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    /// Downcast to a particular variant of an enum, if included.\n+    pub variant_index: Option<VariantIdx>,\n }\n \n static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n@@ -27,16 +23,7 @@ static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n \n impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n-        PlaceTy::Ty { ty }\n-    }\n-\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            PlaceTy::Ty { ty } =>\n-                ty,\n-            PlaceTy::Downcast { adt_def, substs, variant_index: _ } =>\n-                tcx.mk_adt(adt_def, substs),\n-        }\n+        PlaceTy { ty, variant_index: None }\n     }\n \n     /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n@@ -48,21 +35,20 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n-        // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n-        let answer = match (self, VariantIdx::new(0)) {\n-            (PlaceTy::Ty {\n-                ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n-            (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n-                let variant_def = &adt_def.variants[variant_index];\n+        let answer = match self.ty.sty {\n+            ty::TyKind::Adt(adt_def, substs) => {\n+                let variant_def = match self.variant_index {\n+                    None => adt_def.non_enum_variant(),\n+                    Some(variant_index) => {\n+                        assert!(adt_def.is_enum());\n+                        &adt_def.variants[variant_index]\n+                    }\n+                };\n                 let field_def = &variant_def.fields[f.index()];\n                 field_def.ty(tcx, substs)\n             }\n-            (PlaceTy::Ty { ty }, _) => {\n-                match ty.sty {\n-                    ty::Tuple(ref tys) => tys[f.index()],\n-                    _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n-                }\n-            }\n+            ty::Tuple(ref tys) => tys[f.index()],\n+            _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n         };\n         debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n         answer\n@@ -86,70 +72,51 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn projection_ty_core<V, T>(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        elem: &ProjectionElem<'tcx, V, T>,\n+        elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n         -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug, T: ::std::fmt::Debug\n     {\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n-                let ty = self.to_ty(tcx)\n+                let ty = self.ty\n                              .builtin_deref(true)\n                              .unwrap_or_else(|| {\n                                  bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n                              })\n                              .ty;\n-                PlaceTy::Ty {\n-                    ty,\n-                }\n+                PlaceTy::from_ty(ty)\n             }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n-                PlaceTy::Ty {\n-                    ty: self.to_ty(tcx).builtin_index().unwrap()\n-                },\n+                PlaceTy::from_ty(self.ty.builtin_index().unwrap()),\n             ProjectionElem::Subslice { from, to } => {\n-                let ty = self.to_ty(tcx);\n-                PlaceTy::Ty {\n-                    ty: match ty.sty {\n-                        ty::Array(inner, size) => {\n-                            let size = size.unwrap_usize(tcx);\n-                            let len = size - (from as u64) - (to as u64);\n-                            tcx.mk_array(inner, len)\n-                        }\n-                        ty::Slice(..) => ty,\n-                        _ => {\n-                            bug!(\"cannot subslice non-array type: `{:?}`\", self)\n-                        }\n-                    }\n-                }\n-            }\n-            ProjectionElem::Downcast(adt_def1, index) =>\n-                match self.to_ty(tcx).sty {\n-                    ty::Adt(adt_def, substs) => {\n-                        assert!(adt_def.is_enum());\n-                        assert!(index.as_usize() < adt_def.variants.len());\n-                        assert_eq!(adt_def, adt_def1);\n-                        PlaceTy::Downcast { adt_def,\n-                                            substs,\n-                                            variant_index: index }\n+                PlaceTy::from_ty(match self.ty.sty {\n+                    ty::Array(inner, size) => {\n+                        let size = size.unwrap_usize(tcx);\n+                        let len = size - (from as u64) - (to as u64);\n+                        tcx.mk_array(inner, len)\n                     }\n+                    ty::Slice(..) => self.ty,\n                     _ => {\n-                        bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n+                        bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                     }\n-                },\n+                })\n+            }\n+            ProjectionElem::Downcast(_name, index) =>\n+                PlaceTy { ty: self.ty, variant_index: Some(index) },\n             ProjectionElem::Field(ref f, ref fty) =>\n-                PlaceTy::Ty { ty: handle_field(&self, f, fty) },\n+                PlaceTy::from_ty(handle_field(&self, f, fty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer\n     }\n }\n \n-EnumTypeFoldableImpl! {\n+BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n-        (PlaceTy::Ty) { ty },\n-        (PlaceTy::Downcast) { adt_def, substs, variant_index },\n+        ty,\n+        variant_index,\n     }\n }\n \n@@ -159,9 +126,9 @@ impl<'tcx> Place<'tcx> {\n     {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n+                PlaceTy::from_ty(local_decls.local_decls()[index].ty),\n             Place::Base(PlaceBase::Static(ref data)) =>\n-                PlaceTy::Ty { ty: data.ty },\n+                PlaceTy::from_ty(data.ty),\n             Place::Projection(ref proj) =>\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n@@ -186,7 +153,7 @@ impl<'tcx> Place<'tcx> {\n         match place {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(mir, *tcx).to_ty(*tcx);\n+                    let base_ty = proj.base.ty(mir, *tcx).ty;\n \n                     if (base_ty.is_closure() || base_ty.is_generator()) &&\n                         (!by_ref || mir.upvar_decls[field.index()].by_ref)\n@@ -218,7 +185,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.mk_array(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref place) => {\n-                let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+                let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: place_ty,\n@@ -244,7 +211,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 operand.ty(local_decls, tcx)\n             }\n             Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).to_ty(tcx);\n+                let ty = place.ty(local_decls, tcx).ty;\n                 if let ty::Adt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n@@ -293,7 +260,7 @@ impl<'tcx> Operand<'tcx> {\n     {\n         match self {\n             &Operand::Copy(ref l) |\n-            &Operand::Move(ref l) => l.ty(local_decls, tcx).to_ty(tcx),\n+            &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n             &Operand::Constant(ref c) => c.ty,\n         }\n     }"}, {"sha": "b04c28cde571cdfea5c9bf737dd135953b7ad2ea", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -137,7 +137,7 @@ macro_rules! make_mir_visitor {\n             fn visit_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n                                      variance: & $($mutability)? ty::Variance,\n-                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                                     user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n@@ -205,7 +205,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n@@ -391,15 +391,15 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n-                    StatementKind::InlineAsm { outputs, inputs, asm: _ } => {\n-                        for output in & $($mutability)? outputs[..] {\n+                    StatementKind::InlineAsm(asm) => {\n+                        for output in & $($mutability)? asm.outputs[..] {\n                             self.visit_place(\n                                 output,\n                                 PlaceContext::MutatingUse(MutatingUseContext::AsmOutput),\n                                 location\n                             );\n                         }\n-                        for (span, input) in & $($mutability)? inputs[..] {\n+                        for (span, input) in & $($mutability)? asm.inputs[..] {\n                             self.visit_span(span);\n                             self.visit_operand(input, location);\n                         }\n@@ -700,7 +700,7 @@ macro_rules! make_mir_visitor {\n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n                                      _variance: & $($mutability)? ty::Variance,\n-                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                                     user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -777,7 +777,7 @@ macro_rules! make_mir_visitor {\n                                                     min_length: _,\n                                                     from_end: _ } => {\n                     }\n-                    ProjectionElem::Downcast(_adt_def, _variant_index) => {\n+                    ProjectionElem::Downcast(_name, _variant_index) => {\n                     }\n                 }\n             }\n@@ -851,7 +851,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection,\n             ) {\n             }\n "}, {"sha": "03936a82c71512b80cb05d982d0ea83f2773218a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -125,7 +125,7 @@ pub struct CtxtInterners<'tcx> {\n     clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n-    projs: InternedSet<'tcx, List<ProjectionKind<'tcx>>>,\n+    projs: InternedSet<'tcx, List<ProjectionKind>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n@@ -1802,7 +1802,7 @@ nop_list_lift!{Ty<'a> => Ty<'tcx>}\n nop_list_lift!{ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n-nop_list_lift!{ProjectionKind<'a> => ProjectionKind<'tcx>}\n+nop_list_lift!{ProjectionKind => ProjectionKind}\n \n // this is the impl for `&'a InternalSubsts<'a>`\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n@@ -2261,9 +2261,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, InternalSubsts<'t\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[ProjectionKind<'lcx>]>\n-    for Interned<'tcx, List<ProjectionKind<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [ProjectionKind<'lcx>] {\n+impl<'tcx> Borrow<[ProjectionKind]>\n+    for Interned<'tcx, List<ProjectionKind>> {\n+    fn borrow<'a>(&'a self) -> &'a [ProjectionKind] {\n         &self.0[..]\n     }\n }\n@@ -2391,22 +2391,22 @@ direct_interners!('tcx,\n );\n \n macro_rules! slice_interners {\n-    ($($field:ident: $method:ident($ty:ident)),+) => (\n+    ($($field:ident: $method:ident($ty:ty)),+) => (\n         $(intern_method!( 'tcx, $field: $method(\n-            &[$ty<'tcx>],\n+            &[$ty],\n             |a, v| List::from_arena(a, v),\n             Deref::deref,\n-            |xs: &[$ty<'_>]| xs.iter().any(keep_local)) -> List<$ty<'tcx>>);)+\n-    )\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> List<$ty>);)+\n+    );\n }\n \n slice_interners!(\n-    existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n-    predicates: _intern_predicates(Predicate),\n-    type_list: _intern_type_list(Ty),\n-    substs: _intern_substs(Kind),\n-    clauses: _intern_clauses(Clause),\n-    goal_list: _intern_goals(Goal),\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n+    predicates: _intern_predicates(Predicate<'tcx>),\n+    type_list: _intern_type_list(Ty<'tcx>),\n+    substs: _intern_substs(Kind<'tcx>),\n+    clauses: _intern_clauses(Clause<'tcx>),\n+    goal_list: _intern_goals(Goal<'tcx>),\n     projs: _intern_projs(ProjectionKind)\n );\n \n@@ -2774,7 +2774,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn intern_projs(self, ps: &[ProjectionKind<'tcx>]) -> &'tcx List<ProjectionKind<'tcx>> {\n+    pub fn intern_projs(self, ps: &[ProjectionKind]) -> &'tcx List<ProjectionKind> {\n         if ps.len() == 0 {\n             List::empty()\n         } else {"}, {"sha": "262dc30033472b6bc7c90b8a313d8b920a6f0d13", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -936,7 +936,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_projs(&v)"}, {"sha": "8253a1672454d33cb688269101ab5e05259f3904", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -172,14 +172,14 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n                     .projection_ty(cx.tcx(), &proj.elem)\n-                    .to_ty(cx.tcx());\n+                    .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx()));\n+                    let layout = cx.layout_of(base_ty.ty);\n                     if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -247,7 +247,7 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n                 let ty = mir::Place::Base(mir::PlaceBase::Local(local)).ty(self.fx.mir,\n                                                                            self.fx.cx.tcx());\n-                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx()));\n+                let ty = self.fx.monomorphize(&ty.ty);\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "65f7e023fa226a00bce0ec225aa7b81ccbf2e034", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n+        let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = monomorphize::resolve_drop_in_place(bx.tcx(), ty);\n "}, {"sha": "2b7b900475332422cd0f15bf1bf93690996db57f", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -494,8 +494,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n                             bx.cx().const_usize(from as u64));\n-                        let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem).to_ty(tcx);\n+                        let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n+                            .projection_ty(tcx, &projection.elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n@@ -523,6 +523,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n         let place_ty = place.ty(self.mir, tcx);\n-        self.monomorphize(&place_ty.to_ty(tcx))\n+        self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "618d05245d2caddfa38c2d199c91125eb4414cc3", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -68,13 +68,13 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n                 bx\n             }\n-            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                let outputs = outputs.iter().map(|output| {\n+            mir::StatementKind::InlineAsm(ref asm) => {\n+                let outputs = asm.outputs.iter().map(|output| {\n                     self.codegen_place(&mut bx, output)\n                 }).collect();\n \n-                let input_vals = inputs.iter()\n-                    .fold(Vec::with_capacity(inputs.len()), |mut acc, (span, input)| {\n+                let input_vals = asm.inputs.iter()\n+                    .fold(Vec::with_capacity(asm.inputs.len()), |mut acc, (span, input)| {\n                         let op = self.codegen_operand(&mut bx, input);\n                         if let OperandValue::Immediate(_) = op.val {\n                             acc.push(op.immediate());\n@@ -85,8 +85,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         acc\n                 });\n \n-                if input_vals.len() == inputs.len() {\n-                    let res = bx.codegen_inline_asm(asm, outputs, input_vals);\n+                if input_vals.len() == asm.inputs.len() {\n+                    let res = bx.codegen_inline_asm(&asm.asm, outputs, input_vals);\n                     if !res {\n                         span_err!(bx.sess(), statement.source_info.span, E0668,\n                                   \"malformed inline assembly\");"}, {"sha": "c04a36fe9c69c66d38129201fa0f83b72af24818", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -13,6 +13,7 @@ use rustc::mir::{\n     Static, StaticKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -201,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let ty = used_place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+            let ty = used_place.ty(self.mir, self.infcx.tcx).ty;\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -216,7 +217,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                 let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n                 let note_msg = match opt_name {\n                     Some(ref name) => format!(\"`{}`\", name),\n@@ -596,8 +597,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let is_union = |place: &Place<'tcx>| -> bool {\n-            place.ty(self.mir, self.infcx.tcx)\n-                .to_ty(self.infcx.tcx)\n+            place.ty(self.mir, self.infcx.tcx).ty\n                 .ty_adt_def()\n                 .map(|adt| adt.is_union())\n                 .unwrap_or(false)\n@@ -646,7 +646,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                             // Also compute the name of the union type, eg. `Foo` so we\n                             // can add a helpful note with it.\n-                            let ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n \n                             return Some((desc_base, desc_first, desc_second, ty.to_string()));\n                         },\n@@ -1761,20 +1761,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Place<'_>, field: Field) -> String {\n+    fn describe_field(&self, base: &Place<'tcx>, field: Field) -> String {\n         match *base {\n             Place::Base(PlaceBase::Local(local)) => {\n                 let local = &self.mir.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field)\n+                self.describe_field_from_ty(&local.ty, field, None)\n             }\n             Place::Base(PlaceBase::Static(ref static_)) =>\n-                self.describe_field_from_ty(&static_.ty, field),\n+                self.describe_field_from_ty(&static_.ty, field, None),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) =>\n-                    def.variants[variant_index].fields[field.index()].ident.to_string(),\n+                ProjectionElem::Downcast(_, variant_index) => {\n+                    let base_ty = base.ty(self.mir, self.infcx.tcx).ty;\n+                    self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n+                }\n                 ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field)\n+                    self.describe_field_from_ty(&field_type, field, None)\n                 }\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n@@ -1786,24 +1788,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field_index`nth field of `ty`\n-    fn describe_field_from_ty(&self, ty: &ty::Ty<'_>, field: Field) -> String {\n+    fn describe_field_from_ty(\n+        &self,\n+        ty: &ty::Ty<'_>,\n+        field: Field,\n+        variant_index: Option<VariantIdx>\n+    ) -> String {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field)\n+            self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n         } else {\n             match ty.sty {\n-                ty::Adt(def, _) => if def.is_enum() {\n-                    field.index().to_string()\n-                } else {\n-                    def.non_enum_variant().fields[field.index()]\n+                ty::Adt(def, _) => {\n+                    let variant = if let Some(idx) = variant_index {\n+                        assert!(def.is_enum());\n+                        &def.variants[idx]\n+                    } else {\n+                        def.non_enum_variant()\n+                    };\n+                    variant.fields[field.index()]\n                         .ident\n                         .to_string()\n                 },\n                 ty::Tuple(_) => field.index().to_string(),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    self.describe_field_from_ty(&ty, field)\n+                    self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n-                ty::Array(ty, _) | ty::Slice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::Array(ty, _) | ty::Slice(ty) =>\n+                    self.describe_field_from_ty(&ty, field, variant_index),\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // Convert the def-id into a node-id. node-ids are only valid for\n                     // the local code in the current crate, so this returns an `Option` in case\n@@ -1861,15 +1873,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n+                                base.ty(self.mir, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                        let base_ty = base.ty(self.mir, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "a8c151a22eebcd7b5d5c495bd23f3d05c15df9a2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -525,16 +525,12 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     flow_state,\n                 );\n             }\n-            StatementKind::InlineAsm {\n-                ref asm,\n-                ref outputs,\n-                ref inputs,\n-            } => {\n+            StatementKind::InlineAsm(ref asm) => {\n                 let context = ContextKind::InlineAsm.new(location);\n-                for (o, output) in asm.outputs.iter().zip(outputs.iter()) {\n+                for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n-                        // be encoeded through MIR place derefs instead.\n+                        // be encoded through MIR place derefs instead.\n                         self.access_place(\n                             context,\n                             (output, o.span),\n@@ -558,7 +554,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                         );\n                     }\n                 }\n-                for (_, input) in inputs.iter() {\n+                for (_, input) in asm.inputs.iter() {\n                     self.consume_operand(context, (input, span), flow_state);\n                 }\n             }\n@@ -616,8 +612,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n \n                 // Erase the regions.\n-                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty)\n-                    .to_ty(self.infcx.tcx);\n+                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n \n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n@@ -1641,7 +1636,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // assigning to `P.f` requires `P` itself\n                             // be already initialized\n                             let tcx = self.infcx.tcx;\n-                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                            match base.ty(self.mir, tcx).ty.sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n                                         context, InitializationRequiringAction::Assignment,\n@@ -1746,7 +1741,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).to_ty(tcx).sty {\n+                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).ty.sty {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n@@ -2007,7 +2002,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {"}, {"sha": "b6e7996586e4a496901ef2ce55054b064a69eccb", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -266,7 +266,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         // Inspect the type of the content behind the\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n                             .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n@@ -530,7 +530,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     // We're only interested in assignments (in particular, where the\n                     // assignment came from - was it an `Rc` or `Arc`?).\n                     if let StatementKind::Assign(_, box Rvalue::Ref(_, _, source)) = &stmt.kind {\n-                        let ty = source.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n                             ty::TyKind::Ref(_, ty, _) => ty,\n                             _ => ty,\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             _ => continue,\n                         };\n \n-                        let ty = source.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n                             ty::TyKind::Ref(_, ty, _) => ty,\n                             _ => ty,\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             base,\n             elem: ProjectionElem::Deref,\n         }) = place {\n-            if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_unsafe_ptr() {\n+            if base.ty(self.mir, self.infcx.tcx).ty.is_unsafe_ptr() {\n                 return BorrowedContentSource::DerefRawPointer;\n             }\n         }"}, {"sha": "8a55a59b15b17f728216ac16c45f68ac92858b6d", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                        the_place_err.ty(self.mir, self.infcx.tcx).ty\n                     ));\n \n                     reason = if access_place.is_upvar_field_projection(self.mir,\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let pointer_type =\n-                        if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_region_ptr() {\n+                        if base.ty(self.mir, self.infcx.tcx).ty.is_region_ptr() {\n                             \"`&` reference\"\n                         } else {\n                             \"`*const` pointer\"\n@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx),\n+                    base.ty(self.mir, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -304,7 +304,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "bf9cff1e4ae03c8f65f757f579591a2da615838c", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -174,7 +174,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         &mut self,\n         _place: &Place<'tcx>,\n         _variance: &ty::Variance,\n-        _user_ty: &UserTypeProjection<'tcx>,\n+        _user_ty: &UserTypeProjection,\n         _location: Location,\n     ) {\n     }"}, {"sha": "8217200b05788f96707a0a24008fe42265a33cfb", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -92,16 +92,12 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     JustWrite,\n                 );\n             }\n-            StatementKind::InlineAsm {\n-                ref asm,\n-                ref outputs,\n-                ref inputs,\n-            } => {\n+            StatementKind::InlineAsm(ref asm) => {\n                 let context = ContextKind::InlineAsm.new(location);\n-                for (o, output) in asm.outputs.iter().zip(outputs.iter()) {\n+                for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n-                        // be encoeded through MIR place derefs instead.\n+                        // be encoded through MIR place derefs instead.\n                         self.access_place(\n                             context,\n                             output,\n@@ -117,7 +113,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                         );\n                     }\n                 }\n-                for (_, input) in inputs.iter() {\n+                for (_, input) in asm.inputs.iter() {\n                     self.consume_operand(context, input);\n                 }\n             }"}, {"sha": "b06ebbdbf34f6719c03a586ff23cd8c5940b29d8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -450,9 +450,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n         let place_ty = match place {\n-            Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n-                ty: self.mir.local_decls[*index].ty,\n-            },\n+            Place::Base(PlaceBase::Local(index)) =>\n+                PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n             Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n                 let check_err =\n@@ -493,7 +492,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         check_err(self, place, ty, sty);\n                     }\n                 }\n-                PlaceTy::Ty { ty: sty }\n+                PlaceTy::from_ty(sty)\n             }\n             Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {\n@@ -502,12 +501,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n                 };\n                 let base_ty = self.sanitize_place(&proj.base, location, base_context);\n-                if let PlaceTy::Ty { ty } = base_ty {\n-                    if ty.references_error() {\n+                if base_ty.variant_index.is_none() {\n+                    if base_ty.ty.references_error() {\n                         assert!(self.errors_reported);\n-                        return PlaceTy::Ty {\n-                            ty: self.tcx().types.err,\n-                        };\n+                        return PlaceTy::from_ty(self.tcx().types.err);\n                     }\n                 }\n                 self.sanitize_projection(base_ty, &proj.elem, place, location)\n@@ -517,7 +514,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             let tcx = self.tcx();\n             let trait_ref = ty::TraitRef {\n                 def_id: tcx.lang_items().copy_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(place_ty.to_ty(tcx), &[]),\n+                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n             };\n \n             // In order to have a Copy operand, the type T of the\n@@ -615,40 +612,40 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n-        let base_ty = base.to_ty(tcx);\n+        let base_ty = base.ty;\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true);\n-                PlaceTy::Ty {\n-                    ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n+                PlaceTy::from_ty(\n+                    deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)\n-                    }),\n-                }\n+                    })\n+                )\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).to_ty(tcx);\n+                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).ty;\n                 if index_ty != tcx.types.usize {\n-                    PlaceTy::Ty {\n-                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n-                    }\n+                    PlaceTy::from_ty(\n+                        span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n+                    )\n                 } else {\n-                    PlaceTy::Ty {\n-                        ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                    PlaceTy::from_ty(\n+                        base_ty.builtin_index().unwrap_or_else(|| {\n                             span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                         }),\n-                    }\n+                    )\n                 }\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n-                PlaceTy::Ty {\n-                    ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                PlaceTy::from_ty(\n+                    base_ty.builtin_index().unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                     }),\n-                }\n+                )\n             }\n-            ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n-                ty: match base_ty.sty {\n+            ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n+                match base_ty.sty {\n                     ty::Array(inner, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_size = (from as u64) + (to as u64);\n@@ -666,35 +663,39 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     ty::Slice(..) => base_ty,\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n-            },\n-            ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n-                ty::Adt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+            ),\n+            ProjectionElem::Downcast(maybe_name, index) => match base_ty.sty {\n+                ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n-                        PlaceTy::Ty {\n-                            ty: span_mirbug_and_err!(\n+                        PlaceTy::from_ty(\n+                            span_mirbug_and_err!(\n                                 self,\n                                 place,\n                                 \"cast to variant #{:?} but enum only has {:?}\",\n                                 index,\n                                 adt_def.variants.len()\n                             ),\n-                        }\n+                        )\n                     } else {\n-                        PlaceTy::Downcast {\n-                            adt_def,\n-                            substs,\n-                            variant_index: index,\n+                        PlaceTy {\n+                            ty: base_ty,\n+                            variant_index: Some(index),\n                         }\n                     }\n                 }\n-                _ => PlaceTy::Ty {\n-                    ty: span_mirbug_and_err!(\n-                        self,\n-                        place,\n-                        \"can't downcast {:?} as {:?}\",\n-                        base_ty,\n-                        adt_def1\n-                    ),\n+                _ => {\n+                    let ty = if let Some(name) = maybe_name {\n+                        span_mirbug_and_err!(\n+                            self,\n+                            place,\n+                            \"can't downcast {:?} as {:?}\",\n+                            base_ty,\n+                            name\n+                        )\n+                    } else {\n+                        span_mirbug_and_err!(self, place, \"can't downcast {:?}\", base_ty)\n+                    };\n+                    PlaceTy::from_ty(ty)\n                 },\n             },\n             ProjectionElem::Field(field, fty) => {\n@@ -723,7 +724,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         field_count\n                     ),\n                 }\n-                PlaceTy::Ty { ty: fty }\n+                PlaceTy::from_ty(fty)\n             }\n         }\n     }\n@@ -743,12 +744,13 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy::Downcast {\n-                adt_def,\n-                substs,\n-                variant_index,\n-            } => (&adt_def.variants[variant_index], substs),\n-            PlaceTy::Ty { ty } => match ty.sty {\n+            PlaceTy { ty, variant_index: Some(variant_index) } => {\n+                match ty.sty {\n+                    ty::TyKind::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                    _ => bug!(\"can't have downcast of non-adt type\"),\n+                }\n+            }\n+            PlaceTy { ty, variant_index: None } => match ty.sty {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n                     (&adt_def.variants[VariantIdx::new(0)], substs),\n                 ty::Closure(def_id, substs) => {\n@@ -1161,7 +1163,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        user_ty: &UserTypeProjection<'tcx>,\n+        user_ty: &UserTypeProjection,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n@@ -1185,7 +1187,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n                 user_ty.base, annotated_type, user_ty.projs, curr_projected_ty);\n \n-        let ty = curr_projected_ty.to_ty(tcx);\n+        let ty = curr_projected_ty.ty;\n         self.relate_types(a, v, ty, locations, category)?;\n \n         Ok(())\n@@ -1333,7 +1335,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = place.ty(mir, tcx).ty;\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1385,7 +1387,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(mir, tcx).to_ty(tcx);\n+                let place_type = place.ty(mir, tcx).ty;\n                 let adt = match place_type.sty {\n                     TyKind::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1407,7 +1409,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n-                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = place.ty(mir, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1463,7 +1465,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 target: _,\n                 unwind: _,\n             } => {\n-                let place_ty = location.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = location.ty(mir, tcx).ty;\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = term_location.to_locations();\n@@ -1611,7 +1613,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, _target_block)) => {\n-                let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n+                let dest_ty = dest.ty(mir, tcx).ty;\n                 let category = match *dest {\n                     Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n                         if let Some(BorrowCheckContext {\n@@ -2370,7 +2372,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             match *elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+                    let base_ty = base.ty(mir, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {"}, {"sha": "8269b7b95f490ea4ac88e6e5118d3b74afe9d77c", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     tcx, mir, locals_state_at_exit),\n \n                 ProjectionElem::Deref => {\n-                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+                    let ty = proj.base.ty(mir, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and"}, {"sha": "fbe8b8485dda5b9d886ee7b1d8a3834d4c4ab11e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -191,7 +191,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     Place::Projection(box Projection { base, elem }) => (base, elem),\n                     _ => bug!(\"place has no base?\"),\n                 };\n-                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+                let base_ty = base.ty(mir, tcx).ty;\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -427,7 +427,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                         debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                         Overlap::EqualOrDisjoint\n                     } else {\n-                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n+                        let ty = pi1.base.ty(mir, tcx).ty;\n                         match ty.sty {\n                             ty::Adt(def, _) if def.is_union() => {\n                                 // Different fields of a union, we are basically stuck."}, {"sha": "866f1cf994e69669508e953f4d0424263837d7c6", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -139,7 +139,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n             // derefs, except we stop at the deref of a shared\n             // reference.\n \n-            let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            let ty = proj.base.ty(self.mir, self.tcx).ty;\n             match ty.sty {\n                 ty::RawPtr(_) |\n                 ty::Ref("}, {"sha": "7469aceee3a9ee959c7647fee82007ba20eaed77", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n         // of the block, which is stored into `destination`.\n         let tcx = this.hir.tcx();\n-        let destination_ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n+        let destination_ty = destination.ty(&this.local_decls, tcx).ty;\n         if let Some(expr) = expr {\n             let tail_result_is_ignored = destination_ty.is_unit() ||\n                 this.block_context.currently_ignores_tail_results();"}, {"sha": "b58914b017fd4601f4a677772ed2fa9d93c0ac17", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -188,11 +188,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     block,\n                     Statement {\n                         source_info,\n-                        kind: StatementKind::InlineAsm {\n-                            asm: box asm.clone(),\n+                        kind: StatementKind::InlineAsm(box InlineAsm {\n+                            asm: asm.clone(),\n                             outputs,\n                             inputs,\n-                        },\n+                        }),\n                     },\n                 );\n                 this.block_context.pop();"}, {"sha": "566f1790f8f7f488e8d63451684d31e91e9a4a90", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -374,7 +374,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = box pat_ascription_ty.user_ty(\n                     &mut self.canonical_user_type_annotations,\n-                    place.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                    place.ty(&self.local_decls, self.hir.tcx()).ty,\n                     ty_source_info.span,\n                 );\n                 self.cfg.push(\n@@ -575,7 +575,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub(super) fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        pattern_user_ty: UserTypeProjections<'tcx>,\n+        pattern_user_ty: UserTypeProjections,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -584,7 +584,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             HirId,\n             Span,\n             Ty<'tcx>,\n-            UserTypeProjections<'tcx>,\n+            UserTypeProjections,\n         ),\n     ) {\n         debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n@@ -1293,7 +1293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n \n         all_fake_borrows.into_iter().map(|matched_place| {\n-            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).to_ty(tcx);\n+            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n             let fake_borrow_ty = tcx.mk_imm_ref(tcx.types.re_erased, fake_borrow_deref_ty);\n             let fake_borrow_temp = self.local_decls.push(\n                 LocalDecl::new_temp(fake_borrow_ty, temp_span)\n@@ -1587,7 +1587,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             let user_ty = box ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n-                ascription.source.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n                 source_info.span\n             );\n             self.cfg.push(\n@@ -1701,7 +1701,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         mode: BindingMode,\n         var_id: HirId,\n         var_ty: Ty<'tcx>,\n-        user_ty: UserTypeProjections<'tcx>,\n+        user_ty: UserTypeProjections,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,"}, {"sha": "b06022196106a43d035bbfa2865042997f9d7219", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -693,7 +693,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+        let elem = ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name), variant_index);\n         let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n         let consequent_match_pairs =\n             subpatterns.iter()"}, {"sha": "d71a13dec5a2f971340dd3acf5bd6589ec9da708", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n-        let ty = place.ty(&self.local_decls, tcx).to_ty(tcx);\n+        let ty = place.ty(&self.local_decls, tcx).ty;\n         if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {\n             Operand::Move(place)\n         } else {"}, {"sha": "aae4590a387a7a7a2a33164c60f346ce24433dbc", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -49,7 +49,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                             mir: &Mir<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {\n-    let ty = place.ty(mir, tcx).to_ty(tcx);\n+    let ty = place.ty(mir, tcx).ty;\n     match ty.sty {\n         ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n@@ -141,7 +141,7 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n {\n     on_all_children_bits(tcx, mir, &ctxt.move_data, path, |child| {\n         let place = &ctxt.move_data.move_paths[path].place;\n-        let ty = place.ty(mir, tcx).to_ty(tcx);\n+        let ty = place.ty(mir, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();"}, {"sha": "5a3105ed160492b1751b7d2ecda94e1d1a01bcc5", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -288,8 +288,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n                 self.kill_borrows_on_place(sets, &Place::Base(PlaceBase::Local(local)));\n             }\n \n-            mir::StatementKind::InlineAsm { ref outputs, ref asm, .. } => {\n-                for (output, kind) in outputs.iter().zip(&asm.outputs) {\n+            mir::StatementKind::InlineAsm(ref asm) => {\n+                for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n                         self.kill_borrows_on_place(sets, output);\n                     }"}, {"sha": "b26547c4ff77e1bf427cc2531daa64497e5136cc", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -18,8 +18,7 @@ use rustc::ty::Ty;\n pub struct AbstractOperand;\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractType;\n-pub type AbstractElem<'tcx> =\n-    ProjectionElem<'tcx, AbstractOperand, AbstractType>;\n+pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType>;\n \n pub trait Lift {\n     type Abstract;\n@@ -38,7 +37,7 @@ impl<'tcx> Lift for Ty<'tcx> {\n     fn lift(&self) -> Self::Abstract { AbstractType }\n }\n impl<'tcx> Lift for PlaceElem<'tcx> {\n-    type Abstract = AbstractElem<'tcx>;\n+    type Abstract = AbstractElem;\n     fn lift(&self) -> Self::Abstract {\n         match *self {\n             ProjectionElem::Deref =>\n@@ -56,7 +55,7 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n                     from_end,\n                 },\n             ProjectionElem::Downcast(a, u) =>\n-                ProjectionElem::Downcast(a.clone(), u.clone()),\n+                ProjectionElem::Downcast(a, u.clone()),\n         }\n     }\n }"}, {"sha": "011dc54f3b315d1e1ae5e27acb3068eee2bf1f93", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -120,7 +120,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let base = self.move_path_for(&proj.base)?;\n         let mir = self.builder.mir;\n         let tcx = self.builder.tcx;\n-        let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+        let place_ty = proj.base.ty(mir, tcx).ty;\n         match place_ty.sty {\n             ty::Ref(..) | ty::RawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n@@ -272,13 +272,13 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             StatementKind::FakeRead(_, ref place) => {\n                 self.create_move_path(place);\n             }\n-            StatementKind::InlineAsm { ref outputs, ref inputs, ref asm } => {\n-                for (output, kind) in outputs.iter().zip(&asm.outputs) {\n+            StatementKind::InlineAsm(ref asm) => {\n+                for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n                     if !kind.is_indirect {\n                         self.gather_init(output, InitKind::Deep);\n                     }\n                 }\n-                for (_, input) in inputs.iter() {\n+                for (_, input) in asm.inputs.iter() {\n                     self.gather_operand(input);\n                 }\n             }\n@@ -424,7 +424,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base,\n                 elem: ProjectionElem::Field(_, _),\n-            }) if match base.ty(self.builder.mir, self.builder.tcx).to_ty(self.builder.tcx).sty {\n+            }) if match base.ty(self.builder.mir, self.builder.tcx).ty.sty {\n                     ty::TyKind::Adt(def, _) if def.is_union() => true,\n                     _ => false,\n             } => base,"}, {"sha": "5806a01c687cb18b323e72a8704bcc2ddfa771d7", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -148,7 +148,7 @@ pub struct MoveData<'tcx> {\n     /// particular path being moved.)\n     pub loc_map: LocationMap<SmallVec<[MoveOutIndex; 4]>>,\n     pub path_map: IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n-    pub rev_lookup: MovePathLookup<'tcx>,\n+    pub rev_lookup: MovePathLookup,\n     pub inits: IndexVec<InitIndex, Init>,\n     /// Each Location `l` is mapped to the Inits that are effects\n     /// of executing the code at `l`.\n@@ -258,7 +258,7 @@ impl Init {\n \n /// Tables mapping from a place to its MovePathIndex.\n #[derive(Debug)]\n-pub struct MovePathLookup<'tcx> {\n+pub struct MovePathLookup {\n     locals: IndexVec<Local, MovePathIndex>,\n \n     /// projections are made from a base-place and a projection\n@@ -267,7 +267,7 @@ pub struct MovePathLookup<'tcx> {\n     /// subsequent search so that it is solely relative to that\n     /// base-place). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>\n }\n \n mod builder;\n@@ -278,7 +278,7 @@ pub enum LookupResult {\n     Parent(Option<MovePathIndex>)\n }\n \n-impl<'tcx> MovePathLookup<'tcx> {\n+impl MovePathLookup {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available"}, {"sha": "fc12443c0923a7ccb660ff2778557cf13422c9b9", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n         annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n         inferred_ty: Ty<'tcx>,\n         span: Span,\n-    ) -> UserTypeProjection<'tcx> {\n+    ) -> UserTypeProjection {\n         UserTypeProjection {\n             base: annotations.push(CanonicalUserTypeAnnotation {\n                 span,\n@@ -1094,7 +1094,7 @@ CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n     SubstsRef<'tcx>, &'tcx Kind<'tcx>, UserType<'tcx>,\n-    UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>\n+    UserTypeProjection, PatternTypeProjection<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {"}, {"sha": "4f7b59a5a9a955ab9b8fcec79e59882c64116e21", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -558,7 +558,7 @@ where\n     pub fn place_projection(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n+        proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {"}, {"sha": "af875c2f9e8a183ea13bbb3a93797849421b3005", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -625,8 +625,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.tcx)\n-                    .to_ty(self.tcx);\n+                let ty = location.ty(self.mir, self.tcx).ty;\n                 let ty = tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),"}, {"sha": "b6436ec70eef24ff64f77a32594b07671fbf0313", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -106,7 +106,7 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n     };\n \n     let source_info = terminator.source_info;\n-    let ty = location.ty(mir, tcx).to_ty(tcx);\n+    let ty = location.ty(mir, tcx).ty;\n     let temp = patch.new_temp(ty, terminator.source_info.span);\n \n     let storage_dead_block = patch.new_block(BasicBlockData {"}, {"sha": "9b9e6594296bac191813550e1d44dc18cf7cce82", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -87,7 +87,7 @@ impl MirPass for AddRetag {\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n-            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n         };\n \n         // PART 1"}, {"sha": "93f3afe1aea6b85f6c94af606ae2489c075801bb", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 let is_borrow_of_interior_mut = context.is_borrow() && !base\n                     .ty(self.mir, self.tcx)\n-                    .to_ty(self.tcx)\n+                    .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n                 // prevent\n                 // * `&mut x.field`\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_info = self.mir.local_decls[local].source_info;\n                     }\n                 }\n-                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                let base_ty = base.ty(self.mir, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         }) = place {\n             match *elem {\n                 ProjectionElem::Field(..) => {\n-                    let ty = base.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+                    let ty = base.ty(&self.mir.local_decls, self.tcx).ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {},"}, {"sha": "e0ff71cbe52f82bb3358dfe9610cf25b4f5caa0e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -556,7 +556,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n             let place_ty: ty::Ty<'tcx> = place\n                 .ty(&self.mir.local_decls, self.tcx)\n-                .to_ty(self.tcx);\n+                .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n                     if let Place::Base(PlaceBase::Local(local)) = *place {"}, {"sha": "027ae70b06a175e1aa6c1bd98778f7a2a2efde42", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -319,8 +319,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     work_list.push(target);\n                     // If the location doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs);\n-                    let ty = ty.to_ty(tcx);\n+                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs).ty;\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -563,7 +562,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::Base(PlaceBase::Local(tuple));\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).ty.sty {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "7e925f65ee2d733b5155c46afb0a3015b2fe241b", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -82,14 +82,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n-                if projection.base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                if projection.base.ty(self.mir, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }\n         }\n \n         if let Rvalue::Len(ref place) = *rvalue {\n-            let place_ty = place.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+            let place_ty = place.ty(&self.mir.local_decls, self.tcx).ty;\n             if let TyKind::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;"}, {"sha": "dda9457cc8ccf844f48e5656baca822ac1482ad2", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -135,7 +135,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     let sig = poly_sig.no_bound_vars().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n-    let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let place_ty = place.ty(local_decls, tcx).ty;\n     let expected = [lhs_ty, rhs_ty, place_ty];\n     assert_eq!(sig.inputs_and_output[..], expected,\n         \"lang item `{}`\", tcx.def_path_str(did));"}, {"sha": "43723aaf568daadbd6a136ef845fa461d5e10cc5", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                                 place = &mut proj.base;\n                             };\n \n-                            let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n+                            let ty = place.ty(local_decls, self.tcx).ty;\n                             let span = statement.source_info.span;\n \n                             Operand::Move(mem::replace(place, promoted_place(ty, span)))"}, {"sha": "5adcbf84da5a06a2d7aeb4739caf871bb23b5141", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -168,7 +168,7 @@ trait Qualif {\n             cx,\n             proj.base.ty(cx.mir, cx.tcx)\n                 .projection_ty(cx.tcx, &proj.elem)\n-                .to_ty(cx.tcx),\n+                .ty,\n         );\n         match proj.elem {\n             ProjectionElem::Deref |\n@@ -245,7 +245,7 @@ trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let Place::Projection(ref proj) = *place {\n                     if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                        let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n                             return Self::in_place(cx, &proj.base);\n                         }\n@@ -301,7 +301,7 @@ impl Qualif for HasMutInterior {\n             // allowed in constants (and the `Checker` will error), and/or it\n             // won't be promoted, due to `&mut ...` or interior mutability.\n             Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                let ty = place.ty(cx.mir, cx.tcx).ty;\n \n                 if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n@@ -398,7 +398,7 @@ impl Qualif for IsNotConst {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::Fn {\n-                    let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                    let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         if def.is_union() {\n                             return true;\n@@ -988,7 +988,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             // `not_const` errors out in const contexts\n                             self.not_const()\n                         }\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                         match self.mode {\n                             Mode::Fn => {},\n                             _ => {\n@@ -1012,7 +1012,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     ProjectionElem::Subslice {..} |\n                     ProjectionElem::Field(..) |\n                     ProjectionElem::Index(_) => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                         if let Some(def) = base_ty.ty_adt_def() {\n                             if def.is_union() {\n                                 match self.mode {\n@@ -1069,7 +1069,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             let mut is_reborrow = false;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n                         is_reborrow = true;\n                     }\n@@ -1193,7 +1193,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 self.assign(dest, ValueSource::Call {\n                     callee: func,\n                     args,\n-                    return_ty: dest.ty(self.mir, self.tcx).to_ty(self.tcx),\n+                    return_ty: dest.ty(self.mir, self.tcx).ty,\n                 }, location);\n             }\n \n@@ -1367,7 +1367,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if let Some(span) = needs_drop {\n                     // Double-check the type being dropped, to minimize false positives.\n-                    let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let ty = place.ty(self.mir, self.tcx).ty;\n                     if ty.needs_drop(self.tcx, self.param_env) {\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")"}, {"sha": "616944dd7ef99ed87eb2361d783af84d15593554", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                                      from_end: false} = proj.elem {\n                     // no need to transformation\n                 } else {\n-                    let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let place_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n@@ -195,7 +195,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n \n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n+                            let src_ty = src_place.ty(mir, tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {"}, {"sha": "788b7fdaaf91257e9bca59e4b0e35ae4b8b6e356", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -17,7 +17,7 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false\n     }\n \n-    let ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let ty = place.ty(local_decls, tcx).ty;\n     match tcx.layout_raw(param_env.and(ty)) {\n         Ok(layout) if layout.align.abi.bytes() == 1 => {\n             // if the alignment is 1, the type can't be further\n@@ -46,7 +46,7 @@ fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = base.ty(local_decls, tcx).to_ty(tcx);\n+                let ty = base.ty(local_decls, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true"}, {"sha": "2d275c9a13792df1501304a7948160da03feaf24", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546cb21f580ae3d4e0bf42ccecfad4a34defebe7/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=546cb21f580ae3d4e0bf42ccecfad4a34defebe7", "patch": "@@ -122,7 +122,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n     fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n-        place.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+        place.ty(self.elaborator.mir(), self.tcx()).ty\n     }\n \n     fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n@@ -412,8 +412,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n                 let base_place = self.place.clone().elem(\n-                    ProjectionElem::Downcast(adt, variant_index)\n-                        );\n+                    ProjectionElem::Downcast(Some(adt.variants[variant_index].ident.name),\n+                                             variant_index));\n                 let fields = self.move_paths_for_fields(\n                     &base_place,\n                     variant_path,"}]}