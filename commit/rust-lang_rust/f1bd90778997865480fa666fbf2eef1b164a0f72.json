{"sha": "f1bd90778997865480fa666fbf2eef1b164a0f72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYmQ5MDc3ODk5Nzg2NTQ4MGZhNjY2ZmJmMmVlZjFiMTY0YTBmNzI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-11T22:53:43Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-11T22:53:43Z"}, "message": "use `adt::trans_const` when translating constant closures and tuples\n\nFixes #36401", "tree": {"sha": "b5dfbf27575726cee4b62c5dfe03f0ddaa6d77a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5dfbf27575726cee4b62c5dfe03f0ddaa6d77a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1bd90778997865480fa666fbf2eef1b164a0f72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bd90778997865480fa666fbf2eef1b164a0f72", "html_url": "https://github.com/rust-lang/rust/commit/f1bd90778997865480fa666fbf2eef1b164a0f72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1bd90778997865480fa666fbf2eef1b164a0f72/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fca1ab0e7be574022b2d229f0a6ad9bd580d1bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fca1ab0e7be574022b2d229f0a6ad9bd580d1bf", "html_url": "https://github.com/rust-lang/rust/commit/1fca1ab0e7be574022b2d229f0a6ad9bd580d1bf"}], "stats": {"total": 111, "additions": 83, "deletions": 28}, "files": [{"sha": "e9f324c0b08f00e16cb9a9f4d5bb509089732514", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f1bd90778997865480fa666fbf2eef1b164a0f72/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bd90778997865480fa666fbf2eef1b164a0f72/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f1bd90778997865480fa666fbf2eef1b164a0f72", "patch": "@@ -38,6 +38,7 @@ use value::Value;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::fmt;\n use std::ptr;\n \n use super::operand::{OperandRef, OperandValue};\n@@ -149,6 +150,12 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Debug for Const<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Const({:?}: {:?})\", Value(self.llval), self.ty)\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n enum Base {\n     /// A constant value without an unique address.\n@@ -472,7 +479,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n                      -> Result<Const<'tcx>, ConstEvalErr> {\n-        match *operand {\n+        debug!(\"const_operand({:?} @ {:?})\", operand, span);\n+        let result = match *operand {\n             mir::Operand::Consume(ref lvalue) => {\n                 Ok(self.const_lvalue(lvalue, span)?.to_const(span))\n             }\n@@ -501,29 +509,41 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                 }\n             }\n-        }\n+        };\n+        debug!(\"const_operand({:?} @ {:?}) = {:?}\", operand, span,\n+               result.as_ref().ok());\n+        result\n+    }\n+\n+    fn const_array(&self, array_ty: Ty<'tcx>, fields: &[ValueRef])\n+                   -> Const<'tcx>\n+    {\n+        let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n+            bug!(\"bad array type {:?}\", array_ty)\n+        });\n+        let llunitty = type_of::type_of(self.ccx, elem_ty);\n+        // If the array contains enums, an LLVM array won't work.\n+        let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n+            C_array(llunitty, fields)\n+        } else {\n+            C_struct(self.ccx, fields, false)\n+        };\n+        Const::new(val, array_ty)\n     }\n \n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n                     -> Result<Const<'tcx>, ConstEvalErr> {\n         let tcx = self.ccx.tcx();\n+        debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let elem = self.const_operand(elem, span)?;\n                 let size = count.value.as_u64(tcx.sess.target.uint_type);\n                 let fields = vec![elem.llval; size as usize];\n-\n-                let llunitty = type_of::type_of(self.ccx, elem.ty);\n-                // If the array contains enums, an LLVM array won't work.\n-                let val = if val_ty(elem.llval) == llunitty {\n-                    C_array(llunitty, &fields)\n-                } else {\n-                    C_struct(self.ccx, &fields, false)\n-                };\n-                Const::new(val, dest_ty)\n+                self.const_array(dest_ty, &fields)\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n@@ -547,22 +567,26 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                                         self.monomorphize(&substs));\n                 }\n \n-                let val = if let mir::AggregateKind::Adt(adt_def, index, _, _) = *kind {\n-                    let repr = adt::represent_type(self.ccx, dest_ty);\n-                    let disr = Disr::from(adt_def.variants[index].disr_val);\n-                    adt::trans_const(self.ccx, &repr, disr, &fields)\n-                } else if let ty::TyArray(elem_ty, _) = dest_ty.sty {\n-                    let llunitty = type_of::type_of(self.ccx, elem_ty);\n-                    // If the array contains enums, an LLVM array won't work.\n-                    if fields.iter().all(|&f| val_ty(f) == llunitty) {\n-                        C_array(llunitty, &fields)\n-                    } else {\n-                        C_struct(self.ccx, &fields, false)\n+                match *kind {\n+                    mir::AggregateKind::Vec => {\n+                        self.const_array(dest_ty, &fields)\n                     }\n-                } else {\n-                    C_struct(self.ccx, &fields, false)\n-                };\n-                Const::new(val, dest_ty)\n+                    mir::AggregateKind::Adt(..) |\n+                    mir::AggregateKind::Closure(..) |\n+                    mir::AggregateKind::Tuple => {\n+                        let disr = match *kind {\n+                            mir::AggregateKind::Adt(adt_def, index, _, _) => {\n+                                Disr::from(adt_def.variants[index].disr_val)\n+                            }\n+                            _ => Disr(0)\n+                        };\n+                        let repr = adt::represent_type(self.ccx, dest_ty);\n+                        Const::new(\n+                            adt::trans_const(self.ccx, &repr, disr, &fields),\n+                            dest_ty\n+                        )\n+                    }\n+                }\n             }\n \n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -786,6 +810,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             _ => span_bug!(span, \"{:?} in constant\", rvalue)\n         };\n \n+        debug!(\"const_rvalue({:?}: {:?} @ {:?}) = {:?}\", rvalue, dest_ty, span, val);\n+\n         Ok(val)\n     }\n \n@@ -935,6 +961,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> Const<'tcx>\n     {\n+        debug!(\"trans_constant({:?})\", constant);\n         let ty = bcx.monomorphize(&constant.ty);\n         let result = match constant.literal.clone() {\n             mir::Literal::Item { def_id, substs } => {\n@@ -959,11 +986,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         };\n \n-        result.unwrap_or_else(|_| {\n+        let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n             let llty = type_of::type_of(bcx.ccx(), ty);\n             Const::new(C_undef(llty), ty)\n-        })\n+        });\n+\n+        debug!(\"trans_constant({:?}) = {:?}\", constant, result);\n+        result\n     }\n }\n "}, {"sha": "7b08eba9e49887193bf7569a900170f01ecff6e0", "filename": "src/test/run-pass/issue-36401.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1bd90778997865480fa666fbf2eef1b164a0f72/src%2Ftest%2Frun-pass%2Fissue-36401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bd90778997865480fa666fbf2eef1b164a0f72/src%2Ftest%2Frun-pass%2Fissue-36401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36401.rs?ref=f1bd90778997865480fa666fbf2eef1b164a0f72", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Debug)]\n+pub enum Event {\n+    Key(u8),\n+    Resize,\n+    Unknown(u16),\n+}\n+\n+static XTERM_SINGLE_BYTES : [(u8, Event); 1] = [(1,  Event::Resize)];\n+\n+fn main() {\n+    match XTERM_SINGLE_BYTES[0] {\n+        (1, Event::Resize) => {},\n+        ref bad => panic!(\"unexpected {:?}\", bad)\n+    }\n+}"}]}