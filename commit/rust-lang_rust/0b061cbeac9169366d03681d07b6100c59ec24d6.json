{"sha": "0b061cbeac9169366d03681d07b6100c59ec24d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMDYxY2JlYWM5MTY5MzY2ZDAzNjgxZDA3YjYxMDBjNTllYzI0ZDY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-06T15:52:11Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-06T15:54:13Z"}, "message": "Move get_linker to linker.rs", "tree": {"sha": "1407d734ec785c06382b8dfa9bd945b539af7fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1407d734ec785c06382b8dfa9bd945b539af7fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b061cbeac9169366d03681d07b6100c59ec24d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b061cbeac9169366d03681d07b6100c59ec24d6", "html_url": "https://github.com/rust-lang/rust/commit/0b061cbeac9169366d03681d07b6100c59ec24d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b061cbeac9169366d03681d07b6100c59ec24d6/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56ee9864c187a2a754a44be7d6ac529dda9058fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/56ee9864c187a2a754a44be7d6ac529dda9058fc", "html_url": "https://github.com/rust-lang/rust/commit/56ee9864c187a2a754a44be7d6ac529dda9058fc"}], "stats": {"total": 189, "additions": 96, "deletions": 93}, "files": [{"sha": "5f133f7afe454dca6a8ca87f30d0f45c2b8d0a12", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 92, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0b061cbeac9169366d03681d07b6100c59ec24d6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b061cbeac9169366d03681d07b6100c59ec24d6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=0b061cbeac9169366d03681d07b6100c59ec24d6", "patch": "@@ -147,97 +147,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     });\n }\n \n-// The third parameter is for env vars, used on windows to set up the\n-// path for MSVC to find its DLLs, and gcc to find its bundled\n-// toolchain\n-fn get_linker(\n-    sess: &Session,\n-    linker: &Path,\n-    flavor: LinkerFlavor,\n-    self_contained: bool,\n-) -> Command {\n-    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n-\n-    // If our linker looks like a batch script on Windows then to execute this\n-    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n-    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n-    // `cmd /c emcc.bat ...`.\n-    //\n-    // This worked historically but is needed manually since #42436 (regression\n-    // was tagged as #42791) and some more info can be found on #44443 for\n-    // emscripten itself.\n-    let mut cmd = match linker.to_str() {\n-        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n-        _ => match flavor {\n-            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n-            LinkerFlavor::Msvc if sess.opts.cg.linker.is_none() && sess.target.linker.is_none() => {\n-                Command::new(msvc_tool.as_ref().map_or(linker, |t| t.path()))\n-            }\n-            _ => Command::new(linker),\n-        },\n-    };\n-\n-    // UWP apps have API restrictions enforced during Store submissions.\n-    // To comply with the Windows App Certification Kit,\n-    // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n-    let t = &sess.target;\n-    if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n-        && t.vendor == \"uwp\"\n-    {\n-        if let Some(ref tool) = msvc_tool {\n-            let original_path = tool.path();\n-            if let Some(ref root_lib_path) = original_path.ancestors().nth(4) {\n-                let arch = match t.arch.as_str() {\n-                    \"x86_64\" => Some(\"x64\"),\n-                    \"x86\" => Some(\"x86\"),\n-                    \"aarch64\" => Some(\"arm64\"),\n-                    \"arm\" => Some(\"arm\"),\n-                    _ => None,\n-                };\n-                if let Some(ref a) = arch {\n-                    // FIXME: Move this to `fn linker_with_args`.\n-                    let mut arg = OsString::from(\"/LIBPATH:\");\n-                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a));\n-                    cmd.arg(&arg);\n-                } else {\n-                    warn!(\"arch is not supported\");\n-                }\n-            } else {\n-                warn!(\"MSVC root path lib location not found\");\n-            }\n-        } else {\n-            warn!(\"link.exe not found\");\n-        }\n-    }\n-\n-    // The compiler's sysroot often has some bundled tools, so add it to the\n-    // PATH for the child.\n-    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n-    let mut msvc_changed_path = false;\n-    if sess.target.is_like_msvc {\n-        if let Some(ref tool) = msvc_tool {\n-            cmd.args(tool.args());\n-            for &(ref k, ref v) in tool.env() {\n-                if k == \"PATH\" {\n-                    new_path.extend(env::split_paths(v));\n-                    msvc_changed_path = true;\n-                } else {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-    }\n-\n-    if !msvc_changed_path {\n-        if let Some(path) = env::var_os(\"PATH\") {\n-            new_path.extend(env::split_paths(&path));\n-        }\n-    }\n-    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n-\n-    cmd\n-}\n-\n pub fn each_linked_rlib(\n     info: &CrateInfo,\n     f: &mut dyn FnMut(CrateNum, &Path),\n@@ -1804,7 +1713,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n ) -> Command {\n     let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n-    let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n+    let base_cmd = super::linker::get_linker(sess, path, flavor, crt_objects_fallback);\n     // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n     // to the linker args construction.\n     assert!(base_cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");"}, {"sha": "8d76f9814e00db990eb9b66757d0a450c0de550d", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0b061cbeac9169366d03681d07b6100c59ec24d6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b061cbeac9169366d03681d07b6100c59ec24d6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=0b061cbeac9169366d03681d07b6100c59ec24d6", "patch": "@@ -7,19 +7,22 @@ use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n-use std::mem;\n use std::path::{Path, PathBuf};\n+use std::{env, mem, str};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n+use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n \n+use cc::windows_registry;\n+\n /// Disables non-English messages from localized linkers.\n /// Such messages may cause issues with text encoding on Windows (#35785)\n /// and prevent inspection of linker output in case of errors, which we occasionally do.\n@@ -90,6 +93,97 @@ impl LinkerInfo {\n     }\n }\n \n+// The third parameter is for env vars, used on windows to set up the\n+// path for MSVC to find its DLLs, and gcc to find its bundled\n+// toolchain\n+pub fn get_linker(\n+    sess: &Session,\n+    linker: &Path,\n+    flavor: LinkerFlavor,\n+    self_contained: bool,\n+) -> Command {\n+    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n+\n+    // If our linker looks like a batch script on Windows then to execute this\n+    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n+    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n+    // `cmd /c emcc.bat ...`.\n+    //\n+    // This worked historically but is needed manually since #42436 (regression\n+    // was tagged as #42791) and some more info can be found on #44443 for\n+    // emscripten itself.\n+    let mut cmd = match linker.to_str() {\n+        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n+        _ => match flavor {\n+            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n+            LinkerFlavor::Msvc if sess.opts.cg.linker.is_none() && sess.target.linker.is_none() => {\n+                Command::new(msvc_tool.as_ref().map_or(linker, |t| t.path()))\n+            }\n+            _ => Command::new(linker),\n+        },\n+    };\n+\n+    // UWP apps have API restrictions enforced during Store submissions.\n+    // To comply with the Windows App Certification Kit,\n+    // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n+    let t = &sess.target;\n+    if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n+        && t.vendor == \"uwp\"\n+    {\n+        if let Some(ref tool) = msvc_tool {\n+            let original_path = tool.path();\n+            if let Some(ref root_lib_path) = original_path.ancestors().nth(4) {\n+                let arch = match t.arch.as_str() {\n+                    \"x86_64\" => Some(\"x64\"),\n+                    \"x86\" => Some(\"x86\"),\n+                    \"aarch64\" => Some(\"arm64\"),\n+                    \"arm\" => Some(\"arm\"),\n+                    _ => None,\n+                };\n+                if let Some(ref a) = arch {\n+                    // FIXME: Move this to `fn linker_with_args`.\n+                    let mut arg = OsString::from(\"/LIBPATH:\");\n+                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a));\n+                    cmd.arg(&arg);\n+                } else {\n+                    warn!(\"arch is not supported\");\n+                }\n+            } else {\n+                warn!(\"MSVC root path lib location not found\");\n+            }\n+        } else {\n+            warn!(\"link.exe not found\");\n+        }\n+    }\n+\n+    // The compiler's sysroot often has some bundled tools, so add it to the\n+    // PATH for the child.\n+    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n+    let mut msvc_changed_path = false;\n+    if sess.target.is_like_msvc {\n+        if let Some(ref tool) = msvc_tool {\n+            cmd.args(tool.args());\n+            for &(ref k, ref v) in tool.env() {\n+                if k == \"PATH\" {\n+                    new_path.extend(env::split_paths(v));\n+                    msvc_changed_path = true;\n+                } else {\n+                    cmd.env(k, v);\n+                }\n+            }\n+        }\n+    }\n+\n+    if !msvc_changed_path {\n+        if let Some(path) = env::var_os(\"PATH\") {\n+            new_path.extend(env::split_paths(&path));\n+        }\n+    }\n+    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n+\n+    cmd\n+}\n+\n /// Linker abstraction used by `back::link` to build up the command to invoke a\n /// linker.\n ///"}]}