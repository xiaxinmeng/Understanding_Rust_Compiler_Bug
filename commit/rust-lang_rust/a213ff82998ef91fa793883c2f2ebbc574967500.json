{"sha": "a213ff82998ef91fa793883c2f2ebbc574967500", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMTNmZjgyOTk4ZWY5MWZhNzkzODgzYzJmMmViYmM1NzQ5Njc1MDA=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-12-02T08:44:48Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-12-06T13:00:45Z"}, "message": "Move numeric `From` and `TryFrom` impls to `libcore/convert/num.rs`\n\nThis makes `libcore/num/mod.rs` slightly smaller. It\u2019s still 4911 lines and not easy to navigate. This doesn\u2019t change any public API.", "tree": {"sha": "cdf42935798cbb018b49a112eb73ef20e67a2bca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdf42935798cbb018b49a112eb73ef20e67a2bca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a213ff82998ef91fa793883c2f2ebbc574967500", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a213ff82998ef91fa793883c2f2ebbc574967500", "html_url": "https://github.com/rust-lang/rust/commit/a213ff82998ef91fa793883c2f2ebbc574967500", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a213ff82998ef91fa793883c2f2ebbc574967500/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba479f75c7513f91f727741882a99442f393c12", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba479f75c7513f91f727741882a99442f393c12", "html_url": "https://github.com/rust-lang/rust/commit/cba479f75c7513f91f727741882a99442f393c12"}], "stats": {"total": 662, "additions": 332, "deletions": 330}, "files": [{"sha": "0877dacb38dd2ee80662e021f02219274f9a7997", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/a213ff82998ef91fa793883c2f2ebbc574967500/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213ff82998ef91fa793883c2f2ebbc574967500/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=a213ff82998ef91fa793883c2f2ebbc574967500", "patch": "@@ -1,3 +1,6 @@\n+use super::{From, TryFrom};\n+use crate::num::TryFromIntError;\n+\n mod private {\n     /// This trait being unreachable from outside the crate\n     /// prevents other implementations of the `FloatToInt` trait,\n@@ -36,3 +39,331 @@ macro_rules! impl_float_to_int {\n \n impl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+\n+// Conversion traits for primitive integer and float types\n+// Conversions T -> T are covered by a blanket impl and therefore excluded\n+// Some conversions from and to usize/isize are not implemented due to portability concerns\n+macro_rules! impl_from {\n+    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n+        #[$attr]\n+        #[doc = $doc]\n+        impl From<$Small> for $Large {\n+            #[inline]\n+            fn from(small: $Small) -> $Large {\n+                small as $Large\n+            }\n+        }\n+    };\n+    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n+        impl_from!($Small,\n+                   $Large,\n+                   #[$attr],\n+                   concat!(\"Converts `\",\n+                           stringify!($Small),\n+                           \"` to `\",\n+                           stringify!($Large),\n+                           \"` losslessly.\"));\n+    }\n+}\n+\n+macro_rules! impl_from_bool {\n+    ($target: ty, #[$attr:meta]) => {\n+        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n+            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n+values.\n+\n+# Examples\n+\n+```\n+assert_eq!(\", stringify!($target), \"::from(true), 1);\n+assert_eq!(\", stringify!($target), \"::from(false), 0);\n+```\"));\n+    };\n+}\n+\n+// Bool -> Any\n+impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+\n+// Unsigned -> Unsigned\n+impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Signed -> Signed\n+impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Unsigned -> Signed\n+impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n+\n+// Note: integers can only be represented with full precision in a float if\n+// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n+// Lossy float conversions are not implemented at this time.\n+\n+// Signed -> Float\n+impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Unsigned -> Float\n+impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Float -> Float\n+impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// only negative bounds\n+macro_rules! try_from_lower_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u >= 0 {\n+                    Ok(u as $target)\n+                } else {\n+                    Err(TryFromIntError(()))\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u > (<$target>::max_value() as $source) {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// all other cases\n+macro_rules! try_from_both_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target>::min_value() as $source;\n+                let max = <$target>::max_value() as $source;\n+                if u < min || u > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+macro_rules! rev {\n+    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n+        $mac!($target, $source);\n+    )*}\n+}\n+\n+// intra-sign conversions\n+try_from_upper_bounded!(u16, u8);\n+try_from_upper_bounded!(u32, u16, u8);\n+try_from_upper_bounded!(u64, u32, u16, u8);\n+try_from_upper_bounded!(u128, u64, u32, u16, u8);\n+\n+try_from_both_bounded!(i16, i8);\n+try_from_both_bounded!(i32, i16, i8);\n+try_from_both_bounded!(i64, i32, i16, i8);\n+try_from_both_bounded!(i128, i64, i32, i16, i8);\n+\n+// unsigned-to-signed\n+try_from_upper_bounded!(u8, i8);\n+try_from_upper_bounded!(u16, i8, i16);\n+try_from_upper_bounded!(u32, i8, i16, i32);\n+try_from_upper_bounded!(u64, i8, i16, i32, i64);\n+try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n+\n+// signed-to-unsigned\n+try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n+try_from_lower_bounded!(i16, u16, u32, u64, u128);\n+try_from_lower_bounded!(i32, u32, u64, u128);\n+try_from_lower_bounded!(i64, u64, u128);\n+try_from_lower_bounded!(i128, u128);\n+try_from_both_bounded!(i16, u8);\n+try_from_both_bounded!(i32, u16, u8);\n+try_from_both_bounded!(i64, u32, u16, u8);\n+try_from_both_bounded!(i128, u64, u32, u16, u8);\n+\n+// usize/isize\n+try_from_upper_bounded!(usize, isize);\n+try_from_lower_bounded!(isize, usize);\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8);\n+    try_from_unbounded!(usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16);\n+    try_from_unbounded!(usize, i32, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8);\n+    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8);\n+    try_from_unbounded!(isize, i16, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16);\n+    rev!(try_from_both_bounded, usize, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n+    rev!(try_from_both_bounded, isize, i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16);\n+    try_from_unbounded!(usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32);\n+    try_from_unbounded!(usize, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16);\n+    try_from_lower_bounded!(isize, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16);\n+    try_from_unbounded!(isize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32);\n+    rev!(try_from_upper_bounded, usize, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n+    rev!(try_from_both_bounded, usize, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u16);\n+    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i32);\n+    rev!(try_from_both_bounded, isize, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16, u32);\n+    try_from_unbounded!(usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n+    try_from_unbounded!(usize, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16, u32);\n+    try_from_lower_bounded!(isize, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16, i32);\n+    try_from_unbounded!(isize, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32, u64);\n+    rev!(try_from_upper_bounded, usize, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, usize, i128);\n+\n+    rev!(try_from_unbounded, isize, u16, u32);\n+    rev!(try_from_upper_bounded, isize, u64, u128);\n+    rev!(try_from_unbounded, isize, i32, i64);\n+    rev!(try_from_both_bounded, isize, i128);\n+}"}, {"sha": "585f144cf8a9f3b76ce64f2851c47a03409acc48", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 330, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/a213ff82998ef91fa793883c2f2ebbc574967500/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213ff82998ef91fa793883c2f2ebbc574967500/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a213ff82998ef91fa793883c2f2ebbc574967500", "patch": "@@ -4,7 +4,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::TryFrom;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n@@ -4701,7 +4700,7 @@ from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n /// The error type returned when a checked integral type conversion fails.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromIntError(());\n+pub struct TryFromIntError(pub(crate) ());\n \n impl TryFromIntError {\n     #[unstable(feature = \"int_error_internals\",\n@@ -4728,206 +4727,6 @@ impl From<!> for TryFromIntError {\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n-// only negative bounds\n-macro_rules! try_from_lower_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u >= 0 {\n-                    Ok(u as $target)\n-                } else {\n-                    Err(TryFromIntError(()))\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// unsigned to signed (only positive bound)\n-macro_rules! try_from_upper_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u > (<$target>::max_value() as $source) {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// all other cases\n-macro_rules! try_from_both_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                let min = <$target>::min_value() as $source;\n-                let max = <$target>::max_value() as $source;\n-                if u < min || u > max {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-macro_rules! rev {\n-    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n-        $mac!($target, $source);\n-    )*}\n-}\n-\n-// intra-sign conversions\n-try_from_upper_bounded!(u16, u8);\n-try_from_upper_bounded!(u32, u16, u8);\n-try_from_upper_bounded!(u64, u32, u16, u8);\n-try_from_upper_bounded!(u128, u64, u32, u16, u8);\n-\n-try_from_both_bounded!(i16, i8);\n-try_from_both_bounded!(i32, i16, i8);\n-try_from_both_bounded!(i64, i32, i16, i8);\n-try_from_both_bounded!(i128, i64, i32, i16, i8);\n-\n-// unsigned-to-signed\n-try_from_upper_bounded!(u8, i8);\n-try_from_upper_bounded!(u16, i8, i16);\n-try_from_upper_bounded!(u32, i8, i16, i32);\n-try_from_upper_bounded!(u64, i8, i16, i32, i64);\n-try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n-\n-// signed-to-unsigned\n-try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n-try_from_lower_bounded!(i16, u16, u32, u64, u128);\n-try_from_lower_bounded!(i32, u32, u64, u128);\n-try_from_lower_bounded!(i64, u64, u128);\n-try_from_lower_bounded!(i128, u128);\n-try_from_both_bounded!(i16, u8);\n-try_from_both_bounded!(i32, u16, u8);\n-try_from_both_bounded!(i64, u32, u16, u8);\n-try_from_both_bounded!(i128, u64, u32, u16, u8);\n-\n-// usize/isize\n-try_from_upper_bounded!(usize, isize);\n-try_from_lower_bounded!(isize, usize);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8);\n-    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16);\n-    rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16);\n-    try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n-    rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16, u32);\n-    try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n-    rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n-}\n-\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -5110,131 +4909,3 @@ impl fmt::Display for ParseIntError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::num::dec2flt::ParseFloatError;\n-\n-// Conversion traits for primitive integer and float types\n-// Conversions T -> T are covered by a blanket impl and therefore excluded\n-// Some conversions from and to usize/isize are not implemented due to portability concerns\n-macro_rules! impl_from {\n-    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n-        #[$attr]\n-        #[doc = $doc]\n-        impl From<$Small> for $Large {\n-            #[inline]\n-            fn from(small: $Small) -> $Large {\n-                small as $Large\n-            }\n-        }\n-    };\n-    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n-        impl_from!($Small,\n-                   $Large,\n-                   #[$attr],\n-                   concat!(\"Converts `\",\n-                           stringify!($Small),\n-                           \"` to `\",\n-                           stringify!($Large),\n-                           \"` losslessly.\"));\n-    }\n-}\n-\n-macro_rules! impl_from_bool {\n-    ($target: ty, #[$attr:meta]) => {\n-        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n-            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n-values.\n-\n-# Examples\n-\n-```\n-assert_eq!(\", stringify!($target), \"::from(true), 1);\n-assert_eq!(\", stringify!($target), \"::from(false), 0);\n-```\"));\n-    };\n-}\n-\n-// Bool -> Any\n-impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-\n-// Unsigned -> Unsigned\n-impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Signed -> Signed\n-impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Unsigned -> Signed\n-impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n-// which imply that pointer-sized integers must be at least 16 bits:\n-// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n-impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-\n-// RISC-V defines the possibility of a 128-bit address space (RV128).\n-\n-// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n-// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n-// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n-\n-\n-// Note: integers can only be represented with full precision in a float if\n-// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n-// Lossy float conversions are not implemented at this time.\n-\n-// Signed -> Float\n-impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Unsigned -> Float\n-impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Float -> Float\n-impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }"}]}