{"sha": "1599ac9cf26578c881d2235887d694eab4784adb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OTlhYzljZjI2NTc4Yzg4MWQyMjM1ODg3ZDY5NGVhYjQ3ODRhZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T22:16:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T22:16:48Z"}, "message": "auto merge of #13095 : alexcrichton/rust/serialize-tuple, r=huonw\n\nThis commit moves from {read,emit}_seq for tuples to {read,emit}_tuple, as well\r\nas providing a generalized macro for generating these implementations from one\r\ninvocation.\r\n\r\nCloses #13086", "tree": {"sha": "d6aad6d6e00667f5999c9f8c19c3aee69c019e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6aad6d6e00667f5999c9f8c19c3aee69c019e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1599ac9cf26578c881d2235887d694eab4784adb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1599ac9cf26578c881d2235887d694eab4784adb", "html_url": "https://github.com/rust-lang/rust/commit/1599ac9cf26578c881d2235887d694eab4784adb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1599ac9cf26578c881d2235887d694eab4784adb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "841f31ecf942531b54c8ee991924aa969666ee72", "url": "https://api.github.com/repos/rust-lang/rust/commits/841f31ecf942531b54c8ee991924aa969666ee72", "html_url": "https://github.com/rust-lang/rust/commit/841f31ecf942531b54c8ee991924aa969666ee72"}, {"sha": "e46e9332d9574790ccf41ae56ffa1010c4267ba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e46e9332d9574790ccf41ae56ffa1010c4267ba1", "html_url": "https://github.com/rust-lang/rust/commit/e46e9332d9574790ccf41ae56ffa1010c4267ba1"}], "stats": {"total": 170, "additions": 30, "deletions": 140}, "files": [{"sha": "a65443653cc4871d0da70ee9e89db910c8d79135", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 30, "deletions": 140, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/1599ac9cf26578c881d2235887d694eab4784adb/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1599ac9cf26578c881d2235887d694eab4784adb/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=1599ac9cf26578c881d2235887d694eab4784adb", "patch": "@@ -477,153 +477,43 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     }\n }\n \n-impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                s.emit_seq(2, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n-    fn decode(d: &mut D) -> (T0, T1) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 2);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>\n-> Encodable<S> for (T0, T1, T2) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                s.emit_seq(3, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>\n-> Decodable<D> for (T0, T1, T2) {\n-    fn decode(d: &mut D) -> (T0, T1, T2) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 3);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                s.emit_seq(4, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                    s.emit_seq_elt(3, |s| t3.encode(s));\n+macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+\n+macro_rules! tuple (\n+    () => ();\n+    ( $($name:ident,)+ ) => (\n+        impl<D:Decoder,$($name:Decodable<D>),*> Decodable<D> for ($($name,)*) {\n+            #[allow(uppercase_variables)]\n+            fn decode(d: &mut D) -> ($($name,)*) {\n+                d.read_tuple(|d, amt| {\n+                    let mut i = 0;\n+                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> $name {\n+                        Decodable::decode(d)\n+                    }),)*);\n+                    assert!(amt == i,\n+                            \"expected tuple of length `{}`, found tuple \\\n+                             of length `{}`\", i, amt);\n+                    return ret;\n                 })\n             }\n         }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3) {\n-    fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 4);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d)),\n-                d.read_seq_elt(3, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>,\n-    T4: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3, T4) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                s.emit_seq(5, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                    s.emit_seq_elt(3, |s| t3.encode(s));\n-                    s.emit_seq_elt(4, |s| t4.encode(s));\n+        impl<S:Encoder,$($name:Encodable<S>),*> Encodable<S> for ($($name,)*) {\n+            #[allow(uppercase_variables)]\n+            fn encode(&self, s: &mut S) {\n+                let ($(ref $name,)*) = *self;\n+                let mut n = 0;\n+                $(let $name = $name; n += 1;)*\n+                s.emit_tuple(n, |s| {\n+                    let mut i = 0;\n+                    $(s.emit_seq_elt({ i+=1; i-1 }, |s| $name.encode(s));)*\n                 })\n             }\n         }\n-    }\n-}\n+        peel!($($name,)*)\n+    )\n+)\n \n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>,\n-    T4: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3, T4) {\n-    fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 5);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d)),\n-                d.read_seq_elt(3, |d| Decodable::decode(d)),\n-                d.read_seq_elt(4, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n+tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n impl<E: Encoder> Encodable<E> for path::posix::Path {\n     fn encode(&self, e: &mut E) {"}]}