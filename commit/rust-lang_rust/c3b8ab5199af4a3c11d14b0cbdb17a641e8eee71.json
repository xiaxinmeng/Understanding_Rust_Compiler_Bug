{"sha": "c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYjhhYjUxOTlhZjRhM2MxMWQxNGIwY2JkYjE3YTY0MWU4ZWVlNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-06T13:41:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-06T13:41:28Z"}, "message": "Auto merge of #60337 - fabric-and-ink:hiridification, r=Zoxc\n\nA bit of HirIdification\n\nA small contribution to #50928.", "tree": {"sha": "05d98325875031d536d5511b966263bdc6b67e95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d98325875031d536d5511b966263bdc6b67e95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "html_url": "https://github.com/rust-lang/rust/commit/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d98a165e39a3634eeac2b1f35c81560f5a7e8ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/d98a165e39a3634eeac2b1f35c81560f5a7e8ded", "html_url": "https://github.com/rust-lang/rust/commit/d98a165e39a3634eeac2b1f35c81560f5a7e8ded"}, {"sha": "164988c1297c4c28a8f38561cbf1481c25a1c5b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/164988c1297c4c28a8f38561cbf1481c25a1c5b8", "html_url": "https://github.com/rust-lang/rust/commit/164988c1297c4c28a8f38561cbf1481c25a1c5b8"}], "stats": {"total": 99, "additions": 39, "deletions": 60}, "files": [{"sha": "a59170e96669c3d1e7ec790576c4b246c2934e8e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 33, "deletions": 57, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "patch": "@@ -174,15 +174,6 @@ pub struct Map<'hir> {\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n-    /// `NodeId`s are sequential integers from 0, so we can be\n-    /// super-compact by storing them in a vector. Not everything with\n-    /// a `NodeId` is in the map, but empirically the occupancy is about\n-    /// 75-80%, so there's not too much overhead (certainly less than\n-    /// a hashmap, since they (at the time of writing) have a maximum\n-    /// of 75% occupancy).\n-    ///\n-    /// Also, indexing is pretty quick when you've got a vector and\n-    /// plain old integers.\n     map: FxHashMap<HirId, Entry<'hir>>,\n \n     definitions: &'hir Definitions,\n@@ -199,13 +190,7 @@ impl<'hir> Map<'hir> {\n     /// otherwise have had access to those contents, and hence needs a\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n-    pub fn read(&self, id: NodeId) {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.read_by_hir_id(hir_id);\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn read_by_hir_id(&self, hir_id: HirId) {\n+    pub fn read(&self, hir_id: HirId) {\n         if let Some(entry) = self.map.get(&hir_id) {\n             self.dep_graph.read_index(entry.dep_node);\n         } else {\n@@ -223,17 +208,12 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_key(def_id.index)\n     }\n \n-    pub fn def_path_from_id(&self, id: NodeId) -> Option<DefPath> {\n-        self.opt_local_def_id(id).map(|def_id| {\n+    pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n+        self.opt_local_def_id_from_hir_id(id).map(|def_id| {\n             self.def_path(def_id)\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn def_path_from_hir_id(&self, id: HirId) -> DefPath {\n-        self.def_path(self.local_def_id_from_hir_id(id))\n-    }\n-\n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n         assert!(def_id.is_local());\n         self.definitions.def_path(def_id.index)\n@@ -411,23 +391,23 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n-        self.read_by_hir_id(id.hir_id);\n+        self.read(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n-        self.read_by_hir_id(id.hir_id);\n+        self.read(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.impl_item(id)\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body {\n-        self.read_by_hir_id(id.hir_id);\n+        self.read(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -560,7 +540,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n     {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n-        self.read_by_hir_id(hir_id);\n+        self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item {\n                 span,\n@@ -575,13 +555,15 @@ impl<'hir> Map<'hir> {\n     pub fn visit_item_likes_in_module<V>(&self, module: DefId, visitor: &mut V)\n         where V: ItemLikeVisitor<'hir>\n     {\n-        let node_id = self.as_local_node_id(module).unwrap();\n+        let hir_id = self.as_local_hir_id(module).unwrap();\n \n         // Read the module so we'll be re-executed if new items\n         // appear immediately under in the module. If some new item appears\n         // in some nested item in the module, we'll be re-executed due to reads\n         // in the expect_* calls the loops below\n-        self.read(node_id);\n+        self.read(hir_id);\n+\n+        let node_id = self.hir_to_node_id[&hir_id];\n \n         let module = &self.forest.krate.modules[&node_id];\n \n@@ -659,7 +641,7 @@ impl<'hir> Map<'hir> {\n             }\n         });\n         if result.is_some() {\n-            self.read_by_hir_id(hir_id);\n+            self.read(hir_id);\n         }\n         result\n     }\n@@ -893,7 +875,7 @@ impl<'hir> Map<'hir> {\n             if let Entry {\n                 node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n             {\n-                self.read_by_hir_id(hir_id); // reveals some of the content of a node\n+                self.read(hir_id); // reveals some of the content of a node\n                 return nm.abi;\n             }\n         }\n@@ -1001,7 +983,7 @@ impl<'hir> Map<'hir> {\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n-        self.read_by_hir_id(id); // reveals attributes on the node\n+        self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n@@ -1046,7 +1028,7 @@ impl<'hir> Map<'hir> {\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n-        self.read_by_hir_id(hir_id); // reveals span from node\n+        self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n@@ -1088,7 +1070,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn node_to_string(&self, id: NodeId) -> String {\n-        node_id_to_string(self, id, true)\n+        hir_id_to_string(self, self.node_to_hir_id(id), true)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -1097,7 +1079,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n-        node_id_to_string(self, id, false)\n+        hir_id_to_string(self, self.node_to_hir_id(id), false)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -1316,18 +1298,18 @@ impl<'a> print::State<'a> {\n     }\n }\n \n-fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n-    let id_str = format!(\" (id={})\", id);\n+fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n+    let id_str = format!(\" (hir_id={})\", id);\n     let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     let path_str = || {\n         // This functionality is used for debugging, try to use TyCtxt to get\n         // the user-friendly path, otherwise fall back to stringifying DefPath.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n-                let def_id = map.local_def_id(id);\n+                let def_id = map.local_def_id_from_hir_id(id);\n                 tcx.def_path_str(def_id)\n-            } else if let Some(path) = map.def_path_from_id(id) {\n+            } else if let Some(path) = map.def_path_from_hir_id(id) {\n                 path.data.into_iter().map(|elem| {\n                     elem.data.to_string()\n                 }).collect::<Vec<_>>().join(\"::\")\n@@ -1337,7 +1319,7 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         })\n     };\n \n-    match map.find(id) {\n+    match map.find_by_hir_id(id) {\n         Some(Node::Item(item)) => {\n             let item_str = match item.node {\n                 ItemKind::ExternCrate(..) => \"extern crate\",\n@@ -1398,40 +1380,40 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n                     path_str(), id_str)\n         }\n         Some(Node::AnonConst(_)) => {\n-            format!(\"const {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"const {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Expr(_)) => {\n-            format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"expr {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Stmt(_)) => {\n-            format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"stmt {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::PathSegment(_)) => {\n-            format!(\"path segment {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"path segment {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Ty(_)) => {\n-            format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"type {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::TraitRef(_)) => {\n-            format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"trait_ref {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Binding(_)) => {\n-            format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"local {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Pat(_)) => {\n-            format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Block(_)) => {\n-            format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"block {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Local(_)) => {\n-            format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"local {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Ctor(..)) => {\n             format!(\"ctor {}{}\", path_str(), id_str)\n         }\n         Some(Node::Lifetime(_)) => {\n-            format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n+            format!(\"lifetime {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::GenericParam(ref param)) => {\n             format!(\"generic_param {:?}{}\", param, id_str)\n@@ -1447,12 +1429,6 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n     }\n }\n \n-// FIXME(@ljedrz): replace the NodeId variant\n-fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n-    let node_id = map.hir_to_node_id(id);\n-    node_id_to_string(map, node_id, include_id)\n-}\n-\n pub fn def_kind(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefKind> {\n     if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n         tcx.hir().def_kind(node_id)"}, {"sha": "4fdcdafcab86c7b9059a158e7fe5995bca1c1f4f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "patch": "@@ -255,7 +255,10 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n \n     /// Computes an user-readable representation of a path, if possible.\n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n-        self.hir_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n+        self.hir_map().and_then(|map| {\n+            let hir_id = map.node_to_hir_id(id);\n+            map.def_path_from_hir_id(hir_id)\n+        }).map(|path| {\n             path.data\n                 .into_iter()\n                 .map(|elem| elem.data.to_string())"}, {"sha": "b77feeee06f577fa3ea3fdde1ff9fd5d4ca543b2", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=c3b8ab5199af4a3c11d14b0cbdb17a641e8eee71", "patch": "@@ -185,7 +185,7 @@ macro_rules! read_hir {\n     ($t:ty) => {\n         impl<'tcx> DepGraphRead for &'tcx $t {\n             fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-                tcx.hir().read_by_hir_id(self.hir_id);\n+                tcx.hir().read(self.hir_id);\n             }\n         }\n     }\n@@ -219,6 +219,6 @@ pub struct FromId<T>(pub hir::HirId, pub T);\n \n impl<T> DepGraphRead for FromId<T> {\n     fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        tcx.hir().read_by_hir_id(self.0);\n+        tcx.hir().read(self.0);\n     }\n }"}]}