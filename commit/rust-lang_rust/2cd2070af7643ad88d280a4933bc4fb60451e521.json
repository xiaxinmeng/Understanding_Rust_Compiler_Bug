{"sha": "2cd2070af7643ad88d280a4933bc4fb60451e521", "node_id": "C_kwDOAAsO6NoAKDJjZDIwNzBhZjc2NDNhZDg4ZDI4MGE0OTMzYmM0ZmI2MDQ1MWU1MjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-12T05:16:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-12T05:16:50Z"}, "message": "Auto merge of #105160 - nnethercote:rm-Lit-token_lit, r=petrochenkov\n\nRemove `token::Lit` from `ast::MetaItemLit`.\n\nCurrently `ast::MetaItemLit` represents the literal kind twice. This PR removes that redundancy. Best reviewed one commit at a time.\n\nr? `@petrochenkov`", "tree": {"sha": "bae3a424c82e36ea4cd91f596edee0208213f167", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae3a424c82e36ea4cd91f596edee0208213f167"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cd2070af7643ad88d280a4933bc4fb60451e521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd2070af7643ad88d280a4933bc4fb60451e521", "html_url": "https://github.com/rust-lang/rust/commit/2cd2070af7643ad88d280a4933bc4fb60451e521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cd2070af7643ad88d280a4933bc4fb60451e521/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b397bc0727ad27340466166455c6edd327a589c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b397bc0727ad27340466166455c6edd327a589c4", "html_url": "https://github.com/rust-lang/rust/commit/b397bc0727ad27340466166455c6edd327a589c4"}, {"sha": "7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "html_url": "https://github.com/rust-lang/rust/commit/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f"}], "stats": {"total": 415, "additions": 244, "deletions": 171}, "files": [{"sha": "2e86970bcfdc7d1ae84ff14adb70cd2bd9a26311", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1734,8 +1734,10 @@ pub enum StrStyle {\n /// A literal in a meta item.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MetaItemLit {\n-    /// The original literal token as written in source code.\n-    pub token_lit: token::Lit,\n+    /// The original literal as written in the source code.\n+    pub symbol: Symbol,\n+    /// The original suffix as written in the source code.\n+    pub suffix: Option<Symbol>,\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n     pub kind: LitKind,\n@@ -1745,13 +1747,14 @@ pub struct MetaItemLit {\n /// Similar to `MetaItemLit`, but restricted to string literals.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n-    /// The original literal token as written in source code.\n-    pub style: StrStyle,\n+    /// The original literal as written in source code.\n     pub symbol: Symbol,\n+    /// The original suffix as written in source code.\n     pub suffix: Option<Symbol>,\n-    pub span: Span,\n-    /// The unescaped \"semantic\" representation of the literal lowered from the original token.\n+    /// The semantic (unescaped) representation of the literal.\n     pub symbol_unescaped: Symbol,\n+    pub style: StrStyle,\n+    pub span: Span,\n }\n \n impl StrLit {\n@@ -1797,8 +1800,9 @@ pub enum LitKind {\n     /// A string literal (`\"foo\"`). The symbol is unescaped, and so may differ\n     /// from the original token's symbol.\n     Str(Symbol, StrStyle),\n-    /// A byte string (`b\"foo\"`).\n-    ByteStr(Lrc<[u8]>),\n+    /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n+    /// non-utf8, and symbols only allow utf8 strings.\n+    ByteStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n@@ -1823,7 +1827,7 @@ impl LitKind {\n \n     /// Returns `true` if this literal is byte literal string.\n     pub fn is_bytestr(&self) -> bool {\n-        matches!(self, LitKind::ByteStr(_))\n+        matches!(self, LitKind::ByteStr(..))\n     }\n \n     /// Returns `true` if this is a numeric literal.\n@@ -3100,7 +3104,7 @@ mod size_asserts {\n     static_assert_size!(ItemKind, 112);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n-    static_assert_size!(MetaItemLit, 48);\n+    static_assert_size!(MetaItemLit, 40);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 88);\n     static_assert_size!(Path, 24);"}, {"sha": "d99f6ed2c1cd3d842964559774669b83e86dc75b", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1,15 +1,15 @@\n //! Functions dealing with attributes and meta items.\n \n-use crate::ast;\n use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n use crate::ast::{DelimArgs, Expr, ExprKind, LitKind, MetaItemLit};\n use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem, NormalAttr};\n-use crate::ast::{Path, PathSegment, StrStyle, DUMMY_NODE_ID};\n+use crate::ast::{Path, PathSegment, DUMMY_NODE_ID};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n+use crate::util::literal::escape_string_symbol;\n use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -321,18 +321,6 @@ impl Attribute {\n     }\n }\n \n-/* Constructors */\n-\n-pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n-    mk_name_value_item(ident, LitKind::Str(str, ast::StrStyle::Cooked), str_span)\n-}\n-\n-pub fn mk_name_value_item(ident: Ident, kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = MetaItemLit { token_lit: kind.to_token_lit(), kind, span: lit_span };\n-    let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), kind: MetaItemKind::NameValue(lit), span }\n-}\n-\n pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n \n #[cfg(debug_assertions)]\n@@ -408,7 +396,7 @@ pub fn mk_attr_name_value_str(\n     val: Symbol,\n     span: Span,\n ) -> Attribute {\n-    let lit = LitKind::Str(val, StrStyle::Cooked).to_token_lit();\n+    let lit = token::Lit::new(token::Str, escape_string_symbol(val), None);\n     let expr = P(Expr {\n         id: DUMMY_NODE_ID,\n         kind: ExprKind::Lit(lit),"}, {"sha": "0daeecb53a8b9d88a1432fa05440360de7096cad", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1,11 +1,31 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, LitKind, MetaItemLit};\n+use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-use std::ascii;\n+use std::{ascii, fmt, str};\n+\n+// Escapes a string, represented as a symbol. Reuses the original symbol,\n+// avoiding interning, if no changes are required.\n+pub fn escape_string_symbol(symbol: Symbol) -> Symbol {\n+    let s = symbol.as_str();\n+    let escaped = s.escape_default().to_string();\n+    if s == escaped { symbol } else { Symbol::intern(&escaped) }\n+}\n+\n+// Escapes a char.\n+pub fn escape_char_symbol(ch: char) -> Symbol {\n+    let s: String = ch.escape_default().map(Into::<char>::into).collect();\n+    Symbol::intern(&s)\n+}\n+\n+// Escapes a byte string.\n+pub fn escape_byte_str_symbol(bytes: &[u8]) -> Symbol {\n+    let s = bytes.escape_ascii().to_string();\n+    Symbol::intern(&s)\n+}\n \n #[derive(Debug)]\n pub enum LitError {\n@@ -115,9 +135,9 @@ impl LitKind {\n                     }\n                 });\n                 error?;\n-                LitKind::ByteStr(buf.into())\n+                LitKind::ByteStr(buf.into(), StrStyle::Cooked)\n             }\n-            token::ByteStrRaw(_) => {\n+            token::ByteStrRaw(n) => {\n                 let s = symbol.as_str();\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n@@ -136,69 +156,95 @@ impl LitKind {\n                     symbol.to_string().into_bytes()\n                 };\n \n-                LitKind::ByteStr(bytes.into())\n+                LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n             token::Err => LitKind::Err,\n         })\n     }\n+}\n \n-    /// Attempts to recover a token from semantic literal.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn to_token_lit(&self) -> token::Lit {\n-        let (kind, symbol, suffix) = match *self {\n-            LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n-                // Don't re-intern unless the escaped string is different.\n-                let s = symbol.as_str();\n-                let escaped = s.escape_default().to_string();\n-                let symbol = if s == escaped { symbol } else { Symbol::intern(&escaped) };\n-                (token::Str, symbol, None)\n-            }\n-            LitKind::Str(symbol, ast::StrStyle::Raw(n)) => (token::StrRaw(n), symbol, None),\n-            LitKind::ByteStr(ref bytes) => {\n-                let string = bytes.escape_ascii().to_string();\n-                (token::ByteStr, Symbol::intern(&string), None)\n+impl fmt::Display for LitKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            LitKind::Byte(b) => {\n+                let b: String = ascii::escape_default(b).map(Into::<char>::into).collect();\n+                write!(f, \"b'{}'\", b)?;\n             }\n-            LitKind::Byte(byte) => {\n-                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                (token::Byte, Symbol::intern(&string), None)\n+            LitKind::Char(ch) => write!(f, \"'{}'\", escape_char_symbol(ch))?,\n+            LitKind::Str(sym, StrStyle::Cooked) => write!(f, \"\\\"{}\\\"\", escape_string_symbol(sym))?,\n+            LitKind::Str(sym, StrStyle::Raw(n)) => write!(\n+                f,\n+                \"r{delim}\\\"{string}\\\"{delim}\",\n+                delim = \"#\".repeat(n as usize),\n+                string = sym\n+            )?,\n+            LitKind::ByteStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"b\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n             }\n-            LitKind::Char(ch) => {\n-                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                (token::Char, Symbol::intern(&string), None)\n+            LitKind::ByteStr(ref bytes, StrStyle::Raw(n)) => {\n+                // Unwrap because raw byte string literals can only contain ASCII.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(\n+                    f,\n+                    \"br{delim}\\\"{string}\\\"{delim}\",\n+                    delim = \"#\".repeat(n as usize),\n+                    string = symbol\n+                )?;\n             }\n             LitKind::Int(n, ty) => {\n-                let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(ty.name()),\n-                    ast::LitIntType::Signed(ty) => Some(ty.name()),\n-                    ast::LitIntType::Unsuffixed => None,\n-                };\n-                (token::Integer, sym::integer(n), suffix)\n+                write!(f, \"{}\", n)?;\n+                match ty {\n+                    ast::LitIntType::Unsigned(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Signed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Unsuffixed => {}\n+                }\n             }\n             LitKind::Float(symbol, ty) => {\n-                let suffix = match ty {\n-                    ast::LitFloatType::Suffixed(ty) => Some(ty.name()),\n-                    ast::LitFloatType::Unsuffixed => None,\n-                };\n-                (token::Float, symbol, suffix)\n+                write!(f, \"{}\", symbol)?;\n+                match ty {\n+                    ast::LitFloatType::Suffixed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitFloatType::Unsuffixed => {}\n+                }\n             }\n-            LitKind::Bool(value) => {\n-                let symbol = if value { kw::True } else { kw::False };\n-                (token::Bool, symbol, None)\n+            LitKind::Bool(b) => write!(f, \"{}\", if b { \"true\" } else { \"false\" })?,\n+            LitKind::Err => {\n+                // This only shows up in places like `-Zunpretty=hir` output, so we\n+                // don't bother to produce something useful.\n+                write!(f, \"<bad-literal>\")?;\n             }\n-            // This only shows up in places like `-Zunpretty=hir` output, so we\n-            // don't bother to produce something useful.\n-            LitKind::Err => (token::Err, Symbol::intern(\"<bad-literal>\"), None),\n-        };\n+        }\n \n-        token::Lit::new(kind, symbol, suffix)\n+        Ok(())\n     }\n }\n \n impl MetaItemLit {\n-    /// Converts token literal into a meta item literal.\n+    /// Converts a token literal into a meta item literal.\n     pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<MetaItemLit, LitError> {\n-        Ok(MetaItemLit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n+        Ok(MetaItemLit {\n+            symbol: token_lit.symbol,\n+            suffix: token_lit.suffix,\n+            kind: LitKind::from_token_lit(token_lit)?,\n+            span,\n+        })\n+    }\n+\n+    /// Cheaply converts a meta item literal into a token literal.\n+    pub fn as_token_lit(&self) -> token::Lit {\n+        let kind = match self.kind {\n+            LitKind::Bool(_) => token::Bool,\n+            LitKind::Str(_, ast::StrStyle::Cooked) => token::Str,\n+            LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n+            LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n+            LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::Byte(_) => token::Byte,\n+            LitKind::Char(_) => token::Char,\n+            LitKind::Int(..) => token::Integer,\n+            LitKind::Float(..) => token::Float,\n+            LitKind::Err => token::Err,\n+        };\n+\n+        token::Lit::new(kind, self.symbol, self.suffix)\n     }\n \n     /// Converts an arbitrary token into meta item literal."}, {"sha": "3946aab646a1a5b5694b2ed82b2a3039b0dbb3f1", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -97,7 +97,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::IncludedBytes(bytes) => hir::ExprKind::Lit(respan(\n                     self.lower_span(e.span),\n-                    LitKind::ByteStr(bytes.clone()),\n+                    LitKind::ByteStr(bytes.clone(), StrStyle::Cooked),\n                 )),\n                 ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);"}, {"sha": "d67ede6e1302ef731017cf5f61d9ec7ab56dc87a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -958,7 +958,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     lit\n                 } else {\n                     MetaItemLit {\n-                        token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n+                        symbol: kw::Empty,\n+                        suffix: None,\n                         kind: LitKind::Err,\n                         span: DUMMY_SP,\n                     }"}, {"sha": "d0e4761a10db8978519b3326d5718ead15bf29b7", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -376,7 +376,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn print_meta_item_lit(&mut self, lit: &ast::MetaItemLit) {\n-        self.print_token_literal(lit.token_lit, lit.span)\n+        self.print_token_literal(lit.as_token_lit(), lit.span)\n     }\n \n     fn print_token_literal(&mut self, token_lit: token::Lit, span: Span) {"}, {"sha": "3b17f6dd627ebb15eeebb66b0ab4d4730b22aeaf", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -2,6 +2,8 @@ use crate::pp::Breaks::Inconsistent;\n use crate::pprust::state::{AnnNode, IterDelimited, PrintState, State, INDENT_UNIT};\n \n use rustc_ast::ptr::P;\n+use rustc_ast::token;\n+use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode};\n \n@@ -323,7 +325,7 @@ impl<'a> State<'a> {\n                 self.print_token_literal(*token_lit, expr.span);\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n-                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                let lit = token::Lit::new(token::ByteStr, escape_byte_str_symbol(bytes), None);\n                 self.print_token_literal(lit, expr.span)\n             }\n             ast::ExprKind::Cast(expr, ty) => {"}, {"sha": "4c424ea430bdf1f0b01872db872944d88b8aea36", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -69,7 +69,7 @@ fn invalid_type_err(\n         Ok(ast::LitKind::Int(_, _)) => {\n             cx.span_err(span, \"numeric literal is not a `u8`\");\n         }\n-        Ok(ast::LitKind::ByteStr(_) | ast::LitKind::Byte(_)) => unreachable!(),\n+        Ok(ast::LitKind::ByteStr(..) | ast::LitKind::Byte(_)) => unreachable!(),\n         Err(err) => {\n             report_lit_error(&cx.sess.parse_sess, err, token_lit, span);\n         }\n@@ -97,7 +97,7 @@ fn handle_array_element(\n             )) if val <= u8::MAX.into() => Some(val as u8),\n \n             Ok(ast::LitKind::Byte(val)) => Some(val),\n-            Ok(ast::LitKind::ByteStr(_)) => {\n+            Ok(ast::LitKind::ByteStr(..)) => {\n                 if !*has_errors {\n                     cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n                         .note(\"byte strings are treated as arrays of bytes\")\n@@ -174,7 +174,7 @@ pub fn expand_concat_bytes(\n                 Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n-                Ok(ast::LitKind::ByteStr(ref bytes)) => {\n+                Ok(ast::LitKind::ByteStr(ref bytes, _)) => {\n                     accumulator.extend_from_slice(&bytes);\n                 }\n                 _ => {"}, {"sha": "2a8dc02849ea71e6a51701e7905a812966395b2c", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1,7 +1,7 @@\n use crate::cfg_eval::cfg_eval;\n \n use rustc_ast as ast;\n-use rustc_ast::{token, GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -130,9 +130,11 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n }\n \n fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n-    let help_msg = match lit.token_lit.kind {\n-        token::Str if rustc_lexer::is_ident(lit.token_lit.symbol.as_str()) => {\n-            format!(\"try using `#[derive({})]`\", lit.token_lit.symbol)\n+    let help_msg = match lit.kind {\n+        ast::LitKind::Str(_, ast::StrStyle::Cooked)\n+            if rustc_lexer::is_ident(lit.symbol.as_str()) =>\n+        {\n+            format!(\"try using `#[derive({})]`\", lit.symbol)\n         }\n         _ => \"for example, write `#[derive(Debug)]` for `Debug`\".to_string(),\n     };"}, {"sha": "00453f78287efb8ab9067dbbf1fae3a27e43984e", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1231,7 +1231,7 @@ pub fn expr_to_spanned_string<'a>(\n     Err(match expr.kind {\n         ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n             Ok(ast::LitKind::Str(s, style)) => return Ok((s, style, expr.span)),\n-            Ok(ast::LitKind::ByteStr(_)) => {\n+            Ok(ast::LitKind::ByteStr(..)) => {\n                 let mut err = cx.struct_span_err(expr.span, err_msg);\n                 let span = expr.span.shrink_to_lo();\n                 err.span_suggestion("}, {"sha": "ef50efb81253fccd1c224c92f9a61e7d34b9471c", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1,8 +1,7 @@\n use crate::base::ExtCtxt;\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Expr, LocalKind, PatKind, UnOp};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_ast::{attr, token, util::literal};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -332,36 +331,36 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n-        let token_lit = lit_kind.to_token_lit();\n-        self.expr(span, ast::ExprKind::Lit(token_lit))\n+    pub fn expr_usize(&self, span: Span, n: usize) -> P<ast::Expr> {\n+        let suffix = Some(ast::UintTy::Usize.name());\n+        let lit = token::Lit::new(token::Integer, sym::integer(n), suffix);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(\n-            span,\n-            ast::LitKind::Int(i as u128, ast::LitIntType::Unsigned(ast::UintTy::Usize)),\n-        )\n-    }\n-\n-    pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n+    pub fn expr_u32(&self, span: Span, n: u32) -> P<ast::Expr> {\n+        let suffix = Some(ast::UintTy::U32.name());\n+        let lit = token::Lit::new(token::Integer, sym::integer(n), suffix);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Bool(value))\n+    pub fn expr_bool(&self, span: Span, value: bool) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Bool, if value { kw::True } else { kw::False }, None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n+    pub fn expr_str(&self, span: Span, s: Symbol) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Str, literal::escape_string_symbol(s), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_char(&self, sp: Span, ch: char) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Char(ch))\n+    pub fn expr_char(&self, span: Span, ch: char) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Char, literal::escape_char_symbol(ch), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_byte_str(&self, sp: Span, bytes: Vec<u8>) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::ByteStr(Lrc::from(bytes)))\n+    pub fn expr_byte_str(&self, span: Span, bytes: Vec<u8>) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::ByteStr, literal::escape_byte_str_symbol(&bytes), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n     /// `[expr1, expr2, ...]`"}, {"sha": "768bdab8a54199a10aec996bc8c9a6bfa897f17c", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -6,6 +6,7 @@ use pm::{Delimiter, Level, LineColumn};\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{self, Spacing::*, TokenStream};\n+use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -526,7 +527,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n                 Ok(tokenstream::TokenStream::token_alone(token::Literal(*token_lit), expr.span))\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n-                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                let lit = token::Lit::new(token::ByteStr, escape_byte_str_symbol(bytes), None);\n                 Ok(tokenstream::TokenStream::token_alone(token::TokenKind::Literal(lit), expr.span))\n             }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {"}, {"sha": "ef98c4ba54cbdfd1e3a6c1a0b0401beb5ab2a5e8", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1245,7 +1245,7 @@ impl<'a> State<'a> {\n \n     fn print_literal(&mut self, lit: &hir::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.word(lit.node.to_token_lit().to_string())\n+        self.word(lit.node.to_string())\n     }\n \n     fn print_inline_asm(&mut self, asm: &hir::InlineAsm<'_>) {"}, {"sha": "93618c61417300b5957792e262c614d14311f178", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1169,7 +1169,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match lit.node {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n-            ast::LitKind::ByteStr(ref v) => {\n+            ast::LitKind::ByteStr(ref v, _) => {\n                 tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,"}, {"sha": "6810353f9e778bc992e43c6ee94111cdcca39aca", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Byte string patterns behave the same way as array patterns\n         // They can denote both statically and dynamically-sized byte arrays.\n         let mut pat_ty = ty;\n-        if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n+        if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(..), .. }) = lt.kind {\n             let expected = self.structurally_resolved_type(span, expected);\n             if let ty::Ref(_, inner_ty, _) = expected.kind()\n                 && matches!(inner_ty.kind(), ty::Slice(_))"}, {"sha": "3b7ed818dc9b7eb7cd88630d60e63e0fa86ad22d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -135,14 +135,14 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _))\n             if matches!(inner_ty.kind(), ty::Slice(_)) =>\n         {\n             let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }"}, {"sha": "57ae6a3652df5293116b866a65b79b5d4c1153d8", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -33,13 +33,13 @@ pub(crate) fn lit_to_const<'tcx>(\n             let str_bytes = s.as_str().as_bytes();\n             ty::ValTree::from_raw_bytes(tcx, str_bytes)\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _))\n             if matches!(inner_ty.kind(), ty::Slice(_)) =>\n         {\n             let bytes = data as &[u8];\n             ty::ValTree::from_raw_bytes(tcx, bytes)\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let bytes = data as &[u8];\n             ty::ValTree::from_raw_bytes(tcx, bytes)\n         }"}, {"sha": "8a3545eb3be3ab5d874b9c11acc48761774706f1", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1534,15 +1534,16 @@ impl<'a> Parser<'a> {\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n                 || self.token.is_op())\n         {\n-            let lit = self.recover_unclosed_char(label_.ident, |self_| {\n-                self_.sess.create_err(UnexpectedTokenAfterLabel {\n-                    span: self_.token.span,\n-                    remove_label: None,\n-                    enclose_in_block: None,\n-                })\n-            });\n+            let (lit, _) =\n+                self.recover_unclosed_char(label_.ident, Parser::mk_token_lit_char, |self_| {\n+                    self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                        span: self_.token.span,\n+                        remove_label: None,\n+                        enclose_in_block: None,\n+                    })\n+                });\n             consume_colon = false;\n-            Ok(self.mk_expr(lo, ExprKind::Lit(lit.token_lit)))\n+            Ok(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1617,12 +1618,13 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n-    /// Emit an error when a char is parsed as a lifetime because of a missing quote\n-    pub(super) fn recover_unclosed_char(\n+    /// Emit an error when a char is parsed as a lifetime because of a missing quote.\n+    pub(super) fn recover_unclosed_char<L>(\n         &self,\n         lifetime: Ident,\n+        mk_lit_char: impl FnOnce(Symbol, Span) -> L,\n         err: impl FnOnce(&Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> ast::MetaItemLit {\n+    ) -> L {\n         if let Some(mut diag) =\n             self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n         {\n@@ -1644,11 +1646,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n         let name = lifetime.without_first_quote().name;\n-        ast::MetaItemLit {\n-            token_lit: token::Lit::new(token::LitKind::Char, name, None),\n-            kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n-            span: lifetime.span,\n-        }\n+        mk_lit_char(name, lifetime.span)\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n@@ -1764,8 +1762,8 @@ impl<'a> Parser<'a> {\n             Some(lit) => match lit.kind {\n                 ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n                     style,\n-                    symbol: lit.token_lit.symbol,\n-                    suffix: lit.token_lit.suffix,\n+                    symbol: lit.symbol,\n+                    suffix: lit.suffix,\n                     span: lit.span,\n                     symbol_unescaped,\n                 }),\n@@ -1775,7 +1773,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn handle_missing_lit(&mut self) -> PResult<'a, MetaItemLit> {\n+    pub(crate) fn mk_token_lit_char(name: Symbol, span: Span) -> (token::Lit, Span) {\n+        (token::Lit { symbol: name, suffix: None, kind: token::Char }, span)\n+    }\n+\n+    fn mk_meta_item_lit_char(name: Symbol, span: Span) -> MetaItemLit {\n+        ast::MetaItemLit {\n+            symbol: name,\n+            suffix: None,\n+            kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n+            span,\n+        }\n+    }\n+\n+    fn handle_missing_lit<L>(\n+        &mut self,\n+        mk_lit_char: impl FnOnce(Symbol, Span) -> L,\n+    ) -> PResult<'a, L> {\n         if let token::Interpolated(inner) = &self.token.kind {\n             let expr = match inner.as_ref() {\n                 token::NtExpr(expr) => Some(expr),\n@@ -1799,7 +1813,7 @@ impl<'a> Parser<'a> {\n         // On an error path, eagerly consider a lifetime to be an unclosed character lit\n         if self.token.is_lifetime() {\n             let lt = self.expect_lifetime();\n-            Ok(self.recover_unclosed_char(lt.ident, err))\n+            Ok(self.recover_unclosed_char(lt.ident, mk_lit_char, err))\n         } else {\n             Err(err(self))\n         }\n@@ -1808,11 +1822,13 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_token_lit(&mut self) -> PResult<'a, (token::Lit, Span)> {\n         self.parse_opt_token_lit()\n             .ok_or(())\n-            .or_else(|()| self.handle_missing_lit().map(|lit| (lit.token_lit, lit.span)))\n+            .or_else(|()| self.handle_missing_lit(Parser::mk_token_lit_char))\n     }\n \n     pub(super) fn parse_meta_item_lit(&mut self) -> PResult<'a, MetaItemLit> {\n-        self.parse_opt_meta_item_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n+        self.parse_opt_meta_item_lit()\n+            .ok_or(())\n+            .or_else(|()| self.handle_missing_lit(Parser::mk_meta_item_lit_char))\n     }\n \n     fn recover_after_dot(&mut self) -> Option<Token> {"}, {"sha": "a1981e11477753b4506a5f2770e71570e1eb2c57", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -411,16 +411,20 @@ impl<'a> Parser<'a> {\n         {\n             // Recover a `'a` as a `'a'` literal\n             let lt = self.expect_lifetime();\n-            let lit = self.recover_unclosed_char(lt.ident, |self_| {\n-                let expected = expected.unwrap_or(\"pattern\");\n-                let msg =\n-                    format!(\"expected {}, found {}\", expected, super::token_descr(&self_.token));\n+            let (lit, _) =\n+                self.recover_unclosed_char(lt.ident, Parser::mk_token_lit_char, |self_| {\n+                    let expected = expected.unwrap_or(\"pattern\");\n+                    let msg = format!(\n+                        \"expected {}, found {}\",\n+                        expected,\n+                        super::token_descr(&self_.token)\n+                    );\n \n-                let mut err = self_.struct_span_err(self_.token.span, &msg);\n-                err.span_label(self_.token.span, format!(\"expected {}\", expected));\n-                err\n-            });\n-            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit.token_lit)))\n+                    let mut err = self_.struct_span_err(self_.token.span, &msg);\n+                    err.span_label(self_.token.span, format!(\"expected {}\", expected));\n+                    err\n+                });\n+            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else {\n             // Try to parse everything else as literal with optional minus\n             match self.parse_literal_maybe_minus() {"}, {"sha": "81f6767243683eb9fb26909ec5eaece2502db971", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -1,9 +1,8 @@\n use super::*;\n \n-use rustc_ast::attr;\n-use rustc_ast::Path;\n+use rustc_ast::{LitKind, MetaItemLit, Path, StrStyle};\n use rustc_span::create_default_session_globals_then;\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n \n fn word_cfg(s: &str) -> Cfg {\n@@ -22,6 +21,15 @@ fn dummy_meta_item_word(name: &str) -> MetaItem {\n     }\n }\n \n+fn dummy_meta_item_name_value(name: &str, symbol: Symbol, kind: LitKind) -> MetaItem {\n+    let lit = MetaItemLit { symbol, suffix: None, kind, span: DUMMY_SP };\n+    MetaItem {\n+        path: Path::from_ident(Ident::from_str(name)),\n+        kind: MetaItemKind::NameValue(lit),\n+        span: DUMMY_SP,\n+    }\n+}\n+\n macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:ident),* $(,)?]) => {\n         MetaItem {\n@@ -242,8 +250,8 @@ fn test_parse_ok() {\n         let mi = dummy_meta_item_word(\"all\");\n         assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n-        let mi =\n-            attr::mk_name_value_item_str(Ident::from_str(\"all\"), Symbol::intern(\"done\"), DUMMY_SP);\n+        let done = Symbol::intern(\"done\");\n+        let mi = dummy_meta_item_name_value(\"all\", done, LitKind::Str(done, StrStyle::Cooked));\n         assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n         let mi = dummy_meta_item_list!(all, [a, b]);\n@@ -272,7 +280,7 @@ fn test_parse_ok() {\n #[test]\n fn test_parse_err() {\n     create_default_session_globals_then(|| {\n-        let mi = attr::mk_name_value_item(Ident::from_str(\"foo\"), LitKind::Bool(false), DUMMY_SP);\n+        let mi = dummy_meta_item_name_value(\"foo\", kw::False, LitKind::Bool(false));\n         assert!(Cfg::parse(&mi).is_err());\n \n         let mi = dummy_meta_item_list!(not, [a, b]);"}, {"sha": "98329e7fc91935d61601a784ced2f4773fd4c866", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -10,7 +10,6 @@ use std::{cmp, fmt, iter};\n use arrayvec::ArrayVec;\n use thin_vec::ThinVec;\n \n-use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n@@ -27,7 +26,6 @@ use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt, Visibility};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, FileName, Loc};\n use rustc_target::abi::VariantIdx;\n@@ -982,12 +980,12 @@ impl AttributesExt for [ast::Attribute] {\n         // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n         for attr in self.lists(sym::target_feature) {\n             if attr.has_name(sym::enable) {\n-                if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(\n-                        Ident::with_dummy_span(sym::target_feature),\n-                        feat,\n-                        DUMMY_SP,\n-                    );\n+                if attr.value_str().is_some() {\n+                    // Clone `enable = \"feat\"`, change to `target_feature = \"feat\"`.\n+                    // Unwrap is safe because `value_str` succeeded above.\n+                    let mut meta = attr.meta_item().unwrap().clone();\n+                    meta.path = ast::Path::from_ident(Ident::with_dummy_span(sym::target_feature));\n+\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;\n                     }"}, {"sha": "6a4861747d267c83663ca3e405a8d61d13564c26", "filename": "src/tools/clippy/clippy_lints/src/invalid_utf8_in_unchecked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_utf8_in_unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_utf8_in_unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_utf8_in_unchecked.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidUtf8InUnchecked {\n         if let Some([arg]) = match_function_call(cx, expr, &paths::STR_FROM_UTF8_UNCHECKED) {\n             match &arg.kind {\n                 ExprKind::Lit(Spanned { node: lit, .. }) => {\n-                    if let LitKind::ByteStr(bytes) = &lit\n+                    if let LitKind::ByteStr(bytes, _) = &lit\n                         && std::str::from_utf8(bytes).is_err()\n                     {\n                         lint(cx, expr.span);"}, {"sha": "424c0d9e798288257d0347c61c666a12574b5f23", "filename": "src/tools/clippy/clippy_lints/src/large_include_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_include_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_include_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_include_file.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -60,7 +60,7 @@ impl LateLintPass<'_> for LargeIncludeFile {\n             then {\n                 let len = match &lit.node {\n                     // include_bytes\n-                    LitKind::ByteStr(bstr) => bstr.len(),\n+                    LitKind::ByteStr(bstr, _) => bstr.len(),\n                     // include_str\n                     LitKind::Str(sym, _) => sym.as_str().len(),\n                     _ => return,"}, {"sha": "158e6caa4de5485ebcc7b30bd7eb806bc822f84b", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -282,7 +282,7 @@ impl<'a> NormalizedPat<'a> {\n                 // TODO: Handle negative integers. They're currently treated as a wild match.\n                 ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n-                    LitKind::ByteStr(ref bytes) => Self::LitBytes(bytes),\n+                    LitKind::ByteStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),"}, {"sha": "bd7daf0773caf914b7d3bd4b34b9ba88e4f5cba6", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 };\n                 kind!(\"Float(_, {float_ty})\");\n             },\n-            LitKind::ByteStr(ref vec) => {\n+            LitKind::ByteStr(ref vec, _) => {\n                 bind!(self, vec);\n                 kind!(\"ByteStr(ref {vec})\");\n                 chain!(self, \"let [{:?}] = **{vec}\", vec.value);"}, {"sha": "43f0df145f0ec606a4393b7ea73db736b376195d", "filename": "src/tools/clippy/clippy_utils/src/check_proc_macro.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -69,7 +69,9 @@ fn lit_search_pat(lit: &LitKind) -> (Pat, Pat) {\n         LitKind::Str(_, StrStyle::Cooked) => (Pat::Str(\"\\\"\"), Pat::Str(\"\\\"\")),\n         LitKind::Str(_, StrStyle::Raw(0)) => (Pat::Str(\"r\"), Pat::Str(\"\\\"\")),\n         LitKind::Str(_, StrStyle::Raw(_)) => (Pat::Str(\"r#\"), Pat::Str(\"#\")),\n-        LitKind::ByteStr(_) => (Pat::Str(\"b\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::ByteStr(_, StrStyle::Cooked) => (Pat::Str(\"b\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::ByteStr(_, StrStyle::Raw(0)) => (Pat::Str(\"br\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::ByteStr(_, StrStyle::Raw(_)) => (Pat::Str(\"br#\\\"\"), Pat::Str(\"#\")),\n         LitKind::Byte(_) => (Pat::Str(\"b'\"), Pat::Str(\"'\")),\n         LitKind::Char(_) => (Pat::Str(\"'\"), Pat::Str(\"'\")),\n         LitKind::Int(_, LitIntType::Signed(IntTy::Isize)) => (Pat::Num, Pat::Str(\"isize\")),"}, {"sha": "7a637d32babecab6656bd5705f5dbf1873449f60", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -210,7 +210,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     match *lit {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n-        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::ByteStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {"}, {"sha": "c503eeeb9b3b950e387d7b8b0e6a82dcd40a226b", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd2070af7643ad88d280a4933bc4fb60451e521/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=2cd2070af7643ad88d280a4933bc4fb60451e521", "patch": "@@ -260,7 +260,9 @@ impl Rewrite for ast::NestedMetaItem {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n-            ast::NestedMetaItem::Lit(ref l) => rewrite_literal(context, l.token_lit, l.span, shape),\n+            ast::NestedMetaItem::Lit(ref l) => {\n+                rewrite_literal(context, l.as_token_lit(), l.span, shape)\n+            }\n         }\n     }\n }\n@@ -308,18 +310,18 @@ impl Rewrite for ast::MetaItem {\n                     }),\n                 )?\n             }\n-            ast::MetaItemKind::NameValue(ref literal) => {\n+            ast::MetaItemKind::NameValue(ref lit) => {\n                 let path = rewrite_path(context, PathContext::Type, &None, &self.path, shape)?;\n                 // 3 = ` = `\n                 let lit_shape = shape.shrink_left(path.len() + 3)?;\n-                // `rewrite_literal` returns `None` when `literal` exceeds max\n+                // `rewrite_literal` returns `None` when `lit` exceeds max\n                 // width. Since a literal is basically unformattable unless it\n                 // is a string literal (and only if `format_strings` is set),\n                 // we might be better off ignoring the fact that the attribute\n                 // is longer than the max width and continue on formatting.\n                 // See #2479 for example.\n-                let value = rewrite_literal(context, literal.token_lit, literal.span, lit_shape)\n-                    .unwrap_or_else(|| context.snippet(literal.span).to_owned());\n+                let value = rewrite_literal(context, lit.as_token_lit(), lit.span, lit_shape)\n+                    .unwrap_or_else(|| context.snippet(lit.span).to_owned());\n                 format!(\"{} = {}\", path, value)\n             }\n         })"}]}