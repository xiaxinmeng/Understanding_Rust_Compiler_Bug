{"sha": "9c980276d81b727bb8efcbe63f51866ba19793a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOTgwMjc2ZDgxYjcyN2JiOGVmY2JlNjNmNTE4NjZiYTE5NzkzYTA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-21T11:09:13Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-21T11:09:13Z"}, "message": "Directly use Cranelift instructions for 128bit int shifts", "tree": {"sha": "a500213b47cd8388e90a59d4ea649c0701895750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a500213b47cd8388e90a59d4ea649c0701895750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c980276d81b727bb8efcbe63f51866ba19793a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c980276d81b727bb8efcbe63f51866ba19793a0", "html_url": "https://github.com/rust-lang/rust/commit/9c980276d81b727bb8efcbe63f51866ba19793a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c980276d81b727bb8efcbe63f51866ba19793a0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f98b586f9c835e8e3ebecf3db260d2f0ad402a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f98b586f9c835e8e3ebecf3db260d2f0ad402a", "html_url": "https://github.com/rust-lang/rust/commit/c5f98b586f9c835e8e3ebecf3db260d2f0ad402a"}], "stats": {"total": 112, "additions": 9, "deletions": 103}, "files": [{"sha": "7b674df446a23783bbb736085583593bff5148da", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9c980276d81b727bb8efcbe63f51866ba19793a0/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c980276d81b727bb8efcbe63f51866ba19793a0/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=9c980276d81b727bb8efcbe63f51866ba19793a0", "patch": "@@ -97,70 +97,23 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 None\n             };\n \n-            // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n-            // integer into its lsb and msb.\n-            // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n-            if resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n-                let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n-                let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n-                let val = match (bin_op, is_signed) {\n-                    (BinOp::Shr, false) => {\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.u128)))\n-                    }\n-                    (BinOp::Shr, true) => {\n-                        let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n-                        let all_ones = fx.bcx.ins().iconst(types::I64, u64::MAX as i64);\n-                        let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n-\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n-                    }\n-                    (BinOp::Shl, _) => {\n-                        let val_ty = if is_signed {\n-                            fx.tcx.types.i128\n-                        } else {\n-                            fx.tcx.types.u128\n-                        };\n-                        let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n-                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n-                    }\n-                    _ => None,\n-                };\n-                if let Some(val) = val {\n-                    if let Some(is_overflow) = is_overflow {\n-                        let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                        let val = val.load_scalar(fx);\n-                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n+            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n+            let val = match bin_op {\n+                BinOp::Shl => fx.bcx.ins().ishl(lhs_val, truncated_rhs),\n+                BinOp::Shr => {\n+                    if is_signed {\n+                        fx.bcx.ins().sshr(lhs_val, truncated_rhs)\n                     } else {\n-                        return Some(val);\n+                        fx.bcx.ins().ushr(lhs_val, truncated_rhs)\n                     }\n                 }\n-            }\n-\n-            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n-            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.tcx.types.u32));\n-            let val = match (bin_op, is_signed) {\n-                (BinOp::Shl, false) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shl, true) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (BinOp::Shr, false) => {\n-                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shr, true) => {\n-                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (_, _) => unreachable!(),\n+                _ => unreachable!(),\n             };\n             if let Some(is_overflow) = is_overflow {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                let val = val.load_scalar(fx);\n                 Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n             } else {\n-                Some(val)\n+                Some(CValue::by_val(val, lhs.layout()))\n             }\n         }\n     }"}, {"sha": "1443aedb3b8a7a6e9b0f426a719240717b0e24ab", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9c980276d81b727bb8efcbe63f51866ba19793a0/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c980276d81b727bb8efcbe63f51866ba19793a0/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=9c980276d81b727bb8efcbe63f51866ba19793a0", "patch": "@@ -3,8 +3,6 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n-\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -175,51 +173,6 @@ pub(crate) fn codegen_icmp_imm(\n     }\n }\n \n-fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n-    if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } = func.dfg[inst]\n-        {\n-            Some(imm.into())\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    let (lsb, msb) = if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::Binary {\n-            opcode: Opcode::Iconcat,\n-            args: [lsb, msb],\n-        } = func.dfg[inst]\n-        {\n-            (lsb, msb)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        return None;\n-    };\n-\n-    let lsb = u128::from(resolve_normal_value_imm(func, lsb)? as u64);\n-    let msb = u128::from(resolve_normal_value_imm(func, msb)? as u64);\n-\n-    Some(msb << 64 | lsb)\n-}\n-\n-pub(crate) fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    if func.dfg.value_type(val) == types::I128 {\n-        resolve_128bit_value_imm(func, val)\n-    } else {\n-        resolve_normal_value_imm(func, val).map(|imm| u128::from(imm as u64))\n-    }\n-}\n-\n pub(crate) fn type_min_max_value(\n     bcx: &mut FunctionBuilder<'_>,\n     ty: Type,"}]}