{"sha": "894ef966c631facd13cd0d021acca43e37c8510e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NGVmOTY2YzYzMWZhY2QxM2NkMGQwMjFhY2NhNDNlMzdjODUxMGU=", "commit": {"author": {"name": "Stephen M. Coakley", "email": "me@stephencoakley.com", "date": "2016-10-05T16:34:25Z"}, "committer": {"name": "Stephen M. Coakley", "email": "me@stephencoakley.com", "date": "2016-10-05T16:34:25Z"}, "message": "Generate ID using u64 + atomic spinlock", "tree": {"sha": "fb94586493ea4948ce49790566421296323dec8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb94586493ea4948ce49790566421296323dec8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894ef966c631facd13cd0d021acca43e37c8510e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJX9SuSAAoJEJG1nBhJTE/AVQQP/1VdAutcwx4pOZ/ognGRxIkC\n/OHgA/9ikLRQCnBL+GLWn+wO8oTIZcf+mt2+hMVxEBh5ONwBtmNqpKgWAN09mp0D\n6x6XnxDXWYxAYsGF9xCyUwu/4JmxhG5jpvCsU9xrH6b3wxgdgWpPVwq1PYfCh9fK\nyPLq5rZyqrE/CWy4t7XjwgMo2chFn9/FOXChhB/JXj6ZdFBo9ihZ7fsNSey24dj9\ndtmmrHPP1c5+DnHhpmMRoONiHQIcVkFIhGKMMNognLQhn4js/6f6iqlgOIxOJPIs\nZ1T7Ok+Wx3odpOCRaGrNOmbvFQR3KFWfmzUPNcq65PbTjR9glJDKJoBE1DMK1Isb\nUT42G/YjWsDFWx9dLC3DiF+1m7EkZTErnr/KgeXuKsn+WiEc5B1Zq32Gk7c2j6If\n/LDCxGxjA7b+ANW/lzyhO1THpBtRZEnGxRT17xP31QRTlnPuoiuuILIlYJ4wDPia\nyg4sPEAklDinZsDyunJolksiAa8j9erNFRr1Sag509T+9QWK6Nk91uHOi0inHyg6\nDjF0TKbOHAoPELTd9Eop0n//uNKYiOSwhST26shLPpa8q6E3Px/VaGLs1UZFnGkn\n8Uy8eYjad8NabpMrE3127SixKEu9F9hqzwwUxKaNA8QOfSE4wwlX+3/489e6zLTl\nVDYPCtk41DptRopWCWkE\n=AQVu\n-----END PGP SIGNATURE-----", "payload": "tree fb94586493ea4948ce49790566421296323dec8e\nparent 6e10e29a9702ef2fb5b1cedced4e2a72a1a81b69\nauthor Stephen M. Coakley <me@stephencoakley.com> 1475685265 -0500\ncommitter Stephen M. Coakley <me@stephencoakley.com> 1475685265 -0500\n\nGenerate ID using u64 + atomic spinlock\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894ef966c631facd13cd0d021acca43e37c8510e", "html_url": "https://github.com/rust-lang/rust/commit/894ef966c631facd13cd0d021acca43e37c8510e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894ef966c631facd13cd0d021acca43e37c8510e/comments", "author": {"login": "sagebind", "id": 2192863, "node_id": "MDQ6VXNlcjIxOTI4NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/2192863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sagebind", "html_url": "https://github.com/sagebind", "followers_url": "https://api.github.com/users/sagebind/followers", "following_url": "https://api.github.com/users/sagebind/following{/other_user}", "gists_url": "https://api.github.com/users/sagebind/gists{/gist_id}", "starred_url": "https://api.github.com/users/sagebind/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sagebind/subscriptions", "organizations_url": "https://api.github.com/users/sagebind/orgs", "repos_url": "https://api.github.com/users/sagebind/repos", "events_url": "https://api.github.com/users/sagebind/events{/privacy}", "received_events_url": "https://api.github.com/users/sagebind/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sagebind", "id": 2192863, "node_id": "MDQ6VXNlcjIxOTI4NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/2192863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sagebind", "html_url": "https://github.com/sagebind", "followers_url": "https://api.github.com/users/sagebind/followers", "following_url": "https://api.github.com/users/sagebind/following{/other_user}", "gists_url": "https://api.github.com/users/sagebind/gists{/gist_id}", "starred_url": "https://api.github.com/users/sagebind/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sagebind/subscriptions", "organizations_url": "https://api.github.com/users/sagebind/orgs", "repos_url": "https://api.github.com/users/sagebind/repos", "events_url": "https://api.github.com/users/sagebind/events{/privacy}", "received_events_url": "https://api.github.com/users/sagebind/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e10e29a9702ef2fb5b1cedced4e2a72a1a81b69", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e10e29a9702ef2fb5b1cedced4e2a72a1a81b69", "html_url": "https://github.com/rust-lang/rust/commit/6e10e29a9702ef2fb5b1cedced4e2a72a1a81b69"}], "stats": {"total": 68, "additions": 54, "deletions": 14}, "files": [{"sha": "a20c2c5002b79a939aaa75fcc1a44cbb68de3f1a", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/894ef966c631facd13cd0d021acca43e37c8510e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894ef966c631facd13cd0d021acca43e37c8510e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=894ef966c631facd13cd0d021acca43e37c8510e", "patch": "@@ -165,7 +165,7 @@ use panic;\n use panicking;\n use str;\n use sync::{Mutex, Condvar, Arc};\n-use sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+use sync::atomic::{AtomicBool, Ordering};\n use sys::thread as imp;\n use sys_common::thread_info;\n use sys_common::util;\n@@ -536,21 +536,52 @@ pub fn park_timeout(dur: Duration) {\n /// designated identifier.\n #[unstable(feature = \"thread_id\", issue = \"21507\")]\n #[derive(Eq, PartialEq, Copy, Clone)]\n-pub struct ThreadId(usize);\n+pub struct ThreadId(u64);\n \n impl ThreadId {\n-    /// Returns an identifier unique to the current calling thread.\n-    #[unstable(feature = \"thread_id\", issue = \"21507\")]\n-    pub fn current() -> ThreadId {\n-        static THREAD_ID_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n-        #[thread_local] static mut THREAD_ID: ThreadId = ThreadId(0);\n+    // Generate a new unique thread ID. Since this function is called every\n+    // time a thread is created, this is optimized to generate unique values\n+    // as quickly as possible.\n+    fn new() -> ThreadId {\n+        // 64-bit operations are not atomic on all systems, so use an atomic\n+        // flag as a guard around a 64-bit global counter. The window for\n+        // contention on the counter is rather narrow since the general case\n+        // should be compiled down to three instructions between locking and\n+        // unlocking the guard. Since contention on the guard is low, use a\n+        // spinlock that optimizes for the fast path of the guard being\n+        // unlocked.\n+        static GUARD: AtomicBool = AtomicBool::new(false);\n+        static mut COUNTER: u64 = 0;\n+\n+        // Get exclusive access to the counter.\n+        while GUARD.compare_exchange_weak(\n+            false,\n+            true,\n+            Ordering::Acquire,\n+            Ordering::Relaxed\n+        ).is_err() {\n+            // Give up the rest of our thread quantum if another thread is\n+            // using the counter. This is the slow_er_ path.\n+            yield_now();\n+        }\n \n-        unsafe {\n-            if THREAD_ID.0 == 0 {\n-                THREAD_ID.0 = 1 + THREAD_ID_COUNT.fetch_add(1, Ordering::SeqCst);\n+        // We have exclusive access to the counter, so use it fast and get out.\n+        let id = unsafe {\n+            // If we somehow use up all our bits, panic so that we're not\n+            // covering up subtle bugs of IDs being reused.\n+            if COUNTER == ::u64::MAX {\n+                panic!(\"failed to generate unique thread ID: bitspace exhausted\");\n             }\n-            THREAD_ID\n-        }\n+\n+            let id = COUNTER;\n+            COUNTER += 1;\n+            id\n+        };\n+\n+        // Unlock the guard.\n+        GUARD.store(false, Ordering::Release);\n+\n+        ThreadId(id)\n     }\n }\n \n@@ -561,6 +592,7 @@ impl ThreadId {\n /// The internal representation of a `Thread` handle\n struct Inner {\n     name: Option<CString>,      // Guaranteed to be UTF-8\n+    id: ThreadId,\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n     cvar: Condvar,\n }\n@@ -581,6 +613,7 @@ impl Thread {\n         Thread {\n             inner: Arc::new(Inner {\n                 name: cname,\n+                id: ThreadId::new(),\n                 lock: Mutex::new(false),\n                 cvar: Condvar::new(),\n             })\n@@ -599,6 +632,12 @@ impl Thread {\n         }\n     }\n \n+    /// Gets the thread's unique identifier.\n+    #[unstable(feature = \"thread_id\", issue = \"21507\")]\n+    pub fn id(&self) -> ThreadId {\n+        self.inner.id\n+    }\n+\n     /// Gets the thread's name.\n     ///\n     /// # Examples\n@@ -1009,12 +1048,13 @@ mod tests {\n \n     #[test]\n     fn test_thread_id_equal() {\n-        assert!(thread::ThreadId::current() == thread::ThreadId::current());\n+        assert!(thread::current().id() == thread::current().id());\n     }\n \n     #[test]\n     fn test_thread_id_not_equal() {\n-        assert!(thread::ThreadId::current() != thread::spawn(|| thread::ThreadId::current()).join().unwrap());\n+        let spawned_id = thread::spawn(|| thread::current().id()).join().unwrap();\n+        assert!(thread::current().id() != spawned_id);\n     }\n \n     // NOTE: the corresponding test for stderr is in run-pass/thread-stderr, due"}]}