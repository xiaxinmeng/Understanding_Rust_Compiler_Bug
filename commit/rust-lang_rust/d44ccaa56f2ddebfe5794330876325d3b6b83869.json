{"sha": "d44ccaa56f2ddebfe5794330876325d3b6b83869", "node_id": "C_kwDOAAsO6NoAKGQ0NGNjYWE1NmYyZGRlYmZlNTc5NDMzMDg3NjMyNWQzYjZiODM4Njk", "commit": {"author": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2022-08-28T23:07:58Z"}, "committer": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2023-01-09T22:07:25Z"}, "message": "migrate: `types.rs`", "tree": {"sha": "77002dea1824bc68f5f8287e3b7b4e714aba059e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77002dea1824bc68f5f8287e3b7b4e714aba059e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d44ccaa56f2ddebfe5794330876325d3b6b83869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d44ccaa56f2ddebfe5794330876325d3b6b83869", "html_url": "https://github.com/rust-lang/rust/commit/d44ccaa56f2ddebfe5794330876325d3b6b83869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d44ccaa56f2ddebfe5794330876325d3b6b83869/comments", "author": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a90537b62573721c42a83c024d3d7ad031b758b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a90537b62573721c42a83c024d3d7ad031b758b", "html_url": "https://github.com/rust-lang/rust/commit/5a90537b62573721c42a83c024d3d7ad031b758b"}], "stats": {"total": 402, "additions": 248, "deletions": 154}, "files": [{"sha": "ce93616da131ee65fe440fca21f3d1d078215132", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 139, "deletions": 2, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d44ccaa56f2ddebfe5794330876325d3b6b83869/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d44ccaa56f2ddebfe5794330876325d3b6b83869/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=d44ccaa56f2ddebfe5794330876325d3b6b83869", "patch": "@@ -1,5 +1,142 @@\n-use rustc_macros::LintDiagnostic;\n-use rustc_span::{Symbol, Span};\n+use rustc_errors::{fluent, AddSubdiagnostic, DecorateLint, EmissionGuarantee};\n+use rustc_macros::{LintDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_range_endpoint_out_of_range)]\n+pub struct RangeEndpointOutOfRange<'a> {\n+    pub ty: &'a str,\n+    #[suggestion(code = \"{start}..={literal}{suffix}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub start: String,\n+    pub literal: u128,\n+    pub suffix: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_bin_hex)]\n+pub struct OverflowingBinHex<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub dec: u128,\n+    pub actually: String,\n+    #[subdiagnostic]\n+    pub sign: OverflowingBinHexSign,\n+    #[subdiagnostic]\n+    pub sub: Option<OverflowingBinHexSub<'a>>,\n+}\n+\n+pub enum OverflowingBinHexSign {\n+    Positive,\n+    Negative,\n+}\n+\n+impl AddSubdiagnostic for OverflowingBinHexSign {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            OverflowingBinHexSign::Positive => {\n+                diag.note(fluent::positive_note);\n+            }\n+            OverflowingBinHexSign::Negative => {\n+                diag.note(fluent::negative_note);\n+                diag.note(fluent::negative_becomes_note);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum OverflowingBinHexSub<'a> {\n+    #[suggestion(\n+        suggestion,\n+        code = \"{sans_suffix}{suggestion_ty}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        suggestion_ty: &'a str,\n+        sans_suffix: &'a str,\n+    },\n+    #[help(help)]\n+    Help { suggestion_ty: &'a str },\n+}\n+\n+pub struct OverflowingInt<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub min: i128,\n+    pub max: u128,\n+    pub suggestion_ty: Option<&'a str>,\n+}\n+\n+// FIXME: refactor with `Option<&'a str>` in macro\n+impl<'a, G: EmissionGuarantee> DecorateLint<'_, G> for OverflowingInt<'a> {\n+    fn decorate_lint(self, diag: rustc_errors::LintDiagnosticBuilder<'_, G>) {\n+        let mut diag = diag.build(fluent::lint_overflowing_int);\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.set_arg(\"lit\", self.lit);\n+        diag.set_arg(\"min\", self.min);\n+        diag.set_arg(\"max\", self.max);\n+        diag.note(fluent::note);\n+        if let Some(suggestion_ty) = self.suggestion_ty {\n+            diag.set_arg(\"suggestion_ty\", suggestion_ty);\n+            diag.help(fluent::help);\n+        }\n+        diag.emit();\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_only_cast_u8_to_char)]\n+pub struct OnlyCastu8ToChar {\n+    #[suggestion(code = \"'\\\\u{{{literal:X}}}'\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub literal: u128,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_uint)]\n+#[note]\n+pub struct OverflowingUInt<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub min: u128,\n+    pub max: u128,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_literal)]\n+#[note]\n+pub struct OverflowingLiteral<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_comparisons)]\n+pub struct UnusedComparisons;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_variant_size_differences)]\n+pub struct VariantSizeDifferencesDiag {\n+    pub largest: u64,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_load)]\n+#[help]\n+pub struct AtomicOrderingLoad;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_store)]\n+#[help]\n+pub struct AtomicOrderingStore;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_fence)]\n+#[help]\n+pub struct AtomicOrderingFence;\n \n #[derive(LintDiagnostic)]\n #[diag(lint_atomic_ordering_invalid)]"}, {"sha": "46e957d15931ab104740b58f9814f06ffdbf091f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 109, "deletions": 152, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/d44ccaa56f2ddebfe5794330876325d3b6b83869/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d44ccaa56f2ddebfe5794330876325d3b6b83869/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=d44ccaa56f2ddebfe5794330876325d3b6b83869", "patch": "@@ -1,9 +1,16 @@\n-use crate::lints::InvalidAtomicOrderingDiag;\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+use crate::lints::{\n+    AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, InvalidAtomicOrderingDiag,\n+    OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign, OverflowingBinHexSub,\n+    OverflowingInt, OverflowingLiteral, OverflowingUInt, RangeEndpointOutOfRange,\n+    UnusedComparisons, VariantSizeDifferencesDiag,\n+};\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{fluent, Applicability, DiagnosticMessage};\n+use rustc_errors::{fluent, DiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n@@ -146,32 +153,22 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     };\n     let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n-    cx.struct_span_lint(\n+    use rustc_ast::{LitIntType, LitKind};\n+    let suffix = match lit.node {\n+        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+        LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+        _ => bug!(),\n+    };\n+    cx.emit_spanned_lint(\n         OVERFLOWING_LITERALS,\n         struct_expr.span,\n-        fluent::lint_range_endpoint_out_of_range,\n-        |lint| {\n-            use ast::{LitIntType, LitKind};\n-\n-            lint.set_arg(\"ty\", ty);\n-\n-            // We need to preserve the literal's suffix,\n-            // as it may determine typing information.\n-            let suffix = match lit.node {\n-                LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                _ => bug!(),\n-            };\n-            let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-            lint.span_suggestion(\n-                struct_expr.span,\n-                fluent::suggestion,\n-                suggestion,\n-                Applicability::MachineApplicable,\n-            );\n-\n-            lint\n+        RangeEndpointOutOfRange {\n+            ty,\n+            suggestion: struct_expr.span,\n+            start,\n+            literal: lit_val - 1,\n+            suffix,\n         },\n     );\n \n@@ -228,58 +225,37 @@ fn report_bin_hex_error(\n     val: u128,\n     negative: bool,\n ) {\n-    cx.struct_span_lint(\n-        OVERFLOWING_LITERALS,\n-        expr.span,\n-        fluent::lint_overflowing_bin_hex,\n-        |lint| {\n-            let (t, actually) = match ty {\n-                attr::IntType::SignedInt(t) => {\n-                    let actually = if negative {\n-                        -(size.sign_extend(val) as i128)\n-                    } else {\n-                        size.sign_extend(val) as i128\n-                    };\n-                    (t.name_str(), actually.to_string())\n-                }\n-                attr::IntType::UnsignedInt(t) => {\n-                    let actually = size.truncate(val);\n-                    (t.name_str(), actually.to_string())\n-                }\n+    let (t, actually) = match ty {\n+        attr::IntType::SignedInt(t) => {\n+            let actually = if negative {\n+                -(size.sign_extend(val) as i128)\n+            } else {\n+                size.sign_extend(val) as i128\n             };\n-\n-            if negative {\n-                // If the value is negative,\n-                // emits a note about the value itself, apart from the literal.\n-                lint.note(fluent::negative_note);\n-                lint.note(fluent::negative_becomes_note);\n+            (t.name_str(), actually.to_string())\n+        }\n+        attr::IntType::UnsignedInt(t) => {\n+            let actually = size.truncate(val);\n+            (t.name_str(), actually.to_string())\n+        }\n+    };\n+    let sign =\n+        if negative { OverflowingBinHexSign::Negative } else { OverflowingBinHexSign::Positive };\n+    let sub = get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative).map(\n+        |suggestion_ty| {\n+            if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                let (sans_suffix, _) = repr_str.split_at(pos);\n+                OverflowingBinHexSub::Suggestion { span: expr.span, suggestion_ty, sans_suffix }\n             } else {\n-                lint.note(fluent::positive_note);\n+                OverflowingBinHexSub::Help { suggestion_ty }\n             }\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n-            {\n-                lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    lint.span_suggestion(\n-                        expr.span,\n-                        fluent::suggestion,\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    lint.help(fluent::help);\n-                }\n-            }\n-            lint.set_arg(\"ty\", t)\n-                .set_arg(\"lit\", repr_str)\n-                .set_arg(\"dec\", val)\n-                .set_arg(\"actually\", actually);\n-\n-            lint\n         },\n     );\n+    cx.emit_spanned_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        OverflowingBinHex { ty: t, lit: repr_str.clone(), dec: val, actually, sign, sub },\n+    )\n }\n \n // This function finds the next fitting type and generates a suggestion string.\n@@ -363,28 +339,25 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_int, |lint| {\n-            lint.set_arg(\"ty\", t.name_str())\n-                .set_arg(\n-                    \"lit\",\n-                    cx.sess()\n-                        .source_map()\n-                        .span_to_snippet(lit.span)\n-                        .expect(\"must get snippet from literal\"),\n-                )\n-                .set_arg(\"min\", min)\n-                .set_arg(\"max\", max)\n-                .note(fluent::note);\n-\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n-            {\n-                lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                lint.help(fluent::help);\n-            }\n-\n-            lint\n-        });\n+        cx.emit_spanned_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            OverflowingInt {\n+                ty: t.name_str(),\n+                lit: cx\n+                    .sess()\n+                    .source_map()\n+                    .span_to_snippet(lit.span)\n+                    .expect(\"must get snippet from literal\"),\n+                min,\n+                max,\n+                suggestion_ty: get_type_suggestion(\n+                    cx.typeck_results().node_type(e.hir_id),\n+                    v,\n+                    negative,\n+                ),\n+            },\n+        );\n     }\n }\n \n@@ -408,18 +381,10 @@ fn lint_uint_literal<'tcx>(\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             OVERFLOWING_LITERALS,\n                             par_e.span,\n-                            fluent::lint_only_cast_u8_to_char,\n-                            |lint| {\n-                                lint.span_suggestion(\n-                                    par_e.span,\n-                                    fluent::suggestion,\n-                                    format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                            },\n+                            OnlyCastu8ToChar { span: par_e.span, literal: lit_val },\n                         );\n                         return;\n                     }\n@@ -443,19 +408,20 @@ fn lint_uint_literal<'tcx>(\n             );\n             return;\n         }\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_uint, |lint| {\n-            lint.set_arg(\"ty\", t.name_str())\n-                .set_arg(\n-                    \"lit\",\n-                    cx.sess()\n-                        .source_map()\n-                        .span_to_snippet(lit.span)\n-                        .expect(\"must get snippet from literal\"),\n-                )\n-                .set_arg(\"min\", min)\n-                .set_arg(\"max\", max)\n-                .note(fluent::note)\n-        });\n+        cx.emit_spanned_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            OverflowingUInt {\n+                ty: t.name_str(),\n+                lit: cx\n+                    .sess()\n+                    .source_map()\n+                    .span_to_snippet(lit.span)\n+                    .expect(\"must get snippet from literal\"),\n+                min,\n+                max,\n+            },\n+        );\n     }\n }\n \n@@ -484,20 +450,16 @@ fn lint_literal<'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     OVERFLOWING_LITERALS,\n                     e.span,\n-                    fluent::lint_overflowing_literal,\n-                    |lint| {\n-                        lint.set_arg(\"ty\", t.name_str())\n-                            .set_arg(\n-                                \"lit\",\n-                                cx.sess()\n-                                    .source_map()\n-                                    .span_to_snippet(lit.span)\n-                                    .expect(\"must get snippet from literal\"),\n-                            )\n-                            .note(fluent::note)\n+                    OverflowingLiteral {\n+                        ty: t.name_str(),\n+                        lit: cx\n+                            .sess()\n+                            .source_map()\n+                            .span_to_snippet(lit.span)\n+                            .expect(\"must get snippet from literal\"),\n                     },\n                 );\n             }\n@@ -517,12 +479,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.struct_span_lint(\n-                        UNUSED_COMPARISONS,\n-                        e.span,\n-                        fluent::lint_unused_comparisons,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(UNUSED_COMPARISONS, e.span, UnusedComparisons);\n                 }\n             }\n             hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n@@ -1180,9 +1137,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 CItemKind::Declaration => \"block\",\n                 CItemKind::Definition => \"fn\",\n             };\n-            lint.set_arg(\"ty\", ty);\n-            lint.set_arg(\"desc\", item_description);\n-            lint.span_label(sp, fluent::label);\n+            #[allow(rustc::diagnostic_outside_of_impl)]\n+            let mut diag = lint.build(fluent::lint_improper_ctypes);\n+            diag.set_arg(\"ty\", ty);\n+            diag.set_arg(\"desc\", item_description);\n+            diag.span_label(sp, fluent::label);\n             if let Some(help) = help {\n                 lint.help(help);\n             }\n@@ -1397,11 +1356,10 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n             // We only warn if the largest variant is at least thrice as large as\n             // the second-largest.\n             if largest > slargest * 3 && slargest > 0 {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    fluent::lint_variant_size_differences,\n-                    |lint| lint.set_arg(\"largest\", largest),\n+                    VariantSizeDifferencesDiag { largest },\n                 );\n             }\n         }\n@@ -1509,17 +1467,19 @@ impl InvalidAtomicOrdering {\n \n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n-            && let Some((ordering_arg, invalid_ordering, msg)) = match method {\n-                sym::load => Some((&args[0], sym::Release, fluent::lint_atomic_ordering_load)),\n-                sym::store => Some((&args[1], sym::Acquire, fluent::lint_atomic_ordering_store)),\n+            && let Some((ordering_arg, invalid_ordering)) = match method {\n+                sym::load => Some((&args[0], sym::Release)),\n+                sym::store => Some((&args[1], sym::Acquire)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n             && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, msg, |lint| {\n-                lint.help(fluent::help)\n-            });\n+            if method == sym::load {\n+                cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, AtomicOrderingLoad);\n+            } else {\n+                cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, AtomicOrderingStore);\n+            };\n         }\n     }\n \n@@ -1530,10 +1490,7 @@ impl InvalidAtomicOrdering {\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint_atomic_ordering_fence, |lint| {\n-                lint\n-                    .help(fluent::help)\n-            });\n+            cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, args[0].span, AtomicOrderingFence);\n         }\n     }\n "}]}