{"sha": "1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "node_id": "C_kwDOAAsO6NoAKDFmZTE4YTVkYWQwZWZkZTFkNGRkMzFhZmQ0OWZjNjBmMjFkM2Y5OTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-26T09:39:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-26T09:39:12Z"}, "message": "Rollup merge of #104906 - spastorino:remove-ascribeusertypecx, r=compiler-errors\n\nRemove AscribeUserTypeCx\n\nr? ``@compiler-errors``\n\nThis basically inlines `AscribeUserTypeCx::relate_mir_and_user_ty` into `type_op_ascribe_user_type_with_span` which is the only place where it's used and makes direct use of `ObligationCtxt` API.", "tree": {"sha": "e9cfb5253d51af8187cbeb493898a1c0e4390db9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9cfb5253d51af8187cbeb493898a1c0e4390db9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjgd7ACRBK7hj4Ov3rIwAA8r0IAJqLDkIsFSHc9X1tHeijRB7f\nu192zKRgeFXf9SViOoitB6ATGS9I6hkuXwRbaBH1ZaedeW309XBf7T+bd1NcmB1F\ncvoyq4IGZZs3mlwLhP5DDt9cJGriyP8C+doARw51JaibZlEbJm1Ui3r5vbXCjH2L\nE/y4lKrRpaWWL+BLGEZzVFW+WOGsW27ku/w5aq+S4UJDEZW74OGZQiT8xDDYpEXy\nrjLAua02Wq6IpyaSPdnuyqDaCNRajK4Utvalw5iNQytZwpgEF6lQyfiN7GhA45YU\n93AB4slqcltm895wyY3LhSTt44PqEFWc1vWxSUBAdKIsEwKOmtqcoLPvt4mRN64=\n=2Xxc\n-----END PGP SIGNATURE-----\n", "payload": "tree e9cfb5253d51af8187cbeb493898a1c0e4390db9\nparent 85865448555c91711573c1b25d62010e36f512b0\nparent 3c9b30e65876090b2e1e4944dac24d7e9e182d1f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669455552 +0100\ncommitter GitHub <noreply@github.com> 1669455552 +0100\n\nRollup merge of #104906 - spastorino:remove-ascribeusertypecx, r=compiler-errors\n\nRemove AscribeUserTypeCx\n\nr? ``@compiler-errors``\n\nThis basically inlines `AscribeUserTypeCx::relate_mir_and_user_ty` into `type_op_ascribe_user_type_with_span` which is the only place where it's used and makes direct use of `ObligationCtxt` API.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "html_url": "https://github.com/rust-lang/rust/commit/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85865448555c91711573c1b25d62010e36f512b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/85865448555c91711573c1b25d62010e36f512b0", "html_url": "https://github.com/rust-lang/rust/commit/85865448555c91711573c1b25d62010e36f512b0"}, {"sha": "3c9b30e65876090b2e1e4944dac24d7e9e182d1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c9b30e65876090b2e1e4944dac24d7e9e182d1f", "html_url": "https://github.com/rust-lang/rust/commit/3c9b30e65876090b2e1e4944dac24d7e9e182d1f"}], "stats": {"total": 157, "additions": 50, "deletions": 107}, "files": [{"sha": "c6c072ea3d2bdb0e5c249a022914d22d14d36939", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 50, "deletions": 107, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "patch": "@@ -1,6 +1,4 @@\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCauseCode;\n@@ -57,122 +55,67 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n         \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n         mir_ty, def_id, user_substs\n     );\n-    let cx = AscribeUserTypeCx { ocx, param_env, span: span.unwrap_or(DUMMY_SP) };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n-    Ok(())\n-}\n+    let span = span.unwrap_or(DUMMY_SP);\n \n-struct AscribeUserTypeCx<'me, 'tcx> {\n-    ocx: &'me ObligationCtxt<'me, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-}\n+    let UserSubsts { user_self_ty, substs } = user_substs;\n+    let tcx = ocx.infcx.tcx;\n+    let cause = ObligationCause::dummy_with_span(span);\n \n-impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n-    fn normalize<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n-    }\n+    let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n+    let ty = ocx.normalize(cause.clone(), param_env, ty);\n+    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n-    fn normalize_with_cause<T>(&self, value: T, cause: ObligationCause<'tcx>) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.ocx.normalize(cause, self.param_env, value)\n-    }\n+    ocx.eq(&cause, param_env, mir_ty, ty)?;\n \n-    fn eq<T>(&self, a: T, b: T) -> Result<(), NoSolution>\n-    where\n-        T: ToTrace<'tcx>,\n-    {\n-        Ok(self.ocx.eq(&ObligationCause::dummy_with_span(self.span), self.param_env, a, b)?)\n-    }\n+    // Prove the predicates coming along with `def_id`.\n+    //\n+    // Also, normalize the `instantiated_predicates`\n+    // because otherwise we wind up with duplicate \"type\n+    // outlives\" error messages.\n+    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n-    fn prove_predicate(&self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n-        self.ocx.register_obligation(Obligation::new(\n-            self.ocx.infcx.tcx,\n-            cause,\n-            self.param_env,\n-            predicate,\n-        ));\n-    }\n+    debug!(?instantiated_predicates);\n+    for (instantiated_predicate, predicate_span) in\n+        zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n+    {\n+        let span = if span == DUMMY_SP { predicate_span } else { span };\n+        let cause = ObligationCause::new(\n+            span,\n+            hir::CRATE_HIR_ID,\n+            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+        );\n+        let instantiated_predicate =\n+            ocx.normalize(cause.clone(), param_env, instantiated_predicate);\n \n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.ocx.infcx.tcx\n+        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n     }\n \n-    #[instrument(level = \"debug\", skip(self))]\n-    fn relate_mir_and_user_ty(\n-        &self,\n-        mir_ty: Ty<'tcx>,\n-        def_id: DefId,\n-        user_substs: UserSubsts<'tcx>,\n-    ) -> Result<(), NoSolution> {\n-        let UserSubsts { user_self_ty, substs } = user_substs;\n-        let tcx = self.tcx();\n-\n-        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n-        let ty = self.normalize(ty);\n-        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-\n-        self.eq(mir_ty, ty)?;\n-\n-        // Prove the predicates coming along with `def_id`.\n-        //\n-        // Also, normalize the `instantiated_predicates`\n-        // because otherwise we wind up with duplicate \"type\n-        // outlives\" error messages.\n-        let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-        let cause = ObligationCause::dummy_with_span(self.span);\n-\n-        debug!(?instantiated_predicates);\n-        for (instantiated_predicate, predicate_span) in\n-            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n-        {\n-            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n-            let cause = ObligationCause::new(\n-                span,\n-                hir::CRATE_HIR_ID,\n-                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-            );\n-            let instantiated_predicate =\n-                self.normalize_with_cause(instantiated_predicate, cause.clone());\n-            self.prove_predicate(instantiated_predicate, cause);\n-        }\n+    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty = ocx.normalize(cause.clone(), param_env, impl_self_ty);\n \n-        if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-            let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n-            let impl_self_ty = self.normalize(impl_self_ty);\n+        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n \n-            self.eq(self_ty, impl_self_ty)?;\n-\n-            self.prove_predicate(\n-                ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n-                    .to_predicate(tcx),\n-                cause.clone(),\n-            );\n-        }\n-\n-        // In addition to proving the predicates, we have to\n-        // prove that `ty` is well-formed -- this is because\n-        // the WF of `ty` is predicated on the substs being\n-        // well-formed, and we haven't proven *that*. We don't\n-        // want to prove the WF of types from  `substs` directly because they\n-        // haven't been normalized.\n-        //\n-        // FIXME(nmatsakis): Well, perhaps we should normalize\n-        // them?  This would only be relevant if some input\n-        // type were ill-formed but did not appear in `ty`,\n-        // which...could happen with normalization...\n-        self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx),\n-            cause,\n-        );\n-        Ok(())\n+        let predicate: Predicate<'tcx> =\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into())).to_predicate(tcx);\n+        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }\n+\n+    // In addition to proving the predicates, we have to\n+    // prove that `ty` is well-formed -- this is because\n+    // the WF of `ty` is predicated on the substs being\n+    // well-formed, and we haven't proven *that*. We don't\n+    // want to prove the WF of types from  `substs` directly because they\n+    // haven't been normalized.\n+    //\n+    // FIXME(nmatsakis): Well, perhaps we should normalize\n+    // them?  This would only be relevant if some input\n+    // type were ill-formed but did not appear in `ty`,\n+    // which...could happen with normalization...\n+    let predicate: Predicate<'tcx> =\n+        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx);\n+    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n+    Ok(())\n }\n \n fn type_op_eq<'tcx>("}]}