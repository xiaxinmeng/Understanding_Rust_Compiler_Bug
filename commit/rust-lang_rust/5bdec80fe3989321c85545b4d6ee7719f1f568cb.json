{"sha": "5bdec80fe3989321c85545b4d6ee7719f1f568cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZGVjODBmZTM5ODkzMjFjODU1NDViNGQ2ZWU3NzE5ZjFmNTY4Y2I=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-19T12:55:46Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:24:37Z"}, "message": "Allow iterating over step descriptions.\n\nThis simplifies code and allows working mostly with normal Rust instead\nof macros.", "tree": {"sha": "87e59e2ed722c4b7e74e3b1229f7c04b438315b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87e59e2ed722c4b7e74e3b1229f7c04b438315b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bdec80fe3989321c85545b4d6ee7719f1f568cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bdec80fe3989321c85545b4d6ee7719f1f568cb", "html_url": "https://github.com/rust-lang/rust/commit/5bdec80fe3989321c85545b4d6ee7719f1f568cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bdec80fe3989321c85545b4d6ee7719f1f568cb/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56128fb3acdbb40876d1fc8aee613792ebef3080", "url": "https://api.github.com/repos/rust-lang/rust/commits/56128fb3acdbb40876d1fc8aee613792ebef3080", "html_url": "https://github.com/rust-lang/rust/commit/56128fb3acdbb40876d1fc8aee613792ebef3080"}], "stats": {"total": 220, "additions": 113, "deletions": 107}, "files": [{"sha": "02d65289c9cf05ef2dbd5c150c9777185d75d06a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 113, "deletions": 107, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/5bdec80fe3989321c85545b4d6ee7719f1f568cb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bdec80fe3989321c85545b4d6ee7719f1f568cb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5bdec80fe3989321c85545b4d6ee7719f1f568cb", "patch": "@@ -93,6 +93,89 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     }\n }\n \n+struct StepDescription {\n+    default: bool,\n+    only_hosts: bool,\n+    only_build_targets: bool,\n+    only_build: bool,\n+    should_run: fn(ShouldRun) -> ShouldRun,\n+    make_run: fn(&Builder, Option<&Path>, Interned<String>, Interned<String>),\n+}\n+\n+impl StepDescription {\n+    fn from<S: Step>() -> StepDescription {\n+        StepDescription {\n+            default: S::DEFAULT,\n+            only_hosts: S::ONLY_HOSTS,\n+            only_build_targets: S::ONLY_BUILD_TARGETS,\n+            only_build: S::ONLY_BUILD,\n+            should_run: S::should_run,\n+            make_run: S::make_run,\n+        }\n+    }\n+\n+    fn maybe_run(&self, builder: &Builder, path: Option<&Path>) {\n+        let build = builder.build;\n+        let hosts = if self.only_build_targets || self.only_build {\n+            &build.config.host[..1]\n+        } else {\n+            &build.hosts\n+        };\n+\n+        // Determine the actual targets participating in this rule.\n+        // NOTE: We should keep the full projection from build triple to\n+        // the hosts for the dist steps, now that the hosts array above is\n+        // truncated to avoid duplication of work in that case. Therefore\n+        // the original non-shadowed hosts array is used below.\n+        let targets = if self.only_hosts {\n+            // If --target was specified but --host wasn't specified,\n+            // don't run any host-only tests. Also, respect any `--host`\n+            // overrides as done for `hosts`.\n+            if build.flags.host.len() > 0 {\n+                &build.flags.host[..]\n+            } else if build.flags.target.len() > 0 {\n+                &[]\n+            } else if self.only_build {\n+                &build.config.host[..1]\n+            } else {\n+                &build.config.host[..]\n+            }\n+        } else {\n+            &build.targets\n+        };\n+\n+        for host in hosts {\n+            for target in targets {\n+                (self.make_run)(builder, path, *host, *target);\n+            }\n+        }\n+    }\n+\n+    fn run(v: &[StepDescription], builder: &Builder, paths: &[PathBuf]) {\n+        if paths.is_empty() {\n+            for desc in v {\n+                if desc.default {\n+                    desc.maybe_run(builder, None);\n+                }\n+            }\n+        } else {\n+            for path in paths {\n+                let mut attempted_run = false;\n+                for desc in v {\n+                    if (desc.should_run)(ShouldRun::new(builder)).run(path) {\n+                        attempted_run = true;\n+                        desc.maybe_run(builder, Some(path));\n+                    }\n+                }\n+\n+                if !attempted_run {\n+                    eprintln!(\"Warning: no rules matched {}.\", path.display());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct ShouldRun<'a> {\n     builder: &'a Builder<'a>,\n@@ -140,33 +223,34 @@ pub enum Kind {\n     Install,\n }\n \n-macro_rules! check {\n-    ($self:ident, $paths:ident, $($rule:ty),+ $(,)*) => {{\n-        let paths = $paths;\n-        if paths.is_empty() {\n-            $({\n-                if <$rule>::DEFAULT {\n-                    $self.maybe_run::<$rule>(None);\n-                }\n-            })+\n-        } else {\n-            for path in paths {\n-                let mut attempted_run = false;\n-                $({\n-                    if <$rule>::should_run(ShouldRun::new($self)).run(path) {\n-                        attempted_run = true;\n-                        $self.maybe_run::<$rule>(Some(path));\n-                    }\n-                })+\n-                if !attempted_run {\n-                    eprintln!(\"Warning: no rules matched {}.\", path.display());\n-                }\n-            }\n+impl<'a> Builder<'a> {\n+    fn get_step_descriptions(kind: Kind) -> Vec<StepDescription> {\n+        macro_rules! describe {\n+            ($($rule:ty),+ $(,)*) => {{\n+                vec![$(StepDescription::from::<$rule>()),+]\n+            }};\n         }\n-    }};\n-}\n+        match kind {\n+            Kind::Build => describe!(compile::Std, compile::Test, compile::Rustc,\n+                compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n+                tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n+                tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n+                tool::RustInstaller, tool::Cargo, tool::Rls),\n+            Kind::Test => describe!(check::Tidy, check::Bootstrap, check::Compiletest, check::Crate,\n+                check::CrateLibrustc, check::Linkcheck, check::Cargotest, check::Cargo, check::Docs,\n+                check::ErrorIndex, check::Distcheck),\n+            Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n+            Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n+                doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n+                doc::Reference),\n+            Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n+                dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n+                dist::Rls, dist::Extended, dist::HashSign),\n+            Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n+                install::Analysis, install::Src, install::Rustc),\n+        }\n+    }\n \n-impl<'a> Builder<'a> {\n     pub fn get_help(build: &Build, subcommand: &str) -> Option<String> {\n         let kind = match subcommand {\n             \"build\" => Kind::Build,\n@@ -188,31 +272,8 @@ impl<'a> Builder<'a> {\n \n         let builder = &builder;\n         let mut should_run = ShouldRun::new(builder);\n-        macro_rules! into_shouldrun {\n-            ($should_run:ident, $($rule:ty),+ $(,)*) => {{\n-                $(\n-                    $should_run = <$rule>::should_run($should_run);\n-                )+\n-            }};\n-        }\n-        match builder.kind {\n-            Kind::Build => into_shouldrun!(should_run, compile::Std, compile::Test, compile::Rustc,\n-                compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n-                tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n-                tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls),\n-            Kind::Test => into_shouldrun!(should_run, check::Tidy, check::Bootstrap,\n-                check::Compiletest, check::Crate, check::CrateLibrustc, check::Linkcheck,\n-                check::Cargotest, check::Cargo, check::Docs, check::ErrorIndex, check::Distcheck),\n-            Kind::Bench => into_shouldrun!(should_run, check::Crate, check::CrateLibrustc),\n-            Kind::Doc => into_shouldrun!(should_run, doc::UnstableBook, doc::UnstableBookGen,\n-                doc::TheBook, doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex,\n-                doc::Nomicon, doc::Reference),\n-            Kind::Dist => into_shouldrun!(should_run, dist::Docs, dist::Mingw, dist::Rustc,\n-                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n-                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Extended, dist::HashSign),\n-            Kind::Install => into_shouldrun!(should_run, install::Docs, install::Std,\n-                install::Cargo, install::Rls, install::Analysis, install::Src, install::Rustc),\n+        for desc in Builder::get_step_descriptions(builder.kind) {\n+            should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n         for path in should_run.paths {\n@@ -240,30 +301,12 @@ impl<'a> Builder<'a> {\n             stack: RefCell::new(Vec::new()),\n         };\n \n-        let builder = &builder;\n-        match builder.kind {\n-            Kind::Build => check!(builder, paths, compile::Std, compile::Test, compile::Rustc,\n-                compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n-                tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n-                tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls),\n-            Kind::Test => check!(builder, paths, check::Tidy, check::Bootstrap, check::Compiletest,\n-                check::Crate, check::CrateLibrustc, check::Linkcheck, check::Cargotest,\n-                check::Cargo, check::Docs, check::ErrorIndex, check::Distcheck),\n-            Kind::Bench => check!(builder, paths, check::Crate, check::CrateLibrustc),\n-            Kind::Doc => builder.default_doc(Some(paths)),\n-            Kind::Dist => check!(builder, paths, dist::Docs, dist::Mingw, dist::Rustc,\n-                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n-                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Extended, dist::HashSign),\n-            Kind::Install => check!(builder, paths, install::Docs, install::Std, install::Cargo,\n-                install::Rls, install::Analysis, install::Src, install::Rustc),\n-        }\n+        StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n     }\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n         let paths = paths.unwrap_or(&[]);\n-        check!(self, paths, doc::UnstableBook, doc::UnstableBookGen, doc::TheBook, doc::Standalone,\n-            doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon, doc::Reference);\n+        StepDescription::run(&Builder::get_step_descriptions(Kind::Doc), self, paths);\n     }\n \n     /// Obtain a compiler at a given stage and for a given host. Explictly does\n@@ -514,43 +557,6 @@ impl<'a> Builder<'a> {\n         cargo\n     }\n \n-    fn maybe_run<S: Step>(&self, path: Option<&Path>) {\n-        let build = self.build;\n-        let hosts = if S::ONLY_BUILD_TARGETS || S::ONLY_BUILD {\n-            &build.config.host[..1]\n-        } else {\n-            &build.hosts\n-        };\n-\n-        // Determine the actual targets participating in this rule.\n-        // NOTE: We should keep the full projection from build triple to\n-        // the hosts for the dist steps, now that the hosts array above is\n-        // truncated to avoid duplication of work in that case. Therefore\n-        // the original non-shadowed hosts array is used below.\n-        let targets = if S::ONLY_HOSTS {\n-            // If --target was specified but --host wasn't specified,\n-            // don't run any host-only tests. Also, respect any `--host`\n-            // overrides as done for `hosts`.\n-            if build.flags.host.len() > 0 {\n-                &build.flags.host[..]\n-            } else if build.flags.target.len() > 0 {\n-                &[]\n-            } else if S::ONLY_BUILD {\n-                &build.config.host[..1]\n-            } else {\n-                &build.config.host[..]\n-            }\n-        } else {\n-            &build.targets\n-        };\n-\n-        for host in hosts {\n-            for target in targets {\n-                S::make_run(self, path, *host, *target);\n-            }\n-        }\n-    }\n-\n     /// Ensure that a given step is built, returning it's output. This will\n     /// cache the step, so it is safe (and good!) to call this as often as\n     /// needed to ensure that all dependencies are built."}]}