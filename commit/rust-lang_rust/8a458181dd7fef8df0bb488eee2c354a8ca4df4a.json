{"sha": "8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNDU4MTgxZGQ3ZmVmOGRmMGJiNDg4ZWVlMmMzNTRhOGNhNGRmNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-22T09:05:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-22T09:05:29Z"}, "message": "auto merge of #17339 : treeman/rust/doc-things, r=alexcrichton\n\nAlso some cleanup to conform to documentation style.", "tree": {"sha": "49a6c4a4b86a658a498cd2845bcedc0db2ee4264", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49a6c4a4b86a658a498cd2845bcedc0db2ee4264"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "html_url": "https://github.com/rust-lang/rust/commit/8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeda1b87ff9dd2902f6d58c83d384775b90e3734", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeda1b87ff9dd2902f6d58c83d384775b90e3734", "html_url": "https://github.com/rust-lang/rust/commit/eeda1b87ff9dd2902f6d58c83d384775b90e3734"}, {"sha": "a0d502b0ed096397b7cccde37ec7139011ce7e9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d502b0ed096397b7cccde37ec7139011ce7e9a", "html_url": "https://github.com/rust-lang/rust/commit/a0d502b0ed096397b7cccde37ec7139011ce7e9a"}], "stats": {"total": 884, "additions": 636, "deletions": 248}, "files": [{"sha": "eb8d684fe50fdf5ade87ac4073ab11768da3474e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -138,10 +138,10 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// # Example\n ///\n-/// ~~~\n+/// ```\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n-/// ~~~\n+/// ```\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }"}, {"sha": "99d9d1df522203737227de9db2c4862e4c696986", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -61,10 +61,10 @@ pub trait Zero: Add<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~text\n+    /// ```{.text}\n     /// a + 0 = a       \u2200 a \u2208 Self\n     /// 0 + a = a       \u2200 a \u2208 Self\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Purity\n     ///\n@@ -114,10 +114,10 @@ pub trait One: Mul<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~text\n+    /// ```{.text}\n     /// a * 1 = a       \u2200 a \u2208 Self\n     /// 1 * a = a       \u2200 a \u2208 Self\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Purity\n     ///"}, {"sha": "c98a2d124854b77c5fd198acff8bac15b9640866", "filename": "src/libcore/option.rs", "status": "modified", "additions": 217, "deletions": 1, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -175,6 +175,16 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `true` if the option is a `Some` value\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Option<uint> = Some(2);\n+    /// assert_eq!(x.is_some(), true);\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// assert_eq!(x.is_some(), false);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_some(&self) -> bool {\n@@ -185,6 +195,16 @@ impl<T> Option<T> {\n     }\n \n     /// Returns `true` if the option is a `None` value\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Option<uint> = Some(2);\n+    /// assert_eq!(x.is_none(), false);\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// assert_eq!(x.is_none(), true);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_none(&self) -> bool {\n@@ -218,13 +238,37 @@ impl<T> Option<T> {\n     }\n \n     /// Convert from `Option<T>` to `Option<&mut T>`\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(2u);\n+    /// match x.as_mut() {\n+    ///     Some(&ref mut v) => *v = 42,\n+    ///     None => {},\n+    /// }\n+    /// assert_eq!(x, Some(42u));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n     /// Convert from `Option<T>` to `&mut [T]` (without copying)\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(\"Diamonds\");\n+    /// {\n+    ///     let v = x.as_mut_slice();\n+    ///     assert!(v == [\"Diamonds\"]);\n+    ///     v[0] = \"Dirt\";\n+    ///     assert!(v == [\"Dirt\"]);\n+    /// }\n+    /// assert_eq!(x, Some(\"Dirt\"));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n@@ -250,6 +294,18 @@ impl<T> Option<T> {\n     ///\n     /// Fails if the value is a `None` with a custom failure message provided by\n     /// `msg`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"value\");\n+    /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n+    /// ```\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Option<&str> = None;\n+    /// x.expect(\"the world is ending\"); // fails with `world is ending`\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn expect(self, msg: &str) -> T {\n@@ -270,6 +326,18 @@ impl<T> Option<T> {\n     /// In general, because this function may fail, its use is discouraged.\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"air\");\n+    /// assert_eq!(x.unwrap(), \"air\");\n+    /// ```\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.unwrap(), \"air\"); // fails\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n@@ -280,6 +348,13 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the contained value or a default.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n+    /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, def: T) -> T {\n@@ -290,6 +365,14 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the contained value or computes it from a closure.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let k = 10u;\n+    /// assert_eq!(Some(4u).unwrap_or_else(|| 2 * k), 4u);\n+    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, f: || -> T) -> T {\n@@ -321,13 +404,35 @@ impl<T> Option<T> {\n     }\n \n     /// Applies a function to the contained value or returns a default.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"foo\");\n+    /// assert_eq!(x.map_or(42u, |v| v.len()), 3u);\n+    ///\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n     /// Applies a function to the contained value or computes a default.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let k = 21u;\n+    ///\n+    /// let x = Some(\"foo\");\n+    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3u);\n+    ///\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_or_else<U>(self, def: || -> U, f: |T| -> U) -> U {\n@@ -366,6 +471,16 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns an iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(4u);\n+    /// assert_eq!(x.iter().next(), Some(&4));\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// assert_eq!(x.iter().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n@@ -379,6 +494,20 @@ impl<T> Option<T> {\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(4u);\n+    /// match x.iter_mut().next() {\n+    ///     Some(&ref mut v) => *v = 42u,\n+    ///     None => {},\n+    /// }\n+    /// assert_eq!(x, Some(42));\n+    ///\n+    /// let mut x: Option<uint> = None;\n+    /// assert_eq!(x.iter_mut().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n@@ -392,6 +521,18 @@ impl<T> Option<T> {\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"string\");\n+    /// let v: Vec<&str> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![\"string\"]);\n+    ///\n+    /// let x = None;\n+    /// let v: Vec<&str> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![]);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn into_iter(self) -> Item<T> {\n@@ -403,6 +544,26 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `None` if the option is `None`, otherwise returns `optb`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(2u);\n+    /// let y: Option<&str> = None;\n+    /// assert_eq!(x.and(y), None);\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// let y = Some(\"foo\");\n+    /// assert_eq!(x.and(y), None);\n+    ///\n+    /// let x = Some(2u);\n+    /// let y = Some(\"foo\");\n+    /// assert_eq!(x.and(y), Some(\"foo\"));\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// let y: Option<&str> = None;\n+    /// assert_eq!(x.and(y), None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n@@ -414,6 +575,18 @@ impl<T> Option<T> {\n \n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn sq(x: uint) -> Option<uint> { Some(x * x) }\n+    /// fn nope(_: uint) -> Option<uint> { None }\n+    ///\n+    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n+    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n+    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n+    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n@@ -424,6 +597,26 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the option if it contains a value, otherwise returns `optb`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(2u);\n+    /// let y = None;\n+    /// assert_eq!(x.or(y), Some(2u));\n+    ///\n+    /// let x = None;\n+    /// let y = Some(100u);\n+    /// assert_eq!(x.or(y), Some(100u));\n+    ///\n+    /// let x = Some(2u);\n+    /// let y = Some(100u);\n+    /// assert_eq!(x.or(y), Some(2u));\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// let y = None;\n+    /// assert_eq!(x.or(y), None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n@@ -435,6 +628,17 @@ impl<T> Option<T> {\n \n     /// Returns the option if it contains a value, otherwise calls `f` and\n     /// returns the result.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn nobody() -> Option<&'static str> { None }\n+    /// fn vikings() -> Option<&'static str> { Some(\"vikings\") }\n+    ///\n+    /// assert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\n+    /// assert_eq!(None.or_else(vikings), Some(\"vikings\"));\n+    /// assert_eq!(None.or_else(nobody), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n@@ -449,6 +653,18 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Takes the value out of the option, leaving a `None` in its place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(2u);\n+    /// x.take();\n+    /// assert_eq!(x, None);\n+    ///\n+    /// let mut x: Option<uint> = None;\n+    /// x.take();\n+    /// assert_eq!(x, None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn take(&mut self) -> Option<T> {\n@@ -613,7 +829,7 @@ impl<T> Default for Option<T> {\n \n /// An `Option` iterator that yields either one or zero elements\n ///\n-/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n /// methods on `Option`.\n #[deriving(Clone)]\n #[unstable = \"waiting for iterator conventions\"]"}, {"sha": "9f347aacedc026c74a9603b8e2c91e0cf110ad6c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 254, "deletions": 54, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -15,12 +15,12 @@\n //! success and containing a value, and `Err(E)`, representing error\n //! and containing an error value.\n //!\n-//! ~~~\n+//! ```\n //! enum Result<T, E> {\n //!    Ok(T),\n //!    Err(E)\n //! }\n-//! ~~~\n+//! ```\n //!\n //! Functions return `Result` whenever errors are expected and\n //! recoverable. In the `std` crate `Result` is most prominently used\n@@ -29,7 +29,7 @@\n //! A simple function returning `Result` might be\n //! defined and used like so:\n //!\n-//! ~~~\n+//! ```\n //! #[deriving(Show)]\n //! enum Version { Version1, Version2 }\n //!\n@@ -53,13 +53,13 @@\n //!         println!(\"error parsing header: {}\", e);\n //!     }\n //! }\n-//! ~~~\n+//! ```\n //!\n //! Pattern matching on `Result`s is clear and straightforward for\n //! simple cases, but `Result` comes with some convenience methods\n //! that make working it more succinct.\n //!\n-//! ~~~\n+//! ```\n //! let good_result: Result<int, int> = Ok(10);\n //! let bad_result: Result<int, int> = Err(10);\n //!\n@@ -79,7 +79,7 @@\n //!\n //! // Consume the result and return the contents with `unwrap`.\n //! let final_awesome_result = good_result.ok().unwrap();\n-//! ~~~\n+//! ```\n //!\n //! # Results must be used\n //!\n@@ -94,13 +94,13 @@\n //! Consider the `write_line` method defined for I/O types\n //! by the [`Writer`](../io/trait.Writer.html) trait:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::IoError;\n //!\n //! trait Writer {\n //!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n //! }\n-//! ~~~\n+//! ```\n //!\n //! *Note: The actual definition of `Writer` uses `IoResult`, which\n //! is just a synonym for `Result<T, IoError>`.*\n@@ -109,15 +109,15 @@\n //! fail. It's crucial to handle the error case, and *not* write\n //! something like this:\n //!\n-//! ~~~ignore\n+//! ```{.ignore}\n //! use std::io::{File, Open, Write};\n //!\n //! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! // If `write_line` errors, then we'll never know, because the return\n //! // value is ignored.\n //! file.write_line(\"important message\");\n //! drop(file);\n-//! ~~~\n+//! ```\n //!\n //! If you *do* write that in Rust, the compiler will by give you a\n //! warning (by default, controlled by the `unused_must_use` lint).\n@@ -127,35 +127,35 @@\n //! success with `expect`. This will fail if the write fails, proving\n //! a marginally useful message indicating why:\n //!\n-//! ~~~no_run\n+//! ```{.no_run}\n //! use std::io::{File, Open, Write};\n //!\n //! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n //! drop(file);\n-//! ~~~\n+//! ```\n //!\n //! You might also simply assert success:\n //!\n-//! ~~~no_run\n+//! ```{.no_run}\n //! # use std::io::{File, Open, Write};\n //!\n //! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! assert!(file.write_line(\"important message\").is_ok());\n //! # drop(file);\n-//! ~~~\n+//! ```\n //!\n //! Or propagate the error up the call stack with `try!`:\n //!\n-//! ~~~\n+//! ```\n //! # use std::io::{File, Open, Write, IoError};\n //! fn write_message() -> Result<(), IoError> {\n //!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //!     try!(file.write_line(\"important message\"));\n //!     drop(file);\n //!     return Ok(());\n //! }\n-//! ~~~\n+//! ```\n //!\n //! # The `try!` macro\n //!\n@@ -166,7 +166,7 @@\n //!\n //! It replaces this:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n@@ -188,11 +188,11 @@\n //!     }\n //!     return file.write_line(format!(\"rating: {}\", info.rating).as_slice());\n //! }\n-//! ~~~\n+//! ```\n //!\n //! With this:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n@@ -209,7 +209,7 @@\n //!     try!(file.write_line(format!(\"rating: {}\", info.rating).as_slice()));\n //!     return Ok(());\n //! }\n-//! ~~~\n+//! ```\n //!\n //! *It's much nicer!*\n //!\n@@ -218,13 +218,13 @@\n //! `Err` is returned early from the enclosing function. Its simple definition\n //! makes it clear:\n //!\n-//! ~~~\n+//! ```\n //! # #![feature(macro_rules)]\n //! macro_rules! try(\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n //! )\n //! # fn main() { }\n-//! ~~~\n+//! ```\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n //!\n@@ -245,10 +245,10 @@\n //!\n //! Converting to an `Option` with `ok()` to handle an error:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::Timer;\n //! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n-//! ~~~\n+//! ```\n //!\n //! # `Result` vs. `fail!`\n //!\n@@ -311,14 +311,13 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~\n-    /// use std::io::{File, Open, Write};\n+    /// ```\n+    /// let x: Result<int, &str> = Ok(-3);\n+    /// assert_eq!(x.is_ok(), true);\n     ///\n-    /// # fn do_not_run_example() { // creates a file\n-    /// let mut file = File::open_mode(&Path::new(\"secret.txt\"), Open, Write);\n-    /// assert!(file.write_line(\"it's cold in here\").is_ok());\n-    /// # }\n-    /// ~~~\n+    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// assert_eq!(x.is_ok(), false);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_ok(&self) -> bool {\n@@ -332,14 +331,13 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~\n-    /// use std::io::{File, Open, Read};\n+    /// ```\n+    /// let x: Result<int, &str> = Ok(-3);\n+    /// assert_eq!(x.is_err(), false);\n     ///\n-    /// // When opening with `Read` access, if the file does not exist\n-    /// // then `open_mode` returns an error.\n-    /// let bogus = File::open_mode(&Path::new(\"not_a_file.txt\"), Open, Read);\n-    /// assert!(bogus.is_err());\n-    /// ~~~\n+    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// assert_eq!(x.is_err(), true);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_err(&self) -> bool {\n@@ -356,18 +354,15 @@ impl<T, E> Result<T, E> {\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the error, if any.\n     ///\n-    /// To convert to an `Option` without discarding the error value,\n-    /// use `as_ref` to first convert the `Result<T, E>` into a\n-    /// `Result<&T, &E>`.\n-    ///\n-    /// # Examples\n+    /// # Example\n     ///\n-    /// ~~~{.should_fail}\n-    /// use std::io::{File, IoResult};\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.ok(), Some(2));\n     ///\n-    /// let bdays: IoResult<File> = File::open(&Path::new(\"important_birthdays.txt\"));\n-    /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n-    /// ~~~\n+    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// assert_eq!(x.ok(), None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn ok(self) -> Option<T> {\n@@ -381,6 +376,16 @@ impl<T, E> Result<T, E> {\n     ///\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the value, if any.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.err(), None);\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// assert_eq!(x.err(), Some(\"Nothing here\"));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn err(self) -> Option<E> {\n@@ -398,6 +403,14 @@ impl<T, E> Result<T, E> {\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.as_ref(), Ok(&2));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"Error\");\n+    /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n@@ -408,6 +421,23 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n+    ///\n+    /// ```\n+    /// fn mutate(r: &mut Result<int, int>) {\n+    ///     match r.as_mut() {\n+    ///         Ok(&ref mut v) => *v = 42,\n+    ///         Err(&ref mut e) => *e = 0,\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut x: Result<int, int> = Ok(2);\n+    /// mutate(&mut x);\n+    /// assert_eq!(x.unwrap(), 42);\n+    ///\n+    /// let mut x: Result<int, int> = Err(13);\n+    /// mutate(&mut x);\n+    /// assert_eq!(x.unwrap_err(), 0);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n@@ -418,6 +448,20 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n+    ///\n+    /// ```\n+    /// let mut x: Result<&str, uint> = Ok(\"Gold\");\n+    /// {\n+    ///     let v = x.as_mut_slice();\n+    ///     assert!(v == [\"Gold\"]);\n+    ///     v[0] = \"Silver\";\n+    ///     assert!(v == [\"Silver\"]);\n+    /// }\n+    /// assert_eq!(x, Ok(\"Silver\"));\n+    ///\n+    /// let mut x: Result<&str, uint> = Err(45);\n+    /// assert!(x.as_mut_slice() == []);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n@@ -440,12 +484,12 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used to compose the results of two functions.\n     ///\n-    /// # Examples\n+    /// # Example\n     ///\n     /// Sum the lines of a buffer by mapping strings to numbers,\n     /// ignoring I/O and parse errors:\n     ///\n-    /// ~~~\n+    /// ```\n     /// use std::io::{BufReader, IoResult};\n     ///\n     /// let buffer = \"1\\n2\\n3\\n4\\n\";\n@@ -464,7 +508,7 @@ impl<T, E> Result<T, E> {\n     /// }\n     ///\n     /// assert!(sum == 10);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n@@ -479,6 +523,18 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn stringify(x: uint) -> String { format!(\"error code: {}\", x) }\n+    ///\n+    /// let x: Result<uint, uint> = Ok(2u);\n+    /// assert_eq!(x.map_err(stringify), Ok(2u));\n+    ///\n+    /// let x: Result<uint, uint> = Err(13);\n+    /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n@@ -494,6 +550,16 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns an iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(7);\n+    /// assert_eq!(x.iter().next(), Some(&7));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"nothing!\");\n+    /// assert_eq!(x.iter().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n@@ -507,6 +573,20 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x: Result<uint, &str> = Ok(7);\n+    /// match x.iter_mut().next() {\n+    ///     Some(&ref mut x) => *x = 40,\n+    ///     None => {},\n+    /// }\n+    /// assert_eq!(x, Ok(40));\n+    ///\n+    /// let mut x: Result<uint, &str> = Err(\"nothing!\");\n+    /// assert_eq!(x.iter_mut().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n@@ -520,6 +600,18 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(5);\n+    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![5u]);\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"nothing!\");\n+    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![]);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn into_iter(self) -> Item<T> {\n@@ -531,6 +623,26 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"early error\");\n+    /// let y: Result<&str, &str> = Ok(\"foo\");\n+    /// assert_eq!(x.and(y), Err(\"early error\"));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"not a 2\");\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n+    ///\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Ok(\"different result type\");\n+    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n@@ -542,7 +654,19 @@ impl<T, E> Result<T, E> {\n \n     /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     ///\n-    /// This function can be used for control flow based on result values\n+    /// This function can be used for control flow based on result values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n+    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n+    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n+    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n@@ -553,6 +677,26 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"early error\");\n+    /// let y: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"not a 2\");\n+    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<uint, &str> = Ok(100);\n+    /// assert_eq!(x.or(y), Ok(2));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n@@ -564,7 +708,19 @@ impl<T, E> Result<T, E> {\n \n     /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n     ///\n-    /// This function can be used for control flow based on result values\n+    /// This function can be used for control flow based on result values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n+    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n+    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n+    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n+    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n@@ -576,6 +732,17 @@ impl<T, E> Result<T, E> {\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// Else it returns `optb`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let optb = 2u;\n+    /// let x: Result<uint, &str> = Ok(9u);\n+    /// assert_eq!(x.unwrap_or(optb), 9u);\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"error\");\n+    /// assert_eq!(x.unwrap_or(optb), optb);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, optb: T) -> T {\n@@ -587,6 +754,15 @@ impl<T, E> Result<T, E> {\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// If the value is an `Err` then it calls `op` with its value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn count(x: &str) -> uint { x.len() }\n+    ///\n+    /// assert_eq!(Ok(2u).unwrap_or_else(count), 2u);\n+    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, op: |E| -> T) -> T {\n@@ -611,6 +787,18 @@ impl<T, E: Show> Result<T, E> {\n     ///\n     /// Fails if the value is an `Err`, with a custom failure message provided\n     /// by the `Err`'s value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2u);\n+    /// assert_eq!(x.unwrap(), 2u);\n+    /// ```\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// x.unwrap(); // fails with `emergency failure`\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n@@ -629,6 +817,18 @@ impl<T: Show, E> Result<T, E> {\n     ///\n     /// Fails if the value is an `Ok`, with a custom failure message provided\n     /// by the `Ok`'s value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Result<uint, &str> = Ok(2u);\n+    /// x.unwrap_err(); // fails with `2`\n+    /// ```\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_err(self) -> E {\n@@ -666,7 +866,7 @@ impl<T, E> Slice<T> for Result<T, E> {\n \n /// A `Result` iterator that yields either one or zero elements\n ///\n-/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n /// methods on `Result`.\n #[deriving(Clone)]\n #[unstable = \"waiting for iterator conventions\"]"}, {"sha": "f95ecb412d177ea8bd53454e9ee1ab029468dcc3", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -31,7 +31,7 @@\n //! that requires an input file to be specified, accepts an optional output\n //! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n //!\n-//! ~~~{.rust}\n+//! ```{.rust}\n //! extern crate getopts;\n //! use getopts::{optopt,optflag,getopts,OptGroup};\n //! use std::os;\n@@ -76,7 +76,7 @@\n //!     };\n //!     do_work(input.as_slice(), output);\n //! }\n-//! ~~~\n+//! ```\n \n #![crate_name = \"getopts\"]\n #![experimental]"}, {"sha": "f5ac5831ea5e32c182fb59a8859634e9ee363970", "filename": "src/libnum/integer.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -17,7 +17,7 @@ pub trait Integer: Num + PartialOrd\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert!(( 8i).div_floor(& 3) ==  2);\n     /// assert!(( 8i).div_floor(&-3) == -3);\n@@ -28,20 +28,20 @@ pub trait Integer: Num + PartialOrd\n     /// assert!(( 1i).div_floor(&-2) == -1);\n     /// assert!((-1i).div_floor(& 2) == -1);\n     /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ~~~\n+    /// ```\n     fn div_floor(&self, other: &Self) -> Self;\n \n     /// Floored integer modulo, satisfying:\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// # let n = 1i; let d = 1i;\n     /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert!(( 8i).mod_floor(& 3) ==  2);\n     /// assert!(( 8i).mod_floor(&-3) == -1);\n@@ -52,29 +52,29 @@ pub trait Integer: Num + PartialOrd\n     /// assert!(( 1i).mod_floor(&-2) == -1);\n     /// assert!((-1i).mod_floor(& 2) ==  1);\n     /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ~~~\n+    /// ```\n     fn mod_floor(&self, other: &Self) -> Self;\n \n     /// Greatest Common Divisor (GCD).\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(6i.gcd(&8), 2);\n     /// assert_eq!(7i.gcd(&3), 1);\n-    /// ~~~\n+    /// ```\n     fn gcd(&self, other: &Self) -> Self;\n \n     /// Lowest Common Multiple (LCM).\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(7i.lcm(&3), 21);\n     /// assert_eq!(2i.lcm(&4), 4);\n-    /// ~~~\n+    /// ```\n     fn lcm(&self, other: &Self) -> Self;\n \n     /// Deprecated, use `is_multiple_of` instead.\n@@ -85,41 +85,41 @@ pub trait Integer: Num + PartialOrd\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(9i.is_multiple_of(&3), true);\n     /// assert_eq!(3i.is_multiple_of(&9), false);\n-    /// ~~~\n+    /// ```\n     fn is_multiple_of(&self, other: &Self) -> bool;\n \n     /// Returns `true` if the number is even.\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(3i.is_even(), false);\n     /// assert_eq!(4i.is_even(), true);\n-    /// ~~~\n+    /// ```\n     fn is_even(&self) -> bool;\n \n     /// Returns `true` if the number is odd.\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(3i.is_odd(), true);\n     /// assert_eq!(4i.is_odd(), false);\n-    /// ~~~\n+    /// ```\n     fn is_odd(&self) -> bool;\n \n     /// Simultaneous truncated integer division and modulus.\n     /// Returns `(quotient, remainder)`.\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(( 8i).div_rem( &3), ( 2,  2));\n     /// assert_eq!(( 8i).div_rem(&-3), (-2,  2));\n@@ -130,7 +130,7 @@ pub trait Integer: Num + PartialOrd\n     /// assert_eq!(( 1i).div_rem(&-2), ( 0,  1));\n     /// assert_eq!((-1i).div_rem( &2), ( 0, -1));\n     /// assert_eq!((-1i).div_rem(&-2), ( 0, -1));\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn div_rem(&self, other: &Self) -> (Self, Self) {\n         (*self / *other, *self % *other)\n@@ -141,7 +141,7 @@ pub trait Integer: Num + PartialOrd\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(( 8i).div_mod_floor( &3), ( 2,  2));\n     /// assert_eq!(( 8i).div_mod_floor(&-3), (-3, -1));\n@@ -152,7 +152,7 @@ pub trait Integer: Num + PartialOrd\n     /// assert_eq!(( 1i).div_mod_floor(&-2), (-1, -1));\n     /// assert_eq!((-1i).div_mod_floor( &2), (-1,  1));\n     /// assert_eq!((-1i).div_mod_floor(&-2), ( 0, -1));\n-    /// ~~~\n+    /// ```\n     fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n         (self.div_floor(other), self.mod_floor(other))\n     }"}, {"sha": "7855748fc6489cc094a81e3c679f2c1e270bf8c5", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -21,7 +21,7 @@\n ///\n /// # Example\n ///\n-/// ~~~rust\n+/// ```{.rust}\n /// bitflags! {\n ///     flags Flags: u32 {\n ///         static FlagA       = 0x00000001,\n@@ -41,11 +41,11 @@\n ///     assert!((e1 - e2) == FlagA);     // set difference\n ///     assert!(!e2 == FlagA);           // set complement\n /// }\n-/// ~~~\n+/// ```\n ///\n /// The generated `struct`s can also be extended with type and trait implementations:\n ///\n-/// ~~~rust\n+/// ```{.rust}\n /// use std::fmt;\n ///\n /// bitflags! {\n@@ -74,7 +74,7 @@\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n /// }\n-/// ~~~\n+/// ```\n ///\n /// # Attributes\n ///"}, {"sha": "d949a03dfc140ae9282405ad782f8b70f8cc464d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -192,7 +192,7 @@ macro_rules! debug_assert_eq(\n ///\n /// # Example\n ///\n-/// ~~~rust\n+/// ```{.rust}\n /// struct Item { weight: uint }\n ///\n /// fn choose_weighted_item(v: &[Item]) -> Item {\n@@ -208,7 +208,7 @@ macro_rules! debug_assert_eq(\n ///     // type checker that it isn't possible to get down here\n ///     unreachable!();\n /// }\n-/// ~~~\n+/// ```\n #[macro_export]\n macro_rules! unreachable(\n     () => (fail!(\"internal error: entered unreachable code\"))"}, {"sha": "10c045b811ae395ec1e404bc45369faa680b5f9d", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 129, "deletions": 156, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -101,61 +101,61 @@\n //!\n //! When generating the `expr` for the `A` impl, the `SubstructureFields` is\n //!\n-//! ~~~text\n+//! ```{.text}\n //! Struct(~[FieldInfo {\n //!            span: <span of x>\n //!            name: Some(<ident of x>),\n //!            self_: <expr for &self.x>,\n //!            other: ~[<expr for &other.x]\n //!          }])\n-//! ~~~\n+//! ```\n //!\n //! For the `B` impl, called with `B(a)` and `B(b)`,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! Struct(~[FieldInfo {\n //!           span: <span of `int`>,\n //!           name: None,\n //!           <expr for &a>\n //!           ~[<expr for &b>]\n //!          }])\n-//! ~~~\n+//! ```\n //!\n //! ## Enums\n //!\n //! When generating the `expr` for a call with `self == C0(a)` and `other\n //! == C0(b)`, the SubstructureFields is\n //!\n-//! ~~~text\n+//! ```{.text}\n //! EnumMatching(0, <ast::Variant for C0>,\n //!              ~[FieldInfo {\n //!                 span: <span of int>\n //!                 name: None,\n //!                 self_: <expr for &a>,\n //!                 other: ~[<expr for &b>]\n //!               }])\n-//! ~~~\n+//! ```\n //!\n //! For `C1 {x}` and `C1 {x}`,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! EnumMatching(1, <ast::Variant for C1>,\n //!              ~[FieldInfo {\n //!                 span: <span of x>\n //!                 name: Some(<ident of x>),\n //!                 self_: <expr for &self.x>,\n //!                 other: ~[<expr for &other.x>]\n //!                }])\n-//! ~~~\n+//! ```\n //!\n //! For `C0(a)` and `C1 {x}` ,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! EnumNonMatchingCollapsed(\n //!     ~[<ident of self>, <ident of __arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n //!     &[<ident for self index value>, <ident of __arg_1 index value>])\n-//! ~~~\n+//! ```\n //!\n //! It is the same for when the arguments are flipped to `C1 {x}` and\n //! `C0(a)`; the only difference is what the values of the identifiers\n@@ -170,15 +170,15 @@\n //!\n //! A static method on the above would result in,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n //!\n //! StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n //!\n //! StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span of int>])),\n //!                                   (<ident of C1>, <span of C1>,\n //!                                    Named(~[(<ident of x>, <span of x>)]))])\n-//! ~~~\n+//! ```\n \n use std::cell::RefCell;\n use std::vec;\n@@ -252,7 +252,7 @@ pub struct Substructure<'a> {\n     pub type_ident: Ident,\n     /// ident of the method\n     pub method_ident: Ident,\n-    /// dereferenced access to any Self or Ptr(Self, _) arguments\n+    /// dereferenced access to any `Self` or `Ptr(Self, _)` arguments\n     pub self_args: &'a [P<Expr>],\n     /// verbatim access to any other arguments\n     pub nonself_args: &'a [P<Expr>],\n@@ -269,61 +269,52 @@ pub struct FieldInfo {\n     /// (specifically, a reference to it).\n     pub self_: P<Expr>,\n     /// The expressions corresponding to references to this field in\n-    /// the other Self arguments.\n+    /// the other `Self` arguments.\n     pub other: Vec<P<Expr>>,\n }\n \n /// Fields for a static method\n pub enum StaticFields {\n-    /// Tuple structs/enum variants like this\n+    /// Tuple structs/enum variants like this.\n     Unnamed(Vec<Span>),\n     /// Normal structs/struct variants.\n     Named(Vec<(Ident, Span)>),\n }\n \n-/// A summary of the possible sets of fields. See above for details\n-/// and examples\n+/// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n     Struct(Vec<FieldInfo>),\n-    /**\n-    Matching variants of the enum: variant index, ast::Variant,\n-    fields: the field name is only non-`None` in the case of a struct\n-    variant.\n-    */\n+    /// Matching variants of the enum: variant index, ast::Variant,\n+    /// fields: the field name is only non-`None` in the case of a struct\n+    /// variant.\n     EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n \n-    /**\n-    non-matching variants of the enum, but with all state hidden from\n-    the consequent code.  The first component holds Idents for all of\n-    the Self arguments; the second component is a slice of all of the\n-    variants for the enum itself, and the third component is a list of\n-    Idents bound to the variant index values for each of the actual\n-    input Self arguments.\n-    */\n+    /// Non-matching variants of the enum, but with all state hidden from\n+    /// the consequent code.  The first component holds `Ident`s for all of\n+    /// the `Self` arguments; the second component is a slice of all of the\n+    /// variants for the enum itself, and the third component is a list of\n+    /// `Ident`s bound to the variant index values for each of the actual\n+    /// input `Self` arguments.\n     EnumNonMatchingCollapsed(Vec<Ident>, &'a [P<ast::Variant>], &'a [Ident]),\n \n-    /// A static method where Self is a struct.\n+    /// A static method where `Self` is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n-    /// A static method where Self is an enum.\n+    /// A static method where `Self` is an enum.\n     StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)>),\n }\n \n \n \n-/**\n-Combine the values of all the fields together. The last argument is\n-all the fields of all the structures, see above for details.\n-*/\n+/// Combine the values of all the fields together. The last argument is\n+/// all the fields of all the structures.\n pub type CombineSubstructureFunc<'a> =\n     |&mut ExtCtxt, Span, &Substructure|: 'a -> P<Expr>;\n \n-/**\n-Deal with non-matching enum variants.  The tuple is a list of\n-identifiers (one for each Self argument, which could be any of the\n-variants since they have been collapsed together) and the identifiers\n-holding the variant index value for each of the Self arguments.  The\n-last argument is all the non-Self args of the method being derived.\n-*/\n+/// Deal with non-matching enum variants.  The tuple is a list of\n+/// identifiers (one for each `Self` argument, which could be any of the\n+/// variants since they have been collapsed together) and the identifiers\n+/// holding the variant index value for each of the `Self` arguments.  The\n+/// last argument is all the non-`Self` args of the method being derived.\n pub type EnumNonMatchCollapsedFunc<'a> =\n     |&mut ExtCtxt,\n      Span,\n@@ -373,18 +364,14 @@ impl<'a> TraitDef<'a> {\n         }))\n     }\n \n-    /**\n-     *\n-     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n-     * 'z, A, ..., Z>`, creates an impl like:\n-     *\n-     * ```ignore\n-     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n-     * ```\n-     *\n-     * where B1, B2, ... are the bounds given by `bounds_paths`.'\n-     *\n-     */\n+    /// Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+    /// 'z, A, ..., Z>`, creates an impl like:\n+    ///\n+    /// ```ignore\n+    /// impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+    /// ```\n+    ///\n+    /// where B1, B2, ... are the bounds given by `bounds_paths`.'\n     fn create_derived_impl(&self,\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n@@ -693,27 +680,25 @@ impl<'a> MethodDef<'a> {\n         })\n     }\n \n-    /**\n-   ~~~\n-    #[deriving(PartialEq)]\n-    struct A { x: int, y: int }\n-\n-    // equivalent to:\n-    impl PartialEq for A {\n-        fn eq(&self, __arg_1: &A) -> bool {\n-            match *self {\n-                A {x: ref __self_0_0, y: ref __self_0_1} => {\n-                    match *__arg_1 {\n-                        A {x: ref __self_1_0, y: ref __self_1_1} => {\n-                            __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-   ~~~\n-    */\n+    /// ```\n+    /// #[deriving(PartialEq)]\n+    /// struct A { x: int, y: int }\n+    ///\n+    /// // equivalent to:\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///         match *self {\n+    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n+    ///                 match *__arg_1 {\n+    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n+    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n+    ///                     }\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     fn expand_struct_method_body(&self,\n                                  cx: &mut ExtCtxt,\n                                  trait_: &TraitDef,\n@@ -798,37 +783,35 @@ impl<'a> MethodDef<'a> {\n                                       &StaticStruct(struct_def, summary))\n     }\n \n-    /**\n-   ~~~\n-    #[deriving(PartialEq)]\n-    enum A {\n-        A1,\n-        A2(int)\n-    }\n-\n-    // is equivalent to\n-\n-    impl PartialEq for A {\n-        fn eq(&self, __arg_1: &A) -> ::bool {\n-            match (&*self, &*__arg_1) {\n-                (&A1, &A1) => true,\n-                (&A2(ref __self_0),\n-                 &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n-                _ => {\n-                    let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n-                    let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n-                    false\n-                }\n-            }\n-        }\n-    }\n-   ~~~\n-\n-    (Of course `__self_vi` and `__arg_1_vi` are unused for\n-     `PartialEq`, and those subcomputations will hopefully be removed\n-     as their results are unused.  The point of `__self_vi` and\n-     `__arg_1_vi` is for `PartialOrd`; see #15503.)\n-    */\n+    /// ```\n+    /// #[deriving(PartialEq)]\n+    /// enum A {\n+    ///     A1,\n+    ///     A2(int)\n+    /// }\n+    ///\n+    /// // is equivalent to\n+    ///\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, __arg_1: &A) -> ::bool {\n+    ///         match (&*self, &*__arg_1) {\n+    ///             (&A1, &A1) => true,\n+    ///             (&A2(ref __self_0),\n+    ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n+    ///             _ => {\n+    ///                 let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n+    ///                 false\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n+    /// `PartialEq`, and those subcomputations will hopefully be removed\n+    /// as their results are unused.  The point of `__self_vi` and\n+    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body(&self,\n                                cx: &mut ExtCtxt,\n                                trait_: &TraitDef,\n@@ -842,33 +825,31 @@ impl<'a> MethodDef<'a> {\n     }\n \n \n-    /**\n-    Creates a match for a tuple of all `self_args`, where either all\n-    variants match, or it falls into a catch-all for when one variant\n-    does not match.\n-\n-    There are N + 1 cases because is a case for each of the N\n-    variants where all of the variants match, and one catch-all for\n-    when one does not match.\n-\n-    The catch-all handler is provided access the variant index values\n-    for each of the self-args, carried in precomputed variables. (Nota\n-    bene: the variant index values are not necessarily the\n-    discriminant values.  See issue #15523.)\n-\n-    ~~~text\n-    match (this, that, ...) {\n-      (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n-      (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n-      ...\n-      _ => {\n-        let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n-        let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n-        ... // catch-all remainder can inspect above variant index values.\n-      }\n-    }\n-    ~~~\n-    */\n+    /// Creates a match for a tuple of all `self_args`, where either all\n+    /// variants match, or it falls into a catch-all for when one variant\n+    /// does not match.\n+\n+    /// There are N + 1 cases because is a case for each of the N\n+    /// variants where all of the variants match, and one catch-all for\n+    /// when one does not match.\n+\n+    /// The catch-all handler is provided access the variant index values\n+    /// for each of the self-args, carried in precomputed variables. (Nota\n+    /// bene: the variant index values are not necessarily the\n+    /// discriminant values.  See issue #15523.)\n+\n+    /// ```{.text}\n+    /// match (this, that, ...) {\n+    ///   (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n+    ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n+    ///   ...\n+    ///   _ => {\n+    ///     let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n+    ///     let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n+    ///     ... // catch-all remainder can inspect above variant index values.\n+    ///   }\n+    /// }\n+    /// ```\n     fn build_enum_match_tuple(\n         &self,\n         cx: &mut ExtCtxt,\n@@ -1319,10 +1300,8 @@ impl<'a> TraitDef<'a> {\n \n /* helpful premade recipes */\n \n-/**\n-Fold the fields. `use_foldl` controls whether this is done\n-left-to-right (`true`) or right-to-left (`false`).\n-*/\n+/// Fold the fields. `use_foldl` controls whether this is done\n+/// left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold(use_foldl: bool,\n                f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]| -> P<Expr>,\n                base: P<Expr>,\n@@ -1361,15 +1340,13 @@ pub fn cs_fold(use_foldl: bool,\n }\n \n \n-/**\n-Call the method that is being derived on all the fields, and then\n-process the collected results. i.e.\n-\n-~~~\n-f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n-              self_2.method(__arg_1_2, __arg_2_2)])\n-~~~\n-*/\n+/// Call the method that is being derived on all the fields, and then\n+/// process the collected results. i.e.\n+///\n+/// ```\n+/// f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n+///              self_2.method(__arg_1_2, __arg_2_2)])\n+/// ```\n #[inline]\n pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n                       enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n@@ -1400,11 +1377,9 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n     }\n }\n \n-/**\n-Fold together the results of calling the derived method on all the\n-fields. `use_foldl` controls whether this is done left-to-right\n-(`true`) or right-to-left (`false`).\n-*/\n+/// Fold together the results of calling the derived method on all the\n+/// fields. `use_foldl` controls whether this is done left-to-right\n+/// (`true`) or right-to-left (`false`).\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>| -> P<Expr>,\n@@ -1430,10 +1405,8 @@ pub fn cs_same_method_fold(use_foldl: bool,\n         cx, trait_span, substructure)\n }\n \n-/**\n-Use a given binop to combine the result of calling the derived method\n-on all the fields.\n-*/\n+/// Use a given binop to combine the result of calling the derived method\n+/// on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: P<Expr>,\n                 enum_nonmatch_f: EnumNonMatchCollapsedFunc,"}, {"sha": "854bf7f5a42e67783ec9e6d41b197e068a4d576f", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a458181dd7fef8df0bb488eee2c354a8ca4df4a/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=8a458181dd7fef8df0bb488eee2c354a8ca4df4a", "patch": "@@ -352,10 +352,9 @@ pub fn write_5_number_summary<T: Float + Show>(w: &mut io::Writer,\n /// As an example, the summary with 5-number-summary `(min=15, q1=17, med=20, q3=24, max=31)` might\n /// display as:\n ///\n-/// ~~~~ignore\n+/// ```{.ignore}\n ///   10 |        [--****#******----------]          | 40\n-/// ~~~~\n-\n+/// ```\n pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n                      w: &mut io::Writer,\n                      s: &Summary<T>,"}]}