{"sha": "f9e67d692d915b326bd20a4c487039ade377029b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZTY3ZDY5MmQ5MTViMzI2YmQyMGE0YzQ4NzAzOWFkZTM3NzAyOWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-12T14:40:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-12T14:40:28Z"}, "message": "Merge #9230\n\n9230: internal: move inference diagnostics to hir r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "649f0226ded68ee7883b66ebfbbfcc371d1fba74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/649f0226ded68ee7883b66ebfbbfcc371d1fba74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9e67d692d915b326bd20a4c487039ade377029b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxMdcCRBK7hj4Ov3rIwAAShkIACH/MGv6tqNCpDghqn77/d7h\nv5E3Kd8Rh0h2LzaTgff51QaVKTE2aFc/JPT1F+cYjt83YY5N9yNk49CvVJP926ZC\n8zQr4DqGo9chl63Ae4syfL97aYYmjHRYHurhbCK9QATebcGpwJxnQiJzXZ8FWCGI\nlt2LIJF/zTXYzPif7CoQVU8wm2rnBlZp7bgPM1R2v+crr5gqoZ/p4fZPHJYjzBta\nIPkt7tbTATyXZuSrcsRxUGZMYulHTxS3wD/bqWdKwgRsOIDUt4Y/F8hnt9QYl4pG\n7VhvUZ7zzJdoH+WoQ3/aRfz1DBKMgfkba2SHJF4lMhH7ECI7P8KATytZVNdzEhc=\n=N8DB\n-----END PGP SIGNATURE-----\n", "payload": "tree 649f0226ded68ee7883b66ebfbbfcc371d1fba74\nparent c1c2c92e47d1db2386f40c446c5a5122912048a7\nparent 0413d51317a2470c94f82d93e66a3d009fce41a3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623508828 +0000\ncommitter GitHub <noreply@github.com> 1623508828 +0000\n\nMerge #9230\n\n9230: internal: move inference diagnostics to hir r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e67d692d915b326bd20a4c487039ade377029b", "html_url": "https://github.com/rust-lang/rust/commit/f9e67d692d915b326bd20a4c487039ade377029b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9e67d692d915b326bd20a4c487039ade377029b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1c2c92e47d1db2386f40c446c5a5122912048a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c2c92e47d1db2386f40c446c5a5122912048a7", "html_url": "https://github.com/rust-lang/rust/commit/c1c2c92e47d1db2386f40c446c5a5122912048a7"}, {"sha": "0413d51317a2470c94f82d93e66a3d009fce41a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0413d51317a2470c94f82d93e66a3d009fce41a3", "html_url": "https://github.com/rust-lang/rust/commit/0413d51317a2470c94f82d93e66a3d009fce41a3"}], "stats": {"total": 767, "additions": 362, "deletions": 405}, "files": [{"sha": "e888fc23b50f85ff3011d8b0b62982fac708d5f9", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -14,8 +14,7 @@ use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n pub use hir_ty::{\n     diagnostics::{\n         IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingOkOrSomeInTailExpr, NoSuchField, RemoveThisSemicolon,\n-        ReplaceFilterMapNextWithFindMap,\n+        MissingOkOrSomeInTailExpr, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n     },\n     diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder},\n };\n@@ -251,3 +250,78 @@ impl Diagnostic for UnimplementedBuiltinMacro {\n         self\n     }\n }\n+\n+// Diagnostic: no-such-field\n+//\n+// This diagnostic is triggered if created structure does not have field provided in record.\n+#[derive(Debug)]\n+pub struct NoSuchField {\n+    pub file: HirFileId,\n+    pub field: AstPtr<ast::RecordExprField>,\n+}\n+\n+impl Diagnostic for NoSuchField {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"no-such-field\")\n+    }\n+\n+    fn message(&self) -> String {\n+        \"no such field\".to_string()\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.field.clone().into())\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: break-outside-of-loop\n+//\n+// This diagnostic is triggered if the `break` keyword is used outside of a loop.\n+#[derive(Debug)]\n+pub struct BreakOutsideOfLoop {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for BreakOutsideOfLoop {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"break-outside-of-loop\")\n+    }\n+    fn message(&self) -> String {\n+        \"break outside of loop\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: missing-unsafe\n+//\n+// This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n+#[derive(Debug)]\n+pub struct MissingUnsafe {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for MissingUnsafe {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-unsafe\")\n+    }\n+    fn message(&self) -> String {\n+        format!(\"This operation is unsafe and requires an unsafe function or block\")\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "a21a9da21f9cbb39e153819522bab95987eeed20", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -36,13 +36,14 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n use diagnostics::{\n-    InactiveCode, MacroError, UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport,\n-    UnresolvedMacroCall, UnresolvedModule, UnresolvedProcMacro,\n+    BreakOutsideOfLoop, InactiveCode, MacroError, MissingUnsafe, NoSuchField,\n+    UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+    UnresolvedModule, UnresolvedProcMacro,\n };\n use either::Either;\n use hir_def::{\n     adt::{ReprKind, VariantData},\n-    body::BodyDiagnostic,\n+    body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n@@ -1042,6 +1043,35 @@ impl Function {\n             }\n         }\n \n+        let infer = db.infer(self.id.into());\n+        let (_, source_map) = db.body_with_source_map(self.id.into());\n+        for d in &infer.diagnostics {\n+            match d {\n+                hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n+                    let field = source_map.field_syntax(*expr);\n+                    sink.push(NoSuchField { file: field.file_id, field: field.value })\n+                }\n+                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                    let ptr = source_map\n+                        .expr_syntax(*expr)\n+                        .expect(\"break outside of loop in synthetic syntax\");\n+                    sink.push(BreakOutsideOfLoop { file: ptr.file_id, expr: ptr.value })\n+                }\n+            }\n+        }\n+\n+        for expr in hir_ty::diagnostics::missing_unsafe(db, self.id.into()) {\n+            match source_map.as_ref().expr_syntax(expr) {\n+                Ok(in_file) => {\n+                    sink.push(MissingUnsafe { file: in_file.file_id, expr: in_file.value })\n+                }\n+                Err(SyntheticSyntax) => {\n+                    // FIXME: The `expr` was desugared, report or assert that\n+                    // this dosen't happen.\n+                }\n+            }\n+        }\n+\n         hir_ty::diagnostics::validate_module_item(db, krate, self.id.into(), sink);\n         hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n     }"}, {"sha": "12131d9bc0136d9179066b8b4e7067f9ed99818b", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 212, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -17,7 +17,10 @@ use crate::{\n     diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink},\n };\n \n-pub use crate::diagnostics::expr::{record_literal_missing_fields, record_pattern_missing_fields};\n+pub use crate::diagnostics::{\n+    expr::{record_literal_missing_fields, record_pattern_missing_fields},\n+    unsafe_check::missing_unsafe,\n+};\n \n pub fn validate_module_item(\n     db: &dyn HirDatabase,\n@@ -33,38 +36,8 @@ pub fn validate_module_item(\n pub fn validate_body(db: &dyn HirDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n     let _p = profile::span(\"validate_body\");\n     let infer = db.infer(owner);\n-    infer.add_diagnostics(db, owner, sink);\n     let mut validator = expr::ExprValidator::new(owner, infer.clone(), sink);\n     validator.validate_body(db);\n-    let mut validator = unsafe_check::UnsafeValidator::new(owner, infer, sink);\n-    validator.validate_body(db);\n-}\n-\n-// Diagnostic: no-such-field\n-//\n-// This diagnostic is triggered if created structure does not have field provided in record.\n-#[derive(Debug)]\n-pub struct NoSuchField {\n-    pub file: HirFileId,\n-    pub field: AstPtr<ast::RecordExprField>,\n-}\n-\n-impl Diagnostic for NoSuchField {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"no-such-field\")\n-    }\n-\n-    fn message(&self) -> String {\n-        \"no such field\".to_string()\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.field.clone().into())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n }\n \n // Diagnostic: missing-structure-fields\n@@ -247,54 +220,6 @@ impl Diagnostic for RemoveThisSemicolon {\n     }\n }\n \n-// Diagnostic: break-outside-of-loop\n-//\n-// This diagnostic is triggered if the `break` keyword is used outside of a loop.\n-#[derive(Debug)]\n-pub struct BreakOutsideOfLoop {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for BreakOutsideOfLoop {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"break-outside-of-loop\")\n-    }\n-    fn message(&self) -> String {\n-        \"break outside of loop\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: missing-unsafe\n-//\n-// This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n-#[derive(Debug)]\n-pub struct MissingUnsafe {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for MissingUnsafe {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-unsafe\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"This operation is unsafe and requires an unsafe function or block\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n // Diagnostic: mismatched-arg-count\n //\n // This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n@@ -530,129 +455,6 @@ mod tests {\n         assert_eq!(annotations, actual);\n     }\n \n-    #[test]\n-    fn no_such_field_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-struct S { foo: i32, bar: () }\n-impl S {\n-    fn new() -> S {\n-        S {\n-      //^ Missing structure fields:\n-      //|    - bar\n-            foo: 92,\n-            baz: 62,\n-          //^^^^^^^ no such field\n-        }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-    #[test]\n-    fn no_such_field_with_feature_flag_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-struct MyStruct {\n-    my_val: usize,\n-    #[cfg(feature = \"foo\")]\n-    bar: bool,\n-}\n-\n-impl MyStruct {\n-    #[cfg(feature = \"foo\")]\n-    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n-        Self { my_val, bar }\n-    }\n-    #[cfg(not(feature = \"foo\"))]\n-    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n-        Self { my_val }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_enum_with_feature_flag_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-enum Foo {\n-    #[cfg(not(feature = \"foo\"))]\n-    Buz,\n-    #[cfg(feature = \"foo\")]\n-    Bar,\n-    Baz\n-}\n-\n-fn test_fn(f: Foo) {\n-    match f {\n-        Foo::Bar => {},\n-        Foo::Baz => {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-struct S {\n-    #[cfg(feature = \"foo\")]\n-    foo: u32,\n-    #[cfg(not(feature = \"foo\"))]\n-    bar: u32,\n-}\n-\n-impl S {\n-    #[cfg(feature = \"foo\")]\n-    fn new(foo: u32) -> Self {\n-        Self { foo }\n-    }\n-    #[cfg(not(feature = \"foo\"))]\n-    fn new(bar: u32) -> Self {\n-        Self { bar }\n-    }\n-    fn new2(bar: u32) -> Self {\n-        #[cfg(feature = \"foo\")]\n-        { Self { foo: bar } }\n-        #[cfg(not(feature = \"foo\"))]\n-        { Self { bar } }\n-    }\n-    fn new2(val: u32) -> Self {\n-        Self {\n-            #[cfg(feature = \"foo\")]\n-            foo: val,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: val,\n-        }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_with_type_macro() {\n-        check_diagnostics(\n-            r#\"\n-macro_rules! Type { () => { u32 }; }\n-struct Foo { bar: Type![] }\n-\n-impl Foo {\n-    fn new() -> Self {\n-        Foo { bar: 0 }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn missing_record_pat_field_diagnostic() {\n         check_diagnostics(\n@@ -734,16 +536,6 @@ pub struct Claims {\n         );\n     }\n \n-    #[test]\n-    fn break_outside_of_loop() {\n-        check_diagnostics(\n-            r#\"\n-fn foo() { break; }\n-         //^^^^^ break outside of loop\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn missing_semicolon() {\n         check_diagnostics("}, {"sha": "a4054cef92e840fdf1beecb6632c57b0d73321a9", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 15, "deletions": 133, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -1,61 +1,32 @@\n //! Provides validations for unsafe code. Currently checks if unsafe functions are missing\n //! unsafe blocks.\n \n-use std::sync::Arc;\n-\n use hir_def::{\n     body::Body,\n     expr::{Expr, ExprId, UnaryOp},\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId,\n };\n \n-use crate::{\n-    db::HirDatabase, diagnostics::MissingUnsafe, diagnostics_sink::DiagnosticSink, InferenceResult,\n-    Interner, TyExt, TyKind,\n-};\n+use crate::{db::HirDatabase, InferenceResult, Interner, TyExt, TyKind};\n \n-pub(super) struct UnsafeValidator<'a, 'b: 'a> {\n-    owner: DefWithBodyId,\n-    infer: Arc<InferenceResult>,\n-    sink: &'a mut DiagnosticSink<'b>,\n-}\n+pub fn missing_unsafe(db: &dyn HirDatabase, def: DefWithBodyId) -> Vec<ExprId> {\n+    let infer = db.infer(def);\n \n-impl<'a, 'b> UnsafeValidator<'a, 'b> {\n-    pub(super) fn new(\n-        owner: DefWithBodyId,\n-        infer: Arc<InferenceResult>,\n-        sink: &'a mut DiagnosticSink<'b>,\n-    ) -> UnsafeValidator<'a, 'b> {\n-        UnsafeValidator { owner, infer, sink }\n+    // let unsafe_expressions = ;\n+    let is_unsafe = match def {\n+        DefWithBodyId::FunctionId(it) => db.function_data(it).is_unsafe(),\n+        DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) => false,\n+    };\n+    if is_unsafe {\n+        return Vec::new();\n     }\n \n-    pub(super) fn validate_body(&mut self, db: &dyn HirDatabase) {\n-        let def = self.owner;\n-        let unsafe_expressions = unsafe_expressions(db, self.infer.as_ref(), def);\n-        let is_unsafe = match self.owner {\n-            DefWithBodyId::FunctionId(it) => db.function_data(it).is_unsafe(),\n-            DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) => false,\n-        };\n-        if is_unsafe\n-            || unsafe_expressions\n-                .iter()\n-                .filter(|unsafe_expr| !unsafe_expr.inside_unsafe_block)\n-                .count()\n-                == 0\n-        {\n-            return;\n-        }\n-\n-        let (_, body_source) = db.body_with_source_map(def);\n-        for unsafe_expr in unsafe_expressions {\n-            if !unsafe_expr.inside_unsafe_block {\n-                if let Ok(in_file) = body_source.as_ref().expr_syntax(unsafe_expr.expr) {\n-                    self.sink.push(MissingUnsafe { file: in_file.file_id, expr: in_file.value })\n-                }\n-            }\n-        }\n-    }\n+    unsafe_expressions(db, &infer, def)\n+        .into_iter()\n+        .filter(|it| !it.inside_unsafe_block)\n+        .map(|it| it.expr)\n+        .collect()\n }\n \n pub(crate) struct UnsafeExpr {\n@@ -126,92 +97,3 @@ fn walk_unsafe(\n         walk_unsafe(unsafe_exprs, db, infer, def, body, child, inside_unsafe_block);\n     });\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn missing_unsafe_diagnostic_with_raw_ptr() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    let x = &5 as *const usize;\n-    unsafe { let y = *x; }\n-    let z = *x;\n-}         //^^ This operation is unsafe and requires an unsafe function or block\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_unsafe_diagnostic_with_unsafe_call() {\n-        check_diagnostics(\n-            r#\"\n-struct HasUnsafe;\n-\n-impl HasUnsafe {\n-    unsafe fn unsafe_fn(&self) {\n-        let x = &5 as *const usize;\n-        let y = *x;\n-    }\n-}\n-\n-unsafe fn unsafe_fn() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\n-fn main() {\n-    unsafe_fn();\n-  //^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-    HasUnsafe.unsafe_fn();\n-  //^^^^^^^^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-    unsafe {\n-        unsafe_fn();\n-        HasUnsafe.unsafe_fn();\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn missing_unsafe_diagnostic_with_static_mut() {\n-        check_diagnostics(\n-            r#\"\n-struct Ty {\n-    a: u8,\n-}\n-\n-static mut STATIC_MUT: Ty = Ty { a: 0 };\n-\n-fn main() {\n-    let x = STATIC_MUT.a;\n-          //^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-    unsafe {\n-        let x = STATIC_MUT.a;\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_missing_unsafe_diagnostic_with_safe_intrinsic() {\n-        check_diagnostics(\n-            r#\"\n-extern \"rust-intrinsic\" {\n-    pub fn bitreverse(x: u32) -> u32; // Safe intrinsic\n-    pub fn floorf32(x: f32) -> f32; // Unsafe intrinsic\n-}\n-\n-fn main() {\n-    let _ = bitreverse(12);\n-    let _ = floorf32(12.0);\n-          //^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "2c667da25698eec18c419be9be55dd5a683f3151", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -35,11 +35,9 @@ use stdx::impl_from;\n use syntax::SmolStr;\n \n use super::{DomainGoal, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty};\n-use crate::diagnostics_sink::DiagnosticSink;\n use crate::{\n-    db::HirDatabase, fold_tys, infer::diagnostics::InferenceDiagnostic,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Goal, Interner, Substitution,\n-    TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy,\n+    Goal, Interner, Substitution, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -111,6 +109,12 @@ pub(crate) struct InferOk {\n pub(crate) struct TypeError;\n pub(crate) type InferResult = Result<InferOk, TypeError>;\n \n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum InferenceDiagnostic {\n+    NoSuchField { expr: ExprId },\n+    BreakOutsideOfLoop { expr: ExprId },\n+}\n+\n /// A mismatch between an expected and an inferred type.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TypeMismatch {\n@@ -140,7 +144,7 @@ pub struct InferenceResult {\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantId>,\n     /// For each associated item record what it resolves to\n     assoc_resolutions: FxHashMap<ExprOrPatId, AssocItemId>,\n-    diagnostics: Vec<InferenceDiagnostic>,\n+    pub diagnostics: Vec<InferenceDiagnostic>,\n     pub type_of_expr: ArenaMap<ExprId, Ty>,\n     /// For each pattern record the type it resolves to.\n     ///\n@@ -191,14 +195,6 @@ impl InferenceResult {\n             _ => None,\n         })\n     }\n-    pub fn add_diagnostics(\n-        &self,\n-        db: &dyn HirDatabase,\n-        owner: DefWithBodyId,\n-        sink: &mut DiagnosticSink,\n-    ) {\n-        self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n-    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -804,43 +800,3 @@ impl std::ops::BitOrAssign for Diverges {\n         *self = *self | other;\n     }\n }\n-\n-mod diagnostics {\n-    use hir_def::{expr::ExprId, DefWithBodyId};\n-\n-    use crate::{\n-        db::HirDatabase,\n-        diagnostics::{BreakOutsideOfLoop, NoSuchField},\n-        diagnostics_sink::DiagnosticSink,\n-    };\n-\n-    #[derive(Debug, PartialEq, Eq, Clone)]\n-    pub(super) enum InferenceDiagnostic {\n-        NoSuchField { expr: ExprId },\n-        BreakOutsideOfLoop { expr: ExprId },\n-    }\n-\n-    impl InferenceDiagnostic {\n-        pub(super) fn add_to(\n-            &self,\n-            db: &dyn HirDatabase,\n-            owner: DefWithBodyId,\n-            sink: &mut DiagnosticSink,\n-        ) {\n-            match self {\n-                InferenceDiagnostic::NoSuchField { expr } => {\n-                    let (_, source_map) = db.body_with_source_map(owner);\n-                    let field = source_map.field_syntax(*expr);\n-                    sink.push(NoSuchField { file: field.file_id, field: field.value })\n-                }\n-                InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n-                    let (_, source_map) = db.body_with_source_map(owner);\n-                    let ptr = source_map\n-                        .expr_syntax(*expr)\n-                        .expect(\"break outside of loop in synthetic syntax\");\n-                    sink.push(BreakOutsideOfLoop { file: ptr.file_id, expr: ptr.value })\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "0c6b196534e94cd1b35f4c877faa2fdc8b0efe51", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -50,7 +50,7 @@ use crate::{db::HirDatabase, utils::generics};\n pub use autoderef::autoderef;\n pub use builder::TyBuilder;\n pub use chalk_ext::*;\n-pub use infer::{could_unify, InferenceResult};\n+pub use infer::{could_unify, InferenceDiagnostic, InferenceResult};\n pub use interner::Interner;\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, CallableDefId, ImplTraitLoweringMode,"}, {"sha": "b791747c259e09b229e6a300cdcb4ce97ce7cb1d", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 224, "deletions": 1, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e67d692d915b326bd20a4c487039ade377029b/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=f9e67d692d915b326bd20a4c487039ade377029b", "patch": "@@ -305,6 +305,7 @@ fn unresolved_fix(id: &'static str, label: &str, target: TextRange) -> Assist {\n #[cfg(test)]\n mod tests {\n     use expect_test::Expect;\n+    use hir::diagnostics::DiagnosticCode;\n     use ide_assists::AssistResolveStrategy;\n     use stdx::trim_indent;\n     use test_utils::{assert_eq_text, extract_annotations};\n@@ -410,7 +411,12 @@ mod tests {\n             .unwrap();\n \n         let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n-        let actual = diagnostics.into_iter().map(|d| (d.range, d.message)).collect::<Vec<_>>();\n+        let mut actual = diagnostics\n+            .into_iter()\n+            .filter(|d| d.code != Some(DiagnosticCode(\"inactive-code\")))\n+            .map(|d| (d.range, d.message))\n+            .collect::<Vec<_>>();\n+        actual.sort_by_key(|(range, _)| range.start());\n         assert_eq!(expected, actual);\n     }\n \n@@ -716,6 +722,223 @@ $0\n mod foo;\n \n //- /foo.rs\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_outside_of_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() { break; }\n+         //^^^^^ break outside of loop\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+impl S {\n+    fn new() -> S {\n+        S {\n+      //^ Missing structure fields:\n+      //|    - bar\n+            foo: 92,\n+            baz: 62,\n+          //^^^^^^^ no such field\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct MyStruct {\n+    my_val: usize,\n+    #[cfg(feature = \"foo\")]\n+    bar: bool,\n+}\n+\n+impl MyStruct {\n+    #[cfg(feature = \"foo\")]\n+    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+        Self { my_val, bar }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+        Self { my_val }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_enum_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+enum Foo {\n+    #[cfg(not(feature = \"foo\"))]\n+    Buz,\n+    #[cfg(feature = \"foo\")]\n+    Bar,\n+    Baz\n+}\n+\n+fn test_fn(f: Foo) {\n+    match f {\n+        Foo::Bar => {},\n+        Foo::Baz => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {\n+    #[cfg(feature = \"foo\")]\n+    foo: u32,\n+    #[cfg(not(feature = \"foo\"))]\n+    bar: u32,\n+}\n+\n+impl S {\n+    #[cfg(feature = \"foo\")]\n+    fn new(foo: u32) -> Self {\n+        Self { foo }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    fn new(bar: u32) -> Self {\n+        Self { bar }\n+    }\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { foo: bar } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { bar } }\n+    }\n+    fn new2(val: u32) -> Self {\n+        Self {\n+            #[cfg(feature = \"foo\")]\n+            foo: val,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: val,\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type { () => { u32 }; }\n+struct Foo { bar: Type![] }\n+\n+impl Foo {\n+    fn new() -> Self {\n+        Foo { bar: 0 }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_raw_ptr() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe { let y = *x; }\n+    let z = *x;\n+}         //^^ This operation is unsafe and requires an unsafe function or block\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_unsafe_call() {\n+        check_diagnostics(\n+            r#\"\n+struct HasUnsafe;\n+\n+impl HasUnsafe {\n+    unsafe fn unsafe_fn(&self) {\n+        let x = &5 as *const usize;\n+        let y = *x;\n+    }\n+}\n+\n+unsafe fn unsafe_fn() {\n+    let x = &5 as *const usize;\n+    let y = *x;\n+}\n+\n+fn main() {\n+    unsafe_fn();\n+  //^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    HasUnsafe.unsafe_fn();\n+  //^^^^^^^^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafe.unsafe_fn();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_static_mut() {\n+        check_diagnostics(\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = STATIC_MUT.a;\n+          //^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        let x = STATIC_MUT.a;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_missing_unsafe_diagnostic_with_safe_intrinsic() {\n+        check_diagnostics(\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn bitreverse(x: u32) -> u32; // Safe intrinsic\n+    pub fn floorf32(x: f32) -> f32; // Unsafe intrinsic\n+}\n+\n+fn main() {\n+    let _ = bitreverse(12);\n+    let _ = floorf32(12.0);\n+          //^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+}\n \"#,\n         );\n     }"}]}