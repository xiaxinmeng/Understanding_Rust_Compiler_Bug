{"sha": "a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MmNkNzdiMmIzNTgzZjhmMGJkMjdjMWMxYjc4M2ZjZjJlOWRkNmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-10T08:17:40Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-10T08:17:40Z"}, "message": "Rustup to *rustc 1.20.0-nightly (d84693b93 2017-07-09)*", "tree": {"sha": "7fa490f4efc1e0d6fd4b64310ead9ad68ec65240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fa490f4efc1e0d6fd4b64310ead9ad68ec65240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "html_url": "https://github.com/rust-lang/rust/commit/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd7dda097bfa4e238311ac0f0ca71ec6adf3f0ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd7dda097bfa4e238311ac0f0ca71ec6adf3f0ff", "html_url": "https://github.com/rust-lang/rust/commit/fd7dda097bfa4e238311ac0f0ca71ec6adf3f0ff"}], "stats": {"total": 116, "additions": 57, "deletions": 59}, "files": [{"sha": "5ef166388783f8e5e226327bce978740d24e6c9e", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -48,7 +48,7 @@ impl EarlyLintPass for DoubleParens {\n                     }\n                 }\n             },\n-            ExprKind::MethodCall(_, _, ref params) => {\n+            ExprKind::MethodCall(_, ref params) => {\n                 if params.len() == 2 {\n                     let param = &params[1];\n                     if let ExprKind::Paren(_) = param.node {"}, {"sha": "43d8357e335cd8462b4345977ab1dfe1689d5cc9", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -89,9 +89,9 @@ fn check_cond<'a, 'tcx, 'b>(\n     check: &'b Expr\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_let_chain! {[\n-        let ExprMethodCall(ref name, _, ref params) = check.node,\n+        let ExprMethodCall(ref path, _, ref params) = check.node,\n         params.len() >= 2,\n-        name.node == \"contains_key\",\n+        path.name == \"contains_key\",\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n@@ -123,9 +123,9 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_let_chain! {[\n-            let ExprMethodCall(ref name, _, ref params) = expr.node,\n+            let ExprMethodCall(ref path, _, ref params) = expr.node,\n             params.len() == 3,\n-            name.node == \"insert\",\n+            path.name == \"insert\",\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {"}, {"sha": "765da9ea877d0ebbef5770ad445fc9121ef92fd5", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -219,7 +219,7 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n     match expr.node {\n         ExprArray(_) |\n         ExprTup(_) |\n-        ExprMethodCall(_, _, _) |\n+        ExprMethodCall(..) |\n         ExprCall(_, _) |\n         ExprAssign(_, _) |\n         ExprIndex(_, _) |"}, {"sha": "4f97f939964ba82ae4e6fae11eb8ed694f02c9cb", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -158,9 +158,9 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n         }\n     }\n     match (&left.node, &right.node) {\n-        (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) |\n-        (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n-            check_len_zero(cx, span, method.node, args, lit, op)\n+        (&ExprLit(ref lit), &ExprMethodCall(ref method_path, _, ref args)) |\n+        (&ExprMethodCall(ref method_path, _, ref args), &ExprLit(ref lit)) => {\n+            check_len_zero(cx, span, method_path.name, args, lit, op)\n         },\n         _ => (),\n     }"}, {"sha": "c71a36ab9a7c596be6659672e03fd7b5f943f5df", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -405,10 +405,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n             if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                    &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n+                    &ExprMethodCall(ref method_path, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if self.loop_count < 2 && method_name.node == \"next\" &&\n+                if self.loop_count < 2 && method_path.name == \"next\" &&\n                    match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n                    lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n                    !is_iterator_used_after_while_let(cx, iter_expr) {\n@@ -428,7 +428,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n+                if args.len() == 1 && method.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n                               expr.span,\n@@ -660,9 +660,9 @@ fn check_for_loop_range<'a, 'tcx>(\n \n fn is_len_call(expr: &Expr, var: &Name) -> bool {\n     if_let_chain! {[\n-        let ExprMethodCall(method, _, ref len_args) = expr.node,\n+        let ExprMethodCall(ref method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n-        method.node == \"len\",\n+        method.name == \"len\",\n         let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n         path.segments[0].name == *var\n@@ -747,11 +747,11 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n     if let ExprMethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n-            let method_name = method.node.as_str();\n+            let method_name = &*method.name.as_str();\n             // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n             if method_name == \"iter\" || method_name == \"iter_mut\" {\n                 if is_ref_iterable_type(cx, &args[0]) {\n-                    lint_iter_method(cx, args, arg, &method_name);\n+                    lint_iter_method(cx, args, arg, method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n                 let def_id = cx.tables.type_dependent_defs[&arg.id].def_id();\n@@ -761,7 +761,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                 let fn_arg_tys = method_type.fn_sig(cx.tcx).inputs();\n                 assert_eq!(fn_arg_tys.skip_binder().len(), 1);\n                 if fn_arg_tys.skip_binder()[0].is_region_ptr() {\n-                    lint_iter_method(cx, args, arg, &method_name);\n+                    lint_iter_method(cx, args, arg, method_name);\n                 } else {\n                     let object = snippet(cx, args[0].span, \"_\");\n                     span_lint_and_sugg(cx,"}, {"sha": "1661c71167eccdea320db5087231e66623c05e69", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -28,8 +28,8 @@ pub struct Pass;\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n-        if let ExprMethodCall(name, _, ref args) = expr.node {\n-            if name.node == \"map\" && args.len() == 2 {\n+        if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+            if method.name == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n@@ -59,8 +59,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 }\n                             }\n                             // explicit clone() calls ( .map(|x| x.clone()) )\n-                            else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                if clone_call.node == \"clone\" &&\n+                            else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n+                                if clone_call.name == \"clone\" &&\n                                     clone_args.len() == 1 &&\n                                     match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                     expr_eq_name(&clone_args[0], arg_ident)"}, {"sha": "835b836f7ec25e5db28a6248812e6a2061a88354", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -559,7 +559,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         match expr.node {\n-            hir::ExprMethodCall(name, _, ref args) => {\n+            hir::ExprMethodCall(ref method_call, _, ref args) => {\n                 // Chain calls\n                 // GET_UNWRAP needs to be checked before general `UNWRAP` lints\n                 if let Some(arglists) = method_chain_args(expr, &[\"get\", \"unwrap\"]) {\n@@ -604,17 +604,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     lint_iter_cloned_collect(cx, expr, arglists[0]);\n                 }\n \n-                lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n+                lint_or_fun_call(cx, expr, &method_call.name.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && name.node == \"clone\" {\n+                if args.len() == 1 && method_call.name == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n \n                 match self_ty.sty {\n                     ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => {\n                         for &(method, pos) in &PATTERN_METHODS {\n-                            if name.node == method && args.len() > pos {\n+                            if method_call.name == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n@@ -804,8 +804,8 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n                     check_general_case(cx, name, fun.span, &args[0], &args[1], or_has_args, expr.span);\n                 }\n             },\n-            hir::ExprMethodCall(fun, _, ref or_args) => {\n-                check_general_case(cx, name, fun.span, &args[0], &args[1], !or_args.is_empty(), expr.span)\n+            hir::ExprMethodCall(_, span, ref or_args) => {\n+                check_general_case(cx, name, span, &args[0], &args[1], !or_args.is_empty(), expr.span)\n             },\n             _ => {},\n         }\n@@ -981,8 +981,8 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n         }\n     }\n \n-    if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if name.node == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+    if let hir::ExprMethodCall(ref path, _, ref args) = expr.node {\n+        if path.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None"}, {"sha": "0e2c0412702a9017d7c96f5d1883b7cac0b35000", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -44,11 +44,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n                                     &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n                 }\n             },\n-            ExprMethodCall(ref name, _, ref arguments) => {\n+            ExprMethodCall(ref path, _, ref arguments) => {\n                 let def_id = cx.tables.type_dependent_defs[&e.id].def_id();\n                 let substs = cx.tables.node_substs(e.id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, &name.node.as_str())\n+                check_arguments(cx, arguments, method_type, &path.name.as_str())\n             },\n             _ => (),\n         }"}, {"sha": "429d02d068bf8d0dad2d059af36051715c878a82", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -34,9 +34,9 @@ impl LintPass for NonSensical {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n+        if let ExprMethodCall(ref path, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n-            if name.node == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n+            if path.name == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);\n@@ -62,7 +62,7 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprMethodCall(ref name, _, ref arguments) = argument.node {\n+    if let ExprMethodCall(ref path, _, ref arguments) = argument.node {\n         let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n@@ -81,7 +81,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n                 _ => Argument::Unknown,\n             };\n \n-            match &*name.node.as_str() {\n+            match &*path.name.as_str() {\n                 \"create\" => {\n                     options.push((OpenOption::Create, argument_option));\n                 },"}, {"sha": "e7b3413689124abd6489285127c2f9499d303edf", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -75,7 +75,7 @@ impl EarlyLintPass for Precedence {\n         }\n \n         if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.node {\n-            if let ExprKind::MethodCall(_, _, ref args) = rhs.node {\n+            if let ExprKind::MethodCall(_, ref args) = rhs.node {\n                 if let Some(slf) = args.first() {\n                     if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {"}, {"sha": "037ebf8ba2c4361c651e9fa228d72caea12b17ce", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use syntax::codemap::Spanned;\n use utils::{is_integer_literal, paths, snippet, span_lint};\n use utils::{higher, implements_trait, get_trait_def_id};\n \n@@ -49,8 +48,8 @@ impl LintPass for StepByZero {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n-            let name = name.as_str();\n+        if let ExprMethodCall(ref path, _, ref args) = expr.node {\n+            let name = path.name.as_str();\n \n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) {\n@@ -69,14 +68,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                 let zip_arg = &args[1];\n                 if_let_chain! {[\n                     // .iter() call\n-                    let ExprMethodCall( Spanned { node: iter_name, .. }, _, ref iter_args ) = *iter,\n-                    iter_name == \"iter\",\n+                    let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter,\n+                    iter_path.name == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n                     let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n-                    let ExprMethodCall(Spanned { node: len_name, .. }, _, ref len_args) = end.node,\n-                    len_name == \"len\" && len_args.len() == 1,\n+                    let ExprMethodCall(ref len_path, _, ref len_args) = end.node,\n+                    len_path.name == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n                     let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n                     let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,"}, {"sha": "043d1dff8e5008f7270655d250ef7ec2fe4b9f7d", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -142,8 +142,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use syntax::ast::LitKind;\n         use utils::{snippet, in_macro};\n \n-        if let ExprMethodCall(ref name, _, ref args) = e.node {\n-            if name.node == \"as_bytes\" {\n+        if let ExprMethodCall(ref path, _, ref args) = e.node {\n+            if path.name == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {"}, {"sha": "5a97254f3adea7f20822059764753366858aebe1", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -55,8 +55,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprMethodCall(ref symbol, _, ref args) => {\n-                match &*symbol.node.as_str() {\n+            hir::ExprMethodCall(ref path, _, ref args) => {\n+                match &*path.name.as_str() {\n                     \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                         check_method_call(cx, &args[0], expr);\n                     },\n@@ -70,8 +70,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n-    if let hir::ExprMethodCall(ref symbol, _, _) = call.node {\n-        let symbol = &*symbol.node.as_str();\n+    if let hir::ExprMethodCall(ref path, _, _) = call.node {\n+        let symbol = &*path.name.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint(cx,\n                       UNUSED_IO_AMOUNT,"}, {"sha": "bd7edf2f56453d5eb92117d17e58253a4d0f9887", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -110,10 +110,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             },\n-            (&ExprMethodCall(ref l_name, ref l_tys, ref l_args),\n-             &ExprMethodCall(ref r_name, ref r_tys, ref r_args)) => {\n-                !self.ignore_fn && l_name.node == r_name.node && over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n-                self.eq_exprs(l_args, r_args)\n+            (&ExprMethodCall(ref l_path, _, ref l_args),\n+             &ExprMethodCall(ref r_path, _, ref r_args)) => {\n+                !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprRepeat(ref le, ll_id), &ExprRepeat(ref re, rl_id)) => {\n                 self.eq_expr(le, re) &&\n@@ -428,10 +427,10 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprMethodCall(ref name, ref _tys, ref args) => {\n+            ExprMethodCall(ref path, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n                 c.hash(&mut self.s);\n-                self.hash_name(&name.node);\n+                self.hash_name(&path.name);\n                 self.hash_exprs(args);\n             },\n             ExprRepeat(ref e, l_id) => {"}, {"sha": "9962eca507525894334287045cbc1ec53866591c", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -175,9 +175,9 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprMethodCall(ref name, _, ref args) => {\n+        hir::ExprMethodCall(ref path, _, ref args) => {\n             println!(\"{}MethodCall\", ind);\n-            println!(\"{}method name: {}\", ind, name.node);\n+            println!(\"{}method name: {}\", ind, path.name);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }"}, {"sha": "5b53d6dbea7f177b0df773f2ff58aa377dd0a2fc", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a82cd77b2b3583f8f0bd27c1c1b783fcf2e9dd6b", "patch": "@@ -336,8 +336,8 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprMethodCall(ref name, _, ref args) = current.node {\n-            if name.node == *method_name {\n+        if let ExprMethodCall(ref path, _, ref args) = current.node {\n+            if path.name == *method_name {\n                 if args.iter().any(|e| in_macro(e.span)) {\n                     return None;\n                 }"}]}