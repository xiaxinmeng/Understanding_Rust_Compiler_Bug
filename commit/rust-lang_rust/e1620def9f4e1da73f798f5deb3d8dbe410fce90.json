{"sha": "e1620def9f4e1da73f798f5deb3d8dbe410fce90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNjIwZGVmOWY0ZTFkYTczZjc5OGY1ZGViM2Q4ZGJlNDEwZmNlOTA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-12T00:26:40Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-12T00:32:00Z"}, "message": "In typeck, check for dynamically sized by-value arguments to thunks\n\nA check in trans didn't have a corresponding check in typeck, causing\nsome programs (to wit, compile-fail/chan-parameterized-args.rs - part of this\ncommit) to fail with an assertion failure in trans instead of a type error.\nFixed it. In short, arguments that are future thunk arguments (any spawn\narguments, and _ arguments in bind) need to either not contain type params\nor type vars, or be by-reference.\n\nCloses #665.", "tree": {"sha": "9be1f3027af3c566630cbade4f9e4898b2ad99e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9be1f3027af3c566630cbade4f9e4898b2ad99e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1620def9f4e1da73f798f5deb3d8dbe410fce90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1620def9f4e1da73f798f5deb3d8dbe410fce90", "html_url": "https://github.com/rust-lang/rust/commit/e1620def9f4e1da73f798f5deb3d8dbe410fce90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1620def9f4e1da73f798f5deb3d8dbe410fce90/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fe03b3c556eddd99887e7968f9757f7bdf91cc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe03b3c556eddd99887e7968f9757f7bdf91cc1", "html_url": "https://github.com/rust-lang/rust/commit/9fe03b3c556eddd99887e7968f9757f7bdf91cc1"}], "stats": {"total": 88, "additions": 77, "deletions": 11}, "files": [{"sha": "5f13134e06dd0e57c384a0e77c7a2f9c507078b8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e1620def9f4e1da73f798f5deb3d8dbe410fce90", "patch": "@@ -8,11 +8,10 @@ import syntax::walk;\n import metadata::csearch;\n import driver::session;\n import util::common;\n+import util::common::*;\n import syntax::codemap::span;\n import std::map::new_int_hash;\n import std::map::new_str_hash;\n-import util::common::new_def_hash;\n-import util::common::log_expr_err;\n import middle::ty;\n import middle::ty::node_id_to_type;\n import middle::ty::arg;\n@@ -1485,7 +1484,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // expressions.\n \n     fn check_call_or_bind(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n-                          &(option::t[@ast::expr])[] args, bool is_call) {\n+               &(option::t[@ast::expr])[] args, call_kind call_kind) {\n         // Check the function.\n \n         check_expr(fcx, f);\n@@ -1494,8 +1493,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         auto fty = expr_ty(fcx.ccx.tcx, f);\n \n         // We want to autoderef calls but not binds\n-        auto fty_stripped =\n-            if (is_call) { do_autoderef(fcx, sp, fty) } else { fty };\n+        auto fty_stripped = alt (call_kind) {\n+            case (kind_call) { do_autoderef(fcx, sp, fty) }\n+            case (_)         { fty } };\n \n         // Grab the argument types and the return type.\n         auto arg_tys;\n@@ -1532,13 +1532,38 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         auto i = 0u;\n         for (option::t[@ast::expr] a_opt in args) {\n+            auto check_ty_vars = call_kind == kind_spawn;\n             alt (a_opt) {\n                 case (some(?a)) {\n                     check_expr(fcx, a);\n                     demand::simple(fcx, a.span, arg_tys.(i).ty,\n                                    expr_ty(fcx.ccx.tcx, a));\n                 }\n-                case (none) {/* no-op */ }\n+                case (none) {\n+                    check_ty_vars = true;\n+                }\n+            }\n+            /* If this argument is going to be a thunk argument\n+               (that is, it's an underscore-bind thing or a spawn\n+               argument), then it has to be either passed by reference,\n+               or have a statically known size. */\n+            alt (call_kind) {\n+                case (kind_call) { }\n+                case (_) { /* bind or spawn */\n+                    if (check_ty_vars &&\n+                        ((ty::type_contains_params(fcx.ccx.tcx,\n+                                                   arg_tys.(i).ty))\n+                        || ty::type_contains_vars(fcx.ccx.tcx,\n+                                                  arg_tys.(i).ty))\n+                        && arg_tys.(i).mode == mo_val) {\n+                        // For why the check is necessary, see the\n+                        // none case in trans_bind_thunk\n+                        fcx.ccx.tcx.sess.span_fatal(sp,\n+                           call_kind_str(call_kind) +\n+                           \" arguments with types containing parameters \\\n+                             must be passed by alias\");\n+                    }\n+                }\n             }\n             i += 1u;\n         }\n@@ -1556,14 +1581,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // A generic function for checking call expressions\n \n     fn check_call(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n-                  &(@ast::expr)[] args) {\n+                  &(@ast::expr)[] args, call_kind call_kind) {\n         let (option::t[@ast::expr])[] args_opt_0 = ~[];\n         for (@ast::expr arg in args) {\n             args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n         // Call the generic checker.\n \n-        check_call_or_bind(fcx, sp, f, args_opt_0, true);\n+        check_call_or_bind(fcx, sp, f, args_opt_0, call_kind);\n     }\n     // A generic function for checking for or for-each loops\n \n@@ -1990,7 +2015,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_bind(?f, ?args)) {\n             // Call the generic checker.\n \n-            check_call_or_bind(fcx, expr.span, f, args, false);\n+            check_call_or_bind(fcx, expr.span, f, args, kind_bind);\n             // Pull the argument and return types out.\n \n             auto proto_1;\n@@ -2035,7 +2060,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             function name onto purity-designation */\n \n             require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n-            check_call(fcx, expr.span, f, args);\n+            check_call(fcx, expr.span, f, args, kind_call);\n             // Pull the return type out of the type of the function.\n \n             auto rt_1;\n@@ -2085,7 +2110,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n         }\n         case (ast::expr_spawn(_, _, ?f, ?args)) {\n-            check_call(fcx, expr.span, f, args);\n+            check_call(fcx, expr.span, f, args, kind_spawn);\n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto ret_ty = ty::ret_ty_of_fn_ty(fcx.ccx.tcx, fty);\n             demand::simple(fcx, f.span, ty::mk_nil(fcx.ccx.tcx), ret_ty);"}, {"sha": "c2281739bf56ad1d5dfa61735be3c0e0aa5481de", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=e1620def9f4e1da73f798f5deb3d8dbe410fce90", "patch": "@@ -182,6 +182,19 @@ fn any[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n     ret false;\n }\n \n+tag call_kind {\n+    kind_call;\n+    kind_spawn;\n+    kind_bind;\n+}\n+\n+fn call_kind_str(call_kind c) -> str {\n+    alt (c) {\n+        case (kind_call)  { \"Call\" }\n+        case (kind_spawn) { \"Spawn\" }\n+        case (kind_bind)  { \"Bind\" }\n+    }\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "5e2dd24fb28a44c04f5059563ecd0399138da69d", "filename": "src/test/compile-fail/bind-parameterized-args.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs?ref=e1620def9f4e1da73f798f5deb3d8dbe410fce90", "patch": "@@ -0,0 +1,10 @@\n+// xfail-stage0\n+// error-pattern:Bind arguments with types containing parameters must be\n+fn main() {\n+  fn echo[T](int c, vec[T] x) {\n+  }\n+  \n+  let fn(vec[int]) -> () y = bind echo(42, _);\n+\n+  y([1]);\n+}"}, {"sha": "78c9a743c754843891e8a20d8087fe4a560a0a5a", "filename": "src/test/compile-fail/chan-parameterized-args.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1620def9f4e1da73f798f5deb3d8dbe410fce90/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs?ref=e1620def9f4e1da73f798f5deb3d8dbe410fce90", "patch": "@@ -0,0 +1,18 @@\n+// xfail-stage0\n+// error-pattern:Spawn arguments with types containing parameters must be\n+fn main() {\n+// Similar to bind-parameterized-args\n+    fn echo[T](chan[T] c, chan[chan[T]] oc) {\n+        let port[T] p = port();\n+        oc <| chan(p);\n+\n+        auto x;\n+        p |> x;\n+        c <| x;\n+    }\n+\n+    auto p = port[int]();\n+    auto p2 = port[chan[int]]();\n+\n+    spawn echo(chan(p), chan(p2));\n+}\n\\ No newline at end of file"}]}