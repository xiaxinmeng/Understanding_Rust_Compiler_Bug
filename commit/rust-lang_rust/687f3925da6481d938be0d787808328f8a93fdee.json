{"sha": "687f3925da6481d938be0d787808328f8a93fdee", "node_id": "C_kwDOAAsO6NoAKDY4N2YzOTI1ZGE2NDgxZDkzOGJlMGQ3ODc4MDgzMjhmOGE5M2ZkZWU", "commit": {"author": {"name": "dswij", "email": "dswijj@gmail.com", "date": "2021-10-19T10:26:50Z"}, "committer": {"name": "dswij", "email": "dswijj@gmail.com", "date": "2021-10-19T10:50:49Z"}, "message": "Cover `Result` for `question_mark`", "tree": {"sha": "de1fed00edb74b6fd3f7c64e1d342e34b2ca653c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de1fed00edb74b6fd3f7c64e1d342e34b2ca653c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/687f3925da6481d938be0d787808328f8a93fdee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/687f3925da6481d938be0d787808328f8a93fdee", "html_url": "https://github.com/rust-lang/rust/commit/687f3925da6481d938be0d787808328f8a93fdee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/687f3925da6481d938be0d787808328f8a93fdee/comments", "author": {"login": "dswij", "id": 44697459, "node_id": "MDQ6VXNlcjQ0Njk3NDU5", "avatar_url": "https://avatars.githubusercontent.com/u/44697459?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dswij", "html_url": "https://github.com/dswij", "followers_url": "https://api.github.com/users/dswij/followers", "following_url": "https://api.github.com/users/dswij/following{/other_user}", "gists_url": "https://api.github.com/users/dswij/gists{/gist_id}", "starred_url": "https://api.github.com/users/dswij/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dswij/subscriptions", "organizations_url": "https://api.github.com/users/dswij/orgs", "repos_url": "https://api.github.com/users/dswij/repos", "events_url": "https://api.github.com/users/dswij/events{/privacy}", "received_events_url": "https://api.github.com/users/dswij/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dswij", "id": 44697459, "node_id": "MDQ6VXNlcjQ0Njk3NDU5", "avatar_url": "https://avatars.githubusercontent.com/u/44697459?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dswij", "html_url": "https://github.com/dswij", "followers_url": "https://api.github.com/users/dswij/followers", "following_url": "https://api.github.com/users/dswij/following{/other_user}", "gists_url": "https://api.github.com/users/dswij/gists{/gist_id}", "starred_url": "https://api.github.com/users/dswij/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dswij/subscriptions", "organizations_url": "https://api.github.com/users/dswij/orgs", "repos_url": "https://api.github.com/users/dswij/repos", "events_url": "https://api.github.com/users/dswij/events{/privacy}", "received_events_url": "https://api.github.com/users/dswij/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63d715209eaf241114f87db247b435df5272e8e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d715209eaf241114f87db247b435df5272e8e4", "html_url": "https://github.com/rust-lang/rust/commit/63d715209eaf241114f87db247b435df5272e8e4"}], "stats": {"total": 76, "additions": 55, "deletions": 21}, "files": [{"sha": "c1ee20c370a407630fc5cbb2f460ceeb487b5760", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/687f3925da6481d938be0d787808328f8a93fdee/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f3925da6481d938be0d787808328f8a93fdee/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=687f3925da6481d938be0d787808328f8a93fdee", "patch": "@@ -4,10 +4,10 @@ use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, path_to_local_id};\n+use clippy_utils::{eq_expr_value, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -48,16 +48,25 @@ impl QuestionMark {\n     /// }\n     /// ```\n     ///\n+    /// ```ignore\n+    /// if result.is_err() {\n+    ///     return result;\n+    /// }\n+    /// ```\n+    ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_is_none_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n             if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n-            if segment.ident.name == sym!(is_none);\n-            if Self::expression_returns_none(cx, then);\n             if let Some(subject) = args.get(0);\n-            if Self::is_option(cx, subject);\n-\n+            if (Self::is_option(cx, subject)\n+                && Self::expression_returns_none(cx, then)\n+                && segment.ident.name == sym!(is_none))\n+                ||\n+                (Self::is_result(cx, subject)\n+                && Self::expression_returns_unmodified_err(cx, then, subject)\n+                && segment.ident.name == sym!(is_err));\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n@@ -95,31 +104,29 @@ impl QuestionMark {\n         }\n     }\n \n-    fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_if_let_some_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n                 = higher::IfLet::hir(cx, expr);\n-            if Self::is_option(cx, let_expr);\n-\n             if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n-            if is_lang_ctor(cx, path1, OptionSome);\n+            if (Self::is_option(cx, let_expr)\n+                && Self::expression_returns_none(cx, if_else)\n+                && is_lang_ctor(cx, path1, OptionSome))\n+                ||\n+                (Self::is_result(cx, let_expr)\n+                 && Self::expression_returns_unmodified_err(cx, if_else, let_expr)\n+                 && is_lang_ctor(cx, path1, ResultOk));\n+\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-\n             if let ExprKind::Block(block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);\n-\n-            if Self::expression_returns_none(cx, if_else);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n-                let replacement = format!(\n-                    \"{}{}?\",\n-                    receiver_str,\n-                    if by_ref { \".as_ref()\" } else { \"\" },\n-                );\n+                let replacement = format!(\"{}{}?\", receiver_str, if by_ref { \".as_ref()\" } else { \"\" },);\n \n                 span_lint_and_sugg(\n                     cx,\n@@ -146,6 +153,12 @@ impl QuestionMark {\n         is_type_diagnostic_item(cx, expr_ty, sym::Option)\n     }\n \n+    fn is_result(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n+\n+        is_type_diagnostic_item(cx, expr_ty, sym::Result)\n+    }\n+\n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n             ExprKind::Block(block, _) => {\n@@ -161,6 +174,27 @@ impl QuestionMark {\n         }\n     }\n \n+    fn expression_returns_unmodified_err(\n+        cx: &LateContext<'_>,\n+        expression: &Expr<'_>,\n+        origin_hir_id: &Expr<'_>,\n+    ) -> bool {\n+        match expression.kind {\n+            ExprKind::Block(block, _) => {\n+                if let Some(return_expression) = Self::return_expression(block) {\n+                    return Self::expression_returns_unmodified_err(cx, return_expression, origin_hir_id);\n+                }\n+\n+                false\n+            },\n+            ExprKind::Ret(Some(expr)) | ExprKind::Call(expr, _) => {\n+                Self::expression_returns_unmodified_err(cx, expr, origin_hir_id)\n+            },\n+            ExprKind::Path(_) => path_to_local(expression) == path_to_local(origin_hir_id),\n+            _ => false,\n+        }\n+    }\n+\n     fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         // Check if last expression is a return statement. Then, return the expression\n         if_chain! {\n@@ -189,7 +223,7 @@ impl QuestionMark {\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        Self::check_is_none_and_early_return_none(cx, expr);\n-        Self::check_if_let_some_and_early_return_none(cx, expr);\n+        Self::check_is_none_or_err_and_early_return(cx, expr);\n+        Self::check_if_let_some_or_err_and_early_return(cx, expr);\n     }\n }"}]}