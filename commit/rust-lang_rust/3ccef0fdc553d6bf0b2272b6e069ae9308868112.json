{"sha": "3ccef0fdc553d6bf0b2272b6e069ae9308868112", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjY2VmMGZkYzU1M2Q2YmYwYjIyNzJiNmUwNjlhZTkzMDg4NjgxMTI=", "commit": {"author": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-11-19T11:36:31Z"}, "committer": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-11-19T11:36:31Z"}, "message": "Rustfmt trans/base.rs.", "tree": {"sha": "060abb7b33bcded25cefdc8bd30cdfb39cabe9d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/060abb7b33bcded25cefdc8bd30cdfb39cabe9d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ccef0fdc553d6bf0b2272b6e069ae9308868112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccef0fdc553d6bf0b2272b6e069ae9308868112", "html_url": "https://github.com/rust-lang/rust/commit/3ccef0fdc553d6bf0b2272b6e069ae9308868112", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ccef0fdc553d6bf0b2272b6e069ae9308868112/comments", "author": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e48b0e380319dc586a329baac640b9457feb87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e48b0e380319dc586a329baac640b9457feb87a", "html_url": "https://github.com/rust-lang/rust/commit/3e48b0e380319dc586a329baac640b9457feb87a"}], "stats": {"total": 1046, "additions": 561, "deletions": 485}, "files": [{"sha": "884152015e6ee44d1c80261198b8f8425b25c704", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 561, "deletions": 485, "changes": 1046, "blob_url": "https://github.com/rust-lang/rust/blob/3ccef0fdc553d6bf0b2272b6e069ae9308868112/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccef0fdc553d6bf0b2272b6e069ae9308868112/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3ccef0fdc553d6bf0b2272b6e069ae9308868112", "patch": "@@ -110,8 +110,8 @@ thread_local! {\n     }\n }\n \n-pub fn with_insn_ctxt<F>(blk: F) where\n-    F: FnOnce(&[&'static str]),\n+pub fn with_insn_ctxt<F>(blk: F)\n+    where F: FnOnce(&[&'static str])\n {\n     TASK_LOCAL_INSN_KEY.with(move |slot| {\n         slot.borrow().as_ref().map(move |s| blk(s));\n@@ -125,14 +125,16 @@ pub fn init_insn_ctxt() {\n }\n \n pub struct _InsnCtxt {\n-    _cannot_construct_outside_of_this_module: ()\n+    _cannot_construct_outside_of_this_module: (),\n }\n \n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n         TASK_LOCAL_INSN_KEY.with(|slot| {\n             match slot.borrow_mut().as_mut() {\n-                Some(ctx) => { ctx.pop(); }\n+                Some(ctx) => {\n+                    ctx.pop();\n+                }\n                 None => {}\n             }\n         })\n@@ -147,7 +149,9 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n             None => {}\n         }\n     });\n-    _InsnCtxt { _cannot_construct_outside_of_this_module: () }\n+    _InsnCtxt {\n+        _cannot_construct_outside_of_this_module: (),\n+    }\n }\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n@@ -157,8 +161,7 @@ pub struct StatRecorder<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String)\n-               -> StatRecorder<'a, 'tcx> {\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n         let istart = ccx.stats().n_llvm_insns.get();\n         StatRecorder {\n             ccx: ccx,\n@@ -172,20 +175,26 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n             let iend = self.ccx.stats().n_llvm_insns.get();\n-            self.ccx.stats().fn_stats.borrow_mut().push((self.name.take().unwrap(),\n-                                                       iend - self.istart));\n+            self.ccx\n+                .stats()\n+                .fn_stats\n+                .borrow_mut()\n+                .push((self.name.take().unwrap(), iend - self.istart));\n             self.ccx.stats().n_fns.set(self.ccx.stats().n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n             self.ccx.stats().n_llvm_insns.set(self.istart);\n         }\n     }\n }\n \n-fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n-                                name: &str, did: DefId) -> ValueRef {\n+fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                fn_ty: Ty<'tcx>,\n+                                name: &str,\n+                                did: DefId)\n+                                -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n-        None => ()\n+        None => (),\n     }\n \n     let f = declare::declare_rust_fn(ccx, name, fn_ty);\n@@ -200,8 +209,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        closure_id: DefId,\n                                        fn_ty: Ty<'tcx>)\n-                                       -> Ty<'tcx>\n-{\n+                                       -> Ty<'tcx> {\n     let closure_kind = ccx.tcx().closure_kind(closure_id);\n     match closure_kind {\n         ty::FnClosureKind => {\n@@ -210,21 +218,23 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::FnMutClosureKind => {\n             ccx.tcx().mk_mut_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n-        ty::FnOnceClosureKind => fn_ty\n+        ty::FnOnceClosureKind => fn_ty,\n     }\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: DefId) -> ty::ClosureKind {\n     *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }\n \n-pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: DefId,\n-                                  t: Ty<'tcx>) -> ValueRef {\n+pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  did: DefId,\n+                                  t: Ty<'tcx>)\n+                                  -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n     match ccx.externs().borrow_mut().get(&name) {\n         Some(n) => return *n,\n-        None => ()\n+        None => (),\n     }\n     // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n     // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -247,8 +257,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: DefId,\n     return c;\n }\n \n-fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n+fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -271,16 +280,18 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n-        require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n-        &[size, align],\n-        None,\n-        debug_loc);\n+                                    require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n+                                    &[size, align],\n+                                    None,\n+                                    debug_loc);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n \n-pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: hir::BinOp_, signed: bool)\n+pub fn bin_op_to_icmp_predicate(ccx: &CrateContext,\n+                                op: hir::BinOp_,\n+                                signed: bool)\n                                 -> llvm::IntPredicate {\n     match op {\n         hir::BiEq => llvm::IntEQ,\n@@ -290,14 +301,15 @@ pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: hir::BinOp_, signed: boo\n         hir::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n         hir::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n-            ccx.sess().bug(&format!(\"comparison_op_to_icmp_predicate: expected \\\n-                                     comparison operator, found {:?}\", op));\n+            ccx.sess()\n+               .bug(&format!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n+                              found {:?}\",\n+                             op));\n         }\n     }\n }\n \n-pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_)\n-                                -> llvm::RealPredicate {\n+pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_) -> llvm::RealPredicate {\n     match op {\n         hir::BiEq => llvm::RealOEQ,\n         hir::BiNe => llvm::RealUNE,\n@@ -306,8 +318,10 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_)\n         hir::BiGt => llvm::RealOGT,\n         hir::BiGe => llvm::RealOGE,\n         op => {\n-            ccx.sess().bug(&format!(\"comparison_op_to_fcmp_predicate: expected \\\n-                                     comparison operator, found {:?}\", op));\n+            ccx.sess()\n+               .bug(&format!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n+                              found {:?}\",\n+                             op));\n         }\n     }\n }\n@@ -339,7 +353,7 @@ pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::BiLe => (llvm::IntULE, llvm::IntULT),\n                 hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n                 hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => unreachable!()\n+                _ => unreachable!(),\n             };\n \n             let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n@@ -370,14 +384,22 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::BiEq | hir::BiLe | hir::BiGe => return C_bool(bcx.ccx(), true),\n                 hir::BiNe | hir::BiLt | hir::BiGt => return C_bool(bcx.ccx(), false),\n                 // refinements would be nice\n-                _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\")\n+                _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\"),\n             }\n         }\n         ty::TyBareFn(..) | ty::TyBool | ty::TyUint(_) | ty::TyChar => {\n-            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n+            ICmp(bcx,\n+                 bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n+                 lhs,\n+                 rhs,\n+                 debug_loc)\n         }\n         ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n-            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n+            ICmp(bcx,\n+                 bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n+                 lhs,\n+                 rhs,\n+                 debug_loc)\n         }\n         ty::TyRawPtr(_) => {\n             let lhs_addr = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_ADDR]));\n@@ -386,18 +408,30 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n             let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n             compare_fat_ptrs(bcx,\n-                             lhs_addr, lhs_extra,\n-                             rhs_addr, rhs_extra,\n-                             t, op, debug_loc)\n+                             lhs_addr,\n+                             lhs_extra,\n+                             rhs_addr,\n+                             rhs_extra,\n+                             t,\n+                             op,\n+                             debug_loc)\n         }\n         ty::TyInt(_) => {\n-            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n+            ICmp(bcx,\n+                 bin_op_to_icmp_predicate(bcx.ccx(), op, true),\n+                 lhs,\n+                 rhs,\n+                 debug_loc)\n         }\n         ty::TyFloat(_) => {\n-            FCmp(bcx, bin_op_to_fcmp_predicate(bcx.ccx(), op), lhs, rhs, debug_loc)\n+            FCmp(bcx,\n+                 bin_op_to_fcmp_predicate(bcx.ccx(), op),\n+                 lhs,\n+                 rhs,\n+                 debug_loc)\n         }\n         // Should never get here, because t is scalar.\n-        _ => bcx.sess().bug(\"non-scalar type passed to compare_scalar_types\")\n+        _ => bcx.sess().bug(\"non-scalar type passed to compare_scalar_types\"),\n     }\n }\n \n@@ -432,8 +466,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                          av: ValueRef,\n                                          t: Ty<'tcx>,\n                                          mut f: F)\n-                                         -> Block<'blk, 'tcx> where\n-    F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+                                         -> Block<'blk, 'tcx>\n+    where F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>\n {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n@@ -443,16 +477,18 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    variant: ty::VariantDef<'tcx>,\n                                    substs: &Substs<'tcx>,\n                                    f: &mut F)\n-                                   -> Block<'blk, 'tcx> where\n-        F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+                                   -> Block<'blk, 'tcx>\n+        where F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>\n     {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            cx = f(cx, adt::trans_field_ptr(cx, repr, av, variant.disr_val, i), arg);\n+            cx = f(cx,\n+                   adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n+                   arg);\n         }\n         return cx;\n     }\n@@ -467,112 +503,106 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n \n     let mut cx = cx;\n     match t.sty {\n-      ty::TyStruct(..) => {\n-          let repr = adt::represent_type(cx.ccx(), t);\n-          let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n-          for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-              let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n-\n-              let val = if common::type_is_sized(cx.tcx(), field_ty) {\n-                  llfld_a\n-              } else {\n-                  let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n-                  Store(cx, llfld_a, expr::get_dataptr(cx, scratch.val));\n-                  Store(cx, info.unwrap(), expr::get_meta(cx, scratch.val));\n-                  scratch.val\n-              };\n-              cx = f(cx, val, field_ty);\n-          }\n-      }\n-      ty::TyClosure(_, ref substs) => {\n-          let repr = adt::represent_type(cx.ccx(), t);\n-          for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-              let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n-              cx = f(cx, llupvar, upvar_ty);\n-          }\n-      }\n-      ty::TyArray(_, n) => {\n-        let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n-        let unit_ty = t.sequence_element_type(cx.tcx());\n-        cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n-      }\n-      ty::TySlice(_) | ty::TyStr => {\n-        let unit_ty = t.sequence_element_type(cx.tcx());\n-        cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n-      }\n-      ty::TyTuple(ref args) => {\n-          let repr = adt::represent_type(cx.ccx(), t);\n-          for (i, arg) in args.iter().enumerate() {\n-              let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n-              cx = f(cx, llfld_a, *arg);\n-          }\n-      }\n-      ty::TyEnum(en, substs) => {\n-          let fcx = cx.fcx;\n-          let ccx = fcx.ccx;\n-\n-          let repr = adt::represent_type(ccx, t);\n-          let n_variants = en.variants.len();\n-\n-          // NB: we must hit the discriminant first so that structural\n-          // comparison know not to proceed when the discriminants differ.\n-\n-          match adt::trans_switch(cx, &*repr, av) {\n-              (_match::Single, None) => {\n-                  if n_variants != 0 {\n-                      assert!(n_variants == 1);\n-                      cx = iter_variant(cx, &*repr, av, &en.variants[0],\n-                                        substs, &mut f);\n-                  }\n-              }\n-              (_match::Switch, Some(lldiscrim_a)) => {\n-                  cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n-\n-                  // Create a fall-through basic block for the \"else\" case of\n-                  // the switch instruction we're about to generate. Note that\n-                  // we do **not** use an Unreachable instruction here, even\n-                  // though most of the time this basic block will never be hit.\n-                  //\n-                  // When an enum is dropped it's contents are currently\n-                  // overwritten to DTOR_DONE, which means the discriminant\n-                  // could have changed value to something not within the actual\n-                  // range of the discriminant. Currently this function is only\n-                  // used for drop glue so in this case we just return quickly\n-                  // from the outer function, and any other use case will only\n-                  // call this for an already-valid enum in which case the `ret\n-                  // void` will never be hit.\n-                  let ret_void_cx = fcx.new_temp_block(\"enum-iter-ret-void\");\n-                  RetVoid(ret_void_cx, DebugLoc::None);\n-                  let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb,\n-                                        n_variants);\n-                  let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n-\n-                  for variant in &en.variants {\n-                      let variant_cx =\n-                          fcx.new_temp_block(\n-                              &format!(\"enum-iter-variant-{}\",\n-                                      &variant.disr_val.to_string())\n-                              );\n-                      let case_val = adt::trans_case(cx, &*repr, variant.disr_val);\n-                      AddCase(llswitch, case_val, variant_cx.llbb);\n-                      let variant_cx =\n-                          iter_variant(variant_cx,\n-                                       &*repr,\n-                                       data_ptr,\n-                                       variant,\n-                                       substs,\n-                                       &mut f);\n-                      Br(variant_cx, next_cx.llbb, DebugLoc::None);\n-                  }\n-                  cx = next_cx;\n-              }\n-              _ => ccx.sess().unimpl(\"value from adt::trans_switch \\\n-                                      in iter_structural_ty\")\n-          }\n-      }\n-      _ => {\n-          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\", t))\n-      }\n+        ty::TyStruct(..) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+            for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n+                let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n+\n+                let val = if common::type_is_sized(cx.tcx(), field_ty) {\n+                    llfld_a\n+                } else {\n+                    let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n+                    Store(cx, llfld_a, expr::get_dataptr(cx, scratch.val));\n+                    Store(cx, info.unwrap(), expr::get_meta(cx, scratch.val));\n+                    scratch.val\n+                };\n+                cx = f(cx, val, field_ty);\n+            }\n+        }\n+        ty::TyClosure(_, ref substs) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n+                cx = f(cx, llupvar, upvar_ty);\n+            }\n+        }\n+        ty::TyArray(_, n) => {\n+            let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n+            cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n+            cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n+        }\n+        ty::TyTuple(ref args) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            for (i, arg) in args.iter().enumerate() {\n+                let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n+                cx = f(cx, llfld_a, *arg);\n+            }\n+        }\n+        ty::TyEnum(en, substs) => {\n+            let fcx = cx.fcx;\n+            let ccx = fcx.ccx;\n+\n+            let repr = adt::represent_type(ccx, t);\n+            let n_variants = en.variants.len();\n+\n+            // NB: we must hit the discriminant first so that structural\n+            // comparison know not to proceed when the discriminants differ.\n+\n+            match adt::trans_switch(cx, &*repr, av) {\n+                (_match::Single, None) => {\n+                    if n_variants != 0 {\n+                        assert!(n_variants == 1);\n+                        cx = iter_variant(cx, &*repr, av, &en.variants[0], substs, &mut f);\n+                    }\n+                }\n+                (_match::Switch, Some(lldiscrim_a)) => {\n+                    cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n+\n+                    // Create a fall-through basic block for the \"else\" case of\n+                    // the switch instruction we're about to generate. Note that\n+                    // we do **not** use an Unreachable instruction here, even\n+                    // though most of the time this basic block will never be hit.\n+                    //\n+                    // When an enum is dropped it's contents are currently\n+                    // overwritten to DTOR_DONE, which means the discriminant\n+                    // could have changed value to something not within the actual\n+                    // range of the discriminant. Currently this function is only\n+                    // used for drop glue so in this case we just return quickly\n+                    // from the outer function, and any other use case will only\n+                    // call this for an already-valid enum in which case the `ret\n+                    // void` will never be hit.\n+                    let ret_void_cx = fcx.new_temp_block(\"enum-iter-ret-void\");\n+                    RetVoid(ret_void_cx, DebugLoc::None);\n+                    let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n+                    let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n+\n+                    for variant in &en.variants {\n+                        let variant_cx = fcx.new_temp_block(&format!(\"enum-iter-variant-{}\",\n+                                                                     &variant.disr_val\n+                                                                             .to_string()));\n+                        let case_val = adt::trans_case(cx, &*repr, variant.disr_val);\n+                        AddCase(llswitch, case_val, variant_cx.llbb);\n+                        let variant_cx = iter_variant(variant_cx,\n+                                                      &*repr,\n+                                                      data_ptr,\n+                                                      variant,\n+                                                      substs,\n+                                                      &mut f);\n+                        Br(variant_cx, next_cx.llbb, DebugLoc::None);\n+                    }\n+                    cx = next_cx;\n+                }\n+                _ => ccx.sess().unimpl(\"value from adt::trans_switch in iter_structural_ty\"),\n+            }\n+        }\n+        _ => {\n+            cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\", t))\n+        }\n     }\n     return cx;\n }\n@@ -603,14 +633,16 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             // Note that we preserve binding levels here:\n             let substs = principal.0.substs.with_self_ty(source).erase_regions();\n             let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: substs });\n+            let trait_ref = ty::Binder(ty::TraitRef {\n+                def_id: principal.def_id(),\n+                substs: substs,\n+            });\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n         _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n-                                     target))\n+                                     target)),\n     }\n }\n \n@@ -634,8 +666,7 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             (PointerCast(bcx, src, ptr_ty),\n              unsized_info(bcx.ccx(), a, b, None, bcx.fcx.param_substs))\n         }\n-        _ => bcx.sess().bug(\n-            &format!(\"unsize_thin_ptr: called on bad types\"))\n+        _ => bcx.sess().bug(&format!(\"unsize_thin_ptr: called on bad types\")),\n     }\n }\n \n@@ -669,50 +700,43 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n             let src_fields = match &*src_repr {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().bug(\"struct has non-univariant repr\")\n+                _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n             };\n             let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n             let dst_fields = match &*dst_repr {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().bug(\"struct has non-univariant repr\")\n+                _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n             };\n \n             let iter = src_fields.iter().zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n-                if type_is_zero_size(bcx.ccx(), dst_fty) { continue; }\n+                if type_is_zero_size(bcx.ccx(), dst_fty) {\n+                    continue;\n+                }\n \n                 let src_f = adt::trans_field_ptr(bcx, &src_repr, src, 0, i);\n                 let dst_f = adt::trans_field_ptr(bcx, &dst_repr, dst, 0, i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty);\n                 } else {\n-                    coerce_unsized_into(\n-                        bcx,\n-                        src_f, src_fty,\n-                        dst_f, dst_fty\n-                    );\n+                    coerce_unsized_into(bcx, src_f, src_fty, dst_f, dst_fty);\n                 }\n             }\n         }\n         _ => bcx.sess().bug(&format!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n                                      src_ty,\n-                                     dst_ty))\n+                                     dst_ty)),\n     }\n }\n \n-pub fn cast_shift_expr_rhs(cx: Block,\n-                           op: hir::BinOp_,\n-                           lhs: ValueRef,\n-                           rhs: ValueRef)\n-                           -> ValueRef {\n-    cast_shift_rhs(op, lhs, rhs,\n-                   |a,b| Trunc(cx, a, b),\n-                   |a,b| ZExt(cx, a, b))\n+pub fn cast_shift_expr_rhs(cx: Block, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    cast_shift_rhs(op, lhs, rhs, |a, b| Trunc(cx, a, b), |a, b| ZExt(cx, a, b))\n }\n \n-pub fn cast_shift_const_rhs(op: hir::BinOp_,\n-                            lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    cast_shift_rhs(op, lhs, rhs,\n+pub fn cast_shift_const_rhs(op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    cast_shift_rhs(op,\n+                   lhs,\n+                   rhs,\n                    |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n                    |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n@@ -722,16 +746,20 @@ fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n                         rhs: ValueRef,\n                         trunc: F,\n                         zext: G)\n-                        -> ValueRef where\n-    F: FnOnce(ValueRef, Type) -> ValueRef,\n-    G: FnOnce(ValueRef, Type) -> ValueRef,\n+                        -> ValueRef\n+    where F: FnOnce(ValueRef, Type) -> ValueRef,\n+          G: FnOnce(ValueRef, Type) -> ValueRef\n {\n     // Shifts may have any size int on the rhs\n     if rustc_front::util::is_shift_binop(op) {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n-        if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }\n-        if lhs_llty.kind() == Vector { lhs_llty = lhs_llty.element_type() }\n+        if rhs_llty.kind() == Vector {\n+            rhs_llty = rhs_llty.element_type()\n+        }\n+        if lhs_llty.kind() == Vector {\n+            lhs_llty = lhs_llty.element_type()\n+        }\n         let rhs_sz = rhs_llty.int_width();\n         let lhs_sz = lhs_llty.int_width();\n         if lhs_sz < rhs_sz {\n@@ -749,7 +777,8 @@ fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n }\n \n pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                              val_t: Ty<'tcx>) -> (Type, u64) {\n+                                              val_t: Ty<'tcx>)\n+                                              -> (Type, u64) {\n     match val_t.sty {\n         ty::TyInt(t) => {\n             let llty = Type::int_from_ty(cx.ccx(), t);\n@@ -767,14 +796,13 @@ pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n-                                cx: Block<'blk, 'tcx>,\n-                                call_info: NodeIdAndSpan,\n-                                divrem: hir::BinOp,\n-                                lhs: ValueRef,\n-                                rhs: ValueRef,\n-                                rhs_t: Ty<'tcx>)\n-                                -> Block<'blk, 'tcx> {\n+pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                             call_info: NodeIdAndSpan,\n+                                             divrem: hir::BinOp,\n+                                             lhs: ValueRef,\n+                                             rhs: ValueRef,\n+                                             rhs_t: Ty<'tcx>)\n+                                             -> Block<'blk, 'tcx> {\n     let (zero_text, overflow_text) = if divrem.node == hir::BiDiv {\n         (\"attempted to divide by zero\",\n          \"attempted to divide with overflow\")\n@@ -795,10 +823,11 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         ty::TyStruct(def, _) if def.is_simd() => {\n             let mut res = C_bool(cx.ccx(), false);\n-            for i in 0 .. rhs_t.simd_size(cx.tcx()) {\n-                res = Or(cx, res,\n-                         IsNull(cx,\n-                                ExtractElement(cx, rhs, C_int(cx.ccx(), i as i64))), debug_loc);\n+            for i in 0..rhs_t.simd_size(cx.tcx()) {\n+                res = Or(cx,\n+                         res,\n+                         IsNull(cx, ExtractElement(cx, rhs, C_int(cx.ccx(), i as i64))),\n+                         debug_loc);\n             }\n             (res, false)\n         }\n@@ -821,15 +850,19 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     // integers, no action beyond checking for zero need be taken.\n     if is_signed {\n         let (llty, min) = llty_and_min_for_signed_ty(cx, rhs_t);\n-        let minus_one = ICmp(bcx, llvm::IntEQ, rhs,\n-                             C_integral(llty, !0, false), debug_loc);\n+        let minus_one = ICmp(bcx,\n+                             llvm::IntEQ,\n+                             rhs,\n+                             C_integral(llty, !0, false),\n+                             debug_loc);\n         with_cond(bcx, minus_one, |bcx| {\n-            let is_min = ICmp(bcx, llvm::IntEQ, lhs,\n-                              C_integral(llty, min, true), debug_loc);\n+            let is_min = ICmp(bcx,\n+                              llvm::IntEQ,\n+                              lhs,\n+                              C_integral(llty, min, true),\n+                              debug_loc);\n             with_cond(bcx, is_min, |bcx| {\n-                controlflow::trans_fail(bcx,\n-                                        call_info,\n-                                        InternedString::new(overflow_text))\n+                controlflow::trans_fail(bcx, call_info, InternedString::new(overflow_text))\n             })\n         })\n     } else {\n@@ -838,7 +871,9 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n }\n \n pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     did: DefId, t: Ty<'tcx>) -> ValueRef {\n+                                     did: DefId,\n+                                     t: Ty<'tcx>)\n+                                     -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n@@ -905,11 +940,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n-        let llresult = Call(bcx,\n-                            llfn,\n-                            &llargs[..],\n-                            Some(attributes),\n-                            debug_loc);\n+        let llresult = Call(bcx, llfn, &llargs[..], Some(attributes), debug_loc);\n         return (llresult, bcx);\n     }\n }\n@@ -941,18 +972,18 @@ pub fn need_invoke(bcx: Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                     v: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n-    if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n+    if type_is_immediate(cx.ccx(), t) {\n+        return load_ty(cx, v, t);\n+    }\n     return v;\n }\n \n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n-pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                           ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     if cx.unreachable.get() || type_is_zero_size(cx.ccx(), t) {\n         return C_undef(type_of::type_of(cx.ccx(), t));\n     }\n@@ -978,15 +1009,14 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let val =  if t.is_bool() {\n+    let val = if t.is_bool() {\n         LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n     } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (t.is_region_ptr() || t.is_unique())\n-        && !common::type_is_fat_ptr(cx.tcx(), t) {\n-            LoadNonNull(cx, ptr)\n+    } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(cx.tcx(), t) {\n+        LoadNonNull(cx, ptr)\n     } else {\n         Load(cx, ptr)\n     };\n@@ -1006,12 +1036,17 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     }\n \n     debug!(\"store_ty: {} : {:?} <- {}\",\n-           cx.val_to_string(dst), t,\n+           cx.val_to_string(dst),\n+           t,\n            cx.val_to_string(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n-        Store(cx, ExtractValue(cx, v, abi::FAT_PTR_ADDR), expr::get_dataptr(cx, dst));\n-        Store(cx, ExtractValue(cx, v, abi::FAT_PTR_EXTRA), expr::get_meta(cx, dst));\n+        Store(cx,\n+              ExtractValue(cx, v, abi::FAT_PTR_ADDR),\n+              expr::get_dataptr(cx, dst));\n+        Store(cx,\n+              ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n+              expr::get_meta(cx, dst));\n     } else {\n         let store = Store(cx, from_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n         unsafe {\n@@ -1032,8 +1067,8 @@ pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 src: ValueRef,\n-                                _ty: Ty<'tcx>) -> (ValueRef, ValueRef)\n-{\n+                                _ty: Ty<'tcx>)\n+                                -> (ValueRef, ValueRef) {\n     // FIXME: emit metadata\n     (Load(cx, expr::get_dataptr(cx, src)),\n      Load(cx, expr::get_meta(cx, src)))\n@@ -1066,8 +1101,7 @@ pub fn to_arg_ty_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef, ty: Ty<'\n     }\n }\n \n-pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &hir::Local)\n-                              -> Block<'blk, 'tcx> {\n+pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &hir::Local) -> Block<'blk, 'tcx> {\n     debug!(\"init_local(bcx={}, local.id={})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"init_local\");\n@@ -1081,11 +1115,8 @@ pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n     common::BlockS::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                val: ValueRef,\n-                                f: F)\n-                                -> Block<'blk, 'tcx> where\n-    F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>,\n+pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) -> Block<'blk, 'tcx>\n+    where F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>\n {\n     let _icx = push_ctxt(\"with_cond\");\n \n@@ -1119,7 +1150,11 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n \n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx, lifetime_start, &[C_u64(ccx, size), ptr], None, DebugLoc::None);\n+    Call(cx,\n+         lifetime_start,\n+         &[C_u64(ccx, size), ptr],\n+         None,\n+         DebugLoc::None);\n }\n \n pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n@@ -1137,7 +1172,11 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n \n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx, lifetime_end, &[C_u64(ccx, size), ptr], None, DebugLoc::None);\n+    Call(cx,\n+         lifetime_end,\n+         &[C_u64(ccx, size), ptr],\n+         None,\n+         DebugLoc::None);\n }\n \n // Generates code for resumption of unwind at the end of a landing pad.\n@@ -1164,12 +1203,14 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None, DebugLoc::None);\n+    Call(cx,\n+         memcpy,\n+         &[dst_ptr, src_ptr, size, align, volatile],\n+         None,\n+         DebugLoc::None);\n }\n \n-pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             dst: ValueRef, src: ValueRef,\n-                             t: Ty<'tcx>) {\n+pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n \n@@ -1188,14 +1229,18 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn drop_done_fill_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n-    if cx.unreachable.get() { return; }\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     let _icx = push_ctxt(\"drop_done_fill_mem\");\n     let bcx = cx;\n     memfill(&B(bcx), llptr, t, adt::DTOR_DONE);\n }\n \n pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n-    if cx.unreachable.get() { return; }\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     let _icx = push_ctxt(\"init_zero_mem\");\n     let bcx = cx;\n     memfill(&B(bcx), llptr, t, 0);\n@@ -1220,7 +1265,9 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n-    b.call(llintrinsicfn, &[llptr, llzeroval, size, align, volatile], None);\n+    b.call(llintrinsicfn,\n+           &[llptr, llzeroval, size, align, volatile],\n+           None);\n }\n \n pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) -> ValueRef {\n@@ -1251,7 +1298,8 @@ pub fn set_value_name(val: ValueRef, name: &str) {\n \n // Creates the alloca slot which holds the pointer to the slot for the final return value\n pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                                          output_type: Ty<'tcx>) -> ValueRef {\n+                                          output_type: Ty<'tcx>)\n+                                          -> ValueRef {\n     let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n \n     // We create an alloca to hold a pointer of type `output_type`\n@@ -1289,7 +1337,9 @@ struct FindNestedReturn {\n \n impl FindNestedReturn {\n     fn new() -> FindNestedReturn {\n-        FindNestedReturn { found: false }\n+        FindNestedReturn {\n+            found: false,\n+        }\n     }\n }\n \n@@ -1299,7 +1349,7 @@ impl<'v> Visitor<'v> for FindNestedReturn {\n             hir::ExprRet(..) => {\n                 self.found = true;\n             }\n-            _ => intravisit::walk_expr(self, e)\n+            _ => intravisit::walk_expr(self, e),\n         }\n     }\n }\n@@ -1311,31 +1361,30 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n                 hir::ItemFn(_, _, _, _, _, ref blk) => {\n                     blk\n                 }\n-                _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n+                _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\"),\n             }\n         }\n         Some(hir_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n                 hir::MethodTraitItem(_, Some(ref body)) => body,\n                 _ => {\n-                    tcx.sess.bug(\"unexpected variant: trait item other than a \\\n-                                  provided method in has_nested_returns\")\n+                    tcx.sess.bug(\"unexpected variant: trait item other than a provided method in \\\n+                                  has_nested_returns\")\n                 }\n             }\n         }\n         Some(hir_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n                 hir::ImplItemKind::Method(_, ref body) => body,\n                 _ => {\n-                    tcx.sess.bug(\"unexpected variant: non-method impl item in \\\n-                                  has_nested_returns\")\n+                    tcx.sess.bug(\"unexpected variant: non-method impl item in has_nested_returns\")\n                 }\n             }\n         }\n         Some(hir_map::NodeExpr(e)) => {\n             match e.node {\n                 hir::ExprClosure(_, _, ref blk) => blk,\n-                _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n+                _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\"),\n             }\n         }\n         Some(hir_map::NodeVariant(..)) |\n@@ -1345,7 +1394,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n         _ => tcx.sess.bug(&format!(\"unexpected variant in has_nested_returns: {}\",\n-                                   tcx.map.path_to_string(id)))\n+                                   tcx.map.path_to_string(id))),\n     };\n \n     (blk.id, Some(cfg::CFG::new(tcx, blk)))\n@@ -1414,15 +1463,17 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n            } else {\n                ccx.tcx().map.path_to_string(id).to_string()\n            },\n-           id, param_substs);\n+           id,\n+           param_substs);\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n-            let substd_output_type =\n-                monomorphize::apply_param_substs(ccx.tcx(), param_substs, &output_type);\n+            let substd_output_type = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                                      param_substs,\n+                                                                      &output_type);\n             type_of::return_uses_outptr(ccx, substd_output_type)\n         }\n-        ty::FnDiverging => false\n+        ty::FnDiverging => false,\n     };\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n     let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n@@ -1435,27 +1486,27 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let mir = ccx.mir_map().get(&id);\n \n     let mut fcx = FunctionContext {\n-          mir: mir,\n-          llfn: llfndecl,\n-          llenv: None,\n-          llretslotptr: Cell::new(None),\n-          param_env: ccx.tcx().empty_parameter_environment(),\n-          alloca_insert_pt: Cell::new(None),\n-          llreturn: Cell::new(None),\n-          needs_ret_allocas: nested_returns,\n-          personality: Cell::new(None),\n-          caller_expects_out_pointer: uses_outptr,\n-          lllocals: RefCell::new(NodeMap()),\n-          llupvars: RefCell::new(NodeMap()),\n-          lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n-          id: id,\n-          param_substs: param_substs,\n-          span: sp,\n-          block_arena: block_arena,\n-          ccx: ccx,\n-          debug_context: debug_context,\n-          scopes: RefCell::new(Vec::new()),\n-          cfg: cfg\n+        mir: mir,\n+        llfn: llfndecl,\n+        llenv: None,\n+        llretslotptr: Cell::new(None),\n+        param_env: ccx.tcx().empty_parameter_environment(),\n+        alloca_insert_pt: Cell::new(None),\n+        llreturn: Cell::new(None),\n+        needs_ret_allocas: nested_returns,\n+        personality: Cell::new(None),\n+        caller_expects_out_pointer: uses_outptr,\n+        lllocals: RefCell::new(NodeMap()),\n+        llupvars: RefCell::new(NodeMap()),\n+        lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n+        id: id,\n+        param_substs: param_substs,\n+        span: sp,\n+        block_arena: block_arena,\n+        ccx: ccx,\n+        debug_context: debug_context,\n+        scopes: RefCell::new(Vec::new()),\n+        cfg: cfg,\n     };\n \n     if has_env {\n@@ -1553,8 +1604,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n //  - new_fn_ctxt\n //  - trans_args\n \n-pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n-                          -> datum::Rvalue {\n+pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>) -> datum::Rvalue {\n     use trans::datum::{ByRef, ByValue};\n \n     datum::Rvalue {\n@@ -1587,8 +1637,8 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n     let mut idx = fcx.arg_offset() as c_uint;\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n-            if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n-                    && bcx.sess().opts.debuginfo != FullDebugInfo {\n+            if type_of::arg_is_indirect(bcx.ccx(), arg_ty) &&\n+               bcx.sess().opts.debuginfo != FullDebugInfo {\n                 // Don't copy an indirect argument to an alloca, the caller\n                 // already put it in a temporary alloca and gave it up, unless\n                 // we emit extra-debug-info, which requires local allocas :(.\n@@ -1597,7 +1647,9 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n                 bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n \n-                datum::Datum::new(llarg, arg_ty, datum::Lvalue::new(\"create_datum_for_fn_args\"))\n+                datum::Datum::new(llarg,\n+                                  arg_ty,\n+                                  datum::Lvalue::new(\"create_datum_for_fn_args\"))\n             } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 let data = get_param(fcx.llfn, idx);\n                 let extra = get_param(fcx.llfn, idx + 1);\n@@ -1613,9 +1665,13 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 let llarg = get_param(fcx.llfn, idx);\n                 idx += 1;\n                 let tmp = datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty));\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n-                                                           arg_scope_id, tmp,\n-                                                           |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n+                unpack_datum!(bcx,\n+                              datum::lvalue_scratch_datum(bcx,\n+                                                          arg_ty,\n+                                                          \"\",\n+                                                          arg_scope_id,\n+                                                          tmp,\n+                                                          |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n             }\n         } else {\n             // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n@@ -1652,8 +1708,9 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                     }))\n                 }\n                 _ => {\n-                    bcx.tcx().sess.bug(\"last argument of a function with \\\n-                                        `rust-call` ABI isn't a tuple?!\")\n+                    bcx.tcx()\n+                       .sess\n+                       .bug(\"last argument of a function with `rust-call` ABI isn't a tuple?!\")\n                 }\n             }\n         };\n@@ -1691,7 +1748,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n             }\n             raw_block(fcx, false, llreturn)\n         }\n-        None => last_bcx\n+        None => last_bcx,\n     };\n \n     // This shouldn't need to recompute the return type,\n@@ -1762,7 +1819,7 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                     Ret(ret_cx, C_undef(Type::nil(fcx.ccx)), ret_debug_location)\n                 }\n             }\n-        }\n+        },\n     }\n }\n \n@@ -1784,8 +1841,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n \n-    debug!(\"trans_closure(..., param_substs={:?})\",\n-           param_substs);\n+    debug!(\"trans_closure(..., param_substs={:?})\", param_substs);\n \n     let has_env = match closure_env {\n         closure::ClosureEnv::Closure(..) => true,\n@@ -1811,17 +1867,19 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // cleanup scope for the incoming arguments\n-    let fn_cleanup_debug_loc =\n-        debuginfo::get_cleanup_debug_loc_for_ast_node(ccx, fn_ast_id, body.span, true);\n+    let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(ccx,\n+                                                                             fn_ast_id,\n+                                                                             body.span,\n+                                                                             true);\n     let arg_scope = fcx.push_custom_cleanup_scope_with_debug_loc(fn_cleanup_debug_loc);\n \n     let block_ty = node_id_type(bcx, body.id);\n \n     // Set up arguments to the function.\n-    let monomorphized_arg_types =\n-        decl.inputs.iter()\n-                   .map(|arg| node_id_type(bcx, arg.id))\n-                   .collect::<Vec<_>>();\n+    let monomorphized_arg_types = decl.inputs\n+                                      .iter()\n+                                      .map(|arg| node_id_type(bcx, arg.id))\n+                                      .collect::<Vec<_>>();\n     for monomorphized_arg_type in &monomorphized_arg_types {\n         debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n                monomorphized_arg_type);\n@@ -1831,11 +1889,14 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let has_tupled_arg = match closure_env {\n         closure::ClosureEnv::NotClosure => abi == RustCall,\n-        _ => false\n+        _ => false,\n     };\n \n-    bcx = create_datums_for_fn_args(bcx, &decl.inputs, &monomorphized_arg_types,\n-                                    has_tupled_arg, arg_scope);\n+    bcx = create_datums_for_fn_args(bcx,\n+                                    &decl.inputs,\n+                                    &monomorphized_arg_types,\n+                                    has_tupled_arg,\n+                                    arg_scope);\n \n     bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n@@ -1886,8 +1947,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id,\n-                                     fn_cleanup_debug_loc.span);\n+    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id, fn_cleanup_debug_loc.span);\n \n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n@@ -1911,7 +1971,15 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     let output_type = sig.output;\n     let abi = fn_ty.fn_abi();\n-    trans_closure(ccx, decl, body, llfndecl, param_substs, id, attrs, output_type, abi,\n+    trans_closure(ccx,\n+                  decl,\n+                  body,\n+                  llfndecl,\n+                  param_substs,\n+                  id,\n+                  attrs,\n+                  output_type,\n+                  abi,\n                   closure::ClosureEnv::NotClosure);\n }\n \n@@ -1922,12 +1990,7 @@ pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n-    trans_enum_variant_or_tuple_like_struct(\n-        ccx,\n-        ctor_id,\n-        disr,\n-        param_substs,\n-        llfndecl);\n+    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, disr, param_substs, llfndecl);\n }\n \n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n@@ -1971,7 +2034,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       expr::SaveIn(llresult),\n                                       debug_loc);\n             }\n-            _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")\n+            _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\"),\n         }\n     } else {\n         // Just eval all the expressions (if any). Since expressions in Rust can have arbitrary\n@@ -1982,7 +2045,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     bcx = expr::trans_into(bcx, expr, expr::Ignore);\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -2008,12 +2071,7 @@ pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n-    trans_enum_variant_or_tuple_like_struct(\n-        ccx,\n-        ctor_id,\n-        0,\n-        param_substs,\n-        llfndecl);\n+    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, 0, param_substs, llfndecl);\n }\n \n fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2031,8 +2089,14 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n-                      param_substs, None, &arena);\n+    fcx = new_fn_ctxt(ccx,\n+                      llfndecl,\n+                      ctor_id,\n+                      false,\n+                      result_ty,\n+                      param_substs,\n+                      None,\n+                      &arena);\n     let bcx = init_function(&fcx, false, result_ty);\n \n     assert!(!fcx.needs_ret_allocas);\n@@ -2042,14 +2106,14 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n         let mut llarg_idx = fcx.arg_offset() as c_uint;\n         for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx,\n-                                                 &*repr,\n-                                                 dest,\n-                                                 disr,\n-                                                 i);\n+            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest, disr, i);\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                Store(bcx, get_param(fcx.llfn, llarg_idx), expr::get_dataptr(bcx, lldestptr));\n-                Store(bcx, get_param(fcx.llfn, llarg_idx + 1), expr::get_meta(bcx, lldestptr));\n+                Store(bcx,\n+                      get_param(fcx.llfn, llarg_idx),\n+                      expr::get_dataptr(bcx, lldestptr));\n+                Store(bcx,\n+                      get_param(fcx.llfn, llarg_idx + 1),\n+                      expr::get_meta(bcx, lldestptr));\n                 llarg_idx += 2;\n             } else {\n                 let arg = get_param(fcx.llfn, llarg_idx);\n@@ -2080,7 +2144,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n \n     if is_allow && !print_info {\n         // we're not interested in anything here\n-        return\n+        return;\n     }\n \n     let ty = ccx.tcx().node_id_to_type(id);\n@@ -2118,8 +2182,9 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n         match *avar {\n             adt::General(..) => {\n                 for (i, var) in enum_def.variants.iter().enumerate() {\n-                    ccx.tcx().sess.span_note(var.span,\n-                                             &*format!(\"variant data: {} bytes\", sizes[i]));\n+                    ccx.tcx()\n+                       .sess\n+                       .span_note(var.span, &*format!(\"variant data: {} bytes\", sizes[i]));\n                 }\n             }\n             _ => {}\n@@ -2131,11 +2196,13 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n     if !is_allow && largest > slargest * 3 && slargest > 0 {\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n-        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCES,\n-                            *lvlsrc.unwrap(), Some(sp),\n-                            &format!(\"enum variant is more than three times larger \\\n-                                     ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest));\n+        lint::raw_emit_lint(&ccx.tcx().sess,\n+                            lint::builtin::VARIANT_SIZE_DIFFERENCES,\n+                            *lvlsrc.unwrap(),\n+                            Some(sp),\n+                            &format!(\"enum variant is more than three times larger ({} bytes) \\\n+                                      than the next largest (ignoring padding)\",\n+                                     largest));\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2236,12 +2303,10 @@ pub fn update_linkage(ccx: &CrateContext,\n }\n \n fn set_global_section(ccx: &CrateContext, llval: ValueRef, i: &hir::Item) {\n-    match attr::first_attr_value_str_by_name(&i.attrs,\n-                                             \"link_section\") {\n+    match attr::first_attr_value_str_by_name(&i.attrs, \"link_section\") {\n         Some(sect) => {\n             if contains_null(&sect) {\n-                ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n-                                            &sect));\n+                ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n             }\n             unsafe {\n                 let buf = CString::new(sect.as_bytes()).unwrap();\n@@ -2258,74 +2323,88 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n \n     match item.node {\n-      hir::ItemFn(ref decl, _, _, abi, ref generics, ref body) => {\n-        if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(&item.attrs);\n-            // Ignore `trans_everywhere` for cross-crate inlined items\n-            // (`from_external`).  `trans_item` will be called once for each\n-            // compilation unit that references the item, so it will still get\n-            // translated everywhere it's needed.\n-            for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-                let llfn = get_item_val(ccx, item.id);\n-                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                if abi != Rust {\n-                    foreign::trans_rust_fn_with_foreign_abi(ccx, &**decl, &**body, &item.attrs,\n-                                                            llfn, empty_substs, item.id, None);\n-                } else {\n-                    trans_fn(ccx, &**decl, &**body, llfn, empty_substs, item.id, &item.attrs);\n-                }\n-                set_global_section(ccx, llfn, item);\n-                update_linkage(ccx, llfn, Some(item.id),\n-                               if is_origin { OriginalTranslation } else { InlinedCopy });\n-\n-                if is_entry_fn(ccx.sess(), item.id) {\n-                    create_entry_wrapper(ccx, item.span, llfn);\n-                    // check for the #[rustc_error] annotation, which forces an\n-                    // error in trans. This is used to write compile-fail tests\n-                    // that actually test that compilation succeeds without\n-                    // reporting an error.\n-                    let item_def_id = ccx.tcx().map.local_def_id(item.id);\n-                    if ccx.tcx().has_attr(item_def_id, \"rustc_error\") {\n-                        ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n+        hir::ItemFn(ref decl, _, _, abi, ref generics, ref body) => {\n+            if !generics.is_type_parameterized() {\n+                let trans_everywhere = attr::requests_inline(&item.attrs);\n+                // Ignore `trans_everywhere` for cross-crate inlined items\n+                // (`from_external`).  `trans_item` will be called once for each\n+                // compilation unit that references the item, so it will still get\n+                // translated everywhere it's needed.\n+                for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n+                    let llfn = get_item_val(ccx, item.id);\n+                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                    if abi != Rust {\n+                        foreign::trans_rust_fn_with_foreign_abi(ccx,\n+                                                                &**decl,\n+                                                                &**body,\n+                                                                &item.attrs,\n+                                                                llfn,\n+                                                                empty_substs,\n+                                                                item.id,\n+                                                                None);\n+                    } else {\n+                        trans_fn(ccx,\n+                                 &**decl,\n+                                 &**body,\n+                                 llfn,\n+                                 empty_substs,\n+                                 item.id,\n+                                 &item.attrs);\n+                    }\n+                    set_global_section(ccx, llfn, item);\n+                    update_linkage(ccx,\n+                                   llfn,\n+                                   Some(item.id),\n+                                   if is_origin {\n+                                       OriginalTranslation\n+                                   } else {\n+                                       InlinedCopy\n+                                   });\n+\n+                    if is_entry_fn(ccx.sess(), item.id) {\n+                        create_entry_wrapper(ccx, item.span, llfn);\n+                        // check for the #[rustc_error] annotation, which forces an\n+                        // error in trans. This is used to write compile-fail tests\n+                        // that actually test that compilation succeeds without\n+                        // reporting an error.\n+                        let item_def_id = ccx.tcx().map.local_def_id(item.id);\n+                        if ccx.tcx().has_attr(item_def_id, \"rustc_error\") {\n+                            ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n+                        }\n                     }\n                 }\n             }\n         }\n-      }\n-      hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n-        meth::trans_impl(ccx,\n-                         item.name,\n-                         &impl_items[..],\n-                         generics,\n-                         item.id);\n-      }\n-      hir::ItemMod(_) => {\n-          // modules have no equivalent at runtime, they just affect\n-          // the mangled names of things contained within\n-      }\n-      hir::ItemEnum(ref enum_definition, ref gens) => {\n-        if gens.ty_params.is_empty() {\n-            // sizes only make sense for non-generic types\n-\n-            enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n-        }\n-      }\n-      hir::ItemConst(..) => {\n-      }\n-      hir::ItemStatic(_, m, ref expr) => {\n-          let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n-              Ok(g) => g,\n-              Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n-          };\n-          set_global_section(ccx, g, item);\n-          update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n-      },\n-      hir::ItemForeignMod(ref foreign_mod) => {\n-        foreign::trans_foreign_mod(ccx, foreign_mod);\n-      }\n-      hir::ItemTrait(..) => {\n-      }\n-      _ => {/* fall through */ }\n+        hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n+            meth::trans_impl(ccx, item.name, &impl_items[..], generics, item.id);\n+        }\n+        hir::ItemMod(_) => {\n+            // modules have no equivalent at runtime, they just affect\n+            // the mangled names of things contained within\n+        }\n+        hir::ItemEnum(ref enum_definition, ref gens) => {\n+            if gens.ty_params.is_empty() {\n+                // sizes only make sense for non-generic types\n+\n+                enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n+            }\n+        }\n+        hir::ItemConst(..) => {}\n+        hir::ItemStatic(_, m, ref expr) => {\n+            let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n+                Ok(g) => g,\n+                Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+            };\n+            set_global_section(ccx, g, item);\n+            update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n+        }\n+        hir::ItemForeignMod(ref foreign_mod) => {\n+            foreign::trans_foreign_mod(ccx, foreign_mod);\n+        }\n+        hir::ItemTrait(..) => {}\n+        _ => {\n+            // fall through\n+        }\n     }\n }\n \n@@ -2334,8 +2413,9 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n                           sym: String,\n                           node_id: ast::NodeId,\n-                      cc: llvm::CallConv,\n-                          llfty: Type) -> ValueRef {\n+                          cc: llvm::CallConv,\n+                          llfty: Type)\n+                          -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n@@ -2358,15 +2438,18 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          -> ValueRef {\n     if let ty::TyBareFn(_, ref f) = node_type.sty {\n         if f.abi != Rust && f.abi != RustCall {\n-            ccx.sess().span_bug(sp, &format!(\"only the `{}` or `{}` calling conventions are valid \\\n-                                              for this function; `{}` was specified\",\n-                                              Rust.name(), RustCall.name(), f.abi.name()));\n+            ccx.sess().span_bug(sp,\n+                                &format!(\"only the `{}` or `{}` calling conventions are valid \\\n+                                          for this function; `{}` was specified\",\n+                                         Rust.name(),\n+                                         RustCall.name(),\n+                                         f.abi.name()));\n         }\n     } else {\n         ccx.sess().span_bug(sp, \"expected bare rust function\")\n     }\n \n-    let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(||{\n+    let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(|| {\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n     finish_register_fn(ccx, sym, node_id);\n@@ -2376,15 +2459,13 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n     match *sess.entry_fn.borrow() {\n         Some((entry_id, _)) => node_id == entry_id,\n-        None => false\n+        None => false,\n     }\n }\n \n /// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n /// function.\n-pub fn create_entry_wrapper(ccx: &CrateContext,\n-                            sp: Span,\n-                            main_llfn: ValueRef) {\n+pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n@@ -2398,11 +2479,9 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                        sp: Span,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()],\n-                               &ccx.int_type());\n+        let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()], &ccx.int_type());\n \n-        let llfn = declare::define_cfn(ccx, \"main\", llfty,\n-                                       ccx.tcx().mk_nil()).unwrap_or_else(||{\n+        let llfn = declare::define_cfn(ccx, \"main\", llfty, ccx.tcx().mk_nil()).unwrap_or_else(|| {\n             ccx.sess().span_err(sp, \"entry symbol `main` defined multiple times\");\n             // FIXME: We should be smart and show a better diagnostic here.\n             ccx.sess().help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\");\n@@ -2411,8 +2490,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         });\n \n         let llbb = unsafe {\n-            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn,\n-                                                \"top\\0\".as_ptr() as *const _)\n+            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, \"top\\0\".as_ptr() as *const _)\n         };\n         let bld = ccx.raw_builder();\n         unsafe {\n@@ -2423,35 +2501,32 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(&s[..]); }\n+                    Err(s) => {\n+                        ccx.sess().fatal(&s[..]);\n+                    }\n+                };\n+                let start_fn = if let Some(start_node_id) = ccx.tcx()\n+                                                               .map\n+                                                               .as_local_node_id(start_def_id) {\n+                    get_item_val(ccx, start_node_id)\n+                } else {\n+                    let start_fn_type = csearch::get_type(ccx.tcx(), start_def_id).ty;\n+                    trans_external_path(ccx, start_def_id, start_fn_type)\n                 };\n-                let start_fn =\n-                    if let Some(start_node_id) = ccx.tcx().map.as_local_node_id(start_def_id) {\n-                        get_item_val(ccx, start_node_id)\n-                    } else {\n-                        let start_fn_type = csearch::get_type(ccx.tcx(),\n-                                                              start_def_id).ty;\n-                        trans_external_path(ccx, start_def_id, start_fn_type)\n-                    };\n \n                 let args = {\n-                    let opaque_rust_main = llvm::LLVMBuildPointerCast(bld,\n-                        rust_main, Type::i8p(ccx).to_ref(),\n-                        \"rust_main\\0\".as_ptr() as *const _);\n-\n-                    vec!(\n-                        opaque_rust_main,\n-                        get_param(llfn, 0),\n-                        get_param(llfn, 1)\n-                     )\n+                    let opaque_rust_main =\n+                        llvm::LLVMBuildPointerCast(bld,\n+                                                   rust_main,\n+                                                   Type::i8p(ccx).to_ref(),\n+                                                   \"rust_main\\0\".as_ptr() as *const _);\n+\n+                    vec![opaque_rust_main, get_param(llfn, 0), get_param(llfn, 1)]\n                 };\n                 (start_fn, args)\n             } else {\n                 debug!(\"using user-defined start fn\");\n-                let args = vec!(\n-                    get_param(llfn, 0 as c_uint),\n-                    get_param(llfn, 1 as c_uint)\n-                );\n+                let args = vec![get_param(llfn, 0 as c_uint), get_param(llfn, 1 as c_uint)];\n \n                 (rust_main, args)\n             };\n@@ -2467,8 +2542,11 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     }\n }\n \n-fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n-                           ty: Ty<'tcx>, attrs: &[ast::Attribute]) -> String {\n+fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           id: ast::NodeId,\n+                           ty: Ty<'tcx>,\n+                           attrs: &[ast::Attribute])\n+                           -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n@@ -2530,10 +2608,9 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     // Create the global before evaluating the initializer;\n                     // this is necessary to allow recursive statics.\n                     let llty = type_of(ccx, ty);\n-                    let g = declare::define_global(ccx, &sym[..],\n-                                                   llty).unwrap_or_else(|| {\n-                        ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n-                                                                sym))\n+                    let g = declare::define_global(ccx, &sym[..], llty).unwrap_or_else(|| {\n+                        ccx.sess()\n+                           .span_fatal(i.span, &format!(\"symbol `{}` is already defined\", sym))\n                     });\n \n                     ccx.item_symbols().borrow_mut().insert(i.id, sym);\n@@ -2551,7 +2628,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     llfn\n                 }\n \n-                _ => ccx.sess().bug(\"get_item_val: weird result in table\")\n+                _ => ccx.sess().bug(\"get_item_val: weird result in table\"),\n             };\n \n             v\n@@ -2565,8 +2642,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 _ => {\n                     ccx.sess().span_bug(trait_item.span,\n-                        \"unexpected variant: trait item other than a provided \\\n-                         method in get_item_val()\");\n+                                        \"unexpected variant: trait item other than a provided \\\n+                                         method in get_item_val()\");\n                 }\n             }\n         }\n@@ -2578,8 +2655,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 _ => {\n                     ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: non-method impl item in \\\n-                         get_item_val()\");\n+                                        \"unexpected variant: non-method impl item in \\\n+                                         get_item_val()\");\n                 }\n             }\n         }\n@@ -2609,16 +2686,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let ty = ccx.tcx().node_id_to_type(id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);\n-            let sym = exported_name(ccx,\n-                                    id,\n-                                    ty,\n-                                    &enm.attrs);\n+            let sym = exported_name(ccx, id, ty, &enm.attrs);\n \n             llfn = match enm.node {\n                 hir::ItemEnum(_, _) => {\n                     register_fn(ccx, (*v).span, sym, id, ty)\n                 }\n-                _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\")\n+                _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\"),\n             };\n             attributes::inline(llfn, attributes::InlineAttr::Hint);\n             llfn\n@@ -2627,27 +2701,21 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         hir_map::NodeStructCtor(struct_def) => {\n             // Only register the constructor if this is a tuple-like struct.\n             let ctor_id = if struct_def.is_struct() {\n-                ccx.sess().bug(\"attempt to register a constructor of \\\n-                                  a non-tuple-like struct\")\n+                ccx.sess().bug(\"attempt to register a constructor of a non-tuple-like struct\")\n             } else {\n                 struct_def.id()\n             };\n             let parent = ccx.tcx().map.get_parent(id);\n             let struct_item = ccx.tcx().map.expect_item(parent);\n             let ty = ccx.tcx().node_id_to_type(ctor_id);\n-            let sym = exported_name(ccx,\n-                                    id,\n-                                    ty,\n-                                    &struct_item.attrs);\n-            let llfn = register_fn(ccx, struct_item.span,\n-                                   sym, ctor_id, ty);\n+            let sym = exported_name(ccx, id, ty, &struct_item.attrs);\n+            let llfn = register_fn(ccx, struct_item.span, sym, ctor_id, ty);\n             attributes::inline(llfn, attributes::InlineAttr::Hint);\n             llfn\n         }\n \n         ref variant => {\n-            ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                   variant))\n+            ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\", variant))\n         }\n     };\n \n@@ -2664,8 +2732,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     val\n }\n \n-fn register_method(ccx: &CrateContext, id: ast::NodeId,\n-                   attrs: &[ast::Attribute], span: Span) -> ValueRef {\n+fn register_method(ccx: &CrateContext,\n+                   id: ast::NodeId,\n+                   attrs: &[ast::Attribute],\n+                   span: Span)\n+                   -> ValueRef {\n     let mty = ccx.tcx().node_id_to_type(id);\n \n     let sym = exported_name(ccx, id, mty, &attrs);\n@@ -2699,22 +2770,23 @@ pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>\n     }\n }\n \n-pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate,\n-                      reachable: &NodeSet) -> Vec<u8> {\n+pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &NodeSet) -> Vec<u8> {\n     use flate;\n \n-    let any_library = cx.sess().crate_types.borrow().iter().any(|ty| {\n-        *ty != config::CrateTypeExecutable\n-    });\n+    let any_library = cx.sess()\n+                        .crate_types\n+                        .borrow()\n+                        .iter()\n+                        .any(|ty| *ty != config::CrateTypeExecutable);\n     if !any_library {\n-        return Vec::new()\n+        return Vec::new();\n     }\n \n-    let encode_inlined_item: encoder::EncodeInlinedItem =\n-        Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n+    let encode_inlined_item: encoder::EncodeInlinedItem = Box::new(|ecx, rbml_w, ii| {\n+        astencode::encode_inlined_item(ecx, rbml_w, ii)\n+    });\n \n-    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item,\n-                                                  reachable);\n+    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item, reachable);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let mut compressed = encoder::metadata_encoding_version.to_vec();\n     compressed.push_all(&flate::deflate_bytes(&metadata));\n@@ -2725,8 +2797,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate,\n                        cx.link_meta().crate_hash);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(),\n-                            buf.as_ptr())\n+        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -2752,11 +2823,12 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n                 if !(linkage == llvm::ExternalLinkage as c_uint &&\n                      llvm::LLVMIsDeclaration(val) != 0) &&\n                    !(linkage == llvm::AvailableExternallyLinkage as c_uint) {\n-                    continue\n+                    continue;\n                 }\n \n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                                .to_bytes().to_vec();\n+                               .to_bytes()\n+                               .to_vec();\n                 declared.insert(name);\n             }\n         }\n@@ -2769,11 +2841,12 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n                 // We only care about external definitions.\n                 if !(llvm::LLVMGetLinkage(val) == llvm::ExternalLinkage as c_uint &&\n                      llvm::LLVMIsDeclaration(val) == 0) {\n-                    continue\n+                    continue;\n                 }\n \n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                                .to_bytes().to_vec();\n+                               .to_bytes()\n+                               .to_vec();\n                 if !declared.contains(&name) &&\n                    !reachable.contains(str::from_utf8(&name).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n@@ -2802,17 +2875,21 @@ fn create_imps(cx: &SharedCrateContext) {\n     unsafe {\n         for ccx in cx.iter() {\n             let exported: Vec<_> = iter_globals(ccx.llmod())\n-                .filter(|&val| llvm::LLVMGetLinkage(val) == llvm::ExternalLinkage as c_uint &&\n-                               llvm::LLVMIsDeclaration(val) == 0)\n-                .collect();\n+                                       .filter(|&val| {\n+                                           llvm::LLVMGetLinkage(val) ==\n+                                           llvm::ExternalLinkage as c_uint &&\n+                                           llvm::LLVMIsDeclaration(val) == 0\n+                                       })\n+                                       .collect();\n \n             let i8p_ty = Type::i8p(&ccx);\n             for val in exported {\n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                 let mut imp_name = prefix.as_bytes().to_vec();\n                 imp_name.extend(name.to_bytes());\n                 let imp_name = CString::new(imp_name).unwrap();\n-                let imp = llvm::LLVMAddGlobal(ccx.llmod(), i8p_ty.to_ref(),\n+                let imp = llvm::LLVMAddGlobal(ccx.llmod(),\n+                                              i8p_ty.to_ref(),\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n                 llvm::LLVMSetInitializer(imp, init);\n@@ -3110,4 +3187,3 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n         }\n     }\n }\n-"}]}