{"sha": "5480b47d7f9e708300d3ba319869f21cd1ffd487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ODBiNDdkN2Y5ZTcwODMwMGQzYmEzMTk4NjlmMjFjZDFmZmQ0ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-15T09:05:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-15T09:05:18Z"}, "message": "Auto merge of #62629 - matthewjasper:cleanup-borrowck-errors, r=petrochenkov\n\nCleanup borrowck errors\n\nThis removes some of the unnecessary code that allowed sharing error reporting between two borrow checkers.\n\ncloses #59193", "tree": {"sha": "ce9808bc3cfc6d2ecf815ddba9457ca118c57a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce9808bc3cfc6d2ecf815ddba9457ca118c57a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5480b47d7f9e708300d3ba319869f21cd1ffd487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5480b47d7f9e708300d3ba319869f21cd1ffd487", "html_url": "https://github.com/rust-lang/rust/commit/5480b47d7f9e708300d3ba319869f21cd1ffd487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5480b47d7f9e708300d3ba319869f21cd1ffd487/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb855cda0c5ae97faf5dbf1cd4935dd37fad066", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb855cda0c5ae97faf5dbf1cd4935dd37fad066", "html_url": "https://github.com/rust-lang/rust/commit/9bb855cda0c5ae97faf5dbf1cd4935dd37fad066"}, {"sha": "9709b735618ba38e4281501a799eae4f956282df", "url": "https://api.github.com/repos/rust-lang/rust/commits/9709b735618ba38e4281501a799eae4f956282df", "html_url": "https://github.com/rust-lang/rust/commit/9709b735618ba38e4281501a799eae4f956282df"}], "stats": {"total": 450, "additions": 128, "deletions": 322}, "files": [{"sha": "8986e87627e5e6c0102b76ad1523176a32c80806", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 27, "deletions": 53, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -22,7 +22,7 @@ use super::{InitializationRequiringAction, PrefixSet};\n use super::error_reporting::{IncludingDowncast, UseSpans};\n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MovePathIndex, MoveOutIndex};\n-use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n+use crate::util::borrowck_errors;\n \n #[derive(Debug)]\n struct MoveSite {\n@@ -89,12 +89,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-            let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n+            let mut err = self.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n                 &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n                     .unwrap_or_else(|| \"_\".to_owned()),\n-                Origin::Mir,\n             );\n             err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n \n@@ -120,12 +119,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n-            let mut err = self.infcx.tcx.cannot_act_on_moved_value(\n+            let mut err = self.cannot_act_on_moved_value(\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n                 self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n-                Origin::Mir,\n             );\n \n             self.add_moved_or_invoked_closure_note(\n@@ -267,7 +265,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n             location, place, span, borrow\n         );\n-        let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n@@ -283,10 +280,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let move_spans = self.move_spans(place, location);\n         let span = move_spans.args_or_use();\n \n-        let mut err = tcx.cannot_move_when_borrowed(\n+        let mut err = self.cannot_move_when_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-            Origin::Mir,\n         );\n         err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n@@ -315,8 +311,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n-        let tcx = self.infcx.tcx;\n-\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n@@ -325,13 +319,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let use_spans = self.move_spans(place, location);\n         let span = use_spans.var_or_use();\n \n-        let mut err = tcx.cannot_use_when_mutably_borrowed(\n+        let mut err = self.cannot_use_when_mutably_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n             borrow_span,\n             &self.describe_place(&borrow.borrowed_place)\n                 .unwrap_or_else(|| \"_\".to_owned()),\n-            Origin::Mir,\n         );\n \n         borrow_spans.var_span_label(&mut err, {\n@@ -376,7 +369,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let tcx = self.infcx.tcx;\n         let first_borrow_desc;\n         let mut err = match (\n             gen_borrow_kind,\n@@ -388,7 +380,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         ) {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) => {\n                 first_borrow_desc = \"mutable \";\n-                tcx.cannot_reborrow_already_borrowed(\n+                self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n@@ -398,12 +390,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     rgt,\n                     &msg_borrow,\n                     None,\n-                    Origin::Mir,\n                 )\n             }\n             (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n                 first_borrow_desc = \"immutable \";\n-                tcx.cannot_reborrow_already_borrowed(\n+                self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n@@ -413,42 +404,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     rgt,\n                     &msg_borrow,\n                     None,\n-                    Origin::Mir,\n                 )\n             }\n \n             (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n                 first_borrow_desc = \"first \";\n-                tcx.cannot_mutably_borrow_multiply(\n+                self.cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n                     &msg_place,\n                     issued_span,\n                     &msg_borrow,\n                     None,\n-                    Origin::Mir,\n                 )\n             }\n \n             (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n                 first_borrow_desc = \"first \";\n-                tcx.cannot_uniquely_borrow_by_two_closures(\n+                self.cannot_uniquely_borrow_by_two_closures(\n                     span,\n                     &desc_place,\n                     issued_span,\n                     None,\n-                    Origin::Mir,\n                 )\n             }\n \n             (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n             | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n-                let mut err = tcx.cannot_mutate_in_match_guard(\n+                let mut err = self.cannot_mutate_in_match_guard(\n                     span,\n                     issued_span,\n                     &desc_place,\n                     \"mutably borrow\",\n-                    Origin::Mir,\n                 );\n                 borrow_spans.var_span_label(\n                     &mut err,\n@@ -462,7 +449,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             (BorrowKind::Unique, _, _, _, _, _) => {\n                 first_borrow_desc = \"first \";\n-                tcx.cannot_uniquely_borrow_by_one_closure(\n+                self.cannot_uniquely_borrow_by_one_closure(\n                     span,\n                     container_name,\n                     &desc_place,\n@@ -471,13 +458,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"it\",\n                     \"\",\n                     None,\n-                    Origin::Mir,\n                 )\n             },\n \n             (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n                 first_borrow_desc = \"first \";\n-                tcx.cannot_reborrow_already_uniquely_borrowed(\n+                self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n@@ -487,13 +473,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"\",\n                     None,\n                     second_borrow_desc,\n-                    Origin::Mir,\n                 )\n             }\n \n             (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n                 first_borrow_desc = \"first \";\n-                tcx.cannot_reborrow_already_uniquely_borrowed(\n+                self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n@@ -503,7 +488,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"\",\n                     None,\n                     second_borrow_desc,\n-                    Origin::Mir,\n                 )\n             }\n \n@@ -833,10 +817,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n+        let mut err = self.path_does_not_live_long_enough(\n             borrow_span,\n             &format!(\"`{}`\", name),\n-            Origin::Mir,\n         );\n \n         if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n@@ -925,9 +908,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        let mut err = self.infcx\n-            .tcx\n-            .cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+        let mut err = self.cannot_borrow_across_destructor(borrow_span);\n \n         let what_was_dropped = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name.as_str()),\n@@ -978,9 +959,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             drop_span, borrow_span\n         );\n \n-        let mut err = self.infcx\n-            .tcx\n-            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n+        let mut err = self.thread_local_value_does_not_live_long_enough(borrow_span);\n \n         err.span_label(\n             borrow_span,\n@@ -1024,8 +1003,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let tcx = self.infcx.tcx;\n-        let mut err = tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n+        let mut err = self.temporary_value_borrowed_for_too_long(proper_span);\n         err.span_label(\n             proper_span,\n             \"creates a temporary which is freed while still in use\",\n@@ -1068,8 +1046,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         category: ConstraintCategory,\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx>> {\n-        let tcx = self.infcx.tcx;\n-\n         let return_kind = match category {\n             ConstraintCategory::Return => \"return\",\n             ConstraintCategory::Yield => \"yield\",\n@@ -1132,12 +1108,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         };\n \n-        let mut err = tcx.cannot_return_reference_to_local(\n+        let mut err = self.cannot_return_reference_to_local(\n             return_span,\n             return_kind,\n             reference_desc,\n             &place_desc,\n-            Origin::Mir,\n         );\n \n         if return_span != borrow_span {\n@@ -1158,11 +1133,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> DiagnosticBuilder<'cx> {\n         let tcx = self.infcx.tcx;\n \n-        let mut err = tcx.cannot_capture_in_long_lived_closure(\n+        let mut err = self.cannot_capture_in_long_lived_closure(\n             args_span,\n             captured_var,\n             var_span,\n-          Origin::Mir,\n         );\n \n         let suggestion = match tcx.sess.source_map().span_to_snippet(args_span) {\n@@ -1218,7 +1192,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"function\"\n         };\n \n-        let mut err = tcx.borrowed_data_escapes_closure(escape_span, escapes_from, Origin::Mir);\n+        let mut err = borrowck_errors::borrowed_data_escapes_closure(\n+            tcx,\n+            escape_span,\n+            escapes_from,\n+        );\n \n         err.span_label(\n             upvar_span,\n@@ -1360,14 +1338,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n         let loan_span = loan_spans.args_or_use();\n \n-        let tcx = self.infcx.tcx;\n         if loan.kind == BorrowKind::Shallow {\n-            let mut err = tcx.cannot_mutate_in_match_guard(\n+            let mut err = self.cannot_mutate_in_match_guard(\n                 span,\n                 loan_span,\n                 &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n                 \"assign\",\n-                Origin::Mir,\n             );\n             loan_spans.var_span_label(\n                 &mut err,\n@@ -1379,11 +1355,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             return;\n         }\n \n-        let mut err = tcx.cannot_assign_to_borrowed(\n+        let mut err = self.cannot_assign_to_borrowed(\n             span,\n             loan_span,\n             &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n-            Origin::Mir,\n         );\n \n         loan_spans.var_span_label(\n@@ -1444,11 +1419,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n         };\n \n-        let mut err = self.infcx.tcx.cannot_reassign_immutable(\n+        let mut err = self.cannot_reassign_immutable(\n             span,\n             place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n             from_arg,\n-            Origin::Mir,\n         );\n         let msg = if from_arg {\n             \"cannot assign to immutable argument\""}, {"sha": "5851cd8178878bcff5688b95065301572aafca31", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -41,7 +41,6 @@ use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n-use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use self::borrow_set::{BorrowData, BorrowSet};\n use self::flows::Flows;\n@@ -422,8 +421,8 @@ fn downgrade_if_error(diag: &mut Diagnostic) {\n     }\n }\n \n-pub struct MirBorrowckCtxt<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+crate struct MirBorrowckCtxt<'cx, 'tcx> {\n+    crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n@@ -1499,11 +1498,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n         if borrow_of_local_data(&borrow.borrowed_place) {\n-            let err = self.infcx.tcx\n-                .cannot_borrow_across_generator_yield(\n+            let err = self.cannot_borrow_across_generator_yield(\n                     self.retrieve_borrow_spans(borrow).var_or_use(),\n                     yield_span,\n-                    Origin::Mir,\n                 );\n \n             err.buffer(&mut self.errors_buffer);"}, {"sha": "5939adc5528d9f83dec9571f1b360093ab8ff256", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -12,7 +12,6 @@ use crate::dataflow::move_paths::{\n     IllegalMoveOrigin, IllegalMoveOriginKind,\n     LookupResult, MoveError, MovePathIndex,\n };\n-use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n \n // Often when desugaring a pattern match we may have many individual moves in\n // MIR that are all part of one operation from the user's point-of-view. For\n@@ -254,12 +253,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         )\n                     }\n                     IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        self.infcx.tcx\n-                            .cannot_move_out_of_interior_of_drop(span, ty, Origin::Mir)\n+                        self.cannot_move_out_of_interior_of_drop(span, ty)\n                     }\n                     IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n-                        self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                            span, ty, Some(*is_index), Origin::Mir\n+                        self.cannot_move_out_of_interior_noncopy(\n+                            span, ty, Some(*is_index),\n                         ),\n                 },\n                 span,\n@@ -293,7 +291,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             )\n         };\n \n-        self.infcx.tcx.cannot_move_out_of(span, &description, Origin::Mir)\n+        self.cannot_move_out_of(span, &description)\n     }\n \n     fn report_cannot_move_from_borrowed_content(\n@@ -302,8 +300,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         deref_target_place: &Place<'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'a> {\n-        let origin = Origin::Mir;\n-\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n@@ -319,10 +315,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Place::Base(PlaceBase::Local(local)) = *deref_base {\n             let decl = &self.body.local_decls[local];\n             if decl.is_ref_for_guard() {\n-                let mut err = self.infcx.tcx.cannot_move_out_of(\n+                let mut err = self.cannot_move_out_of(\n                     span,\n                     &format!(\"`{}` in pattern guard\", decl.name.unwrap()),\n-                    origin,\n                 );\n                 err.note(\n                     \"variables bound in patterns cannot be moved from \\\n@@ -334,9 +329,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report: ty={:?}\", ty);\n         let mut err = match ty.sty {\n             ty::Array(..) | ty::Slice(..) =>\n-                self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                    span, ty, None, origin\n-                ),\n+                self.cannot_move_out_of_interior_noncopy(span, ty, None),\n             ty::Closure(def_id, closure_substs)\n                 if def_id == self.mir_def_id && upvar_field.is_some()\n             => {\n@@ -378,7 +371,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     closure_kind_ty, closure_kind, place_description,\n                 );\n \n-                let mut diag = self.infcx.tcx.cannot_move_out_of(span, &place_description, origin);\n+                let mut diag = self.cannot_move_out_of(span, &place_description);\n \n                 diag.span_label(upvar_span, \"captured outer variable\");\n \n@@ -388,17 +381,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let source = self.borrowed_content_source(deref_base);\n                 match (self.describe_place(move_place), source.describe_for_named_place()) {\n                     (Some(place_desc), Some(source_desc)) => {\n-                        self.infcx.tcx.cannot_move_out_of(\n+                        self.cannot_move_out_of(\n                             span,\n                             &format!(\"`{}` which is behind a {}\", place_desc, source_desc),\n-                            origin,\n                         )\n                     }\n                     (_, _) => {\n-                        self.infcx.tcx.cannot_move_out_of(\n+                        self.cannot_move_out_of(\n                             span,\n                             &source.describe_for_unnamed_place(),\n-                            origin,\n                         )\n                     }\n                 }"}, {"sha": "59a3354f9c52f62d97ae45b8795a2ff877a86e76", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -1,3 +1,4 @@\n+use core::unicode::property::Pattern_White_Space;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n@@ -9,9 +10,7 @@ use syntax_pos::symbol::kw;\n \n use crate::borrow_check::MirBorrowckCtxt;\n use crate::borrow_check::error_reporting::BorrowedContentSource;\n-use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n use crate::util::collect_writes::FindAssignments;\n-use crate::util::suggest_ref_mut;\n use rustc_errors::Applicability;\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -161,15 +160,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let span = match error_access {\n             AccessKind::Move => {\n-                err = self.infcx.tcx\n-                    .cannot_move_out_of(span, &(item_msg + &reason), Origin::Mir);\n+                err = self.cannot_move_out_of(span, &(item_msg + &reason));\n                 err.span_label(span, \"cannot move\");\n                 err.buffer(&mut self.errors_buffer);\n                 return;\n             }\n             AccessKind::Mutate => {\n-                err = self.infcx.tcx\n-                    .cannot_assign(span, &(item_msg + &reason), Origin::Mir);\n+                err = self.cannot_assign(span, &(item_msg + &reason));\n                 act = \"assign\";\n                 acted_on = \"written\";\n                 span\n@@ -180,11 +177,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let borrow_spans = self.borrow_spans(span, location);\n                 let borrow_span = borrow_spans.args_or_use();\n-                err = self.infcx.tcx.cannot_borrow_path_as_mutable_because(\n+                err = self.cannot_borrow_path_as_mutable_because(\n                     borrow_span,\n                     &item_msg,\n                     &reason,\n-                    Origin::Mir,\n                 );\n                 borrow_spans.var_span_label(\n                     &mut err,\n@@ -632,3 +628,16 @@ fn annotate_struct_field(\n \n     None\n }\n+\n+/// If possible, suggest replacing `ref` with `ref mut`.\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<(String)> {\n+    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n+    if hi_src.starts_with(\"ref\")\n+        && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n+    {\n+        let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n+        Some(replacement)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "efa18587b7ddb7ddbc4b880ba14639e034af2f48", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -4,8 +4,8 @@ use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ConstraintDescription;\n-use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n use crate::borrow_check::Upvar;\n+use crate::util::borrowck_errors;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n@@ -487,9 +487,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n         }\n \n-        let mut diag = infcx\n-            .tcx\n-            .borrowed_data_escapes_closure(span, escapes_from, Origin::Mir);\n+        let mut diag = borrowck_errors::borrowed_data_escapes_closure(\n+            infcx.tcx,\n+            span,\n+            escapes_from,\n+        );\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label("}, {"sha": "83d441b90be720aacb650654f8c62facba121e69", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -2462,12 +2462,12 @@ register_diagnostics! {\n //  E0298, // cannot compare constants\n //  E0299, // mismatched types between arms\n //  E0471, // constant evaluation error (in pattern)\n-//    E0385, // {} in an aliasable location\n+//  E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n-    E0521,  // borrowed data escapes outside of closure\n+    E0521, // borrowed data escapes outside of closure\n     E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}\n-    E0598, // lifetime of {} is too short to guarantee its contents can be...\n+//  E0598, // lifetime of {} is too short to guarantee its contents can be...\n     E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "3359d1b3bbfe102ba7c5e4e7068e3ec96ea6efe1", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 63, "deletions": 213, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -2,27 +2,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use syntax_pos::{MultiSpan, Span};\n \n-// FIXME(chrisvittal) remove Origin entirely\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Origin {\n-    Mir,\n-}\n-\n-pub trait BorrowckErrors<'cx>: Sized + Copy {\n-    fn struct_span_err_with_code<S: Into<MultiSpan>>(\n-        self,\n-        sp: S,\n-        msg: &str,\n-        code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'cx>;\n-\n-    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx>;\n-\n-    fn cannot_move_when_borrowed(\n-        self,\n+impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n+    crate fn cannot_move_when_borrowed(\n+        &self,\n         span: Span,\n         desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -33,13 +17,12 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn cannot_use_when_mutably_borrowed(\n-        self,\n+    crate fn cannot_use_when_mutably_borrowed(\n+        &self,\n         span: Span,\n         desc: &str,\n         borrow_span: Span,\n         borrow_desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -57,12 +40,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_act_on_uninitialized_variable(\n-        self,\n+    crate fn cannot_act_on_uninitialized_variable(\n+        &self,\n         span: Span,\n         verb: &str,\n         desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -74,15 +56,14 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn cannot_mutably_borrow_multiply(\n-        self,\n+    crate fn cannot_mutably_borrow_multiply(\n+        &self,\n         new_loan_span: Span,\n         desc: &str,\n         opt_via: &str,\n         old_loan_span: Span,\n         old_opt_via: &str,\n         old_load_end_span: Option<Span>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let via = |msg: &str|\n             if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n@@ -124,13 +105,12 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(\n-        self,\n+    crate fn cannot_uniquely_borrow_by_two_closures(\n+        &self,\n         new_loan_span: Span,\n         desc: &str,\n         old_loan_span: Span,\n         old_load_end_span: Option<Span>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -154,8 +134,8 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_uniquely_borrow_by_one_closure(\n-        self,\n+    crate fn cannot_uniquely_borrow_by_one_closure(\n+        &self,\n         new_loan_span: Span,\n         container_name: &str,\n         desc_new: &str,\n@@ -164,7 +144,6 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         noun_old: &str,\n         old_opt_via: &str,\n         previous_end_span: Option<Span>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -186,8 +165,8 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_reborrow_already_uniquely_borrowed(\n-        self,\n+    crate fn cannot_reborrow_already_uniquely_borrowed(\n+        &self,\n         new_loan_span: Span,\n         container_name: &str,\n         desc_new: &str,\n@@ -197,7 +176,6 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_opt_via: &str,\n         previous_end_span: Option<Span>,\n         second_borrow_desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -223,8 +201,8 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_reborrow_already_borrowed(\n-        self,\n+    crate fn cannot_reborrow_already_borrowed(\n+        &self,\n         span: Span,\n         desc_new: &str,\n         msg_new: &str,\n@@ -234,7 +212,6 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         kind_old: &str,\n         msg_old: &str,\n         old_load_end_span: Option<Span>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let via = |msg: &str|\n             if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n@@ -277,12 +254,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_assign_to_borrowed(\n-        self,\n+    crate fn cannot_assign_to_borrowed(\n+        &self,\n         span: Span,\n         borrow_span: Span,\n         desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -300,22 +276,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_move_into_closure(self, span: Span, desc: &str, _: Origin) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(\n-            self,\n-            span,\n-            E0504,\n-            \"cannot move `{}` into closure because it is borrowed\",\n-            desc,\n-        )\n-    }\n-\n-    fn cannot_reassign_immutable(\n-        self,\n+    crate fn cannot_reassign_immutable(\n+        &self,\n         span: Span,\n         desc: &str,\n         is_arg: bool,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let msg = if is_arg {\n             \"to immutable argument\"\n@@ -332,19 +297,14 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn cannot_assign(self, span: Span, desc: &str, _: Origin) -> DiagnosticBuilder<'cx> {\n+    crate fn cannot_assign(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(self, span, E0594, \"cannot assign to {}\", desc)\n     }\n \n-    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n-        self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n-    }\n-\n-    fn cannot_move_out_of(\n-        self,\n+    crate fn cannot_move_out_of(\n+        &self,\n         move_from_span: Span,\n         move_from_desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -358,12 +318,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     /// Signal an error due to an attempt to move out of the interior\n     /// of an array or slice. `is_index` is None when error origin\n     /// didn't capture whether there was an indexing operation or not.\n-    fn cannot_move_out_of_interior_noncopy(\n-        self,\n+    crate fn cannot_move_out_of_interior_noncopy(\n+        &self,\n         move_from_span: Span,\n         ty: Ty<'_>,\n         is_index: Option<bool>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let type_name = match (&ty.sty, is_index) {\n             (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n@@ -382,11 +341,10 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_move_out_of_interior_of_drop(\n-        self,\n+    crate fn cannot_move_out_of_interior_of_drop(\n+        &self,\n         move_from_span: Span,\n         container_ty: Ty<'_>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -399,13 +357,12 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_act_on_moved_value(\n-        self,\n+    crate fn cannot_act_on_moved_value(\n+        &self,\n         use_span: Span,\n         verb: &str,\n         optional_adverb_for_moved: &str,\n         moved_path: Option<String>,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let moved_path = moved_path\n             .map(|mp| format!(\": `{}`\", mp))\n@@ -422,42 +379,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn cannot_partially_reinit_an_uninit_struct(\n-        self,\n-        span: Span,\n-        uninit_path: &str,\n-        _: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(\n-            self,\n-            span,\n-            E0383,\n-            \"partial reinitialization of uninitialized structure `{}`\",\n-            uninit_path,\n-        )\n-    }\n-\n-    fn closure_cannot_assign_to_borrowed(\n-        self,\n-        span: Span,\n-        descr: &str,\n-        _: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(\n-            self,\n-            span,\n-            E0595,\n-            \"closure cannot assign to {}\",\n-            descr,\n-        )\n-    }\n-\n-    fn cannot_borrow_path_as_mutable_because(\n-        self,\n+    crate fn cannot_borrow_path_as_mutable_because(\n+        &self,\n         span: Span,\n         path: &str,\n         reason: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -469,22 +395,12 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn cannot_borrow_path_as_mutable(\n-        self,\n-        span: Span,\n-        path: &str,\n-        o: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        self.cannot_borrow_path_as_mutable_because(span, path, \"\", o)\n-    }\n-\n-    fn cannot_mutate_in_match_guard(\n-        self,\n+    crate fn cannot_mutate_in_match_guard(\n+        &self,\n         mutate_span: Span,\n         match_span: Span,\n         match_place: &str,\n         action: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -499,11 +415,10 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_borrow_across_generator_yield(\n-        self,\n+    crate fn cannot_borrow_across_generator_yield(\n+        &self,\n         span: Span,\n         yield_span: Span,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -515,10 +430,9 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn cannot_borrow_across_destructor(\n-        self,\n+    crate fn cannot_borrow_across_destructor(\n+        &self,\n         borrow_span: Span,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -528,11 +442,10 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn path_does_not_live_long_enough(\n-        self,\n+    crate fn path_does_not_live_long_enough(\n+        &self,\n         span: Span,\n         path: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -543,13 +456,12 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn cannot_return_reference_to_local(\n-        self,\n+    crate fn cannot_return_reference_to_local(\n+        &self,\n         span: Span,\n         return_kind: &str,\n         reference_desc: &str,\n         path_desc: &str,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -569,64 +481,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn lifetime_too_short_for_reborrow(\n-        self,\n-        span: Span,\n-        path: &str,\n-        _: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(\n-            self,\n-            span,\n-            E0598,\n-            \"lifetime of {} is too short to guarantee \\\n-             its contents can be safely reborrowed\",\n-            path,\n-        )\n-    }\n-\n-    fn cannot_act_on_capture_in_sharable_fn(\n-        self,\n-        span: Span,\n-        bad_thing: &str,\n-        help: (Span, &str),\n-        _: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        let (help_span, help_msg) = help;\n-        let mut err = struct_span_err!(\n-            self,\n-            span,\n-            E0387,\n-            \"{} in a captured outer variable in an `Fn` closure\",\n-            bad_thing,\n-        );\n-        err.span_help(help_span, help_msg);\n-        err\n-    }\n-\n-    fn cannot_assign_into_immutable_reference(\n-        self,\n-        span: Span,\n-        bad_thing: &str,\n-        _: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        let mut err = struct_span_err!(\n-            self,\n-            span,\n-            E0389,\n-            \"{} in a `&` reference\",\n-            bad_thing,\n-        );\n-        err.span_label(span, \"assignment into an immutable reference\");\n-        err\n-    }\n-\n-    fn cannot_capture_in_long_lived_closure(\n-        self,\n+    crate fn cannot_capture_in_long_lived_closure(\n+        &self,\n         closure_span: Span,\n         borrowed_path: &str,\n         capture_span: Span,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n@@ -645,25 +504,9 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err\n     }\n \n-    fn borrowed_data_escapes_closure(\n-        self,\n-        escape_span: Span,\n-        escapes_from: &str,\n-        _: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(\n-            self,\n-            escape_span,\n-            E0521,\n-            \"borrowed data escapes outside of {}\",\n-            escapes_from,\n-        )\n-    }\n-\n-    fn thread_local_value_does_not_live_long_enough(\n-        self,\n+    crate fn thread_local_value_does_not_live_long_enough(\n+        &self,\n         span: Span,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -673,10 +516,9 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         )\n     }\n \n-    fn temporary_value_borrowed_for_too_long(\n-        self,\n+    crate fn temporary_value_borrowed_for_too_long(\n+        &self,\n         span: Span,\n-        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         struct_span_err!(\n             self,\n@@ -685,19 +527,27 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             \"temporary value dropped while borrowed\",\n         )\n     }\n-}\n \n-impl BorrowckErrors<'tcx> for TyCtxt<'tcx> {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(\n-        self,\n+        &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'tcx> {\n-        self.sess.struct_span_err_with_code(sp, msg, code)\n+        self.infcx.tcx.sess.struct_span_err_with_code(sp, msg, code)\n     }\n+}\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'tcx> {\n-        self.sess.struct_span_err(sp, msg)\n-    }\n+crate fn borrowed_data_escapes_closure<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    escape_span: Span,\n+    escapes_from: &str,\n+) -> DiagnosticBuilder<'tcx> {\n+    struct_span_err!(\n+        tcx.sess,\n+        escape_span,\n+        E0521,\n+        \"borrowed data escapes outside of {}\",\n+        escapes_from,\n+    )\n }"}, {"sha": "c8a90a989142facb95943bdd6d21e1af1898e14f", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5480b47d7f9e708300d3ba319869f21cd1ffd487/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=5480b47d7f9e708300d3ba319869f21cd1ffd487", "patch": "@@ -1,7 +1,3 @@\n-use core::unicode::property::Pattern_White_Space;\n-use rustc::ty::TyCtxt;\n-use syntax_pos::Span;\n-\n pub mod aggregate;\n pub mod borrowck_errors;\n pub mod elaborate_drops;\n@@ -19,16 +15,3 @@ pub use self::alignment::is_disaligned;\n pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};\n pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;\n-\n-/// If possible, suggest replacing `ref` with `ref mut`.\n-pub fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<(String)> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n-    if hi_src.starts_with(\"ref\")\n-        && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n-    {\n-        let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n-        Some(replacement)\n-    } else {\n-        None\n-    }\n-}"}]}