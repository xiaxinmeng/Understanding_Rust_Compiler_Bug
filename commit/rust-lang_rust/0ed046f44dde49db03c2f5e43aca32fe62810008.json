{"sha": "0ed046f44dde49db03c2f5e43aca32fe62810008", "node_id": "C_kwDOAAsO6NoAKDBlZDA0NmY0NGRkZTQ5ZGIwM2MyZjVlNDNhY2EzMmZlNjI4MTAwMDg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-31T05:58:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T05:58:01Z"}, "message": "Rollup merge of #101171 - thomcc:fix-winfs-ub, r=ChrisDenton\n\nFix UB from misalignment and provenance widening in `std::sys::windows`\n\nThis fixes two types of UB:\n\n1. Reading past the end of a reference in types like `&c::REPARSE_DATA_BUFFER` (see https://github.com/rust-lang/unsafe-code-guidelines/issues/256). This is fixed by using `addr_of!`. I think there are probably a couple more cases where we do this for other structures, and will look into it in a bit.\n\n2. Failing to ensure that a `[u8; N]` on the stack is sufficiently aligned to convert to a `REPARSE_DATA_BUFFER`. ~~This was done by introducing a new `AlignedAs` struct that allows aligning one type to the alignment of another type. I expect there are other places where we have this issue too, or I wouldn't introduce this type, but will get to them after this lands.~~\n\n    ~~Worth noting, it *is* implemented in a way that can cause problems depending on how we fix #81996, but this would be caught by the test I added (and presumably if we decide to fix that in a way that would break this code, we'd also introduce a `#[repr(simple)]` or `#[repr(linear)]` as a replacement for this usage of `#[repr(C)]`).~~\n\n    Edit: None of that is still in the code, I just went with a `Align8` since that's all we'll need for almost everything we want to call.\n\nThese are more or less \"potential UB\" since it's likely at the moment everything works fine, although the alignment not causing issues might just be down to luck (and x86 being forgiving).\n\n~~NB: I've only ensured this check builds, but will run tests soon.~~ All tests pass, including stage2 compiler tests.\n\nr? ``@ChrisDenton``", "tree": {"sha": "09af256d5fac504baf6435a6d77b81d34ac1c52b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09af256d5fac504baf6435a6d77b81d34ac1c52b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ed046f44dde49db03c2f5e43aca32fe62810008", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDvhpCRBK7hj4Ov3rIwAApFwIAAu6uRNmI16bB7J+ieljWswD\ntaHCEOmheEqpYlty/SL/BicfjdfcJjFvndNJw/6YwBi8VqTkYC1fhzedUFCY2Qms\nbyVWrRWHCKkiOXkG2TZrx7oz1iOzF00xaOz6GEDDtAxWA6h/T0QSGP1pyn0vCT4h\n4zSneh4KJ5kSvr665dAxXRZhucycXBSS1hBVMafpG3Q1CLDPzw9xfN2BnqTy+EQl\nC0O0E9yj1CwtZi0JfFvnMOcPJTnU+aXvSCnR3scgf1Bb8SCEqrzdXrAxVzaz6Dtg\n7VhWyKUUpS/VvLC9L/8zTiDr1fL7JfFp1dDUUvsBLS3SctM59waP5p1ollB4Yys=\n=ugMY\n-----END PGP SIGNATURE-----\n", "payload": "tree 09af256d5fac504baf6435a6d77b81d34ac1c52b\nparent b8b2f88a044fdd20be4925eb222a0572f359de2f\nparent c41f21b3e4e992d5c5c11dae880dc81192a12653\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661925481 +0200\ncommitter GitHub <noreply@github.com> 1661925481 +0200\n\nRollup merge of #101171 - thomcc:fix-winfs-ub, r=ChrisDenton\n\nFix UB from misalignment and provenance widening in `std::sys::windows`\n\nThis fixes two types of UB:\n\n1. Reading past the end of a reference in types like `&c::REPARSE_DATA_BUFFER` (see https://github.com/rust-lang/unsafe-code-guidelines/issues/256). This is fixed by using `addr_of!`. I think there are probably a couple more cases where we do this for other structures, and will look into it in a bit.\n\n2. Failing to ensure that a `[u8; N]` on the stack is sufficiently aligned to convert to a `REPARSE_DATA_BUFFER`. ~~This was done by introducing a new `AlignedAs` struct that allows aligning one type to the alignment of another type. I expect there are other places where we have this issue too, or I wouldn't introduce this type, but will get to them after this lands.~~\n\n    ~~Worth noting, it *is* implemented in a way that can cause problems depending on how we fix #81996, but this would be caught by the test I added (and presumably if we decide to fix that in a way that would break this code, we'd also introduce a `#[repr(simple)]` or `#[repr(linear)]` as a replacement for this usage of `#[repr(C)]`).~~\n\n    Edit: None of that is still in the code, I just went with a `Align8` since that's all we'll need for almost everything we want to call.\n\nThese are more or less \"potential UB\" since it's likely at the moment everything works fine, although the alignment not causing issues might just be down to luck (and x86 being forgiving).\n\n~~NB: I've only ensured this check builds, but will run tests soon.~~ All tests pass, including stage2 compiler tests.\n\nr? ``@ChrisDenton``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed046f44dde49db03c2f5e43aca32fe62810008", "html_url": "https://github.com/rust-lang/rust/commit/0ed046f44dde49db03c2f5e43aca32fe62810008", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ed046f44dde49db03c2f5e43aca32fe62810008/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b2f88a044fdd20be4925eb222a0572f359de2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b2f88a044fdd20be4925eb222a0572f359de2f", "html_url": "https://github.com/rust-lang/rust/commit/b8b2f88a044fdd20be4925eb222a0572f359de2f"}, {"sha": "c41f21b3e4e992d5c5c11dae880dc81192a12653", "url": "https://api.github.com/repos/rust-lang/rust/commits/c41f21b3e4e992d5c5c11dae880dc81192a12653", "html_url": "https://github.com/rust-lang/rust/commit/c41f21b3e4e992d5c5c11dae880dc81192a12653"}], "stats": {"total": 83, "additions": 55, "deletions": 28}, "files": [{"sha": "c99c8efe4367f18ce174bc6c64d2e8abd66901f3", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ed046f44dde49db03c2f5e43aca32fe62810008/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed046f44dde49db03c2f5e43aca32fe62810008/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=0ed046f44dde49db03c2f5e43aca32fe62810008", "patch": "@@ -501,6 +501,8 @@ pub struct FILE_END_OF_FILE_INFO {\n     pub EndOfFile: LARGE_INTEGER,\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `rest` field!\n #[repr(C)]\n pub struct REPARSE_DATA_BUFFER {\n     pub ReparseTag: c_uint,\n@@ -509,6 +511,8 @@ pub struct REPARSE_DATA_BUFFER {\n     pub rest: (),\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `PathBuffer` field!\n #[repr(C)]\n pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub SubstituteNameOffset: c_ushort,\n@@ -519,6 +523,8 @@ pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub PathBuffer: WCHAR,\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `PathBuffer` field!\n #[repr(C)]\n pub struct MOUNT_POINT_REPARSE_BUFFER {\n     pub SubstituteNameOffset: c_ushort,"}, {"sha": "0aa7c50ded1c7acfca41ad6c67eaa0dd463171e1", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0ed046f44dde49db03c2f5e43aca32fe62810008/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed046f44dde49db03c2f5e43aca32fe62810008/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=0ed046f44dde49db03c2f5e43aca32fe62810008", "patch": "@@ -11,7 +11,7 @@ use crate::slice;\n use crate::sync::Arc;\n use crate::sys::handle::Handle;\n use crate::sys::time::SystemTime;\n-use crate::sys::{c, cvt};\n+use crate::sys::{c, cvt, Align8};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::thread;\n \n@@ -326,9 +326,9 @@ impl File {\n             cvt(c::GetFileInformationByHandle(self.handle.as_raw_handle(), &mut info))?;\n             let mut reparse_tag = 0;\n             if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                let mut b = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                    reparse_tag = buf.ReparseTag;\n+                    reparse_tag = (*buf).ReparseTag;\n                 }\n             }\n             Ok(FileAttr {\n@@ -389,9 +389,9 @@ impl File {\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n             if attr.file_type().is_reparse_point() {\n-                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                let mut b = Align8([0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                    attr.reparse_tag = buf.ReparseTag;\n+                    attr.reparse_tag = (*buf).ReparseTag;\n                 }\n             }\n             Ok(attr)\n@@ -458,48 +458,57 @@ impl File {\n         Ok(Self { handle: self.handle.try_clone()? })\n     }\n \n-    fn reparse_point<'a>(\n+    // NB: returned pointer is derived from `space`, and has provenance to\n+    // match. A raw pointer is returned rather than a reference in order to\n+    // avoid narrowing provenance to the actual `REPARSE_DATA_BUFFER`.\n+    fn reparse_point(\n         &self,\n-        space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n-    ) -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n+        space: &mut Align8<[u8]>,\n+    ) -> io::Result<(c::DWORD, *const c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n             cvt({\n+                // Grab this in advance to avoid it invalidating the pointer\n+                // we get from `space.0.as_mut_ptr()`.\n+                let len = space.0.len();\n                 c::DeviceIoControl(\n                     self.handle.as_raw_handle(),\n                     c::FSCTL_GET_REPARSE_POINT,\n                     ptr::null_mut(),\n                     0,\n-                    space.as_mut_ptr() as *mut _,\n-                    space.len() as c::DWORD,\n+                    space.0.as_mut_ptr().cast(),\n+                    len as c::DWORD,\n                     &mut bytes,\n                     ptr::null_mut(),\n                 )\n             })?;\n-            Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n+            const _: () = assert!(core::mem::align_of::<c::REPARSE_DATA_BUFFER>() <= 8);\n+            Ok((bytes, space.0.as_ptr().cast::<c::REPARSE_DATA_BUFFER>()))\n         }\n     }\n \n     fn readlink(&self) -> io::Result<PathBuf> {\n-        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut space = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let (_bytes, buf) = self.reparse_point(&mut space)?;\n         unsafe {\n-            let (path_buffer, subst_off, subst_len, relative) = match buf.ReparseTag {\n+            let (path_buffer, subst_off, subst_len, relative) = match (*buf).ReparseTag {\n                 c::IO_REPARSE_TAG_SYMLINK => {\n                     let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n-                        &buf.rest as *const _ as *const _;\n+                        ptr::addr_of!((*buf).rest).cast();\n+                    assert!(info.is_aligned());\n                     (\n-                        &(*info).PathBuffer as *const _ as *const u16,\n+                        ptr::addr_of!((*info).PathBuffer).cast::<u16>(),\n                         (*info).SubstituteNameOffset / 2,\n                         (*info).SubstituteNameLength / 2,\n                         (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0,\n                     )\n                 }\n                 c::IO_REPARSE_TAG_MOUNT_POINT => {\n                     let info: *const c::MOUNT_POINT_REPARSE_BUFFER =\n-                        &buf.rest as *const _ as *const _;\n+                        ptr::addr_of!((*buf).rest).cast();\n+                    assert!(info.is_aligned());\n                     (\n-                        &(*info).PathBuffer as *const _ as *const u16,\n+                        ptr::addr_of!((*info).PathBuffer).cast::<u16>(),\n                         (*info).SubstituteNameOffset / 2,\n                         (*info).SubstituteNameLength / 2,\n                         false,\n@@ -649,18 +658,18 @@ impl File {\n \n /// A buffer for holding directory entries.\n struct DirBuff {\n-    buffer: Vec<u8>,\n+    buffer: Box<Align8<[u8; Self::BUFFER_SIZE]>>,\n }\n impl DirBuff {\n+    const BUFFER_SIZE: usize = 1024;\n     fn new() -> Self {\n-        const BUFFER_SIZE: usize = 1024;\n-        Self { buffer: vec![0_u8; BUFFER_SIZE] }\n+        Self { buffer: Box::new(Align8([0u8; Self::BUFFER_SIZE])) }\n     }\n     fn capacity(&self) -> usize {\n-        self.buffer.len()\n+        self.buffer.0.len()\n     }\n     fn as_mut_ptr(&mut self) -> *mut u8 {\n-        self.buffer.as_mut_ptr().cast()\n+        self.buffer.0.as_mut_ptr().cast()\n     }\n     /// Returns a `DirBuffIter`.\n     fn iter(&self) -> DirBuffIter<'_> {\n@@ -669,7 +678,7 @@ impl DirBuff {\n }\n impl AsRef<[u8]> for DirBuff {\n     fn as_ref(&self) -> &[u8] {\n-        &self.buffer\n+        &self.buffer.0\n     }\n }\n \n@@ -697,9 +706,12 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         // used to get the file name slice.\n         let (name, is_directory, next_entry) = unsafe {\n             let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n+            // Guaranteed to be aligned in documentation for\n+            // https://docs.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info\n+            assert!(info.is_aligned());\n             let next_entry = (*info).NextEntryOffset as usize;\n             let name = crate::slice::from_raw_parts(\n-                (*info).FileName.as_ptr().cast::<u16>(),\n+                ptr::addr_of!((*info).FileName).cast::<u16>(),\n                 (*info).FileNameLength as usize / size_of::<u16>(),\n             );\n             let is_directory = ((*info).FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) != 0;\n@@ -1337,9 +1349,10 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     let h = f.as_inner().as_raw_handle();\n \n     unsafe {\n-        let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-        let db = data.as_mut_ptr() as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n-        let buf = &mut (*db).ReparseTarget as *mut c::WCHAR;\n+        let mut data = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+        let data_ptr = data.0.as_mut_ptr();\n+        let db = data_ptr.cast::<c::REPARSE_MOUNTPOINT_DATA_BUFFER>();\n+        let buf = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();\n         let mut i = 0;\n         // FIXME: this conversion is very hacky\n         let v = br\"\\??\\\";\n@@ -1359,7 +1372,7 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n         cvt(c::DeviceIoControl(\n             h as *mut _,\n             c::FSCTL_SET_REPARSE_POINT,\n-            data.as_ptr() as *mut _,\n+            data_ptr.cast(),\n             (*db).ReparseDataLength + 8,\n             ptr::null_mut(),\n             0,"}, {"sha": "340cae4066bf44deb42f872769a37ffea7333afb", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ed046f44dde49db03c2f5e43aca32fe62810008/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed046f44dde49db03c2f5e43aca32fe62810008/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=0ed046f44dde49db03c2f5e43aca32fe62810008", "patch": "@@ -329,3 +329,11 @@ pub fn abort_internal() -> ! {\n     }\n     crate::intrinsics::abort();\n }\n+\n+/// Align the inner value to 8 bytes.\n+///\n+/// This is enough for almost all of the buffers we're likely to work with in\n+/// the Windows APIs we use.\n+#[repr(C, align(8))]\n+#[derive(Copy, Clone)]\n+pub(crate) struct Align8<T: ?Sized>(pub T);"}]}