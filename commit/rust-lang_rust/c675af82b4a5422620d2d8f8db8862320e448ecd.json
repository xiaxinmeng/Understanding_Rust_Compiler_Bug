{"sha": "c675af82b4a5422620d2d8f8db8862320e448ecd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NzVhZjgyYjRhNTQyMjYyMGQyZDhmOGRiODg2MjMyMGU0NDhlY2Q=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2021-02-14T13:42:47Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2021-02-15T16:52:33Z"}, "message": "Add internal `collect_into_array[_unchecked]` to remove duplicate code\n\nThis does not suggest adding such a function to the public API. This is\njust for the purpose of avoiding duplicate code. Many array methods\nalready contained the same kind of code and there are still many array\nrelated methods to come (e.g. `Iterator::{chunks, map_windows, next_n,\n...}`) which all basically need this functionality. Writing custom\n`unsafe` code for each of those seems not like a good idea.", "tree": {"sha": "0c6e407bd5835fd8e15b82a282354e540af1f1a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c6e407bd5835fd8e15b82a282354e540af1f1a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c675af82b4a5422620d2d8f8db8862320e448ecd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQSOpdglyeINwt5bMtWqUCXPHMhXVAUCYCqm0QAKCRCqUCXPHMhX\nVB4hAQDgnLWtXNg5Yf8EfJslJ714qX8azicw4NGFcr6Nbn9xfwD/bnPwHk48tP00\npbORXrc8MvIcse6/GgCaSldpRSZpzAg=\n=tL0N\n-----END PGP SIGNATURE-----", "payload": "tree 0c6e407bd5835fd8e15b82a282354e540af1f1a1\nparent b86674e7cc8ac9c846ed5aca84aaefc2d0d12e4a\nauthor Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1613310167 +0100\ncommitter Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1613407953 +0100\n\nAdd internal `collect_into_array[_unchecked]` to remove duplicate code\n\nThis does not suggest adding such a function to the public API. This is\njust for the purpose of avoiding duplicate code. Many array methods\nalready contained the same kind of code and there are still many array\nrelated methods to come (e.g. `Iterator::{chunks, map_windows, next_n,\n...}`) which all basically need this functionality. Writing custom\n`unsafe` code for each of those seems not like a good idea.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c675af82b4a5422620d2d8f8db8862320e448ecd", "html_url": "https://github.com/rust-lang/rust/commit/c675af82b4a5422620d2d8f8db8862320e448ecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c675af82b4a5422620d2d8f8db8862320e448ecd/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b86674e7cc8ac9c846ed5aca84aaefc2d0d12e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86674e7cc8ac9c846ed5aca84aaefc2d0d12e4a", "html_url": "https://github.com/rust-lang/rust/commit/b86674e7cc8ac9c846ed5aca84aaefc2d0d12e4a"}], "stats": {"total": 170, "additions": 110, "deletions": 60}, "files": [{"sha": "d4fd7545d9bda2303ed8820357de44e16cc5280e", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 110, "deletions": 60, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c675af82b4a5422620d2d8f8db8862320e448ecd/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c675af82b4a5422620d2d8f8db8862320e448ecd/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=c675af82b4a5422620d2d8f8db8862320e448ecd", "patch": "@@ -11,8 +11,9 @@ use crate::cmp::Ordering;\n use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{self, Hash};\n+use crate::iter::TrustedLen;\n use crate::marker::Unsize;\n-use crate::mem::MaybeUninit;\n+use crate::mem::{self, MaybeUninit};\n use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n \n@@ -426,41 +427,13 @@ impl<T, const N: usize> [T; N] {\n     /// assert_eq!(y, [6, 9, 3, 3]);\n     /// ```\n     #[unstable(feature = \"array_map\", issue = \"75243\")]\n-    pub fn map<F, U>(self, mut f: F) -> [U; N]\n+    pub fn map<F, U>(self, f: F) -> [U; N]\n     where\n         F: FnMut(T) -> U,\n     {\n-        struct Guard<T, const N: usize> {\n-            dst: *mut T,\n-            initialized: usize,\n-        }\n-\n-        impl<T, const N: usize> Drop for Guard<T, N> {\n-            fn drop(&mut self) {\n-                debug_assert!(self.initialized <= N);\n-\n-                let initialized_part =\n-                    crate::ptr::slice_from_raw_parts_mut(self.dst, self.initialized);\n-                // SAFETY: this raw slice will contain only initialized objects\n-                // that's why, it is allowed to drop it.\n-                unsafe {\n-                    crate::ptr::drop_in_place(initialized_part);\n-                }\n-            }\n-        }\n-        let mut dst = MaybeUninit::uninit_array::<N>();\n-        let mut guard: Guard<U, N> =\n-            Guard { dst: MaybeUninit::slice_as_mut_ptr(&mut dst), initialized: 0 };\n-        for (src, dst) in IntoIter::new(self).zip(&mut dst) {\n-            dst.write(f(src));\n-            guard.initialized += 1;\n-        }\n-        // FIXME: Convert to crate::mem::transmute once it works with generics.\n-        // unsafe { crate::mem::transmute::<[MaybeUninit<U>; N], [U; N]>(dst) }\n-        crate::mem::forget(guard);\n-        // SAFETY: At this point we've properly initialized the whole array\n-        // and we just need to cast it to the correct type.\n-        unsafe { crate::mem::transmute_copy::<_, [U; N]>(&dst) }\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut IntoIter::new(self).map(f)) }\n     }\n \n     /// 'Zips up' two arrays into a single array of pairs.\n@@ -481,15 +454,11 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        let mut dst = MaybeUninit::uninit_array::<N>();\n-        for (i, (lhs, rhs)) in IntoIter::new(self).zip(IntoIter::new(rhs)).enumerate() {\n-            dst[i].write((lhs, rhs));\n-        }\n-        // FIXME: Convert to crate::mem::transmute once it works with generics.\n-        // unsafe { crate::mem::transmute::<[MaybeUninit<U>; N], [U; N]>(dst) }\n-        // SAFETY: At this point we've properly initialized the whole array\n-        // and we just need to cast it to the correct type.\n-        unsafe { crate::mem::transmute_copy::<_, [(T, U); N]>(&dst) }\n+        let mut iter = IntoIter::new(self).zip(IntoIter::new(rhs));\n+\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut iter) }\n     }\n \n     /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n@@ -535,16 +504,9 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_ref(&self) -> [&T; N] {\n-        // Unlike in `map`, we don't need a guard here, as dropping a reference\n-        // is a noop.\n-        let mut out = MaybeUninit::uninit_array::<N>();\n-        for (src, dst) in self.iter().zip(&mut out) {\n-            dst.write(src);\n-        }\n-\n-        // SAFETY: All elements of `dst` are properly initialized and\n-        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n-        unsafe { (&mut out as *mut _ as *mut [&T; N]).read() }\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut self.iter()) }\n     }\n \n     /// Borrows each element mutably and returns an array of mutable references\n@@ -564,15 +526,103 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_mut(&mut self) -> [&mut T; N] {\n-        // Unlike in `map`, we don't need a guard here, as dropping a reference\n-        // is a noop.\n-        let mut out = MaybeUninit::uninit_array::<N>();\n-        for (src, dst) in self.iter_mut().zip(&mut out) {\n-            dst.write(src);\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut self.iter_mut()) }\n+    }\n+}\n+\n+/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n+/// yields fewer than `N` items, this function exhibits undefined behavior.\n+///\n+/// See [`collect_into_array`] for more information.\n+///\n+///\n+/// # Safety\n+///\n+/// It is up to the caller to guarantee that `iter` yields at least `N` items.\n+/// Violating this condition causes undefined behavior.\n+unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+where\n+    // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n+    // internal function, so feel free to remove if this bound turns out to be a\n+    // bad idea. In that case, remember to also remove the lower bound\n+    // `debug_assert!` below!\n+    I: Iterator + TrustedLen,\n+{\n+    debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n+    debug_assert!(N <= iter.size_hint().0);\n+\n+    match collect_into_array(iter) {\n+        Some(array) => array,\n+        // SAFETY: covered by the function contract.\n+        None => unsafe { crate::hint::unreachable_unchecked() },\n+    }\n+}\n+\n+/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n+/// yields fewer than `N` items, `None` is returned and all already yielded\n+/// items are dropped.\n+///\n+/// Since the iterator is passed as mutable reference and this function calls\n+/// `next` at most `N` times, the iterator can still be used afterwards to\n+/// retrieve the remaining items.\n+///\n+/// If `iter.next()` panicks, all items already yielded by the iterator are\n+/// dropped.\n+fn collect_into_array<I, const N: usize>(iter: &mut I) -> Option<[I::Item; N]>\n+where\n+    I: Iterator,\n+{\n+    if N == 0 {\n+        // SAFETY: An empty array is always inhabited and has no validity invariants.\n+        return unsafe { Some(mem::zeroed()) };\n+    }\n+\n+    struct Guard<T, const N: usize> {\n+        ptr: *mut T,\n+        initialized: usize,\n+    }\n+\n+    impl<T, const N: usize> Drop for Guard<T, N> {\n+        fn drop(&mut self) {\n+            debug_assert!(self.initialized <= N);\n+\n+            let initialized_part = crate::ptr::slice_from_raw_parts_mut(self.ptr, self.initialized);\n+\n+            // SAFETY: this raw slice will contain only initialized objects.\n+            unsafe {\n+                crate::ptr::drop_in_place(initialized_part);\n+            }\n+        }\n+    }\n+\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    let mut guard: Guard<_, N> =\n+        Guard { ptr: MaybeUninit::slice_as_mut_ptr(&mut array), initialized: 0 };\n+\n+    while let Some(item) = iter.next() {\n+        // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n+        // loop and the loop is aborted once it reaches N (which is\n+        // `array.len()`).\n+        unsafe {\n+            array.get_unchecked_mut(guard.initialized).write(item);\n         }\n+        guard.initialized += 1;\n+\n+        // Check if the whole array was initialized.\n+        if guard.initialized == N {\n+            mem::forget(guard);\n \n-        // SAFETY: All elements of `dst` are properly initialized and\n-        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n-        unsafe { (&mut out as *mut _ as *mut [&mut T; N]).read() }\n+            // SAFETY: the condition above asserts that all elements are\n+            // initialized.\n+            let out = unsafe { MaybeUninit::array_assume_init(array) };\n+            return Some(out);\n+        }\n     }\n+\n+    // This is only reached if the iterator is exhausted before\n+    // `guard.initialized` reaches `N`. Also note that `guard` is dropped here,\n+    // dropping all already initialized elements.\n+    None\n }"}]}