{"sha": "557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1N2MxZTM2ZGRiYjE5Y2M3NmY3YTFmMDRkMWIzMjc5NDJhYWZjYjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-30T08:13:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-30T08:13:32Z"}, "message": "Merge #7494\n\n7494: Simpilfy mbe parsing r=edwin0cheng a=edwin0cheng\n\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "17161b762cf3b8585a8d00a093de6bc4782301d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17161b762cf3b8585a8d00a093de6bc4782301d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgFRUsCRBK7hj4Ov3rIwAAdHIIAIvrvrPJPOM9DG65wXsDNDek\nQY/OjHsEaiiD4bynkGFAzqHJdl66/iGX/WF5B0RRhLB9F9l3Te5mQ0sT5/1cNFxp\ngN8HIT1GbL1XH+pxNgoWdh1hwssYIKRucsgRd3qWJmchNLXoaDfALd/N40JtQnsd\nRd5LR/frv3kc0LucV5mREzoHcnm68IEMhBRbOa9H/7t6G80Qa3cZdbUJ/5nz7PdK\niA/kVZmJ1pdHxNSFzb+gNBiFov3J521NeMizT0SM/qS812AylBzkCt7MdcqBTqcC\nnUrYAhsk3tDKQ+Y2AO4c1ROnSkgbZeYVLnQwUCCt/nUooUTBwrVQQOQ9sGsDo2w=\n=3qxv\n-----END PGP SIGNATURE-----\n", "payload": "tree 17161b762cf3b8585a8d00a093de6bc4782301d8\nparent 715dade21b531c4cf74ee95a453540ec7ef68d1b\nparent 438b34dceede1cf0bebef9309d90ab6a3bde5002\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611994412 +0000\ncommitter GitHub <noreply@github.com> 1611994412 +0000\n\nMerge #7494\n\n7494: Simpilfy mbe parsing r=edwin0cheng a=edwin0cheng\n\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "html_url": "https://github.com/rust-lang/rust/commit/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "715dade21b531c4cf74ee95a453540ec7ef68d1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/715dade21b531c4cf74ee95a453540ec7ef68d1b", "html_url": "https://github.com/rust-lang/rust/commit/715dade21b531c4cf74ee95a453540ec7ef68d1b"}, {"sha": "438b34dceede1cf0bebef9309d90ab6a3bde5002", "url": "https://api.github.com/repos/rust-lang/rust/commits/438b34dceede1cf0bebef9309d90ab6a3bde5002", "html_url": "https://github.com/rust-lang/rust/commit/438b34dceede1cf0bebef9309d90ab6a3bde5002"}], "stats": {"total": 145, "additions": 71, "deletions": 74}, "files": [{"sha": "800931cd1d6a31040426457b4db9ca85179958f2", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "patch": "@@ -70,7 +70,7 @@ pub(super) struct Match {\n }\n \n impl Match {\n-    pub(super) fn add_err(&mut self, err: ExpandError) {\n+    fn add_err(&mut self, err: ExpandError) {\n         let prev_err = self.err.take();\n         self.err = prev_err.or(Some(err));\n         self.err_count += 1;\n@@ -79,12 +79,10 @@ impl Match {\n \n /// Matching errors are added to the `Match`.\n pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n-    assert!(pattern.delimiter == None);\n-\n     let mut res = Match::default();\n     let mut src = TtIter::new(src);\n \n-    match_subtree(&mut res, pattern, &mut src);\n+    match_tokens(&mut res, pattern, &mut src);\n \n     if src.len() > 0 {\n         res.unmatched_tts += src.len();\n@@ -94,49 +92,29 @@ pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     res\n }\n \n-fn match_subtree(res: &mut Match, pattern: &MetaTemplate, src: &mut TtIter) {\n+fn match_tokens(res: &mut Match, pattern: &MetaTemplate, src: &mut TtIter) {\n     for op in pattern.iter() {\n         match op {\n             Op::Leaf(lhs) => {\n-                let rhs = match src.expect_leaf() {\n-                    Ok(l) => l,\n-                    Err(()) => {\n-                        res.add_err(err!(\"expected leaf: `{}`\", lhs));\n-                        continue;\n-                    }\n-                };\n-                match (lhs, rhs) {\n-                    (\n-                        tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n-                        tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n-                    ) if lhs == rhs => (),\n-                    (\n-                        tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n-                        tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n-                    ) if lhs == rhs => (),\n-                    (\n-                        tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n-                        tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n-                    ) if lhs == rhs => (),\n-                    _ => {\n-                        res.add_err(ExpandError::UnexpectedToken);\n-                    }\n+                if let Err(err) = match_leaf(lhs, src) {\n+                    res.add_err(err);\n+                    continue;\n                 }\n             }\n-            Op::Subtree(lhs) => {\n+            Op::Subtree { tokens, delimiter: delim } => {\n                 let rhs = match src.expect_subtree() {\n                     Ok(s) => s,\n                     Err(()) => {\n                         res.add_err(err!(\"expected subtree\"));\n                         continue;\n                     }\n                 };\n-                if lhs.delimiter_kind() != rhs.delimiter_kind() {\n+                if delim.map(|it| it.kind) != rhs.delimiter_kind() {\n                     res.add_err(err!(\"mismatched delimiter\"));\n                     continue;\n                 }\n                 let mut src = TtIter::new(rhs);\n-                match_subtree(res, lhs, &mut src);\n+                match_tokens(res, tokens, &mut src);\n                 if src.len() > 0 {\n                     res.add_err(err!(\"leftover tokens\"));\n                 }\n@@ -162,14 +140,42 @@ fn match_subtree(res: &mut Match, pattern: &MetaTemplate, src: &mut TtIter) {\n                     res.add_err(err);\n                 }\n             }\n-            Op::Repeat { subtree, kind, separator } => {\n+            Op::Repeat { tokens: subtree, kind, separator } => {\n                 match_repeat(res, subtree, *kind, separator, src);\n             }\n         }\n     }\n }\n \n-pub(super) fn match_repeat(\n+fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n+    let rhs = match src.expect_leaf() {\n+        Ok(l) => l,\n+        Err(()) => {\n+            return Err(err!(\"expected leaf: `{}`\", lhs));\n+        }\n+    };\n+    match (lhs, rhs) {\n+        (\n+            tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n+            tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n+        ) if lhs == rhs => (),\n+        (\n+            tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n+            tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n+        ) if lhs == rhs => (),\n+        (\n+            tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n+            tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n+        ) if lhs == rhs => (),\n+        _ => {\n+            return Err(ExpandError::UnexpectedToken);\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn match_repeat(\n     res: &mut Match,\n     pattern: &MetaTemplate,\n     kind: RepeatKind,\n@@ -191,7 +197,7 @@ pub(super) fn match_repeat(\n         }\n \n         let mut nested = Match::default();\n-        match_subtree(&mut nested, pattern, &mut fork);\n+        match_tokens(&mut nested, pattern, &mut fork);\n         if nested.err.is_none() {\n             limit -= 1;\n             if limit == 0 {\n@@ -292,8 +298,8 @@ fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) {\n         match op {\n             Op::Var { name, .. } => buf.push(name.clone()),\n             Op::Leaf(_) => (),\n-            Op::Subtree(subtree) => collect_vars(buf, subtree),\n-            Op::Repeat { subtree, .. } => collect_vars(buf, subtree),\n+            Op::Subtree { tokens, .. } => collect_vars(buf, tokens),\n+            Op::Repeat { tokens, .. } => collect_vars(buf, tokens),\n         }\n     }\n }\n@@ -325,7 +331,7 @@ impl<'a> TtIter<'a> {\n         ok\n     }\n \n-    pub(crate) fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n+    fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n         match self.peek_n(0) {\n             Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '\\'' => {\n                 return self.expect_lifetime();\n@@ -386,7 +392,7 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n+    fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n         let punct = self.expect_punct()?;\n         if punct.char != '\\'' {\n             return Err(());\n@@ -403,13 +409,13 @@ impl<'a> TtIter<'a> {\n         .into())\n     }\n \n-    pub(crate) fn expect_fragment(\n+    fn expect_fragment(\n         &mut self,\n         fragment_kind: parser::FragmentKind,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n-        pub(crate) struct OffsetTokenSink<'a> {\n-            pub(crate) cursor: Cursor<'a>,\n-            pub(crate) error: bool,\n+        struct OffsetTokenSink<'a> {\n+            cursor: Cursor<'a>,\n+            error: bool,\n         }\n \n         impl<'a> TreeSink for OffsetTokenSink<'a> {\n@@ -465,7 +471,7 @@ impl<'a> TtIter<'a> {\n         ExpandResult { value: res, err }\n     }\n \n-    pub(crate) fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n+    fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n         let mut fork = self.clone();\n         match fork.expect_fragment(Visibility) {\n             ExpandResult { value: tt, err: None } => {\n@@ -476,7 +482,7 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn eat_char(&mut self, c: char) -> Option<tt::TokenTree> {\n+    fn eat_char(&mut self, c: char) -> Option<tt::TokenTree> {\n         let mut fork = self.clone();\n         match fork.expect_char(c) {\n             Ok(_) => {"}, {"sha": "78368a33e504cc1d7bd62460829fb3be062827b0", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "patch": "@@ -2,6 +2,7 @@\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n use syntax::SmolStr;\n+use tt::Delimiter;\n \n use super::ExpandResult;\n use crate::{\n@@ -54,10 +55,9 @@ pub(super) fn transcribe(\n     template: &MetaTemplate,\n     bindings: &Bindings,\n ) -> ExpandResult<tt::Subtree> {\n-    assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n     let mut arena: Vec<tt::TokenTree> = Vec::new();\n-    expand_subtree(&mut ctx, template, &mut arena)\n+    expand_subtree(&mut ctx, template, None, &mut arena)\n }\n \n #[derive(Debug)]\n@@ -80,6 +80,7 @@ struct ExpandCtx<'a> {\n fn expand_subtree(\n     ctx: &mut ExpandCtx,\n     template: &MetaTemplate,\n+    delimiter: Option<Delimiter>,\n     arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<tt::Subtree> {\n     // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n@@ -88,8 +89,9 @@ fn expand_subtree(\n     for op in template.iter() {\n         match op {\n             Op::Leaf(tt) => arena.push(tt.clone().into()),\n-            Op::Subtree(tt) => {\n-                let ExpandResult { value: tt, err: e } = expand_subtree(ctx, &tt, arena);\n+            Op::Subtree { tokens, delimiter } => {\n+                let ExpandResult { value: tt, err: e } =\n+                    expand_subtree(ctx, &tokens, *delimiter, arena);\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n@@ -98,7 +100,7 @@ fn expand_subtree(\n                 err = err.or(e);\n                 push_fragment(arena, fragment);\n             }\n-            Op::Repeat { subtree, kind, separator } => {\n+            Op::Repeat { tokens: subtree, kind, separator } => {\n                 let ExpandResult { value: fragment, err: e } =\n                     expand_repeat(ctx, subtree, *kind, separator, arena);\n                 err = err.or(e);\n@@ -108,7 +110,7 @@ fn expand_subtree(\n     }\n     // drain the elements added in this instance of expand_subtree\n     let tts = arena.drain(start_elements..arena.len()).collect();\n-    ExpandResult { value: tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err }\n+    ExpandResult { value: tt::Subtree { delimiter, token_trees: tts }, err }\n }\n \n fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n@@ -162,7 +164,7 @@ fn expand_repeat(\n     let mut counter = 0;\n \n     loop {\n-        let ExpandResult { value: mut t, err: e } = expand_subtree(ctx, template, arena);\n+        let ExpandResult { value: mut t, err: e } = expand_subtree(ctx, template, None, arena);\n         let nesting_state = ctx.nesting.last_mut().unwrap();\n         if nesting_state.at_end || !nesting_state.hit {\n             break;"}, {"sha": "d80bd7a3355f32203af70c6c56d1298d5fc42d6d", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "patch": "@@ -92,18 +92,11 @@ struct Rule {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-struct MetaTemplate {\n-    delimiter: Option<Delimiter>,\n-    tokens: Vec<Op>,\n-}\n+struct MetaTemplate(Vec<Op>);\n \n impl<'a> MetaTemplate {\n     fn iter(&self) -> impl Iterator<Item = &Op> {\n-        self.tokens.iter()\n-    }\n-\n-    fn delimiter_kind(&self) -> Option<DelimiterKind> {\n-        self.delimiter.map(|it| it.kind)\n+        self.0.iter()\n     }\n }\n \n@@ -288,8 +281,8 @@ impl Rule {\n             .expect_subtree()\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;\n \n-        let lhs = MetaTemplate { tokens: parse_pattern(&lhs)?, delimiter: None };\n-        let rhs = MetaTemplate { tokens: parse_template(&rhs)?, delimiter: None };\n+        let lhs = MetaTemplate(parse_pattern(&lhs)?);\n+        let rhs = MetaTemplate(parse_template(&rhs)?);\n \n         Ok(crate::Rule { lhs, rhs })\n     }\n@@ -298,8 +291,8 @@ impl Rule {\n fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n     for op in pattern.iter() {\n         match op {\n-            Op::Subtree(subtree) => validate(&subtree)?,\n-            Op::Repeat { subtree, separator, .. } => {\n+            Op::Subtree { tokens, .. } => validate(&tokens)?,\n+            Op::Repeat { tokens: subtree, separator, .. } => {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n \n@@ -319,7 +312,7 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n                                 )\n                             }\n                             Op::Leaf(_) => {}\n-                            Op::Subtree(_) => {}\n+                            Op::Subtree { .. } => {}\n                         }\n                         false\n                     }) {"}, {"sha": "f891ec29c6e80b1dacf5fb88b6aac9a74de23da2", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557c1e36ddbb19cc76f7a1f04d1b327942aafcb9/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=557c1e36ddbb19cc76f7a1f04d1b327942aafcb9", "patch": "@@ -3,15 +3,16 @@\n \n use smallvec::SmallVec;\n use syntax::SmolStr;\n+use tt::Delimiter;\n \n use crate::{tt_iter::TtIter, MetaTemplate, ParseError};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n     Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n-    Repeat { subtree: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n+    Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Leaf(tt::Leaf),\n-    Subtree(MetaTemplate),\n+    Subtree { tokens: MetaTemplate, delimiter: Option<Delimiter> },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -92,12 +93,10 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n             match second {\n                 tt::TokenTree::Subtree(subtree) => {\n                     let (separator, kind) = parse_repeat(src)?;\n-                    let delimiter = subtree.delimiter;\n                     let tokens = parse_inner(&subtree, mode)\n                         .into_iter()\n                         .collect::<Result<Vec<Op>, ParseError>>()?;\n-                    let subtree = MetaTemplate { tokens, delimiter };\n-                    Op::Repeat { subtree, separator, kind }\n+                    Op::Repeat { tokens: MetaTemplate(tokens), separator, kind }\n                 }\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Punct(punct) => {\n@@ -136,12 +135,9 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n         }\n         tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n         tt::TokenTree::Subtree(subtree) => {\n-            let delimiter = subtree.delimiter;\n             let tokens =\n                 parse_inner(&subtree, mode).into_iter().collect::<Result<Vec<Op>, ParseError>>()?;\n-\n-            let subtree = MetaTemplate { tokens, delimiter };\n-            Op::Subtree(subtree)\n+            Op::Subtree { tokens: MetaTemplate(tokens), delimiter: subtree.delimiter }\n         }\n     };\n     Ok(res)"}]}