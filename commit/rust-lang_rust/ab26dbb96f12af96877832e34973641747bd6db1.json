{"sha": "ab26dbb96f12af96877832e34973641747bd6db1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMjZkYmI5NmYxMmFmOTY4Nzc4MzJlMzQ5NzM2NDE3NDdiZDZkYjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-07-01T15:36:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-12T03:43:34Z"}, "message": "rustc: always normalize projections in ty::layout regardless where they appear.", "tree": {"sha": "102df7fe2376522d22a99e0d7137172b81b7d4ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102df7fe2376522d22a99e0d7137172b81b7d4ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab26dbb96f12af96877832e34973641747bd6db1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab26dbb96f12af96877832e34973641747bd6db1", "html_url": "https://github.com/rust-lang/rust/commit/ab26dbb96f12af96877832e34973641747bd6db1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab26dbb96f12af96877832e34973641747bd6db1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1d16c94c5ec007ce91ec306bdf06c8ee6f2d29a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d16c94c5ec007ce91ec306bdf06c8ee6f2d29a", "html_url": "https://github.com/rust-lang/rust/commit/d1d16c94c5ec007ce91ec306bdf06c8ee6f2d29a"}], "stats": {"total": 90, "additions": 65, "deletions": 25}, "files": [{"sha": "e27a9d79b62d110188ef91343008200cb70d65ee", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ab26dbb96f12af96877832e34973641747bd6db1/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab26dbb96f12af96877832e34973641747bd6db1/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ab26dbb96f12af96877832e34973641747bd6db1", "patch": "@@ -558,8 +558,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             (&Univariant { non_zero: true, .. }, &ty::TyStruct(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n-                let ty = normalize_associated_type(infcx, fields[0].ty(tcx, substs));\n-                match *ty.layout(infcx)? {\n+                match *fields[0].ty(tcx, substs).layout(infcx)? {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n@@ -577,7 +576,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             (_, &ty::TyStruct(def, substs)) => {\n                 Struct::non_zero_field_path(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n-                    normalize_associated_type(infcx, field.ty(tcx, substs))\n+                    field.ty(tcx, substs)\n                 }))\n             }\n \n@@ -595,6 +594,14 @@ impl<'a, 'gcx, 'tcx> Struct {\n                 Struct::non_zero_field_path(infcx, Some(ety).into_iter())\n             }\n \n+            (_, &ty::TyProjection(_)) => {\n+                let normalized = normalize_associated_type(infcx, ty);\n+                if ty == normalized {\n+                    return Ok(None);\n+                }\n+                return Struct::non_zero_field_in_type(infcx, normalized);\n+            }\n+\n             // Anything else is not a non-zero type.\n             _ => Ok(None)\n         }\n@@ -762,8 +769,9 @@ fn normalize_associated_type<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> Layout {\n     pub fn compute_uncached(ty: Ty<'gcx>,\n                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                            -> Result<Layout, LayoutError<'gcx>> {\n+                            -> Result<&'gcx Layout, LayoutError<'gcx>> {\n         let tcx = infcx.tcx.global_tcx();\n+        let success = |layout| Ok(tcx.intern_layout(layout));\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n@@ -795,6 +803,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                     Scalar { value: Pointer, non_zero: non_zero }\n                 } else {\n+                    let pointee = normalize_associated_type(infcx, pointee);\n                     let unsized_part = tcx.struct_tail(pointee);\n                     let meta = match unsized_part.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n@@ -860,7 +869,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let element = ty.simd_type(tcx);\n                     match *element.layout(infcx)? {\n                         Scalar { value, .. } => {\n-                            return Ok(Vector {\n+                            return success(Vector {\n                                 element: value,\n                                 count: ty.simd_size(tcx) as u64\n                             });\n@@ -873,8 +882,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n                 }\n                 let fields = def.struct_variant().fields.iter().map(|field| {\n-                    normalize_associated_type(infcx, field.ty(tcx, substs))\n-                        .layout(infcx)\n+                    field.ty(tcx, substs).layout(infcx)\n                 });\n                 let packed = tcx.lookup_packed(def.did);\n                 let mut st = Struct::new(dl, packed);\n@@ -914,7 +922,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                     let mut st = Struct::new(dl, false);\n                     st.extend(dl, drop_flag.iter().map(Ok), ty)?;\n-                    return Ok(Univariant { variant: st, non_zero: false });\n+                    return success(Univariant { variant: st, non_zero: false });\n                 }\n \n                 if !dtor && def.variants.iter().all(|v| v.fields.is_empty()) {\n@@ -927,7 +935,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n \n                     let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n-                    return Ok(CEnum {\n+                    return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n                         min: min as u64,\n@@ -950,19 +958,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     // (Typechecking will reject discriminant-sizing attrs.)\n                     assert_eq!(hint, attr::ReprAny);\n                     let fields = def.variants[0].fields.iter().map(|field| {\n-                        normalize_associated_type(infcx, field.ty(tcx, substs))\n-                            .layout(infcx)\n+                        field.ty(tcx, substs).layout(infcx)\n                     });\n                     let mut st = Struct::new(dl, false);\n                     st.extend(dl, fields.chain(drop_flag.iter().map(Ok)), ty)?;\n-                    return Ok(Univariant { variant: st, non_zero: false });\n+                    return success(Univariant { variant: st, non_zero: false });\n                 }\n \n                 // Cache the substituted and normalized variant field types.\n                 let variants = def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|field| {\n-                        normalize_associated_type(infcx, field.ty(tcx, substs))\n-                    }).collect::<Vec<_>>()\n+                    v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n                 if !dtor && variants.len() == 2 && hint == attr::ReprAny {\n@@ -982,7 +987,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if path == &[0] && variants[discr].len() == 1 {\n                             match *variants[discr][0].layout(infcx)? {\n                                 Scalar { value, .. } => {\n-                                    return Ok(RawNullablePointer {\n+                                    return success(RawNullablePointer {\n                                         nndiscr: discr as u64,\n                                         value: value\n                                     });\n@@ -998,10 +1003,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         path.push(0); // For GEP through a pointer.\n                         path.reverse();\n                         let mut st = Struct::new(dl, false);\n-                        st.extend(dl, variants[discr].iter().map(|ty| {\n-                            ty.layout(infcx)\n-                        }), ty)?;\n-                        return Ok(StructWrappedNullablePointer {\n+                        st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n+                        return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n                             discrfield: path\n@@ -1105,15 +1108,22 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // Types with no meaningful known layout.\n-            ty::TyProjection(_) | ty::TyParam(_) => {\n+            ty::TyProjection(_) => {\n+                let normalized = normalize_associated_type(infcx, ty);\n+                if ty == normalized {\n+                    return Err(LayoutError::Unknown(ty));\n+                }\n+                return normalized.layout(infcx);\n+            }\n+            ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n             ty::TyInfer(_) | ty::TyError => {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n         };\n \n-        Ok(layout)\n+        success(layout)\n     }\n \n     /// Returns true if the layout corresponds to an unsized type.\n@@ -1272,8 +1282,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i: usize| {\n                     let fields = def.variants[i].fields.iter().map(|field| {\n-                        let ty = normalize_associated_type(infcx, &field.ty(tcx, substs));\n-                        SizeSkeleton::compute(ty, infcx)\n+                        SizeSkeleton::compute(field.ty(tcx, substs), infcx)\n                     });\n                     let mut ptr = None;\n                     for field in fields {\n@@ -1323,6 +1332,15 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 }\n             }\n \n+            ty::TyProjection(_) => {\n+                let normalized = normalize_associated_type(infcx, ty);\n+                if ty == normalized {\n+                    Err(err)\n+                } else {\n+                    SizeSkeleton::compute(normalized, infcx)\n+                }\n+            }\n+\n             _ => Err(err)\n         }\n     }"}, {"sha": "07439d7104af4348ed8cd350b5cca5a860c70eee", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab26dbb96f12af96877832e34973641747bd6db1/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab26dbb96f12af96877832e34973641747bd6db1/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ab26dbb96f12af96877832e34973641747bd6db1", "patch": "@@ -626,7 +626,6 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         }\n \n         let layout = Layout::compute_uncached(self, infcx)?;\n-        let layout = tcx.intern_layout(layout);\n         if can_cache {\n             tcx.layout_cache.borrow_mut().insert(self, layout);\n         }"}, {"sha": "823def32270445314d2cb425ac56c981ca674721", "filename": "src/test/run-pass/transmute-specialization.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ab26dbb96f12af96877832e34973641747bd6db1/src%2Ftest%2Frun-pass%2Ftransmute-specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab26dbb96f12af96877832e34973641747bd6db1/src%2Ftest%2Frun-pass%2Ftransmute-specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftransmute-specialization.rs?ref=ab26dbb96f12af96877832e34973641747bd6db1", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+trait Specializable { type Output; }\n+\n+impl<T> Specializable for T {\n+    default type Output = u16;\n+}\n+\n+fn main() {\n+    unsafe {\n+        std::mem::transmute::<u16, <() as Specializable>::Output>(0);\n+    }\n+}"}]}