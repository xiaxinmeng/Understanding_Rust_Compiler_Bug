{"sha": "36305e3a504434aa49999d6e56c28170cd2312c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MzA1ZTNhNTA0NDM0YWE0OTk5OWQ2ZTU2YzI4MTcwY2QyMzEyYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-24T13:45:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-24T13:45:51Z"}, "message": "Auto merge of #1136 - Aaron1011:feature/check-libstd, r=RalfJung\n\nUse 'cargo check' to build the sysroot and target crate\n\nFixes #1057\n\nI'm using my original approach from PR #1048. Ideally, we would\ndistinguish between build-deps/dependencies/'final crate' via a\ndifferent approach (e.g. the target directory). However, I\nhaven't been able to get that to work just yet.\n\nHowever, everything should be working with the approach I'm using. At a\nminimum, we can use this PR to verify that everything works as expected\nwhen we don't actually produce native build outputs.", "tree": {"sha": "0ff14b2b60a443949243086847a5b75eb8ad62eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ff14b2b60a443949243086847a5b75eb8ad62eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36305e3a504434aa49999d6e56c28170cd2312c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36305e3a504434aa49999d6e56c28170cd2312c0", "html_url": "https://github.com/rust-lang/rust/commit/36305e3a504434aa49999d6e56c28170cd2312c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36305e3a504434aa49999d6e56c28170cd2312c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c444bf6a6cff3b9014005f21cc44995b34862ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c444bf6a6cff3b9014005f21cc44995b34862ce", "html_url": "https://github.com/rust-lang/rust/commit/3c444bf6a6cff3b9014005f21cc44995b34862ce"}, {"sha": "faf7bf538d3bf61321ca0128ad039d5d13fc2a40", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf7bf538d3bf61321ca0128ad039d5d13fc2a40", "html_url": "https://github.com/rust-lang/rust/commit/faf7bf538d3bf61321ca0128ad039d5d13fc2a40"}], "stats": {"total": 175, "additions": 110, "deletions": 65}, "files": [{"sha": "951e91dad5b295efee5ff74190b2e9a5ae1880e8", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36305e3a504434aa49999d6e56c28170cd2312c0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/36305e3a504434aa49999d6e56c28170cd2312c0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=36305e3a504434aa49999d6e56c28170cd2312c0", "patch": "@@ -334,6 +334,7 @@ dependencies = [\n  \"rustc-workspace-hack 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vergen 3.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]"}, {"sha": "896c726b9aa6540a3a581ee396c65f7fa3193a7a", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36305e3a504434aa49999d6e56c28170cd2312c0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/36305e3a504434aa49999d6e56c28170cd2312c0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=36305e3a504434aa49999d6e56c28170cd2312c0", "patch": "@@ -33,6 +33,8 @@ required-features = [\"rustc_tests\"]\n cargo_metadata = { version = \"0.9.0\", optional = true }\n directories = { version = \"2.0\", optional = true }\n rustc_version = { version = \"0.2.3\", optional = true }\n+serde_json = { version = \"1.0.44\", optional = true }\n+\n getrandom = { version = \"0.1.8\", features = [\"std\"] }\n byteorder = \"1.3\"\n env_logger = \"0.7.1\"\n@@ -56,7 +58,7 @@ vergen = \"3\"\n \n [features]\n default = [\"cargo_miri\"]\n-cargo_miri = [\"cargo_metadata\", \"directories\", \"rustc_version\"]\n+cargo_miri = [\"cargo_metadata\", \"directories\", \"rustc_version\", \"serde_json\"]\n rustc_tests = []\n \n [dev-dependencies]"}, {"sha": "17063b6ff67fcb197ee79c746cdfef0274a5773d", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 106, "deletions": 64, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/36305e3a504434aa49999d6e56c28170cd2312c0/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36305e3a504434aa49999d6e56c28170cd2312c0/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=36305e3a504434aa49999d6e56c28170cd2312c0", "patch": "@@ -6,7 +6,7 @@ use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 17);\n+const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 19);\n \n const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n \n@@ -23,7 +23,7 @@ Common options:\n     --features               Features to compile for the package\n     -V, --version            Print version info and exit\n \n-Other [options] are the same as `cargo rustc`.  Everything after the first \"--\" is\n+Other [options] are the same as `cargo check`.  Everything after the first \"--\" is\n passed verbatim to Miri, which will pass everything after the second \"--\" verbatim\n to the interpreted program.\n \"#;\n@@ -84,6 +84,31 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n+/// Returns the path to the `miri` binary\n+fn find_miri() -> PathBuf {\n+    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n+    path.set_file_name(\"miri\");\n+    path\n+}\n+\n+fn cargo() -> Command {\n+    if let Ok(val) = std::env::var(\"CARGO\") {\n+        // Bootstrap tells us where to find cargo\n+        Command::new(val)\n+    } else {\n+        Command::new(\"cargo\")\n+    }\n+}\n+\n+fn xargo() -> Command {\n+    if let Ok(val) = std::env::var(\"XARGO\") {\n+        // Bootstrap tells us where to find xargo\n+        Command::new(val)\n+    } else {\n+        Command::new(\"xargo-check\")\n+    }\n+}\n+\n fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     // We need to get the manifest, and then the metadata, to enumerate targets.\n     let manifest_path =\n@@ -127,13 +152,6 @@ fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     package.targets.into_iter()\n }\n \n-/// Returns the path to the `miri` binary\n-fn find_miri() -> PathBuf {\n-    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n-    path.set_file_name(\"miri\");\n-    path\n-}\n-\n /// Make sure that the `miri` and `rustc` binary are from the same sysroot.\n /// This can be violated e.g. when miri is locally built and installed with a different\n /// toolchain than what is used when `cargo miri` is run.\n@@ -183,24 +201,6 @@ fn test_sysroot_consistency() {\n     }\n }\n \n-fn cargo() -> Command {\n-    if let Ok(val) = std::env::var(\"CARGO\") {\n-        // Bootstrap tells us where to find cargo\n-        Command::new(val)\n-    } else {\n-        Command::new(\"cargo\")\n-    }\n-}\n-\n-fn xargo() -> Command {\n-    if let Ok(val) = std::env::var(\"XARGO\") {\n-        // Bootstrap tells us where to find xargo\n-        Command::new(val)\n-    } else {\n-        Command::new(\"xargo\")\n-    }\n-}\n-\n fn xargo_version() -> Option<(u32, u32, u32)> {\n     let out = xargo().arg(\"--version\").output().ok()?;\n     if !out.status.success() {\n@@ -357,6 +357,7 @@ features = [\"panic_unwind\"]\n         )\n         .unwrap();\n     // The boring bits: a dummy project for xargo.\n+    // FIXME: With xargo-check, can we avoid doing this?\n     File::create(dir.join(\"Cargo.toml\"))\n         .unwrap()\n         .write_all(\n@@ -419,12 +420,12 @@ fn main() {\n     }\n \n     if let Some(\"miri\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // This arm is for when `cargo miri` is called. We call `cargo rustc` for each applicable target,\n+        // This arm is for when `cargo miri` is called. We call `cargo check` for each applicable target,\n         // but with the `RUSTC` env var set to the `cargo-miri` binary so that we come back in the other branch,\n         // and dispatch the invocations to `rustc` and `miri`, respectively.\n         in_cargo_miri();\n     } else if let Some(\"rustc\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // This arm is executed when `cargo-miri` runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n+        // This arm is executed when `cargo-miri` runs `cargo check` with the `RUSTC_WRAPPER` env var set to itself:\n         // dependencies get dispatched to `rustc`, the final test/binary to `miri`.\n         inside_cargo_rustc();\n     } else {\n@@ -463,11 +464,11 @@ fn in_cargo_miri() {\n             .kind\n             .get(0)\n             .expect(\"badly formatted cargo metadata: target::kind is an empty array\");\n-        // Now we run `cargo rustc $FLAGS $ARGS`, giving the user the\n+        // Now we run `cargo check $FLAGS $ARGS`, giving the user the\n         // change to add additional arguments. `FLAGS` is set to identify\n         // this target.  The user gets to control what gets actually passed to Miri.\n         let mut cmd = cargo();\n-        cmd.arg(\"rustc\");\n+        cmd.arg(\"check\");\n         match (subcommand, kind.as_str()) {\n             (MiriCommand::Run, \"bin\") => {\n                 // FIXME: we just run all the binaries here.\n@@ -487,20 +488,29 @@ fn in_cargo_miri() {\n             // The remaining targets we do not even want to build.\n             _ => continue,\n         }\n-        // Add user-defined args until first `--`.\n+        // Forward user-defined `cargo` args until first `--`.\n         while let Some(arg) = args.next() {\n             if arg == \"--\" {\n                 break;\n             }\n             cmd.arg(arg);\n         }\n-        // Add `--` (to end the `cargo` flags), and then the user flags. We add markers around the\n-        // user flags to be able to identify them later.  \"cargo rustc\" adds more stuff after this,\n-        // so we have to mark both the beginning and the end.\n-        cmd.arg(\"--\").arg(\"cargo-miri-marker-begin\").args(args).arg(\"cargo-miri-marker-end\");\n+\n+        // Serialize the remaining args into a special environemt variable.\n+        // This will be read by `inside_cargo_rustc` when we go to invoke\n+        // our actual target crate (the binary or the test we are running).\n+        // Since we're using \"cargo check\", we have no other way of passing\n+        // these arguments.\n+        let args_vec: Vec<String> = args.collect();\n+        cmd.env(\"MIRI_ARGS\", serde_json::to_string(&args_vec).expect(\"failed to serialize args\"));\n+\n+        // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n+        // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n+        // the two codepaths.\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {\n+            cmd.env(\"MIRI_VERBOSE\", \"\"); // this makes `inside_cargo_rustc` verbose.\n             eprintln!(\"+ {:?}\", cmd);\n         }\n \n@@ -514,38 +524,71 @@ fn in_cargo_miri() {\n }\n \n fn inside_cargo_rustc() {\n-    let sysroot = std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n-\n-    let rustc_args = std::env::args().skip(2); // skip `cargo rustc`\n-    let mut args: Vec<String> =\n-        rustc_args.chain(Some(\"--sysroot\".to_owned())).chain(Some(sysroot)).collect();\n-    args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n-\n-    // See if we can find the `cargo-miri` markers. Those only get added to the binary we want to\n-    // run. They also serve to mark the user-defined arguments, which we have to move all the way\n-    // to the end (they get added somewhere in the middle).\n-    let needs_miri =\n-        if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n-            let end = args\n-                .iter()\n-                .position(|arg| arg == \"cargo-miri-marker-end\")\n-                .expect(\"cannot find end marker\");\n-            // These mark the user arguments. We remove the first and last as they are the markers.\n-            let mut user_args = args.drain(begin..=end);\n-            assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n-            assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n-            // Collect the rest and add it back at the end.\n-            let mut user_args = user_args.collect::<Vec<String>>();\n+    /// Determines if we are being invoked (as rustc) to build a runnable\n+    /// executable. We run \"cargo check\", so this should only happen when\n+    /// we are trying to compile a build script or build script dependency,\n+    /// which actually needs to be executed on the host platform.\n+    ///\n+    /// Currently, we detect this by checking for \"--emit=link\",\n+    /// which indicates that Cargo instruced rustc to output\n+    /// a native object.\n+    fn is_target_crate() -> bool {\n+        // `--emit` is sometimes missing, e.g. cargo calls rustc for \"--print\".\n+        // That is definitely not a target crate.\n+        // If `--emit` is present, then host crates are built (\"--emit=link,...),\n+        // while the rest is only checked.\n+        get_arg_flag_value(\"--emit\").map_or(false, |emit| !emit.contains(\"link\"))\n+    }\n+\n+    /// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n+    /// the final, target crate (either a test for 'cargo test', or a binary for 'cargo run')\n+    /// Cargo does not give us this information directly, so we need to check\n+    /// various command-line flags.\n+    fn is_runnable_crate() -> bool {\n+        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref() == Some(\"bin\");\n+        let is_test = has_arg_flag(\"--test\");\n+\n+        // The final runnable (under Miri) crate will either be a binary crate\n+        // or a test crate. We make sure to exclude build scripts here, since\n+        // they are also build with \"--crate-type bin\"\n+        is_bin || is_test\n+    }\n+\n+    let verbose = std::env::var(\"MIRI_VERBOSE\").is_ok();\n+    let target_crate = is_target_crate();\n+\n+    // Figure out which arguments we need to pass.\n+    let mut args: Vec<String> = std::env::args().skip(2).collect(); // skip `cargo-miri rustc`\n+    // We make sure to only specify our custom Xargo sysroot and\n+    // other args for target crates - that is, crates which are ultimately\n+    // going to get interpreted by Miri.\n+    if target_crate {\n+        let sysroot = std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n+        args.push(\"--sysroot\".to_owned());\n+        args.push(sysroot);\n+        args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n+    }\n+\n+    // Figure out the binary we need to call. If this is a runnable target crate, we want to call\n+    // Miri to start interpretation; otherwise we want to call rustc to build the crate as usual.\n+    let mut command =\n+        if target_crate && is_runnable_crate() {\n+            // This is the 'target crate' - the binary or test crate that\n+            // we want to interpret under Miri. We deserialize the user-provided arguments\n+            // from the special environment variable \"MIRI_ARGS\", and feed them\n+            // to the 'miri' binary.\n+            let magic = std::env::var(\"MIRI_ARGS\").expect(\"missing MIRI_ARGS\");\n+            let mut user_args: Vec<String> = serde_json::from_str(&magic).expect(\"failed to deserialize MIRI_ARGS\");\n             args.append(&mut user_args);\n             // Run this in Miri.\n-            true\n+            Command::new(find_miri())\n         } else {\n-            false\n+            Command::new(\"rustc\")\n         };\n \n-    let mut command = if needs_miri { Command::new(find_miri()) } else { Command::new(\"rustc\") };\n+    // Run it.\n     command.args(&args);\n-    if has_arg_flag(\"-v\") {\n+    if verbose {\n         eprintln!(\"+ {:?}\", command);\n     }\n \n@@ -554,7 +597,6 @@ fn inside_cargo_rustc() {\n             if !exit.success() {\n                 std::process::exit(exit.code().unwrap_or(42));\n             },\n-        Err(ref e) if needs_miri => panic!(\"error during miri run: {:?}\", e),\n-        Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n+        Err(ref e) => panic!(\"error running {:?}:\\n{:?}\", command, e),\n     }\n }"}]}