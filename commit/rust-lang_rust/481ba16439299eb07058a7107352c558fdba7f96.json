{"sha": "481ba16439299eb07058a7107352c558fdba7f96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MWJhMTY0MzkyOTllYjA3MDU4YTcxMDczNTJjNTU4ZmRiYTdmOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-23T18:35:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-23T18:35:49Z"}, "message": "Auto merge of #84339 - alexcrichton:llvm-fptoint-sat, r=nagisa\n\nrustc: Use LLVM's new saturating float-to-int intrinsics\n\nThis commit updates rustc, with an applicable LLVM version, to use\nLLVM's new `llvm.fpto{u,s}i.sat.*.*` intrinsics to implement saturating\nfloating-point-to-int conversions. This results in a little bit tighter\ncodegen for x86/x86_64, but the main purpose of this is to prepare for\nupcoming changes to the WebAssembly backend in LLVM where wasm's\nsaturating float-to-int instructions will now be implemented with these\nintrinsics.\n\nThis change allows simplifying a good deal of surrounding code, namely\nremoving a lot of wasm-specific behavior. WebAssembly no longer has any\nspecial-casing of saturating arithmetic instructions and the need for\n`fptoint_may_trap` is gone and all handling code for that is now\nremoved. This means that the only wasm-specific logic is in the\n`fpto{s,u}i` instructions which only get used for \"out of bounds is\nundefined behavior\". This does mean that for the WebAssembly target\nspecifically the Rust compiler will no longer be 100% compatible with\npre-LLVM 12 versions, but it seems like that's unlikely to be relied on\nby too many folks.\n\nNote that this change does immediately regress the codegen of saturating\nfloat-to-int casts on WebAssembly due to the specialization of the LLVM\nintrinsic not being present in our LLVM fork just yet. I'll be following\nup with an LLVM update to pull in those patches, but affects a few other\nSIMD things in flight for WebAssembly so I wanted to separate this change.\n\nEventually the entire `cast_float_to_int` function can be removed when\nLLVM 12 is the minimum version, but that will require sinking the\ncomplexity of it into other backends such as Cranelfit.", "tree": {"sha": "fb9fa4d55497e6e4534c072f4a096879e8362069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb9fa4d55497e6e4534c072f4a096879e8362069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/481ba16439299eb07058a7107352c558fdba7f96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/481ba16439299eb07058a7107352c558fdba7f96", "html_url": "https://github.com/rust-lang/rust/commit/481ba16439299eb07058a7107352c558fdba7f96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/481ba16439299eb07058a7107352c558fdba7f96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "484c61943f818272719bac81f6d5709fc5456438", "url": "https://api.github.com/repos/rust-lang/rust/commits/484c61943f818272719bac81f6d5709fc5456438", "html_url": "https://github.com/rust-lang/rust/commit/484c61943f818272719bac81f6d5709fc5456438"}, {"sha": "ed6dd40b28223f16aaabd88e66a26d2aa5cc4a50", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6dd40b28223f16aaabd88e66a26d2aa5cc4a50", "html_url": "https://github.com/rust-lang/rust/commit/ed6dd40b28223f16aaabd88e66a26d2aa5cc4a50"}], "stats": {"total": 482, "additions": 104, "deletions": 378}, "files": [{"sha": "053cda1e7cc9cf89a09f6f414dca059433783080", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 34, "deletions": 63, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=481ba16439299eb07058a7107352c558fdba7f96", "patch": "@@ -2,6 +2,7 @@ use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::llvm::{self, BasicBlock, False};\n use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n+use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -16,7 +17,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n@@ -669,81 +670,47 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        // WebAssembly has saturating floating point to integer casts if the\n-        // `nontrapping-fptoint` target feature is activated. We'll use those if\n-        // they are available.\n-        if self.sess().target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-        {\n+        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return Some(self.call(intrinsic, &[val], None));\n-            }\n+            let name = format!(\"llvm.fptoui.sat.i{}.f{}\", int_width, float_width);\n+            let intrinsic = self.get_intrinsic(&name);\n+            return Some(self.call(intrinsic, &[val], None));\n         }\n+\n         None\n     }\n \n     fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        // WebAssembly has saturating floating point to integer casts if the\n-        // `nontrapping-fptoint` target feature is activated. We'll use those if\n-        // they are available.\n-        if self.sess().target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-        {\n+        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return Some(self.call(intrinsic, &[val], None));\n-            }\n+            let name = format!(\"llvm.fptosi.sat.i{}.f{}\", int_width, float_width);\n+            let intrinsic = self.get_intrinsic(&name);\n+            return Some(self.call(intrinsic, &[val], None));\n         }\n-        None\n-    }\n \n-    fn fptosui_may_trap(&self, val: &'ll Value, dest_ty: &'ll Type) -> bool {\n-        // Most of the time we'll be generating the `fptosi` or `fptoui`\n-        // instruction for floating-point-to-integer conversions. These\n-        // instructions by definition in LLVM do not trap. For the WebAssembly\n-        // target, however, we'll lower in some cases to intrinsic calls instead\n-        // which may trap. If we detect that this is a situation where we'll be\n-        // using the intrinsics then we report that the call map trap, which\n-        // callers might need to handle.\n-        if !self.wasm_and_missing_nontrapping_fptoint() {\n-            return false;\n-        }\n-        let src_ty = self.cx.val_ty(val);\n-        let float_width = self.cx.float_width(src_ty);\n-        let int_width = self.cx.int_width(dest_ty);\n-        matches!((int_width, float_width), (32, 32) | (32, 64) | (64, 32) | (64, 64))\n+        None\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        // When we can, use the native wasm intrinsics which have tighter\n-        // codegen. Note that this has a semantic difference in that the\n-        // intrinsic can trap whereas `fptoui` never traps. That difference,\n-        // however, is handled by `fptosui_may_trap` above.\n+        // On WebAssembly the `fptoui` and `fptosi` instructions currently have\n+        // poor codegen. The reason for this is that the corresponding wasm\n+        // instructions, `i32.trunc_f32_s` for example, will trap when the float\n+        // is out-of-bounds, infinity, or nan. This means that LLVM\n+        // automatically inserts control flow around `fptoui` and `fptosi`\n+        // because the LLVM instruction `fptoui` is defined as producing a\n+        // poison value, not having UB on out-of-bounds values.\n         //\n-        // Note that we skip the wasm intrinsics for vector types where `fptoui`\n-        // must be used instead.\n-        if self.wasm_and_missing_nontrapping_fptoint() {\n+        // This method, however, is only used with non-saturating casts that\n+        // have UB on out-of-bounds values. This means that it's ok if we use\n+        // the raw wasm instruction since out-of-bounds values can do whatever\n+        // we like. To ensure that LLVM picks the right instruction we choose\n+        // the raw wasm intrinsic functions which avoid LLVM inserting all the\n+        // other control flow automatically.\n+        if self.sess().target.arch == \"wasm32\" {\n             let src_ty = self.cx.val_ty(val);\n             if self.cx.type_kind(src_ty) != TypeKind::Vector {\n                 let float_width = self.cx.float_width(src_ty);\n@@ -765,7 +732,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        if self.wasm_and_missing_nontrapping_fptoint() {\n+        // see `fptoui` above for why wasm is different here\n+        if self.sess().target.arch == \"wasm32\" {\n             let src_ty = self.cx.val_ty(val);\n             if self.cx.type_kind(src_ty) != TypeKind::Vector {\n                 let float_width = self.cx.float_width(src_ty);\n@@ -1420,8 +1388,11 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n-        self.sess().target.arch == \"wasm32\"\n-            && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+    fn fptoint_sat_broken_in_llvm(&self) -> bool {\n+        match self.tcx.sess.target.arch.as_str() {\n+            // FIXME - https://bugs.llvm.org/show_bug.cgi?id=50083\n+            \"riscv64\" => llvm_util::get_version() < (13, 0, 0),\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "f5c54b11c08e73d93fdff88bea8812cf3b6c94f6", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=481ba16439299eb07058a7107352c558fdba7f96", "patch": "@@ -503,14 +503,6 @@ impl CodegenCx<'b, 'tcx> {\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n \n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\", fn(t_f64) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f32\", fn(t_f32) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f64\", fn(t_f64) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f32\", fn(t_f32) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f64\", fn(t_f64) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n@@ -520,6 +512,28 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.wasm.trunc.signed.i64.f32\", fn(t_f32) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.signed.i64.f64\", fn(t_f64) -> t_i64);\n \n+        ifn!(\"llvm.fptosi.sat.i8.f32\", fn(t_f32) -> t_i8);\n+        ifn!(\"llvm.fptosi.sat.i16.f32\", fn(t_f32) -> t_i16);\n+        ifn!(\"llvm.fptosi.sat.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.fptosi.sat.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.fptosi.sat.i128.f32\", fn(t_f32) -> t_i128);\n+        ifn!(\"llvm.fptosi.sat.i8.f64\", fn(t_f64) -> t_i8);\n+        ifn!(\"llvm.fptosi.sat.i16.f64\", fn(t_f64) -> t_i16);\n+        ifn!(\"llvm.fptosi.sat.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.fptosi.sat.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.fptosi.sat.i128.f64\", fn(t_f64) -> t_i128);\n+\n+        ifn!(\"llvm.fptoui.sat.i8.f32\", fn(t_f32) -> t_i8);\n+        ifn!(\"llvm.fptoui.sat.i16.f32\", fn(t_f32) -> t_i16);\n+        ifn!(\"llvm.fptoui.sat.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.fptoui.sat.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.fptoui.sat.i128.f32\", fn(t_f32) -> t_i128);\n+        ifn!(\"llvm.fptoui.sat.i8.f64\", fn(t_f64) -> t_i8);\n+        ifn!(\"llvm.fptoui.sat.i16.f64\", fn(t_f64) -> t_i16);\n+        ifn!(\"llvm.fptoui.sat.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.fptoui.sat.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.fptoui.sat.i128.f64\", fn(t_f64) -> t_i128);\n+\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);"}, {"sha": "9917c23f121501f6294debbc4f4c52fb391e2cb5", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 36, "deletions": 132, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=481ba16439299eb07058a7107352c558fdba7f96", "patch": "@@ -11,7 +11,7 @@ use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n-use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::sym;\n@@ -385,10 +385,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out, cast)\n+                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(_)) => {\n-                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out, cast)\n+                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out)\n                             }\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty),\n                         };\n@@ -790,7 +790,6 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     x: Bx::Value,\n     float_ty: Bx::Type,\n     int_ty: Bx::Type,\n-    int_layout: TyAndLayout<'tcx>,\n ) -> Bx::Value {\n     if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n         return if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n@@ -891,134 +890,39 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let int_min = bx.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n     let zero = bx.cx().const_uint(int_ty, 0);\n \n-    // The codegen here differs quite a bit depending on whether our builder's\n-    // `fptosi` and `fptoui` instructions may trap for out-of-bounds values. If\n-    // they don't trap then we can start doing everything inline with a\n-    // `select` instruction because it's ok to execute `fptosi` and `fptoui`\n-    // even if we don't use the results.\n-    if !bx.fptosui_may_trap(x, int_ty) {\n-        // Step 1 ...\n-        let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-        let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n-        let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n-\n-        // Step 2: We use two comparisons and two selects, with %s1 being the\n-        // result:\n-        //     %less_or_nan = fcmp ult %x, %f_min\n-        //     %greater = fcmp olt %x, %f_max\n-        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-        //     %s1 = select %greater, int_ty::MAX, %s0\n-        // Note that %less_or_nan uses an *unordered* comparison. This\n-        // comparison is true if the operands are not comparable (i.e., if x is\n-        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n-        // x is NaN.\n-        //\n-        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n-        // comparison and a negation, and the negation can be merged into the\n-        // select. Therefore, it not necessarily any more expensive than a\n-        // ordered (\"normal\") comparison. Whether these optimizations will be\n-        // performed is ultimately up to the backend, but at least x86 does\n-        // perform them.\n-        let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n-        let s1 = bx.select(greater, int_max, s0);\n-\n-        // Step 3: NaN replacement.\n-        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-        // Therefore we only need to execute this step for signed integer types.\n-        if signed {\n-            // LLVM has no isNaN predicate, so we use (x == x) instead\n-            let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n-            bx.select(cmp, s1, zero)\n-        } else {\n-            s1\n-        }\n+    // Step 1 ...\n+    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n+    let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n+    let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n+\n+    // Step 2: We use two comparisons and two selects, with %s1 being the\n+    // result:\n+    //     %less_or_nan = fcmp ult %x, %f_min\n+    //     %greater = fcmp olt %x, %f_max\n+    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+    //     %s1 = select %greater, int_ty::MAX, %s0\n+    // Note that %less_or_nan uses an *unordered* comparison. This\n+    // comparison is true if the operands are not comparable (i.e., if x is\n+    // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+    // x is NaN.\n+    //\n+    // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+    // comparison and a negation, and the negation can be merged into the\n+    // select. Therefore, it not necessarily any more expensive than a\n+    // ordered (\"normal\") comparison. Whether these optimizations will be\n+    // performed is ultimately up to the backend, but at least x86 does\n+    // perform them.\n+    let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n+    let s1 = bx.select(greater, int_max, s0);\n+\n+    // Step 3: NaN replacement.\n+    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n+    // Therefore we only need to execute this step for signed integer types.\n+    if signed {\n+        // LLVM has no isNaN predicate, so we use (x == x) instead\n+        let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n+        bx.select(cmp, s1, zero)\n     } else {\n-        // In this case we cannot execute `fptosi` or `fptoui` and then later\n-        // discard the result. The builder is telling us that these instructions\n-        // will trap on out-of-bounds values, so we need to use basic blocks and\n-        // control flow to avoid executing the `fptosi` and `fptoui`\n-        // instructions.\n-        //\n-        // The general idea of what we're constructing here is, for f64 -> i32:\n-        //\n-        //      ;; block so far... %0 is the argument\n-        //      %result = alloca i32, align 4\n-        //      %inbound_lower = fcmp oge double %0, 0xC1E0000000000000\n-        //      %inbound_upper = fcmp ole double %0, 0x41DFFFFFFFC00000\n-        //      ;; match (inbound_lower, inbound_upper) {\n-        //      ;;     (true, true) => %0 can be converted without trapping\n-        //      ;;     (false, false) => %0 is a NaN\n-        //      ;;     (true, false) => %0 is too large\n-        //      ;;     (false, true) => %0 is too small\n-        //      ;; }\n-        //      ;;\n-        //      ;; The (true, true) check, go to %convert if so.\n-        //      %inbounds = and i1 %inbound_lower, %inbound_upper\n-        //      br i1 %inbounds, label %convert, label %specialcase\n-        //\n-        //  convert:\n-        //      %cvt = call i32 @llvm.wasm.trunc.signed.i32.f64(double %0)\n-        //      store i32 %cvt, i32* %result, align 4\n-        //      br label %done\n-        //\n-        //  specialcase:\n-        //      ;; Handle the cases where the number is NaN, too large or too small\n-        //\n-        //      ;; Either (true, false) or (false, true)\n-        //      %is_not_nan = or i1 %inbound_lower, %inbound_upper\n-        //      ;; Figure out which saturated value we are interested in if not `NaN`\n-        //      %saturated = select i1 %inbound_lower, i32 2147483647, i32 -2147483648\n-        //      ;; Figure out between saturated and NaN representations\n-        //      %result_nan = select i1 %is_not_nan, i32 %saturated, i32 0\n-        //      store i32 %result_nan, i32* %result, align 4\n-        //      br label %done\n-        //\n-        //  done:\n-        //      %r = load i32, i32* %result, align 4\n-        //      ;; ...\n-        let done = bx.build_sibling_block(\"float_cast_done\");\n-        let mut convert = bx.build_sibling_block(\"float_cast_convert\");\n-        let mut specialcase = bx.build_sibling_block(\"float_cast_specialcase\");\n-\n-        let result = PlaceRef::alloca(bx, int_layout);\n-        result.storage_live(bx);\n-\n-        // Use control flow to figure out whether we can execute `fptosi` in a\n-        // basic block, or whether we go to a different basic block to implement\n-        // the saturating logic.\n-        let inbound_lower = bx.fcmp(RealPredicate::RealOGE, x, f_min);\n-        let inbound_upper = bx.fcmp(RealPredicate::RealOLE, x, f_max);\n-        let inbounds = bx.and(inbound_lower, inbound_upper);\n-        bx.cond_br(inbounds, convert.llbb(), specialcase.llbb());\n-\n-        // Translation of the `convert` basic block\n-        let cvt = if signed { convert.fptosi(x, int_ty) } else { convert.fptoui(x, int_ty) };\n-        convert.store(cvt, result.llval, result.align);\n-        convert.br(done.llbb());\n-\n-        // Translation of the `specialcase` basic block. Note that like above\n-        // we try to be a bit clever here for unsigned conversions. In those\n-        // cases the `int_min` is zero so we don't need two select instructions,\n-        // just one to choose whether we need `int_max` or not. If\n-        // `inbound_lower` is true then we're guaranteed to not be `NaN` and\n-        // since we're greater than zero we must be saturating to `int_max`. If\n-        // `inbound_lower` is false then we're either NaN or less than zero, so\n-        // we saturate to zero.\n-        let result_nan = if signed {\n-            let is_not_nan = specialcase.or(inbound_lower, inbound_upper);\n-            let saturated = specialcase.select(inbound_lower, int_max, int_min);\n-            specialcase.select(is_not_nan, saturated, zero)\n-        } else {\n-            specialcase.select(inbound_lower, int_max, int_min)\n-        };\n-        specialcase.store(result_nan, result.llval, result.align);\n-        specialcase.br(done.llbb());\n-\n-        // Translation of the `done` basic block, positioning ourselves to\n-        // continue from that point as well.\n-        *bx = done;\n-        let ret = bx.load(result.llval, result.align);\n-        result.storage_dead(bx);\n-        ret\n+        s1\n     }\n }"}, {"sha": "1bc05f30e5c3785abf2e6be40ba059654745b71a", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=481ba16439299eb07058a7107352c558fdba7f96", "patch": "@@ -171,7 +171,6 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n     fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n-    fn fptosui_may_trap(&self, val: Self::Value, dest_ty: Self::Type) -> bool;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;"}, {"sha": "1d1471fdeca047faf4ab968f0e8e7a7d7105955f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481ba16439299eb07058a7107352c558fdba7f96/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=481ba16439299eb07058a7107352c558fdba7f96", "patch": "@@ -796,7 +796,6 @@ symbols! {\n         non_modrs_mods,\n         none_error,\n         nontemporal_store,\n-        nontrapping_dash_fptoint: \"nontrapping-fptoint\",\n         noop_method_borrow,\n         noop_method_clone,\n         noop_method_deref,"}, {"sha": "bd6073d8c204a7eb0b099a8ae792f5478f0eb746", "filename": "src/test/codegen/wasm_casts_nontrapping.rs", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/484c61943f818272719bac81f6d5709fc5456438/src%2Ftest%2Fcodegen%2Fwasm_casts_nontrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484c61943f818272719bac81f6d5709fc5456438/src%2Ftest%2Fcodegen%2Fwasm_casts_nontrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_nontrapping.rs?ref=484c61943f818272719bac81f6d5709fc5456438", "patch": "@@ -1,162 +0,0 @@\n-// only-wasm32\n-// compile-flags: -C target-feature=+nontrapping-fptoint\n-#![crate_type = \"lib\"]\n-\n-// CHECK-LABEL: @cast_f64_i64\n-#[no_mangle]\n-pub fn cast_f64_i64(a: f64) -> i64 {\n-    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.signed.i64.f64(double {{.*}})\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f64_i32\n-#[no_mangle]\n-pub fn cast_f64_i32(a: f64) -> i32 {\n-    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.signed.i32.f64(double {{.*}})\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f32_i64\n-#[no_mangle]\n-pub fn cast_f32_i64(a: f32) -> i64 {\n-    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.signed.i64.f32(float {{.*}})\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f32_i32\n-#[no_mangle]\n-pub fn cast_f32_i32(a: f32) -> i32 {\n-    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.signed.i32.f32(float {{.*}})\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a as _\n-}\n-\n-\n-// CHECK-LABEL: @cast_f64_u64\n-#[no_mangle]\n-pub fn cast_f64_u64(a: f64) -> u64 {\n-    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.unsigned.i64.f64(double {{.*}})\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f64_u32\n-#[no_mangle]\n-pub fn cast_f64_u32(a: f64) -> u32 {\n-    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.unsigned.i32.f64(double {{.*}})\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f32_u64\n-#[no_mangle]\n-pub fn cast_f32_u64(a: f32) -> u64 {\n-    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.unsigned.i64.f32(float {{.*}})\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f32_u32\n-#[no_mangle]\n-pub fn cast_f32_u32(a: f32) -> u32 {\n-    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.unsigned.i32.f32(float {{.*}})\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a as _\n-}\n-\n-// CHECK-LABEL: @cast_f32_u8\n-#[no_mangle]\n-pub fn cast_f32_u8(a: f32) -> u8 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i8\n-    // CHECK-NEXT: select i1 {{.*}}, i8 {{.*}}, i8 {{.*}}\n-    // CHECK-NEXT: ret i8 {{.*}}\n-    a as _\n-}\n-\n-\n-\n-// CHECK-LABEL: @cast_unchecked_f64_i64\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f64_i64(a: f64) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i64\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f64_i32\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f64_i32(a: f64) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i32\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f32_i64\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f32_i64(a: f32) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i64\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f32_i32\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f32_i32(a: f32) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i32\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-\n-// CHECK-LABEL: @cast_unchecked_f64_u64\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f64_u64(a: f64) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i64\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f64_u32\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f64_u32(a: f64) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i32\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f32_u64\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f32_u64(a: f32) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i64\n-    // CHECK-NEXT: ret i64 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f32_u32\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f32_u32(a: f32) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i32\n-    // CHECK-NEXT: ret i32 {{.*}}\n-    a.to_int_unchecked()\n-}\n-\n-// CHECK-LABEL: @cast_unchecked_f32_u8\n-#[no_mangle]\n-pub unsafe fn cast_unchecked_f32_u8(a: f32) -> u8 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i8\n-    // CHECK-NEXT: ret i8 {{.*}}\n-    a.to_int_unchecked()\n-}"}, {"sha": "baf130a87917972c569e8b17edda7d95c282a58e", "filename": "src/test/codegen/wasm_casts_trapping.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/481ba16439299eb07058a7107352c558fdba7f96/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481ba16439299eb07058a7107352c558fdba7f96/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs?ref=481ba16439299eb07058a7107352c558fdba7f96", "patch": "@@ -1,13 +1,14 @@\n // only-wasm32\n // compile-flags: -C target-feature=-nontrapping-fptoint\n+// min-llvm-version: 12.0\n #![crate_type = \"lib\"]\n \n // CHECK-LABEL: @cast_f64_i64\n #[no_mangle]\n pub fn cast_f64_i64(a: f64) -> i64 {\n     // CHECK-NOT: fptosi double {{.*}} to i64\n     // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptosi.sat.i64.f64{{.*}}\n     a as _\n }\n \n@@ -16,7 +17,7 @@ pub fn cast_f64_i64(a: f64) -> i64 {\n pub fn cast_f64_i32(a: f64) -> i32 {\n     // CHECK-NOT: fptosi double {{.*}} to i32\n     // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptosi.sat.i32.f64{{.*}}\n     a as _\n }\n \n@@ -25,7 +26,7 @@ pub fn cast_f64_i32(a: f64) -> i32 {\n pub fn cast_f32_i64(a: f32) -> i64 {\n     // CHECK-NOT: fptosi float {{.*}} to i64\n     // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptosi.sat.i64.f32{{.*}}\n     a as _\n }\n \n@@ -34,7 +35,7 @@ pub fn cast_f32_i64(a: f32) -> i64 {\n pub fn cast_f32_i32(a: f32) -> i32 {\n     // CHECK-NOT: fptosi float {{.*}} to i32\n     // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptosi.sat.i32.f32{{.*}}\n     a as _\n }\n \n@@ -43,7 +44,7 @@ pub fn cast_f32_i32(a: f32) -> i32 {\n pub fn cast_f64_u64(a: f64) -> u64 {\n     // CHECK-NOT: fptoui double {{.*}} to i64\n     // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptoui.sat.i64.f64{{.*}}\n     a as _\n }\n \n@@ -52,7 +53,7 @@ pub fn cast_f64_u64(a: f64) -> u64 {\n pub fn cast_f64_u32(a: f64) -> u32 {\n     // CHECK-NOT: fptoui double {{.*}} to i32\n     // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptoui.sat.i32.f64{{.*}}\n     a as _\n }\n \n@@ -61,7 +62,7 @@ pub fn cast_f64_u32(a: f64) -> u32 {\n pub fn cast_f32_u64(a: f32) -> u64 {\n     // CHECK-NOT: fptoui float {{.*}} to i64\n     // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptoui.sat.i64.f32{{.*}}\n     a as _\n }\n \n@@ -70,16 +71,16 @@ pub fn cast_f32_u64(a: f32) -> u64 {\n pub fn cast_f32_u32(a: f32) -> u32 {\n     // CHECK-NOT: fptoui float {{.*}} to i32\n     // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n-    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptoui.sat.i32.f32{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_u8\n #[no_mangle]\n pub fn cast_f32_u8(a: f32) -> u8 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i8\n-    // CHECK-NEXT: select i1 {{.*}}, i8 {{.*}}, i8 {{.*}}\n+    // CHECK-NOT: fptoui float {{.*}} to i8\n+    // CHECK-NOT: select i1 {{.*}}, i8 {{.*}}, i8 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.fptoui.sat.i8.f32{{.*}}\n     a as _\n }\n "}]}