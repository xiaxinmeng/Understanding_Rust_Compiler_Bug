{"sha": "153efb58bc1a50d12997081a0cbb0db19c12103b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1M2VmYjU4YmMxYTUwZDEyOTk3MDgxYTBjYmIwZGIxOWMxMjEwM2I=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-30T23:28:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-30T23:28:19Z"}, "message": "Teach typeck to check obj field accesses.", "tree": {"sha": "5a6b5a643367b0acdaca1a053427b71a0218f6fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a6b5a643367b0acdaca1a053427b71a0218f6fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/153efb58bc1a50d12997081a0cbb0db19c12103b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/153efb58bc1a50d12997081a0cbb0db19c12103b", "html_url": "https://github.com/rust-lang/rust/commit/153efb58bc1a50d12997081a0cbb0db19c12103b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/153efb58bc1a50d12997081a0cbb0db19c12103b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc9db2e9722e34ecfaa73c3561e32c440a6cedd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9db2e9722e34ecfaa73c3561e32c440a6cedd2", "html_url": "https://github.com/rust-lang/rust/commit/bc9db2e9722e34ecfaa73c3561e32c440a6cedd2"}], "stats": {"total": 44, "additions": 41, "deletions": 3}, "files": [{"sha": "b5cc5e769f9ae99e761f587689188aac565c53fb", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/153efb58bc1a50d12997081a0cbb0db19c12103b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/153efb58bc1a50d12997081a0cbb0db19c12103b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=153efb58bc1a50d12997081a0cbb0db19c12103b", "patch": "@@ -33,6 +33,7 @@ import std.option.some;\n type ty_table = hashmap[ast.def_id, @ty.t];\n type crate_ctxt = rec(session.session sess,\n                       @ty_table item_types,\n+                      vec[ast.obj_field] obj_fields,\n                       mutable int next_var_id);\n \n type fn_ctxt = rec(@ty.t ret_ty,\n@@ -410,6 +411,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n         auto t = e.item_to_ty.get(id);\n         let vec[method] meth_tys = get_ctor_obj_methods(t);\n         let vec[@ast.method] methods = vec();\n+        let vec[ast.obj_field] fields = vec();\n \n         let uint n = 0u;\n         for (method meth_ty in meth_tys) {\n@@ -423,8 +425,16 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n             append[@ast.method](methods, m);\n             n += 1u;\n         }\n+        auto g = bind getter(e.id_to_ty_item, e.item_to_ty, _);\n+        for (ast.obj_field fld in ob.fields) {\n+            let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n+            let ast.obj_field f = rec(ann=ast.ann_type(fty) with fld);\n+            append[ast.obj_field](fields, f);\n+        }\n \n-        auto ob_ = rec(methods = methods with ob);\n+        auto ob_ = rec(methods = methods,\n+                       fields = fields\n+                       with ob);\n         auto item = ast.item_obj(i, ob_, ty_params, id,\n                                  ast.ann_type(t));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -915,6 +925,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n                     }\n                 }\n+                case (ast.def_obj_field(?id)) {\n+                    check (fcx.locals.contains_key(id));\n+                    t = fcx.locals.get(id);\n+                }\n                 case (ast.def_fn(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n                     t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n@@ -1456,11 +1470,18 @@ fn check_fn(&@crate_ctxt ccx, ast.effect effect,\n     // and return type translated to typeck.ty values. We don't need do to it\n     // again here, we can extract them.\n \n+\n+    for (ast.obj_field f in ccx.obj_fields) {\n+        auto field_ty = ty.ann_to_type(f.ann);\n+        local_ty_table.insert(f.id, field_ty);\n+    }\n+\n     // Store the type of each argument in the table.\n     for (ast.arg arg in inputs) {\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n         local_ty_table.insert(arg.id, input_ty);\n     }\n+\n     let @fn_ctxt fcx = @rec(ret_ty = ast_ty_to_ty_crate(ccx, output),\n                             locals = local_ty_table,\n                             ccx = ccx);\n@@ -1496,14 +1517,31 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     ret @fold.respan[ast.item_](sp, item);\n }\n \n+fn update_obj_fields(&@crate_ctxt ccx, @ast.item i) -> @crate_ctxt {\n+    alt (i.node) {\n+        case (ast.item_obj(_, ?ob, _, _, _)) {\n+            ret @rec(obj_fields = ob.fields with *ccx);\n+        }\n+        case (_) {\n+        }\n+    }\n+    ret ccx;\n+}\n+\n fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto result = collect_item_types(crate);\n \n-    auto ccx = @rec(sess=sess, item_types=result._1, mutable next_var_id=0);\n+    let vec[ast.obj_field] fields = vec();\n+\n+    auto ccx = @rec(sess=sess,\n+                    item_types=result._1,\n+                    obj_fields=fields,\n+                    mutable next_var_id=0);\n \n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n \n-    fld = @rec(fold_fn      = bind check_fn(_,_,_,_,_),\n+    fld = @rec(update_env_for_item = bind update_obj_fields(_, _),\n+               fold_fn      = bind check_fn(_,_,_,_,_),\n                fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_)\n                with *fld);\n     ret fold.fold_crate[@crate_ctxt](ccx, fld, result._0);"}]}