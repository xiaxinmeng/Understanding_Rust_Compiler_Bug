{"sha": "8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZDg0NjZlODEyZTdjNWFjYjk5YTUwNDkzZTQ1YWViMWJiODFlOTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-20T10:48:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-23T22:05:20Z"}, "message": "Refactor how we handle overflow so that it is a fatal error that aborts\ncompilation: this removes all the ungainly code that special cases\noverflow so that we can ensure it propagates.", "tree": {"sha": "75a322675f967e2c18dc75f6a520e69b5ee6c109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75a322675f967e2c18dc75f6a520e69b5ee6c109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "html_url": "https://github.com/rust-lang/rust/commit/8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809a554fca2d0ebc2ba50077016fe282a4064752", "url": "https://api.github.com/repos/rust-lang/rust/commits/809a554fca2d0ebc2ba50077016fe282a4064752", "html_url": "https://github.com/rust-lang/rust/commit/809a554fca2d0ebc2ba50077016fe282a4064752"}], "stats": {"total": 150, "additions": 61, "deletions": 89}, "files": [{"sha": "d10ff060418ccb05cdca1061c2e816224c9fbacf", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -12,6 +12,7 @@ use super::{\n     FulfillmentError,\n     FulfillmentErrorCode,\n     MismatchedProjectionTypes,\n+    Obligation,\n     ObligationCauseCode,\n     OutputTypeParameterMismatch,\n     PredicateObligation,\n@@ -21,6 +22,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n+use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n@@ -137,24 +139,36 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     report\n }\n \n+/// Reports that an overflow has occurred and halts compilation. We\n+/// halt compilation unconditionally because it is important that\n+/// overflows never be masked -- they basically represent computations\n+/// whose result could not be truly determined and thus we can't say\n+/// if the program type checks or not -- and they are unusual\n+/// occurrences in any case.\n+pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                          obligation: &Obligation<'tcx, T>)\n+                                          -> !\n+    where T: UserString<'tcx> + TypeFoldable<'tcx>\n+{\n+    let predicate =\n+        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+    span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n+              \"overflow evaluating the requirement `{}`\",\n+              predicate.user_string(infcx.tcx));\n+\n+    suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n+\n+    note_obligation_cause(infcx, obligation);\n+\n+    infcx.tcx.sess.abort_if_errors();\n+    unreachable!();\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n     match *error {\n-        SelectionError::Overflow => {\n-            // We could track the stack here more precisely if we wanted, I imagine.\n-            let predicate =\n-                infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-            span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n-                    \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(infcx.tcx));\n-\n-            suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n-\n-            note_obligation_cause(infcx, obligation);\n-        }\n-\n         SelectionError::Unimplemented => {\n             match &obligation.cause.code {\n                 &ObligationCauseCode::CompareImplMethodObligation => {\n@@ -309,19 +323,21 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   obligation: &PredicateObligation<'tcx>)\n+fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      obligation: &Obligation<'tcx, T>)\n+    where T: UserString<'tcx>\n {\n     note_obligation_cause_code(infcx,\n                                &obligation.predicate,\n                                obligation.cause.span,\n                                &obligation.cause.code);\n }\n \n-fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        predicate: &ty::Predicate<'tcx>,\n-                                        cause_span: Span,\n-                                        cause_code: &ObligationCauseCode<'tcx>)\n+fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                           predicate: &T,\n+                                           cause_span: Span,\n+                                           cause_code: &ObligationCauseCode<'tcx>)\n+    where T: UserString<'tcx>\n {\n     let tcx = infcx.tcx;\n     match *cause_code {"}, {"sha": "24b201c960f16ffe001b9914c2010b81170e4946", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -23,9 +23,10 @@ use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n+pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n@@ -151,7 +152,6 @@ pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n #[derive(Clone,Debug)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n-    Overflow,\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::type_err<'tcx>),\n@@ -327,16 +327,9 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     let result = match fulfill_cx.select_all_or_error(infcx, typer) {\n         Ok(()) => Ok(Some(())), // Success, we know it implements Copy.\n         Err(errors) => {\n-            // Check if overflow occurred anywhere and propagate that.\n-            if errors.iter().any(\n-                |err| match err.code { CodeSelectionError(Overflow) => true, _ => false })\n-            {\n-                return Err(Overflow);\n-            }\n-\n-            // Otherwise, if there were any hard errors, propagate an\n-            // arbitrary one of those. If no hard errors at all,\n-            // report ambiguity.\n+            // If there were any hard errors, propagate an arbitrary\n+            // one of those. If no hard errors at all, report\n+            // ambiguity.\n             let sel_error =\n                 errors.iter()\n                       .filter_map(|err| {\n@@ -384,16 +377,8 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             // soldering on, so just treat this like not implemented\n             false\n         }\n-        Err(Overflow) => {\n-            span_err!(infcx.tcx.sess, span, E0285,\n-                \"overflow evaluating whether `{}` is `{}`\",\n-                      ty.user_string(infcx.tcx),\n-                      bound.user_string(infcx.tcx));\n-            suggest_new_overflow_limit(infcx.tcx, span);\n-            false\n-        }\n         Err(_) => {\n-            // other errors: not implemented.\n+            // errors: not implemented.\n             false\n         }\n     }\n@@ -652,15 +637,6 @@ impl<'tcx> FulfillmentError<'tcx> {\n     {\n         FulfillmentError { obligation: obligation, code: code }\n     }\n-\n-    pub fn is_overflow(&self) -> bool {\n-        match self.code {\n-            CodeAmbiguity => false,\n-            CodeSelectionError(Overflow) => true,\n-            CodeSelectionError(_) => false,\n-            CodeProjectionError(_) => false,\n-        }\n-    }\n }\n \n impl<'tcx> TraitObligation<'tcx> {"}, {"sha": "a67410998c7276ac24849eaa3a90f585d84ec4a1", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -11,9 +11,9 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n+use super::report_overflow_error;\n use super::Obligation;\n use super::ObligationCause;\n-use super::Overflow;\n use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n@@ -442,7 +442,7 @@ fn project_type<'cx,'tcx>(\n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        return Err(ProjectionTyError::TraitSelectionError(Overflow));\n+        report_overflow_error(selcx.infcx(), &obligation);\n     }\n \n     let obligation_trait_ref ="}, {"sha": "026ef7d4d0e44b0be63231d0db930cf52ee4c1e4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -21,8 +21,9 @@ use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n+use super::{report_overflow_error};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n-use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n+use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n@@ -561,10 +562,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            debug!(\"{} --> overflow (limit={})\",\n-                   stack.obligation.repr(self.tcx()),\n-                   recursion_limit);\n-            return Err(Overflow)\n+            report_overflow_error(self.infcx(), &stack.obligation);\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -2582,11 +2580,13 @@ impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n impl<'tcx> EvaluationResult<'tcx> {\n     fn may_apply(&self) -> bool {\n         match *self {\n-            EvaluatedToOk\n-            | EvaluatedToAmbig\n-            | EvaluatedToErr(Overflow)\n-            | EvaluatedToErr(OutputTypeParameterMismatch(..)) => true,\n-            EvaluatedToErr(Unimplemented) => false,\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) =>\n+                true,\n+\n+            EvaluatedToErr(Unimplemented) =>\n+                false,\n         }\n     }\n }"}, {"sha": "965aaf12044ec20692b20ca403d9234580c25a04", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -514,9 +514,6 @@ impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            super::Overflow =>\n-                format!(\"Overflow\"),\n-\n             super::Unimplemented =>\n                 format!(\"Unimplemented\"),\n "}, {"sha": "69846d4f0e4e47f9b394c51680a46fb66c9cf1f3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -1025,8 +1025,9 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // shallow result we are looking for -- that is, what specific impl.\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.to_poly_trait_predicate());\n+    let obligation =\n+        traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+                                trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n         Ok(None) => {\n@@ -1081,7 +1082,7 @@ pub fn predicates_hold<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(), predicate);\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &()).is_ok()\n+    drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n@@ -1138,7 +1139,7 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    match drain_fulfillment_cx(span, infcx, fulfill_cx, result) {\n+    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n             infcx.tcx.sess.span_bug(\n@@ -1156,8 +1157,7 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n /// inference variables that appear in `result` to be unified, and\n /// hence we need to process those obligations to get the complete\n /// picture of the type.\n-pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n-                                       infcx: &infer::InferCtxt<'a,'tcx>,\n+pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n@@ -1173,14 +1173,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n-            // We always want to surface any overflow errors, no matter what.\n-            if errors.iter().all(|e| e.is_overflow()) {\n-                infcx.tcx.sess.span_fatal(\n-                    span,\n-                    \"reached the recursion limit during monomorphization\");\n-            } else {\n-                return Err(errors);\n-            }\n+            return Err(errors);\n         }\n     }\n "}, {"sha": "f8d85f939374dabce61c3f7eeaa4f705b2fc0b5a", "filename": "src/test/compile-fail/issue-18400.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -33,7 +33,4 @@ fn main() {\n \n     0.contains(bits);\n     //~^ ERROR overflow\n-    //~| ERROR overflow\n-    //~| ERROR overflow\n-    //~| ERROR mismatched types\n }"}, {"sha": "368269999a296c0008f457a5f7c37f12b63d9e63", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd8466e812e7c5acb99a50493e45aeb1bb81e93/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=8bd8466e812e7c5acb99a50493e45aeb1bb81e93", "patch": "@@ -42,12 +42,5 @@ fn is_send<T:Send>() { }\n fn main() {\n     is_send::<A>();\n     //~^ ERROR overflow evaluating\n-    //~^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^ NOTE required by `is_send`\n-    //~^^^^ ERROR overflow evaluating\n-    //~^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^^^^ NOTE required by `is_send`\n-    //~^^^^^^^ ERROR overflow evaluating\n-    //~^^^^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^^^^^^^ NOTE required by `is_send`\n+    //~| NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n }"}]}