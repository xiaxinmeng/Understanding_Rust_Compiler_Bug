{"sha": "09573ea8cf6441b41cac00690dba98f687185d26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NTczZWE4Y2Y2NDQxYjQxY2FjMDA2OTBkYmE5OGY2ODcxODVkMjY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-07T00:19:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-07T19:21:14Z"}, "message": "syntax: stage0-guard uses of #ast, rewrite as quote_foo! in stage1,2.", "tree": {"sha": "db05a48ecdb15fe4361114a65e57046cd819cebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db05a48ecdb15fe4361114a65e57046cd819cebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09573ea8cf6441b41cac00690dba98f687185d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09573ea8cf6441b41cac00690dba98f687185d26", "html_url": "https://github.com/rust-lang/rust/commit/09573ea8cf6441b41cac00690dba98f687185d26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09573ea8cf6441b41cac00690dba98f687185d26/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6fcfd726bb70582c5e2cf1bb47d2fcd8834e74e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fcfd726bb70582c5e2cf1bb47d2fcd8834e74e", "html_url": "https://github.com/rust-lang/rust/commit/a6fcfd726bb70582c5e2cf1bb47d2fcd8834e74e"}], "stats": {"total": 219, "additions": 122, "deletions": 97}, "files": [{"sha": "7e5a267c00843ce1b5e170b0a034974a16065be2", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09573ea8cf6441b41cac00690dba98f687185d26/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09573ea8cf6441b41cac00690dba98f687185d26/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=09573ea8cf6441b41cac00690dba98f687185d26", "patch": "@@ -17,6 +17,7 @@ use ast::{ident, node_id};\n use ast_util::{ident_to_path, respan, dummy_sp};\n use codemap::span;\n use ext::base::mk_ctxt;\n+use quote::rt::*;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -121,6 +122,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n           span: dummy_sp()}\n     }\n \n+    #[cfg(stage0)]\n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n         // If the quasiquoter could interpolate idents, this is all\n         // we'd need.\n@@ -142,6 +144,13 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n               span: dummy_sp()}]),\n                                span: dummy_sp()}, self.next_id()),\n          span: dummy_sp()}\n+     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n+        let ext_cx = self;\n+        quote_stmt!( let $ident = $e; )\n     }\n \n     fn field_imm(name: ident, e: @ast::expr) -> ast::field {"}, {"sha": "822480f0ad65e8add166a95cccdb458ec5f12cbe", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 113, "deletions": 97, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/09573ea8cf6441b41cac00690dba98f687185d26/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09573ea8cf6441b41cac00690dba98f687185d26/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=09573ea8cf6441b41cac00690dba98f687185d26", "patch": "@@ -17,12 +17,10 @@ use dvec::DVec;\n use ast::ident;\n use ast_util::dummy_sp;\n use util::interner;\n-use print::pprust;\n-use pprust::{item_to_str, ty_to_str};\n-use ext::base::{mk_ctxt, ext_ctxt};\n+use ext::base::ext_ctxt;\n use parse::*;\n use proto::*;\n-\n+use quote::rt::*;\n use ast_builder::{append_types, path};\n \n // Transitional reexports so qquote can find the paths it is looking for\n@@ -303,6 +301,8 @@ impl state: to_type_decls {\n }\n \n impl protocol: gen_init {\n+\n+    #[cfg(stage0)]\n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n \n@@ -341,6 +341,47 @@ impl protocol: gen_init {\n                            body.to_source(cx)))\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn gen_init(cx: ext_ctxt) -> @ast::item {\n+        let ext_cx = cx;\n+\n+        debug!(\"gen_init\");\n+        let start_state = self.states[0];\n+\n+        let body = if !self.is_bounded() {\n+            match start_state.dir {\n+              send => quote_expr!( pipes::entangle() ),\n+              recv => {\n+                quote_expr!({\n+                    let (s, c) = pipes::entangle();\n+                    (move c, move s)\n+                })\n+              }\n+            }\n+        }\n+        else {\n+            let body = self.gen_init_bounded(ext_cx);\n+            match start_state.dir {\n+              send => body,\n+              recv => {\n+                  quote_expr!({\n+                      let (s, c) = $body;\n+                      (move c, move s)\n+                  })\n+              }\n+            }\n+        };\n+\n+        cx.parse_item(fmt!(\"pub fn init%s() -> (client::%s, server::%s)\\\n+                            { use pipes::HasBuffer; %s }\",\n+                           start_state.ty_params.to_source(cx),\n+                           start_state.to_ty(cx).to_source(cx),\n+                           start_state.to_ty(cx).to_source(cx),\n+                           body.to_source(cx)))\n+    }\n+\n+    #[cfg(stage0)]\n     fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n         ext_cx.rec(self.states.map_to_vec(|s| {\n             let fty = s.to_ty(ext_cx);\n@@ -349,10 +390,22 @@ impl protocol: gen_init {\n         }))\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n+        ext_cx.rec(self.states.map_to_vec(|s| {\n+            let fty = s.to_ty(ext_cx);\n+            ext_cx.field_imm(ext_cx.ident_of(s.name),\n+                             quote_expr!(\n+                                 pipes::mk_packet::<$fty>()\n+                             ))\n+        }))\n+    }\n+\n+    #[cfg(stage0)]\n     fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n-\n         let buffer = #ast {\n             ~{header: pipes::BufferHeader(),\n               data: $(buffer_fields)}\n@@ -376,6 +429,34 @@ impl protocol: gen_init {\n         }}\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n+        debug!(\"gen_init_bounded\");\n+        let buffer_fields = self.gen_buffer_init(ext_cx);\n+        let buffer = quote_expr!(\n+            ~{header: pipes::BufferHeader(),\n+              data: $buffer_fields}\n+        );\n+\n+        let entangle_body = ext_cx.block_expr(\n+            ext_cx.block(\n+                self.states.map_to_vec(\n+                    |s| ext_cx.parse_stmt(\n+                        fmt!(\"data.%s.set_buffer_(buffer)\",\n+                             s.name))),\n+                ext_cx.parse_expr(\n+                    fmt!(\"ptr::addr_of(&(data.%s))\",\n+                         self.states[0].name))));\n+\n+        quote_expr!({\n+            let buffer = $buffer;\n+            do pipes::entangle_buffer(move buffer) |buffer, data| {\n+                $entangle_body\n+            }\n+        })\n+    }\n+\n     fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty {\n         let mut params: ~[ast::ty_param] = ~[];\n         for (copy self.states).each |s| {\n@@ -391,6 +472,7 @@ impl protocol: gen_init {\n                                .add_tys(cx.ty_vars(params)))\n     }\n \n+    #[cfg(stage0)]\n     fn gen_buffer_type(cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: ~[ast::ty_param] = ~[];\n@@ -405,6 +487,32 @@ impl protocol: gen_init {\n             let fty = #ast[ty] {\n                 pipes::Packet<$(ty)>\n             };\n+\n+            cx.ty_field_imm(cx.ident_of(s.name), fty)\n+        };\n+\n+        cx.item_ty_poly(\n+            cx.ident_of(~\"__Buffer\"),\n+            dummy_sp(),\n+            cx.ty_rec(fields),\n+            params)\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    fn gen_buffer_type(cx: ext_ctxt) -> @ast::item {\n+        let ext_cx = cx;\n+        let mut params: ~[ast::ty_param] = ~[];\n+        let fields = do (copy self.states).map_to_vec |s| {\n+            for s.ty_params.each |tp| {\n+                match params.find(|tpp| tp.ident == tpp.ident) {\n+                  None => params.push(*tp),\n+                  _ => ()\n+                }\n+            }\n+            let ty = s.to_ty(cx);\n+            let fty = quote_ty!( pipes::Packet<$ty> );\n+\n             cx.ty_field_imm(cx.ident_of(s.name), fty)\n         };\n \n@@ -420,7 +528,6 @@ impl protocol: gen_init {\n         let mut client_states = ~[];\n         let mut server_states = ~[];\n \n-        // :(\n         for (copy self.states).each |s| {\n             items += s.to_type_decls(cx);\n \n@@ -441,95 +548,4 @@ impl protocol: gen_init {\n \n         cx.item_mod(cx.ident_of(self.name), self.span, items)\n     }\n-}\n-\n-trait to_source {\n-    // Takes a thing and generates a string containing rust code for it.\n-    fn to_source(cx: ext_ctxt) -> ~str;\n-}\n-\n-impl @ast::item: to_source {\n-    fn to_source(cx: ext_ctxt) -> ~str {\n-        item_to_str(self, cx.parse_sess().interner)\n-    }\n-}\n-\n-impl ~[@ast::item]: to_source {\n-    fn to_source(cx: ext_ctxt) -> ~str {\n-        str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n-    }\n-}\n-\n-impl @ast::Ty: to_source {\n-    fn to_source(cx: ext_ctxt) -> ~str {\n-        ty_to_str(self, cx.parse_sess().interner)\n-    }\n-}\n-\n-impl ~[@ast::Ty]: to_source {\n-    fn to_source(cx: ext_ctxt) -> ~str {\n-        str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n-    }\n-}\n-\n-impl ~[ast::ty_param]: to_source {\n-    fn to_source(cx: ext_ctxt) -> ~str {\n-        pprust::typarams_to_str(self, cx.parse_sess().interner)\n-    }\n-}\n-\n-impl @ast::expr: to_source {\n-    fn to_source(cx: ext_ctxt) -> ~str {\n-        pprust::expr_to_str(self, cx.parse_sess().interner)\n     }\n-}\n-\n-trait ext_ctxt_parse_utils {\n-    fn parse_item(s: ~str) -> @ast::item;\n-    fn parse_expr(s: ~str) -> @ast::expr;\n-    fn parse_stmt(s: ~str) -> @ast::stmt;\n-    fn parse_tts(s: ~str) -> ~[ast::token_tree];\n-}\n-\n-impl ext_ctxt: ext_ctxt_parse_utils {\n-    fn parse_item(s: ~str) -> @ast::item {\n-        let res = parse::parse_item_from_source_str(\n-            ~\"***protocol expansion***\",\n-            @(copy s),\n-            self.cfg(),\n-            ~[],\n-            self.parse_sess());\n-        match res {\n-          Some(ast) => ast,\n-          None => {\n-            error!(\"Parse error with ```\\n%s\\n```\", s);\n-            fail\n-          }\n-        }\n-    }\n-\n-    fn parse_stmt(s: ~str) -> @ast::stmt {\n-        parse::parse_stmt_from_source_str(\n-            ~\"***protocol expansion***\",\n-            @(copy s),\n-            self.cfg(),\n-            ~[],\n-            self.parse_sess())\n-    }\n-\n-    fn parse_expr(s: ~str) -> @ast::expr {\n-        parse::parse_expr_from_source_str(\n-            ~\"***protocol expansion***\",\n-            @(copy s),\n-            self.cfg(),\n-            self.parse_sess())\n-    }\n-\n-    fn parse_tts(s: ~str) -> ~[ast::token_tree] {\n-        parse::parse_tts_from_source_str(\n-            ~\"***protocol expansion***\",\n-            @(copy s),\n-            self.cfg(),\n-            self.parse_sess())\n-    }\n-}"}]}