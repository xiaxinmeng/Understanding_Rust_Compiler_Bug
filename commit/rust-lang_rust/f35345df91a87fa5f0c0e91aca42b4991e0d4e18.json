{"sha": "f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNTM0NWRmOTFhODdmYTVmMGMwZTkxYWNhNDJiNDk5MWUwZDRlMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-05T17:11:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-05T17:11:14Z"}, "message": "Auto merge of #6887 - xFrednet:4310-internal-metadata-extraction-lint, r=xFrednet\n\nA metadata collection monster\n\nThis PR introduces a metadata collection lint as discussed in #4310. It currently collects:\n* The lint ID\n* The lint declaration file and location (for #1303)\n* The lint group\n* The documentation\n* The applicability (if resolvable)\n* If the suggestion is a multi-part-suggestion\n\nThis data has a slightly different structure than the current [lints.json](https://github.com/rust-lang/rust-clippy/blob/gh-pages/master/lints.json) and doesn't include depreciated lints yet. I plan to adapt the website to the new format and include depreciated lints in a follow-up PR :). The current collected json looks like this: [metadata_collection.json](https://gist.github.com/xFrednet/6b9e2c3f725f476ba88db9563f67e119)\n\nThe entire implementation is guarded behind the `metadata-collector-lint` feature and the `ENABLE_METADATA_COLLECTION` environment value to prevent default collection. You can test the implementation via:\n```sh\n$ ENABLE_METADATA_COLLECTION=1 cargo test --test dogfood --all-features\n```\n\nchangelog: none\n\n---\n\nThe size of this PR sadly also grew into a small monster, sorry! I definitely plan to improve on this! And it's totally okay if you take your time with this :)\n\nr? `@phansch`\ncc: `@flip1995`", "tree": {"sha": "db5fd3d1c466b9718e2b3274face78210385acae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db5fd3d1c466b9718e2b3274face78210385acae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "html_url": "https://github.com/rust-lang/rust/commit/f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0baf6bf226062b52e9f13cb36190bd332fbd4dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/0baf6bf226062b52e9f13cb36190bd332fbd4dce", "html_url": "https://github.com/rust-lang/rust/commit/0baf6bf226062b52e9f13cb36190bd332fbd4dce"}, {"sha": "e0eb29c936602553f7952a4d12c7d193bc3a7513", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eb29c936602553f7952a4d12c7d193bc3a7513", "html_url": "https://github.com/rust-lang/rust/commit/e0eb29c936602553f7952a4d12c7d193bc3a7513"}], "stats": {"total": 707, "additions": 688, "deletions": 19}, "files": [{"sha": "523bab1882836e9ddc5c0c6c81db7c0733f2bfdf", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -29,6 +29,7 @@ out\n \n # gh pages docs\n util/gh-pages/lints.json\n+**/metadata_collection.json\n \n # rustfmt backups\n *.rs.bk"}, {"sha": "23a035f9715db093a4cee9515dceffed096ad5af", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -52,6 +52,7 @@ rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n deny-warnings = []\n integration = [\"tempfile\"]\n internal-lints = [\"clippy_lints/internal-lints\"]\n+metadata-collector-lint = [\"internal-lints\", \"clippy_lints/metadata-collector-lint\"]\n \n [package.metadata.rust-analyzer]\n # This package uses #[feature(rustc_private)]"}, {"sha": "42218c2c00ac5e6eaa3165914aa97f782c70da5c", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -20,6 +20,7 @@ pulldown-cmark = { version = \"0.8\", default-features = false }\n quine-mc_cluskey = \"0.2.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = { version = \"1.0\", optional = true }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n semver = \"0.11\"\n@@ -32,6 +33,7 @@ url = { version = \"2.1.0\", features = [\"serde\"] }\n deny-warnings = []\n # build clippy with internal lints enabled, off by default\n internal-lints = [\"clippy_utils/internal-lints\"]\n+metadata-collector-lint = [\"serde_json\", \"clippy_utils/metadata-collector-lint\"]\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "1a74f641554db9143d9e0469a870479c3d860f4a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -1004,6 +1004,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n         store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n     }\n+    #[cfg(feature = \"metadata-collector-lint\")]\n+    {\n+        if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n+            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::default());\n+        }\n+    }\n+\n     store.register_late_pass(|| box utils::author::Author);\n     store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeApi);"}, {"sha": "a9ae2b77119bcaa1bda2f9d9d6bfa4264c2b2899", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath, Stmt, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -157,26 +157,16 @@ impl SlowVectorInit {\n         vec_alloc: &VecAllocation<'_>,\n     ) {\n         match initialization {\n-            InitializationType::Extend(e) | InitializationType::Resize(e) => Self::emit_lint(\n-                cx,\n-                e,\n-                vec_alloc,\n-                \"slow zero-filling initialization\",\n-                SLOW_VECTOR_INITIALIZATION,\n-            ),\n+            InitializationType::Extend(e) | InitializationType::Resize(e) => {\n+                Self::emit_lint(cx, e, vec_alloc, \"slow zero-filling initialization\")\n+            },\n         };\n     }\n \n-    fn emit_lint<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        slow_fill: &Expr<'_>,\n-        vec_alloc: &VecAllocation<'_>,\n-        msg: &str,\n-        lint: &'static Lint,\n-    ) {\n+    fn emit_lint<'tcx>(cx: &LateContext<'tcx>, slow_fill: &Expr<'_>, vec_alloc: &VecAllocation<'_>, msg: &str) {\n         let len_expr = Sugg::hir(cx, vec_alloc.len_expr, \"len\");\n \n-        span_lint_and_then(cx, lint, slow_fill.span, msg, |diag| {\n+        span_lint_and_then(cx, SLOW_VECTOR_INITIALIZATION, slow_fill.span, msg, |diag| {\n             diag.span_suggestion(\n                 vec_alloc.allocation_expr.span,\n                 \"consider replace allocation with\","}, {"sha": "ee7be24eae8013f05680ef3b7056aae0a2c973a3", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -32,6 +32,9 @@ use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n \n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub mod metadata_collector;\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for various things we like to keep tidy in clippy.\n     ///"}, {"sha": "e85637ca758884abee452581dfea267e164c905a", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "added", "additions": 632, "deletions": 0, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -0,0 +1,632 @@\n+//! This lint is used to collect metadata about clippy lints. This metadata is exported as a json\n+//! file and then used to generate the [clippy lint list](https://rust-lang.github.io/rust-clippy/master/index.html)\n+//!\n+//! This module and therefor the entire lint is guarded by a feature flag called\n+//! `metadata-collector-lint`\n+//!\n+//! The module transforms all lint names to ascii lowercase to ensure that we don't have mismatches\n+//! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n+//! a simple mistake)\n+\n+// # NITs\n+// - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n+\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{\n+    self as hir, def::DefKind, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath,\n+};\n+use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{sym, Loc, Span, Symbol};\n+use serde::{ser::SerializeStruct, Serialize, Serializer};\n+use std::collections::BinaryHeap;\n+use std::fs::{self, OpenOptions};\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+use crate::utils::internal_lints::is_lint_ref_type;\n+use clippy_utils::{\n+    diagnostics::span_lint, last_path_segment, match_function_call, match_path, paths, ty::match_type,\n+    ty::walk_ptrs_ty_depth,\n+};\n+\n+/// This is the output file of the lint collector.\n+const OUTPUT_FILE: &str = \"../util/gh-pages/metadata_collection.json\";\n+/// These lints are excluded from the export.\n+const BLACK_LISTED_LINTS: [&str; 3] = [\"lint_author\", \"deep_code_inspection\", \"internal_metadata_collector\"];\n+/// These groups will be ignored by the lint group matcher. This is useful for collections like\n+/// `clippy::all`\n+const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];\n+/// Lints within this group will be excluded from the collection\n+const EXCLUDED_LINT_GROUPS: [&str; 1] = [\"clippy::internal\"];\n+\n+const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir_and_then\"],\n+];\n+const SUGGESTION_DIAGNOSTIC_BUILDER_METHODS: [(&str, bool); 9] = [\n+    (\"span_suggestion\", false),\n+    (\"span_suggestion_short\", false),\n+    (\"span_suggestion_verbose\", false),\n+    (\"span_suggestion_hidden\", false),\n+    (\"tool_only_span_suggestion\", false),\n+    (\"multipart_suggestion\", true),\n+    (\"multipart_suggestions\", true),\n+    (\"tool_only_multipart_suggestion\", true),\n+    (\"span_suggestions\", true),\n+];\n+const SUGGESTION_FUNCTIONS: [&[&str]; 2] = [\n+    &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg_with_applicability\"],\n+];\n+\n+/// The index of the applicability name of `paths::APPLICABILITY_VALUES`\n+const APPLICABILITY_NAME_INDEX: usize = 2;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Collects metadata about clippy lints for the website.\n+    ///\n+    /// This lint will be used to report problems of syntax parsing. You should hopefully never\n+    /// see this but never say never I guess ^^\n+    ///\n+    /// **Why is this bad?** This is not a bad thing but definitely a hacky way to do it. See\n+    /// issue [#4310](https://github.com/rust-lang/rust-clippy/issues/4310) for a discussion\n+    /// about the implementation.\n+    ///\n+    /// **Known problems:** Hopefully none. It would be pretty uncool to have a problem here :)\n+    ///\n+    /// **Example output:**\n+    /// ```json,ignore\n+    /// {\n+    ///     \"id\": \"internal_metadata_collector\",\n+    ///     \"id_span\": {\n+    ///         \"path\": \"clippy_lints/src/utils/internal_lints/metadata_collector.rs\",\n+    ///         \"line\": 1\n+    ///     },\n+    ///     \"group\": \"clippy::internal\",\n+    ///     \"docs\": \" **What it does:** Collects metadata about clippy lints for the website. [...] \"\n+    /// }\n+    /// ```\n+    pub INTERNAL_METADATA_COLLECTOR,\n+    internal_warn,\n+    \"A busy bee collection metadata about lints\"\n+}\n+\n+impl_lint_pass!(MetadataCollector => [INTERNAL_METADATA_COLLECTOR]);\n+\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Debug, Clone, Default)]\n+pub struct MetadataCollector {\n+    /// All collected lints\n+    ///\n+    /// We use a Heap here to have the lints added in alphabetic order in the export\n+    lints: BinaryHeap<LintMetadata>,\n+    applicability_info: FxHashMap<String, ApplicabilityInfo>,\n+}\n+\n+impl Drop for MetadataCollector {\n+    /// You might ask: How hacky is this?\n+    /// My answer:     YES\n+    fn drop(&mut self) {\n+        // The metadata collector gets dropped twice, this makes sure that we only write\n+        // when the list is full\n+        if self.lints.is_empty() {\n+            return;\n+        }\n+\n+        let mut applicability_info = std::mem::take(&mut self.applicability_info);\n+\n+        // Mapping the final data\n+        let mut lints = std::mem::take(&mut self.lints).into_sorted_vec();\n+        lints\n+            .iter_mut()\n+            .for_each(|x| x.applicability = applicability_info.remove(&x.id));\n+\n+        // Outputting\n+        if Path::new(OUTPUT_FILE).exists() {\n+            fs::remove_file(OUTPUT_FILE).unwrap();\n+        }\n+        let mut file = OpenOptions::new().write(true).create(true).open(OUTPUT_FILE).unwrap();\n+        writeln!(file, \"{}\", serde_json::to_string_pretty(&lints).unwrap()).unwrap();\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord)]\n+struct LintMetadata {\n+    id: String,\n+    id_span: SerializableSpan,\n+    group: String,\n+    docs: String,\n+    /// This field is only used in the output and will only be\n+    /// mapped shortly before the actual output.\n+    applicability: Option<ApplicabilityInfo>,\n+}\n+\n+impl LintMetadata {\n+    fn new(id: String, id_span: SerializableSpan, group: String, docs: String) -> Self {\n+        Self {\n+            id,\n+            id_span,\n+            group,\n+            docs,\n+            applicability: None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord)]\n+struct SerializableSpan {\n+    path: String,\n+    line: usize,\n+}\n+\n+impl std::fmt::Display for SerializableSpan {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}:{}\", self.path.rsplit('/').next().unwrap_or_default(), self.line)\n+    }\n+}\n+\n+impl SerializableSpan {\n+    fn from_item(cx: &LateContext<'_>, item: &Item<'_>) -> Self {\n+        Self::from_span(cx, item.ident.span)\n+    }\n+\n+    fn from_span(cx: &LateContext<'_>, span: Span) -> Self {\n+        let loc: Loc = cx.sess().source_map().lookup_char_pos(span.lo());\n+\n+        Self {\n+            path: format!(\"{}\", loc.file.name),\n+            line: loc.line,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord)]\n+struct ApplicabilityInfo {\n+    /// Indicates if any of the lint emissions uses multiple spans. This is related to\n+    /// [rustfix#141](https://github.com/rust-lang/rustfix/issues/141) as such suggestions can\n+    /// currently not be applied automatically.\n+    is_multi_part_suggestion: bool,\n+    applicability: Option<usize>,\n+}\n+\n+impl Serialize for ApplicabilityInfo {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let index = self.applicability.unwrap_or_default();\n+\n+        let mut s = serializer.serialize_struct(\"ApplicabilityInfo\", 2)?;\n+        s.serialize_field(\"is_multi_part_suggestion\", &self.is_multi_part_suggestion)?;\n+        s.serialize_field(\n+            \"applicability\",\n+            &paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX],\n+        )?;\n+        s.end()\n+    }\n+}\n+\n+impl<'hir> LateLintPass<'hir> for MetadataCollector {\n+    /// Collecting lint declarations like:\n+    /// ```rust, ignore\n+    /// declare_clippy_lint! {\n+    ///     /// **What it does:** Something IDK.\n+    ///     pub SOME_LINT,\n+    ///     internal,\n+    ///     \"Who am I?\"\n+    /// }\n+    /// ```\n+    fn check_item(&mut self, cx: &LateContext<'hir>, item: &'hir Item<'_>) {\n+        if_chain! {\n+            // item validation\n+            if let ItemKind::Static(ref ty, Mutability::Not, _) = item.kind;\n+            if is_lint_ref_type(cx, ty);\n+            // blacklist check\n+            let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n+            if !BLACK_LISTED_LINTS.contains(&lint_name.as_str());\n+            // metadata extraction\n+            if let Some(group) = get_lint_group_or_lint(cx, &lint_name, item);\n+            if let Some(docs) = extract_attr_docs_or_lint(cx, item);\n+            then {\n+                self.lints.push(LintMetadata::new(\n+                    lint_name,\n+                    SerializableSpan::from_item(cx, item),\n+                    group,\n+                    docs,\n+                ));\n+            }\n+        }\n+    }\n+\n+    /// Collecting constant applicability from the actual lint emissions\n+    ///\n+    /// Example:\n+    /// ```rust, ignore\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     SOME_LINT,\n+    ///     item.span,\n+    ///     \"Le lint message\",\n+    ///     \"Here comes help:\",\n+    ///     \"#![allow(clippy::all)]\",\n+    ///     Applicability::MachineApplicable, // <-- Extracts this constant value\n+    /// );\n+    /// ```\n+    fn check_expr(&mut self, cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) {\n+        if let Some(args) = match_lint_emission(cx, expr) {\n+            let mut emission_info = extract_emission_info(cx, args);\n+            if emission_info.is_empty() {\n+                // See:\n+                // - src/misc.rs:734:9\n+                // - src/methods/mod.rs:3545:13\n+                // - src/methods/mod.rs:3496:13\n+                // We are basically unable to resolve the lint name it self.\n+                return;\n+            }\n+\n+            for (lint_name, applicability, is_multi_part) in emission_info.drain(..) {\n+                let app_info = self.applicability_info.entry(lint_name).or_default();\n+                app_info.applicability = applicability;\n+                app_info.is_multi_part_suggestion = is_multi_part;\n+            }\n+        }\n+    }\n+}\n+\n+// ==================================================================\n+// Lint definition extraction\n+// ==================================================================\n+fn sym_to_string(sym: Symbol) -> String {\n+    sym.as_str().to_string()\n+}\n+\n+fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n+    extract_attr_docs(cx, item).or_else(|| {\n+        lint_collection_error_item(cx, item, \"could not collect the lint documentation\");\n+        None\n+    })\n+}\n+\n+/// This function collects all documentation that has been added to an item using\n+/// `#[doc = r\"\"]` attributes. Several attributes are aggravated using line breaks\n+///\n+/// ```ignore\n+/// #[doc = r\"Hello world!\"]\n+/// #[doc = r\"=^.^=\"]\n+/// struct SomeItem {}\n+/// ```\n+///\n+/// Would result in `Hello world!\\n=^.^=\\n`\n+fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n+    cx.tcx\n+        .hir()\n+        .attrs(item.hir_id())\n+        .iter()\n+        .filter_map(|ref x| x.doc_str().map(|sym| sym.as_str().to_string()))\n+        .reduce(|mut acc, sym| {\n+            acc.push_str(&sym);\n+            acc.push('\\n');\n+            acc\n+        })\n+}\n+\n+fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Item<'_>) -> Option<String> {\n+    let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n+    if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n+        get_lint_group(cx, lint_lst[0])\n+            .or_else(|| {\n+                lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n+                None\n+            })\n+            .filter(|group| !EXCLUDED_LINT_GROUPS.contains(&group.as_str()))\n+    } else {\n+        lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n+        None\n+    }\n+}\n+\n+fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n+    for (group_name, lints, _) in &cx.lint_store.get_lint_groups() {\n+        if IGNORED_LINT_GROUPS.contains(group_name) {\n+            continue;\n+        }\n+\n+        if lints.iter().any(|x| *x == lint_id) {\n+            return Some((*group_name).to_string());\n+        }\n+    }\n+\n+    None\n+}\n+\n+// ==================================================================\n+// Lint emission\n+// ==================================================================\n+fn lint_collection_error_item(cx: &LateContext<'_>, item: &Item<'_>, message: &str) {\n+    span_lint(\n+        cx,\n+        INTERNAL_METADATA_COLLECTOR,\n+        item.ident.span,\n+        &format!(\"metadata collection error for `{}`: {}\", item.ident.name, message),\n+    );\n+}\n+\n+// ==================================================================\n+// Applicability\n+// ==================================================================\n+/// This function checks if a given expression is equal to a simple lint emission function call.\n+/// It will return the function arguments if the emission matched any function.\n+fn match_lint_emission<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) -> Option<&'hir [hir::Expr<'hir>]> {\n+    LINT_EMISSION_FUNCTIONS\n+        .iter()\n+        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n+}\n+\n+fn take_higher_applicability(a: Option<usize>, b: Option<usize>) -> Option<usize> {\n+    a.map_or(b, |a| a.max(b.unwrap_or_default()).into())\n+}\n+\n+fn extract_emission_info<'hir>(\n+    cx: &LateContext<'hir>,\n+    args: &'hir [hir::Expr<'hir>],\n+) -> Vec<(String, Option<usize>, bool)> {\n+    let mut lints = Vec::new();\n+    let mut applicability = None;\n+    let mut multi_part = false;\n+\n+    for arg in args {\n+        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n+\n+        if match_type(cx, arg_ty, &paths::LINT) {\n+            // If we found the lint arg, extract the lint name\n+            let mut resolved_lints = resolve_lints(cx, arg);\n+            lints.append(&mut resolved_lints);\n+        } else if match_type(cx, arg_ty, &paths::APPLICABILITY) {\n+            applicability = resolve_applicability(cx, arg);\n+        } else if arg_ty.is_closure() {\n+            multi_part |= check_is_multi_part(cx, arg);\n+            // TODO xFrednet 2021-03-01: don't use or_else but rather a comparison\n+            applicability = applicability.or_else(|| resolve_applicability(cx, arg));\n+        }\n+    }\n+\n+    lints\n+        .drain(..)\n+        .map(|lint_name| (lint_name, applicability, multi_part))\n+        .collect()\n+}\n+\n+/// Resolves the possible lints that this expression could reference\n+fn resolve_lints(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Vec<String> {\n+    let mut resolver = LintResolver::new(cx);\n+    resolver.visit_expr(expr);\n+    resolver.lints\n+}\n+\n+/// This function tries to resolve the linked applicability to the given expression.\n+fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<usize> {\n+    let mut resolver = ApplicabilityResolver::new(cx);\n+    resolver.visit_expr(expr);\n+    resolver.complete()\n+}\n+\n+fn check_is_multi_part(cx: &LateContext<'hir>, closure_expr: &'hir hir::Expr<'hir>) -> bool {\n+    if let ExprKind::Closure(_, _, body_id, _, _) = closure_expr.kind {\n+        let mut scanner = IsMultiSpanScanner::new(cx);\n+        intravisit::walk_body(&mut scanner, cx.tcx.hir().body(body_id));\n+        return scanner.is_multi_part();\n+    } else if let Some(local) = get_parent_local(cx, closure_expr) {\n+        if let Some(local_init) = local.init {\n+            return check_is_multi_part(cx, local_init);\n+        }\n+    }\n+\n+    false\n+}\n+\n+struct LintResolver<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    lints: Vec<String>,\n+}\n+\n+impl<'a, 'hir> LintResolver<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            lints: Vec::<String>::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for LintResolver<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        if_chain! {\n+            if let ExprKind::Path(qpath) = &expr.kind;\n+            if let QPath::Resolved(_, path) = qpath;\n+\n+            let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+            if match_type(self.cx, expr_ty, &paths::LINT);\n+            then {\n+                if let hir::def::Res::Def(DefKind::Static, _) = path.res {\n+                    let lint_name = last_path_segment(qpath).ident.name;\n+                    self.lints.push(sym_to_string(lint_name).to_ascii_lowercase());\n+                } else if let Some(local) = get_parent_local(self.cx, expr) {\n+                    if let Some(local_init) = local.init {\n+                        intravisit::walk_expr(self, local_init);\n+                    }\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// This visitor finds the highest applicability value in the visited expressions\n+struct ApplicabilityResolver<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    /// This is the index of hightest `Applicability` for `paths::APPLICABILITY_VALUES`\n+    applicability_index: Option<usize>,\n+}\n+\n+impl<'a, 'hir> ApplicabilityResolver<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            applicability_index: None,\n+        }\n+    }\n+\n+    fn add_new_index(&mut self, new_index: usize) {\n+        self.applicability_index = take_higher_applicability(self.applicability_index, Some(new_index));\n+    }\n+\n+    fn complete(self) -> Option<usize> {\n+        self.applicability_index\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_path(&mut self, path: &'hir hir::Path<'hir>, _id: hir::HirId) {\n+        for (index, enum_value) in paths::APPLICABILITY_VALUES.iter().enumerate() {\n+            if match_path(path, enum_value) {\n+                self.add_new_index(index);\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+\n+        if_chain! {\n+            if match_type(self.cx, expr_ty, &paths::APPLICABILITY);\n+            if let Some(local) = get_parent_local(self.cx, expr);\n+            if let Some(local_init) = local.init;\n+            then {\n+                intravisit::walk_expr(self, local_init);\n+            }\n+        };\n+\n+        // TODO xFrednet 2021-03-01: support function arguments?\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// This returns the parent local node if the expression is a reference one\n+fn get_parent_local(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<&'hir hir::Local<'hir>> {\n+    if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind {\n+        if let hir::def::Res::Local(local_hir) = path.res {\n+            return get_parent_local_hir_id(cx, local_hir);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn get_parent_local_hir_id(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n+    let map = cx.tcx.hir();\n+\n+    match map.find(map.get_parent_node(hir_id)) {\n+        Some(hir::Node::Local(local)) => Some(local),\n+        Some(hir::Node::Pat(pattern)) => get_parent_local_hir_id(cx, pattern.hir_id),\n+        _ => None,\n+    }\n+}\n+\n+/// This visitor finds the highest applicability value in the visited expressions\n+struct IsMultiSpanScanner<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    suggestion_count: usize,\n+}\n+\n+impl<'a, 'hir> IsMultiSpanScanner<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            suggestion_count: 0,\n+        }\n+    }\n+\n+    /// Add a new single expression suggestion to the counter\n+    fn add_single_span_suggestion(&mut self) {\n+        self.suggestion_count += 1;\n+    }\n+\n+    /// Signals that a suggestion with possible multiple spans was found\n+    fn add_multi_part_suggestion(&mut self) {\n+        self.suggestion_count += 2;\n+    }\n+\n+    /// Checks if the suggestions include multiple spanns\n+    fn is_multi_part(&self) -> bool {\n+        self.suggestion_count > 1\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        // Early return if the lint is already multi span\n+        if self.is_multi_part() {\n+            return;\n+        }\n+\n+        match &expr.kind {\n+            ExprKind::Call(fn_expr, _args) => {\n+                let found_function = SUGGESTION_FUNCTIONS\n+                    .iter()\n+                    .any(|func_path| match_function_call(self.cx, fn_expr, func_path).is_some());\n+                if found_function {\n+                    // These functions are all multi part suggestions\n+                    self.add_single_span_suggestion()\n+                }\n+            },\n+            ExprKind::MethodCall(path, _path_span, arg, _arg_span) => {\n+                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n+                if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n+                    let called_method = path.ident.name.as_str().to_string();\n+                    for (method_name, is_multi_part) in &SUGGESTION_DIAGNOSTIC_BUILDER_METHODS {\n+                        if *method_name == called_method {\n+                            if *is_multi_part {\n+                                self.add_multi_part_suggestion();\n+                            } else {\n+                                self.add_single_span_suggestion();\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "b67448e3a57406be07c7589baec3e72f17a964b2", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -1,5 +1,5 @@\n pub mod author;\n pub mod conf;\n pub mod inspector;\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub mod internal_lints;"}, {"sha": "6e158c8ce72397ec5e9801114adf80635f3e64f9", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -15,6 +15,7 @@ rustc-semver=\"1.1.0\"\n \n [features]\n internal-lints = []\n+metadata-collector-lint = []\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "a4efae54894fb10463ba54f745c594830604b047", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -1,4 +1,12 @@\n //! Clippy wrappers around rustc's diagnostic functions.\n+//!\n+//! These functions are used by the `INTERNAL_METADATA_COLLECTOR` lint to collect the corresponding\n+//! lint applicability. Please make sure that you update the `LINT_EMISSION_FUNCTIONS` variable in\n+//! `clippy_lints::utils::internal_lints::metadata_collector` when a new function is added\n+//! or renamed.\n+//!\n+//! Thank you!\n+//! ~The `INTERNAL_METADATA_COLLECTOR` lint\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::HirId;"}, {"sha": "d4bc42657f48eae059a658f64c0f1174b020d6c8", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -821,7 +821,13 @@ pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match get_parent_node(cx.tcx, e.hir_id) {\n+    get_parent_expr_for_hir(cx, e.hir_id)\n+}\n+\n+/// This retrieves the parent for the given `HirId` if it's an expression. This is useful for\n+/// constraint lints\n+pub fn get_parent_expr_for_hir<'tcx>(cx: &LateContext<'tcx>, hir_id: hir::HirId) -> Option<&'tcx Expr<'tcx>> {\n+    match get_parent_node(cx.tcx, hir_id) {\n         Some(Node::Expr(parent)) => Some(parent),\n         _ => None,\n     }"}, {"sha": "7c7bb9b02b111b0bbe988de9c162d8e8a6f03f59", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -5,6 +5,17 @@\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n+    [\"rustc_lint_defs\", \"Applicability\", \"Unspecified\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MaybeIncorrect\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MachineApplicable\"],\n+];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n@@ -72,7 +83,7 @@ pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];"}, {"sha": "6524fd4706ce13f37694cff7407c8515cfeec45c", "filename": "tests/dogfood.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35345df91a87fa5f0c0e91aca42b4991e0d4e18/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=f35345df91a87fa5f0c0e91aca42b4991e0d4e18", "patch": "@@ -1,3 +1,8 @@\n+//! This test is a part of quality control and makes clippy eat what it produces. Awesome lints and\n+//! long error messages\n+//!\n+//! See [Eating your own dog food](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) for context\n+\n // Dogfood cannot run on Windows\n #![cfg(not(windows))]\n #![feature(once_cell)]\n@@ -17,12 +22,14 @@ fn dogfood_clippy() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+    let enable_metadata_collection = std::env::var(\"ENABLE_METADATA_COLLECTION\").unwrap_or_else(|_| \"0\".to_string());\n \n     let mut command = Command::new(&*CLIPPY_PATH);\n     command\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n+        .env(\"ENABLE_METADATA_COLLECTION\", &enable_metadata_collection)\n         .arg(\"clippy\")\n         .arg(\"--all-targets\")\n         .arg(\"--all-features\")"}]}