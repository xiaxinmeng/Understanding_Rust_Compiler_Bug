{"sha": "f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZWQ1M2M5ZGFkNDY3YjViOWUzMzM5OGU5ZTMzZjAwYTY3MjRkOTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-10-02T14:03:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-10-02T14:03:40Z"}, "message": "extract expected return type from `-> impl Future` obligation", "tree": {"sha": "cf32ecf52a5b5eff49b9809e9f0a3bd833285b19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf32ecf52a5b5eff49b9809e9f0a3bd833285b19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "html_url": "https://github.com/rust-lang/rust/commit/f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e58512d4ad327cdc974b6bfbde62e2778f0cc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e58512d4ad327cdc974b6bfbde62e2778f0cc3", "html_url": "https://github.com/rust-lang/rust/commit/c8e58512d4ad327cdc974b6bfbde62e2778f0cc3"}], "stats": {"total": 161, "additions": 158, "deletions": 3}, "files": [{"sha": "e53f90ea71943222a5a5d4182a47691194b4b313", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "patch": "@@ -611,9 +611,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // function.\n                 Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn)) => {\n                     debug!(\"supplied_sig_of_closure: closure is async fn body\");\n-\n-                    // FIXME\n-                    astconv.ty_infer(None, decl.output.span())\n+                    self.deduce_future_output_from_obligations(expr_def_id)\n                 }\n \n                 _ => astconv.ty_infer(None, decl.output.span()),\n@@ -639,6 +637,104 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         result\n     }\n \n+    /// Invoked when we are translating the generator that results\n+    /// from desugaring an `async fn`. Returns the \"sugared\" return\n+    /// type of the `async fn` -- that is, the return type that the\n+    /// user specified. The \"desugared\" return type is a `impl\n+    /// Future<Output = T>`, so we do this by searching through the\n+    /// obligations to extract the `T`.\n+    fn deduce_future_output_from_obligations(\n+        &self,\n+        expr_def_id: DefId,\n+    ) -> Ty<'tcx> {\n+        debug!(\"deduce_future_output_from_obligations(expr_def_id={:?})\", expr_def_id);\n+\n+        let ret_coercion =\n+            self.ret_coercion\n+            .as_ref()\n+            .unwrap_or_else(|| span_bug!(\n+                self.tcx.def_span(expr_def_id),\n+                \"async fn generator outside of a fn\"\n+            ));\n+\n+        // In practice, the return type of the surrounding function is\n+        // always a (not yet resolved) inference variable, because it\n+        // is the hidden type for an `impl Trait` that we are going to\n+        // be inferring.\n+        let ret_ty = ret_coercion.borrow().expected_ty();\n+        let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+        let ret_vid = match ret_ty.sty {\n+            ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n+            _ => {\n+                span_bug!(\n+                    self.tcx.def_span(expr_def_id),\n+                    \"async fn generator return type not an inference variable\"\n+                )\n+            }\n+        };\n+\n+        // Search for a pending obligation like\n+        //\n+        // `<R as Future>::Output = T`\n+        //\n+        // where R is the return type we are expecting. This type `T`\n+        // will be our output.\n+        let output_ty = self.obligations_for_self_ty(ret_vid)\n+            .find_map(|(_, obligation)| {\n+                if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n+                    self.deduce_future_output_from_projection(\n+                        obligation.cause.span,\n+                        proj_predicate\n+                    )\n+                } else {\n+                    None\n+                }\n+            })\n+            .unwrap();\n+\n+        debug!(\"deduce_future_output_from_obligations: output_ty={:?}\", output_ty);\n+        output_ty\n+    }\n+\n+    /// Given a projection like\n+    ///\n+    /// `<_ as Future>::Output = T`\n+    ///\n+    /// returns `Some(T)`. If the projection is for some other trait,\n+    /// returns `None`.\n+    fn deduce_future_output_from_projection(\n+        &self,\n+        cause_span: Span,\n+        projection: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        debug!(\"deduce_future_output_from_projection(projection={:?})\", projection);\n+\n+        let trait_ref = projection.to_poly_trait_ref(self.tcx);\n+        let future_trait = self.tcx.lang_items().future_trait().unwrap();\n+        if trait_ref.def_id() != future_trait {\n+            debug!(\"deduce_future_output_from_projection: not a future\");\n+            return None;\n+        }\n+\n+        // The `Future` trait has only one associted item, `Output`,\n+        // so check that this is what we see.\n+        let output_assoc_item = self.tcx.associated_items(future_trait).nth(0).unwrap().def_id;\n+        if output_assoc_item != projection.projection_def_id() {\n+            span_bug!(\n+                cause_span,\n+                \"projecting associated item `{:?}` from future, which is not Output `{:?}`\",\n+                projection.projection_def_id(),\n+                output_assoc_item,\n+            );\n+        }\n+\n+        // Extract the type from the projection.\n+        let output_ty = projection.skip_binder().ty;\n+        let output_ty = self.resolve_vars_if_possible(&output_ty);\n+        debug!(\"deduce_future_output_from_projection: output_ty={:?}\", output_ty);\n+        Some(output_ty)\n+    }\n+\n     /// Converts the types that the user supplied, in case that doing\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`."}, {"sha": "570e745f8c74610cc575a8cfe4372da6ee721d75", "filename": "src/test/ui/async-await/return-ty-raw-ptr-coercion.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/src%2Ftest%2Fui%2Fasync-await%2Freturn-ty-raw-ptr-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/src%2Ftest%2Fui%2Fasync-await%2Freturn-ty-raw-ptr-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Freturn-ty-raw-ptr-coercion.rs?ref=f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "patch": "@@ -0,0 +1,25 @@\n+// Check that we apply unsizing coercions based on the return type.\n+//\n+// Also serves as a regression test for #60424.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![allow(warnings)]\n+\n+use std::fmt::Debug;\n+\n+const TMP: u32 = 22;\n+\n+// Coerce from `Box<\"asdf\">` to `Box<dyn Debug>`.\n+fn raw_pointer_coercion() {\n+    fn sync_example() -> *const u32 {\n+        &TMP\n+    }\n+\n+    async fn async_example() -> *const u32 {\n+        &TMP\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4d1b87677ed2469c5db04cedf75b437a71c02bf7", "filename": "src/test/ui/async-await/return-ty-unsize-coercion.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/src%2Ftest%2Fui%2Fasync-await%2Freturn-ty-unsize-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ed53c9dad467b5b9e33398e9e33f00a6724d96/src%2Ftest%2Fui%2Fasync-await%2Freturn-ty-unsize-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Freturn-ty-unsize-coercion.rs?ref=f7ed53c9dad467b5b9e33398e9e33f00a6724d96", "patch": "@@ -0,0 +1,34 @@\n+// Check that we apply unsizing coercions based on the return type.\n+//\n+// Also serves as a regression test for #60424.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![allow(warnings)]\n+\n+use std::fmt::Debug;\n+\n+// Coerce from `Box<\"asdf\">` to `Box<dyn Debug>`.\n+fn unsize_trait_coercion() {\n+    fn sync_example() -> Box<dyn Debug> {\n+        Box::new(\"asdf\")\n+    }\n+\n+    async fn async_example() -> Box<dyn Debug> {\n+        Box::new(\"asdf\")\n+    }\n+}\n+\n+// Coerce from `Box<[u32; N]>` to `Box<[32]>`.\n+fn unsize_slice_coercion() {\n+    fn sync_example() -> Box<[u32]> {\n+        Box::new([0])\n+    }\n+\n+    async fn async_example() -> Box<[u32]> {\n+        Box::new([0])\n+    }\n+}\n+\n+fn main() {}"}]}