{"sha": "5ec12b154bcc839f9a903f238791b6010a61418b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYzEyYjE1NGJjYzgzOWY5YTkwM2YyMzg3OTFiNjAxMGE2MTQxOGI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-07T06:36:10Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-07T06:36:10Z"}, "message": "cleanup", "tree": {"sha": "82ac5daf49ecd478e294c54b73c7504a4306daae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ac5daf49ecd478e294c54b73c7504a4306daae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ec12b154bcc839f9a903f238791b6010a61418b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec12b154bcc839f9a903f238791b6010a61418b", "html_url": "https://github.com/rust-lang/rust/commit/5ec12b154bcc839f9a903f238791b6010a61418b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ec12b154bcc839f9a903f238791b6010a61418b/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adcd30c5a2aa732174b0c5deba3f4b9c9a9a44d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/adcd30c5a2aa732174b0c5deba3f4b9c9a9a44d0", "html_url": "https://github.com/rust-lang/rust/commit/adcd30c5a2aa732174b0c5deba3f4b9c9a9a44d0"}], "stats": {"total": 103, "additions": 56, "deletions": 47}, "files": [{"sha": "31aba0adbf98cd83f3f58ca03d5f885b39afafd6", "filename": "subtyping.md", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5ec12b154bcc839f9a903f238791b6010a61418b/subtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ec12b154bcc839f9a903f238791b6010a61418b/subtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/subtyping.md?ref=5ec12b154bcc839f9a903f238791b6010a61418b", "patch": "@@ -2,22 +2,23 @@\n \n Although Rust doesn't have any notion of inheritance, it *does* include subtyping.\n In Rust, subtyping derives entirely from *lifetimes*. Since lifetimes are scopes,\n-we can partially order them based on a *contains* (outlives) relationship. We\n-can even express this as a generic bound: `T: 'a` specifies that whatever scope `T`\n-is valid for must contain the scope `'a` (\"T outlives `'a`\").\n+we can partially order them based on the *contains* (outlives) relationship. We\n+can even express this as a generic bound.\n \n-We can then define subtyping on lifetimes in terms of that relationship: if `'a: 'b`\n+Subtyping on lifetimes in terms of that relationship: if `'a: 'b`\n (\"a contains b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a\n large source of confusion, because it seems intuitively backwards to many:\n the bigger scope is a *sub type* of the smaller scope.\n \n-This does in fact make sense. The intuitive reason for this is that if you expect an\n-`&'a u8`, then it's totally fine for me to hand you an `&'static u8`, in the same way\n-that if you expect an Animal in Java, it's totally fine for me to hand you a Cat.\n-Cats are just Animals *and more*, just as `'static` is just `'a` *and more*.\n+This does in fact make sense, though. The intuitive reason for this is that if\n+you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static u8`,\n+in the same way that if you expect an Animal in Java, it's totally fine for me to\n+hand you a Cat. Cats are just Animals *and more*, just as `'static` is just `'a`\n+*and more*.\n \n (Note, the subtyping relationship and typed-ness of lifetimes is a fairly arbitrary\n-construct that some disagree with. I just find that it simplifies this analysis.)\n+construct that some disagree with. However it simplifies our analysis to treat\n+lifetimes and types uniformly.)\n \n Higher-ranked lifetimes are also subtypes of every concrete lifetime. This is because\n taking an arbitrary lifetime is strictly more general than taking a specific one.\n@@ -26,15 +27,15 @@ taking an arbitrary lifetime is strictly more general than taking a specific one\n \n # Variance\n \n-Variance is where things get really harsh.\n+Variance is where things get a bit complicated.\n \n Variance is a property that *type constructors* have. A type constructor in Rust\n is a generic type with unbound arguments. For instance `Vec` is a type constructor\n that takes a `T` and returns a `Vec<T>`. `&` and `&mut` are type constructors that\n-take a lifetime and a type.\n+take a two types: a lifetime, and a type to point to.\n \n-A type constructor's *variance* is how the subtypes of its inputs affects the\n-subtypes of its outputs. There are three kinds of variance:\n+A type constructor's *variance* is how the subtyping of its inputs affects the\n+subtyping of its outputs. There are two kinds of variance in Rust:\n \n * F is *variant* if `T` being a subtype of `U` implies `F<T>` is a subtype of `F<U>`\n * F is *invariant* otherwise (no subtyping relation can be derived)\n@@ -60,42 +61,47 @@ needed.\n \n To see why `&mut` should be invariant, consider the following code:\n \n-```rust\n+```rust,ignore\n+fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n+    *input = *new;\n+}\n+\n fn main() {\n     let mut forever_str: &'static str = \"hello\";\n     {\n         let string = String::from(\"world\");\n         overwrite(&mut forever_str, &mut &*string);\n     }\n+    // Oops, printing free'd memory\n     println!(\"{}\", forever_str);\n }\n-\n-fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n-    *input = *new;\n-}\n ```\n \n-The signature of `overwrite` is clearly valid: it takes mutable references to two values\n-of the same type, and overwrites one with the other. We have seen already that `&` is\n-variant, and `'static` is a subtype of *any* `'a`, so `&'static str` is a\n-subtype of `&'a str`. Therefore, if `&mut` was\n-*also* variant, then the lifetime of the `&'static str` would successfully be\n-\"shrunk\" down to the shorter lifetime of the string, and `overwrite` would be\n-called successfully. The string would subsequently be dropped, and `forever_str`\n-would point to freed memory when we print it!\n+The signature of `overwrite` is clearly valid: it takes mutable references to\n+two values of the same type, and overwrites one with the other. If `&mut` was\n+variant, then `&mut &'a str` would be a subtype of `&mut &'static str`, since\n+`&'a str` is a subtype of `&'static str`. Therefore the lifetime of\n+`forever_str` would successfully be \"shrunk\" down to the shorter lifetime of\n+`string`, and `overwrite` would be called successfully. `string` would\n+subsequently be dropped, and `forever_str` would point to freed memory when we\n+print it! Therefore `&mut` should be invariant.\n \n-Therefore `&mut` should be invariant. This is the general theme of variance vs\n+This is the general theme of variance vs\n invariance: if variance would allow you to *store* a short-lived value in a\n longer-lived slot, then you must be invariant.\n \n `Box` and `Vec` are interesting cases because they're variant, but you can\n-definitely store values in them! This is fine because *you can only store values\n-in them through a mutable reference*! The mutable reference makes the whole type\n-invariant, and therefore prevents you from getting in trouble.\n+definitely store values in them! This is where Rust gets really clever: it's\n+fine for them to be variant because you can only store values\n+in them *via a mutable reference*! The mutable reference makes the whole type\n+invariant, and therefore prevents you from smuggling a short-lived type into\n+them.\n+\n+Being variant *does* allows them to be weakened when shared immutably.\n+So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is expected.\n \n-Being variant allows them to be variant when shared immutably (so you can pass\n-a `&Box<&'static str>` where a `&Box<&'a str>` is expected). It also allows you to\n-forever weaken the type by moving it into a weaker slot. That is, you can do:\n+However what should happen when passing *by-value* is less obvious. It turns out\n+that, yes, you can use subtyping when passing by-value. That is, this works:\n \n ```rust\n fn get_box<'a>(&'a u8) -> Box<&'a str> {\n@@ -104,14 +110,16 @@ fn get_box<'a>(&'a u8) -> Box<&'a str> {\n }\n ```\n \n-which is fine because unlike the mutable borrow case, there's no one else who\n-\"remembers\" the old lifetime in the box.\n+Weakening when you pass by-value is fine because there's no one else who\n+\"remembers\" the old lifetime in the Box. The reason a variant `&mut` was\n+trouble was because there's always someone else who remembers the original\n+subtype: the actual owner.\n \n-The variance of the cell types similarly follows. `&` is like an `&mut` for a\n+The invariance of the cell types can be seen as follows: `&` is like an `&mut` for a\n cell, because you can still store values in them through an `&`. Therefore cells\n must be invariant to avoid lifetime smuggling.\n \n-`Fn` is the most subtle case, because it has mixed variance. To see why\n+`Fn` is the most subtle case because it has mixed variance. To see why\n `Fn(T) -> U` should be invariant over T, consider the following function\n signature:\n \n@@ -120,7 +128,7 @@ signature:\n fn foo(&'a str) -> usize;\n ```\n \n-This signature claims that it can handle any &str that lives *at least* as long\n+This signature claims that it can handle any `&str` that lives *at least* as long\n as `'a`. Now if this signature was variant with respect to `&str`, that would mean\n \n ```rust"}, {"sha": "0526896550287169c8973eb4148847e1cb2e4e80", "filename": "unwinding.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5ec12b154bcc839f9a903f238791b6010a61418b/unwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ec12b154bcc839f9a903f238791b6010a61418b/unwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/unwinding.md?ref=5ec12b154bcc839f9a903f238791b6010a61418b", "patch": "@@ -263,17 +263,18 @@ impl<T: Ord> BinaryHeap<T> {\n \n Although all unsafe code *must* ensure some minimal level of exception safety,\n some types may choose to explicitly *poison* themselves if they witness a panic.\n-The most notable example of this is the standard library's Mutex type. A Mutex\n-will poison itself if one of its MutexGuards (the thing it returns when a lock\n-is obtained) is dropped during a panic. Any future attempts to lock the Mutex\n-will return an `Err`.\n+Poisoning doesn't entail anything in particular. Generally it just means\n+preventing normal usage from proceeding. The most notable example of this is the\n+standard library's Mutex type. A Mutex will poison itself if one of its\n+MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n+panic. Any future attempts to lock the Mutex will return an `Err`.\n \n Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n poisons as a safety-guard against blindly using the data that comes out of a Mutex\n that has witnessed a panic while locked. The data in such a Mutex was likely in the\n middle of being modified, and as such may be in an inconsistent or incomplete state.\n It is important to note that one cannot violate memory safety with such a type\n-if it is correctly written. After all, it must be exception safe!\n+if it is correctly written. After all, it must be minimally exception safe!\n \n However if the Mutex contained, say, a BinaryHeap that does not actually have the\n heap property, it's unlikely that any code that uses it will do\n@@ -288,7 +289,7 @@ the Err exposes a method to get the lock anyway. It *is* safe, after all.\n Rust's unwinding strategy is not specified to be fundamentally compatible\n with any other language's unwinding. As such, unwinding into Rust from another\n language, or unwinding into another language from Rust is Undefined Behaviour.\n-What you do at that point is up to you, but you must *absolutely* catch any\n-panics at the FFI boundary! At best, your application will crash and burn. At\n-worst, your application *won't* crash and burn, and will proceed with completely\n-clobbered state.\n+You must *absolutely* catch any panics at the FFI boundary! What you do at that\n+point is up to you, but *something* must be done. If you fail to do this,\n+at best, your application will crash and burn. At worst, your application *won't*\n+crash and burn, and will proceed with completely clobbered state."}]}