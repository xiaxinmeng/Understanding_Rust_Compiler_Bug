{"sha": "4a365a29d64bec75d107214319a129ba68fc12a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMzY1YTI5ZDY0YmVjNzVkMTA3MjE0MzE5YTEyOWJhNjhmYzEyYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-22T15:12:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-22T15:12:15Z"}, "message": "Auto merge of #61020 - HeroicKatora:master, r=matthewjasper\n\nlibrustc_data_structures: Speedup union of sparse and dense hybrid set\n\nThis optimization speeds up the union of a hybrid bitset when that\nswitches it from a sparse representation to a dense bitset. It now\nclones the dense bitset and integrate only the spare elements instead of\ndensifying the sparse bitset, initializing all elements, and then a\nunion on two dense bitset, touching all words a second time.\n\nIt's not completely certain if the added complexity is worth it but I would\nlike to hear some feedback in any case. Benchmark results from my machine:\n\n```\nNow:  bit_set::union_hybrid_sparse_to_dense ... bench:          72 ns/iter (+/- 5)\nPrevious: bit_set::union_hybrid_sparse_to_dense ... bench:          90 ns/iter (+/- 6)\n```\n\nThis being the second iteration of trying to improve the speed, since I missed the return value in the first, and forgot to run the relevant tests. Oops.", "tree": {"sha": "53411659f0e073468d798001b442873717ebf65b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53411659f0e073468d798001b442873717ebf65b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a365a29d64bec75d107214319a129ba68fc12a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a365a29d64bec75d107214319a129ba68fc12a3", "html_url": "https://github.com/rust-lang/rust/commit/4a365a29d64bec75d107214319a129ba68fc12a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a365a29d64bec75d107214319a129ba68fc12a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d5d67c1c20b9599c812ab4d926ab4fa9fe6935", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d5d67c1c20b9599c812ab4d926ab4fa9fe6935", "html_url": "https://github.com/rust-lang/rust/commit/d4d5d67c1c20b9599c812ab4d926ab4fa9fe6935"}, {"sha": "3f28811774da8ee16bd6391a0e66d23e6962485f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f28811774da8ee16bd6391a0e66d23e6962485f", "html_url": "https://github.com/rust-lang/rust/commit/3f28811774da8ee16bd6391a0e66d23e6962485f"}], "stats": {"total": 147, "additions": 143, "deletions": 4}, "files": [{"sha": "3430d83f23f5e221c986449f1bb9698ddf855225", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 143, "deletions": 4, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/4a365a29d64bec75d107214319a129ba68fc12a3/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a365a29d64bec75d107214319a129ba68fc12a3/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=4a365a29d64bec75d107214319a129ba68fc12a3", "patch": "@@ -5,6 +5,10 @@ use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::slice;\n+#[cfg(test)]\n+extern crate test;\n+#[cfg(test)]\n+use test::Bencher;\n \n pub type Word = u64;\n pub const WORD_BYTES: usize = mem::size_of::<Word>();\n@@ -177,6 +181,45 @@ impl<T: Idx> BitSet<T> {\n         // Note: we currently don't bother trying to make a Sparse set.\n         HybridBitSet::Dense(self.to_owned())\n     }\n+\n+    /// Set `self = self | other`. In contrast to `union` returns `true` if the set contains at\n+    /// least one bit that is not in `other` (i.e. `other` is not a superset of `self`).\n+    ///\n+    /// This is an optimization for union of a hybrid bitset.\n+    fn reverse_union_sparse(&mut self, sparse: &SparseBitSet<T>) -> bool {\n+        assert!(sparse.domain_size == self.domain_size);\n+        self.clear_excess_bits();\n+\n+        let mut not_already = false;\n+        // Index of the current word not yet merged.\n+        let mut current_index = 0;\n+        // Mask of bits that came from the sparse set in the current word.\n+        let mut new_bit_mask = 0;\n+        for (word_index, mask) in sparse.iter().map(|x| word_index_and_mask(*x)) {\n+            // Next bit is in a word not inspected yet.\n+            if word_index > current_index {\n+                self.words[current_index] |= new_bit_mask;\n+                // Were there any bits in the old word that did not occur in the sparse set?\n+                not_already |= (self.words[current_index] ^ new_bit_mask) != 0;\n+                // Check all words we skipped for any set bit.\n+                not_already |= self.words[current_index+1..word_index].iter().any(|&x| x != 0);\n+                // Update next word.\n+                current_index = word_index;\n+                // Reset bit mask, no bits have been merged yet.\n+                new_bit_mask = 0;\n+            }\n+            // Add bit and mark it as coming from the sparse set.\n+            // self.words[word_index] |= mask;\n+            new_bit_mask |= mask;\n+        }\n+        self.words[current_index] |= new_bit_mask;\n+        // Any bits in the last inspected word that were not in the sparse set?\n+        not_already |= (self.words[current_index] ^ new_bit_mask) != 0;\n+        // Any bits in the tail? Note `clear_excess_bits` before.\n+        not_already |= self.words[current_index+1..].iter().any(|&x| x != 0);\n+\n+        not_already\n+    }\n }\n \n /// This is implemented by all the bitsets so that BitSet::union() can be\n@@ -514,10 +557,22 @@ impl<T: Idx> HybridBitSet<T> {\n                         changed\n                     }\n                     HybridBitSet::Dense(other_dense) => {\n-                        // `self` is sparse and `other` is dense. Densify\n-                        // `self` and then do the bitwise union.\n-                        let mut new_dense = self_sparse.to_dense();\n-                        let changed = new_dense.union(other_dense);\n+                        // `self` is sparse and `other` is dense. To\n+                        // merge them, we have two available strategies:\n+                        // * Densify `self` then merge other\n+                        // * Clone other then integrate bits from `self`\n+                        // The second strategy requires dedicated method\n+                        // since the usual `union` returns the wrong\n+                        // result. In the dedicated case the computation\n+                        // is slightly faster if the bits of the sparse\n+                        // bitset map to only few words of the dense\n+                        // representation, i.e. indices are near each\n+                        // other.\n+                        //\n+                        // Benchmarking seems to suggest that the second\n+                        // option is worth it.\n+                        let mut new_dense = other_dense.clone();\n+                        let changed = new_dense.reverse_union_sparse(self_sparse);\n                         *self = HybridBitSet::Dense(new_dense);\n                         changed\n                     }\n@@ -1214,3 +1269,87 @@ fn sparse_matrix_iter() {\n     }\n     assert!(iter.next().is_none());\n }\n+\n+/// Merge dense hybrid set into empty sparse hybrid set.\n+#[bench]\n+fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set with same indices.\n+#[bench]\n+fn union_hybrid_sparse_full_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set with indices over the whole domain.\n+#[bench]\n+fn union_hybrid_sparse_domain_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i*64));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into empty hybrid set where the domain is very small.\n+#[bench]\n+fn union_hybrid_sparse_empty_small_domain(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set where the domain is very small.\n+#[bench]\n+fn union_hybrid_sparse_full_small_domain(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}"}]}