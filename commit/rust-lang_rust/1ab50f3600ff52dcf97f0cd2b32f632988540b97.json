{"sha": "1ab50f3600ff52dcf97f0cd2b32f632988540b97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYjUwZjM2MDBmZjUyZGNmOTdmMGNkMmIzMmY2MzI5ODg1NDBiOTc=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-10-29T14:47:53Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-10-29T22:35:53Z"}, "message": "Remove Token::get_close_delimiter\n\nWe can simplify these usages due to the new delimiter representation. `Parser::expect_open_delim` has been added for convenience.", "tree": {"sha": "55e36ee17ee55cbaea1220c2ac4d170090d86db7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e36ee17ee55cbaea1220c2ac4d170090d86db7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ab50f3600ff52dcf97f0cd2b32f632988540b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab50f3600ff52dcf97f0cd2b32f632988540b97", "html_url": "https://github.com/rust-lang/rust/commit/1ab50f3600ff52dcf97f0cd2b32f632988540b97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ab50f3600ff52dcf97f0cd2b32f632988540b97/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "936d999b5270d186df28123a5dbd6d2bb848bb2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/936d999b5270d186df28123a5dbd6d2bb848bb2c", "html_url": "https://github.com/rust-lang/rust/commit/936d999b5270d186df28123a5dbd6d2bb848bb2c"}], "stats": {"total": 91, "additions": 33, "deletions": 58}, "files": [{"sha": "8bd984b60ed8f06a7544845a72f640e9701005ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1ab50f3600ff52dcf97f0cd2b32f632988540b97/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab50f3600ff52dcf97f0cd2b32f632988540b97/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1ab50f3600ff52dcf97f0cd2b32f632988540b97", "patch": "@@ -2013,6 +2013,16 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn expect_open_delim(&mut self) -> token::DelimToken {\n+        match self.token {\n+            token::OpenDelim(delim) => {\n+                self.bump();\n+                delim\n+            },\n+            _ => self.fatal(\"expected open delimiter\"),\n+        }\n+    }\n+\n     /// At the bottom (top?) of the precedence hierarchy,\n     /// parse things like parenthesized exprs,\n     /// macros, return, etc.\n@@ -2209,14 +2219,9 @@ impl<'a> Parser<'a> {\n                         // MACRO INVOCATION expression\n                         self.bump();\n \n-                        let ket = self.token.get_close_delimiter()\n-                            .unwrap_or_else(|| {\n-                                self.fatal(\"expected open delimiter\")\n-                            });\n-                        self.bump();\n-\n+                        let delim = self.expect_open_delim();\n                         let tts = self.parse_seq_to_end(\n-                            &ket,\n+                            &token::CloseDelim(delim),\n                             seq_sep_none(),\n                             |p| p.parse_token_tree());\n                         let hi = self.span.hi;\n@@ -2624,13 +2629,8 @@ impl<'a> Parser<'a> {\n         // the interpolation of Matcher's\n         maybe_whole!(self, NtMatchers);\n         let mut name_idx = 0u;\n-        match self.token.get_close_delimiter() {\n-            Some(other_delimiter) => {\n-                self.bump();\n-                self.parse_matcher_subseq_upto(&mut name_idx, &other_delimiter)\n-            }\n-            None => self.fatal(\"expected open delimiter\")\n-        }\n+        let delim = self.expect_open_delim();\n+        self.parse_matcher_subseq_upto(&mut name_idx, &token::CloseDelim(delim))\n     }\n \n     /// This goofy function is necessary to correctly match parens in Matcher's.\n@@ -3325,11 +3325,8 @@ impl<'a> Parser<'a> {\n                 let pth1 = codemap::Spanned{span:id_span, node: id};\n                 if self.eat(&token::Not) {\n                     // macro invocation\n-                    let ket = self.token.get_close_delimiter()\n-                                    .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n-                    self.bump();\n-\n-                    let tts = self.parse_seq_to_end(&ket,\n+                    let delim = self.expect_open_delim();\n+                    let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                     seq_sep_none(),\n                                                     |p| p.parse_token_tree());\n \n@@ -3545,18 +3542,17 @@ impl<'a> Parser<'a> {\n             let pth = self.parse_path(NoTypesAllowed).path;\n             self.bump();\n \n-            let id = if self.token.get_close_delimiter().is_some() {\n-                token::special_idents::invalid // no special identifier\n-            } else {\n-                self.parse_ident()\n+            let id = match self.token {\n+                token::OpenDelim(_) => token::special_idents::invalid, // no special identifier\n+                _ => self.parse_ident(),\n             };\n \n             // check that we're pointing at delimiters (need to check\n             // again after the `if`, because of `parse_ident`\n             // consuming more tokens).\n-            let (bra, ket) = match self.token.get_close_delimiter() {\n-                Some(ket) => (self.token.clone(), ket),\n-                None      => {\n+            let delim = match self.token {\n+                token::OpenDelim(delim) => delim,\n+                _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n                     let ident_str = if id.name == token::special_idents::invalid.name {\n@@ -3568,12 +3564,12 @@ impl<'a> Parser<'a> {\n                     self.fatal(format!(\"expected {}`(` or `{{`, found `{}`\",\n                                        ident_str,\n                                        tok_str).as_slice())\n-                }\n+                },\n             };\n \n             let tts = self.parse_unspanned_seq(\n-                &bra,\n-                &ket,\n+                &token::OpenDelim(delim),\n+                &token::CloseDelim(delim),\n                 seq_sep_none(),\n                 |p| p.parse_token_tree()\n             );\n@@ -4414,15 +4410,10 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Not);\n \n                 // eat a matched-delimiter token tree:\n-                let tts = match self.token.get_close_delimiter() {\n-                    Some(ket) => {\n-                        self.bump();\n-                        self.parse_seq_to_end(&ket,\n-                                              seq_sep_none(),\n-                                              |p| p.parse_token_tree())\n-                    }\n-                    None => self.fatal(\"expected open delimiter\")\n-                };\n+                let delim = self.expect_open_delim();\n+                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                seq_sep_none(),\n+                                                |p| p.parse_token_tree());\n                 let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n                 let m: ast::Mac = codemap::Spanned { node: m_,\n                                                  span: mk_sp(self.span.lo,\n@@ -5505,15 +5496,10 @@ impl<'a> Parser<'a> {\n                 token::special_idents::invalid // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n-            let tts = match self.token.get_close_delimiter() {\n-                Some(ket) => {\n-                    self.bump();\n-                    self.parse_seq_to_end(&ket,\n-                                          seq_sep_none(),\n-                                          |p| p.parse_token_tree())\n-                }\n-                None => self.fatal(\"expected open delimiter\")\n-            };\n+            let delim = self.expect_open_delim();\n+            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                            seq_sep_none(),\n+                                            |p| p.parse_token_tree());\n             // single-variant-enum... :\n             let m = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n             let m: ast::Mac = codemap::Spanned { node: m,"}, {"sha": "2025b65835eeca9df7f61bcf2baa82dd6a986ae7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ab50f3600ff52dcf97f0cd2b32f632988540b97/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab50f3600ff52dcf97f0cd2b32f632988540b97/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1ab50f3600ff52dcf97f0cd2b32f632988540b97", "patch": "@@ -230,17 +230,6 @@ impl Token {\n         }\n     }\n \n-    /// Returns the matching close delimiter if this is an open delimiter,\n-    /// otherwise `None`.\n-    pub fn get_close_delimiter(&self) -> Option<Token> {\n-        match *self {\n-            OpenDelim(Paren)   => Some(CloseDelim(Paren)),\n-            OpenDelim(Brace)   => Some(CloseDelim(Brace)),\n-            OpenDelim(Bracket) => Some(CloseDelim(Bracket)),\n-            _                  => None,\n-        }\n-    }\n-\n     /// Returns `true` if the token is any literal\n     pub fn is_lit(&self) -> bool {\n         match *self {"}]}