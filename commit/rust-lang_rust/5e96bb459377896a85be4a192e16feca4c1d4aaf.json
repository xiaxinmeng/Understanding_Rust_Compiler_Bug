{"sha": "5e96bb459377896a85be4a192e16feca4c1d4aaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOTZiYjQ1OTM3Nzg5NmE4NWJlNGExOTJlMTZmZWNhNGMxZDRhYWY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-28T14:15:40Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-28T14:15:40Z"}, "message": "Replace all uses of `log::log_enabled` with `Debug` printers", "tree": {"sha": "db7e329af18ef908ea27ced9267f9cdae7cdb814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db7e329af18ef908ea27ced9267f9cdae7cdb814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e96bb459377896a85be4a192e16feca4c1d4aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e96bb459377896a85be4a192e16feca4c1d4aaf", "html_url": "https://github.com/rust-lang/rust/commit/5e96bb459377896a85be4a192e16feca4c1d4aaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e96bb459377896a85be4a192e16feca4c1d4aaf/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f5d69daccd1f04e42886d9aaf513f2691132d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5d69daccd1f04e42886d9aaf513f2691132d17", "html_url": "https://github.com/rust-lang/rust/commit/1f5d69daccd1f04e42886d9aaf513f2691132d17"}], "stats": {"total": 380, "additions": 219, "deletions": 161}, "files": [{"sha": "125a020de37b7bcc845a222faa66a72a87ed877e", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -2,7 +2,7 @@ use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n \n-use log::{info, log_enabled, warn};\n+use log::{info, warn};\n use once_cell::sync::Lazy;\n use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self, ast, visit};\n@@ -1015,21 +1015,15 @@ pub fn start_codegen<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     outputs: &OutputFilenames,\n ) -> Box<dyn Any> {\n-    if log_enabled!(::log::Level::Info) {\n-        println!(\"Pre-codegen\");\n-        tcx.print_debug_stats();\n-    }\n+    info!(\"Pre-codegen\\n{:?}\", tcx.debug_stats());\n \n     let (metadata, need_metadata_module) = encode_and_write_metadata(tcx, outputs);\n \n     let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n \n-    if log_enabled!(::log::Level::Info) {\n-        println!(\"Post-codegen\");\n-        tcx.print_debug_stats();\n-    }\n+    info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n         if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, outputs) {"}, {"sha": "bb1370fabefe1fe61e3978e7103e00201455e29a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -26,7 +26,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n-use log::{debug, info, log_enabled};\n+use log::{debug, info};\n use proc_macro::bridge::client::ProcMacro;\n use std::path::Path;\n use std::{cmp, env, fs};\n@@ -82,24 +82,38 @@ impl std::ops::Deref for CrateMetadataRef<'_> {\n     }\n }\n \n-fn dump_crates(cstore: &CStore) {\n-    info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|cnum, data| {\n-        info!(\"  name: {}\", data.name());\n-        info!(\"  cnum: {}\", cnum);\n-        info!(\"  hash: {}\", data.hash());\n-        info!(\"  reqd: {:?}\", data.dep_kind());\n-        let CrateSource { dylib, rlib, rmeta } = data.source();\n-        if let Some(dylib) = dylib {\n-            info!(\"  dylib: {}\", dylib.0.display());\n-        }\n-        if let Some(rlib) = rlib {\n-            info!(\"   rlib: {}\", rlib.0.display());\n-        }\n-        if let Some(rmeta) = rmeta {\n-            info!(\"   rmeta: {}\", rmeta.0.display());\n-        }\n-    });\n+struct CrateDump<'a>(&'a CStore);\n+\n+fn crate_dump(cstore: &'a CStore) -> impl std::fmt::Debug + 'a {\n+    CrateDump(cstore)\n+}\n+\n+impl<'a> std::fmt::Debug for CrateDump<'a> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        writeln!(fmt, \"resolved crates:\")?;\n+        let mut res = Ok(());\n+        self.0.iter_crate_data(|cnum, data| {\n+            res = res.and(\n+                try {\n+                    writeln!(fmt, \"  name: {}\", data.name())?;\n+                    writeln!(fmt, \"  cnum: {}\", cnum)?;\n+                    writeln!(fmt, \"  hash: {}\", data.hash())?;\n+                    writeln!(fmt, \"  reqd: {:?}\", data.dep_kind())?;\n+                    let CrateSource { dylib, rlib, rmeta } = data.source();\n+                    if let Some(dylib) = dylib {\n+                        writeln!(fmt, \"  dylib: {}\", dylib.0.display())?;\n+                    }\n+                    if let Some(rlib) = rlib {\n+                        writeln!(fmt, \"   rlib: {}\", rlib.0.display())?;\n+                    }\n+                    if let Some(rmeta) = rmeta {\n+                        writeln!(fmt, \"   rmeta: {}\", rmeta.0.display())?;\n+                    }\n+                },\n+            );\n+        });\n+        res\n+    }\n }\n \n impl CStore {\n@@ -864,9 +878,7 @@ impl<'a> CrateLoader<'a> {\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n \n-        if log_enabled!(log::Level::Info) {\n-            dump_crates(&self.cstore);\n-        }\n+        info!(\"{:?}\", crate_dump(&self.cstore));\n \n         self.report_unused_deps(krate);\n     }"}, {"sha": "059ae340bcfe968821f5f36d99a46165a365a837", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -9,6 +9,7 @@\n #![feature(proc_macro_internals)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n+#![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "7b7db9453245e1b59a2fc2d72cee9b52e80331aa", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -1831,7 +1831,7 @@ pub mod tls {\n }\n \n macro_rules! sty_debug_print {\n-    ($ctxt: expr, $($variant: ident),*) => {{\n+    ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as\n         // variable names.\n         #[allow(non_snake_case)]\n@@ -1848,7 +1848,7 @@ macro_rules! sty_debug_print {\n                 all_infer: usize,\n             }\n \n-            pub fn go(tcx: TyCtxt<'_>) {\n+            pub fn go(fmt: &mut std::fmt::Formatter<'_>, tcx: TyCtxt<'_>) -> std::fmt::Result {\n                 let mut total = DebugStat {\n                     total: 0,\n                     lt_infer: 0,\n@@ -1878,18 +1878,18 @@ macro_rules! sty_debug_print {\n                     if ct { total.ct_infer += 1; variant.ct_infer += 1 }\n                     if lt && ty && ct { total.all_infer += 1; variant.all_infer += 1 }\n                 }\n-                println!(\"Ty interner             total           ty lt ct all\");\n-                $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n+                writeln!(fmt, \"Ty interner             total           ty lt ct all\")?;\n+                $(writeln!(fmt, \"    {:18}: {uses:6} {usespc:4.1}%, \\\n                             {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n                     stringify!($variant),\n                     uses = $variant.total,\n                     usespc = $variant.total as f64 * 100.0 / total.total as f64,\n                     ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n                     lt = $variant.lt_infer as f64 * 100.0  / total.total as f64,\n                     ct = $variant.ct_infer as f64 * 100.0  / total.total as f64,\n-                    all = $variant.all_infer as f64 * 100.0  / total.total as f64);\n+                    all = $variant.all_infer as f64 * 100.0  / total.total as f64)?;\n                 )*\n-                println!(\"                  total {uses:6}        \\\n+                writeln!(fmt, \"                  total {uses:6}        \\\n                           {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n                     uses = total.total,\n                     ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n@@ -1899,14 +1899,23 @@ macro_rules! sty_debug_print {\n             }\n         }\n \n-        inner::go($ctxt)\n+        inner::go($fmt, $ctxt)\n     }}\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn print_debug_stats(self) {\n+    pub fn debug_stats(self) -> impl std::fmt::Debug + 'tcx {\n+        DebugStats(self)\n+    }\n+}\n+\n+struct DebugStats<'tcx>(TyCtxt<'tcx>);\n+\n+impl std::fmt::Debug for DebugStats<'tcx> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         sty_debug_print!(\n-            self,\n+            fmt,\n+            self.0,\n             Adt,\n             Array,\n             Slice,\n@@ -1926,14 +1935,16 @@ impl<'tcx> TyCtxt<'tcx> {\n             Projection,\n             Opaque,\n             Foreign\n-        );\n-\n-        println!(\"InternalSubsts interner: #{}\", self.interners.substs.len());\n-        println!(\"Region interner: #{}\", self.interners.region.len());\n-        println!(\"Stability interner: #{}\", self.stability_interner.len());\n-        println!(\"Const Stability interner: #{}\", self.const_stability_interner.len());\n-        println!(\"Allocation interner: #{}\", self.allocation_interner.len());\n-        println!(\"Layout interner: #{}\", self.layout_interner.len());\n+        )?;\n+\n+        writeln!(fmt, \"InternalSubsts interner: #{}\", self.0.interners.substs.len())?;\n+        writeln!(fmt, \"Region interner: #{}\", self.0.interners.region.len())?;\n+        writeln!(fmt, \"Stability interner: #{}\", self.0.stability_interner.len())?;\n+        writeln!(fmt, \"Const Stability interner: #{}\", self.0.const_stability_interner.len())?;\n+        writeln!(fmt, \"Allocation interner: #{}\", self.0.allocation_interner.len())?;\n+        writeln!(fmt, \"Layout interner: #{}\", self.0.layout_interner.len())?;\n+\n+        Ok(())\n     }\n }\n "}, {"sha": "0dac8b64910114fb58ddebb45323fc301061eda4", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         self.copy_op(place.into(), dest)?;\n \n         self.return_to_block(ret.map(|r| r.1))?;\n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n         Ok(true)\n     }\n "}, {"sha": "630b2890835da86feab408c66fd5f9dc2ea3d339", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -1,5 +1,4 @@\n use std::cell::Cell;\n-use std::fmt::Write;\n use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -728,7 +727,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(return_place) = frame.return_place {\n                 let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n                 self.copy_op_transmute(op, return_place)?;\n-                self.dump_place(*return_place);\n+                trace!(\"{:?}\", self.dump_place(*return_place));\n             } else {\n                 throw_ub!(Unreachable);\n             }\n@@ -823,9 +822,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // All locals have a backing allocation, even if the allocation is empty\n             // due to the local having ZST type.\n             let ptr = ptr.assert_ptr();\n-            if log_enabled!(::log::Level::Trace) {\n-                self.memory.dump_alloc(ptr.alloc_id);\n-            }\n+            trace!(\"{:?}\", self.memory.dump_alloc(ptr.alloc_id));\n             self.memory.deallocate_local(ptr)?;\n         };\n         Ok(())\n@@ -881,47 +878,77 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.raw_const_to_mplace(val)\n     }\n \n-    pub fn dump_place(&self, place: Place<M::PointerTag>) {\n-        // Debug output\n-        if !log_enabled!(::log::Level::Trace) {\n-            return;\n+    #[must_use]\n+    pub fn dump_place(&'a self, place: Place<M::PointerTag>) -> PlacePrinter<'a, 'mir, 'tcx, M> {\n+        PlacePrinter { ecx: self, place }\n+    }\n+\n+    #[must_use]\n+    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n+        let mut frames = Vec::new();\n+        for frame in self.stack().iter().rev() {\n+            let source_info = frame.current_source_info();\n+            let lint_root = source_info.and_then(|source_info| {\n+                match &frame.body.source_scopes[source_info.scope].local_data {\n+                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n+                    mir::ClearCrossCrate::Clear => None,\n+                }\n+            });\n+            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n+\n+            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n         }\n-        match place {\n+        trace!(\"generate stacktrace: {:#?}\", frames);\n+        frames\n+    }\n+}\n+\n+#[doc(hidden)]\n+/// Helper struct for the `dump_place` function.\n+pub struct PlacePrinter<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+    ecx: &'a InterpCx<'mir, 'tcx, M>,\n+    place: Place<M::PointerTag>,\n+}\n+\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n+    for PlacePrinter<'a, 'mir, 'tcx, M>\n+{\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self.place {\n             Place::Local { frame, local } => {\n                 let mut allocs = Vec::new();\n-                let mut msg = format!(\"{:?}\", local);\n-                if frame != self.frame_idx() {\n-                    write!(msg, \" ({} frames up)\", self.frame_idx() - frame).unwrap();\n+                write!(fmt, \"{:?}\", local)?;\n+                if frame != self.ecx.frame_idx() {\n+                    write!(fmt, \" ({} frames up)\", self.ecx.frame_idx() - frame)?;\n                 }\n-                write!(msg, \":\").unwrap();\n+                write!(fmt, \":\")?;\n \n-                match self.stack()[frame].locals[local].value {\n-                    LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n-                    LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n+                match self.ecx.stack()[frame].locals[local].value {\n+                    LocalValue::Dead => write!(fmt, \" is dead\")?,\n+                    LocalValue::Uninitialized => write!(fmt, \" is uninitialized\")?,\n                     LocalValue::Live(Operand::Indirect(mplace)) => match mplace.ptr {\n                         Scalar::Ptr(ptr) => {\n                             write!(\n-                                msg,\n+                                fmt,\n                                 \" by align({}){} ref:\",\n                                 mplace.align.bytes(),\n                                 match mplace.meta {\n                                     MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n                                     MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n                                 }\n-                            )\n-                            .unwrap();\n+                            )?;\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n+                        ptr => write!(fmt, \" by integral ref: {:?}\", ptr)?,\n                     },\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n-                        write!(msg, \" {:?}\", val).unwrap();\n+                        write!(fmt, \" {:?}\", val)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n-                        write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n+                        write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n@@ -931,36 +958,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                trace!(\"{}\", msg);\n-                self.memory.dump_allocs(allocs);\n+                write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n             }\n             Place::Ptr(mplace) => match mplace.ptr {\n-                Scalar::Ptr(ptr) => {\n-                    trace!(\"by align({}) ref:\", mplace.align.bytes());\n-                    self.memory.dump_alloc(ptr.alloc_id);\n-                }\n-                ptr => trace!(\" integral by ref: {:?}\", ptr),\n+                Scalar::Ptr(ptr) => write!(\n+                    fmt,\n+                    \"by align({}) ref: {:?}\",\n+                    mplace.align.bytes(),\n+                    self.ecx.memory.dump_alloc(ptr.alloc_id)\n+                ),\n+                ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },\n         }\n     }\n-\n-    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n-        let mut frames = Vec::new();\n-        for frame in self.stack().iter().rev() {\n-            let source_info = frame.current_source_info();\n-            let lint_root = source_info.and_then(|source_info| {\n-                match &frame.body.source_scopes[source_info.scope].local_data {\n-                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n-                    mir::ClearCrossCrate::Clear => None,\n-                }\n-            });\n-            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n-\n-            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n-        }\n-        trace!(\"generate stacktrace: {:#?}\", frames);\n-        frames\n-    }\n }\n \n impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>"}, {"sha": "6681c4c7b8202bc59260f5804aede587959bdc06", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -430,7 +430,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => return Ok(false),\n         }\n \n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n         self.go_to_block(ret);\n         Ok(true)\n     }"}, {"sha": "0194c273f221781d31a0f02e3fa08bbd8037e4cd", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 91, "deletions": 61, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -667,69 +667,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Print an allocation and all allocations it points to, recursively.\n-    /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n-    /// control for this.\n-    pub fn dump_alloc(&self, id: AllocId) {\n-        self.dump_allocs(vec![id]);\n+    /// Create a lazy debug printer that prints the given allocation and all allocations it points\n+    /// to, recursively.\n+    #[must_use]\n+    pub fn dump_alloc<'a>(&'a self, id: AllocId) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n+        self.dump_allocs(vec![id])\n     }\n \n-    /// Print a list of allocations and all allocations they point to, recursively.\n-    /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n-    /// control for this.\n-    pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n-        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n-            tcx: TyCtxt<'tcx>,\n-            allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Tag, Extra>,\n-        ) {\n-            for &(_, target_id) in alloc.relocations().values() {\n-                allocs_to_print.push_back(target_id);\n-            }\n-            pretty::write_allocation(tcx, alloc, &mut std::io::stderr()).unwrap();\n-        }\n-\n+    /// Create a lazy debug printer for a list of allocations and all allocations they point to,\n+    /// recursively.\n+    #[must_use]\n+    pub fn dump_allocs<'a>(&'a self, mut allocs: Vec<AllocId>) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n-        let mut allocs_to_print = VecDeque::from(allocs);\n-        // `allocs_printed` contains all allocations that we have already printed.\n-        let mut allocs_printed = FxHashSet::default();\n-\n-        while let Some(id) = allocs_to_print.pop_front() {\n-            if !allocs_printed.insert(id) {\n-                // Already printed, so skip this.\n-                continue;\n-            }\n-\n-            eprint!(\"{}\", id);\n-            match self.alloc_map.get(id) {\n-                Some(&(kind, ref alloc)) => {\n-                    // normal alloc\n-                    eprint!(\" ({}, \", kind);\n-                    write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n-                }\n-                None => {\n-                    // global alloc\n-                    match self.tcx.get_global_alloc(id) {\n-                        Some(GlobalAlloc::Memory(alloc)) => {\n-                            eprint!(\" (unchanged global, \");\n-                            write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n-                        }\n-                        Some(GlobalAlloc::Function(func)) => {\n-                            eprint!(\" (fn: {})\", func);\n-                        }\n-                        Some(GlobalAlloc::Static(did)) => {\n-                            eprint!(\" (static: {})\", self.tcx.def_path_str(did));\n-                        }\n-                        None => {\n-                            eprint!(\" (deallocated)\");\n-                        }\n-                    }\n-                }\n-            }\n-            eprintln!();\n-        }\n+        DumpAllocs { mem: self, allocs }\n     }\n \n     /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n@@ -760,8 +711,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         });\n         let n = leaks.len();\n         if n > 0 {\n-            eprintln!(\"The following memory was leaked:\");\n-            self.dump_allocs(leaks);\n+            eprintln!(\"The following memory was leaked: {:?}\", self.dump_allocs(leaks));\n         }\n         n\n     }\n@@ -772,6 +722,86 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n+#[doc(hidden)]\n+/// There's no way to use this directly, it's just a helper struct for the `dump_alloc(s)` methods.\n+pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+    mem: &'a Memory<'mir, 'tcx, M>,\n+    allocs: Vec<AllocId>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n+            fmt: &mut std::fmt::Formatter<'_>,\n+            tcx: TyCtxt<'tcx>,\n+            allocs_to_print: &mut VecDeque<AllocId>,\n+            alloc: &Allocation<Tag, Extra>,\n+        ) -> std::fmt::Result {\n+            for &(_, target_id) in alloc.relocations().values() {\n+                allocs_to_print.push_back(target_id);\n+            }\n+            // This vec dance is necessary, because there is no trait\n+            // that supports writing to files and to `std::fmt::Formatter` at the\n+            // same time.\n+            let mut v = Vec::new();\n+            pretty::write_allocation(tcx, alloc, &mut v).unwrap();\n+            let s = String::from_utf8(v).unwrap();\n+            fmt.write_str(&s)\n+        }\n+\n+        let mut allocs_to_print: VecDeque<_> = self.allocs.iter().copied().collect();\n+        // `allocs_printed` contains all allocations that we have already printed.\n+        let mut allocs_printed = FxHashSet::default();\n+\n+        while let Some(id) = allocs_to_print.pop_front() {\n+            if !allocs_printed.insert(id) {\n+                // Already printed, so skip this.\n+                continue;\n+            }\n+\n+            write!(fmt, \"{}\", id)?;\n+            match self.mem.alloc_map.get(id) {\n+                Some(&(kind, ref alloc)) => {\n+                    // normal alloc\n+                    write!(fmt, \" ({}, \", kind)?;\n+                    write_allocation_track_relocs(\n+                        &mut *fmt,\n+                        self.mem.tcx,\n+                        &mut allocs_to_print,\n+                        alloc,\n+                    )?;\n+                }\n+                None => {\n+                    // global alloc\n+                    match self.mem.tcx.get_global_alloc(id) {\n+                        Some(GlobalAlloc::Memory(alloc)) => {\n+                            write!(fmt, \" (unchanged global, \")?;\n+                            write_allocation_track_relocs(\n+                                &mut *fmt,\n+                                self.mem.tcx,\n+                                &mut allocs_to_print,\n+                                alloc,\n+                            )?;\n+                        }\n+                        Some(GlobalAlloc::Function(func)) => {\n+                            write!(fmt, \" (fn: {})\", func)?;\n+                        }\n+                        Some(GlobalAlloc::Static(did)) => {\n+                            write!(fmt, \" (static: {})\", self.mem.tcx.def_path_str(did))?;\n+                        }\n+                        None => {\n+                            write!(fmt, \" (deallocated)\")?;\n+                        }\n+                    }\n+                }\n+            }\n+            writeln!(fmt)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice."}, {"sha": "15e341d9c4c01380cd6a1d6844327e630c939afb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -648,7 +648,7 @@ where\n             place_ty = self.place_projection(place_ty, &elem)?\n         }\n \n-        self.dump_place(place_ty.place);\n+        trace!(\"{:?}\", self.dump_place(place_ty.place));\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,"}, {"sha": "fcd26c86c473d62b3ebf0e04ae276f96ac50e9c5", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e96bb459377896a85be4a192e16feca4c1d4aaf/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=5e96bb459377896a85be4a192e16feca4c1d4aaf", "patch": "@@ -271,7 +271,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n \n         Ok(())\n     }"}]}