{"sha": "ac841e74502183cde08e462d98cc55752abd000a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODQxZTc0NTAyMTgzY2RlMDhlNDYyZDk4Y2M1NTc1MmFiZDAwMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-06T00:44:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-06T00:44:11Z"}, "message": "Auto merge of #54859 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #54078 (Expand the documentation for the `std::sync` module)\n - #54717 (Cleanup rustc/ty part 1)\n - #54781 (Add examples to `TyKind::FnDef` and `TyKind::FnPtr` docs)\n - #54787 (Only warn about unused `mut` in user-written code)\n - #54804 (add suggestion for inverted function parameters)\n - #54812 (Regression test for #32382.)\n - #54833 (make `Parser::parse_foreign_item()` return a foreign item or error)\n - #54834 (rustdoc: overflow:auto doesn't work nicely on small screens)\n - #54838 (Fix typo in src/libsyntax/parse/parser.rs)\n - #54851 (Fix a regression in 1.30 by reverting #53564)\n - #54853 (Remove unneccessary error from test, revealing NLL error.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5459e65f4c6e10cc9b02b1c31150fdc337f9446c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5459e65f4c6e10cc9b02b1c31150fdc337f9446c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac841e74502183cde08e462d98cc55752abd000a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac841e74502183cde08e462d98cc55752abd000a", "html_url": "https://github.com/rust-lang/rust/commit/ac841e74502183cde08e462d98cc55752abd000a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac841e74502183cde08e462d98cc55752abd000a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "html_url": "https://github.com/rust-lang/rust/commit/fddcd316af98583ebebfc40f6a25bec3f4e5fccc"}, {"sha": "51334c96b3810c2a4c299715fd7fe25da84146fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/51334c96b3810c2a4c299715fd7fe25da84146fc", "html_url": "https://github.com/rust-lang/rust/commit/51334c96b3810c2a4c299715fd7fe25da84146fc"}], "stats": {"total": 1299, "additions": 796, "deletions": 503}, "files": [{"sha": "571f35a2031d2a0b9e1eb57ac1f9728ca2fb245f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 5, "deletions": 47, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -19,7 +19,6 @@\n \n use core::cmp::Ordering;\n use core::fmt;\n-use core::isize;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n@@ -203,33 +202,6 @@ impl<T> VecDeque<T> {\n                                  len);\n     }\n \n-    /// Copies all values from `src` to the back of `self`, wrapping around if needed.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The capacity must be sufficient to hold self.len() + src.len() elements.\n-    /// If so, this function never panics.\n-    #[inline]\n-    unsafe fn copy_slice(&mut self, src: &[T]) {\n-        /// This is guaranteed by `RawVec`.\n-        debug_assert!(self.capacity() <= isize::MAX as usize);\n-\n-        let expected_new_len = self.len() + src.len();\n-        debug_assert!(self.capacity() >= expected_new_len);\n-\n-        let dst_high_ptr = self.ptr().add(self.head);\n-        let dst_high_len = self.cap() - self.head;\n-\n-        let split = cmp::min(src.len(), dst_high_len);\n-        let (src_high, src_low) = src.split_at(split);\n-\n-        ptr::copy_nonoverlapping(src_high.as_ptr(), dst_high_ptr, src_high.len());\n-        ptr::copy_nonoverlapping(src_low.as_ptr(), self.ptr(), src_low.len());\n-\n-        self.head = self.wrap_add(self.head, src.len());\n-        debug_assert!(self.len() == expected_new_len);\n-    }\n-\n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n@@ -1052,7 +1024,7 @@ impl<T> VecDeque<T> {\n             iter: Iter {\n                 tail: drain_tail,\n                 head: drain_head,\n-                ring: unsafe { self.buffer_as_slice() },\n+                ring: unsafe { self.buffer_as_mut_slice() },\n             },\n         }\n     }\n@@ -1862,22 +1834,8 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        unsafe {\n-            // Guarantees there is space in `self` for `other`.\n-            self.reserve(other.len());\n-\n-            {\n-                let (src_high, src_low) = other.as_slices();\n-\n-                // This is only safe because copy_slice never panics when capacity is sufficient.\n-                self.copy_slice(src_low);\n-                self.copy_slice(src_high);\n-            }\n-\n-            // Some values now exist in both `other` and `self` but are made inaccessible\n-            // in`other`.\n-            other.tail = other.head;\n-        }\n+        // naive impl\n+        self.extend(other.drain(..));\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -2635,8 +2593,8 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                         let mut right_offset = 0;\n                         for i in left_edge..right_edge {\n                             right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src = right_edge + right_offset;\n-                            ptr::swap(buf.add(i), buf.add(src));\n+                            let src: isize = (right_edge + right_offset) as isize;\n+                            ptr::swap(buf.add(i), buf.offset(src));\n                         }\n                         let n_ops = right_edge - left_edge;\n                         left_edge += n_ops;"}, {"sha": "7309358091056e32bc512e7536d5b0d05b6681fe", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -4132,16 +4132,16 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let head = self.lower_expr(head);\n                 let head_sp = head.span;\n+                let desugared_span = self.allow_internal_unstable(\n+                    CompilerDesugaringKind::ForLoop,\n+                    head_sp,\n+                );\n \n                 let iter = self.str_to_ident(\"iter\");\n \n                 let next_ident = self.str_to_ident(\"__next\");\n-                let next_sp = self.allow_internal_unstable(\n-                    CompilerDesugaringKind::ForLoop,\n-                    head_sp,\n-                );\n                 let next_pat = self.pat_ident_binding_mode(\n-                    next_sp,\n+                    desugared_span,\n                     next_ident,\n                     hir::BindingAnnotation::Mutable,\n                 );\n@@ -4170,8 +4170,11 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // `mut iter`\n-                let iter_pat =\n-                    self.pat_ident_binding_mode(head_sp, iter, hir::BindingAnnotation::Mutable);\n+                let iter_pat = self.pat_ident_binding_mode(\n+                    desugared_span,\n+                    iter,\n+                    hir::BindingAnnotation::Mutable\n+                );\n \n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n@@ -4200,8 +4203,12 @@ impl<'a> LoweringContext<'a> {\n                 let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n \n                 // `let mut __next`\n-                let next_let =\n-                    self.stmt_let_pat(head_sp, None, next_pat, hir::LocalSource::ForLoopDesugar);\n+                let next_let = self.stmt_let_pat(\n+                    desugared_span,\n+                    None,\n+                    next_pat,\n+                    hir::LocalSource::ForLoopDesugar,\n+                );\n \n                 // `let <pat> = __next`\n                 let pat = self.lower_pat(pat);"}, {"sha": "da2173fead3707d1e34a5e2b3cb0bf9dffbb1b59", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -46,7 +46,7 @@ use ty::subst::Subst;\n use ty::SubtypePredicate;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -68,18 +68,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }).collect();\n \n         for (index, error) in errors.iter().enumerate() {\n-            error_map.entry(error.obligation.cause.span).or_default().push(\n+            // We want to ignore desugarings here: spans are equivalent even\n+            // if one is the result of a desugaring and the other is not.\n+            let mut span = error.obligation.cause.span;\n+            if let Some(ExpnInfo {\n+                format: ExpnFormat::CompilerDesugaring(_),\n+                def_site: Some(def_span),\n+                ..\n+            }) = span.ctxt().outer().expn_info() {\n+                span = def_span;\n+            }\n+\n+            error_map.entry(span).or_default().push(\n                 ErrorDescriptor {\n                     predicate: error.obligation.predicate.clone(),\n                     index: Some(index)\n-                });\n+                }\n+            );\n \n             self.reported_trait_errors.borrow_mut()\n-                .entry(error.obligation.cause.span).or_default()\n+                .entry(span).or_default()\n                 .push(error.obligation.predicate.clone());\n         }\n \n-        // We do this in 2 passes because we want to display errors in order, tho\n+        // We do this in 2 passes because we want to display errors in order, though\n         // maybe it *is* better to sort errors by span or something.\n         let mut is_suppressed = vec![false; errors.len()];\n         for (_, error_set) in error_map.iter() {"}, {"sha": "8738f574148239e37966edc1ef3ef1a90f2f532e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -178,19 +178,19 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n     Ok(ty::GenericPredicates {\n         parent: Decodable::decode(decoder)?,\n         predicates: (0..decoder.read_usize()?).map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate = if decoder.positioned_at_shorthand() {\n-                    let pos = decoder.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let shorthand = pos - SHORTHAND_OFFSET;\n-\n-                    decoder.with_position(shorthand, ty::Predicate::decode)\n-                } else {\n-                    ty::Predicate::decode(decoder)\n-                }?;\n-                Ok((predicate, Decodable::decode(decoder)?))\n-            })\n-            .collect::<Result<Vec<_>, _>>()?,\n+            // Handle shorthands first, if we have an usize > 0x80.\n+            let predicate = if decoder.positioned_at_shorthand() {\n+                let pos = decoder.read_usize()?;\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                decoder.with_position(shorthand, ty::Predicate::decode)\n+            } else {\n+                ty::Predicate::decode(decoder)\n+            }?;\n+            Ok((predicate, Decodable::decode(decoder)?))\n+        })\n+        .collect::<Result<Vec<_>, _>>()?,\n     })\n }\n \n@@ -267,7 +267,7 @@ pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_allocation<'a, 'tcx, D>(decoder: &mut D)\n-                                 -> Result<&'tcx Allocation, D::Error>\n+    -> Result<&'tcx Allocation, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {"}, {"sha": "46ba5f5ef362dfb30e6f5b5deb2186dbe577d255", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -190,8 +190,8 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             // types/regions in the global interner\n             if local as *const _ as usize == global as *const _ as usize {\n                 bug!(\"Attempted to intern `{:?}` which contains \\\n-                    inference types/regions in the global type context\",\n-                    &ty_struct);\n+                      inference types/regions in the global type context\",\n+                     &ty_struct);\n             }\n \n             // Don't be &mut TyS.\n@@ -272,9 +272,9 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n \n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                          tcx.hir.node_to_string(node_id),\n-                          DefId::local(hir_id.owner),\n-                          local_id_root)\n+                         tcx.hir.node_to_string(node_id),\n+                         DefId::local(hir_id.owner),\n+                         local_id_root)\n                 });\n             }\n         } else {\n@@ -540,16 +540,13 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_id_to_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        match self.node_id_to_type_opt(id) {\n-            Some(ty) => ty,\n-            None => {\n-                bug!(\"node_id_to_type: no type for node `{}`\",\n-                    tls::with(|tcx| {\n-                        let id = tcx.hir.hir_to_node_id(id);\n-                        tcx.hir.node_to_string(id)\n-                    }))\n-            }\n-        }\n+        self.node_id_to_type_opt(id).unwrap_or_else(||\n+            bug!(\"node_id_to_type: no type for node `{}`\",\n+                 tls::with(|tcx| {\n+                     let id = tcx.hir.hir_to_node_id(id);\n+                     tcx.hir.node_to_string(id)\n+                 }))\n+        )\n     }\n \n     pub fn node_id_to_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n@@ -686,7 +683,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn pat_adjustments_mut(&mut self)\n-                           -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+                               -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.pat_adjustments,\n@@ -1199,8 +1196,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n             Lrc::get_mut(map).unwrap()\n-                            .insert(hir_id.local_id,\n-                                    Lrc::new(StableVec::new(v)));\n+                             .insert(hir_id.local_id,\n+                                     Lrc::new(StableVec::new(v)));\n         }\n \n         let gcx = &GlobalCtxt {\n@@ -2188,7 +2185,6 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-\n                 for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n@@ -2207,7 +2203,7 @@ macro_rules! sty_debug_print {\n                 }\n                 println!(\"Ty interner             total           ty region  both\");\n                 $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n-{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                            {ty:4.1}% {region:5.1}% {both:4.1}%\",\n                            stringify!($variant),\n                            uses = $variant.total,\n                            usespc = $variant.total as f64 * 100.0 / total.total as f64,\n@@ -2216,7 +2212,7 @@ macro_rules! sty_debug_print {\n                            both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n                   )*\n                 println!(\"                  total {uses:6}        \\\n-{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                          {ty:4.1}% {region:5.1}% {both:4.1}%\",\n                          uses = total.total,\n                          ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n                          region = total.region_infer as f64 * 100.0  / total.total as f64,\n@@ -2653,7 +2649,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n     pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n-                                          -> Ty<'tcx> {\n+                      -> Ty<'tcx> {\n         self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n@@ -2686,8 +2682,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_ty_param(self,\n-                    index: u32,\n-                    name: InternedString) -> Ty<'tcx> {\n+                       index: u32,\n+                       name: InternedString) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n "}, {"sha": "3123f0fbe31de3c9308c3b1999db83abe7862e52", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n+use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n@@ -71,7 +72,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::TypeError::*;\n         fn report_maybe_different(f: &mut fmt::Formatter<'_>,\n-                                  expected: String, found: String) -> fmt::Result {\n+                                  expected: &str, found: &str) -> fmt::Result {\n             // A naive approach to making sure that we're not reporting silly errors such as:\n             // (expected closure, found closure).\n             if expected == found {\n@@ -126,15 +127,15 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        br)\n             }\n             Sorts(values) => ty::tls::with(|tcx| {\n-                report_maybe_different(f, values.expected.sort_string(tcx),\n-                                       values.found.sort_string(tcx))\n+                report_maybe_different(f, &values.expected.sort_string(tcx),\n+                                       &values.found.sort_string(tcx))\n             }),\n             Traits(values) => ty::tls::with(|tcx| {\n                 report_maybe_different(f,\n-                                       format!(\"trait `{}`\",\n-                                               tcx.item_path_str(values.expected)),\n-                                       format!(\"trait `{}`\",\n-                                               tcx.item_path_str(values.found)))\n+                                       &format!(\"trait `{}`\",\n+                                                tcx.item_path_str(values.expected)),\n+                                       &format!(\"trait `{}`\",\n+                                                tcx.item_path_str(values.found)))\n             }),\n             IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n@@ -162,8 +163,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.found)\n             },\n             ExistentialMismatch(ref values) => {\n-                report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n-                                       format!(\"trait `{}`\", values.found))\n+                report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n+                                       &format!(\"trait `{}`\", values.found))\n             }\n             OldStyleLUB(ref err) => {\n                 write!(f, \"{}\", err)\n@@ -173,22 +174,22 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n }\n \n impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n+    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> Cow<'static, str> {\n         match self.sty {\n             ty::Bool | ty::Char | ty::Int(_) |\n-            ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string(),\n-            ty::Tuple(ref tys) if tys.is_empty() => self.to_string(),\n+            ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n+            ty::Tuple(ref tys) if tys.is_empty() => self.to_string().into(),\n \n-            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n-            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)).into(),\n+            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)).into(),\n             ty::Array(_, n) => {\n                 match n.assert_usize(tcx) {\n-                    Some(n) => format!(\"array of {} elements\", n),\n-                    None => \"array\".to_string(),\n+                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    None => \"array\".into(),\n                 }\n             }\n-            ty::Slice(_) => \"slice\".to_string(),\n-            ty::RawPtr(_) => \"*-ptr\".to_string(),\n+            ty::Slice(_) => \"slice\".into(),\n+            ty::RawPtr(_) => \"*-ptr\".into(),\n             ty::Ref(region, ty, mutbl) => {\n                 let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n@@ -199,39 +200,39 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     format!(\"{}reference\", match mutbl {\n                         hir::Mutability::MutMutable => \"mutable \",\n                         _ => \"\"\n-                    })\n+                    }).into()\n                 } else {\n-                    format!(\"&{}\", tymut_string)\n+                    format!(\"&{}\", tymut_string).into()\n                 }\n             }\n-            ty::FnDef(..) => \"fn item\".to_string(),\n-            ty::FnPtr(_) => \"fn pointer\".to_string(),\n+            ty::FnDef(..) => \"fn item\".into(),\n+            ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n-                inner.principal().map_or_else(|| \"trait\".to_string(),\n-                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n+                inner.principal().map_or_else(|| \"trait\".into(),\n+                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())).into())\n             }\n-            ty::Closure(..) => \"closure\".to_string(),\n-            ty::Generator(..) => \"generator\".to_string(),\n-            ty::GeneratorWitness(..) => \"generator witness\".to_string(),\n-            ty::Tuple(..) => \"tuple\".to_string(),\n-            ty::Infer(ty::TyVar(_)) => \"inferred type\".to_string(),\n-            ty::Infer(ty::IntVar(_)) => \"integral variable\".to_string(),\n-            ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::Closure(..) => \"closure\".into(),\n+            ty::Generator(..) => \"generator\".into(),\n+            ty::GeneratorWitness(..) => \"generator witness\".into(),\n+            ty::Tuple(..) => \"tuple\".into(),\n+            ty::Infer(ty::TyVar(_)) => \"inferred type\".into(),\n+            ty::Infer(ty::IntVar(_)) => \"integral variable\".into(),\n+            ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".into(),\n             ty::Infer(ty::CanonicalTy(_)) |\n-            ty::Infer(ty::FreshTy(_)) => \"fresh type\".to_string(),\n-            ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".to_string(),\n-            ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".to_string(),\n-            ty::Projection(_) => \"associated type\".to_string(),\n-            ty::UnnormalizedProjection(_) => \"non-normalized associated type\".to_string(),\n+            ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n+            ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n+            ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n+            ty::Projection(_) => \"associated type\".into(),\n+            ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n             ty::Param(ref p) => {\n                 if p.is_self() {\n-                    \"Self\".to_string()\n+                    \"Self\".into()\n                 } else {\n-                    \"type parameter\".to_string()\n+                    \"type parameter\".into()\n                 }\n             }\n-            ty::Opaque(..) => \"opaque type\".to_string(),\n-            ty::Error => \"type error\".to_string(),\n+            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Error => \"type error\".into(),\n         }\n     }\n }\n@@ -251,20 +252,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     db.note(\"no two closures, even if identical, have the same type\");\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n-                match (&values.found.sty, &values.expected.sty) { // Issue #53280\n-                    (ty::Infer(ty::IntVar(_)), ty::Float(_)) => {\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n-                            if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                                db.span_suggestion_with_applicability(\n-                                    sp,\n-                                    \"use a float literal\",\n-                                    format!(\"{}.0\", snippet),\n-                                    Applicability::MachineApplicable\n-                                );\n-                            }\n+                if let (ty::Infer(ty::IntVar(_)), ty::Float(_)) =\n+                       (&values.found.sty, &values.expected.sty) // Issue #53280\n+                {\n+                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n+                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n+                            db.span_suggestion_with_applicability(\n+                                sp,\n+                                \"use a float literal\",\n+                                format!(\"{}.0\", snippet),\n+                                Applicability::MachineApplicable\n+                            );\n                         }\n-                    },\n-                    _ => {}\n+                    }\n                 }\n             },\n             OldStyleLUB(err) => {"}, {"sha": "c3d41873009a7b1d294a88e611b96e8f1d127df9", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -62,9 +62,7 @@ impl FlagComputation {\n         let outer_exclusive_binder = computation.outer_exclusive_binder;\n         if outer_exclusive_binder > ty::INNERMOST {\n             self.add_exclusive_binder(outer_exclusive_binder.shifted_out(1));\n-        } else {\n-            // otherwise, this binder captures nothing\n-        }\n+        } // otherwise, this binder captures nothing\n     }\n \n     fn add_sty(&mut self, st: &ty::TyKind<'_>) {"}, {"sha": "7bc77e1b1a14053350f9b25e3bdfde56772840dd", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -66,12 +66,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     id: DefId) -> bool\n     {\n-        for root_id in self.root_ids.iter() {\n-            if tcx.is_descendant_of(id, *root_id) {\n-                return true;\n-            }\n-        }\n-        false\n+        self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n     }\n \n     /// Calculate the intersection of a collection of forests.\n@@ -92,11 +87,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n             }\n             ret.root_ids.extend(old_ret.drain());\n \n-            for id in next_forest.root_ids {\n-                if ret.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n+            next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n \n             mem::swap(&mut next_ret, &mut ret.root_ids);\n             next_ret.drain();\n@@ -112,11 +103,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n         let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();\n         for next_forest in iter {\n-            for id in ret.root_ids.drain() {\n-                if !next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n+            next_ret.extend(ret.root_ids.drain().filter(|&id| !next_forest.contains(tcx, id)));\n \n             for id in next_forest.root_ids {\n                 if !next_ret.contains(&id) {"}, {"sha": "79eab3c6f34b9eb79f674d974860cc624714671f", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 219, "deletions": 208, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -23,6 +23,7 @@ use ty::query::Query;\n use ty::query::QueryCache;\n use util::profiling::ProfileCategory;\n \n+use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n@@ -55,7 +56,7 @@ pub(super) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n }\n \n pub(super) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: Self::Key) -> String;\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n     fn cache_on_disk(_: Self::Key) -> bool {\n@@ -70,12 +71,12 @@ pub(super) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n }\n \n impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n-    default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n-            format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+            format!(\"processing `{}`\", tcx.item_path_str(def_id)).into()\n         } else {\n             let name = unsafe { ::std::intrinsics::type_name::<M>() };\n-            format!(\"processing `{}` applied to `{:?}`\", name, def_id)\n+            format!(\"processing `{}` applied to `{:?}`\", name, def_id).into()\n         }\n     }\n }\n@@ -84,201 +85,210 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,\n         goal: CanonicalProjectionGoal<'tcx>,\n-    ) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    ) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::implied_outlives_bounds<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> String {\n-        format!(\"computing implied outlives bounds for `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing implied outlives bounds for `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> String {\n-        format!(\"computing dropck types for `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing dropck types for `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_regions<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalPredicateGoal<'tcx>) -> String {\n-        format!(\"evaluating trait selection obligation `{}`\", goal.value.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalPredicateGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"evaluating trait selection obligation `{}`\", goal.value.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> String {\n-        format!(\"evaluating `type_op_eq` `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_eq` `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_subtype<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpSubtypeGoal<'tcx>) -> String {\n-        format!(\"evaluating `type_op_subtype` `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpSubtypeGoal<'tcx>)\n+                -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_subtype` `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_prove_predicate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpProvePredicateGoal<'tcx>) -> String {\n-        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpProvePredicateGoal<'tcx>)\n+                -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_ty<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+                goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_predicate<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,\n         goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    ) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_poly_fn_sig<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,\n         goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>,\n-    ) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    ) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_fn_sig<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+                goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Copy`\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` is `Copy`\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_sized_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Sized`\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` is `Sized`\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_freeze_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is freeze\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` is freeze\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::needs_drop_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` needs drop\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` needs drop\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing layout of `{}`\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing layout of `{}`\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"computing the supertraits of `{}`\",\n-                tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> String {\n-        format!(\"erasing regions from `{:?}`\", ty)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> Cow<'static, str> {\n+        format!(\"erasing regions from `{:?}`\", ty).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir.ty_param_name(id))\n+                tcx.hir.ty_param_name(id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::upstream_monomorphizations<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> String {\n-        format!(\"collecting available upstream monomorphizations `{:?}`\", k)\n+    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n+        format!(\"collecting available upstream monomorphizations `{:?}`\", k).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> String {\n-        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls_overlap_check<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"check for overlap between inherent impls defined in this crate\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"check for overlap between inherent impls defined in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_variances<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"computing the variances for items in this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"computing the variances for items in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"computing the inferred outlives predicates for items in this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"computing the inferred outlives predicates for items in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n         format!(\"generating MIR shim for `{}`\",\n-                tcx.item_path_str(def.def_id()))\n+                tcx.item_path_str(def.def_id())).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"privacy access levels\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"privacy access levels\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"type-checking all item bodies\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"type-checking all item bodies\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::reachable_set<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"reachability\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"reachability\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>) -> String {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id()))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+        -> Cow<'static, str>\n+    {\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id())).into()\n     }\n \n     #[inline]\n@@ -295,14 +305,14 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::mir_keys<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"getting a list of all mir_keys\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"getting a list of all mir_keys\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> String {\n-        format!(\"computing the symbol for `{}`\", instance)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing the symbol for `{}`\", instance).into()\n     }\n \n     #[inline]\n@@ -319,64 +329,64 @@ impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::describe_def<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"describe_def\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::def_span<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"def_span\")\n     }\n }\n \n \n impl<'tcx> QueryDescription<'tcx> for queries::lookup_stability<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"stability\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::lookup_deprecation_entry<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"deprecation\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"item_attrs\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_reachable_non_generic<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"is_reachable_non_generic\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::fn_arg_names<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"fn_arg_names\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::impl_parent<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"impl_parent\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"trait_of_item\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.item_path_str(def_id))\n+            tcx.item_path_str(def_id)).into()\n     }\n \n     #[inline]\n@@ -386,30 +396,31 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_sta\n \n     #[inline]\n     fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          id: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n         tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking which parts of `{}` are promotable to static\",\n-                tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking if item is mir available: `{}`\",\n-            tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>,\n-                key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n+                key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Cow<'static, str> {\n         format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+            .into()\n     }\n \n     #[inline]\n@@ -426,320 +437,320 @@ impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx>\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n-        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n-        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn_raw<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n-        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"dylib dependency formats of crate\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"dylib dependency formats of crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate is_panic_runtime\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate is_panic_runtime\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate is_compiler_builtins\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate is_compiler_builtins\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate has_global_allocator\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate has_global_allocator\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::has_panic_handler<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate has_panic_handler\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate has_panic_handler\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n-        \"getting crate's ExternCrateData\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n+        \"getting crate's ExternCrateData\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::lint_levels<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"computing the lint levels for items in this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"computing the lint levels for items in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::specializes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> String {\n-        \"computing whether impls specialize one another\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> Cow<'static, str> {\n+        \"computing whether impls specialize one another\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::in_scope_traits_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"traits in scope at a block\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"traits in scope at a block\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_no_builtins<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"test whether a crate has #![no_builtins]\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"test whether a crate has #![no_builtins]\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::panic_strategy<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"query a crate's configured panic strategy\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"query a crate's configured panic strategy\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_profiler_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"query a crate is #![profiler_runtime]\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"query a crate is #![profiler_runtime]\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"query a crate is #![sanitizer_runtime]\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"query a crate is #![sanitizer_runtime]\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::reachable_non_generics<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the exported symbols of a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the exported symbols of a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::native_libraries<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the native libraries of a linked crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the native libraries of a linked crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::foreign_modules<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the foreign modules of a linked crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the foreign modules of a linked crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the plugin registrar for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the plugin registrar for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::derive_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the derive registrar for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the derive registrar for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_disambiguator<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the disambiguator a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the disambiguator a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_hash<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the hash a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the hash a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the original name a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the original name a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::extra_filename<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the extra filename for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the extra filename for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (CrateNum, DefId)) -> String {\n-        \"looking up implementations of a trait in a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (CrateNum, DefId)) -> Cow<'static, str> {\n+        \"looking up implementations of a trait in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::all_trait_implementations<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up all (?) trait implementations\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up all (?) trait implementations\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up link arguments for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up link arguments for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::resolve_lifetimes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"resolving lifetimes\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"resolving lifetimes\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"looking up a named region\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"looking up a named region\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_late_bound_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"testing if a region is late bound\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"testing if a region is late bound\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::object_lifetime_defaults_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"looking up lifetime defaults for a region\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"looking up lifetime defaults for a region\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dep_kind<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching what a dependency looks like\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching what a dependency looks like\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching what a crate is named\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching what a crate is named\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::get_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        format!(\"calculating the lib features map\")\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lib features map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::defined_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        format!(\"calculating the lib features defined in a crate\")\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lib features defined in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::get_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the lang items map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lang items map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::defined_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the lang items defined in a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lang items defined in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::missing_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the missing lang items in a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the missing lang items in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::visible_parent_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the visible parent map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the visible parent map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::missing_extern_crate_item<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"seeing if we're missing an `extern crate` item for this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"seeing if we're missing an `extern crate` item for this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::used_crate_source<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking at the source for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking at the source for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::postorder_cnums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"generating a postorder list of CrateNums\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"generating a postorder list of CrateNums\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::maybe_unused_extern_crates<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up all possibly unused extern crates\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up all possibly unused extern crates\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::stability_index<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the stability index for the local crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the stability index for the local crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::all_traits<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching all foreign and local traits\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching all foreign and local traits\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::all_crate_nums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching all foreign CrateNum instances\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching all foreign CrateNum instances\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::exported_symbols<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"exported_symbols\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"exported_symbols\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_mono_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"collect_and_partition_mono_items\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"collect_and_partition_mono_items\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: InternedString) -> String {\n-        \"codegen_unit\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: InternedString) -> Cow<'static, str> {\n+        \"codegen_unit\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"output_filenames\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"output_filenames\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> String {\n-        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> Cow<'static, str> {\n+        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id())).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up enabled feature gates\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up enabled feature gates\".into()\n     }\n }\n \n@@ -776,20 +787,20 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, &'tcx Substs<'tcx>)) -> String {\n-        format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, &'tcx Substs<'tcx>)) -> Cow<'static, str> {\n+        format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the whitelist of target features\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the whitelist of target features\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> String {\n-        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id()))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n+        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id())).into()\n     }\n }\n \n@@ -809,26 +820,26 @@ impl<'tcx> QueryDescription<'tcx> for queries::generics_of<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n-        \"generating chalk-style clauses\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n+        \"generating chalk-style clauses\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for_env<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: ty::ParamEnv<'tcx>) -> String {\n-        \"generating chalk-style clauses for param env\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: ty::ParamEnv<'tcx>) -> Cow<'static, str> {\n+        \"generating chalk-style clauses for param env\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::wasm_import_module_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"wasm import module map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"wasm import module map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"wasm import module map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"wasm import module map\".into()\n     }\n }\n "}, {"sha": "d588bc8c0cb5ca6992b57884fbad14e5ee5e81ec", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -123,9 +123,11 @@ impl<'tcx> QueryJob<'tcx> {\n         let mut cycle = Vec::new();\n \n         while let Some(job) = current_job {\n-            cycle.insert(0, job.info.clone());\n+            cycle.push(job.info.clone());\n \n             if ptr::eq(&*job, self) {\n+                cycle.reverse();\n+\n                 // This is the end of the cycle\n                 // The span entry we included was for the usage\n                 // of the cycle itself, and not part of the cycle\n@@ -324,16 +326,16 @@ fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n ) -> bool {\n-    // We already visited this or we're deliberately ignoring it\n-    if visited.contains(&query.as_ptr()) {\n-        return false;\n-    }\n-\n     // This query is connected to the root (it has no query parent), return true\n     if query.parent.is_none() {\n         return true;\n     }\n \n+    // We already visited this or we're deliberately ignoring it\n+    if visited.contains(&query.as_ptr()) {\n+        return false;\n+    }\n+\n     visited.insert(query.as_ptr());\n \n     let mut connected = false;\n@@ -368,13 +370,11 @@ fn remove_cycle<'tcx>(\n         // Reverse the stack so earlier entries require later entries\n         stack.reverse();\n \n-        // Extract the spans and queries into separate arrays\n-        let mut spans: Vec<_> = stack.iter().map(|e| e.0).collect();\n-        let queries = stack.into_iter().map(|e| e.1);\n+        // The stack is a vector of pairs of spans and queries\n+        let (mut spans, queries): (Vec<_>, Vec<_>) = stack.into_iter().unzip();\n \n         // Shift the spans so that queries are matched with the span for their waitee\n-        let last = spans.pop().unwrap();\n-        spans.insert(0, last);\n+        spans.rotate_right(1);\n \n         // Zip them back together\n         let mut stack: Vec<_> = spans.into_iter().zip(queries).collect();\n@@ -388,7 +388,7 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points: Vec<Lrc<QueryJob<'tcx>>> = stack.iter().filter_map(|query| {\n+        let entry_points = stack.iter().filter_map(|query| {\n             // Mark all the other queries in the cycle as already visited\n             let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n                 if q.1.as_ptr() != query.1.as_ptr() {\n@@ -403,21 +403,21 @@ fn remove_cycle<'tcx>(\n             } else {\n                 None\n             }\n-        }).collect();\n+        });\n \n         // Deterministically pick an entry point\n         // FIXME: Sort this instead\n         let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.iter().min_by_key(|q| {\n+        let entry_point = entry_points.min_by_key(|q| {\n             let mut stable_hasher = StableHasher::<u64>::new();\n             q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n             stable_hasher.finish()\n         }).unwrap().as_ptr();\n \n-        // Shift the stack until our entry point is first\n-        while stack[0].1.as_ptr() != entry_point {\n-            let last = stack.pop().unwrap();\n-            stack.insert(0, last);\n+        // Shift the stack so that our entry point is first\n+        let entry_point_pos = stack.iter().position(|(_, query)| query.as_ptr() == entry_point);\n+        if let Some(pos) = entry_point_pos {\n+            stack.rotate_right(pos);\n         }\n \n         // Create the cycle error"}, {"sha": "7f5bc35f91f9bbc4a60c14af289903767b664748", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -56,6 +56,7 @@ use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::PanicStrategy;\n \n+use std::borrow::Cow;\n use std::ops::Deref;\n use std::sync::Arc;\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "ce580c7803355ea8e5de3b3baabd1ad4351572bf", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -254,23 +254,19 @@ impl<'sess> OnDiskCache<'sess> {\n             })?;\n \n             // Encode diagnostics\n-            let diagnostics_index = {\n-                let mut diagnostics_index = EncodedDiagnosticsIndex::new();\n-\n-                for (dep_node_index, diagnostics) in self.current_diagnostics\n-                                                        .borrow()\n-                                                        .iter() {\n-                    let pos = AbsoluteBytePos::new(encoder.position());\n-                    // Let's make sure we get the expected type here:\n-                    let diagnostics: &EncodedDiagnostics = diagnostics;\n-                    let dep_node_index =\n-                        SerializedDepNodeIndex::new(dep_node_index.index());\n-                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n-                    diagnostics_index.push((dep_node_index, pos));\n-                }\n-\n-                diagnostics_index\n-            };\n+            let diagnostics_index: EncodedDiagnosticsIndex = self.current_diagnostics.borrow()\n+                .iter()\n+                .map(|(dep_node_index, diagnostics)|\n+            {\n+                let pos = AbsoluteBytePos::new(encoder.position());\n+                // Let's make sure we get the expected type here:\n+                let diagnostics: &EncodedDiagnostics = diagnostics;\n+                let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                Ok((dep_node_index, pos))\n+            })\n+            .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n@@ -282,6 +278,7 @@ impl<'sess> OnDiskCache<'sess> {\n                         // otherwise, abort\n                         break;\n                     }\n+                    interpret_alloc_index.reserve(new_n);\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n                         let pos = encoder.position() as u32;\n@@ -441,16 +438,15 @@ impl<'sess> OnDiskCache<'sess> {\n         tcx.dep_graph.with_ignore(|| {\n             let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n                 let crate_name = tcx.original_crate_name(cnum)\n-                                    .as_str()\n                                     .to_string();\n                 let crate_disambiguator = tcx.crate_disambiguator(cnum);\n                 ((crate_name, crate_disambiguator), cnum)\n             }).collect::<FxHashMap<_,_>>();\n \n             let map_size = prev_cnums.iter()\n-                                    .map(|&(cnum, ..)| cnum)\n-                                    .max()\n-                                    .unwrap_or(0) + 1;\n+                                     .map(|&(cnum, ..)| cnum)\n+                                     .max()\n+                                     .unwrap_or(0) + 1;\n             let mut map = IndexVec::new();\n             map.resize(map_size as usize, None);\n \n@@ -465,7 +461,6 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n }\n \n-\n //- DECODING -------------------------------------------------------------------\n \n /// A decoder that can read the incr. comp. cache. It is similar to the one\n@@ -494,7 +489,7 @@ impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             source_map.source_file_by_stable_id(stable_id)\n-                   .expect(\"Failed to lookup SourceFile in new context.\")\n+                .expect(\"Failed to lookup SourceFile in new context.\")\n         }).clone()\n     }\n }\n@@ -761,7 +756,7 @@ for CacheDecoder<'a, 'tcx, 'x> {\n \n struct CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder,\n-          'tcx: 'a,\n+             'tcx: 'a,\n {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     encoder: &'enc mut E,\n@@ -839,9 +834,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n         let (file_lo, line_lo, col_lo) = match self.source_map\n                                                    .byte_pos_to_line_and_col(span_data.lo) {\n             Some(pos) => pos,\n-            None => {\n-                return TAG_INVALID_SPAN.encode(self);\n-            }\n+            None => return TAG_INVALID_SPAN.encode(self)\n         };\n \n         if !file_lo.contains(span_data.hi) {"}, {"sha": "39a59cf090ea80b5b99363c616ada5dc16d4a588", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -449,14 +449,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let prev_dep_node_index =\n                 self.dep_graph.prev_dep_node_index_of(dep_node);\n             let result = Q::try_load_from_disk(self.global_tcx(),\n-                                                    prev_dep_node_index);\n+                                               prev_dep_node_index);\n \n             // We always expect to find a cached result for things that\n             // can be forced from DepNode.\n             debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n-                            result.is_some(),\n-                            \"Missing on-disk cache entry for {:?}\",\n-                            dep_node);\n+                          result.is_some(),\n+                          \"Missing on-disk cache entry for {:?}\",\n+                          dep_node);\n             result\n         } else {\n             // Some things are never cached on disk.\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                     self.dep_graph.prev_fingerprint_of(dep_node),\n                     \"Fingerprint for green query instance not loaded \\\n-                        from cache: {:?}\", dep_node);\n+                     from cache: {:?}\", dep_node);\n \n             debug!(\"BEGIN verify_ich({:?})\", dep_node);\n             let mut hcx = self.create_stable_hashing_context();\n@@ -530,8 +530,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //    (see for example #48923)\n         assert!(!self.dep_graph.dep_node_exists(&dep_node),\n                 \"Forcing query with already existing DepNode.\\n\\\n-                    - query-key: {:?}\\n\\\n-                    - dep-node: {:?}\",\n+                 - query-key: {:?}\\n\\\n+                 - dep-node: {:?}\",\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n@@ -709,14 +709,19 @@ macro_rules! define_queries_inner {\n \n                 // We use try_lock here since we are only called from the\n                 // deadlock handler, and this shouldn't be locked\n-                $(for v in self.$name.try_lock().unwrap().active.values() {\n-                    match *v {\n-                        QueryResult::Started(ref job) => jobs.push(job.clone()),\n-                        _ => (),\n-                    }\n-                })*\n-\n-                return jobs;\n+                $(\n+                    jobs.extend(\n+                        self.$name.try_lock().unwrap().active.values().filter_map(|v|\n+                            if let QueryResult::Started(ref job) = *v {\n+                                Some(job.clone())\n+                            } else {\n+                                None\n+                            }\n+                        )\n+                    );\n+                )*\n+\n+                jobs\n             }\n         }\n \n@@ -733,14 +738,14 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            pub fn describe(&self, tcx: TyCtxt<'_, '_, '_>) -> String {\n+            pub fn describe(&self, tcx: TyCtxt<'_, '_, '_>) -> Cow<'static, str> {\n                 let (r, name) = match *self {\n                     $(Query::$name(key) => {\n                         (queries::$name::describe(tcx, key), stringify!($name))\n                     })*\n                 };\n                 if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name)\n+                    format!(\"{} [{}]\", r, name).into()\n                 } else {\n                     r\n                 }\n@@ -753,9 +758,8 @@ macro_rules! define_queries_inner {\n                 }\n                 // The def_span query is used to calculate default_span,\n                 // so exit to avoid infinite recursion\n-                match *self {\n-                    Query::def_span(..) => return span,\n-                    _ => ()\n+                if let Query::def_span(..) = *self {\n+                    return span\n                 }\n                 match *self {\n                     $(Query::$name(key) => key.default_span(tcx),)*\n@@ -1028,13 +1032,10 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                     )\n                 );\n \n-                match tcx.force_query::<::ty::query::queries::$query<'_>>(\n+                if let Err(e) = tcx.force_query::<::ty::query::queries::$query<'_>>(\n                     $key, DUMMY_SP, *dep_node\n                 ) {\n-                    Ok(_) => {},\n-                    Err(e) => {\n-                        tcx.report_cycle(e).emit();\n-                    }\n+                    tcx.report_cycle(e).emit();\n                 }\n             }\n         }"}, {"sha": "145c122e75d681070cfa2f1616b2c2185dcef61f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -126,10 +126,25 @@ pub enum TyKind<'tcx> {\n     Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n \n     /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type.\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n     FnDef(DefId, &'tcx Substs<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n     FnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`."}, {"sha": "b1f89ce33fcfa58339a4ac31e5ec8f4160face2c", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -76,10 +76,14 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n             }\n \n             let (hir_id, span) = ids[0];\n-            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n+            if span.compiler_desugaring_kind().is_some() {\n+                // If the `mut` arises as part of a desugaring, we should ignore it.\n+                continue;\n+            }\n \n             // Ok, every name wasn't used mutably, so issue a warning that this\n             // didn't need to be mutable.\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n             tcx.struct_span_lint_hir(UNUSED_MUT,\n                                      hir_id,\n                                      span,"}, {"sha": "0943b36440aa67c7fc2f2f65c814d22f1c76e750", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -316,14 +316,18 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             }\n \n             let span = local_decl.source_info.span;\n-            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n+            if span.compiler_desugaring_kind().is_some() {\n+                // If the `mut` arises as part of a desugaring, we should ignore it.\n+                continue;\n+            }\n \n             let mut err = tcx.struct_span_lint_node(\n                 UNUSED_MUT,\n                 vsi[local_decl.source_info.scope].lint_root,\n                 span,\n                 \"variable does not need to be mutable\",\n             );\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n             err.span_suggestion_short_with_applicability(\n                 mut_span,\n                 \"remove this `mut`\","}, {"sha": "7ee45d7078739f04fbab8da8d53d8c061806a4fe", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -140,7 +140,8 @@ enum CallKind {\n fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span };\n     LocalDecl {\n-        mutability, ty,\n+        mutability,\n+        ty,\n         user_ty: None,\n         name: None,\n         source_info,"}, {"sha": "58ac46d22717bc7dd0af46b28d11b7335a5ce9f1", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -97,7 +97,6 @@ h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod):not(.important), h4\n h1.fqn {\n \tborder-bottom: 1px dashed;\n \tmargin-top: 0;\n-\toverflow: auto;\n }\n h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tborder-bottom: 1px solid;"}, {"sha": "d69ebc17622720200a1db22eb5262621e99946ce", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 148, "deletions": 4, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -10,10 +10,154 @@\n \n //! Useful synchronization primitives.\n //!\n-//! This module contains useful safe and unsafe synchronization primitives.\n-//! Most of the primitives in this module do not provide any sort of locking\n-//! and/or blocking at all, but rather provide the necessary tools to build\n-//! other types of concurrent primitives.\n+//! ## The need for synchronization\n+//!\n+//! Conceptually, a Rust program is a series of operations which will\n+//! be executed on a computer. The timeline of events happening in the\n+//! program is consistent with the order of the operations in the code.\n+//!\n+//! Consider the following code, operating on some global static variables:\n+//!\n+//! ```rust\n+//! static mut A: u32 = 0;\n+//! static mut B: u32 = 0;\n+//! static mut C: u32 = 0;\n+//!\n+//! fn main() {\n+//!     unsafe {\n+//!         A = 3;\n+//!         B = 4;\n+//!         A = A + B;\n+//!         C = B;\n+//!         println!(\"{} {} {}\", A, B, C);\n+//!         C = A;\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! It appears as if some variables stored in memory are changed, an addition\n+//! is performed, result is stored in `A` and the variable `C` is\n+//! modified twice.\n+//!\n+//! When only a single thread is involved, the results are as expected:\n+//! the line `7 4 4` gets printed.\n+//!\n+//! As for what happens behind the scenes, when optimizations are enabled the\n+//! final generated machine code might look very different from the code:\n+//!\n+//! - The first store to `C` might be moved before the store to `A` or `B`,\n+//!   _as if_ we had written `C = 4; A = 3; B = 4`.\n+//!\n+//! - Assignment of `A + B` to `A` might be removed, since the sum can be stored\n+//!   in a temporary location until it gets printed, with the global variable\n+//!   never getting updated.\n+//!\n+//! - The final result could be determined just by looking at the code\n+//!   at compile time, so [constant folding] might turn the whole\n+//!   block into a simple `println!(\"7 4 4\")`.\n+//!\n+//! The compiler is allowed to perform any combination of these\n+//! optimizations, as long as the final optimized code, when executed,\n+//! produces the same results as the one without optimizations.\n+//!\n+//! Due to the [concurrency] involved in modern computers, assumptions\n+//! about the program's execution order are often wrong. Access to\n+//! global variables can lead to nondeterministic results, **even if**\n+//! compiler optimizations are disabled, and it is **still possible**\n+//! to introduce synchronization bugs.\n+//!\n+//! Note that thanks to Rust's safety guarantees, accessing global (static)\n+//! variables requires `unsafe` code, assuming we don't use any of the\n+//! synchronization primitives in this module.\n+//!\n+//! [constant folding]: https://en.wikipedia.org/wiki/Constant_folding\n+//! [concurrency]: https://en.wikipedia.org/wiki/Concurrency_(computer_science)\n+//!\n+//! ## Out-of-order execution\n+//!\n+//! Instructions can execute in a different order from the one we define, due to\n+//! various reasons:\n+//!\n+//! - The **compiler** reordering instructions: If the compiler can issue an\n+//!   instruction at an earlier point, it will try to do so. For example, it\n+//!   might hoist memory loads at the top of a code block, so that the CPU can\n+//!   start [prefetching] the values from memory.\n+//!\n+//!   In single-threaded scenarios, this can cause issues when writing\n+//!   signal handlers or certain kinds of low-level code.\n+//!   Use [compiler fences] to prevent this reordering.\n+//!\n+//! - A **single processor** executing instructions [out-of-order]:\n+//!   Modern CPUs are capable of [superscalar] execution,\n+//!   i.e. multiple instructions might be executing at the same time,\n+//!   even though the machine code describes a sequential process.\n+//!\n+//!   This kind of reordering is handled transparently by the CPU.\n+//!\n+//! - A **multiprocessor** system executing multiple hardware threads\n+//!   at the same time: In multi-threaded scenarios, you can use two\n+//!   kinds of primitives to deal with synchronization:\n+//!   - [memory fences] to ensure memory accesses are made visibile to\n+//!   other CPUs in the right order.\n+//!   - [atomic operations] to ensure simultaneous access to the same\n+//!   memory location doesn't lead to undefined behavior.\n+//!\n+//! [prefetching]: https://en.wikipedia.org/wiki/Cache_prefetching\n+//! [compiler fences]: crate::sync::atomic::compiler_fence\n+//! [out-of-order]: https://en.wikipedia.org/wiki/Out-of-order_execution\n+//! [superscalar]: https://en.wikipedia.org/wiki/Superscalar_processor\n+//! [memory fences]: crate::sync::atomic::fence\n+//! [atomic operations]: crate::sync::atomic\n+//!\n+//! ## Higher-level synchronization objects\n+//!\n+//! Most of the low-level synchronization primitives are quite error-prone and\n+//! inconvenient to use, which is why the standard library also exposes some\n+//! higher-level synchronization objects.\n+//!\n+//! These abstractions can be built out of lower-level primitives.\n+//! For efficiency, the sync objects in the standard library are usually\n+//! implemented with help from the operating system's kernel, which is\n+//! able to reschedule the threads while they are blocked on acquiring\n+//! a lock.\n+//!\n+//! The following is an overview of the available synchronization\n+//! objects:\n+//!\n+//! - [`Arc`]: Atomically Reference-Counted pointer, which can be used\n+//!   in multithreaded environments to prolong the lifetime of some\n+//!   data until all the threads have finished using it.\n+//!\n+//! - [`Barrier`]: Ensures multiple threads will wait for each other\n+//!   to reach a point in the program, before continuing execution all\n+//!   together.\n+//!\n+//! - [`Condvar`]: Condition Variable, providing the ability to block\n+//!   a thread while waiting for an event to occur.\n+//!\n+//! - [`mpsc`]: Multi-producer, single-consumer queues, used for\n+//!   message-based communication. Can provide a lightweight\n+//!   inter-thread synchronisation mechanism, at the cost of some\n+//!   extra memory.\n+//!\n+//! - [`Mutex`]: Mutual Exclusion mechanism, which ensures that at\n+//!   most one thread at a time is able to access some data.\n+//!\n+//! - [`Once`]: Used for thread-safe, one-time initialization of a\n+//!   global variable.\n+//!\n+//! - [`RwLock`]: Provides a mutual exclusion mechanism which allows\n+//!   multiple readers at the same time, while allowing only one\n+//!   writer at a time. In some cases, this can be more efficient than\n+//!   a mutex.\n+//!\n+//! [`Arc`]: crate::sync::Arc\n+//! [`Barrier`]: crate::sync::Barrier\n+//! [`Condvar`]: crate::sync::Condvar\n+//! [`mpsc`]: crate::sync::mpsc\n+//! [`Mutex`]: crate::sync::Mutex\n+//! [`Once`]: crate::sync::Once\n+//! [`RwLock`]: crate::sync::RwLock\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "9e06384f5a804e574124136419bba662902f37ac", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -1001,9 +1001,7 @@ impl<'a> Parser<'a> {\n             AstFragmentKind::ForeignItems => {\n                 let mut items = SmallVec::new();\n                 while self.token != token::Eof {\n-                    if let Some(item) = self.parse_foreign_item()? {\n-                        items.push(item);\n-                    }\n+                    items.push(self.parse_foreign_item()?);\n                 }\n                 AstFragment::ForeignItems(items)\n             }"}, {"sha": "d653ed819fddde9ed1f5549566312940f045f928", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -1777,7 +1777,26 @@ impl<'a> Parser<'a> {\n                    require_name);\n             let pat = self.parse_pat()?;\n \n-            self.expect(&token::Colon)?;\n+            if let Err(mut err) = self.expect(&token::Colon) {\n+                // If we find a pattern followed by an identifier, it could be an (incorrect)\n+                // C-style parameter declaration.\n+                if self.check_ident() && self.look_ahead(1, |t| {\n+                    *t == token::Comma || *t == token::CloseDelim(token::Paren)\n+                }) {\n+                    let ident = self.parse_ident().unwrap();\n+                    let span = pat.span.with_hi(ident.span.hi());\n+\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"declare the type after the parameter binding\",\n+                        String::from(\"<identifier>: <type>\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+\n+                return Err(err);\n+            }\n+\n             (pat, self.parse_ty()?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n@@ -6718,10 +6737,9 @@ impl<'a> Parser<'a> {\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let mut foreign_items = vec![];\n-        while let Some(item) = self.parse_foreign_item()? {\n-            foreign_items.push(item);\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            foreign_items.push(self.parse_foreign_item()?);\n         }\n-        self.expect(&token::CloseDelim(token::Brace))?;\n \n         let prev_span = self.prev_span;\n         let m = ast::ForeignMod {\n@@ -7305,8 +7323,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a foreign item.\n-    crate fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n-        maybe_whole!(self, NtForeignItem, |ni| Some(ni));\n+    crate fn parse_foreign_item(&mut self) -> PResult<'a, ForeignItem> {\n+        maybe_whole!(self, NtForeignItem, |ni| ni);\n \n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span;\n@@ -7326,20 +7344,20 @@ impl<'a> Parser<'a> {\n                     ).emit();\n             }\n             self.bump(); // `static` or `const`\n-            return Ok(Some(self.parse_item_foreign_static(visibility, lo, attrs)?));\n+            return Ok(self.parse_item_foreign_static(visibility, lo, attrs)?);\n         }\n         // FOREIGN FUNCTION ITEM\n         if self.check_keyword(keywords::Fn) {\n-            return Ok(Some(self.parse_item_foreign_fn(visibility, lo, attrs)?));\n+            return Ok(self.parse_item_foreign_fn(visibility, lo, attrs)?);\n         }\n         // FOREIGN TYPE ITEM\n         if self.check_keyword(keywords::Type) {\n-            return Ok(Some(self.parse_item_foreign_type(visibility, lo, attrs)?));\n+            return Ok(self.parse_item_foreign_type(visibility, lo, attrs)?);\n         }\n \n         match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n             Some(mac) => {\n-                Ok(Some(\n+                Ok(\n                     ForeignItem {\n                         ident: keywords::Invalid.ident(),\n                         span: lo.to(self.prev_span),\n@@ -7348,14 +7366,14 @@ impl<'a> Parser<'a> {\n                         vis: visibility,\n                         node: ForeignItemKind::Macro(mac),\n                     }\n-                ))\n+                )\n             }\n             None => {\n-                if !attrs.is_empty() {\n+                if !attrs.is_empty()  {\n                     self.expected_item_err(&attrs);\n                 }\n \n-                Ok(None)\n+                self.unexpected()\n             }\n         }\n     }"}, {"sha": "cc3286fe70512881c31a834e2d0446b54a2d4d40", "filename": "src/test/parse-fail/duplicate-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fparse-fail%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fparse-fail%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fduplicate-visibility.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:expected one of `(`, `fn`, `static`, `type`, or `}` here\n+// error-pattern:expected one of `(`, `fn`, `static`, or `type`\n extern {\n     pub pub fn foo();\n }"}, {"sha": "0d641ec8e891ad150a7b8d85a42291311cc364d9", "filename": "src/test/ui/issues/issue-13058.nll.stderr", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fissues%2Fissue-13058.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fissues%2Fissue-13058.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13058.nll.stderr?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -1,15 +1,12 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-13058.rs:36:11\n+error[E0621]: explicit lifetime required in the type of `cont`\n+  --> $DIR/issue-13058.rs:24:21\n    |\n-LL |     check((3, 5));\n-   |           ^^^^^^\n-   |           |\n-   |           expected reference, found tuple\n-   |           help: consider borrowing here: `&(3, 5)`\n-   |\n-   = note: expected type `&_`\n-              found type `({integer}, {integer})`\n+LL | fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n+   |                                                                     -- help: add explicit lifetime `'r` to the type of `cont`: `&'r T`\n+LL | {\n+LL |     let cont_iter = cont.iter();\n+   |                     ^^^^^^^^^^^ lifetime `'r` required\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "cabf02194776a1bde47e6575df8be52be5d774d4", "filename": "src/test/ui/issues/issue-13058.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fissues%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fissues%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13058.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -33,6 +33,5 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n }\n \n fn main() {\n-    check((3, 5));\n-//~^ ERROR mismatched types\n+    check(&(3, 5));\n }"}, {"sha": "ee39678736cddaeed08d61593e9355206735d818", "filename": "src/test/ui/issues/issue-13058.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fissues%2Fissue-13058.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fissues%2Fissue-13058.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13058.stderr?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -7,19 +7,6 @@ LL | {\n LL |     let cont_iter = cont.iter();\n    |                          ^^^^ lifetime `'r` required\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-13058.rs:36:11\n-   |\n-LL |     check((3, 5));\n-   |           ^^^^^^\n-   |           |\n-   |           expected reference, found tuple\n-   |           help: consider borrowing here: `&(3, 5)`\n-   |\n-   = note: expected type `&_`\n-              found type `({integer}, {integer})`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0308, E0621.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "b45aedb549ecd66d6a5e77437d67e2b2f89d86a9", "filename": "src/test/ui/macros/issue-54441.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -0,0 +1,13 @@\n+#![feature(macros_in_extern)]\n+\n+macro_rules! m {\n+    () => {\n+        let //~ ERROR expected\n+    };\n+}\n+\n+extern \"C\" {\n+    m!();\n+}\n+\n+fn main() {}"}, {"sha": "aa1edb2cf893fdd26ed2b99911ad8a5caf95c594", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -0,0 +1,14 @@\n+error: expected one of `crate`, `fn`, `pub`, `static`, or `type`, found `let`\n+  --> $DIR/issue-54441.rs:5:9\n+   |\n+LL | #![feature(macros_in_extern)]\n+   | - expected one of `crate`, `fn`, `pub`, `static`, or `type` here\n+...\n+LL |         let //~ ERROR expected\n+   |         ^^^ unexpected token\n+...\n+LL |     m!();\n+   |     ----- in this macro invocation\n+\n+error: aborting due to previous error\n+"}, {"sha": "419d580419f42270217c2f633ea4dbba70b9ee33", "filename": "src/test/ui/mut/no-mut-lint-for-desugared-mut.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fmut%2Fno-mut-lint-for-desugared-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fmut%2Fno-mut-lint-for-desugared-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmut%2Fno-mut-lint-for-desugared-mut.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+\n+#![deny(unused_mut)]\n+#![allow(unreachable_code)]\n+\n+fn main() {\n+    for _ in { return (); 0..3 } {} // ok\n+}"}, {"sha": "a114d7092ecf97a39010fea0427eb2e7e998e3d3", "filename": "src/test/ui/nll/issue-32382-index-assoc-type-with-lifetime.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fnll%2Fissue-32382-index-assoc-type-with-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fnll%2Fissue-32382-index-assoc-type-with-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-32382-index-assoc-type-with-lifetime.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -0,0 +1,42 @@\n+#![feature(nll)]\n+// compile-pass\n+\n+// rust-lang/rust#32382: Borrow checker used to complain about\n+// `foobar_3` in the `impl` below, presumably due to some interaction\n+// between the use of a lifetime in the associated type and the use of\n+// the overloaded operator[]. This regression test ensures that we do\n+// not resume complaining about it in the future.\n+\n+\n+use std::marker::PhantomData;\n+use std::ops::Index;\n+\n+pub trait Context: Clone {\n+    type Container: ?Sized;\n+    fn foobar_1( container: &Self::Container ) -> &str;\n+    fn foobar_2( container: &Self::Container ) -> &str;\n+    fn foobar_3( container: &Self::Container ) -> &str;\n+}\n+\n+#[derive(Clone)]\n+struct Foobar<'a> {\n+    phantom: PhantomData<&'a ()>\n+}\n+\n+impl<'a> Context for Foobar<'a> {\n+    type Container = [&'a str];\n+\n+    fn foobar_1<'r>( container: &'r [&'a str] ) -> &'r str {\n+        container[0]\n+    }\n+\n+    fn foobar_2<'r>( container: &'r Self::Container ) -> &'r str {\n+        container.index( 0 )\n+    }\n+\n+    fn foobar_3<'r>( container: &'r Self::Container ) -> &'r str {\n+        container[0]\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "a100debbf1242a898e2487ec3f3cb54eb7e15681", "filename": "src/test/ui/parser/inverted-parameters.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.rs?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    fn foo(&self, &str bar) {}\n+    //~^ ERROR expected one of `:` or `@`\n+    //~| HELP declare the type after the parameter binding\n+    //~| SUGGESTION <identifier>: <type>\n+}\n+\n+fn baz(S quux, xyzzy: i32) {}\n+//~^ ERROR expected one of `:` or `@`\n+//~| HELP declare the type after the parameter binding\n+//~| SUGGESTION <identifier>: <type>\n+\n+fn one(i32 a b) {}\n+//~^ ERROR expected one of `:` or `@`\n+\n+fn pattern((i32, i32) (a, b)) {}\n+//~^ ERROR expected `:`\n+\n+fn fizz(i32) {}\n+//~^ ERROR expected one of `:` or `@`\n+\n+fn missing_colon(quux S) {}\n+//~^ ERROR expected one of `:` or `@`\n+//~| HELP declare the type after the parameter binding\n+//~| SUGGESTION <identifier>: <type>\n+\n+fn main() {}"}, {"sha": "3f4f0615bc8f78425d3e8aa4fab6309536c04f5f", "filename": "src/test/ui/parser/inverted-parameters.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac841e74502183cde08e462d98cc55752abd000a/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.stderr?ref=ac841e74502183cde08e462d98cc55752abd000a", "patch": "@@ -0,0 +1,47 @@\n+error: expected one of `:` or `@`, found `bar`\n+  --> $DIR/inverted-parameters.rs:14:24\n+   |\n+LL |     fn foo(&self, &str bar) {}\n+   |                   -----^^^\n+   |                   |    |\n+   |                   |    expected one of `:` or `@` here\n+   |                   help: declare the type after the parameter binding: `<identifier>: <type>`\n+\n+error: expected one of `:` or `@`, found `quux`\n+  --> $DIR/inverted-parameters.rs:20:10\n+   |\n+LL | fn baz(S quux, xyzzy: i32) {}\n+   |        --^^^^\n+   |        | |\n+   |        | expected one of `:` or `@` here\n+   |        help: declare the type after the parameter binding: `<identifier>: <type>`\n+\n+error: expected one of `:` or `@`, found `a`\n+  --> $DIR/inverted-parameters.rs:25:12\n+   |\n+LL | fn one(i32 a b) {}\n+   |            ^ expected one of `:` or `@` here\n+\n+error: expected `:`, found `(`\n+  --> $DIR/inverted-parameters.rs:28:23\n+   |\n+LL | fn pattern((i32, i32) (a, b)) {}\n+   |                       ^ expected `:`\n+\n+error: expected one of `:` or `@`, found `)`\n+  --> $DIR/inverted-parameters.rs:31:12\n+   |\n+LL | fn fizz(i32) {}\n+   |            ^ expected one of `:` or `@` here\n+\n+error: expected one of `:` or `@`, found `S`\n+  --> $DIR/inverted-parameters.rs:34:23\n+   |\n+LL | fn missing_colon(quux S) {}\n+   |                  -----^\n+   |                  |    |\n+   |                  |    expected one of `:` or `@` here\n+   |                  help: declare the type after the parameter binding: `<identifier>: <type>`\n+\n+error: aborting due to 6 previous errors\n+"}]}