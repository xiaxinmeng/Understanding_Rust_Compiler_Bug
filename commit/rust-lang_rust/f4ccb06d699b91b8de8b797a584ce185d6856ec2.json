{"sha": "f4ccb06d699b91b8de8b797a584ce185d6856ec2", "node_id": "C_kwDOAAsO6NoAKGY0Y2NiMDZkNjk5YjkxYjhkZThiNzk3YTU4NGNlMTg1ZDY4NTZlYzI", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2023-03-13T12:17:30Z"}, "committer": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2023-03-13T12:17:30Z"}, "message": "extract `is_interior_mutable_type` from [`mut_key`] to `clippy_utils::ty`;\n\nfix configuration of [`ifs_same_cond`];\n\nadd some style improvement for [`ifs_same_cond`];", "tree": {"sha": "4fbba25e81ea99665e09ef4dcecd08f6c1d62d34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fbba25e81ea99665e09ef4dcecd08f6c1d62d34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4ccb06d699b91b8de8b797a584ce185d6856ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ccb06d699b91b8de8b797a584ce185d6856ec2", "html_url": "https://github.com/rust-lang/rust/commit/f4ccb06d699b91b8de8b797a584ce185d6856ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4ccb06d699b91b8de8b797a584ce185d6856ec2/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ae2b71ca4053db3b86c20e7d612ecc11d50ee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ae2b71ca4053db3b86c20e7d612ecc11d50ee2", "html_url": "https://github.com/rust-lang/rust/commit/f0ae2b71ca4053db3b86c20e7d612ecc11d50ee2"}], "stats": {"total": 193, "additions": 107, "deletions": 86}, "files": [{"sha": "970f50049935ce1919804db5b7c3ad2d5c6aabc3", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -1,16 +1,15 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n-use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::ty::{is_interior_mut_ty, needs_ordered_drop};\n use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{\n     capture_local_usage, def_path_def_ids, eq_expr_value, find_binding_init, get_enclosing_block, hash_expr, hash_stmt,\n     if_sequence, is_else_clause, is_lint_allowed, path_to_local, search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n };\n use core::iter;\n use core::ops::ControlFlow;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_hir::intravisit;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, HirIdSet, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -164,12 +163,14 @@ declare_clippy_lint! {\n \n pub struct CopyAndPaste {\n     ignore_interior_mutability: Vec<String>,\n+    ignored_ty_ids: DefIdSet,\n }\n \n impl CopyAndPaste {\n     pub fn new(ignore_interior_mutability: Vec<String>) -> Self {\n         Self {\n             ignore_interior_mutability,\n+            ignored_ty_ids: DefIdSet::new(),\n         }\n     }\n }\n@@ -182,17 +183,18 @@ impl_lint_pass!(CopyAndPaste => [\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>) {\n+        for ignored_ty in &self.ignore_interior_mutability {\n+            let path: Vec<&str> = ignored_ty.split(\"::\").collect();\n+            for id in def_path_def_ids(cx, path.as_slice()) {\n+                self.ignored_ty_ids.insert(id);\n+            }\n+        }\n+    }\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if !expr.span.from_expansion() && matches!(expr.kind, ExprKind::If(..)) && !is_else_clause(cx.tcx, expr) {\n             let (conds, blocks) = if_sequence(expr);\n-            let mut ignored_ty_ids = FxHashSet::default();\n-            for ignored_ty in &self.ignore_interior_mutability {\n-                let path: Vec<&str> = ignored_ty.split(\"::\").collect();\n-                for id in def_path_def_ids(cx, path.as_slice()) {\n-                    ignored_ty_ids.insert(id);\n-                }\n-            }\n-            lint_same_cond(cx, &conds, &ignored_ty_ids);\n+            lint_same_cond(cx, &conds, &self.ignored_ty_ids);\n             lint_same_fns_in_if_cond(cx, &conds);\n             let all_same =\n                 !is_lint_allowed(cx, IF_SAME_THEN_ELSE, expr.hir_id) && lint_if_same_then_else(cx, &conds, &blocks);\n@@ -569,38 +571,30 @@ fn check_for_warn_of_moved_symbol(cx: &LateContext<'_>, symbols: &[(HirId, Symbo\n     })\n }\n \n-fn method_caller_is_ignored_or_mutable(\n-    cx: &LateContext<'_>,\n-    caller_expr: &Expr<'_>,\n-    ignored_ty_ids: &FxHashSet<DefId>,\n-) -> bool {\n+fn method_caller_is_mutable(cx: &LateContext<'_>, caller_expr: &Expr<'_>, ignored_ty_ids: &DefIdSet) -> bool {\n     let caller_ty = cx.typeck_results().expr_ty(caller_expr);\n-    let is_ignored_ty = if let Some(adt_id) = caller_ty.ty_adt_id() && ignored_ty_ids.contains(&adt_id) {\n-        true\n-    } else {\n-        false\n-    };\n+    // Check if given type has inner mutability and was not set to ignored by the configuration\n+    let is_inner_mut_ty = is_interior_mut_ty(cx, caller_ty)\n+        && !matches!(caller_ty.ty_adt_id(), Some(adt_id) if ignored_ty_ids.contains(&adt_id));\n \n-    if is_ignored_ty\n+    is_inner_mut_ty\n         || caller_ty.is_mutable_ptr()\n+        // `find_binding_init` will return the binding iff its not mutable\n         || path_to_local(caller_expr)\n             .and_then(|hid| find_binding_init(cx, hid))\n             .is_none()\n-    {\n-        return true;\n-    }\n-\n-    false\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>], ignored_ty_ids: &FxHashSet<DefId>) {\n+fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>], ignored_ty_ids: &DefIdSet) {\n     for (i, j) in search_same(\n         conds,\n         |e| hash_expr(cx, e),\n         |lhs, rhs| {\n+            // Ignore eq_expr side effects iff one of the expressin kind is a method call\n+            // and the caller is not a mutable, including inner mutable type.\n             if let ExprKind::MethodCall(_, caller, _, _) = lhs.kind {\n-                if method_caller_is_ignored_or_mutable(cx, caller, ignored_ty_ids) {\n+                if method_caller_is_mutable(cx, caller, ignored_ty_ids) {\n                     false\n                 } else {\n                     SpanlessEq::new(cx).eq_expr(lhs, rhs)"}, {"sha": "309f67521a3b4f0323ee3c2f48e45ecfab0dfee1", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_interior_mut_ty;\n use clippy_utils::{def_path_def_ids, trait_ref_of_method};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeVisitableExt;\n-use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n+use rustc_middle::query::Key;\n+use rustc_middle::ty::{Adt, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -153,53 +154,18 @@ impl MutableKeyType {\n             let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n                 .iter()\n                 .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-            if is_keyed_type && self.is_interior_mutable_type(cx, substs.type_at(0)) {\n-                span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n+            if !is_keyed_type {\n+                return;\n             }\n-        }\n-    }\n \n-    /// Determines if a type contains interior mutability which would affect its implementation of\n-    /// [`Hash`] or [`Ord`].\n-    fn is_interior_mutable_type<'tcx>(&self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        match *ty.kind() {\n-            Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || self.is_interior_mutable_type(cx, inner_ty),\n-            Slice(inner_ty) => self.is_interior_mutable_type(cx, inner_ty),\n-            Array(inner_ty, size) => {\n-                size.try_eval_target_usize(cx.tcx, cx.param_env)\n-                    .map_or(true, |u| u != 0)\n-                    && self.is_interior_mutable_type(cx, inner_ty)\n-            },\n-            Tuple(fields) => fields.iter().any(|ty| self.is_interior_mutable_type(cx, ty)),\n-            Adt(def, substs) => {\n-                // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n-                // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n-                // because they have no impl for `Hash` or `Ord`.\n-                let def_id = def.did();\n-                let is_std_collection = [\n-                    sym::Option,\n-                    sym::Result,\n-                    sym::LinkedList,\n-                    sym::Vec,\n-                    sym::VecDeque,\n-                    sym::BTreeMap,\n-                    sym::BTreeSet,\n-                    sym::Rc,\n-                    sym::Arc,\n-                ]\n-                .iter()\n-                .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def_id));\n-                let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n-                if is_std_collection || is_box || self.ignore_mut_def_ids.contains(&def_id) {\n-                    // The type is mutable if any of its type parameters are\n-                    substs.types().any(|ty| self.is_interior_mutable_type(cx, ty))\n-                } else {\n-                    !ty.has_escaping_bound_vars()\n-                        && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                        && !ty.is_freeze(cx.tcx, cx.param_env)\n-                }\n-            },\n-            _ => false,\n+            let subst_ty = substs.type_at(0);\n+            // Determines if a type contains interior mutability which would affect its implementation of\n+            // [`Hash`] or [`Ord`].\n+            if is_interior_mut_ty(cx, subst_ty)\n+                && !matches!(subst_ty.ty_adt_id(), Some(adt_id) if self.ignore_mut_def_ids.contains(&adt_id))\n+            {\n+                span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n+            }\n         }\n     }\n }"}, {"sha": "f1c6f1dddd8a5d57f0627826cf495bdec23bc801", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -1121,3 +1121,47 @@ pub fn make_normalized_projection<'tcx>(\n     }\n     helper(tcx, param_env, make_projection(tcx, container_id, assoc_ty, substs)?)\n }\n+\n+/// Check if given type has inner mutability such as [`std::cell::Cell`] or [`std::cell::RefCell`]\n+/// etc.\n+pub fn is_interior_mut_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match *ty.kind() {\n+        ty::Ref(_, inner_ty, mutbl) => mutbl == Mutability::Mut || is_interior_mut_ty(cx, inner_ty),\n+        ty::Slice(inner_ty) => is_interior_mut_ty(cx, inner_ty),\n+        ty::Array(inner_ty, size) => {\n+            size.try_eval_target_usize(cx.tcx, cx.param_env)\n+                .map_or(true, |u| u != 0)\n+                && is_interior_mut_ty(cx, inner_ty)\n+        },\n+        ty::Tuple(fields) => fields.iter().any(|ty| is_interior_mut_ty(cx, ty)),\n+        ty::Adt(def, substs) => {\n+            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+            // because they have no impl for `Hash` or `Ord`.\n+            let def_id = def.did();\n+            let is_std_collection = [\n+                sym::Option,\n+                sym::Result,\n+                sym::LinkedList,\n+                sym::Vec,\n+                sym::VecDeque,\n+                sym::BTreeMap,\n+                sym::BTreeSet,\n+                sym::Rc,\n+                sym::Arc,\n+            ]\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def_id));\n+            let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n+            if is_std_collection || is_box {\n+                // The type is mutable if any of its type parameters are\n+                substs.types().any(|ty| is_interior_mut_ty(cx, ty))\n+            } else {\n+                !ty.has_escaping_bound_vars()\n+                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                    && !ty.is_freeze(cx.tcx, cx.param_env)\n+            }\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "90a36ecd92022c69911f71162a5036ffc11c0492", "filename": "tests/ui-toml/ifs_same_cond/clippy.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui-toml%2Fifs_same_cond%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui-toml%2Fifs_same_cond%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fifs_same_cond%2Fclippy.toml?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -1 +1 @@\n-ignore-interior-mutability = [\"std::cell::Cell\"]\n\\ No newline at end of file\n+ignore-interior-mutability = [\"std::cell::Cell\"]"}, {"sha": "d623ac7e0200820de7ee1d5e62d02d91efaba023", "filename": "tests/ui-toml/ifs_same_cond/ifs_same_cond.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.rs?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -6,19 +6,13 @@ fn main() {}\n fn issue10272() {\n     use std::cell::Cell;\n \n+    // Because the `ignore-interior-mutability` configuration\n+    // is set to ignore for `std::cell::Cell`, the following `get()` calls\n+    // should trigger warning\n     let x = Cell::new(true);\n     if x.get() {\n     } else if !x.take() {\n     } else if x.get() {\n-        // ok, x is interior mutable type\n-    } else {\n-    }\n-\n-    let a = [Cell::new(true)];\n-    if a[0].get() {\n-    } else if a[0].take() {\n-    } else if a[0].get() {\n-        // ok, a contains interior mutable type\n     } else {\n     }\n }"}, {"sha": "2841f62bc94ab1e10914223a7d7bfdf0533c4b17", "filename": "tests/ui-toml/ifs_same_cond/ifs_same_cond.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.stderr?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -0,0 +1,15 @@\n+error: this `if` has the same condition as a previous `if`\n+  --> $DIR/ifs_same_cond.rs:15:15\n+   |\n+LL |     } else if x.get() {\n+   |               ^^^^^^^\n+   |\n+note: same as this\n+  --> $DIR/ifs_same_cond.rs:13:8\n+   |\n+LL |     if x.get() {\n+   |        ^^^^^^^\n+   = note: `-D clippy::ifs-same-cond` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "9ce9a87626a79f4cfaa0610a92f03a1472c5815f", "filename": "tests/ui/ifs_same_cond.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui%2Fifs_same_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ccb06d699b91b8de8b797a584ce185d6856ec2/tests%2Fui%2Fifs_same_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fifs_same_cond.rs?ref=f4ccb06d699b91b8de8b797a584ce185d6856ec2", "patch": "@@ -59,6 +59,14 @@ fn issue10272() {\n         // ok, p is mutable pointer\n     } else {\n     }\n+\n+    let x = std::cell::Cell::new(true);\n+    if x.get() {\n+    } else if !x.take() {\n+    } else if x.get() {\n+        // ok, x is interior mutable type\n+    } else {\n+    }\n }\n \n fn main() {}"}]}