{"sha": "f01a9a8d02f6c09b89a3cecadaa5b62073381180", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMWE5YThkMDJmNmMwOWI4OWEzY2VjYWRhYTViNjIwNzMzODExODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-27T22:56:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-27T22:56:56Z"}, "message": "auto merge of #12584 : alexcrichton/rust/windows-files, r=brson\n\nThese commits fix handling of binary files on windows by using the raw `CreateFile` apis directly, also splitting out the windows/unix implementations to their own files because everything was configured between the two platforms.\r\n\r\nWith this fix in place, this also switches `rustc` to using libnative instead of libgreen. I have confirmed that this PR passes through try on all bots.", "tree": {"sha": "6d325f9b3110f829319de6c3eeecafbea4b8d5bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d325f9b3110f829319de6c3eeecafbea4b8d5bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f01a9a8d02f6c09b89a3cecadaa5b62073381180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f01a9a8d02f6c09b89a3cecadaa5b62073381180", "html_url": "https://github.com/rust-lang/rust/commit/f01a9a8d02f6c09b89a3cecadaa5b62073381180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f01a9a8d02f6c09b89a3cecadaa5b62073381180/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68a92c5ed58e676d6aa224681080f921b9e069a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a92c5ed58e676d6aa224681080f921b9e069a5", "html_url": "https://github.com/rust-lang/rust/commit/68a92c5ed58e676d6aa224681080f921b9e069a5"}, {"sha": "8c157ed63d95b4b4ff122493228eb0b5acf1e2ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c157ed63d95b4b4ff122493228eb0b5acf1e2ae", "html_url": "https://github.com/rust-lang/rust/commit/8c157ed63d95b4b4ff122493228eb0b5acf1e2ae"}], "stats": {"total": 2525, "additions": 1346, "deletions": 1179}, "files": [{"sha": "45b6ed1a058d0c748266af3359aa545b3ad857aa", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -81,8 +81,8 @@ DEPS_test := std extra collections getopts serialize term\n DEPS_time := std serialize\n \n TOOL_DEPS_compiletest := test green rustuv getopts\n-TOOL_DEPS_rustdoc := rustdoc green rustuv\n-TOOL_DEPS_rustc := rustc green rustuv\n+TOOL_DEPS_rustdoc := rustdoc native\n+TOOL_DEPS_rustc := rustc native\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs"}, {"sha": "0ceb12064b0eba316519db707dc9ab387cacee7d", "filename": "src/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -8,10 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[no_uv];\n+\n #[cfg(rustdoc)]\n extern crate this = \"rustdoc\";\n \n #[cfg(rustc)]\n extern crate this = \"rustc\";\n \n-fn main() { this::main() }\n+extern crate native;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, this::main) }"}, {"sha": "27430ddee97eb7b3e8102dd108e88594b4c6ef20", "filename": "src/libnative/io/file.rs", "status": "removed", "additions": 0, "deletions": 995, "changes": 995, "blob_url": "https://github.com/rust-lang/rust/blob/68a92c5ed58e676d6aa224681080f921b9e069a5/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a92c5ed58e676d6aa224681080f921b9e069a5/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=68a92c5ed58e676d6aa224681080f921b9e069a5", "patch": "@@ -1,995 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Blocking posix-based file I/O\n-\n-#[allow(non_camel_case_types)];\n-\n-use std::sync::arc::UnsafeArc;\n-use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n-use std::libc::{c_int, c_void};\n-use std::libc;\n-use std::mem;\n-use std::os;\n-use std::rt::rtio;\n-use std::vec;\n-\n-use io::{IoResult, retry};\n-\n-#[cfg(windows)] use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-#[cfg(windows)] use std::ptr;\n-#[cfg(windows)] use std::str;\n-\n-pub fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n-    #[cfg(windows)] static eintr: int = 0; // doesn't matter\n-    #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n-\n-    let origamt = data.len();\n-    let mut data = data.as_ptr();\n-    let mut amt = origamt;\n-    while amt > 0 {\n-        let mut ret;\n-        loop {\n-            ret = f(data, amt);\n-            if cfg!(windows) { break } // windows has no eintr\n-            // if we get an eintr, then try again\n-            if ret != -1 || os::errno() as int != eintr { break }\n-        }\n-        if ret == 0 {\n-            break\n-        } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n-        } else {\n-            return ret;\n-        }\n-    }\n-    return (origamt - amt) as i64;\n-}\n-\n-pub type fd_t = libc::c_int;\n-\n-struct Inner {\n-    fd: fd_t,\n-    close_on_drop: bool,\n-}\n-\n-pub struct FileDesc {\n-    priv inner: UnsafeArc<Inner>\n-}\n-\n-impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n-    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { inner: UnsafeArc::new(Inner {\n-            fd: fd,\n-            close_on_drop: close_on_drop\n-        }) }\n-    }\n-\n-    // FIXME(#10465) these functions should not be public, but anything in\n-    //               native::io wanting to use them is forced to have all the\n-    //               rtio traits in scope\n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        #[cfg(windows)] type rlen = libc::c_uint;\n-        #[cfg(not(windows))] type rlen = libc::size_t;\n-        let ret = retry(|| unsafe {\n-            libc::read(self.fd(),\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as rlen) as libc::c_int\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        #[cfg(windows)] type wlen = libc::c_uint;\n-        #[cfg(not(windows))] type wlen = libc::size_t;\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::write(self.fd(), buf as *libc::c_void, len as wlen) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn fd(&self) -> fd_t {\n-        // This unsafety is fine because we're just reading off the file\n-        // descriptor, no one is modifying this.\n-        unsafe { (*self.inner.get()).fd }\n-    }\n-}\n-\n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        return os_pread(self.fd(), buf.as_ptr(), buf.len(), offset);\n-\n-        #[cfg(windows)]\n-        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            unsafe {\n-                let mut overlap: libc::OVERLAPPED = mem::init();\n-                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n-                let mut bytes_read = 0;\n-                overlap.Offset = offset as libc::DWORD;\n-                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-\n-                match libc::ReadFile(handle, buf as libc::LPVOID,\n-                                   amt as libc::DWORD,\n-                                   &mut bytes_read, &mut overlap) {\n-                    0 => Err(super::last_error()),\n-                    _ => Ok(bytes_read as int)\n-                }\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            match retry(|| unsafe {\n-                libc::pread(fd, buf as *libc::c_void, amt as libc::size_t,\n-                            offset as libc::off_t) as libc::c_int\n-            }) {\n-                -1 => Err(super::last_error()),\n-                n => Ok(n as int)\n-            }\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        return os_pwrite(self.fd(), buf.as_ptr(), buf.len(), offset);\n-\n-        #[cfg(windows)]\n-        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            unsafe {\n-                let mut overlap: libc::OVERLAPPED = mem::init();\n-                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n-                overlap.Offset = offset as libc::DWORD;\n-                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-\n-                match libc::WriteFile(handle, buf as libc::LPVOID,\n-                                      amt as libc::DWORD,\n-                                      ptr::mut_null(), &mut overlap) {\n-                    0 => Err(super::last_error()),\n-                    _ => Ok(()),\n-                }\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            super::mkerr_libc(retry(|| unsafe {\n-                libc::pwrite(fd, buf as *libc::c_void, amt as libc::size_t,\n-                             offset as libc::off_t)\n-            } as c_int))\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match style {\n-            io::SeekSet => libc::FILE_BEGIN,\n-            io::SeekEnd => libc::FILE_END,\n-            io::SeekCur => libc::FILE_CURRENT,\n-        };\n-        unsafe {\n-            let handle = libc::get_osfhandle(self.fd()) as libc::HANDLE;\n-            let mut newpos = 0;\n-            match libc::SetFilePointerEx(handle, pos, &mut newpos, whence) {\n-                0 => Err(super::last_error()),\n-                _ => Ok(newpos as u64),\n-            }\n-        }\n-    }\n-    #[cfg(unix)]\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match whence {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        return os_fsync(self.fd());\n-\n-        #[cfg(windows)]\n-        fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_winbool(unsafe {\n-                let handle = libc::get_osfhandle(fd);\n-                libc::FlushFileBuffers(handle as libc::HANDLE)\n-            })\n-        }\n-        #[cfg(unix)]\n-        fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_libc(retry(|| unsafe { libc::fsync(fd) }))\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n-\n-    #[cfg(not(windows))]\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        return super::mkerr_libc(os_datasync(self.fd()));\n-\n-        #[cfg(target_os = \"macos\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fdatasync(fd) })\n-        }\n-        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fsync(fd) })\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        let orig_pos = match self.tell() { Ok(i) => i, Err(e) => return Err(e) };\n-        match self.seek(offset, io::SeekSet) {\n-            Ok(_) => {}, Err(e) => return Err(e),\n-        };\n-        let ret = unsafe {\n-            let handle = libc::get_osfhandle(self.fd()) as libc::HANDLE;\n-            match libc::SetEndOfFile(handle) {\n-                0 => Err(super::last_error()),\n-                _ => Ok(())\n-            }\n-        };\n-        let _ = self.seek(orig_pos as i64, io::SeekSet);\n-        return ret;\n-    }\n-    #[cfg(unix)]\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::ftruncate(self.fd(), offset as libc::off_t)\n-        }))\n-    }\n-}\n-\n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn clone(&self) -> ~rtio::RtioPipe {\n-        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n-    }\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            let n = unsafe { libc::close(self.fd) };\n-            if n != 0 {\n-                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n-            }\n-        }\n-    }\n-}\n-\n-pub struct CFile {\n-    priv file: *libc::FILE,\n-    priv fd: FileDesc,\n-}\n-\n-impl CFile {\n-    /// Create a `CFile` from an open `FILE` pointer.\n-    ///\n-    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n-    /// destruction.\n-    pub fn new(file: *libc::FILE) -> CFile {\n-        CFile {\n-            file: file,\n-            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n-        }\n-    }\n-\n-    pub fn flush(&mut self) -> Result<(), IoError> {\n-        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n-    }\n-}\n-\n-impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as int)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        self.flush().and_then(|()| self.fd.pread(buf, offset))\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n-    }\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match style {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        let ret = unsafe { libc::ftell(self.file) };\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.fsync())\n-    }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.fsync())\n-    }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.truncate(offset))\n-    }\n-}\n-\n-impl Drop for CFile {\n-    fn drop(&mut self) {\n-        unsafe { let _ = libc::fclose(self.file); }\n-    }\n-}\n-\n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<FileDesc> {\n-    let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n-    };\n-    // Opening with a write permission must silently create the file.\n-    let (flags, mode) = match fa {\n-        io::Read => (flags | libc::O_RDONLY, 0),\n-        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                      libc::S_IRUSR | libc::S_IWUSR),\n-        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n-    };\n-\n-    return match os_open(path, flags, mode) {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(FileDesc::new(fd, true)),\n-    };\n-\n-    #[cfg(windows)]\n-    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        as_utf16_p(path.as_str().unwrap(), |path| {\n-            retry(|| unsafe { libc::wopen(path, flags, mode) })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) })\n-    }\n-}\n-\n-pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n-    return os_mkdir(p, mode as c_int);\n-\n-    #[cfg(windows)]\n-    fn os_mkdir(p: &CString, _mode: c_int) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            // FIXME: turn mode into something useful? #2623\n-            as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::CreateDirectoryW(buf, ptr::mut_null())\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_mkdir(p: &CString, mode: c_int) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n-        }))\n-    }\n-}\n-\n-pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n-    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n-        let root = Path::new(root);\n-\n-        dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }).map(|path| root.join(path)).collect()\n-    }\n-\n-    unsafe {\n-        #[cfg(not(windows))]\n-        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use std::libc::{dirent_t};\n-            use std::libc::{opendir, readdir, closedir};\n-            extern {\n-                fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n-            }\n-            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-\n-            let dir_ptr = p.with_ref(|buf| opendir(buf));\n-\n-            if dir_ptr as uint != 0 {\n-                let mut paths = ~[];\n-                debug!(\"os::list_dir -- opendir() SUCCESS\");\n-                let mut entry_ptr = readdir(dir_ptr);\n-                while entry_ptr as uint != 0 {\n-                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(Path::new(cstr));\n-                    entry_ptr = readdir(dir_ptr);\n-                }\n-                assert_eq!(closedir(dir_ptr), 0);\n-                Ok(paths)\n-            } else {\n-                Err(super::last_error())\n-            }\n-        }\n-\n-        #[cfg(windows)]\n-        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use std::libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use std::libc::{wcslen, free};\n-            use std::libc::funcs::extra::kernel32::{\n-                FindFirstFileW,\n-                FindNextFileW,\n-                FindClose,\n-            };\n-            use std::libc::types::os::arch::extra::HANDLE;\n-            use os::win32::{\n-                as_utf16_p\n-            };\n-            use rt::global_heap::malloc_raw;\n-\n-            #[nolink]\n-            extern {\n-                fn rust_list_dir_wfd_size() -> libc::size_t;\n-                fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n-            }\n-            let p = CString::new(p.with_ref(|p| p), false);\n-            let p = Path::new(p);\n-            let star = p.join(\"*\");\n-            as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n-                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n-                    let mut paths = ~[];\n-                    let mut more_files = 1 as libc::c_int;\n-                    while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n-                        if fp_buf as uint == 0 {\n-                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n-                        }\n-                        else {\n-                            let fp_vec = vec::from_buf(\n-                                fp_buf, wcslen(fp_buf) as uint);\n-                            let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n-                            let fp_str = str::from_utf16(fp_trimmed)\n-                                    .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n-                            paths.push(Path::new(fp_str));\n-                        }\n-                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n-                    }\n-                    assert!(FindClose(find_handle) != 0);\n-                    free(wfd_ptr as *mut c_void);\n-                    Ok(paths)\n-                } else {\n-                    Err(super::last_error())\n-                }\n-            })\n-        }\n-\n-        get_list(p).map(|paths| prune(p, paths))\n-    }\n-}\n-\n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    return os_unlink(p);\n-\n-    #[cfg(windows)]\n-    fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::DeleteFileW(buf)\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n-    }\n-}\n-\n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n-    return os_rename(old, new);\n-\n-    #[cfg(windows)]\n-    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            as_utf16_p(old.as_str().unwrap(), |old| {\n-                as_utf16_p(new.as_str().unwrap(), |new| {\n-                    libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-                })\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n-        }))\n-    }\n-}\n-\n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n-    return super::mkerr_libc(os_chmod(p, mode as c_int));\n-\n-    #[cfg(windows)]\n-    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n-                libc::wchmod(p, mode)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        retry(||unsafe { libc::chmod(p.with_ref(|p| p), mode as libc::mode_t) })\n-    }\n-}\n-\n-pub fn rmdir(p: &CString) -> IoResult<()> {\n-    return super::mkerr_libc(os_rmdir(p));\n-\n-    #[cfg(windows)]\n-    fn os_rmdir(p: &CString) -> c_int {\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n-                libc::wrmdir(p)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_rmdir(p: &CString) -> c_int {\n-        retry(|| unsafe { libc::rmdir(p.with_ref(|p| p)) })\n-    }\n-}\n-\n-pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n-    return super::mkerr_libc(os_chown(p, uid, gid));\n-\n-    // libuv has this as a no-op, so seems like this should as well?\n-    #[cfg(windows)]\n-    fn os_chown(_p: &CString, _uid: int, _gid: int) -> c_int { 0 }\n-\n-    #[cfg(unix)]\n-    fn os_chown(p: &CString, uid: int, gid: int) -> c_int {\n-        retry(|| unsafe {\n-            libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n-                        gid as libc::gid_t)\n-        })\n-    }\n-}\n-\n-pub fn readlink(p: &CString) -> IoResult<Path> {\n-    return os_readlink(p);\n-\n-    // FIXME: I have a feeling that this reads intermediate symlinks as well.\n-    #[cfg(windows)]\n-    fn os_readlink(p: &CString) -> IoResult<Path> {\n-        let handle = unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| {\n-                libc::CreateFileW(p,\n-                                  libc::GENERIC_READ,\n-                                  libc::FILE_SHARE_READ,\n-                                  ptr::mut_null(),\n-                                  libc::OPEN_EXISTING,\n-                                  libc::FILE_ATTRIBUTE_NORMAL,\n-                                  ptr::mut_null())\n-            })\n-        };\n-        if handle as int == libc::INVALID_HANDLE_VALUE as int {\n-            return Err(super::last_error())\n-        }\n-        let ret = fill_utf16_buf_and_decode(|buf, sz| {\n-            unsafe {\n-                libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n-                                                libc::VOLUME_NAME_NT)\n-            }\n-        });\n-        let ret = match ret {\n-            Some(s) => Ok(Path::new(s)),\n-            None => Err(super::last_error()),\n-        };\n-        assert!(unsafe { libc::CloseHandle(handle) } != 0);\n-        return ret;\n-\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_readlink(p: &CString) -> IoResult<Path> {\n-        let p = p.with_ref(|p| p);\n-        let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n-        if len == -1 {\n-            len = 1024; // FIXME: read PATH_MAX from C ffi?\n-        }\n-        let mut buf = vec::with_capacity::<u8>(len as uint);\n-        match retry(|| unsafe {\n-            libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n-                           len as libc::size_t) as libc::c_int\n-        }) {\n-            -1 => Err(super::last_error()),\n-            n => {\n-                assert!(n > 0);\n-                unsafe { buf.set_len(n as uint); }\n-                Ok(Path::new(buf))\n-            }\n-        }\n-    }\n-}\n-\n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    return os_symlink(src, dst);\n-\n-    #[cfg(windows)]\n-    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-            as_utf16_p(dst.as_str().unwrap(), |dst| {\n-                unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n-            }) as libc::BOOL\n-        }))\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        }))\n-    }\n-}\n-\n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    return os_link(src, dst);\n-\n-    #[cfg(windows)]\n-    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-            as_utf16_p(dst.as_str().unwrap(), |dst| {\n-                unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-            })\n-        }))\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        }))\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n-    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    io::FileStat {\n-        path: Path::new(path),\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n-        created: stat.st_ctime as u64,\n-        modified: stat.st_mtime as u64,\n-        accessed: stat.st_atime as u64,\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n-    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n-    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n-    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n-    fn flags(_stat: &libc::stat) -> u64 { 0 }\n-\n-    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n-    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n-    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n-    fn gen(_stat: &libc::stat) -> u64 { 0 }\n-\n-    io::FileStat {\n-        path: Path::new(path),\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: flags(stat),\n-            gen: gen(stat),\n-        }\n-    }\n-}\n-\n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n-    return os_stat(p);\n-\n-    #[cfg(windows)]\n-    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::uninit() };\n-        as_utf16_p(p.as_str().unwrap(), |up| {\n-            match retry(|| unsafe { libc::wstat(up, &mut stat) }) {\n-                0 => Ok(mkstat(&stat, p)),\n-                _ => Err(super::last_error()),\n-            }\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::uninit() };\n-        match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n-            0 => Ok(mkstat(&stat, p)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n-    return os_lstat(p);\n-\n-    // FIXME: windows implementation is missing\n-    #[cfg(windows)]\n-    fn os_lstat(_p: &CString) -> IoResult<io::FileStat> {\n-        Err(super::unimpl())\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_lstat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::uninit() };\n-        match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n-            0 => Ok(mkstat(&stat, p)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    return super::mkerr_libc(os_utime(p, atime, mtime));\n-\n-    #[cfg(windows)]\n-    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n-        let buf = libc::utimbuf {\n-            actime: (atime / 1000) as libc::time64_t,\n-            modtime: (mtime / 1000) as libc::time64_t,\n-        };\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n-                libc::wutime(p, &buf)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n-        let buf = libc::utimbuf {\n-            actime: (atime / 1000) as libc::time_t,\n-            modtime: (mtime / 1000) as libc::time_t,\n-        };\n-        retry(|| unsafe { libc::utime(p.with_ref(|p| p), &buf) })\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{CFile, FileDesc};\n-    use std::io;\n-    use std::libc;\n-    use std::os;\n-    use std::rt::rtio::RtioFileStream;\n-\n-    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n-    #[test]\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        unsafe {\n-            let os::Pipe { input, out } = os::pipe();\n-            let mut reader = FileDesc::new(input, true);\n-            let mut writer = FileDesc::new(out, true);\n-\n-            writer.inner_write(bytes!(\"test\")).unwrap();\n-            let mut buf = [0u8, ..4];\n-            match reader.inner_read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-\n-            assert!(writer.inner_read(buf).is_err());\n-            assert!(reader.inner_write(buf).is_err());\n-        }\n-    }\n-\n-    #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n-    #[test]\n-    fn test_cfile() {\n-        unsafe {\n-            let f = libc::tmpfile();\n-            assert!(!f.is_null());\n-            let mut file = CFile::new(f);\n-\n-            file.write(bytes!(\"test\")).unwrap();\n-            let mut buf = [0u8, ..4];\n-            let _ = file.seek(0, io::SeekSet).unwrap();\n-            match file.read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-        }\n-    }\n-}"}, {"sha": "4b6d1813ffa4ad598aedca6c45601004b902b9d7", "filename": "src/libnative/io/file_unix.rs", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -0,0 +1,573 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking posix-based file I/O\n+\n+use std::sync::arc::UnsafeArc;\n+use std::c_str::CString;\n+use std::io::IoError;\n+use std::io;\n+use std::libc::{c_int, c_void};\n+use std::libc;\n+use std::mem;\n+use std::rt::rtio;\n+use std::vec;\n+\n+use io::{IoResult, retry, keep_going};\n+\n+pub type fd_t = libc::c_int;\n+\n+struct Inner {\n+    fd: fd_t,\n+    close_on_drop: bool,\n+}\n+\n+pub struct FileDesc {\n+    priv inner: UnsafeArc<Inner>\n+}\n+\n+impl FileDesc {\n+    /// Create a `FileDesc` from an open C file descriptor.\n+    ///\n+    /// The `FileDesc` will take ownership of the specified file descriptor and\n+    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n+    /// it will not close the file descriptor when this `FileDesc` is dropped.\n+    ///\n+    /// Note that all I/O operations done on this object will be *blocking*, but\n+    /// they do not require the runtime to be active.\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { inner: UnsafeArc::new(Inner {\n+            fd: fd,\n+            close_on_drop: close_on_drop\n+        }) }\n+    }\n+\n+    // FIXME(#10465) these functions should not be public, but anything in\n+    //               native::io wanting to use them is forced to have all the\n+    //               rtio traits in scope\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let ret = retry(|| unsafe {\n+            libc::read(self.fd(),\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n+                       buf.len() as libc::size_t) as libc::c_int\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::write(self.fd(), buf as *libc::c_void,\n+                            len as libc::size_t) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn fd(&self) -> fd_t {\n+        // This unsafety is fine because we're just reading off the file\n+        // descriptor, no one is modifying this.\n+        unsafe { (*self.inner.get()).fd }\n+    }\n+}\n+\n+impl io::Reader for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.inner_read(buf)\n+    }\n+}\n+\n+impl io::Writer for FileDesc {\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.inner_write(buf)\n+    }\n+}\n+\n+impl rtio::RtioFileStream for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.inner_read(buf).map(|i| i as int)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        match retry(|| unsafe {\n+            libc::pread(self.fd(), buf.as_ptr() as *libc::c_void,\n+                        buf.len() as libc::size_t,\n+                        offset as libc::off_t) as libc::c_int\n+        }) {\n+            -1 => Err(super::last_error()),\n+            n => Ok(n as int)\n+        }\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe {\n+            libc::pwrite(self.fd(), buf.as_ptr() as *libc::c_void,\n+                         buf.len() as libc::size_t, offset as libc::off_t)\n+        } as c_int))\n+    }\n+    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match whence {\n+            io::SeekSet => libc::SEEK_SET,\n+            io::SeekEnd => libc::SEEK_END,\n+            io::SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        return super::mkerr_libc(os_datasync(self.fd()));\n+\n+        #[cfg(target_os = \"macos\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fdatasync(fd) })\n+        }\n+        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fsync(fd) })\n+        }\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe {\n+            libc::ftruncate(self.fd(), offset as libc::off_t)\n+        }))\n+    }\n+}\n+\n+impl rtio::RtioPipe for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    }\n+}\n+\n+impl rtio::RtioTTY for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn isatty(&self) -> bool { false }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+pub struct CFile {\n+    priv file: *libc::FILE,\n+    priv fd: FileDesc,\n+}\n+\n+impl CFile {\n+    /// Create a `CFile` from an open `FILE` pointer.\n+    ///\n+    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n+    /// destruction.\n+    pub fn new(file: *libc::FILE) -> CFile {\n+        CFile {\n+            file: file,\n+            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n+        }\n+    }\n+\n+    pub fn flush(&mut self) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n+    }\n+}\n+\n+impl rtio::RtioFileStream for CFile {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as int)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.flush().and_then(|()| self.fd.pread(buf, offset))\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n+    }\n+    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match style {\n+            io::SeekSet => libc::SEEK_SET,\n+            io::SeekEnd => libc::SEEK_END,\n+            io::SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        let ret = unsafe { libc::ftell(self.file) };\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as u64)\n+        }\n+    }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.fsync())\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.fsync())\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.truncate(offset))\n+    }\n+}\n+\n+impl Drop for CFile {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::fclose(self.file); }\n+    }\n+}\n+\n+pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+        -> IoResult<FileDesc> {\n+    let flags = match fm {\n+        io::Open => 0,\n+        io::Append => libc::O_APPEND,\n+        io::Truncate => libc::O_TRUNC,\n+    };\n+    // Opening with a write permission must silently create the file.\n+    let (flags, mode) = match fa {\n+        io::Read => (flags | libc::O_RDONLY, 0),\n+        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                      libc::S_IRUSR | libc::S_IWUSR),\n+        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                          libc::S_IRUSR | libc::S_IWUSR),\n+    };\n+\n+    match retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) }) {\n+        -1 => Err(super::last_error()),\n+        fd => Ok(FileDesc::new(fd, true)),\n+    }\n+}\n+\n+pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n+    }))\n+}\n+\n+pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n+    use std::libc::{dirent_t};\n+    use std::libc::{opendir, readdir, closedir};\n+\n+    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = Path::new(root);\n+\n+        dirs.move_iter().filter(|path| {\n+            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+        }).map(|path| root.join(path)).collect()\n+    }\n+\n+    extern {\n+        fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n+    }\n+\n+    debug!(\"os::list_dir -- BEFORE OPENDIR\");\n+\n+    let dir_ptr = p.with_ref(|buf| unsafe { opendir(buf) });\n+\n+    if dir_ptr as uint != 0 {\n+        let mut paths = ~[];\n+        debug!(\"os::list_dir -- opendir() SUCCESS\");\n+        let mut entry_ptr = unsafe { readdir(dir_ptr) };\n+        while entry_ptr as uint != 0 {\n+            let cstr = unsafe {\n+                CString::new(rust_list_dir_val(entry_ptr), false)\n+            };\n+            paths.push(Path::new(cstr));\n+            entry_ptr = unsafe { readdir(dir_ptr) };\n+        }\n+        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n+        Ok(prune(p, paths))\n+    } else {\n+        Err(super::last_error())\n+    }\n+}\n+\n+pub fn unlink(p: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n+}\n+\n+pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n+    }))\n+}\n+\n+pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::chmod(p.with_ref(|p| p), mode as libc::mode_t)\n+    }))\n+}\n+\n+pub fn rmdir(p: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::rmdir(p.with_ref(|p| p))\n+    }))\n+}\n+\n+pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n+                    gid as libc::gid_t)\n+    }))\n+}\n+\n+pub fn readlink(p: &CString) -> IoResult<Path> {\n+    let p = p.with_ref(|p| p);\n+    let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n+    if len == -1 {\n+        len = 1024; // FIXME: read PATH_MAX from C ffi?\n+    }\n+    let mut buf = vec::with_capacity::<u8>(len as uint);\n+    match retry(|| unsafe {\n+        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n+                       len as libc::size_t) as libc::c_int\n+    }) {\n+        -1 => Err(super::last_error()),\n+        n => {\n+            assert!(n > 0);\n+            unsafe { buf.set_len(n as uint); }\n+            Ok(Path::new(buf))\n+        }\n+    }\n+}\n+\n+pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n+    }))\n+}\n+\n+pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n+    }))\n+}\n+\n+fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n+    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n+\n+    // FileStat times are in milliseconds\n+    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n+\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+\n+    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n+    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n+    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n+    fn flags(_stat: &libc::stat) -> u64 { 0 }\n+\n+    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n+    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n+    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n+    fn gen(_stat: &libc::stat) -> u64 { 0 }\n+\n+    io::FileStat {\n+        path: Path::new(path),\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n+        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n+        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n+        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: flags(stat),\n+            gen: gen(stat),\n+        }\n+    }\n+}\n+\n+pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+    let mut stat: libc::stat = unsafe { mem::uninit() };\n+    match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n+        0 => Ok(mkstat(&stat, p)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n+    let mut stat: libc::stat = unsafe { mem::uninit() };\n+    match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n+        0 => Ok(mkstat(&stat, p)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+    let buf = libc::utimbuf {\n+        actime: (atime / 1000) as libc::time_t,\n+        modtime: (mtime / 1000) as libc::time_t,\n+    };\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::utime(p.with_ref(|p| p), &buf)\n+    }))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{CFile, FileDesc};\n+    use std::io;\n+    use std::libc;\n+    use std::os;\n+    use std::rt::rtio::RtioFileStream;\n+\n+    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n+    #[test]\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        unsafe {\n+            let os::Pipe { input, out } = os::pipe();\n+            let mut reader = FileDesc::new(input, true);\n+            let mut writer = FileDesc::new(out, true);\n+\n+            writer.inner_write(bytes!(\"test\")).unwrap();\n+            let mut buf = [0u8, ..4];\n+            match reader.inner_read(buf) {\n+                Ok(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail!(\"invalid read: {:?}\", r)\n+            }\n+\n+            assert!(writer.inner_read(buf).is_err());\n+            assert!(reader.inner_write(buf).is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cfile() {\n+        unsafe {\n+            let f = libc::tmpfile();\n+            assert!(!f.is_null());\n+            let mut file = CFile::new(f);\n+\n+            file.write(bytes!(\"test\")).unwrap();\n+            let mut buf = [0u8, ..4];\n+            let _ = file.seek(0, io::SeekSet).unwrap();\n+            match file.read(buf) {\n+                Ok(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail!(\"invalid read: {:?}\", r)\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "e880bd05cf7fccf10935fb4218fb9105331b2482", "filename": "src/libnative/io/file_win32.rs", "status": "added", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -0,0 +1,517 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking win32-based file I/O\n+\n+use std::c_str::CString;\n+use std::cast;\n+use std::io::IoError;\n+use std::io;\n+use std::libc::{c_int, c_void};\n+use std::libc;\n+use std::mem;\n+use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+use std::ptr;\n+use std::rt::rtio;\n+use std::str;\n+use std::sync::arc::UnsafeArc;\n+use std::vec;\n+\n+use io::IoResult;\n+\n+pub type fd_t = libc::c_int;\n+\n+struct Inner {\n+    fd: fd_t,\n+    close_on_drop: bool,\n+}\n+\n+pub struct FileDesc {\n+    priv inner: UnsafeArc<Inner>\n+}\n+\n+impl FileDesc {\n+    /// Create a `FileDesc` from an open C file descriptor.\n+    ///\n+    /// The `FileDesc` will take ownership of the specified file descriptor and\n+    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n+    /// it will not close the file descriptor when this `FileDesc` is dropped.\n+    ///\n+    /// Note that all I/O operations done on this object will be *blocking*, but\n+    /// they do not require the runtime to be active.\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { inner: UnsafeArc::new(Inner {\n+            fd: fd,\n+            close_on_drop: close_on_drop\n+        }) }\n+    }\n+\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let mut read = 0;\n+        let ret = unsafe {\n+            libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD, &mut read,\n+                           ptr::mut_null())\n+        };\n+        if ret != 0 {\n+            Ok(read as uint)\n+        } else {\n+            Err(super::last_error())\n+        }\n+    }\n+    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let mut cur = buf.as_ptr();\n+        let mut remaining = buf.len();\n+        while remaining > 0 {\n+            let mut amt = 0;\n+            let ret = unsafe {\n+                libc::WriteFile(self.handle(), cur as libc::LPVOID,\n+                                remaining as libc::DWORD, &mut amt,\n+                                ptr::mut_null())\n+            };\n+            if ret != 0 {\n+                remaining -= amt as uint;\n+                cur = unsafe { cur.offset(amt as int) };\n+            } else {\n+                return Err(super::last_error())\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn fd(&self) -> fd_t {\n+        // This unsafety is fine because we're just reading off the file\n+        // descriptor, no one is modifying this.\n+        unsafe { (*self.inner.get()).fd }\n+    }\n+\n+    pub fn handle(&self) -> libc::HANDLE {\n+        unsafe { libc::get_osfhandle(self.fd()) as libc::HANDLE }\n+    }\n+}\n+\n+impl io::Reader for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.inner_read(buf)\n+    }\n+}\n+\n+impl io::Writer for FileDesc {\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.inner_write(buf)\n+    }\n+}\n+\n+impl rtio::RtioFileStream for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.inner_read(buf).map(|i| i as int)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        let mut read = 0;\n+        let mut overlap: libc::OVERLAPPED = unsafe { mem::init() };\n+        overlap.Offset = offset as libc::DWORD;\n+        overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n+        let ret = unsafe {\n+            libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD, &mut read,\n+                           &mut overlap)\n+        };\n+        if ret != 0 {\n+            Ok(read as int)\n+        } else {\n+            Err(super::last_error())\n+        }\n+    }\n+    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> Result<(), IoError> {\n+        let mut cur = buf.as_ptr();\n+        let mut remaining = buf.len();\n+        let mut overlap: libc::OVERLAPPED = unsafe { mem::init() };\n+        while remaining > 0 {\n+            overlap.Offset = offset as libc::DWORD;\n+            overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n+            let mut amt = 0;\n+            let ret = unsafe {\n+                libc::WriteFile(self.handle(), cur as libc::LPVOID,\n+                                remaining as libc::DWORD, &mut amt,\n+                                &mut overlap)\n+            };\n+            if ret != 0 {\n+                remaining -= amt as uint;\n+                cur = unsafe { cur.offset(amt as int) };\n+                offset += amt as u64;\n+            } else {\n+                return Err(super::last_error())\n+            }\n+        }\n+        Ok(())\n+    }\n+    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match style {\n+            io::SeekSet => libc::FILE_BEGIN,\n+            io::SeekEnd => libc::FILE_END,\n+            io::SeekCur => libc::FILE_CURRENT,\n+        };\n+        unsafe {\n+            let mut newpos = 0;\n+            match libc::SetFilePointerEx(self.handle(), pos, &mut newpos,\n+                                         whence) {\n+                0 => Err(super::last_error()),\n+                _ => Ok(newpos as u64),\n+            }\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        // This transmute is fine because our seek implementation doesn't\n+        // actually use the mutable self at all.\n+        unsafe { cast::transmute_mut(self).seek(0, io::SeekCur) }\n+    }\n+\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        super::mkerr_winbool(unsafe {\n+            libc::FlushFileBuffers(self.handle())\n+        })\n+    }\n+\n+    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n+\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        let orig_pos = try!(self.tell());\n+        let _ = try!(self.seek(offset, io::SeekSet));\n+        let ret = unsafe {\n+            match libc::SetEndOfFile(self.handle()) {\n+                0 => Err(super::last_error()),\n+                _ => Ok(())\n+            }\n+        };\n+        let _ = self.seek(orig_pos as i64, io::SeekSet);\n+        return ret;\n+    }\n+}\n+\n+impl rtio::RtioPipe for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    }\n+}\n+\n+impl rtio::RtioTTY for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn isatty(&self) -> bool { false }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+        -> IoResult<FileDesc> {\n+    // Flags passed to open_osfhandle\n+    let flags = match fm {\n+        io::Open => 0,\n+        io::Append => libc::O_APPEND,\n+        io::Truncate => libc::O_TRUNC,\n+    };\n+    let flags = match fa {\n+        io::Read => flags | libc::O_RDONLY,\n+        io::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n+        io::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n+    };\n+\n+    let mut dwDesiredAccess = match fa {\n+        io::Read => libc::FILE_GENERIC_READ,\n+        io::Write => libc::FILE_GENERIC_WRITE,\n+        io::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n+    };\n+\n+    // libuv has a good comment about this, but the basic idea is what we try to\n+    // emulate unix semantics by enabling all sharing by allowing things such as\n+    // deleting a file while it's still open.\n+    let dwShareMode = libc::FILE_SHARE_READ | libc::FILE_SHARE_WRITE |\n+                      libc::FILE_SHARE_DELETE;\n+\n+    let dwCreationDisposition = match (fm, fa) {\n+        (io::Truncate, io::Read) => libc::TRUNCATE_EXISTING,\n+        (io::Truncate, _) => libc::CREATE_ALWAYS,\n+        (io::Open, io::Read) => libc::OPEN_EXISTING,\n+        (io::Open, _) => libc::CREATE_NEW,\n+        (io::Append, io::Read) => {\n+            dwDesiredAccess |= libc::FILE_APPEND_DATA;\n+            libc::OPEN_EXISTING\n+        }\n+        (io::Append, _) => {\n+            dwDesiredAccess &= !libc::FILE_WRITE_DATA;\n+            dwDesiredAccess |= libc::FILE_APPEND_DATA;\n+            libc::OPEN_ALWAYS\n+        }\n+    };\n+\n+    let mut dwFlagsAndAttributes = libc::FILE_ATTRIBUTE_NORMAL;\n+    // Compat with unix, this allows opening directories (see libuv)\n+    dwFlagsAndAttributes |= libc::FILE_FLAG_BACKUP_SEMANTICS;\n+\n+    let handle = as_utf16_p(path.as_str().unwrap(), |buf| unsafe {\n+        libc::CreateFileW(buf,\n+                          dwDesiredAccess,\n+                          dwShareMode,\n+                          ptr::mut_null(),\n+                          dwCreationDisposition,\n+                          dwFlagsAndAttributes,\n+                          ptr::mut_null())\n+    });\n+    if handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+        Err(super::last_error())\n+    } else {\n+        let fd = unsafe {\n+            libc::open_osfhandle(handle as libc::intptr_t, flags)\n+        };\n+        if fd < 0 {\n+            let _ = unsafe { libc::CloseHandle(handle) };\n+            Err(super::last_error())\n+        } else {\n+            Ok(FileDesc::new(fd, true))\n+        }\n+    }\n+}\n+\n+pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_winbool(unsafe {\n+        // FIXME: turn mode into something useful? #2623\n+        as_utf16_p(p.as_str().unwrap(), |buf| {\n+            libc::CreateDirectoryW(buf, ptr::mut_null())\n+        })\n+    })\n+}\n+\n+pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n+    use rt::global_heap::malloc_raw;\n+\n+    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = Path::new(root);\n+\n+        dirs.move_iter().filter(|path| {\n+            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+        }).map(|path| root.join(path)).collect()\n+    }\n+\n+    #[nolink]\n+    extern {\n+        fn rust_list_dir_wfd_size() -> libc::size_t;\n+        fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+    }\n+    let star = Path::new(unsafe {\n+        CString::new(p.with_ref(|p| p), false)\n+    }).join(\"*\");\n+    as_utf16_p(star.as_str().unwrap(), |path_ptr| unsafe {\n+        let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n+        let find_handle = libc::FindFirstFileW(path_ptr, wfd_ptr as libc::HANDLE);\n+        if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n+            let mut paths = ~[];\n+            let mut more_files = 1 as libc::c_int;\n+            while more_files != 0 {\n+                let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n+                if fp_buf as uint == 0 {\n+                    fail!(\"os::list_dir() failure: got null ptr from wfd\");\n+                } else {\n+                    let fp_vec = vec::from_buf(fp_buf,\n+                                               libc::wcslen(fp_buf) as uint);\n+                    let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n+                    let fp_str = str::from_utf16(fp_trimmed)\n+                            .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n+                    paths.push(Path::new(fp_str));\n+                }\n+                more_files = libc::FindNextFileW(find_handle,\n+                                                 wfd_ptr as libc::HANDLE);\n+            }\n+            assert!(libc::FindClose(find_handle) != 0);\n+            libc::free(wfd_ptr as *mut c_void);\n+            Ok(prune(p, paths))\n+        } else {\n+            Err(super::last_error())\n+        }\n+    })\n+}\n+\n+pub fn unlink(p: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(unsafe {\n+        as_utf16_p(p.as_str().unwrap(), |buf| {\n+            libc::DeleteFileW(buf)\n+        })\n+    })\n+}\n+\n+pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(unsafe {\n+        as_utf16_p(old.as_str().unwrap(), |old| {\n+            as_utf16_p(new.as_str().unwrap(), |new| {\n+                libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n+            })\n+        })\n+    })\n+}\n+\n+pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+        libc::wchmod(p, mode as libc::c_int)\n+    }))\n+}\n+\n+pub fn rmdir(p: &CString) -> IoResult<()> {\n+    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+        libc::wrmdir(p)\n+    }))\n+}\n+\n+pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n+    // libuv has this as a no-op, so seems like this should as well?\n+    Ok(())\n+}\n+\n+pub fn readlink(p: &CString) -> IoResult<Path> {\n+    // FIXME: I have a feeling that this reads intermediate symlinks as well.\n+    let handle = unsafe {\n+        as_utf16_p(p.as_str().unwrap(), |p| {\n+            libc::CreateFileW(p,\n+                              libc::GENERIC_READ,\n+                              libc::FILE_SHARE_READ,\n+                              ptr::mut_null(),\n+                              libc::OPEN_EXISTING,\n+                              libc::FILE_ATTRIBUTE_NORMAL,\n+                              ptr::mut_null())\n+        })\n+    };\n+    if handle as int == libc::INVALID_HANDLE_VALUE as int {\n+        return Err(super::last_error())\n+    }\n+    // Specify (sz - 1) because the documentation states that it's the size\n+    // without the null pointer\n+    let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n+        libc::GetFinalPathNameByHandleW(handle,\n+                                        buf as *u16,\n+                                        sz - 1,\n+                                        libc::VOLUME_NAME_DOS)\n+    });\n+    let ret = match ret {\n+        Some(ref s) if s.starts_with(r\"\\\\?\\\") => Ok(Path::new(s.slice_from(4))),\n+        Some(s) => Ok(Path::new(s)),\n+        None => Err(super::last_error()),\n+    };\n+    assert!(unsafe { libc::CloseHandle(handle) } != 0);\n+    return ret;\n+}\n+\n+pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+        as_utf16_p(dst.as_str().unwrap(), |dst| {\n+            unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n+        }) as libc::BOOL\n+    }))\n+}\n+\n+pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+        as_utf16_p(dst.as_str().unwrap(), |dst| {\n+            unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n+        })\n+    }))\n+}\n+\n+fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n+    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+\n+    io::FileStat {\n+        path: Path::new(path),\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n+        created: stat.st_ctime as u64,\n+        modified: stat.st_mtime as u64,\n+        accessed: stat.st_atime as u64,\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: 0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        }\n+    }\n+}\n+\n+pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+    let mut stat: libc::stat = unsafe { mem::uninit() };\n+    as_utf16_p(p.as_str().unwrap(), |up| {\n+        match unsafe { libc::wstat(up, &mut stat) } {\n+            0 => Ok(mkstat(&stat, p)),\n+            _ => Err(super::last_error()),\n+        }\n+    })\n+}\n+\n+pub fn lstat(_p: &CString) -> IoResult<io::FileStat> {\n+    // FIXME: implementation is missing\n+    Err(super::unimpl())\n+}\n+\n+pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+    let buf = libc::utimbuf {\n+        actime: (atime / 1000) as libc::time64_t,\n+        modtime: (mtime / 1000) as libc::time64_t,\n+    };\n+    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+        libc::wutime(p, &buf)\n+    }))\n+}"}, {"sha": "2e3e9b3b5063739af982402b518148bdd4a90cbd", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -42,10 +42,16 @@ pub use self::process::Process;\n \n // Native I/O implementations\n pub mod addrinfo;\n-pub mod file;\n pub mod net;\n pub mod process;\n \n+#[cfg(unix)]\n+#[path = \"file_unix.rs\"]\n+pub mod file;\n+#[cfg(windows)]\n+#[path = \"file_win32.rs\"]\n+pub mod file;\n+\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"android\")]\n@@ -97,7 +103,14 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n             libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n             libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n             libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-            libc::ERROR_BROKEN_PIPE => (io::BrokenPipe, \"the pipe has ended\"),\n+            libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n+\n+            // libuv maps this error code to EISDIR. we do too. if it is found\n+            // to be incorrect, we can add in some more machinery to only\n+            // return this message when ERROR_INVALID_FUNCTION after certain\n+            // win32 calls.\n+            libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n+                                             \"illegal operation on a directory\"),\n \n             x => {\n                 debug!(\"ignoring {}: {}\", x, os::last_os_error());\n@@ -121,6 +134,7 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n             libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n             libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n             libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n+            libc::EISDIR => (io::InvalidInput, \"illegal operation on a directory\"),\n \n             // These two constants can have the same value on some systems, but\n             // different values on others, so we can't use a match clause\n@@ -185,6 +199,24 @@ fn retry(f: || -> libc::c_int) -> libc::c_int {\n     }\n }\n \n+fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n+    let origamt = data.len();\n+    let mut data = data.as_ptr();\n+    let mut amt = origamt;\n+    while amt > 0 {\n+        let ret = retry(|| f(data, amt) as libc::c_int);\n+        if ret == 0 {\n+            break\n+        } else if ret != -1 {\n+            amt -= ret as uint;\n+            data = unsafe { data.offset(ret as int) };\n+        } else {\n+            return ret as i64;\n+        }\n+    }\n+    return (origamt - amt) as i64;\n+}\n+\n /// Implementation of rt::rtio's IoFactory trait to generate handles to the\n /// native I/O functionality.\n pub struct IoFactory {"}, {"sha": "7445e4c09926171c7b90d4c67b61db062bd62fc0", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(non_camel_case_types)];\n-\n use std::cast;\n use std::io::net::ip;\n use std::io;\n@@ -18,8 +16,7 @@ use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n \n-use super::{IoResult, retry};\n-use super::file::keep_going;\n+use super::{IoResult, retry, keep_going};\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -323,16 +320,14 @@ impl rtio::RtioTcpStream for TcpStream {\n         }\n     }\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::send(self.fd(),\n-                           buf as *mut libc::c_void,\n-                           len as wrlen,\n-                           0) as i64\n-            }\n+        let ret = keep_going(buf, |buf, len| unsafe {\n+            libc::send(self.fd(),\n+                       buf as *mut libc::c_void,\n+                       len as wrlen,\n+                       0) as i64\n         });\n         if ret < 0 {\n-            Err(last_error())\n+            Err(super::last_error())\n         } else {\n             Ok(())\n         }"}, {"sha": "9e81dc02cc5969bea57255aebe96b8a5924d9513", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -17,8 +17,8 @@ use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n use std::intrinsics;\n \n-use super::{IoResult, retry};\n-use super::file::{keep_going, fd_t};\n+use super::{IoResult, retry, keep_going};\n+use super::file::fd_t;\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {"}, {"sha": "7669d4a658fad3db5e936597b14895c2f05178a7", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -20,8 +20,6 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-#[allow(non_camel_case_types)];\n-\n use std::cast;\n use std::rt;\n use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n@@ -100,7 +98,6 @@ mod imp {\n \n     use io::file::FileDesc;\n \n-    #[allow(non_camel_case_types)]\n     pub type signal = libc::c_int;\n \n     pub fn new() -> (signal, signal) {"}, {"sha": "0784b5ee048450961541bed71e62499397ec191b", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -46,8 +46,6 @@\n //!\n //! Note that all time units in this file are in *milliseconds*.\n \n-#[allow(non_camel_case_types)];\n-\n use std::comm::Data;\n use std::libc;\n use std::mem;"}, {"sha": "7feeaa4768c9aff71e8094f3957efd973d0e7eed", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -28,8 +28,6 @@\n //!\n //! As with timer_other, all units in this file are in units of millseconds.\n \n-#[allow(non_camel_case_types)];\n-\n use std::comm::Data;\n use std::libc;\n use std::ptr;"}, {"sha": "238e4c23b452e70cbafa692d6e3fe5d39b2701de", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -49,6 +49,7 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[deny(unused_result, unused_must_use)];\n+#[allow(non_camel_case_types)];\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "5f070ef782b4ec87674363f397f7558b9da7a986", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 155, "deletions": 132, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -663,6 +663,13 @@ mod test {\n     use io;\n     use ops::Drop;\n \n+    macro_rules! check( ($e:expr) => (\n+        match $e {\n+            Ok(t) => t,\n+            Err(e) => fail!(\"{} failed with: {}\", stringify!($e), e),\n+        }\n+    ) )\n+\n     struct TempDir(Path);\n \n     impl TempDir {\n@@ -682,15 +689,15 @@ mod test {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n             let TempDir(ref p) = *self;\n-            io::fs::rmdir_recursive(p).unwrap();\n+            check!(io::fs::rmdir_recursive(p));\n         }\n     }\n \n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        io::fs::mkdir(&ret, io::UserRWX).unwrap();\n+        check!(io::fs::mkdir(&ret, io::UserRWX));\n         TempDir(ret)\n     }\n \n@@ -700,18 +707,18 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n         {\n             let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            write_stream.write(message.as_bytes()).unwrap();\n+            check!(write_stream.write(message.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             let mut read_buf = [0, .. 1028];\n-            let read_str = match read_stream.read(read_buf).unwrap() {\n+            let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8_owned(read_buf.slice_to(n).to_owned()).unwrap()\n+                n => str::from_utf8(read_buf.slice_to(n).to_owned()).unwrap().to_owned()\n             };\n             assert_eq!(read_str, message.to_owned());\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n     })\n \n     iotest!(fn invalid_path_raises() {\n@@ -734,20 +741,20 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes()).unwrap();\n+            check!(rw_stream.write(message.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n                 let read_buf = read_mem.mut_slice(0, 4);\n-                read_stream.read(read_buf).unwrap();\n+                check!(read_stream.read(read_buf));\n             }\n             {\n                 let read_buf = read_mem.mut_slice(4, 8);\n-                read_stream.read(read_buf).unwrap();\n+                check!(read_stream.read(read_buf));\n             }\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message);\n     })\n@@ -762,16 +769,16 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes()).unwrap();\n+            check!(rw_stream.write(message.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.seek(set_cursor as i64, SeekSet).unwrap();\n-            tell_pos_pre_read = read_stream.tell().unwrap();\n-            read_stream.read(read_mem).unwrap();\n-            tell_pos_post_read = read_stream.tell().unwrap();\n+            check!(read_stream.seek(set_cursor as i64, SeekSet));\n+            tell_pos_pre_read = check!(read_stream.tell());\n+            check!(read_stream.read(read_mem));\n+            tell_pos_post_read = check!(read_stream.tell());\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n@@ -788,15 +795,15 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes()).unwrap();\n-            rw_stream.seek(seek_idx as i64, SeekSet).unwrap();\n-            rw_stream.write(overwrite_msg.as_bytes()).unwrap();\n+            check!(rw_stream.write(initial_msg.as_bytes()));\n+            check!(rw_stream.seek(seek_idx as i64, SeekSet));\n+            check!(rw_stream.write(overwrite_msg.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.read(read_mem));\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert!(read_str == final_msg.to_owned());\n     })\n@@ -812,24 +819,24 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes()).unwrap();\n+            check!(rw_stream.write(initial_msg.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n \n-            read_stream.seek(-4, SeekEnd).unwrap();\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.seek(-4, SeekEnd));\n+            check!(read_stream.read(read_mem));\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_three);\n \n-            read_stream.seek(-9, SeekCur).unwrap();\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.seek(-9, SeekCur));\n+            check!(read_stream.read(read_mem));\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_two);\n \n-            read_stream.seek(0, SeekSet).unwrap();\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.seek(0, SeekSet));\n+            check!(read_stream.read(read_mem));\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_file() {\n@@ -840,81 +847,81 @@ mod test {\n             let msg = \"hw\";\n             fs.write(msg.as_bytes()).unwrap();\n         }\n-        let stat_res = stat(filename).unwrap();\n+        let stat_res = check!(stat(filename));\n         assert_eq!(stat_res.kind, io::TypeFile);\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        mkdir(filename, io::UserRWX).unwrap();\n-        let stat_res = filename.stat().unwrap();\n+        check!(mkdir(filename, io::UserRWX));\n+        let stat_res = check!(filename.stat());\n         assert!(stat_res.kind == io::TypeDirectory);\n-        rmdir(filename).unwrap();\n+        check!(rmdir(filename));\n     })\n \n     iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        mkdir(dir, io::UserRWX).unwrap();\n+        check!(mkdir(dir, io::UserRWX));\n         assert!(dir.is_file() == false);\n-        rmdir(dir).unwrap();\n+        check!(rmdir(dir));\n     })\n \n     iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        File::create(file).write(bytes!(\"foo\")).unwrap();\n+        check!(File::create(file).write(bytes!(\"foo\")));\n         assert!(file.exists());\n-        unlink(file).unwrap();\n+        check!(unlink(file));\n         assert!(!file.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        mkdir(dir, io::UserRWX).unwrap();\n+        check!(mkdir(dir, io::UserRWX));\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n-        rmdir(dir).unwrap();\n+        check!(rmdir(dir));\n         assert!(!dir.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        mkdir(dir, io::UserRWX).unwrap();\n+        check!(mkdir(dir, io::UserRWX));\n         let prefix = \"foo\";\n         for n in range(0,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = File::create(&f).unwrap();\n+            let mut w = check!(File::create(&f));\n             let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n             let msg = msg_str.as_bytes();\n-            w.write(msg).unwrap();\n+            check!(w.write(msg));\n         }\n-        let files = readdir(dir).unwrap();\n+        let files = check!(readdir(dir));\n         let mut mem = [0u8, .. 4];\n         for f in files.iter() {\n             {\n                 let n = f.filestem_str();\n-                File::open(f).read(mem).unwrap();\n+                check!(File::open(f).read(mem));\n                 let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n\n                 };\n                 assert_eq!(expected.as_slice(), read_str);\n             }\n-            unlink(f).unwrap();\n+            check!(unlink(f));\n         }\n-        rmdir(dir).unwrap();\n+        check!(rmdir(dir));\n     })\n \n     iotest!(fn recursive_mkdir_slash() {\n-        mkdir_recursive(&Path::new(\"/\"), io::UserRWX).unwrap();\n+        check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n     })\n \n     iotest!(fn unicode_path_is_dir() {\n@@ -925,12 +932,12 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        mkdir(&dirpath, io::UserRWX).unwrap();\n+        check!(mkdir(&dirpath, io::UserRWX));\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        File::create(&filepath).unwrap(); // ignore return; touch only\n+        check!(File::create(&filepath)); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n     })\n@@ -942,7 +949,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        mkdir(&unicode, io::UserRWX).unwrap();\n+        check!(mkdir(&unicode, io::UserRWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n@@ -964,19 +971,19 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(bytes!(\"hello\")).unwrap();\n-        copy(&input, &out).unwrap();\n-        let contents = File::open(&out).read_to_end().unwrap();\n+        check!(File::create(&input).write(bytes!(\"hello\")));\n+        check!(copy(&input, &out));\n+        let contents = check!(File::open(&out).read_to_end());\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n-        assert_eq!(input.stat().unwrap().perm, out.stat().unwrap().perm);\n+        assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n     })\n \n     iotest!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        File::create(&out).unwrap();\n+        check!(File::create(&out));\n         match copy(&out, tmpdir.path()) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n@@ -987,11 +994,11 @@ mod test {\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n \n-        File::create(&input).write(\"foo\".as_bytes()).unwrap();\n-        File::create(&output).write(\"bar\".as_bytes()).unwrap();\n-        copy(&input, &output).unwrap();\n+        check!(File::create(&input).write(\"foo\".as_bytes()));\n+        check!(File::create(&output).write(\"bar\".as_bytes()));\n+        check!(copy(&input, &output));\n \n-        assert_eq!(File::open(&output).read_to_end().unwrap(),\n+        assert_eq!(check!(File::open(&output).read_to_end()),\n                    (bytes!(\"foo\")).to_owned());\n     })\n \n@@ -1010,13 +1017,13 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).unwrap();\n-        chmod(&input, io::UserRead).unwrap();\n-        copy(&input, &out).unwrap();\n-        assert!(out.stat().unwrap().perm & io::UserWrite == 0);\n+        check!(File::create(&input));\n+        check!(chmod(&input, io::UserRead));\n+        check!(copy(&input, &out));\n+        assert!(check!(out.stat()).perm & io::UserWrite == 0);\n \n-        chmod(&input, io::UserFile).unwrap();\n-        chmod(&out, io::UserFile).unwrap();\n+        check!(chmod(&input, io::UserFile));\n+        check!(chmod(&out, io::UserFile));\n     })\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1025,22 +1032,22 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n-        symlink(&input, &out).unwrap();\n+        check!(File::create(&input).write(\"foobar\".as_bytes()));\n+        check!(symlink(&input, &out));\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).unwrap().kind, io::TypeSymlink);\n+            assert_eq!(check!(lstat(&out)).kind, io::TypeSymlink);\n         }\n-        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n-        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n+        assert_eq!(check!(File::open(&out).read_to_end()),\n                    (bytes!(\"foobar\")).to_owned());\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n     iotest!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n-        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")).unwrap();\n-        assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n+        check!(symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n+        assert!(check!(readlink(&tmpdir.join(\"bar\"))) == tmpdir.join(\"foo\"));\n     })\n \n     iotest!(fn readlink_not_symlink() {\n@@ -1056,14 +1063,14 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n-        link(&input, &out).unwrap();\n+        check!(File::create(&input).write(\"foobar\".as_bytes()));\n+        check!(link(&input, &out));\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).unwrap().kind, io::TypeFile);\n-            assert_eq!(stat(&out).unwrap().unstable.nlink, 2);\n+            assert_eq!(check!(lstat(&out)).kind, io::TypeFile);\n+            assert_eq!(check!(stat(&out)).unstable.nlink, 2);\n         }\n-        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n-        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n+        assert_eq!(check!(File::open(&out).read_to_end()),\n                    (bytes!(\"foobar\")).to_owned());\n \n         // can't link to yourself\n@@ -1082,109 +1089,112 @@ mod test {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n-        File::create(&file).unwrap();\n-        assert!(stat(&file).unwrap().perm & io::UserWrite == io::UserWrite);\n-        chmod(&file, io::UserRead).unwrap();\n-        assert!(stat(&file).unwrap().perm & io::UserWrite == 0);\n+        check!(File::create(&file));\n+        assert!(check!(stat(&file)).perm & io::UserWrite == io::UserWrite);\n+        check!(chmod(&file, io::UserRead));\n+        assert!(check!(stat(&file)).perm & io::UserWrite == 0);\n \n         match chmod(&tmpdir.join(\"foo\"), io::UserRWX) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n \n-        chmod(&file, io::UserFile).unwrap();\n+        check!(chmod(&file, io::UserFile));\n     })\n \n     iotest!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.fsync().unwrap();\n-        file.datasync().unwrap();\n-        file.write(bytes!(\"foo\")).unwrap();\n-        file.fsync().unwrap();\n-        file.datasync().unwrap();\n+        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        check!(file.fsync());\n+        check!(file.datasync());\n+        check!(file.write(bytes!(\"foo\")));\n+        check!(file.fsync());\n+        check!(file.datasync());\n         drop(file);\n-    } #[ignore(cfg(windows))])\n+    })\n \n     iotest!(fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.write(bytes!(\"foo\")).unwrap();\n-        file.fsync().unwrap();\n+        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        check!(file.write(bytes!(\"foo\")));\n+        check!(file.fsync());\n \n         // Do some simple things with truncation\n-        assert_eq!(stat(&path).unwrap().size, 3);\n-        file.truncate(10).unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 10);\n-        file.write(bytes!(\"bar\")).unwrap();\n-        file.fsync().unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 10);\n-        assert_eq!(File::open(&path).read_to_end().unwrap(),\n+        assert_eq!(check!(stat(&path)).size, 3);\n+        check!(file.truncate(10));\n+        assert_eq!(check!(stat(&path)).size, 10);\n+        check!(file.write(bytes!(\"bar\")));\n+        check!(file.fsync());\n+        assert_eq!(check!(stat(&path)).size, 10);\n+        assert_eq!(check!(File::open(&path).read_to_end()),\n                    (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n-        file.truncate(2).unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 2);\n-        file.write(bytes!(\"wut\")).unwrap();\n-        file.fsync().unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 9);\n-        assert_eq!(File::open(&path).read_to_end().unwrap(),\n+        check!(file.truncate(2));\n+        assert_eq!(check!(stat(&path)).size, 2);\n+        check!(file.write(bytes!(\"wut\")));\n+        check!(file.fsync());\n+        assert_eq!(check!(stat(&path)).size, 9);\n+        assert_eq!(check!(File::open(&path).read_to_end()),\n                    (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n         drop(file);\n-    } #[ignore(cfg(windows))]) // FIXME(#11638)\n+    })\n \n     iotest!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n         match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n-        File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite).unwrap();\n-        File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite).unwrap();\n-        File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n-\n-        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()).unwrap();\n-        File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n+        check!(File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite));\n+\n+        check!(File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()));\n+        check!(File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read));\n         {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n-                                        io::Read).unwrap();\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Open,\n+                                               io::Read));\n             match f.write(\"wut\".as_bytes()) {\n                 Ok(..) => fail!(), Err(..) => {}\n             }\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n+        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n+                \"write/stat failed\");\n         {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n-                                        io::Write).unwrap();\n-            f.write(\"bar\".as_bytes()).unwrap();\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Append,\n+                                               io::Write));\n+            check!(f.write(\"bar\".as_bytes()));\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 6);\n+        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 6,\n+                \"append didn't append\");\n         {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n-                                        io::Write).unwrap();\n-            f.write(\"bar\".as_bytes()).unwrap();\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n+                                               io::Write));\n+            check!(f.write(\"bar\".as_bytes()));\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n+        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n+                \"truncate didn't truncate\");\n     })\n \n     #[test]\n     fn utime() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n-        File::create(&path).unwrap();\n+        check!(File::create(&path));\n \n-        change_file_times(&path, 1000, 2000).unwrap();\n-        assert_eq!(path.stat().unwrap().accessed, 1000);\n-        assert_eq!(path.stat().unwrap().modified, 2000);\n+        check!(change_file_times(&path, 1000, 2000));\n+        assert_eq!(check!(path.stat()).accessed, 1000);\n+        assert_eq!(check!(path.stat()).modified, 2000);\n     }\n \n     #[test]\n@@ -1196,4 +1206,17 @@ mod test {\n             Err(..) => {}\n         }\n     }\n+\n+    iotest!(fn binary_file() {\n+        use rand::{rng, Rng};\n+\n+        let mut bytes = [0, ..1024];\n+        rng().fill_bytes(bytes);\n+\n+        let tmpdir = tmpdir();\n+\n+        check!(File::create(&tmpdir.join(\"test\")).write(bytes));\n+        let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n+        assert!(actual.as_slice() == bytes);\n+    })\n }"}, {"sha": "4545fea061b8f31a67e765a3440c0afda746ba2d", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -137,16 +137,20 @@ mod tests {\n     pub fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n-        let (port, chan) = Chan::new();\n+\n+        let mut acceptor = UnixListener::bind(&path1).listen();\n \n         spawn(proc() {\n-            port.recv();\n-            client(UnixStream::connect(&path2).unwrap());\n+            match UnixStream::connect(&path2) {\n+                Ok(c) => client(c),\n+                Err(e) => fail!(\"failed connect: {}\", e),\n+            }\n         });\n \n-        let mut acceptor = UnixListener::bind(&path1).listen();\n-        chan.send(());\n-        server(acceptor.accept().unwrap());\n+        match acceptor.accept() {\n+            Ok(c) => server(c),\n+            Err(e) => fail!(\"failed accept: {}\", e),\n+        }\n     }\n \n     iotest!(fn bind_error() {"}, {"sha": "43419c751fcced9e4101069e96f435c0cb6897bc", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -146,22 +146,20 @@ impl Listener {\n     }\n }\n \n-#[cfg(test)]\n-mod test {\n+#[cfg(test, unix)]\n+mod test_unix {\n     use libc;\n     use comm::Empty;\n     use io::timer;\n     use super::{Listener, Interrupt};\n \n-    // kill is only available on Unixes\n-    #[cfg(unix)]\n     fn sigint() {\n         unsafe {\n             libc::funcs::posix88::signal::kill(libc::getpid(), libc::SIGINT);\n         }\n     }\n \n-    #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n+    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_smoketest() {\n         let mut signal = Listener::new();\n         signal.register(Interrupt).unwrap();\n@@ -173,7 +171,7 @@ mod test {\n         }\n     }\n \n-    #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n+    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_two_signal_one_signum() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n@@ -191,7 +189,7 @@ mod test {\n         }\n     }\n \n-    #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n+    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_unregister() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n@@ -202,15 +200,16 @@ mod test {\n         timer::sleep(10);\n         assert_eq!(s2.port.try_recv(), Empty);\n     }\n+}\n+\n+#[cfg(test, windows)]\n+mod test_windows {\n+    use super::{User1, Listener};\n+    use result::{Ok, Err};\n \n-    #[cfg(windows)]\n     #[test]\n     fn test_io_signal_invalid_signum() {\n-        use io;\n-        use super::User1;\n-        use result::{Ok, Err};\n         let mut s = Listener::new();\n-        let mut called = false;\n         match s.register(User1) {\n             Ok(..) => {\n                 fail!(\"Unexpected successful registry of signum {:?}\", User1);"}, {"sha": "07be753925f20e4d254019510a899490b630e32a", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -1623,6 +1623,7 @@ pub mod consts {\n             pub static O_NOINHERIT: c_int = 128;\n \n             pub static ERROR_SUCCESS : c_int = 0;\n+            pub static ERROR_INVALID_FUNCTION: c_int = 1;\n             pub static ERROR_FILE_NOT_FOUND: c_int = 2;\n             pub static ERROR_ACCESS_DENIED: c_int = 5;\n             pub static ERROR_INVALID_HANDLE : c_int = 6;\n@@ -1745,6 +1746,10 @@ pub mod consts {\n             pub static OPEN_EXISTING: DWORD = 3;\n             pub static TRUNCATE_EXISTING: DWORD = 5;\n \n+            pub static FILE_APPEND_DATA: DWORD = 0x00000004;\n+            pub static FILE_READ_DATA: DWORD = 0x00000001;\n+            pub static FILE_WRITE_DATA: DWORD = 0x00000002;\n+\n             pub static FILE_ATTRIBUTE_ARCHIVE: DWORD = 0x20;\n             pub static FILE_ATTRIBUTE_COMPRESSED: DWORD = 0x800;\n             pub static FILE_ATTRIBUTE_DEVICE: DWORD = 0x40;\n@@ -1791,6 +1796,18 @@ pub mod consts {\n             pub static FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n             pub static FILE_READ_ATTRIBUTES: DWORD = 0x00000080;\n \n+            pub static STANDARD_RIGHTS_READ: DWORD = 0x20000;\n+            pub static STANDARD_RIGHTS_WRITE: DWORD = 0x20000;\n+            pub static FILE_WRITE_EA: DWORD = 0x00000010;\n+            pub static FILE_READ_EA: DWORD = 0x00000008;\n+            pub static FILE_GENERIC_READ: DWORD =\n+                STANDARD_RIGHTS_READ | FILE_READ_DATA |\n+                FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE;\n+            pub static FILE_GENERIC_WRITE: DWORD =\n+                STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA |\n+                FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA |\n+                SYNCHRONIZE;\n+\n             pub static FILE_BEGIN: DWORD = 0;\n             pub static FILE_CURRENT: DWORD = 1;\n             pub static FILE_END: DWORD = 2;\n@@ -4231,6 +4248,7 @@ pub mod funcs {\n \n         pub mod msvcrt {\n             use libc::types::os::arch::c95::{c_int, c_long};\n+            use libc::types::os::arch::c99::intptr_t;\n \n             #[nolink]\n             extern {\n@@ -4239,6 +4257,10 @@ pub mod funcs {\n \n                 #[link_name = \"_get_osfhandle\"]\n                 pub fn get_osfhandle(fd: c_int) -> c_long;\n+\n+                #[link_name = \"_open_osfhandle\"]\n+                pub fn open_osfhandle(osfhandle: intptr_t,\n+                                      flags: c_int) -> c_int;\n             }\n         }\n     }"}, {"sha": "a8f7782fa4623a2371ac47c54501c33d946d43f6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -698,8 +698,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr) => (\n                 {\n-                    let path = ($path);\n-                    let join = ($join);\n+                    let path = $path;\n+                    let join = $join;\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);"}, {"sha": "10834aec64c94ea9bc836ea70bb3e1ad3a603c35", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -1433,8 +1433,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr) => (\n                 {\n-                    let path = ($path);\n-                    let join = ($join);\n+                    let path = $path;\n+                    let join = $join;\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);"}, {"sha": "57dbc045a65fedaa3f5df4523fe3694a6323a74e", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -82,9 +82,7 @@ impl DynamicLibrary {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use option::*;\n-    use result::*;\n-    use path::*;\n+    use prelude::*;\n     use libc;\n \n     #[test]"}, {"sha": "ce719c6d0b8db4ce2ad57b7872c92509bf435dc5", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01a9a8d02f6c09b89a3cecadaa5b62073381180/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f01a9a8d02f6c09b89a3cecadaa5b62073381180", "patch": "@@ -3529,7 +3529,7 @@ mod tests {\n         let mut v: [uint, .. 0] = [];\n         v.sort();\n \n-        let mut v = [0xDEADBEEF];\n+        let mut v = [0xDEADBEEFu];\n         v.sort();\n         assert_eq!(v, [0xDEADBEEF]);\n     }"}]}