{"sha": "2d366428cc50d1f20c139ffc854a603de1c1470c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMzY2NDI4Y2M1MGQxZjIwYzEzOWZmYzg1NGE2MDNkZTFjMTQ3MGM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-08-17T01:13:43Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-08-17T18:09:30Z"}, "message": "Properly invalidate the early exit cache\n\nFixes #35737", "tree": {"sha": "a4e24e4860239733593dc884f1f1ea936116eaa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e24e4860239733593dc884f1f1ea936116eaa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d366428cc50d1f20c139ffc854a603de1c1470c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d366428cc50d1f20c139ffc854a603de1c1470c", "html_url": "https://github.com/rust-lang/rust/commit/2d366428cc50d1f20c139ffc854a603de1c1470c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d366428cc50d1f20c139ffc854a603de1c1470c/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e25542cb02d946959517ebb68e2f7b1318817237", "url": "https://api.github.com/repos/rust-lang/rust/commits/e25542cb02d946959517ebb68e2f7b1318817237", "html_url": "https://github.com/rust-lang/rust/commit/e25542cb02d946959517ebb68e2f7b1318817237"}], "stats": {"total": 80, "additions": 60, "deletions": 20}, "files": [{"sha": "ca9e108bb415af75b6eec9c87736864b78d28b27", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2d366428cc50d1f20c139ffc854a603de1c1470c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d366428cc50d1f20c139ffc854a603de1c1470c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=2d366428cc50d1f20c139ffc854a603de1c1470c", "patch": "@@ -198,8 +198,11 @@ impl<'tcx> Scope<'tcx> {\n     ///\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n-    fn invalidate_cache(&mut self) {\n-        self.cached_exits = FnvHashMap();\n+    ///\n+    /// `unwind` controls whether caches for the unwind branch are also invalidated.\n+    fn invalidate_cache(&mut self, unwind: bool) {\n+        self.cached_exits.clear();\n+        if !unwind { return; }\n         for dropdata in &mut self.drops {\n             if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n                 *cached_block = None;\n@@ -455,25 +458,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in self.scopes.iter_mut().rev() {\n-            if scope.extent == extent {\n+            let this_scope = scope.extent == extent;\n+            // We must invalidate all the caches leading up to the scope we\u2019re looking for, because\n+            // the cached blocks will branch into build of scope not containing the new drop. If we\n+            // add stuff to the currently inspected scope, then in some cases the non-unwind caches\n+            // may become invalid, therefore we should invalidate these as well. The unwind caches\n+            // will stay correct, because the already generated unwind blocks cannot be influenced\n+            // by just added drop.\n+            //\n+            // If we\u2019re scheduling cleanup for non-droppable type (i.e. DropKind::Storage), then we\n+            // do not need to invalidate unwind branch, because DropKind::Storage does not end up\n+            // built in the unwind branch currently.\n+            let invalidate_unwind = needs_drop && !this_scope;\n+            scope.invalidate_cache(invalidate_unwind);\n+            if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n-\n-                // No need to invalidate any caches here. The just-scheduled drop will branch into\n-                // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n                     span: span,\n                     location: lvalue.clone(),\n                     kind: drop_kind\n                 });\n                 return;\n-            } else {\n-                // We must invalidate all the cached_blocks leading up to the scope we\u2019re\n-                // looking for, because all of the blocks in the chain will become incorrect.\n-                if let DropKind::Value { .. } = drop_kind {\n-                    scope.invalidate_cache()\n-                }\n             }\n         }\n         span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n@@ -490,11 +497,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {\n+            // We must invalidate all the caches leading up to and including the scope we\u2019re\n+            // looking for, because otherwise some of the blocks in the chain will become\n+            // incorrect and must be rebuilt.\n+            scope.invalidate_cache(true);\n             if scope.extent == extent {\n                 assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n-                // We also must invalidate the caches in the scope for which the free is scheduled\n-                // because the drops must branch into the free we schedule here.\n-                scope.invalidate_cache();\n                 scope.needs_cleanup = true;\n                 scope.free = Some(FreeData {\n                     span: span,\n@@ -503,11 +511,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     cached_block: None\n                 });\n                 return;\n-            } else {\n-                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n-                // for, because otherwise some/most of the blocks in the chain will become\n-                // incorrect.\n-                scope.invalidate_cache();\n             }\n         }\n         span_bug!(span, \"extent {:?} not in scope to free {:?}\", extent, value);"}, {"sha": "c27e57358b09b848c18bfbcd974b2bbcf2cd3486", "filename": "src/test/run-pass/mir_early_return_scope.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2d366428cc50d1f20c139ffc854a603de1c1470c/src%2Ftest%2Frun-pass%2Fmir_early_return_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d366428cc50d1f20c139ffc854a603de1c1470c/src%2Ftest%2Frun-pass%2Fmir_early_return_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_early_return_scope.rs?ref=2d366428cc50d1f20c139ffc854a603de1c1470c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROP: bool = false;\n+\n+struct ConnWrap(Conn);\n+impl ::std::ops::Deref for ConnWrap {\n+    type Target=Conn;\n+    fn deref(&self) -> &Conn { &self.0 }\n+}\n+\n+struct Conn;\n+impl Drop for  Conn {\n+    fn drop(&mut self) { unsafe { DROP = true; } }\n+}\n+\n+fn inner() {\n+    let conn = &*match Some(ConnWrap(Conn)) {\n+        Some(val) => val,\n+        None => return,\n+    };\n+    return;\n+}\n+\n+fn main() {\n+    inner();\n+    unsafe {\n+        assert_eq!(DROP, true);\n+    }\n+}"}]}