{"sha": "2e5837a1024fe488ca153a1ea64824250344cf1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNTgzN2ExMDI0ZmU0ODhjYTE1M2ExZWE2NDgyNDI1MDM0NGNmMWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-10-01T11:08:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-01T11:08:32Z"}, "message": "Rollup merge of #36872 - frewsxcv:rustdoc, r=GuillaumeGomez\n\nA couple refactorings in librustdoc.\n\nNone", "tree": {"sha": "3fb9eae804cb553a86cef634e082bd0e37af9834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fb9eae804cb553a86cef634e082bd0e37af9834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e5837a1024fe488ca153a1ea64824250344cf1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e5837a1024fe488ca153a1ea64824250344cf1c", "html_url": "https://github.com/rust-lang/rust/commit/2e5837a1024fe488ca153a1ea64824250344cf1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e5837a1024fe488ca153a1ea64824250344cf1c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3821811c49cfba5f1bafbd953253760e05a762c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3821811c49cfba5f1bafbd953253760e05a762c1", "html_url": "https://github.com/rust-lang/rust/commit/3821811c49cfba5f1bafbd953253760e05a762c1"}, {"sha": "7732e621f49a91cb9dd5d788d333da4f6618f39e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7732e621f49a91cb9dd5d788d333da4f6618f39e", "html_url": "https://github.com/rust-lang/rust/commit/7732e621f49a91cb9dd5d788d333da4f6618f39e"}], "stats": {"total": 96, "additions": 47, "deletions": 49}, "files": [{"sha": "da0f6bd995ae3bc7b4de3b75e538c8e8123bb7f3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2e5837a1024fe488ca153a1ea64824250344cf1c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e5837a1024fe488ca153a1ea64824250344cf1c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2e5837a1024fe488ca153a1ea64824250344cf1c", "patch": "@@ -283,34 +283,34 @@ impl Item {\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        ItemType::from(self) == ItemType::Module\n+        self.type_() == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        ItemType::from(self) == ItemType::Trait\n+        self.type_() == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        ItemType::from(self) == ItemType::Struct\n+        self.type_() == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        ItemType::from(self) == ItemType::Module\n+        self.type_() == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        ItemType::from(self) == ItemType::Function\n+        self.type_() == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        ItemType::from(self) == ItemType::AssociatedType\n+        self.type_() == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        ItemType::from(self) == ItemType::AssociatedConst\n+        self.type_() == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        ItemType::from(self) == ItemType::Method\n+        self.type_() == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        ItemType::from(self) == ItemType::TyMethod\n+        self.type_() == ItemType::TyMethod\n     }\n     pub fn is_primitive(&self) -> bool {\n-        ItemType::from(self) == ItemType::Primitive\n+        self.type_() == ItemType::Primitive\n     }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n@@ -342,6 +342,11 @@ impl Item {\n     pub fn stable_since(&self) -> Option<&str> {\n         self.stability.as_ref().map(|s| &s.since[..])\n     }\n+\n+    /// Returns a documentation-level item type from the item.\n+    pub fn type_(&self) -> ItemType {\n+        ItemType::from(self)\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "46461226381a3e04b5fb314f94fdc9a92d7d45ea", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2e5837a1024fe488ca153a1ea64824250344cf1c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e5837a1024fe488ca153a1ea64824250344cf1c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2e5837a1024fe488ca153a1ea64824250344cf1c", "patch": "@@ -89,9 +89,6 @@ pub struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n-    /// String representation of how to get back to the root path of the 'doc/'\n-    /// folder in terms of a relative URL.\n-    pub root_path: String,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: PathBuf,\n@@ -496,7 +493,6 @@ pub fn run(mut krate: clean::Crate,\n     krate = render_sources(&dst, &mut scx, krate)?;\n     let cx = Context {\n         current: Vec::new(),\n-        root_path: String::new(),\n         dst: dst,\n         render_redirect_pages: false,\n         shared: Arc::new(scx),\n@@ -591,7 +587,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_impl_items {\n         if let Some(&(ref fqp, _)) = paths.get(&did) {\n             search_index.push(IndexItem {\n-                ty: item_type(item),\n+                ty: item.type_(),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -835,11 +831,6 @@ fn mkdir(path: &Path) -> io::Result<()> {\n     }\n }\n \n-/// Returns a documentation-level item type from the item.\n-fn item_type(item: &clean::Item) -> ItemType {\n-    ItemType::from(item)\n-}\n-\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree. Each component in the cleaned path will be passed as an\n@@ -1075,7 +1066,7 @@ impl DocFolder for Cache {\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n-                            ty: item_type(&item),\n+                            ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -1122,7 +1113,7 @@ impl DocFolder for Cache {\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), item_type(&item)));\n+                                      (self.stack.clone(), item.type_()));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -1135,7 +1126,7 @@ impl DocFolder for Cache {\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n                 self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                item_type(&item)));\n+                                                item.type_()));\n             }\n \n             _ => {}\n@@ -1230,6 +1221,12 @@ impl<'a> Cache {\n }\n \n impl Context {\n+    /// String representation of how to get back to the root path of the 'doc/'\n+    /// folder in terms of a relative URL.\n+    fn root_path(&self) -> String {\n+        repeat(\"../\").take(self.current.len()).collect::<String>()\n+    }\n+\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n     fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n@@ -1240,7 +1237,6 @@ impl Context {\n         }\n         let prev = self.dst.clone();\n         self.dst.push(&s);\n-        self.root_path.push_str(\"../\");\n         self.current.push(s);\n \n         info!(\"Recursing into {}\", self.dst.display());\n@@ -1251,8 +1247,6 @@ impl Context {\n \n         // Go back to where we were at\n         self.dst = prev;\n-        let len = self.root_path.len();\n-        self.root_path.truncate(len - 3);\n         self.current.pop().unwrap();\n \n         return ret;\n@@ -1304,7 +1298,7 @@ impl Context {\n             title.push_str(it.name.as_ref().unwrap());\n         }\n         title.push_str(\" - Rust\");\n-        let tyname = item_type(it).css_class();\n+        let tyname = it.type_().css_class();\n         let desc = if it.is_crate() {\n             format!(\"API documentation for the Rust `{}` crate.\",\n                     self.shared.layout.krate)\n@@ -1315,7 +1309,7 @@ impl Context {\n         let keywords = make_item_keywords(it);\n         let page = layout::Page {\n             css_class: tyname,\n-            root_path: &self.root_path,\n+            root_path: &self.root_path(),\n             title: &title,\n             description: &desc,\n             keywords: &keywords,\n@@ -1329,8 +1323,7 @@ impl Context {\n                            &Item{ cx: self, item: it },\n                            self.shared.css_file_extension.is_some())?;\n         } else {\n-            let mut url = repeat(\"../\").take(self.current.len())\n-                                       .collect::<String>();\n+            let mut url = self.root_path();\n             if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n@@ -1407,7 +1400,7 @@ impl Context {\n             // buf will be empty if the item is stripped and there is no redirect for it\n             if !buf.is_empty() {\n                 let name = item.name.as_ref().unwrap();\n-                let item_type = item_type(&item);\n+                let item_type = item.type_();\n                 let file_name = &item_path(item_type, name);\n                 let joint_dst = self.dst.join(file_name);\n                 try_err!(fs::create_dir_all(&self.dst), &self.dst);\n@@ -1444,7 +1437,7 @@ impl Context {\n         for item in &m.items {\n             if maybe_ignore_item(item) { continue }\n \n-            let short = item_type(item).css_class();\n+            let short = item.type_().css_class();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -1492,7 +1485,7 @@ impl<'a> Item<'a> {\n             }).map(|l| &l.1);\n             let root = match root {\n                 Some(&Remote(ref s)) => s.to_string(),\n-                Some(&Local) => self.cx.root_path.clone(),\n+                Some(&Local) => self.cx.root_path(),\n                 None | Some(&Unknown) => return None,\n             };\n             Some(format!(\"{root}/{krate}/macro.{name}.html?gotomacrosrc=1\",\n@@ -1507,7 +1500,7 @@ impl<'a> Item<'a> {\n             let path = PathBuf::from(&self.item.source.filename);\n             self.cx.shared.local_sources.get(&path).map(|path| {\n                 format!(\"{root}src/{krate}/{path}#{href}\",\n-                        root = self.cx.root_path,\n+                        root = self.cx.root_path(),\n                         krate = self.cx.shared.layout.krate,\n                         path = path,\n                         href = href)\n@@ -1531,7 +1524,7 @@ impl<'a> Item<'a> {\n             };\n             let mut path = match cache.extern_locations.get(&self.item.def_id.krate) {\n                 Some(&(_, Remote(ref s))) => s.to_string(),\n-                Some(&(_, Local)) => self.cx.root_path.clone(),\n+                Some(&(_, Local)) => self.cx.root_path(),\n                 Some(&(_, Unknown)) => return None,\n                 None => return None,\n             };\n@@ -1541,7 +1534,7 @@ impl<'a> Item<'a> {\n             }\n             Some(format!(\"{path}{file}?gotosrc={goto}\",\n                          path = path,\n-                         file = item_path(item_type(self.item), external_path.last().unwrap()),\n+                         file = item_path(self.item.type_(), external_path.last().unwrap()),\n                          goto = self.item.def_id.index.as_usize()))\n         }\n     }\n@@ -1586,7 +1579,7 @@ impl<'a> fmt::Display for Item<'a> {\n             }\n         }\n         write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-               item_type(self.item), self.item.name.as_ref().unwrap())?;\n+               self.item.type_(), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n@@ -1739,8 +1732,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     }\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n-        let ty1 = item_type(i1);\n-        let ty2 = item_type(i2);\n+        let ty1 = i1.type_();\n+        let ty2 = i2.type_();\n         if ty1 != ty2 {\n             return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n         }\n@@ -1764,7 +1757,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             continue;\n         }\n \n-        let myty = Some(item_type(myitem));\n+        let myty = Some(myitem.type_());\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n             // Put `extern crate` and `use` re-exports in the same section.\n             curty = myty;\n@@ -1851,9 +1844,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n                        docs = shorter(Some(&Markdown(doc_value).to_string())),\n-                       class = item_type(myitem),\n+                       class = myitem.type_(),\n                        stab = myitem.stability_class(),\n-                       href = item_path(item_type(myitem), myitem.name.as_ref().unwrap()),\n+                       href = item_path(myitem.type_(), myitem.name.as_ref().unwrap()),\n                        title = full_path(cx, myitem))?;\n             }\n         }\n@@ -2059,7 +2052,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n-        let item_type = item_type(m);\n+        let item_type = m.type_();\n         let id = derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n         write!(w, \"<h3 id='{id}' class='method stab {stab}'>\\\n@@ -2145,7 +2138,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = item_type(it).css_class(),\n+           ty = it.type_().css_class(),\n            name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n@@ -2154,7 +2147,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     use html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n-    let ty = match item_type(it) {\n+    let ty = match it.type_() {\n         Typedef | AssociatedType => AssociatedType,\n         s@_ => s,\n     };\n@@ -2232,7 +2225,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               link: AssocItemLink)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", item_type(meth), name);\n+        let anchor = format!(\"#{}.{}\", meth.type_(), name);\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n             AssocItemLink::Anchor(None) => anchor,\n@@ -2740,7 +2733,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                      link: AssocItemLink, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n                      trait_: Option<&clean::Trait>) -> fmt::Result {\n-        let item_type = item_type(item);\n+        let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n         let render_method_item: bool = match render_mode {\n@@ -2918,7 +2911,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 write!(fmt, \"::<wbr>\")?;\n             }\n             write!(fmt, \"<a href='{}index.html'>{}</a>\",\n-                   &cx.root_path[..(cx.current.len() - i - 1) * 3],\n+                   &cx.root_path()[..(cx.current.len() - i - 1) * 3],\n                    *name)?;\n         }\n         write!(fmt, \"</p>\")?;\n@@ -2932,7 +2925,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                    relpath: '{path}'\\\n                 }};</script>\",\n                name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-               ty = item_type(it).css_class(),\n+               ty = it.type_().css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path"}]}