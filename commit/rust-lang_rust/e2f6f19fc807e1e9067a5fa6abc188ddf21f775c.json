{"sha": "e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZjZmMTlmYzgwN2UxZTkwNjdhNWZhNmFiYzE4OGRkZjIxZjc3NWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-08T20:19:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-08T20:19:37Z"}, "message": "rustc: Rework type substitution to pair up type parameter IDs with the supplied type parameter instantiations explicitly", "tree": {"sha": "5939555e9eeff08bef272d56f65af5c1cf5cc628", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5939555e9eeff08bef272d56f65af5c1cf5cc628"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "html_url": "https://github.com/rust-lang/rust/commit/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51be50490e277ce61d156fcf40a5d5b4057eee64", "url": "https://api.github.com/repos/rust-lang/rust/commits/51be50490e277ce61d156fcf40a5d5b4057eee64", "html_url": "https://github.com/rust-lang/rust/commit/51be50490e277ce61d156fcf40a5d5b4057eee64"}], "stats": {"total": 103, "additions": 60, "deletions": 43}, "files": [{"sha": "9634841a8365070ef0ceedcadd5cf3ccec3318d4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 60, "deletions": 43, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "patch": "@@ -85,59 +85,47 @@ fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n                         @ty.t typ,\n+                        vec[ast.def_id] ty_params,\n                         vec[@ast.ty] supplied,\n                         &span sp) -> @ty.t {\n     state obj ty_substituter(@crate_ctxt ccx,\n-                             @mutable uint i,\n-                             vec[@ast.ty] supplied,\n-                             @hashmap[int,@ty.t] substs) {\n+                             vec[ast.def_id] ty_params,\n+                             vec[@ast.ty] supplied) {\n         fn fold_simple_ty(@ty.t typ) -> @ty.t {\n             alt (typ.struct) {\n-                case (ty.ty_var(?vid)) {\n-                    alt (substs.find(vid)) {\n-                        case (some[@ty.t](?resolved_ty)) {\n-                            ret resolved_ty;\n-                        }\n-                        case (none[@ty.t]) {\n-                            if (i >= _vec.len[@ast.ty](supplied)) {\n-                                // Just leave it as an unresolved parameter\n-                                // for now. (We will error out later.)\n-                                ret typ;\n-                            }\n-\n-                            auto result = ast_ty_to_ty_crate(ccx,\n-                                                             supplied.(*i));\n-                            *i += 1u;\n-                            substs.insert(vid, result);\n-                            ret result;\n-                        }\n+                case (ty.ty_param(?pid)) {\n+                    // Find the index of the type parameter.\n+                    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n+                    auto i = 0u;\n+                    while (i < ty_param_len &&\n+                            !common.def_eq(pid, ty_params.(i))) {\n+                        i += 1u;\n+                    }\n+                    if (i == ty_param_len) {\n+                        log \"substitute_ty_params(): \" +\n+                            \"no ty param for param id!\";\n+                        fail;\n                     }\n+\n+                    // Substitute it in.\n+                    ret ast_ty_to_ty_crate(ccx, supplied.(i));\n                 }\n                 case (_) { ret typ; }\n             }\n         }\n     }\n \n-    fn hash_int(&int x) -> uint { ret x as uint; }\n-    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n-    auto hasher = hash_int;\n-    auto eqer = eq_int;\n-    auto substs = @map.mk_hashmap[int,@ty.t](hasher, eqer);\n-\n-    auto subst_count = @mutable 0u;\n-    auto substituter = ty_substituter(ccx, subst_count, supplied, substs);\n-\n-    auto result = ty.fold_ty(substituter, typ);\n-\n+    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n     auto supplied_len = _vec.len[@ast.ty](supplied);\n-    if ((*subst_count) != supplied_len) {\n-        ccx.sess.span_err(sp, \"expected \" + _uint.to_str(*subst_count, 10u) +\n+    if (ty_param_len != supplied_len) {\n+        ccx.sess.span_err(sp, \"expected \" + _uint.to_str(ty_param_len, 10u) +\n                           \" type parameter(s) but found \" +\n                           _uint.to_str(supplied_len, 10u) + \" parameter(s)\");\n         fail;\n     }\n \n-    ret result;\n+    auto substituter = ty_substituter(ccx, ty_params, supplied);\n+    ret ty.fold_ty(substituter, typ);\n }\n \n // Parses the programmer's textual representation of a type into our internal\n@@ -1476,49 +1464,60 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n+\n+            auto ty_params;\n             alt (option.get[ast.def](defopt)) {\n                 case (ast.def_arg(?id)) {\n                     check (fcx.locals.contains_key(id));\n                     t = fcx.locals.get(id);\n+                    ty_params = none[vec[ast.def_id]];\n                 }\n                 case (ast.def_local(?id)) {\n                     alt (fcx.locals.find(id)) {\n                         case (some[@ty.t](?t1)) { t = t1; }\n                         case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n                     }\n+                    ty_params = none[vec[ast.def_id]];\n                 }\n                 case (ast.def_obj_field(?id)) {\n                     check (fcx.locals.contains_key(id));\n                     t = fcx.locals.get(id);\n+                    ty_params = none[vec[ast.def_id]];\n                 }\n                 case (ast.def_fn(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n-                    t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n+                    t = fcx.ccx.item_types.get(id);\n+                    ty_params = some(fcx.ccx.item_ty_params.get(id));\n                 }\n                 case (ast.def_native_fn(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n-                    t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n+                    t = fcx.ccx.item_types.get(id);\n+                    ty_params = some(fcx.ccx.item_ty_params.get(id));\n                 }\n                 case (ast.def_const(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n                     t = fcx.ccx.item_types.get(id);\n+                    ty_params = none[vec[ast.def_id]];\n                 }\n-                case (ast.def_variant(_, ?variant_id)) {\n+                case (ast.def_variant(?tag_id, ?variant_id)) {\n                     check (fcx.ccx.item_types.contains_key(variant_id));\n-                    t = generalize_ty(fcx.ccx,\n-                                      fcx.ccx.item_types.get(variant_id));\n+                    t = fcx.ccx.item_types.get(variant_id);\n+                    ty_params = some(fcx.ccx.item_ty_params.get(tag_id));\n                 }\n                 case (ast.def_binding(?id)) {\n                     check (fcx.locals.contains_key(id));\n                     t = fcx.locals.get(id);\n+                    ty_params = none[vec[ast.def_id]];\n                 }\n                 case (ast.def_obj(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n-                    t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n+                    t = fcx.ccx.item_types.get(id);\n+                    ty_params = some(fcx.ccx.item_ty_params.get(id));\n                 }\n \n                 case (ast.def_mod(_)) {\n                     // Hopefully part of a path.\n+                    ty_params = none[vec[ast.def_id]];\n                 }\n \n                 case (_) {\n@@ -1531,8 +1530,26 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Substitute type parameters if the user provided some.\n             if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n-                t = substitute_ty_params(fcx.ccx, t, pth.node.types,\n-                                         expr.span);\n+                alt (ty_params) {\n+                    case (none[vec[ast.def_id]]) {\n+                        fcx.ccx.sess.span_err(expr.span, \"this kind of \" +\n+                                              \"item may not take type \" +\n+                                              \"parameters\");\n+                    }\n+                    case (some[vec[ast.def_id]](?tps)) {\n+                        t = substitute_ty_params(fcx.ccx, t, tps,\n+                                                 pth.node.types, expr.span);\n+                    }\n+                }\n+            } else {\n+                alt (ty_params) {\n+                    case (none[vec[ast.def_id]]) {  /* nothing */ }\n+                    case (some[vec[ast.def_id]](_)) {\n+                        // We will acquire the type parameters through\n+                        // unification.\n+                        t = generalize_ty(fcx.ccx, t);\n+                    }\n+                }\n             }\n \n             ret @fold.respan[ast.expr_](expr.span,"}]}