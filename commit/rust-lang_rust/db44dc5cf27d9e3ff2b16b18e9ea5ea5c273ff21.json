{"sha": "db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNDRkYzVjZjI3ZDllM2ZmMmIxNmIxOGU5ZWE1ZWE1YzI3M2ZmMjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T21:02:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T21:09:44Z"}, "message": "De-export gc and io. Part of #3583.", "tree": {"sha": "f09ce6b671370600be072b4edc4277a5868610ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f09ce6b671370600be072b4edc4277a5868610ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "html_url": "https://github.com/rust-lang/rust/commit/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cc61c816a0f08535f6300af4a5eaf30b8094c57", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc61c816a0f08535f6300af4a5eaf30b8094c57", "html_url": "https://github.com/rust-lang/rust/commit/8cc61c816a0f08535f6300af4a5eaf30b8094c57"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "78d9ec8fccbc6a81304b9d86339626e4ff1252a8", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "patch": "@@ -248,9 +248,7 @@ mod pipes;\n \n // Runtime and language-primitive support\n \n-#[legacy_exports]\n mod gc;\n-#[legacy_exports]\n mod io;\n mod libc;\n mod os;"}, {"sha": "f8f644a17ab87ae5bf40aad36d4fdaacbea3535f", "filename": "src/libcore/io.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "patch": "@@ -17,7 +17,6 @@ type fd_t = c_int;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_get_stdin() -> *libc::FILE;\n     fn rust_get_stdout() -> *libc::FILE;\n     fn rust_get_stderr() -> *libc::FILE;\n@@ -27,11 +26,11 @@ extern mod rustrt {\n \n // FIXME (#2004): This is all buffered. We might need an unbuffered variant\n // as well\n-enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n+pub enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n \n \n // The raw underlying reader trait. All readers must implement this.\n-trait Reader {\n+pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n     // FIXME (#2982): This should probably return an error.\n@@ -45,7 +44,7 @@ trait Reader {\n \n // Generic utility functions defined on readers\n \n-trait ReaderUtil {\n+pub trait ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8];\n     fn read_line() -> ~str;\n \n@@ -267,7 +266,7 @@ fn FILERes(f: *libc::FILE) -> FILERes {\n     }\n }\n \n-fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n+pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n     if cleanup {\n         {base: f, cleanup: FILERes(f)} as Reader\n     } else {\n@@ -279,9 +278,9 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n // top-level functions that take a reader, or a set of default methods on\n // reader (which can then be called reader)\n \n-fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n+pub fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n \n-fn file_reader(path: &Path) -> Result<Reader, ~str> {\n+pub fn file_reader(path: &Path) -> Result<Reader, ~str> {\n     let f = os::as_c_charp(path.to_str(), |pathbuf| {\n         os::as_c_charp(\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n@@ -297,7 +296,7 @@ fn file_reader(path: &Path) -> Result<Reader, ~str> {\n \n // Byte buffer readers\n \n-type ByteBuf = {buf: &[const u8], mut pos: uint};\n+pub type ByteBuf = {buf: &[const u8], mut pos: uint};\n \n impl ByteBuf: Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n@@ -326,21 +325,21 @@ impl ByteBuf: Reader {\n     fn tell() -> uint { self.pos }\n }\n \n-fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n+pub fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n     f({buf: bytes, mut pos: 0u} as Reader)\n }\n \n-fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n+pub fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n \n // Writing\n-enum FileFlag { Append, Create, Truncate, NoFlag, }\n+pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n \n // What type of writer are we?\n-enum WriterType { Screen, File }\n+pub enum WriterType { Screen, File }\n \n-impl WriterType : Eq {\n+pub impl WriterType : Eq {\n     pure fn eq(other: &WriterType) -> bool {\n         match (self, (*other)) {\n             (Screen, Screen) | (File, File) => true,\n@@ -352,7 +351,7 @@ impl WriterType : Eq {\n \n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n-trait Writer {\n+pub trait Writer {\n     fn write(v: &[const u8]);\n     fn seek(int, SeekStyle);\n     fn tell() -> uint;\n@@ -393,7 +392,7 @@ impl *libc::FILE: Writer {\n     }\n }\n \n-fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n+pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n     if cleanup {\n         {base: f, cleanup: FILERes(f)} as Writer\n     } else {\n@@ -442,7 +441,7 @@ fn FdRes(fd: fd_t) -> FdRes {\n     }\n }\n \n-fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n+pub fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n     if cleanup {\n         {base: fd, cleanup: FdRes(fd)} as Writer\n     } else {\n@@ -451,7 +450,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n }\n \n \n-fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     -> Result<Writer, ~str> {\n \n     #[cfg(windows)]\n@@ -481,7 +480,8 @@ fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     }\n }\n \n-fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n+                          f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n     match size {\n       1u => f(&[n as u8]),\n@@ -512,7 +512,8 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n-fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n+                           f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n     match size {\n       1u => f(&[n as u8]),\n@@ -543,7 +544,8 @@ fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n-fn u64_from_be_bytes(data: &[const u8], start: uint, size: uint) -> u64 {\n+pub fn u64_from_be_bytes(data: &[const u8],\n+                         start: uint, size: uint) -> u64 {\n     let mut sz = size;\n     assert (sz <= 8u);\n     let mut val = 0_u64;\n@@ -558,7 +560,7 @@ fn u64_from_be_bytes(data: &[const u8], start: uint, size: uint) -> u64 {\n \n // FIXME: #3048 combine trait+impl (or just move these to\n // default methods on writer)\n-trait WriterUtil {\n+pub trait WriterUtil {\n     fn write_char(ch: char);\n     fn write_str(s: &str);\n     fn write_line(s: &str);\n@@ -655,13 +657,13 @@ impl<T: Writer> T : WriterUtil {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<Writer, ~str> {\n+pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<Writer, ~str> {\n     mk_file_writer(path, flags).chain(|w| result::Ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n+pub fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n     let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n         do os::as_c_charp(\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n@@ -675,13 +677,13 @@ fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n // FIXME (#2004) it would be great if this could be a const\n // FIXME (#2004) why are these different from the way stdin() is\n // implemented?\n-fn stdout() -> Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n-fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n+pub fn stdout() -> Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n+pub fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n-fn print(s: &str) { stdout().write_str(s); }\n-fn println(s: &str) { stdout().write_line(s); }\n+pub fn print(s: &str) { stdout().write_str(s); }\n+pub fn println(s: &str) { stdout().write_line(s); }\n \n-struct BytesWriter {\n+pub struct BytesWriter {\n     buf: DVec<u8>,\n     mut pos: uint,\n }\n@@ -725,17 +727,17 @@ impl @BytesWriter : Writer {\n     fn get_type() -> WriterType { (*self).get_type() }\n }\n \n-fn BytesWriter() -> BytesWriter {\n+pub fn BytesWriter() -> BytesWriter {\n     BytesWriter { buf: DVec(), mut pos: 0u }\n }\n \n-fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n+pub fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     wr.buf.check_out(|buf| buf)\n }\n \n-fn with_str_writer(f: fn(Writer)) -> ~str {\n+pub fn with_str_writer(f: fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // Make sure the vector has a trailing null and is proper utf8.\n@@ -746,7 +748,7 @@ fn with_str_writer(f: fn(Writer)) -> ~str {\n }\n \n // Utility functions\n-fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n+pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n    uint {\n     let mut bpos = pos as int;\n     let blen = len as int;\n@@ -760,7 +762,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n+pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n     result::chain(read_whole_file(file), |bytes| {\n         if str::is_utf8(bytes) {\n             result::Ok(str::from_bytes(bytes))\n@@ -773,18 +775,17 @@ fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n #[allow(non_implicitly_copyable_typarams)]\n-fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n+pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n     result::chain(file_reader(file), |rdr| {\n         result::Ok(rdr.read_whole_stream())\n     })\n }\n \n // fsync related\n \n-mod fsync {\n-    #[legacy_exports];\n+pub mod fsync {\n \n-    enum Level {\n+    pub enum Level {\n         // whatever fsync does on that platform\n         FSync,\n \n@@ -799,7 +800,7 @@ mod fsync {\n \n \n     // Artifacts that need to fsync on destruction\n-    struct Res<t: Copy> {\n+    pub struct Res<t: Copy> {\n         arg: Arg<t>,\n         drop {\n           match self.arg.opt_level {\n@@ -812,13 +813,13 @@ mod fsync {\n         }\n     }\n \n-    fn Res<t: Copy>(+arg: Arg<t>) -> Res<t>{\n+    pub fn Res<t: Copy>(+arg: Arg<t>) -> Res<t>{\n         Res {\n             arg: move arg\n         }\n     }\n \n-    type Arg<t> = {\n+    pub type Arg<t> = {\n         val: t,\n         opt_level: Option<Level>,\n         fsync_fn: fn@(+f: t, Level) -> int\n@@ -827,8 +828,8 @@ mod fsync {\n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n-    fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n-                  blk: fn(+v: Res<*libc::FILE>)) {\n+    pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n+                         blk: fn(+v: Res<*libc::FILE>)) {\n         blk(move Res({\n             val: file.f, opt_level: opt_level,\n             fsync_fn: fn@(+file: *libc::FILE, l: Level) -> int {\n@@ -838,8 +839,8 @@ mod fsync {\n     }\n \n     // fsync fd after executing blk\n-    fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n-                   blk: fn(+v: Res<fd_t>)) {\n+    pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n+                       blk: fn(+v: Res<fd_t>)) {\n         blk(move Res({\n             val: fd.fd, opt_level: opt_level,\n             fsync_fn: fn@(+fd: fd_t, l: Level) -> int {\n@@ -849,11 +850,11 @@ mod fsync {\n     }\n \n     // Type of objects that may want to fsync\n-    trait FSyncable { fn fsync(l: Level) -> int; }\n+    pub trait FSyncable { fn fsync(l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    fn obj_sync(+o: FSyncable, opt_level: Option<Level>,\n-                blk: fn(+v: Res<FSyncable>)) {\n+    pub fn obj_sync(+o: FSyncable, opt_level: Option<Level>,\n+                    blk: fn(+v: Res<FSyncable>)) {\n         blk(Res({\n             val: o, opt_level: opt_level,\n             fsync_fn: fn@(+o: FSyncable, l: Level) -> int {\n@@ -865,7 +866,6 @@ mod fsync {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     #[test]\n     fn test_simple() {"}]}