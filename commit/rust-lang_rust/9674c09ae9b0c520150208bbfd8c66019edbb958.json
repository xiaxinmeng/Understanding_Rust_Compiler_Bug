{"sha": "9674c09ae9b0c520150208bbfd8c66019edbb958", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NzRjMDlhZTliMGM1MjAxNTAyMDhiYmZkOGM2NjAxOWVkYmI5NTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-11T13:03:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-11T13:03:45Z"}, "message": "Rollup merge of #69760 - Centril:parse-expr-improve, r=estebank\n\nImprove expression & attribute parsing\n\nThis PR includes misc improvements to expression and attribute parsing.\n\n1. Some code simplifications\n2. Better recovery for various block forms, e.g. `loop statements }` (missing `{` after `loop`). (See e.g., `block-no-opening-brace.rs` among others for examples.)\n3. Added recovery for e.g., `unsafe $b` where `$b` refers to a `block` macro fragment. (See `bad-interpolated-block.rs` for examples.)\n4. ^--- These are done so that code sharing in block parsing is increased.\n5. Added recovery for e.g., `'label: loop { ... }` (See `labeled-no-colon-expr.rs`.)\n6. Added recovery for e.g., `&'lifetime expr` (See `regions-out-of-scope-slice.rs`.)\n7. Added recovery for e.g., `fn foo() = expr;` (See `fn-body-eq-expr-semi.rs`.)\n8. Simplified attribute parsing code & slightly improved diagnostics.\n9. Added recovery for e.g., `Box<('a) + Trait>`.\n10. Added recovery for e.g, `if true #[attr] {} else #[attr] {} else #[attr] if true {}`.\n\nr? @estebank", "tree": {"sha": "ac9c9ede8db10ffb858a1d2d5656c1b817f75876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac9c9ede8db10ffb858a1d2d5656c1b817f75876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9674c09ae9b0c520150208bbfd8c66019edbb958", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeaOGyCRBK7hj4Ov3rIwAAdHIIAIcRrXkftGoLbGfj1pKDlG8C\nQb7stMvwmEEZIj7xNxF7ZPHgTbXALCC7fuNe4sxFT64m1u/i1yGDP8TTrj3rKsjy\n8J7tJyvr+pENC+AgsXX3m3ZLPGHcxzhBNNnc5AsY11TgoLvqlk3muF1aINTPfbzP\n23OAa8o5MAnqTwdnDSK4BdcAyfEEoF4NtqomDi83pkgD2ptqcpGXxPelw1sr2M1f\npuUABSEC7wYMqJwY484WjlArF4RCnMk3PVpxeetpB37drT2zKCfIdXcE8dEo2BHU\npWaZmslLDgvgBoPIVToqBmX06pFVmJvE7fsmjyIVj6+XS6n358HmBMoqsXzOf30=\n=SOxe\n-----END PGP SIGNATURE-----\n", "payload": "tree ac9c9ede8db10ffb858a1d2d5656c1b817f75876\nparent dde2484fce20f029748b85316e11e5218958e731\nparent 458383dd337f276d091fa2de81bb7c1d31dde5fa\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583931825 +0100\ncommitter GitHub <noreply@github.com> 1583931825 +0100\n\nRollup merge of #69760 - Centril:parse-expr-improve, r=estebank\n\nImprove expression & attribute parsing\n\nThis PR includes misc improvements to expression and attribute parsing.\n\n1. Some code simplifications\n2. Better recovery for various block forms, e.g. `loop statements }` (missing `{` after `loop`). (See e.g., `block-no-opening-brace.rs` among others for examples.)\n3. Added recovery for e.g., `unsafe $b` where `$b` refers to a `block` macro fragment. (See `bad-interpolated-block.rs` for examples.)\n4. ^--- These are done so that code sharing in block parsing is increased.\n5. Added recovery for e.g., `'label: loop { ... }` (See `labeled-no-colon-expr.rs`.)\n6. Added recovery for e.g., `&'lifetime expr` (See `regions-out-of-scope-slice.rs`.)\n7. Added recovery for e.g., `fn foo() = expr;` (See `fn-body-eq-expr-semi.rs`.)\n8. Simplified attribute parsing code & slightly improved diagnostics.\n9. Added recovery for e.g., `Box<('a) + Trait>`.\n10. Added recovery for e.g, `if true #[attr] {} else #[attr] {} else #[attr] if true {}`.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9674c09ae9b0c520150208bbfd8c66019edbb958", "html_url": "https://github.com/rust-lang/rust/commit/9674c09ae9b0c520150208bbfd8c66019edbb958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9674c09ae9b0c520150208bbfd8c66019edbb958/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde2484fce20f029748b85316e11e5218958e731", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde2484fce20f029748b85316e11e5218958e731", "html_url": "https://github.com/rust-lang/rust/commit/dde2484fce20f029748b85316e11e5218958e731"}, {"sha": "458383dd337f276d091fa2de81bb7c1d31dde5fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/458383dd337f276d091fa2de81bb7c1d31dde5fa", "html_url": "https://github.com/rust-lang/rust/commit/458383dd337f276d091fa2de81bb7c1d31dde5fa"}], "stats": {"total": 1327, "additions": 926, "deletions": 401}, "files": [{"sha": "3fc6444168e24297b8e1118ad9e1b384d9100a60", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -535,6 +535,16 @@ impl Token {\n         false\n     }\n \n+    // Is the token an interpolated block (`$b:block`)?\n+    pub fn is_whole_block(&self) -> bool {\n+        if let Interpolated(ref nt) = self.kind {\n+            if let NtBlock(..) = **nt {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     /// Returns `true` if the token is either the `mut` or `const` keyword.\n     pub fn is_mutability(&self) -> bool {\n         self.is_keyword(kw::Mut) || self.is_keyword(kw::Const)"}, {"sha": "fe75062ee503cb63fbebcaf5228fcb154d941326", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(bindings_after_at)]\n \n use rustc_ast::ast;\n use rustc_ast::token::{self, Nonterminal};"}, {"sha": "b56dd30739dae76ee75262c76e26663779ab7362", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 98, "deletions": 133, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,4 +1,4 @@\n-use super::{Parser, PathStyle, TokenType};\n+use super::{Parser, PathStyle};\n use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::token::{self, Nonterminal};\n@@ -10,63 +10,65 @@ use rustc_span::{Span, Symbol};\n use log::debug;\n \n #[derive(Debug)]\n-enum InnerAttributeParsePolicy<'a> {\n+pub(super) enum InnerAttrPolicy<'a> {\n     Permitted,\n-    NotPermitted { reason: &'a str, saw_doc_comment: bool, prev_attr_sp: Option<Span> },\n+    Forbidden { reason: &'a str, saw_doc_comment: bool, prev_attr_sp: Option<Span> },\n }\n \n const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n                                                      permitted in this context\";\n \n+pub(super) const DEFAULT_INNER_ATTR_FORBIDDEN: InnerAttrPolicy<'_> = InnerAttrPolicy::Forbidden {\n+    reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG,\n+    saw_doc_comment: false,\n+    prev_attr_sp: None,\n+};\n+\n impl<'a> Parser<'a> {\n     /// Parses attributes that appear before an item.\n     pub(super) fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         let mut just_parsed_doc_comment = false;\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n-            match self.token.kind {\n-                token::Pound => {\n-                    let inner_error_reason = if just_parsed_doc_comment {\n-                        \"an inner attribute is not permitted following an outer doc comment\"\n-                    } else if !attrs.is_empty() {\n-                        \"an inner attribute is not permitted following an outer attribute\"\n-                    } else {\n-                        DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n-                    };\n-                    let inner_parse_policy = InnerAttributeParsePolicy::NotPermitted {\n-                        reason: inner_error_reason,\n-                        saw_doc_comment: just_parsed_doc_comment,\n-                        prev_attr_sp: attrs.last().map(|a| a.span),\n-                    };\n-                    let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n-                    attrs.push(attr);\n-                    just_parsed_doc_comment = false;\n-                }\n-                token::DocComment(s) => {\n-                    let attr = self.mk_doc_comment(s);\n-                    if attr.style != ast::AttrStyle::Outer {\n-                        let span = self.token.span;\n-                        let mut err = self.struct_span_err(span, \"expected outer doc comment\");\n-                        err.note(\n+            if self.check(&token::Pound) {\n+                let inner_error_reason = if just_parsed_doc_comment {\n+                    \"an inner attribute is not permitted following an outer doc comment\"\n+                } else if !attrs.is_empty() {\n+                    \"an inner attribute is not permitted following an outer attribute\"\n+                } else {\n+                    DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n+                };\n+                let inner_parse_policy = InnerAttrPolicy::Forbidden {\n+                    reason: inner_error_reason,\n+                    saw_doc_comment: just_parsed_doc_comment,\n+                    prev_attr_sp: attrs.last().map(|a| a.span),\n+                };\n+                let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n+                attrs.push(attr);\n+                just_parsed_doc_comment = false;\n+            } else if let token::DocComment(s) = self.token.kind {\n+                let attr = self.mk_doc_comment(s);\n+                if attr.style != ast::AttrStyle::Outer {\n+                    self.struct_span_err(self.token.span, \"expected outer doc comment\")\n+                        .note(\n                             \"inner doc comments like this (starting with \\\n-                                  `//!` or `/*!`) can only appear before items\",\n-                        );\n-                        return Err(err);\n-                    }\n-                    attrs.push(attr);\n-                    self.bump();\n-                    just_parsed_doc_comment = true;\n+                              `//!` or `/*!`) can only appear before items\",\n+                        )\n+                        .emit();\n                 }\n-                _ => break,\n+                attrs.push(attr);\n+                self.bump();\n+                just_parsed_doc_comment = true;\n+            } else {\n+                break;\n             }\n         }\n         Ok(attrs)\n     }\n \n     fn mk_doc_comment(&self, s: Symbol) -> ast::Attribute {\n-        let style = comments::doc_comment_style(&s.as_str());\n-        attr::mk_doc_comment(style, s, self.token.span)\n+        attr::mk_doc_comment(comments::doc_comment_style(&s.as_str()), s, self.token.span)\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`.\n@@ -75,96 +77,67 @@ impl<'a> Parser<'a> {\n     /// attribute.\n     pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n         debug!(\"parse_attribute: permit_inner={:?} self.token={:?}\", permit_inner, self.token);\n-        let inner_parse_policy = if permit_inner {\n-            InnerAttributeParsePolicy::Permitted\n-        } else {\n-            InnerAttributeParsePolicy::NotPermitted {\n-                reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG,\n-                saw_doc_comment: false,\n-                prev_attr_sp: None,\n-            }\n-        };\n+        let inner_parse_policy =\n+            if permit_inner { InnerAttrPolicy::Permitted } else { DEFAULT_INNER_ATTR_FORBIDDEN };\n         self.parse_attribute_with_inner_parse_policy(inner_parse_policy)\n     }\n \n-    /// The same as `parse_attribute`, except it takes in an `InnerAttributeParsePolicy`\n+    /// The same as `parse_attribute`, except it takes in an `InnerAttrPolicy`\n     /// that prescribes how to handle inner attributes.\n     fn parse_attribute_with_inner_parse_policy(\n         &mut self,\n-        inner_parse_policy: InnerAttributeParsePolicy<'_>,\n+        inner_parse_policy: InnerAttrPolicy<'_>,\n     ) -> PResult<'a, ast::Attribute> {\n         debug!(\n             \"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n             inner_parse_policy, self.token\n         );\n-        let (span, item, style) = match self.token.kind {\n-            token::Pound => {\n-                let lo = self.token.span;\n-                self.bump();\n-\n-                if let InnerAttributeParsePolicy::Permitted = inner_parse_policy {\n-                    self.expected_tokens.push(TokenType::Token(token::Not));\n-                }\n-\n-                let style = if self.token == token::Not {\n-                    self.bump();\n-                    ast::AttrStyle::Inner\n-                } else {\n-                    ast::AttrStyle::Outer\n-                };\n+        let lo = self.token.span;\n+        let (span, item, style) = if self.eat(&token::Pound) {\n+            let style =\n+                if self.eat(&token::Not) { ast::AttrStyle::Inner } else { ast::AttrStyle::Outer };\n \n-                self.expect(&token::OpenDelim(token::Bracket))?;\n-                let item = self.parse_attr_item()?;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.prev_token.span;\n-\n-                let attr_sp = lo.to(hi);\n-\n-                // Emit error if inner attribute is encountered and not permitted\n-                if style == ast::AttrStyle::Inner {\n-                    if let InnerAttributeParsePolicy::NotPermitted {\n-                        reason,\n-                        saw_doc_comment,\n-                        prev_attr_sp,\n-                    } = inner_parse_policy\n-                    {\n-                        let prev_attr_note = if saw_doc_comment {\n-                            \"previous doc comment\"\n-                        } else {\n-                            \"previous outer attribute\"\n-                        };\n-\n-                        let mut diagnostic = self.struct_span_err(attr_sp, reason);\n-\n-                        if let Some(prev_attr_sp) = prev_attr_sp {\n-                            diagnostic\n-                                .span_label(attr_sp, \"not permitted following an outer attribute\")\n-                                .span_label(prev_attr_sp, prev_attr_note);\n-                        }\n-\n-                        diagnostic\n-                            .note(\n-                                \"inner attributes, like `#![no_std]`, annotate the item \\\n-                                   enclosing them, and are usually found at the beginning of \\\n-                                   source files. Outer attributes, like `#[test]`, annotate the \\\n-                                   item following them.\",\n-                            )\n-                            .emit();\n-                    }\n-                }\n+            self.expect(&token::OpenDelim(token::Bracket))?;\n+            let item = self.parse_attr_item()?;\n+            self.expect(&token::CloseDelim(token::Bracket))?;\n+            let attr_sp = lo.to(self.prev_token.span);\n \n-                (attr_sp, item, style)\n-            }\n-            _ => {\n-                let token_str = pprust::token_to_string(&self.token);\n-                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n-                return Err(self.struct_span_err(self.token.span, msg));\n+            // Emit error if inner attribute is encountered and forbidden.\n+            if style == ast::AttrStyle::Inner {\n+                self.error_on_forbidden_inner_attr(attr_sp, inner_parse_policy);\n             }\n+\n+            (attr_sp, item, style)\n+        } else {\n+            let token_str = pprust::token_to_string(&self.token);\n+            let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+            return Err(self.struct_span_err(self.token.span, msg));\n         };\n \n         Ok(attr::mk_attr_from_item(style, item, span))\n     }\n \n+    pub(super) fn error_on_forbidden_inner_attr(&self, attr_sp: Span, policy: InnerAttrPolicy<'_>) {\n+        if let InnerAttrPolicy::Forbidden { reason, saw_doc_comment, prev_attr_sp } = policy {\n+            let prev_attr_note =\n+                if saw_doc_comment { \"previous doc comment\" } else { \"previous outer attribute\" };\n+\n+            let mut diag = self.struct_span_err(attr_sp, reason);\n+\n+            if let Some(prev_attr_sp) = prev_attr_sp {\n+                diag.span_label(attr_sp, \"not permitted following an outer attribute\")\n+                    .span_label(prev_attr_sp, prev_attr_note);\n+            }\n+\n+            diag.note(\n+                \"inner attributes, like `#![no_std]`, annotate the item enclosing them, \\\n+                and are usually found at the beginning of source files. \\\n+                Outer attributes, like `#[test]`, annotate the item following them.\",\n+            )\n+            .emit();\n+        }\n+    }\n+\n     /// Parses an inner part of an attribute (the path and following tokens).\n     /// The tokens must be either a delimited token stream, or empty token stream,\n     /// or the \"legacy\" key-value form.\n@@ -200,28 +173,22 @@ impl<'a> Parser<'a> {\n     crate fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n-            match self.token.kind {\n-                token::Pound => {\n-                    // Don't even try to parse if it's not an inner attribute.\n-                    if !self.look_ahead(1, |t| t == &token::Not) {\n-                        break;\n-                    }\n-\n-                    let attr = self.parse_attribute(true)?;\n-                    assert_eq!(attr.style, ast::AttrStyle::Inner);\n+            // Only try to parse if it is an inner attribute (has `!`).\n+            if self.check(&token::Pound) && self.look_ahead(1, |t| t == &token::Not) {\n+                let attr = self.parse_attribute(true)?;\n+                assert_eq!(attr.style, ast::AttrStyle::Inner);\n+                attrs.push(attr);\n+            } else if let token::DocComment(s) = self.token.kind {\n+                // We need to get the position of this token before we bump.\n+                let attr = self.mk_doc_comment(s);\n+                if attr.style == ast::AttrStyle::Inner {\n                     attrs.push(attr);\n+                    self.bump();\n+                } else {\n+                    break;\n                 }\n-                token::DocComment(s) => {\n-                    // We need to get the position of this token before we bump.\n-                    let attr = self.mk_doc_comment(s);\n-                    if attr.style == ast::AttrStyle::Inner {\n-                        attrs.push(attr);\n-                        self.bump();\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                _ => break,\n+            } else {\n+                break;\n             }\n         }\n         Ok(attrs)\n@@ -232,12 +199,10 @@ impl<'a> Parser<'a> {\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n-            let msg = \"suffixed literals are not allowed in attributes\";\n-            self.struct_span_err(lit.span, msg)\n+            self.struct_span_err(lit.span, \"suffixed literals are not allowed in attributes\")\n                 .help(\n-                    \"instead of using a suffixed literal \\\n-                                    (`1u8`, `1.0f32`, etc.), use an unsuffixed version \\\n-                                    (`1`, `1.0`, etc.)\",\n+                    \"instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), \\\n+                    use an unsuffixed version (`1`, `1.0`, etc.)\",\n                 )\n                 .emit();\n         }"}, {"sha": "7f6f90431fc940a3dbfec9ca3247ff22efeee51e", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 100, "deletions": 31, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -673,10 +673,28 @@ impl<'a> Parser<'a> {\n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n     fn parse_borrow_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n+        let has_lifetime = self.token.is_lifetime() && self.look_ahead(1, |t| t != &token::Colon);\n+        let lifetime = has_lifetime.then(|| self.expect_lifetime()); // For recovery, see below.\n         let (borrow_kind, mutbl) = self.parse_borrow_modifiers(lo);\n         let expr = self.parse_prefix_expr(None);\n-        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n-        Ok((lo.to(span), ExprKind::AddrOf(borrow_kind, mutbl, expr)))\n+        let (hi, expr) = self.interpolated_or_expr_span(expr)?;\n+        let span = lo.to(hi);\n+        if let Some(lt) = lifetime {\n+            self.error_remove_borrow_lifetime(span, lt.ident.span);\n+        }\n+        Ok((span, ExprKind::AddrOf(borrow_kind, mutbl, expr)))\n+    }\n+\n+    fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n+        self.struct_span_err(span, \"borrow expressions cannot be annotated with lifetimes\")\n+            .span_label(lt_span, \"annotated with lifetime here\")\n+            .span_suggestion(\n+                lt_span,\n+                \"remove the lifetime annotation\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -901,7 +919,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_lt() {\n             let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n             Ok(self.mk_expr(lo.to(path.span), ExprKind::Path(Some(qself), path), attrs))\n-        } else if self.token.is_path_start() {\n+        } else if self.check_path() {\n             self.parse_path_start_expr(attrs)\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n             self.parse_closure_expr(attrs)\n@@ -1067,26 +1085,44 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    /// Parse `'label: $expr`. The label is already parsed.\n     fn parse_labeled_expr(&mut self, label: Label, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n-        self.expect(&token::Colon)?;\n-        if self.eat_keyword(kw::While) {\n-            return self.parse_while_expr(Some(label), lo, attrs);\n-        }\n-        if self.eat_keyword(kw::For) {\n-            return self.parse_for_expr(Some(label), lo, attrs);\n-        }\n-        if self.eat_keyword(kw::Loop) {\n-            return self.parse_loop_expr(Some(label), lo, attrs);\n-        }\n-        if self.token == token::OpenDelim(token::Brace) {\n-            return self.parse_block_expr(Some(label), lo, BlockCheckMode::Default, attrs);\n+        let label = Some(label);\n+        let ate_colon = self.eat(&token::Colon);\n+        let expr = if self.eat_keyword(kw::While) {\n+            self.parse_while_expr(label, lo, attrs)\n+        } else if self.eat_keyword(kw::For) {\n+            self.parse_for_expr(label, lo, attrs)\n+        } else if self.eat_keyword(kw::Loop) {\n+            self.parse_loop_expr(label, lo, attrs)\n+        } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n+            self.parse_block_expr(label, lo, BlockCheckMode::Default, attrs)\n+        } else {\n+            let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n+            self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n+            // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n+            self.parse_expr()\n+        }?;\n+\n+        if !ate_colon {\n+            self.error_labeled_expr_must_be_followed_by_colon(lo, expr.span);\n         }\n \n-        let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-        self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n-        // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n-        self.parse_expr()\n+        Ok(expr)\n+    }\n+\n+    fn error_labeled_expr_must_be_followed_by_colon(&self, lo: Span, span: Span) {\n+        self.struct_span_err(span, \"labeled expression must be followed by `:`\")\n+            .span_label(lo, \"the label\")\n+            .span_suggestion_short(\n+                lo.shrink_to_hi(),\n+                \"add `:` after the label\",\n+                \": \".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .note(\"labels are used before loops and blocks, allowing e.g., `break 'label` to them\")\n+            .emit();\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n@@ -1363,18 +1399,20 @@ impl<'a> Parser<'a> {\n         opt_label: Option<Label>,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-        outer_attrs: AttrVec,\n+        mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n             self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n         }\n \n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        let mut attrs = outer_attrs;\n-        attrs.extend(self.parse_inner_attributes()?);\n+        if self.token.is_whole_block() {\n+            self.struct_span_err(self.token.span, \"cannot use a `block` macro fragment here\")\n+                .span_label(lo.to(self.token.span), \"the `block` fragment is within this context\")\n+                .emit();\n+        }\n \n-        let blk = self.parse_block_tail(lo, blk_mode)?;\n+        let (inner_attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n+        attrs.extend(inner_attrs);\n         Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n@@ -1476,13 +1514,16 @@ impl<'a> Parser<'a> {\n         let thn = if self.eat_keyword(kw::Else) || !cond.returns() {\n             self.error_missing_if_cond(lo, cond.span)\n         } else {\n+            let attrs = self.parse_outer_attributes()?; // For recovery.\n             let not_block = self.token != token::OpenDelim(token::Brace);\n-            self.parse_block().map_err(|mut err| {\n+            let block = self.parse_block().map_err(|mut err| {\n                 if not_block {\n                     err.span_label(lo, \"this `if` expression has a condition, but no block\");\n                 }\n                 err\n-            })?\n+            })?;\n+            self.error_on_if_block_attrs(lo, false, block.span, &attrs);\n+            block\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n@@ -1524,12 +1565,40 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.eat_keyword(kw::If) {\n-            self.parse_if_expr(AttrVec::new())\n+        let ctx_span = self.prev_token.span; // `else`\n+        let attrs = self.parse_outer_attributes()?; // For recovery.\n+        let expr = if self.eat_keyword(kw::If) {\n+            self.parse_if_expr(AttrVec::new())?\n         } else {\n             let blk = self.parse_block()?;\n-            Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()))\n-        }\n+            self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new())\n+        };\n+        self.error_on_if_block_attrs(ctx_span, true, expr.span, &attrs);\n+        Ok(expr)\n+    }\n+\n+    fn error_on_if_block_attrs(\n+        &self,\n+        ctx_span: Span,\n+        is_ctx_else: bool,\n+        branch_span: Span,\n+        attrs: &[ast::Attribute],\n+    ) {\n+        let (span, last) = match attrs {\n+            [] => return,\n+            [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n+        };\n+        let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n+        self.struct_span_err(last, \"outer attributes are not allowed on `if` and `else` branches\")\n+            .span_label(branch_span, \"the attributes are attached to this branch\")\n+            .span_label(ctx_span, format!(\"the branch belongs to this `{}`\", ctx))\n+            .span_suggestion(\n+                span,\n+                \"remove the attributes\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten)."}, {"sha": "3932bbd7564c385f374ab73cdd602a2c35780186", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -218,7 +218,7 @@ impl<'a> Parser<'a> {\n         } else if vis.node.is_pub() && self.isnt_macro_invocation() {\n             self.recover_missing_kw_before_item()?;\n             return Ok(None);\n-        } else if macros_allowed && self.token.is_path_start() {\n+        } else if macros_allowed && self.check_path() {\n             // MACRO INVOCATION ITEM\n             (Ident::invalid(), ItemKind::Mac(self.parse_item_macro(vis)?))\n         } else {\n@@ -352,8 +352,7 @@ impl<'a> Parser<'a> {\n     fn recover_attrs_no_item(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n         let (start, end) = match attrs {\n             [] => return Ok(()),\n-            [x0] => (x0, x0),\n-            [x0, .., xn] => (x0, xn),\n+            [x0 @ xn] | [x0, .., xn] => (x0, xn),\n         };\n         let msg = if end.is_doc_comment() {\n             \"expected item after doc comment\"\n@@ -1411,23 +1410,28 @@ impl<'a> Parser<'a> {\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the function is a provided one.\n     fn parse_fn_body(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, Option<P<Block>>> {\n-        let (inner_attrs, body) = match self.token.kind {\n-            token::Semi => {\n-                self.bump();\n-                (Vec::new(), None)\n-            }\n-            token::OpenDelim(token::Brace) => {\n-                let (attrs, body) = self.parse_inner_attrs_and_block()?;\n-                (attrs, Some(body))\n-            }\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtBlock(..) => {\n-                    let (attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    (attrs, Some(body))\n-                }\n-                _ => return self.expected_semi_or_open_brace(),\n-            },\n-            _ => return self.expected_semi_or_open_brace(),\n+        let (inner_attrs, body) = if self.check(&token::Semi) {\n+            self.bump(); // `;`\n+            (Vec::new(), None)\n+        } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n+            self.parse_inner_attrs_and_block().map(|(attrs, body)| (attrs, Some(body)))?\n+        } else if self.token.kind == token::Eq {\n+            // Recover `fn foo() = $expr;`.\n+            self.bump(); // `=`\n+            let eq_sp = self.prev_token.span;\n+            let _ = self.parse_expr()?;\n+            self.expect_semi()?; // `;`\n+            let span = eq_sp.to(self.prev_token.span);\n+            self.struct_span_err(span, \"function body cannot be `= expression;`\")\n+                .multipart_suggestion(\n+                    \"surround the expression with `{` and `}` instead of `=` and `;`\",\n+                    vec![(eq_sp, \"{\".to_string()), (self.prev_token.span, \" }\".to_string())],\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            (Vec::new(), Some(self.mk_block_err(span)))\n+        } else {\n+            return self.expected_semi_or_open_brace();\n         };\n         attrs.extend(inner_attrs);\n         Ok(body)"}, {"sha": "5f2b3b03488b4a4981cb7278481a52b8fc03ac03", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -704,7 +704,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.token.is_path_start() {\n+        if self.check_path() {\n             let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path"}, {"sha": "489549a57505fa43ce88fee18fc105c6cd2a0a87", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,3 +1,4 @@\n+use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n use super::diagnostics::Error;\n use super::expr::LhsExpr;\n use super::pat::GateOr;\n@@ -47,10 +48,7 @@ impl<'a> Parser<'a> {\n             self.bump(); // `var`\n             let msg = \"write `let` instead of `var` to introduce a new variable\";\n             self.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n-        } else if self.token.is_path_start()\n-            && !self.token.is_qpath_start()\n-            && !self.is_path_start_item()\n-        {\n+        } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n@@ -238,15 +236,11 @@ impl<'a> Parser<'a> {\n \n     /// Parses a block. No inner attributes are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n-        maybe_whole!(self, NtBlock, |x| x);\n-\n-        let lo = self.token.span;\n-\n-        if !self.eat(&token::OpenDelim(token::Brace)) {\n-            return self.error_block_no_opening_brace();\n+        let (attrs, block) = self.parse_inner_attrs_and_block()?;\n+        if let [.., last] = &*attrs {\n+            self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);\n         }\n-\n-        self.parse_block_tail(lo, BlockCheckMode::Default)\n+        Ok(block)\n     }\n \n     fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n@@ -262,16 +256,14 @@ impl<'a> Parser<'a> {\n         //\n         // which is valid in other languages, but not Rust.\n         match self.parse_stmt_without_recovery() {\n-            Ok(Some(stmt)) => {\n+            // If the next token is an open brace (e.g., `if a b {`), the place-\n+            // inside-a-block suggestion would be more likely wrong than right.\n+            Ok(Some(_))\n                 if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n-                    || do_not_suggest_help\n-                {\n-                    // If the next token is an open brace (e.g., `if a b {`), the place-\n-                    // inside-a-block suggestion would be more likely wrong than right.\n-                    e.span_label(sp, \"expected `{`\");\n-                    return Err(e);\n-                }\n-                let stmt_span = if self.eat(&token::Semi) {\n+                    || do_not_suggest_help => {}\n+            Ok(Some(stmt)) => {\n+                let stmt_own_line = self.sess.source_map().is_line_before_span_empty(sp);\n+                let stmt_span = if stmt_own_line && self.eat(&token::Semi) {\n                     // Expand the span to include the semicolon.\n                     stmt.span.with_hi(self.prev_token.span.hi())\n                 } else {\n@@ -300,21 +292,28 @@ impl<'a> Parser<'a> {\n     /// Parses a block. Inner attributes are allowed.\n     pub(super) fn parse_inner_attrs_and_block(\n         &mut self,\n+    ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n+        self.parse_block_common(self.token.span, BlockCheckMode::Default)\n+    }\n+\n+    /// Parses a block. Inner attributes are allowed.\n+    pub(super) fn parse_block_common(\n+        &mut self,\n+        lo: Span,\n+        blk_mode: BlockCheckMode,\n     ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n-        let lo = self.token.span;\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-        Ok((self.parse_inner_attributes()?, self.parse_block_tail(lo, BlockCheckMode::Default)?))\n+        if !self.eat(&token::OpenDelim(token::Brace)) {\n+            return self.error_block_no_opening_brace();\n+        }\n+\n+        Ok((self.parse_inner_attributes()?, self.parse_block_tail(lo, blk_mode)?))\n     }\n \n     /// Parses the rest of a block expression or function body.\n     /// Precondition: already parsed the '{'.\n-    pub(super) fn parse_block_tail(\n-        &mut self,\n-        lo: Span,\n-        s: BlockCheckMode,\n-    ) -> PResult<'a, P<Block>> {\n+    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             if self.token == token::Eof {"}, {"sha": "3dd415bf37289bd2683845e7f47dc4d3eee46ad4", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -142,24 +142,20 @@ impl<'a> Parser<'a> {\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n                 let parse_plus = allow_plus == AllowPlus::Yes && self.check_plus();\n-                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n+                self.parse_remaining_bounds_path(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(kw::Impl) {\n             self.parse_impl_ty(&mut impl_dyn_multi)?\n         } else if self.is_explicit_dyn_type() {\n             self.parse_dyn_ty(&mut impl_dyn_multi)?\n-        } else if self.check(&token::Question)\n-            || self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus())\n-        {\n-            // Bound list (trait object type)\n-            let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n-            TyKind::TraitObject(bounds, TraitObjectSyntax::None)\n         } else if self.eat_lt() {\n             // Qualified path\n             let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n-        } else if self.token.is_path_start() {\n+        } else if self.check_path() {\n             self.parse_path_start_ty(lo, allow_plus)?\n+        } else if self.can_begin_bound() {\n+            self.parse_bare_trait_object(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n             if allow_c_variadic == AllowCVariadic::Yes {\n                 TyKind::CVarArgs\n@@ -203,21 +199,12 @@ impl<'a> Parser<'a> {\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                 TyKind::Path(None, path) if maybe_bounds => {\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                    self.parse_remaining_bounds_path(Vec::new(), path, lo, true)\n                 }\n-                TyKind::TraitObject(mut bounds, TraitObjectSyntax::None)\n+                TyKind::TraitObject(bounds, TraitObjectSyntax::None)\n                     if maybe_bounds && bounds.len() == 1 && !trailing_plus =>\n                 {\n-                    let path = match bounds.remove(0) {\n-                        GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n-                        GenericBound::Outlives(..) => {\n-                            return Err(self.struct_span_err(\n-                                ty.span,\n-                                \"expected trait bound, not lifetime bound\",\n-                            ));\n-                        }\n-                    };\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                    self.parse_remaining_bounds(bounds, true)\n                 }\n                 // `(TYPE)`\n                 _ => Ok(TyKind::Paren(P(ty))),\n@@ -227,18 +214,35 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_remaining_bounds(\n+    fn parse_bare_trait_object(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n+        let lt_no_plus = self.check_lifetime() && !self.look_ahead(1, |t| t.is_like_plus());\n+        let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n+        if lt_no_plus {\n+            self.struct_span_err(lo, \"lifetime in trait object type must be followed by `+`\").emit()\n+        }\n+        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n+    }\n+\n+    fn parse_remaining_bounds_path(\n         &mut self,\n         generic_params: Vec<GenericParam>,\n         path: ast::Path,\n         lo: Span,\n         parse_plus: bool,\n     ) -> PResult<'a, TyKind> {\n-        assert_ne!(self.token, token::Question);\n-\n         let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_token.span));\n-        let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n-        if parse_plus {\n+        let bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n+        self.parse_remaining_bounds(bounds, parse_plus)\n+    }\n+\n+    /// Parse the remainder of a bare trait object type given an already parsed list.\n+    fn parse_remaining_bounds(\n+        &mut self,\n+        mut bounds: GenericBounds,\n+        plus: bool,\n+    ) -> PResult<'a, TyKind> {\n+        assert_ne!(self.token, token::Question);\n+        if plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n             bounds.append(&mut self.parse_generic_bounds(Some(self.prev_token.span))?);\n         }\n@@ -358,7 +362,7 @@ impl<'a> Parser<'a> {\n             }))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n-            self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+            self.parse_remaining_bounds_path(Vec::new(), path, lo, true)\n         } else {\n             // Just a type path.\n             Ok(TyKind::Path(None, path))"}, {"sha": "353f7b3f52bc3d10fa22f1e17c8141bd115ee312", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -517,6 +517,13 @@ impl SourceMap {\n         Ok((lo, hi))\n     }\n \n+    pub fn is_line_before_span_empty(&self, sp: Span) -> bool {\n+        match self.span_to_prev_source(sp) {\n+            Ok(s) => s.split('\\n').last().map(|l| l.trim_start().is_empty()).unwrap_or(false),\n+            Err(_) => false,\n+        }\n+    }\n+\n     pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n         debug!(\"span_to_lines(sp={:?})\", sp);\n         let (lo, hi) = self.is_valid_span(sp)?;"}, {"sha": "76e87a3749c33a5b8f2849c41707741b14b78dc6", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -32,11 +32,11 @@ LL |     X() {}\n LL | }\n    | - the item list ends here\n \n-error: expected `[`, found `#`\n+error: expected one of `!` or `[`, found `#`\n   --> $DIR/issue-40006.rs:19:17\n    |\n LL |     fn xxx() { ### }\n-   |                 ^ expected `[`\n+   |                 ^ expected one of `!` or `[`\n \n error: expected one of `!` or `::`, found `=`\n   --> $DIR/issue-40006.rs:22:7"}, {"sha": "6eb25a92f34133587558e8196be83835d03d9a88", "filename": "src/test/ui/generic-associated-types/empty_generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -3,7 +3,7 @@\n \n trait Foo {\n     type Bar<,>;\n-    //~^ ERROR expected one of `>`, `const`, identifier, or lifetime, found `,`\n+    //~^ ERROR expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n }\n \n fn main() {}"}, {"sha": "1599d683ad6dd7dc078b9e9b01d0c80a446cd9c8", "filename": "src/test/ui/generic-associated-types/empty_generics.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,10 +1,10 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/empty_generics.rs:5:14\n    |\n LL | trait Foo {\n    |           - while parsing this item list starting here\n LL |     type Bar<,>;\n-   |              ^ expected one of `>`, `const`, identifier, or lifetime\n+   |              ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n LL |\n LL | }\n    | - the item list ends here"}, {"sha": "85da7cf6bb8c3d453cc2558e11aac91b1f6e58b9", "filename": "src/test/ui/if-attrs/else-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -8,7 +8,7 @@ fn if_else_parse_error() {\n #[cfg(FALSE)]\n fn else_attr_ifparse_error() {\n     if true {\n-    } else #[attr] if false { //~ ERROR expected\n+    } else #[attr] if false { //~ ERROR outer attributes are not allowed\n     } else {\n     }\n }"}, {"sha": "2733377054d7d93df1d1cc38e7ff4ed361a5963a", "filename": "src/test/ui/if-attrs/else-attrs.stderr", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -4,18 +4,17 @@ error: expected expression, found keyword `else`\n LL |     } #[attr] else if false {\n    |               ^^^^ expected expression\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/else-attrs.rs:11:12\n    |\n-LL |     } else #[attr] if false {\n-   |            ^ expected `{`\n-   |\n-help: try placing this code inside a block\n-   |\n-LL |     } else #[attr] { if false {\n-LL |     } else {\n-LL |     } }\n-   |\n+LL |       } else #[attr] if false {\n+   |  _______----_^^^^^^^_-\n+   | |       |    |\n+   | |       |    help: remove the attributes\n+   | |       the branch belongs to this `else`\n+LL | |     } else {\n+LL | |     }\n+   | |_____- the attributes are attached to this branch\n \n error: expected expression, found keyword `else`\n   --> $DIR/else-attrs.rs:20:15"}, {"sha": "3ceb58d1252d315c67e63d44b318aace5d719b31", "filename": "src/test/ui/issues/issue-20616-8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -29,7 +29,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n \n \n type Type_8<'a,,> = &'a ();\n-//~^ error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+//~^ error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n \n \n //type Type_9<T,,> = Box<T>; // error: expected identifier, found `,`"}, {"sha": "e9f37e50fffec7e02ce674346c82b42f5f932c45", "filename": "src/test/ui/issues/issue-20616-8.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/issue-20616-8.rs:31:16\n    |\n LL | type Type_8<'a,,> = &'a ();\n-   |                ^ expected one of `>`, `const`, identifier, or lifetime\n+   |                ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n \n error: aborting due to previous error\n "}, {"sha": "7f84284481e2f02e07fc82788163d6e01bf1d98d", "filename": "src/test/ui/issues/issue-20616-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -32,4 +32,4 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n \n \n type Type_9<T,,> = Box<T>;\n-//~^ error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+//~^ error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`"}, {"sha": "dc309d1bce1586c12e35eb3fae926ca6a246edf8", "filename": "src/test/ui/issues/issue-20616-9.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/issue-20616-9.rs:34:15\n    |\n LL | type Type_9<T,,> = Box<T>;\n-   |               ^ expected one of `>`, `const`, identifier, or lifetime\n+   |               ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n \n error: aborting due to previous error\n "}, {"sha": "9db4521bb423926b5dba771279e0e245581d51be", "filename": "src/test/ui/issues/issue-66473.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-66473.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-66473.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66473.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958"}, {"sha": "b370b125cfefda4f82cbb4866fec528b1465a2ef", "filename": "src/test/ui/issues/issue-66473.stderr", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-66473.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fissues%2Fissue-66473.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66473.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958"}, {"sha": "a2c75882be0ca3d76d19efb4f9edfb46a5ad08ba", "filename": "src/test/ui/label/label_break_value_illegal_uses.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -2,7 +2,10 @@ error: expected `{`, found `'b`\n   --> $DIR/label_break_value_illegal_uses.rs:6:12\n    |\n LL |     unsafe 'b: {}\n-   |            ^^ expected `{`\n+   |            ^^----\n+   |            |\n+   |            expected `{`\n+   |            help: try placing this code inside a block: `{ 'b: {} }`\n \n error: expected `{`, found `'b`\n   --> $DIR/label_break_value_illegal_uses.rs:10:13"}, {"sha": "09f494bdc2fed2b6a8cf2d25ea4eea15652de015", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -39,35 +39,35 @@ fn main() {}\n #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n //~^ ERROR expected one of\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n //~^ ERROR expected one of\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n "}, {"sha": "6dfe7aad6ea64b3412b04c781e26fcd907c0744c", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -136,14 +136,14 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:41:37\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n-   |                                --   ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                --   ^^^^^^^ -- the attributes are attached to this branch\n    |                                |    |\n-   |                                |    expected `{`\n-   |                                this `if` expression has a condition, but no block\n+   |                                |    help: remove the attributes\n+   |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:43:38\n@@ -159,13 +159,14 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n    |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n-   |                                             ^       --- help: try placing this code inside a block: `{ {}; }`\n-   |                                             |\n-   |                                             expected `{`\n+   |                                        ---- ^^^^^^^ -- the attributes are attached to this branch\n+   |                                        |    |\n+   |                                        |    help: remove the attributes\n+   |                                        the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:49:46\n@@ -175,22 +176,23 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n-   |                                             ^       -------- help: try placing this code inside a block: `{ if 0 {}; }`\n-   |                                             |\n-   |                                             expected `{`\n+   |                                        ---- ^^^^^^^ ------- the attributes are attached to this branch\n+   |                                        |    |\n+   |                                        |    help: remove the attributes\n+   |                                        the branch belongs to this `else`\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:53:50\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n-   |                                             --   ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                             --   ^^^^^^^ -- the attributes are attached to this branch\n    |                                             |    |\n-   |                                             |    expected `{`\n-   |                                             this `if` expression has a condition, but no block\n+   |                                             |    help: remove the attributes\n+   |                                             the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:55:51\n@@ -200,14 +202,14 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:57:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n-   |                                --           ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                --           ^^^^^^^ -- the attributes are attached to this branch\n    |                                |            |\n-   |                                |            expected `{`\n-   |                                this `if` expression has a condition, but no block\n+   |                                |            help: remove the attributes\n+   |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:59:46\n@@ -223,13 +225,14 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n    |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:63:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n-   |                                                     ^       --- help: try placing this code inside a block: `{ {}; }`\n-   |                                                     |\n-   |                                                     expected `{`\n+   |                                                ---- ^^^^^^^ -- the attributes are attached to this branch\n+   |                                                |    |\n+   |                                                |    help: remove the attributes\n+   |                                                the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:65:54\n@@ -239,22 +242,23 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:67:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n-   |                                                     ^       ---------------- help: try placing this code inside a block: `{ if let _ = 0 {}; }`\n-   |                                                     |\n-   |                                                     expected `{`\n+   |                                                ---- ^^^^^^^ --------------- the attributes are attached to this branch\n+   |                                                |    |\n+   |                                                |    help: remove the attributes\n+   |                                                the branch belongs to this `else`\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:69:66\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n-   |                                                     --           ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                                     --           ^^^^^^^ -- the attributes are attached to this branch\n    |                                                     |            |\n-   |                                                     |            expected `{`\n-   |                                                     this `if` expression has a condition, but no block\n+   |                                                     |            help: remove the attributes\n+   |                                                     the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:71:67"}, {"sha": "38d53a14bc0bc7e52419e6eb29e067ae3abacbdc", "filename": "src/test/ui/parser/bad-interpolated-block.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,15 @@\n+#![feature(label_break_value)]\n+\n+fn main() {}\n+\n+macro_rules! m {\n+    ($b:block) => {\n+        'lab: $b; //~ ERROR cannot use a `block` macro fragment here\n+        unsafe $b; //~ ERROR cannot use a `block` macro fragment here\n+        |x: u8| -> () $b; //~ ERROR cannot use a `block` macro fragment here\n+    }\n+}\n+\n+fn foo() {\n+    m!({});\n+}"}, {"sha": "2cbb6a13e74b9b192b790b05fe8bfc07d9e470da", "filename": "src/test/ui/parser/bad-interpolated-block.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,39 @@\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/bad-interpolated-block.rs:7:15\n+   |\n+LL |         'lab: $b;\n+   |         ------^^\n+   |         |\n+   |         the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/bad-interpolated-block.rs:8:16\n+   |\n+LL |         unsafe $b;\n+   |         -------^^\n+   |         |\n+   |         the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/bad-interpolated-block.rs:9:23\n+   |\n+LL |         |x: u8| -> () $b;\n+   |                       ^^ the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "e4bb39f6836b48c9ca7570acb29509f820fa379c", "filename": "src/test/ui/parser/block-no-opening-brace.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,31 @@\n+// edition:2018\n+\n+#![feature(try_blocks)]\n+\n+fn main() {}\n+\n+fn f1() {\n+    loop\n+        let x = 0; //~ ERROR expected `{`, found keyword `let`\n+        drop(0);\n+    }\n+\n+fn f2() {\n+    while true\n+        let x = 0; //~ ERROR expected `{`, found keyword `let`\n+    }\n+\n+fn f3() {\n+    for x in 0..1\n+        let x = 0; //~ ERROR expected `{`, found keyword `let`\n+    }\n+\n+fn f4() {\n+    try //~ ERROR expected expression, found reserved keyword `try`\n+        let x = 0;\n+    }\n+\n+fn f5() {\n+    async //~ ERROR async closures are unstable\n+        let x = 0; //~ ERROR expected one of `move`, `|`, or `||`, found keyword `let`\n+    }"}, {"sha": "a88e4ac44cfda5f75bf1d25f7f2ac2d7156abf3a", "filename": "src/test/ui/parser/block-no-opening-brace.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,53 @@\n+error: expected `{`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:9:9\n+   |\n+LL |         let x = 0;\n+   |         ^^^-------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ let x = 0; }`\n+\n+error: expected `{`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:15:9\n+   |\n+LL |         let x = 0;\n+   |         ^^^-------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ let x = 0; }`\n+\n+error: expected `{`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:20:9\n+   |\n+LL |         let x = 0;\n+   |         ^^^-------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ let x = 0; }`\n+\n+error: expected expression, found reserved keyword `try`\n+  --> $DIR/block-no-opening-brace.rs:24:5\n+   |\n+LL |     try\n+   |     ^^^ expected expression\n+\n+error: expected one of `move`, `|`, or `||`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:30:9\n+   |\n+LL |     async\n+   |          - expected one of `move`, `|`, or `||`\n+LL |         let x = 0;\n+   |         ^^^ unexpected token\n+\n+error[E0658]: async closures are unstable\n+  --> $DIR/block-no-opening-brace.rs:29:5\n+   |\n+LL |     async\n+   |     ^^^^^\n+   |\n+   = note: see issue #62290 <https://github.com/rust-lang/rust/issues/62290> for more information\n+   = help: add `#![feature(async_closure)]` to the crate attributes to enable\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c9251ac5321851c786cc06862790481505887481", "filename": "src/test/ui/parser/bounds-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -6,6 +6,6 @@ type A = for<'a: 'b + 'c> fn(); // OK (rejected later by ast_validation)\n type A = for<'a: 'b,> fn(); // OK(rejected later by ast_validation)\n type A = for<'a: 'b +> fn(); // OK (rejected later by ast_validation)\n type A = for<'a, T> fn(); // OK (rejected later by ast_validation)\n-type A = for<,> fn(); //~ ERROR expected one of `>`, `const`, identifier, or lifetime, found `,`\n+type A = for<,> fn(); //~ ERROR expected one of `#`, `>`, `const`, identifier, or lifetime\n \n fn main() {}"}, {"sha": "e47a21d892b2f745a68e92e7bb3982409d9a1d6f", "filename": "src/test/ui/parser/bounds-lifetime.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/bounds-lifetime.rs:9:14\n    |\n LL | type A = for<,> fn();\n-   |              ^ expected one of `>`, `const`, identifier, or lifetime\n+   |              ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n \n error: aborting due to previous error\n "}, {"sha": "c6a08abeff4ba76d1094bddf8618a08c9f2e091d", "filename": "src/test/ui/parser/closure-return-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -3,5 +3,5 @@\n \n fn main() {\n     let x = || -> i32 22;\n-    //~^ ERROR expected one of `!`, `(`, `+`, `::`, `<`, or `{`, found `22`\n+    //~^ ERROR expected `{`, found `22`\n }"}, {"sha": "1ccdd977305559e318cd35b99b035fc08b9929b2", "filename": "src/test/ui/parser/closure-return-syntax.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,11 @@\n-error: expected one of `!`, `(`, `+`, `::`, `<`, or `{`, found `22`\n+error: expected `{`, found `22`\n   --> $DIR/closure-return-syntax.rs:5:23\n    |\n LL |     let x = || -> i32 22;\n-   |                       ^^ expected one of `!`, `(`, `+`, `::`, `<`, or `{`\n+   |                       ^^\n+   |                       |\n+   |                       expected `{`\n+   |                       help: try placing this code inside a block: `{ 22 }`\n \n error: aborting due to previous error\n "}, {"sha": "0c24478c25c8b62af03ed797833d1a9c9902f0c5", "filename": "src/test/ui/parser/column-offset-1-based.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1 +1 @@\n-# //~ ERROR expected `[`, found `<eof>`\n+# //~ ERROR expected one of `!` or `[`, found `<eof>`"}, {"sha": "766d72a0a5a93b9cef808048fdad8c6fb3753225", "filename": "src/test/ui/parser/column-offset-1-based.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,8 @@\n-error: expected `[`, found `<eof>`\n+error: expected one of `!` or `[`, found `<eof>`\n   --> $DIR/column-offset-1-based.rs:1:1\n    |\n LL | #\n-   | ^ expected `[`\n+   | ^ expected one of `!` or `[`\n \n error: aborting due to previous error\n "}, {"sha": "343eac1b81ff0dc958a0e183ec9bdb11f2458ed6", "filename": "src/test/ui/parser/doc-comment-in-if-statement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n     if true /*!*/ {}\n-    //~^ ERROR expected `{`, found doc comment `/*!*/`\n+    //~^ ERROR outer attributes are not allowed on\n+    //~| ERROR expected outer doc comment\n }"}, {"sha": "af21b78733f90baa9c6f92d9dcbd105b6d3e2847", "filename": "src/test/ui/parser/doc-comment-in-if-statement.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,10 +1,19 @@\n-error: expected `{`, found doc comment `/*!*/`\n+error: expected outer doc comment\n   --> $DIR/doc-comment-in-if-statement.rs:2:13\n    |\n LL |     if true /*!*/ {}\n-   |     --      ^^^^^ expected `{`\n-   |     |\n-   |     this `if` expression has a condition, but no block\n+   |             ^^^^^\n+   |\n+   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n+\n+error: outer attributes are not allowed on `if` and `else` branches\n+  --> $DIR/doc-comment-in-if-statement.rs:2:13\n+   |\n+LL |     if true /*!*/ {}\n+   |     --      ^^^^^ -- the attributes are attached to this branch\n+   |     |       |\n+   |     |       help: remove the attributes\n+   |     the branch belongs to this `if`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "09444079365bf0df973c36100c58f67986add58c", "filename": "src/test/ui/parser/fn-body-eq-expr-semi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,23 @@\n+fn main() {}\n+\n+fn syntax() {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+}\n+\n+extern {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    //~^ ERROR incorrect function inside `extern` block\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+    //~^ ERROR incorrect function inside `extern` block\n+}\n+\n+trait Foo {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+}\n+\n+impl Foo for () {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+}"}, {"sha": "739133e0b408b825f0b36e536aa1f37fe1cfd899", "filename": "src/test/ui/parser/fn-body-eq-expr-semi.stderr", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,117 @@\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:4:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:5:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:9:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:11:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:16:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:17:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:21:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:22:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: incorrect function inside `extern` block\n+  --> $DIR/fn-body-eq-expr-semi.rs:9:8\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+LL |     fn foo() = 42;\n+   |        ^^^   ----- help: remove the invalid body: `;`\n+   |        |\n+   |        cannot have a body\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: incorrect function inside `extern` block\n+  --> $DIR/fn-body-eq-expr-semi.rs:11:8\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+...\n+LL |     fn bar() -> u8 = 42;\n+   |        ^^^         ----- help: remove the invalid body: `;`\n+   |        |\n+   |        cannot have a body\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e9fc6f15346f24ec13200f98b6a053665397cd90", "filename": "src/test/ui/parser/issue-1655.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-1655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-1655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-1655.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,6 +1,5 @@\n-// error-pattern:expected `[`, found `vec`\n mod blade_runner {\n-    #vec[doc(\n+    #vec[doc( //~ ERROR expected one of `!` or `[`, found `vec`\n         brief = \"Blade Runner is probably the best movie ever\",\n         desc = \"I like that in the world of Blade Runner it is always\n                 raining, and that it's always night time. And Aliens"}, {"sha": "0c390a0ec563c95c78e25b7fcf996520a33f0bd0", "filename": "src/test/ui/parser/issue-1655.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-1655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-1655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-1655.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,8 @@\n-error: expected `[`, found `vec`\n-  --> $DIR/issue-1655.rs:3:6\n+error: expected one of `!` or `[`, found `vec`\n+  --> $DIR/issue-1655.rs:2:6\n    |\n LL |     #vec[doc(\n-   |      ^^^ expected `[`\n+   |      ^^^ expected one of `!` or `[`\n \n error: aborting due to previous error\n "}, {"sha": "15cd3df860b0da7a44d1cd045877b545f5d99e0b", "filename": "src/test/ui/parser/issue-63116.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -12,7 +12,7 @@ error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `;`\n LL | impl W <s(f;Y(;]\n    |            ^ expected one of 7 possible tokens\n \n-error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `->`, `...`, `::`, `<`, `>`, `?`, `[`, `_`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, or lifetime, found `;`\n+error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `->`, `...`, `::`, `<`, `>`, `?`, `[`, `_`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, lifetime, or path, found `;`\n   --> $DIR/issue-63116.rs:3:15\n    |\n LL | impl W <s(f;Y(;]"}, {"sha": "a5a8de85466bbccf5c549f3d538f82bf69ccc854", "filename": "src/test/ui/parser/issue-63135.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern: aborting due to 7 previous errors\n+// error-pattern: aborting due to 5 previous errors\n \n fn i(n{...,f #"}, {"sha": "396aec8335dbf162fa2c574bd3b78a328aa7cc6c", "filename": "src/test/ui/parser/issue-63135.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -31,23 +31,11 @@ LL | fn i(n{...,f #\n    |        |  expected `}`\n    |        `..` must be at the end and cannot have a trailing comma\n \n-error: expected `[`, found `}`\n+error: expected one of `!` or `[`, found `}`\n   --> $DIR/issue-63135.rs:3:16\n    |\n LL | fn i(n{...,f #\n-   |                ^ expected `[`\n+   |                ^ expected one of `!` or `[`\n \n-error: expected one of `:` or `|`, found `)`\n-  --> $DIR/issue-63135.rs:3:16\n-   |\n-LL | fn i(n{...,f #\n-   |                ^ expected one of `:` or `|`\n-\n-error: expected `;` or `{`, found `<eof>`\n-  --> $DIR/issue-63135.rs:3:16\n-   |\n-LL | fn i(n{...,f #\n-   |                ^ expected `;` or `{`\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "20e18b4bcbb323d50ecfe254f9800cd5aa0a4a40", "filename": "src/test/ui/parser/issue-68730.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68730.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958"}, {"sha": "9f8833e17fe25afc9f10b08683294ecd7e9efe32", "filename": "src/test/ui/parser/issue-68730.stderr", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68730.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958"}, {"sha": "ae02246046880e48ddfd4c9ce46310f74fee1e92", "filename": "src/test/ui/parser/issue-68890-2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,6 @@\n+fn main() {}\n+\n+type X<'a> = (?'a) +;\n+//~^ ERROR `?` may only modify trait bounds, not lifetime bounds\n+//~| ERROR at least one trait is required for an object type\n+//~| WARN trait objects without an explicit `dyn` are deprecated"}, {"sha": "d475c79cb27b4522a6ccbd33383a1c6e0ae5b23e", "filename": "src/test/ui/parser/issue-68890-2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,22 @@\n+error: `?` may only modify trait bounds, not lifetime bounds\n+  --> $DIR/issue-68890-2.rs:3:15\n+   |\n+LL | type X<'a> = (?'a) +;\n+   |               ^\n+\n+warning: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/issue-68890-2.rs:3:14\n+   |\n+LL | type X<'a> = (?'a) +;\n+   |              ^^^^^^^ help: use `dyn`: `dyn (?'a) +`\n+   |\n+   = note: `#[warn(bare_trait_objects)]` on by default\n+\n+error[E0224]: at least one trait is required for an object type\n+  --> $DIR/issue-68890-2.rs:3:14\n+   |\n+LL | type X<'a> = (?'a) +;\n+   |              ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bab4ed7f800c5d7dcf32f2c344542703016cb4c7", "filename": "src/test/ui/parser/issue-68890.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,4 +1,4 @@\n enum e{A((?'a a+?+l))}\n //~^ ERROR `?` may only modify trait bounds, not lifetime bounds\n //~| ERROR expected one of `)`, `+`, or `,`\n-//~| ERROR expected trait bound, not lifetime bound\n+//~| ERROR expected item, found `)`"}, {"sha": "2a3bf6b41f02ea7c363eebc582786a62d4f7559a", "filename": "src/test/ui/parser/issue-68890.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -10,11 +10,11 @@ error: expected one of `)`, `+`, or `,`, found `a`\n LL | enum e{A((?'a a+?+l))}\n    |               ^ expected one of `)`, `+`, or `,`\n \n-error: expected trait bound, not lifetime bound\n-  --> $DIR/issue-68890.rs:1:11\n+error: expected item, found `)`\n+  --> $DIR/issue-68890.rs:1:21\n    |\n LL | enum e{A((?'a a+?+l))}\n-   |           ^^^\n+   |                     ^ expected item\n \n error: aborting due to 3 previous errors\n "}, {"sha": "db9ef52c1aeec3a71e6aa4995b6d7bfeec122d8f", "filename": "src/test/ui/parser/labeled-no-colon-expr.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,17 @@\n+#![feature(label_break_value)]\n+\n+fn main() {\n+    'l0 while false {} //~ ERROR labeled expression must be followed by `:`\n+    'l1 for _ in 0..1 {} //~ ERROR labeled expression must be followed by `:`\n+    'l2 loop {} //~ ERROR labeled expression must be followed by `:`\n+    'l3 {} //~ ERROR labeled expression must be followed by `:`\n+    'l4 0; //~ ERROR labeled expression must be followed by `:`\n+    //~^ ERROR expected `while`, `for`, `loop` or `{`\n+\n+    macro_rules! m {\n+        ($b:block) => {\n+            'l5 $b; //~ ERROR cannot use a `block` macro fragment here\n+        }\n+    }\n+    m!({}); //~ ERROR labeled expression must be followed by `:`\n+}"}, {"sha": "4f5e8f78aa0cdcb5bd400a23ce34f0b159901306", "filename": "src/test/ui/parser/labeled-no-colon-expr.stderr", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -0,0 +1,89 @@\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:4:5\n+   |\n+LL |     'l0 while false {}\n+   |     ----^^^^^^^^^^^^^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:5:5\n+   |\n+LL |     'l1 for _ in 0..1 {}\n+   |     ----^^^^^^^^^^^^^^^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:6:5\n+   |\n+LL |     'l2 loop {}\n+   |     ----^^^^^^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:7:5\n+   |\n+LL |     'l3 {}\n+   |     ----^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/labeled-no-colon-expr.rs:8:9\n+   |\n+LL |     'l4 0;\n+   |         ^ expected `while`, `for`, `loop` or `{` after a label\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:8:9\n+   |\n+LL |     'l4 0;\n+   |     ----^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/labeled-no-colon-expr.rs:13:17\n+   |\n+LL |             'l5 $b;\n+   |             ----^^\n+   |             |\n+   |             the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:16:8\n+   |\n+LL |             'l5 $b;\n+   |             ---- help: add `:` after the label\n+   |             |\n+   |             the label\n+...\n+LL |     m!({});\n+   |        ^^\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "170ac22780b6319d4a1bb9876231af29e8b5ee36", "filename": "src/test/ui/parser/macro/trait-object-macro-matcher.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -2,9 +2,14 @@\n // `ty` matcher in particular doesn't accept a single lifetime\n \n macro_rules! m {\n-    ($t: ty) => ( let _: $t; )\n+    ($t: ty) => {\n+        let _: $t;\n+    };\n }\n \n fn main() {\n-    m!('static); //~ ERROR expected type, found `'static`\n+    m!('static);\n+    //~^ ERROR lifetime in trait object type must be followed by `+`\n+    //~| ERROR at least one trait is required for an object type\n+    //~| WARN trait objects without an explicit `dyn` are deprecated\n }"}, {"sha": "230733371ddd8a362efd512eb042126d82568a96", "filename": "src/test/ui/parser/macro/trait-object-macro-matcher.stderr", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,22 @@\n-error: expected type, found `'static`\n-  --> $DIR/trait-object-macro-matcher.rs:9:8\n+error: lifetime in trait object type must be followed by `+`\n+  --> $DIR/trait-object-macro-matcher.rs:11:8\n    |\n LL |     m!('static);\n-   |        ^^^^^^^ expected type\n+   |        ^^^^^^^\n \n-error: aborting due to previous error\n+warning: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/trait-object-macro-matcher.rs:11:8\n+   |\n+LL |     m!('static);\n+   |        ^^^^^^^ help: use `dyn`: `dyn 'static`\n+   |\n+   = note: `#[warn(bare_trait_objects)]` on by default\n+\n+error[E0224]: at least one trait is required for an object type\n+  --> $DIR/trait-object-macro-matcher.rs:11:8\n+   |\n+LL |     m!('static);\n+   |        ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "d223619e1de9ed3bdb23d80dc9ad9f9260b04874", "filename": "src/test/ui/parser/regions-out-of-scope-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -4,7 +4,7 @@ fn foo(cond: bool) {\n     let mut x;\n \n     if cond {\n-        x = &'blk [1,2,3]; //~ ERROR expected `:`, found `[`\n+        x = &'blk [1,2,3]; //~ ERROR borrow expressions cannot be annotated with lifetimes\n     }\n }\n "}, {"sha": "bbc657ffd614c40cac5689a7cca84156a72536c8", "filename": "src/test/ui/parser/regions-out-of-scope-slice.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,8 +1,11 @@\n-error: expected `:`, found `[`\n-  --> $DIR/regions-out-of-scope-slice.rs:7:19\n+error: borrow expressions cannot be annotated with lifetimes\n+  --> $DIR/regions-out-of-scope-slice.rs:7:13\n    |\n LL |         x = &'blk [1,2,3];\n-   |                   ^ expected `:`\n+   |             ^----^^^^^^^^\n+   |              |\n+   |              annotated with lifetime here\n+   |              help: remove the lifetime annotation\n \n error: aborting due to previous error\n "}, {"sha": "5a5c19f32e8060553581805d79d4e819e94d51d4", "filename": "src/test/ui/parser/trait-object-lifetime-parens.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -6,9 +6,7 @@ fn f<'a, T: Trait + ('a)>() {} //~ ERROR parenthesized lifetime bounds are not s\n \n fn check<'a>() {\n     let _: Box<Trait + ('a)>; //~ ERROR parenthesized lifetime bounds are not supported\n-    let _: Box<('a) + Trait>;\n-    //~^ ERROR expected type, found `'a`\n-    //~| ERROR expected `:`, found `)`\n+    let _: Box<('a) + Trait>; //~ ERROR lifetime in trait object type must be followed by `+`\n }\n \n fn main() {}"}, {"sha": "1289c248275dc8b39b6b16ea8bee252fc17727eb", "filename": "src/test/ui/parser/trait-object-lifetime-parens.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -10,19 +10,11 @@ error: parenthesized lifetime bounds are not supported\n LL |     let _: Box<Trait + ('a)>;\n    |                        ^^^^ help: remove the parentheses\n \n-error: expected `:`, found `)`\n-  --> $DIR/trait-object-lifetime-parens.rs:9:19\n-   |\n-LL |     let _: Box<('a) + Trait>;\n-   |                   ^ expected `:`\n-\n-error: expected type, found `'a`\n+error: lifetime in trait object type must be followed by `+`\n   --> $DIR/trait-object-lifetime-parens.rs:9:17\n    |\n LL |     let _: Box<('a) + Trait>;\n-   |         -       ^^ expected type\n-   |         |\n-   |         while parsing the type for `_`\n+   |                 ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "9fbc938c4dce81e290668ffab3ebddfc3e993db3", "filename": "src/test/ui/parser/trait-object-trait-parens.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.rs?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,15 +1,20 @@\n trait Trait<'a> {}\n \n+trait Obj {}\n+\n fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {}\n \n fn main() {\n-    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n+    let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+    //~^ ERROR `?Trait` is not permitted in trait object types\n+    //~| ERROR only auto traits can be used as additional traits\n+    //~| WARN trait objects without an explicit `dyn` are deprecated\n+    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n     //~^ ERROR `?Trait` is not permitted in trait object types\n+    //~| ERROR only auto traits can be used as additional traits\n     //~| WARN trait objects without an explicit `dyn` are deprecated\n-    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;\n-    //~^ WARN trait objects without an explicit `dyn` are deprecated\n-    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-    //~^ ERROR use of undeclared lifetime name `'a`\n-    //~| ERROR `?Trait` is not permitted in trait object types\n+    let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+    //~^ ERROR `?Trait` is not permitted in trait object types\n+    //~| ERROR only auto traits can be used as additional traits\n     //~| WARN trait objects without an explicit `dyn` are deprecated\n }"}, {"sha": "7022a66ca1a17be179961799c2bba804dbaa4cc8", "filename": "src/test/ui/parser/trait-object-trait-parens.stderr", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,44 +1,74 @@\n error: `?Trait` is not permitted in trait object types\n-  --> $DIR/trait-object-trait-parens.rs:6:25\n+  --> $DIR/trait-object-trait-parens.rs:8:24\n    |\n-LL |     let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n-   |                         ^^^^^^^^\n+LL |     let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+   |                        ^^^^^^^^\n \n error: `?Trait` is not permitted in trait object types\n-  --> $DIR/trait-object-trait-parens.rs:11:47\n+  --> $DIR/trait-object-trait-parens.rs:12:17\n    |\n-LL |     let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-   |                                               ^^^^^^^^\n+LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n+   |                 ^^^^^^\n+\n+error: `?Trait` is not permitted in trait object types\n+  --> $DIR/trait-object-trait-parens.rs:16:46\n+   |\n+LL |     let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+   |                                              ^^^^^^^^\n \n warning: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/trait-object-trait-parens.rs:6:16\n+  --> $DIR/trait-object-trait-parens.rs:8:16\n    |\n-LL |     let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (Copy) + (?Sized) + (for<'a> Trait<'a>)`\n+LL |     let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (Obj) + (?Sized) + (for<'a> Trait<'a>)`\n    |\n    = note: `#[warn(bare_trait_objects)]` on by default\n \n warning: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/trait-object-trait-parens.rs:9:16\n+  --> $DIR/trait-object-trait-parens.rs:12:16\n    |\n-LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (?Sized) + (for<'a> Trait<'a>) + (Copy)`\n+LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (?Sized) + (for<'a> Trait<'a>) + (Obj)`\n \n warning: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/trait-object-trait-parens.rs:11:16\n+  --> $DIR/trait-object-trait-parens.rs:16:16\n+   |\n+LL |     let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (for<'a> Trait<'a>) + (Obj) + (?Sized)`\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/trait-object-trait-parens.rs:8:35\n+   |\n+LL |     let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+   |                -----              ^^^^^^^^^^^^^^^^^^^\n+   |                |                  |\n+   |                |                  additional non-auto trait\n+   |                |                  trait alias used in trait object type (additional use)\n+   |                first non-auto trait\n+   |                trait alias used in trait object type (first use)\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/trait-object-trait-parens.rs:12:49\n    |\n-LL |     let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (for<'a> Trait<'a>) + (Copy) + (?Sized)`\n+LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n+   |                           -------------------   ^^^^^\n+   |                           |                     |\n+   |                           |                     additional non-auto trait\n+   |                           |                     trait alias used in trait object type (additional use)\n+   |                           first non-auto trait\n+   |                           trait alias used in trait object type (first use)\n \n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/trait-object-trait-parens.rs:11:31\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/trait-object-trait-parens.rs:16:38\n    |\n-LL | fn main() {\n-   |        - help: consider introducing lifetime `'a` here: `<'a>`\n-...\n-LL |     let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-   |                               ^^ undeclared lifetime\n+LL |     let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+   |                 -----------------    ^^^^^\n+   |                 |                    |\n+   |                 |                    additional non-auto trait\n+   |                 |                    trait alias used in trait object type (additional use)\n+   |                 first non-auto trait\n+   |                 trait alias used in trait object type (first use)\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0261`.\n+For more information about this error, try `rustc --explain E0225`."}, {"sha": "895f33638f95aa0154beb2036b78494bf56ed9ea", "filename": "src/test/ui/unsafe/unsafe-block-without-braces.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9674c09ae9b0c520150208bbfd8c66019edbb958/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr?ref=9674c09ae9b0c520150208bbfd8c66019edbb958", "patch": "@@ -1,10 +1,11 @@\n error: expected `{`, found `std`\n   --> $DIR/unsafe-block-without-braces.rs:3:9\n    |\n-LL |     unsafe //{\n-   |           - expected `{`\n LL |         std::mem::transmute::<f32, u32>(1.0);\n-   |         ^^^ unexpected token\n+   |         ^^^----------------------------------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ std::mem::transmute::<f32, u32>(1.0); }`\n \n error: aborting due to previous error\n "}]}