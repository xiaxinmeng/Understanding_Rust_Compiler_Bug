{"sha": "b4a85c7b583b75eade31d698ad9862f5f98e8857", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YTg1YzdiNTgzYjc1ZWFkZTMxZDY5OGFkOTg2MmY1Zjk4ZTg4NTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-04T01:27:35Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-04T01:36:38Z"}, "message": "Factor out and generalize sequence pointer walking, for use in vec-grow.", "tree": {"sha": "ef5a39594d21c1fb043c033321683330b453cef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef5a39594d21c1fb043c033321683330b453cef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4a85c7b583b75eade31d698ad9862f5f98e8857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a85c7b583b75eade31d698ad9862f5f98e8857", "html_url": "https://github.com/rust-lang/rust/commit/b4a85c7b583b75eade31d698ad9862f5f98e8857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4a85c7b583b75eade31d698ad9862f5f98e8857/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04a0a6fbef0cc7c3c89fbbbeff68ab2c999d9592", "url": "https://api.github.com/repos/rust-lang/rust/commits/04a0a6fbef0cc7c3c89fbbbeff68ab2c999d9592", "html_url": "https://github.com/rust-lang/rust/commit/04a0a6fbef0cc7c3c89fbbbeff68ab2c999d9592"}], "stats": {"total": 110, "additions": 80, "deletions": 30}, "files": [{"sha": "2af5359a399e0526d70b75bb6f05a09619ceba87", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 80, "deletions": 30, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b4a85c7b583b75eade31d698ad9862f5f98e8857/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a85c7b583b75eade31d698ad9862f5f98e8857/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b4a85c7b583b75eade31d698ad9862f5f98e8857", "patch": "@@ -1770,6 +1770,81 @@ fn iter_structural_ty_full(@block_ctxt cx,\n     ret r;\n }\n \n+// Iterates through a pair of sequences, until the src* hits the src_lim*.\n+fn iter_sequence_pair_inner(@block_ctxt cx,\n+                            ValueRef dst,     // elt*\n+                            ValueRef src,     // elt*\n+                            ValueRef src_lim, // elt*\n+                            @ty.t elt_ty,\n+                            val_pair_and_ty_fn f) -> result {\n+\n+    auto bcx = cx;\n+\n+    auto llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n+    auto unit_sz = size_of(bcx, elt_ty);\n+    bcx = unit_sz.bcx;\n+\n+    let ValueRef src_int = vp2i(bcx, src);\n+    let ValueRef src_lim_int = vp2i(bcx, src_lim);\n+    let ValueRef dst_int = vp2i(bcx, dst);\n+\n+    auto cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n+    auto body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+\n+    bcx.build.Br(cond_cx.llbb);\n+\n+    let ValueRef src_curr = cond_cx.build.Phi(T_int(),\n+                                              vec(src_int), vec(bcx.llbb));\n+    let ValueRef dst_curr = cond_cx.build.Phi(T_int(),\n+                                              vec(dst_int), vec(bcx.llbb));\n+\n+    auto end_test = cond_cx.build.ICmp(lib.llvm.LLVMIntNE,\n+                                       src_curr, src_lim_int);\n+\n+    cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n+\n+    auto src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(llunit_ty));\n+    auto dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(llunit_ty));\n+\n+    auto body_res = f(body_cx,\n+                      dst_curr_ptr,\n+                      load_scalar_or_boxed(body_cx, src_curr_ptr, elt_ty),\n+                      elt_ty);\n+    body_cx = body_res.bcx;\n+\n+    auto src_next = body_cx.build.Add(src_curr, unit_sz.val);\n+    auto dst_next = body_cx.build.Add(dst_curr, unit_sz.val);\n+    body_cx.build.Br(cond_cx.llbb);\n+\n+    cond_cx.build.AddIncomingToPhi(src_curr, vec(src_next),\n+                                   vec(body_cx.llbb));\n+\n+    cond_cx.build.AddIncomingToPhi(dst_curr, vec(dst_next),\n+                                   vec(body_cx.llbb));\n+\n+    ret res(next_cx, C_nil());\n+}\n+\n+\n+fn iter_sequence_inner(@block_ctxt cx,\n+                       ValueRef src,     // elt*\n+                       ValueRef src_lim, // elt*\n+                       @ty.t elt_ty,\n+                       val_and_ty_fn f) -> result {\n+    fn adaptor_fn(val_and_ty_fn f,\n+                  @block_ctxt cx,\n+                  ValueRef av,\n+                  ValueRef bv,\n+                  @ty.t t) -> result {\n+        ret f(cx, bv, t);\n+    }\n+\n+    be iter_sequence_pair_inner(cx, src, src, src_lim, elt_ty,\n+                                bind adaptor_fn(f, _, _, _, _));\n+}\n+\n+\n // Iterates through the elements of a vec or str.\n fn iter_sequence(@block_ctxt cx,\n                  ValueRef v,\n@@ -1789,43 +1864,18 @@ fn iter_sequence(@block_ctxt cx,\n \n         auto llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n         auto bcx = cx;\n-        auto unit_sz = size_of(bcx, elt_ty);\n-        bcx = unit_sz.bcx;\n \n         auto len = bcx.build.Load(lenptr);\n         if (trailing_null) {\n+            auto unit_sz = size_of(bcx, elt_ty);\n+            bcx = unit_sz.bcx;\n             len = bcx.build.Sub(len, unit_sz.val);\n         }\n \n-        auto cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n-        auto body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n-        auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-\n-        bcx.build.Br(cond_cx.llbb);\n-\n-        auto ix = cond_cx.build.Phi(T_int(), vec(C_int(0)), vec(cx.llbb));\n-        auto scaled_ix = cond_cx.build.Phi(T_int(),\n-                                           vec(C_int(0)), vec(cx.llbb));\n-\n-        auto end_test = cond_cx.build.ICmp(lib.llvm.LLVMIntNE,\n-                                           scaled_ix, len);\n-        cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n+        auto p1 = vi2p(bcx, bcx.build.Add(vp2i(bcx, p0), len),\n+                       T_ptr(llunit_ty));\n \n-        auto elt = body_cx.build.GEP(p0, vec(C_int(0), ix));\n-        auto body_res = f(body_cx,\n-                          load_scalar_or_boxed(body_cx, elt, elt_ty),\n-                          elt_ty);\n-        auto next_ix = body_res.bcx.build.Add(ix, C_int(1));\n-        auto next_scaled_ix = body_res.bcx.build.Add(scaled_ix, unit_sz.val);\n-\n-        cond_cx.build.AddIncomingToPhi(ix, vec(next_ix),\n-                                       vec(body_res.bcx.llbb));\n-\n-        cond_cx.build.AddIncomingToPhi(scaled_ix, vec(next_scaled_ix),\n-                                       vec(body_res.bcx.llbb));\n-\n-        body_res.bcx.build.Br(cond_cx.llbb);\n-        ret res(next_cx, C_nil());\n+        ret iter_sequence_inner(cx, p0, p1, elt_ty, f);\n     }\n \n     alt (t.struct) {"}]}