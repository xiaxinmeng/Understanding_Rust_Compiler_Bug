{"sha": "b4ad612697b7dccbf83562010fcfaa36023324cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YWQ2MTI2OTdiN2RjY2JmODM1NjIwMTBmY2ZhYTM2MDIzMzI0Y2Q=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-28T15:12:33Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-30T18:56:49Z"}, "message": "Remove unused parts of ExprUseVisitor", "tree": {"sha": "c8037d166f0fd06a6d919e21d0a0bfbe91f1e908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8037d166f0fd06a6d919e21d0a0bfbe91f1e908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4ad612697b7dccbf83562010fcfaa36023324cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ad612697b7dccbf83562010fcfaa36023324cd", "html_url": "https://github.com/rust-lang/rust/commit/b4ad612697b7dccbf83562010fcfaa36023324cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4ad612697b7dccbf83562010fcfaa36023324cd/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "455945f24b12689340d5085ed795aa3bfdab9d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/455945f24b12689340d5085ed795aa3bfdab9d34", "html_url": "https://github.com/rust-lang/rust/commit/455945f24b12689340d5085ed795aa3bfdab9d34"}], "stats": {"total": 511, "additions": 83, "deletions": 428}, "files": [{"sha": "bb7ac5d8dbe1a75c79af0ac5e89fabb49dd5d390", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 78, "deletions": 380, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/b4ad612697b7dccbf83562010fcfaa36023324cd/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ad612697b7dccbf83562010fcfaa36023324cd/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b4ad612697b7dccbf83562010fcfaa36023324cd", "patch": "@@ -2,20 +2,16 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n-pub use self::LoanCause::*;\n pub use self::ConsumeMode::*;\n-pub use self::MoveReason::*;\n-pub use self::MatchMode::*;\n-use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use crate::hir::def::{CtorOf, Res, DefKind};\n+use crate::hir::def::Res;\n use crate::hir::def_id::DefId;\n use crate::hir::ptr::P;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n use crate::middle::region;\n-use crate::ty::{self, DefIdTree, TyCtxt, adjustment};\n+use crate::ty::{self, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n use std::rc::Rc;\n@@ -29,161 +25,19 @@ use syntax_pos::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self,\n-               consume_id: hir::HirId,\n-               consume_span: Span,\n-               cmt: &mc::cmt_<'tcx>,\n-               mode: ConsumeMode);\n-\n-    // The value found at `cmt` has been determined to match the\n-    // pattern binding `matched_pat`, and its subparts are being\n-    // copied or moved depending on `mode`.  Note that `matched_pat`\n-    // is called on all variant/structs in the pattern (i.e., the\n-    // interior nodes of the pattern's tree structure) while\n-    // consume_pat is called on the binding identifiers in the pattern\n-    // (which are leaves of the pattern's tree structure).\n-    //\n-    // Note that variants/structs and identifiers are disjoint; thus\n-    // `matched_pat` and `consume_pat` are never both called on the\n-    // same input pattern structure (though of `consume_pat` can be\n-    // called on a subpart of an input passed to `matched_pat).\n-    fn matched_pat(&mut self,\n-                   matched_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: MatchMode);\n-\n-    // The value found at `cmt` is either copied or moved via the\n-    // pattern binding `consume_pat`, depending on mode.\n-    fn consume_pat(&mut self,\n-                   consume_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: ConsumeMode);\n-\n-    // The value found at `borrow` is being borrowed at the point\n-    // `borrow_id` for the region `loan_region` with kind `bk`.\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              borrow_span: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: LoanCause);\n-\n-    // The local variable `id` is declared but not initialized.\n-    fn decl_without_init(&mut self,\n-                         id: hir::HirId,\n-                         span: Span);\n+    fn consume(&mut self, cmt: &mc::cmt_<'tcx>, mode: ConsumeMode);\n \n-    // The path at `cmt` is being assigned to.\n-    fn mutate(&mut self,\n-              assignment_id: hir::HirId,\n-              assignment_span: Span,\n-              assignee_cmt: &mc::cmt_<'tcx>,\n-              mode: MutateMode);\n-\n-    // A nested closure or generator - only one layer deep.\n-    fn nested_body(&mut self, _body_id: hir::BodyId) {}\n-}\n+    // The value found at `cmt` is being borrowed with kind `bk`.\n+    fn borrow(&mut self, cmt: &mc::cmt_<'tcx>, bk: ty::BorrowKind);\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum LoanCause {\n-    ClosureCapture(Span),\n-    AddrOf,\n-    AutoRef,\n-    AutoUnsafe,\n-    RefBinding,\n-    OverloadedOperator,\n-    ClosureInvocation,\n-    ForLoop,\n-    MatchDiscriminant\n+    // The path at `cmt` is being assigned to.\n+    fn mutate(&mut self, assignee_cmt: &mc::cmt_<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ConsumeMode {\n     Copy,                // reference to x where x has a type that copies\n-    Move(MoveReason),    // reference to x where x has a type that moves\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MoveReason {\n-    DirectRefMove,\n-    PatBindingMove,\n-    CaptureMove,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MatchMode {\n-    NonBindingMatch,\n-    BorrowingMatch,\n-    CopyingMatch,\n-    MovingMatch,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum TrackMatchMode {\n-    Unknown,\n-    Definite(MatchMode),\n-    Conflicting,\n-}\n-\n-impl TrackMatchMode {\n-    // Builds up the whole match mode for a pattern from its constituent\n-    // parts.  The lattice looks like this:\n-    //\n-    //          Conflicting\n-    //            /     \\\n-    //           /       \\\n-    //      Borrowing   Moving\n-    //           \\       /\n-    //            \\     /\n-    //            Copying\n-    //               |\n-    //          NonBinding\n-    //               |\n-    //            Unknown\n-    //\n-    // examples:\n-    //\n-    // * `(_, some_int)` pattern is Copying, since\n-    //   NonBinding + Copying => Copying\n-    //\n-    // * `(some_int, some_box)` pattern is Moving, since\n-    //   Copying + Moving => Moving\n-    //\n-    // * `(ref x, some_box)` pattern is Conflicting, since\n-    //   Borrowing + Moving => Conflicting\n-    //\n-    // Note that the `Unknown` and `Conflicting` states are\n-    // represented separately from the other more interesting\n-    // `Definite` states, which simplifies logic here somewhat.\n-    fn lub(&mut self, mode: MatchMode) {\n-        *self = match (*self, mode) {\n-            // Note that clause order below is very significant.\n-            (Unknown, new) => Definite(new),\n-            (Definite(old), new) if old == new => Definite(old),\n-\n-            (Definite(old), NonBindingMatch) => Definite(old),\n-            (Definite(NonBindingMatch), new) => Definite(new),\n-\n-            (Definite(old), CopyingMatch) => Definite(old),\n-            (Definite(CopyingMatch), new) => Definite(new),\n-\n-            (Definite(_), _) => Conflicting,\n-            (Conflicting, _) => *self,\n-        };\n-    }\n-\n-    fn match_mode(&self) -> MatchMode {\n-        match *self {\n-            Unknown => NonBindingMatch,\n-            Definite(mode) => mode,\n-            Conflicting => {\n-                // Conservatively return MovingMatch to let the\n-                // compiler continue to make progress.\n-                MovingMatch\n-            }\n-        }\n-    }\n+    Move,                // reference to x where x has a type that moves\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -326,15 +180,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.mc.tcx\n     }\n \n-    fn delegate_consume(&mut self,\n-                        consume_id: hir::HirId,\n-                        consume_span: Span,\n-                        cmt: &mc::cmt_<'tcx>) {\n-        debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n-               consume_id, cmt);\n+    fn delegate_consume(&mut self, cmt: &mc::cmt_<'tcx>) {\n+        debug!(\"delegate_consume(cmt={:?})\", cmt);\n \n-        let mode = copy_or_move(&self.mc, self.param_env, cmt, DirectRefMove);\n-        self.delegate.consume(consume_id, consume_span, cmt, mode);\n+        let mode = copy_or_move(&self.mc, self.param_env, cmt);\n+        self.delegate.consume(cmt, mode);\n     }\n \n     fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n@@ -347,30 +197,21 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.hir_id, expr.span, &cmt);\n+        self.delegate_consume(&cmt);\n         self.walk_expr(expr);\n     }\n \n-    fn mutate_expr(&mut self,\n-                   span: Span,\n-                   assignment_expr: &hir::Expr,\n-                   expr: &hir::Expr,\n-                   mode: MutateMode) {\n+    fn mutate_expr(&mut self, expr: &hir::Expr) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.hir_id, span, &cmt, mode);\n+        self.delegate.mutate(&cmt);\n         self.walk_expr(expr);\n     }\n \n-    fn borrow_expr(&mut self,\n-                   expr: &hir::Expr,\n-                   r: ty::Region<'tcx>,\n-                   bk: ty::BorrowKind,\n-                   cause: LoanCause) {\n-        debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\",\n-               expr, r, bk);\n+    fn borrow_expr(&mut self, expr: &hir::Expr, bk: ty::BorrowKind) {\n+        debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.hir_id, expr.span, &cmt, r, bk, cause);\n+        self.delegate.borrow(&cmt, bk);\n \n         self.walk_expr(expr)\n     }\n@@ -388,24 +229,24 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Path(_) => { }\n \n             hir::ExprKind::Type(ref subexpr, _) => {\n-                self.walk_expr(&subexpr)\n+                self.walk_expr(subexpr)\n             }\n \n             hir::ExprKind::Unary(hir::UnDeref, ref base) => { // *base\n-                self.select_from_expr(&base);\n+                self.select_from_expr(base);\n             }\n \n             hir::ExprKind::Field(ref base, _) => { // base.f\n-                self.select_from_expr(&base);\n+                self.select_from_expr(base);\n             }\n \n             hir::ExprKind::Index(ref lhs, ref rhs) => { // lhs[rhs]\n-                self.select_from_expr(&lhs);\n-                self.consume_expr(&rhs);\n+                self.select_from_expr(lhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Call(ref callee, ref args) => { // callee(args)\n-                self.walk_callee(expr, &callee);\n+                self.walk_callee(expr, callee);\n                 self.consume_exprs(args);\n             }\n \n@@ -423,14 +264,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n-                let r = self.tcx().lifetimes.re_empty;\n-                self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n+                self.borrow_expr(&discr, ty::ImmBorrow);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n-                    let mode = self.arm_move_mode(discr_cmt.clone(), arm);\n-                    let mode = mode.match_mode();\n-                    self.walk_arm(discr_cmt.clone(), arm, mode);\n+                    self.walk_arm(discr_cmt.clone(), arm);\n                 }\n             }\n \n@@ -441,28 +279,16 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::AddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::Ref(r, _, _) = expr_ty.kind {\n-                    let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(&base, r, bk, AddrOf);\n-                }\n+                let bk = ty::BorrowKind::from_mutbl(m);\n+                self.borrow_expr(&base, bk);\n             }\n \n             hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n                 for (o, output) in ia.outputs.iter().zip(outputs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n                     } else {\n-                        self.mutate_expr(\n-                            output.span,\n-                            expr,\n-                            output,\n-                            if o.is_rw {\n-                                MutateMode::WriteAndRead\n-                            } else {\n-                                MutateMode::JustWrite\n-                            },\n-                        );\n+                        self.mutate_expr(output);\n                     }\n                 }\n                 self.consume_exprs(inputs);\n@@ -473,65 +299,64 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Err => {}\n \n             hir::ExprKind::Loop(ref blk, _, _) => {\n-                self.walk_block(&blk);\n+                self.walk_block(blk);\n             }\n \n             hir::ExprKind::Unary(_, ref lhs) => {\n-                self.consume_expr(&lhs);\n+                self.consume_expr(lhs);\n             }\n \n             hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                self.consume_expr(&lhs);\n-                self.consume_expr(&rhs);\n+                self.consume_expr(lhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Block(ref blk, _) => {\n-                self.walk_block(&blk);\n+                self.walk_block(blk);\n             }\n \n             hir::ExprKind::Break(_, ref opt_expr) | hir::ExprKind::Ret(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n-                    self.consume_expr(&expr);\n+                    self.consume_expr(expr);\n                 }\n             }\n \n             hir::ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.mutate_expr(expr.span, expr, &lhs, MutateMode::JustWrite);\n-                self.consume_expr(&rhs);\n+                self.mutate_expr(lhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Cast(ref base, _) => {\n-                self.consume_expr(&base);\n+                self.consume_expr(base);\n             }\n \n             hir::ExprKind::DropTemps(ref expr) => {\n-                self.consume_expr(&expr);\n+                self.consume_expr(expr);\n             }\n \n             hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n-                    self.mutate_expr(expr.span, expr, &lhs, MutateMode::WriteAndRead);\n+                    self.mutate_expr(lhs);\n                 }\n-                self.consume_expr(&rhs);\n+                self.consume_expr(rhs);\n             }\n \n             hir::ExprKind::Repeat(ref base, _) => {\n-                self.consume_expr(&base);\n+                self.consume_expr(base);\n             }\n \n-            hir::ExprKind::Closure(_, _, body_id, fn_decl_span, _) => {\n-                self.delegate.nested_body(body_id);\n+            hir::ExprKind::Closure(_, _, _, fn_decl_span, _) => {\n                 self.walk_captures(expr, fn_decl_span);\n             }\n \n             hir::ExprKind::Box(ref base) => {\n-                self.consume_expr(&base);\n+                self.consume_expr(base);\n             }\n \n             hir::ExprKind::Yield(ref value, _) => {\n-                self.consume_expr(&value);\n+                self.consume_expr(value);\n             }\n         }\n     }\n@@ -547,24 +372,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Error => { }\n             _ => {\n                 if let Some(def_id) = self.mc.tables.type_dependent_def_id(call.hir_id) {\n-                    let call_scope = region::Scope {\n-                        id: call.hir_id.local_id,\n-                        data: region::ScopeData::Node\n-                    };\n                     match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                         FnMutOverloadedCall => {\n-                            let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n-                            self.borrow_expr(callee,\n-                                            call_scope_r,\n-                                            ty::MutBorrow,\n-                                            ClosureInvocation);\n+                            self.borrow_expr(callee, ty::MutBorrow);\n                         }\n                         FnOverloadedCall => {\n-                            let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n-                            self.borrow_expr(callee,\n-                                            call_scope_r,\n-                                            ty::ImmBorrow,\n-                                            ClosureInvocation);\n+                            self.borrow_expr(callee, ty::ImmBorrow);\n                         }\n                         FnOnceOverloadedCall => self.consume_expr(callee),\n                     }\n@@ -595,22 +408,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn walk_local(&mut self, local: &hir::Local) {\n-        match local.init {\n-            None => {\n-                local.pat.each_binding(|_, hir_id, span, _| {\n-                    self.delegate.decl_without_init(hir_id, span);\n-                })\n-            }\n-\n-            Some(ref expr) => {\n-                // Variable declarations with\n-                // initializers are considered\n-                // \"assigns\", which is handled by\n-                // `walk_pat`:\n-                self.walk_expr(&expr);\n-                let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n-                self.walk_irrefutable_pat(init_cmt, &local.pat);\n-            }\n+        if let Some(ref expr) = local.init {\n+            // Variable declarations with\n+            // initializers are considered\n+            // \"assigns\", which is handled by\n+            // `walk_pat`:\n+            self.walk_expr(&expr);\n+            let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n+            self.walk_irrefutable_pat(init_cmt, &local.pat);\n         }\n     }\n \n@@ -660,7 +465,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             with_field.ident,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.hir_id, with_expr.span, &cmt_field);\n+                        self.delegate_consume(&cmt_field);\n                     }\n                 }\n             }\n@@ -695,7 +500,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 adjustment::Adjust::Pointer(_)  => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.hir_id, expr.span, &cmt);\n+                    self.delegate_consume(&cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -707,7 +512,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.hir_id, expr.span, &cmt, deref.region, bk, AutoRef);\n+                    self.delegate.borrow(&cmt, bk);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n@@ -731,47 +536,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                autoref);\n \n         match *autoref {\n-            adjustment::AutoBorrow::Ref(r, m) => {\n-                self.delegate.borrow(expr.hir_id,\n-                                     expr.span,\n-                                     cmt_base,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m.into()),\n-                                     AutoRef);\n+            adjustment::AutoBorrow::Ref(_, m) => {\n+                self.delegate.borrow(cmt_base, ty::BorrowKind::from_mutbl(m.into()));\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n                 debug!(\"walk_autoref: expr.hir_id={} cmt_base={:?}\",\n                        expr.hir_id,\n                        cmt_base);\n \n-                // Converting from a &T to *T (or &mut T to *mut T) is\n-                // treated as borrowing it for the enclosing temporary\n-                // scope.\n-                let r = self.tcx().mk_region(ty::ReScope(\n-                    region::Scope {\n-                        id: expr.hir_id.local_id,\n-                        data: region::ScopeData::Node\n-                    }));\n-\n-                self.delegate.borrow(expr.hir_id,\n-                                     expr.span,\n-                                     cmt_base,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m),\n-                                     AutoUnsafe);\n+\n+                self.delegate.borrow(cmt_base, ty::BorrowKind::from_mutbl(m));\n             }\n         }\n     }\n \n-    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n-        let mut mode = Unknown;\n-        self.determine_pat_move_mode(discr_cmt.clone(), &arm.pat, &mut mode);\n-        mode\n-    }\n-\n-    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n-        self.walk_pat(discr_cmt.clone(), &arm.pat, mode);\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) {\n+        self.walk_pat(discr_cmt.clone(), &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n             self.consume_expr(e)\n@@ -783,55 +564,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n-        let mut mode = Unknown;\n-        self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);\n-        let mode = mode.match_mode();\n-        self.walk_pat(cmt_discr, pat, mode);\n+        self.walk_pat(cmt_discr, pat);\n     }\n \n-    /// Identifies any bindings within `pat` and accumulates within\n-    /// `mode` whether the overall pattern/match structure is a move,\n-    /// copy, or borrow.\n-    fn determine_pat_move_mode(&mut self,\n-                               cmt_discr: mc::cmt<'tcx>,\n-                               pat: &hir::Pat,\n-                               mode: &mut TrackMatchMode) {\n-        debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n-\n-        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(..) = pat.kind {\n-                let bm = *self.mc.tables.pat_binding_modes()\n-                                        .get(pat.hir_id)\n-                                        .expect(\"missing binding mode\");\n-                match bm {\n-                    ty::BindByReference(..) =>\n-                        mode.lub(BorrowingMatch),\n-                    ty::BindByValue(..) => {\n-                        match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n-                            Copy => mode.lub(CopyingMatch),\n-                            Move(..) => mode.lub(MovingMatch),\n-                        }\n-                    }\n-                }\n-            }\n-        }));\n-    }\n \n-    /// The core driver for walking a pattern; `match_mode` must be\n-    /// established up front, e.g., via `determine_pat_move_mode` (see\n-    /// also `walk_irrefutable_pat` for patterns that stand alone).\n-    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n+    /// The core driver for walking a pattern\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n \n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\n-                    \"walk_pat: binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                    \"walk_pat: binding cmt_pat={:?} pat={:?}\",\n                     cmt_pat,\n                     pat,\n-                    match_mode,\n                 );\n                 if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n                     debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n@@ -844,75 +592,34 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     // binding being produced.\n                     let def = Res::Local(canonical_id);\n                     if let Ok(ref binding_cmt) = mc.cat_res(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n+                        delegate.mutate(binding_cmt);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n-                            if let ty::Ref(r, _, _) = pat_ty.kind {\n-                                let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.hir_id, pat.span, &cmt_pat, r, bk, RefBinding);\n-                            }\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(&cmt_pat, bk);\n                         }\n                         ty::BindByValue(..) => {\n-                            let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n+                            let mode = copy_or_move(mc, param_env, &cmt_pat);\n                             debug!(\"walk_pat binding consuming pat\");\n-                            delegate.consume_pat(pat, &cmt_pat, mode);\n+                            delegate.consume(&cmt_pat, mode);\n                         }\n                     }\n                 } else {\n                     tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n         }));\n-\n-        // Do a second pass over the pattern, calling `matched_pat` on\n-        // the interior nodes (enum variants and structs), as opposed\n-        // to the above loop's visit of than the bindings that form\n-        // the leaves of the pattern tree structure.\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            let qpath = match pat.kind {\n-                PatKind::Path(ref qpath) |\n-                PatKind::TupleStruct(ref qpath, ..) |\n-                PatKind::Struct(ref qpath, ..) => qpath,\n-                _ => return\n-            };\n-            let res = mc.tables.qpath_res(qpath, pat.hir_id);\n-            match res {\n-                Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_did) => {\n-                    let variant_did = mc.tcx.parent(variant_ctor_did).unwrap();\n-                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n-\n-                    debug!(\"variantctor downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n-                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n-                }\n-                Res::Def(DefKind::Variant, variant_did) => {\n-                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n-\n-                    debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n-                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n-                }\n-                Res::Def(DefKind::Struct, _)\n-                | Res::Def(DefKind::Ctor(..), _)\n-                | Res::Def(DefKind::Union, _)\n-                | Res::Def(DefKind::TyAlias, _)\n-                | Res::Def(DefKind::AssocTy, _)\n-                | Res::SelfTy(..) => {\n-                    debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n-                    delegate.matched_pat(pat, &cmt_pat, match_mode);\n-                }\n-                _ => {}\n-            }\n-        }));\n     }\n \n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);\n         if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n-            for (&var_id, upvar) in upvars.iter() {\n+            for &var_id in upvars.keys() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -923,19 +630,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                                                                    var_id));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(&self.mc,\n-                                                self.param_env,\n-                                                &cmt_var,\n-                                                CaptureMove);\n-                        self.delegate.consume(closure_expr.hir_id, upvar.span, &cmt_var, mode);\n+                        let mode = copy_or_move(&self.mc, self.param_env, &cmt_var);\n+                        self.delegate.consume(&cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(closure_expr.hir_id,\n-                                             fn_decl_span,\n-                                             &cmt_var,\n-                                             upvar_borrow.region,\n-                                             upvar_borrow.kind,\n-                                             ClosureCapture(upvar.span));\n+                        self.delegate.borrow(&cmt_var, upvar_borrow.kind);\n                     }\n                 }\n             }\n@@ -958,10 +657,9 @@ fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cmt: &mc::cmt_<'tcx>,\n-    move_reason: MoveReason,\n ) -> ConsumeMode {\n     if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n-        Move(move_reason)\n+        Move\n     } else {\n         Copy\n     }"}, {"sha": "c0fdd743286dd156fa3c144519e98c21edbecc3a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 48, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b4ad612697b7dccbf83562010fcfaa36023324cd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ad612697b7dccbf83562010fcfaa36023324cd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b4ad612697b7dccbf83562010fcfaa36023324cd", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             euv::Copy => {\n                 return;\n             }\n-            euv::Move(_) => {}\n+            euv::Move => {}\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -582,48 +582,13 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(\n-        &mut self,\n-        _consume_id: hir::HirId,\n-        _consume_span: Span,\n-        cmt: &mc::cmt_<'tcx>,\n-        mode: euv::ConsumeMode,\n-    ) {\n+    fn consume(&mut self, cmt: &mc::cmt_<'tcx>,mode: euv::ConsumeMode) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(\n-        &mut self,\n-        _matched_pat: &hir::Pat,\n-        _cmt: &mc::cmt_<'tcx>,\n-        _mode: euv::MatchMode,\n-    ) {\n-    }\n-\n-    fn consume_pat(\n-        &mut self,\n-        _consume_pat: &hir::Pat,\n-        cmt: &mc::cmt_<'tcx>,\n-        mode: euv::ConsumeMode,\n-    ) {\n-        debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n-        self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n-    }\n-\n-    fn borrow(\n-        &mut self,\n-        borrow_id: hir::HirId,\n-        _borrow_span: Span,\n-        cmt: &mc::cmt_<'tcx>,\n-        _loan_region: ty::Region<'tcx>,\n-        bk: ty::BorrowKind,\n-        _loan_cause: euv::LoanCause,\n-    ) {\n-        debug!(\n-            \"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n-            borrow_id, cmt, bk\n-        );\n+    fn borrow(&mut self, cmt: &mc::cmt_<'tcx>, bk: ty::BorrowKind) {\n+        debug!(\"borrow(cmt={:?}, bk={:?})\", cmt, bk);\n \n         match bk {\n             ty::ImmBorrow => {}\n@@ -636,15 +601,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n-\n-    fn mutate(\n-        &mut self,\n-        _assignment_id: hir::HirId,\n-        _assignment_span: Span,\n-        assignee_cmt: &mc::cmt_<'tcx>,\n-        _mode: euv::MutateMode,\n-    ) {\n+    fn mutate(&mut self, assignee_cmt: &mc::cmt_<'tcx>) {\n         debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);"}]}