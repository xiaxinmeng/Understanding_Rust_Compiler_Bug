{"sha": "89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5Y2ZkMDhiNDdmMzhmMjcyMWEwMGJkMGEyYmEyZmNlNmY1MzBjNzk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-25T09:07:03Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "validate enum discriminant whenever it is read", "tree": {"sha": "3bbc90fd65fa15571f4b219ed433171f724c84d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bbc90fd65fa15571f4b219ed433171f724c84d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "html_url": "https://github.com/rust-lang/rust/commit/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "url": "https://api.github.com/repos/rust-lang/rust/commits/548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "html_url": "https://github.com/rust-lang/rust/commit/548b3738c2fa83d8ba91384cbcd2df37b2eba45c"}], "stats": {"total": 129, "additions": 64, "deletions": 65}, "files": [{"sha": "c62ed841866df2c1e4ac531d7305f5566a87fd9d", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -303,7 +303,7 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n             InvalidBool =>\n                 \"invalid boolean value read\",\n             InvalidDiscriminant =>\n-                \"invalid enum discriminant value read\",\n+                \"invalid enum discriminant value read or written\",\n             PointerOutOfBounds { .. } =>\n                 \"pointer offset outside bounds of allocation\",\n             InvalidNullPointerUsage =>"}, {"sha": "3017197477c820c5a2be60e6b7b10967e3405f71", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -382,7 +382,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let op = ecx.const_to_op(val)?;\n-    ecx.read_discriminant_as_variant_index(op)\n+    Ok(ecx.read_discriminant(op)?.1)\n }\n \n pub fn const_to_allocation_provider<'a, 'tcx>("}, {"sha": "32ea63514067cc7c5532bbf6d368c86340225f60", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -544,34 +544,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.const_value_to_op(cv.val)\n     }\n \n-    /// reads a tag and produces the corresponding variant index\n-    pub fn read_discriminant_as_variant_index(\n+    /// Read discriminant, return the runtime value as well as the variant index.\n+    pub fn read_discriminant(\n         &self,\n         rval: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, usize> {\n-        match rval.layout.variants {\n-            layout::Variants::Single { index } => Ok(index),\n-            layout::Variants::Tagged { .. } => {\n-                let discr_val = self.read_discriminant_value(rval)?;\n-                rval.layout.ty\n-                    .ty_adt_def()\n-                    .expect(\"tagged layout for non adt\")\n-                    .discriminants(self.tcx.tcx)\n-                    .position(|var| var.val == discr_val)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n-            }\n-            layout::Variants::NicheFilling { .. } => {\n-                let discr_val = self.read_discriminant_value(rval)?;\n-                assert_eq!(discr_val as usize as u128, discr_val);\n-                Ok(discr_val as usize)\n-            },\n-        }\n-    }\n-\n-    pub fn read_discriminant_value(\n-        &self,\n-        rval: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, u128> {\n+    ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n         if rval.layout.abi == layout::Abi::Uninhabited {\n             return err!(Unreachable);\n@@ -582,20 +559,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let discr_val = rval.layout.ty.ty_adt_def().map_or(\n                     index as u128,\n                     |def| def.discriminant_for_variant(*self.tcx, index).val);\n-                return Ok(discr_val);\n+                return Ok((discr_val, index));\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n         }\n+        // read raw discriminant value\n         let discr_op = self.operand_field(rval, 0)?;\n         let discr_val = self.read_value(discr_op)?;\n-        trace!(\"discr value: {:?}\", discr_val);\n         let raw_discr = discr_val.to_scalar()?;\n+        trace!(\"discr value: {:?}\", raw_discr);\n+        // post-process\n         Ok(match rval.layout.variants {\n             layout::Variants::Single { .. } => bug!(),\n-            // FIXME: We should catch invalid discriminants here!\n             layout::Variants::Tagged { .. } => {\n-                if discr_val.layout.ty.is_signed() {\n+                let real_discr = if discr_val.layout.ty.is_signed() {\n                     let i = raw_discr.to_bits(discr_val.layout.size)? as i128;\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant\n@@ -612,7 +590,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     (truncatee << shift) >> shift\n                 } else {\n                     raw_discr.to_bits(discr_val.layout.size)?\n-                }\n+                };\n+                // Make sure we catch invalid discriminants\n+                let index = rval.layout.ty\n+                    .ty_adt_def()\n+                    .expect(\"tagged layout for non adt\")\n+                    .discriminants(self.tcx.tcx)\n+                    .position(|var| var.val == real_discr)\n+                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant)?;\n+                (real_discr, index)\n             },\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -622,8 +608,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             } => {\n                 let variants_start = *niche_variants.start() as u128;\n                 let variants_end = *niche_variants.end() as u128;\n-                match raw_discr {\n+                let real_discr = match raw_discr {\n                     Scalar::Ptr(_) => {\n+                        // The niche must be just 0 (which a pointer value never is)\n                         assert!(niche_start == 0);\n                         assert!(variants_start == variants_end);\n                         dataful_variant as u128\n@@ -638,7 +625,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             dataful_variant as u128\n                         }\n                     },\n-                }\n+                };\n+                let index = real_discr as usize;\n+                assert_eq!(index as u128, real_discr);\n+                assert!(index < rval.layout.ty\n+                    .ty_adt_def()\n+                    .expect(\"tagged layout for non adt\")\n+                    .variants.len());\n+                (real_discr, index)\n             }\n         })\n     }"}, {"sha": "b1eb3749d5d2034af3eb2a7eca96ec519c643462", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -702,22 +702,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n-    pub fn write_discriminant_value(\n+    pub fn write_discriminant_index(\n         &mut self,\n         variant_index: usize,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match dest.layout.variants {\n             layout::Variants::Single { index } => {\n                 if index != variant_index {\n-                    // If the layout of an enum is `Single`, all\n-                    // other variants are necessarily uninhabited.\n-                    assert_eq!(dest.layout.for_variant(&self, variant_index).abi,\n-                               layout::Abi::Uninhabited);\n+                    return err!(InvalidDiscriminant);\n                 }\n             }\n             layout::Variants::Tagged { ref tag, .. } => {\n-                let discr_val = dest.layout.ty.ty_adt_def().unwrap()\n+                let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n+                if variant_index >= adt_def.variants.len() {\n+                    return err!(InvalidDiscriminant);\n+                }\n+                let discr_val = adt_def\n                     .discriminant_for_variant(*self.tcx, variant_index)\n                     .val;\n \n@@ -740,6 +741,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 niche_start,\n                 ..\n             } => {\n+                if variant_index >= dest.layout.ty.ty_adt_def().unwrap().variants.len() {\n+                    return err!(InvalidDiscriminant);\n+                }\n                 if variant_index != dataful_variant {\n                     let niche_dest =\n                         self.place_field(dest, 0)?;"}, {"sha": "b2faf59af3e842b4870d239e4eac4048621202af", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 variant_index,\n             } => {\n                 let dest = self.eval_place(place)?;\n-                self.write_discriminant_value(variant_index, dest)?;\n+                self.write_discriminant_index(variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -222,7 +222,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant_value(variant_index, dest)?;\n+                        self.write_discriminant_index(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)\n                         } else {\n@@ -312,7 +312,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             Discriminant(ref place) => {\n                 let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant_value(self.place_to_op(place)?)?;\n+                let discr_val = self.read_discriminant(self.place_to_op(place)?)?.0;\n                 let size = dest.layout.size.bytes() as u8;\n                 self.write_scalar(Scalar::Bits {\n                     bits: discr_val,"}, {"sha": "a3752a05fc812837fabf5d94ff9167b31a1b50e6", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -198,25 +198,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         seen: &mut FxHashSet<(OpTy<'tcx>)>,\n         todo: &mut Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n+        trace!(\"validate_operand: {:?}, {:#?}\", *dest, dest.layout);\n \n         // Find the right variant.  We have to handle this as a prelude, not via\n         // proper recursion with the new inner layout, to be able to later nicely\n         // print the field names of the enum field that is being accessed.\n         let (variant, dest) = match dest.layout.variants {\n-            layout::Variants::NicheFilling { niche: ref tag, .. } |\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let size = tag.value.size(self);\n-                // we first read the tag value as scalar, to be able to validate it\n-                let tag_mplace = self.operand_field(dest, 0)?;\n-                let tag_value = self.read_scalar(tag_mplace)?;\n-                path.push(PathElem::Tag);\n-                self.validate_scalar(\n-                    tag_value, size, tag, &path, tag_mplace.layout.ty\n-                )?;\n-                path.pop(); // remove the element again\n-                // then we read it again to get the index, to continue\n-                let variant = self.read_discriminant_as_variant_index(dest.into())?;\n+            layout::Variants::NicheFilling { .. } |\n+            layout::Variants::Tagged { .. } => {\n+                let variant = match self.read_discriminant(dest) {\n+                    Ok(res) => res.1,\n+                    Err(err) => match err.kind {\n+                        EvalErrorKind::InvalidDiscriminant |\n+                        EvalErrorKind::ReadPointerAsBytes =>\n+                            return validation_failure!(\n+                                \"invalid enum discriminant\", path\n+                            ),\n+                        _ => return Err(err),\n+                    }\n+                };\n                 let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n                 path.push(PathElem::Field(dest.layout.ty\n@@ -258,17 +258,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                                 if let Some(AllocType::Static(did)) = alloc_kind {\n                                     // statics from other crates are already checked.\n-                                    // extern statics should not be validated as they have no body.\n+                                    // extern statics cannot be validated as they have no body.\n                                     if !did.is_local() || self.tcx.is_foreign_item(did) {\n                                         return Ok(());\n                                     }\n                                 }\n                                 if value.layout.ty.builtin_deref(false).is_some() {\n-                                    trace!(\"Recursing below ptr {:#?}\", value);\n                                     let ptr_op = self.ref_to_mplace(value)?.into();\n                                     // we have not encountered this pointer+layout combination\n                                     // before.\n                                     if seen.insert(ptr_op) {\n+                                        trace!(\"Recursing below ptr {:#?}\", *value);\n                                         todo.push((ptr_op, path_clone_and_deref(path)));\n                                     }\n                                 }\n@@ -284,6 +284,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n             layout::FieldPlacement::Array { .. } => {\n+                // FIXME: For a TyStr, check that this is valid UTF-8.\n                 // Skips for ZSTs; we could have an empty array as an immediate\n                 if !dest.layout.is_zst() {\n                     let dest = dest.to_mem_place(); // arrays cannot be immediate\n@@ -316,8 +317,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     let unpacked_ptr = self.unpack_unsized_mplace(ptr)?.into();\n                     // for safe ptrs, recursively check it\n                     if !dest.layout.ty.is_unsafe_ptr() {\n-                        trace!(\"Recursing below fat ptr {:?} (unpacked: {:?})\", ptr, unpacked_ptr);\n                         if seen.insert(unpacked_ptr) {\n+                            trace!(\"Recursing below fat ptr {:?} (unpacked: {:?})\",\n+                                ptr, unpacked_ptr);\n                             todo.push((unpacked_ptr, path_clone_and_deref(path)));\n                         }\n                     }\n@@ -329,7 +331,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         self.validate_operand(field, path, seen, todo)?;\n                         path.truncate(path_len);\n                     }\n-                    // FIXME: For a TyStr, check that this is valid UTF-8.\n                 }\n             }\n         }"}, {"sha": "6b33007ec098494bf86ae4991309d190e7cbad85", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n LL | |     Union { usize: &BAR }.foo,\n LL | |     Union { usize: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 5 at .1.<deref>.<enum-tag>, but expected something in the range 42..=99\n+   | |___^ type validation failed: encountered invalid enum discriminant at .1.<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "bb015db3e5419e27924f00b169f9e65a5c7a5818", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "patch": "@@ -2,15 +2,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:22:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .<enum-tag>, but expected something in the range 0..=0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:35:1\n    |\n LL | const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0 at .<enum-tag>, but expected something in the range 2..=2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}