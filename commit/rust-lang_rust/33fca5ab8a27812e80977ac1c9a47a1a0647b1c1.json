{"sha": "33fca5ab8a27812e80977ac1c9a47a1a0647b1c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZmNhNWFiOGEyNzgxMmU4MDk3N2FjMWM5YTQ3YTFhMDY0N2IxYzE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-08-14T01:00:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-14T01:00:21Z"}, "message": "Rollup merge of #75477 - RalfJung:fn-ptrs, r=Mark-Simulacrum\n\nExpand function pointer docs\n\nBe more explicit in the ABI section, and add a section on how to obtain a function pointer, which can be somewhat confusing.\n\nCc https://github.com/rust-lang/rust/issues/75239", "tree": {"sha": "2dc373f6f05586eafcd9e6877f9126850687ce9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dc373f6f05586eafcd9e6877f9126850687ce9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33fca5ab8a27812e80977ac1c9a47a1a0647b1c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfNeImCRBK7hj4Ov3rIwAAdHIIAAWcbksqf1a3dxVkrnTRmEXK\nvvwrvjqnPJZwLg52E0qP2Ba8fPmwOwf+mUKHv+TcLX8/yDJSZvRQ5ixiHNUT810k\n8eP43Zqs+GZ6nSWAa72ZDUCWpilR3Td6BeS7HVUbnFf5nq5YAZkYfrKjmxpQlQNH\nutgDnP2KtG6pWBfTx8ChL9GuL4z10lgYkbPG6Mt3Z+t7oCApvOTSgzc8UUTeHT46\np44pMQ0eLNf6kNdAHIyHHjq5GKwFnALzV/pVir9pGl0txHXTF/NVVvykBHbyuJWb\ncdI5AkOQRZeeAjU6MOnmkNi2uhwmfyAVJ4L2FoqCFLuXxg+eh4QVIhTFDriG1XY=\n=PhPG\n-----END PGP SIGNATURE-----\n", "payload": "tree 2dc373f6f05586eafcd9e6877f9126850687ce9f\nparent d000fb1ca837f175dc5722bbbc4fe15416eb5cd9\nparent 2338903260e60e470268d92b7e4894d18a598d59\nauthor Tyler Mandry <tmandry@gmail.com> 1597366821 -0700\ncommitter GitHub <noreply@github.com> 1597366821 -0700\n\nRollup merge of #75477 - RalfJung:fn-ptrs, r=Mark-Simulacrum\n\nExpand function pointer docs\n\nBe more explicit in the ABI section, and add a section on how to obtain a function pointer, which can be somewhat confusing.\n\nCc https://github.com/rust-lang/rust/issues/75239\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33fca5ab8a27812e80977ac1c9a47a1a0647b1c1", "html_url": "https://github.com/rust-lang/rust/commit/33fca5ab8a27812e80977ac1c9a47a1a0647b1c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33fca5ab8a27812e80977ac1c9a47a1a0647b1c1/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d000fb1ca837f175dc5722bbbc4fe15416eb5cd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d000fb1ca837f175dc5722bbbc4fe15416eb5cd9", "html_url": "https://github.com/rust-lang/rust/commit/d000fb1ca837f175dc5722bbbc4fe15416eb5cd9"}, {"sha": "2338903260e60e470268d92b7e4894d18a598d59", "url": "https://api.github.com/repos/rust-lang/rust/commits/2338903260e60e470268d92b7e4894d18a598d59", "html_url": "https://github.com/rust-lang/rust/commit/2338903260e60e470268d92b7e4894d18a598d59"}], "stats": {"total": 57, "additions": 48, "deletions": 9}, "files": [{"sha": "bca1732b84d95677af4fbb4742c3b7d11beea5ab", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/33fca5ab8a27812e80977ac1c9a47a1a0647b1c1/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fca5ab8a27812e80977ac1c9a47a1a0647b1c1/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=33fca5ab8a27812e80977ac1c9a47a1a0647b1c1", "patch": "@@ -1058,6 +1058,8 @@ mod prim_ref {}\n /// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null\n /// pointers, make your type `Option<fn()>` with your required signature.\n ///\n+/// ### Safety\n+///\n /// Plain function pointers are obtained by casting either plain functions, or closures that don't\n /// capture an environment:\n ///\n@@ -1095,23 +1097,60 @@ mod prim_ref {}\n /// let really_safe_ptr: unsafe fn(usize) -> usize = add_one;\n /// ```\n ///\n-/// On top of that, function pointers can vary based on what ABI they use. This is achieved by\n-/// adding the `extern` keyword to the type name, followed by the ABI in question. For example,\n-/// `fn()` is different from `extern \"C\" fn()`, which itself is different from `extern \"stdcall\"\n-/// fn()`, and so on for the various ABIs that Rust supports. Non-`extern` functions have an ABI\n-/// of `\"Rust\"`, and `extern` functions without an explicit ABI have an ABI of `\"C\"`. For more\n-/// information, see [the nomicon's section on foreign calling conventions][nomicon-abi].\n+/// ### ABI\n+///\n+/// On top of that, function pointers can vary based on what ABI they use. This\n+/// is achieved by adding the `extern` keyword before the type, followed by the\n+/// ABI in question. The default ABI is \"Rust\", i.e., `fn()` is the exact same\n+/// type as `extern \"Rust\" fn()`. A pointer to a function with C ABI would have\n+/// type `extern \"C\" fn()`.\n+///\n+/// `extern \"ABI\" { ... }` blocks declare functions with ABI \"ABI\". The default\n+/// here is \"C\", i.e., functions declared in an `extern {...}` block have \"C\"\n+/// ABI.\n+///\n+/// For more information and a list of supported ABIs, see [the nomicon's\n+/// section on foreign calling conventions][nomicon-abi].\n ///\n-/// [nomicon-abi]: ../nomicon/ffi.html#foreign-calling-conventions\n+/// ### Variadic functions\n ///\n /// Extern function declarations with the \"C\" or \"cdecl\" ABIs can also be *variadic*, allowing them\n-/// to be called with a variable number of arguments. Normal rust functions, even those with an\n+/// to be called with a variable number of arguments. Normal Rust functions, even those with an\n /// `extern \"ABI\"`, cannot be variadic. For more information, see [the nomicon's section on\n /// variadic functions][nomicon-variadic].\n ///\n /// [nomicon-variadic]: ../nomicon/ffi.html#variadic-functions\n ///\n-/// These markers can be combined, so `unsafe extern \"stdcall\" fn()` is a valid type.\n+/// ### Creating function pointers\n+///\n+/// When `bar` is the name of a function, then the expression `bar` is *not* a\n+/// function pointer. Rather, it denotes a value of an unnameable type that\n+/// uniquely identifies the function `bar`. The value is zero-sized because the\n+/// type already identifies the function. This has the advantage that \"calling\"\n+/// the value (it implements the `Fn*` traits) does not require dynamic\n+/// dispatch.\n+///\n+/// This zero-sized type *coerces* to a regular function pointer. For example:\n+///\n+/// ```rust\n+/// use std::mem;\n+///\n+/// fn bar(x: i32) {}\n+///\n+/// let not_bar_ptr = bar; // `not_bar_ptr` is zero-sized, uniquely identifying `bar`\n+/// assert_eq!(mem::size_of_val(&not_bar_ptr), 0);\n+///\n+/// let bar_ptr: fn(i32) = not_bar_ptr; // force coercion to function pointer\n+/// assert_eq!(mem::size_of_val(&bar_ptr), mem::size_of::<usize>());\n+///\n+/// let footgun = &bar; // this is a shared reference to the zero-sized type identifying `bar`\n+/// ```\n+///\n+/// The last line shows that `&bar` is not a function pointer either. Rather, it\n+/// is a reference to the function-specific ZST. `&bar` is basically never what you\n+/// want when `bar` is a function.\n+///\n+/// ### Traits\n ///\n /// Function pointers implement the following traits:\n ///"}]}