{"sha": "fe69acfdf0592e15bc0df3caffd922748d0ab70e", "node_id": "C_kwDOAAsO6NoAKGZlNjlhY2ZkZjA1OTJlMTViYzBkZjNjYWZmZDkyMjc0OGQwYWI3MGU", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-05-29T02:03:06Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-05-29T02:03:06Z"}, "message": "Merge from rustc", "tree": {"sha": "8541126d2eb309f23bad2a88fe8d20df45db4cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8541126d2eb309f23bad2a88fe8d20df45db4cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe69acfdf0592e15bc0df3caffd922748d0ab70e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe69acfdf0592e15bc0df3caffd922748d0ab70e", "html_url": "https://github.com/rust-lang/rust/commit/fe69acfdf0592e15bc0df3caffd922748d0ab70e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe69acfdf0592e15bc0df3caffd922748d0ab70e/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5013ce996ff018d8c1de89c6505a76d2a83cfe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5013ce996ff018d8c1de89c6505a76d2a83cfe8", "html_url": "https://github.com/rust-lang/rust/commit/c5013ce996ff018d8c1de89c6505a76d2a83cfe8"}, {"sha": "2f65aac667302849407fe677cc34078300b57eee", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f65aac667302849407fe677cc34078300b57eee", "html_url": "https://github.com/rust-lang/rust/commit/2f65aac667302849407fe677cc34078300b57eee"}], "stats": {"total": 8755, "additions": 5324, "deletions": 3431}, "files": [{"sha": "443e6d09156f0a41bbb7402eed2733504e90c744", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4379,6 +4379,15 @@ dependencies = [\n  \"tracing-tree\",\n ]\n \n+[[package]]\n+name = \"rustdoc-gui-test\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"compiletest\",\n+ \"getopts\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n@@ -4972,22 +4981,22 @@ checksum = \"aac81b6fd6beb5884b0cf3321b8117e6e5d47ecb6fc89f414cfdcca8b2fe2dd8\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.38\"\n+version = \"1.0.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6a9cd18aa97d5c45c6603caea1da6628790b37f7a34b6ca89522331c5180fed0\"\n+checksum = \"978c9a314bd8dc99be594bc3c175faaa9794be04a5a5e153caba6915336cebac\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.38\"\n+version = \"1.0.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f\"\n+checksum = \"f9456a42c5b0d803c8cd86e73dd7cc9edd429499f37a3550d286d5e86720569f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]"}, {"sha": "8eb378afe428a380b45bcfa09171ae3d692f0cb1", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -40,6 +40,7 @@ members = [\n   \"src/tools/generate-copyright\",\n   \"src/tools/suggest-tests\",\n   \"src/tools/generate-windows-sys\",\n+  \"src/tools/rustdoc-gui-test\",\n ]\n \n exclude = ["}, {"sha": "fa95df685aaa4bbd6a8e70e531ce380b2403303d", "filename": "RELEASES.md", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,3 +1,139 @@\n+Version 1.70.0 (2023-06-01)\n+==========================\n+\n+<a id=\"1.70.0-Language\"></a>\n+\n+Language\n+--------\n+- [Relax ordering rules for `asm!` operands](https://github.com/rust-lang/rust/pull/105798/)\n+- [Properly allow macro expanded `format_args` invocations to uses captures](https://github.com/rust-lang/rust/pull/106505/)\n+- [Lint ambiguous glob re-exports](https://github.com/rust-lang/rust/pull/107880/)\n+- [Perform const and unsafe checking for expressions in `let _ = expr` position.](https://github.com/rust-lang/rust/pull/102256/)\n+\n+<a id=\"1.70.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+- [Extend -Cdebuginfo with new options and named aliases](https://github.com/rust-lang/rust/pull/109808/)\n+  This provides a smaller version of debuginfo for cases that only need line number information\n+  (`-Cdebuginfo=line-tables-only`), which may eventually become the default for `-Cdebuginfo=1`.\n+- [Make `unused_allocation` lint against `Box::new` too](https://github.com/rust-lang/rust/pull/104363/)\n+- [Detect uninhabited types early in const eval](https://github.com/rust-lang/rust/pull/109435/)\n+- [Switch to LLD as default linker for {arm,thumb}v4t-none-eabi](https://github.com/rust-lang/rust/pull/109721/)\n+- [Add tier 3 target `loongarch64-unknown-linux-gnu`](https://github.com/rust-lang/rust/pull/96971)\n+- [Add tier 3 target for `i586-pc-nto-qnx700` (QNX Neutrino RTOS, version 7.0)](https://github.com/rust-lang/rust/pull/109173/), \n+- [Insert alignment checks for pointer dereferences as debug assertions](https://github.com/rust-lang/rust/pull/98112)\n+  This catches undefined behavior at runtime, and may cause existing code to fail.\n+\n+Refer to Rust's [platform support page][platform-support-doc]\n+for more information on Rust's tiered platform support.\n+\n+<a id=\"1.70.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+- [Document NonZeroXxx layout guarantees](https://github.com/rust-lang/rust/pull/94786/)\n+- [Windows: make `Command` prefer non-verbatim paths](https://github.com/rust-lang/rust/pull/96391/)\n+- [Implement Default for some alloc/core iterators](https://github.com/rust-lang/rust/pull/99929/)\n+- [Fix handling of trailing bare CR in str::lines](https://github.com/rust-lang/rust/pull/100311/)\n+- [allow negative numeric literals in `concat!`](https://github.com/rust-lang/rust/pull/106844/)\n+- [Add documentation about the memory layout of `Cell`](https://github.com/rust-lang/rust/pull/106921/)\n+- [Use `partial_cmp` to implement tuple `lt`/`le`/`ge`/`gt`](https://github.com/rust-lang/rust/pull/108157/)\n+- [Stabilize `atomic_as_ptr`](https://github.com/rust-lang/rust/pull/108419/)\n+- [Stabilize `nonnull_slice_from_raw_parts`](https://github.com/rust-lang/rust/pull/97506/)\n+- [Partial stabilization of `once_cell`](https://github.com/rust-lang/rust/pull/105587/)\n+- [Stabilize `nonzero_min_max`](https://github.com/rust-lang/rust/pull/106633/)\n+- [Flatten/inline format_args!() and (string and int) literal arguments into format_args!()](https://github.com/rust-lang/rust/pull/106824/)\n+- [Stabilize movbe target feature](https://github.com/rust-lang/rust/pull/107711/)\n+- [don't splice from files into pipes in io::copy](https://github.com/rust-lang/rust/pull/108283/)\n+- [Add a builtin unstable `FnPtr` trait that is implemented for all function pointers](https://github.com/rust-lang/rust/pull/108080/)\n+  This extends `Debug`, `Pointer`, `Hash`, `PartialEq`, `Eq`, `PartialOrd`, and `Ord`\n+  implementations for function pointers with all ABIs.\n+\n+<a id=\"1.70.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`NonZero*::MIN/MAX`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroI8.html#associatedconstant.MIN)\n+- [`BinaryHeap::retain`](https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.retain)\n+- [`Default for std::collections::binary_heap::IntoIter`](https://doc.rust-lang.org/stable/std/collections/binary_heap/struct.IntoIter.html)\n+- [`Default for std::collections::btree_map::{IntoIter, Iter, IterMut}`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.IntoIter.html)\n+- [`Default for std::collections::btree_map::{IntoKeys, Keys}`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.IntoKeys.html)\n+- [`Default for std::collections::btree_map::{IntoValues, Values}`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.IntoKeys.html)\n+- [`Default for std::collections::btree_map::Range`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.Range.html)\n+- [`Default for std::collections::btree_set::{IntoIter, Iter}`](https://doc.rust-lang.org/stable/std/collections/btree_set/struct.IntoIter.html)\n+- [`Default for std::collections::btree_set::Range`](https://doc.rust-lang.org/stable/std/collections/btree_set/struct.Range.html)\n+- [`Default for std::collections::linked_list::{IntoIter, Iter, IterMut}`](https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.IntoIter.html)\n+- [`Default for std::vec::IntoIter`](https://doc.rust-lang.org/stable/alloc/vec/struct.IntoIter.html#impl-Default-for-IntoIter%3CT,+A%3E)\n+- [`Default for std::iter::Chain`](https://doc.rust-lang.org/stable/std/iter/struct.Chain.html)\n+- [`Default for std::iter::Cloned`](https://doc.rust-lang.org/stable/std/iter/struct.Cloned.html)\n+- [`Default for std::iter::Copied`](https://doc.rust-lang.org/stable/std/iter/struct.Copied.html)\n+- [`Default for std::iter::Enumerate`](https://doc.rust-lang.org/stable/std/iter/struct.Enumerate.html)\n+- [`Default for std::iter::Flatten`](https://doc.rust-lang.org/stable/std/iter/struct.Flatten.html)\n+- [`Default for std::iter::Fuse`](https://doc.rust-lang.org/stable/std/iter/struct.Fuse.html)\n+- [`Default for std::iter::Rev`](https://doc.rust-lang.org/stable/std/iter/struct.Rev.html)\n+- [`Default for std::slice::Iter`](https://doc.rust-lang.org/stable/std/slice/struct.Iter.html)\n+- [`Default for std::slice::IterMut`](https://doc.rust-lang.org/stable/std/slice/struct.IterMut.html)\n+- [`Rc::into_inner`](https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html#method.into_inner)\n+- [`Arc::into_inner`](https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#method.into_inner)\n+- [`std::cell::OnceCell`](https://doc.rust-lang.org/stable/std/cell/struct.OnceCell.html)\n+- [`Option::is_some_and`](https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.is_some_and)\n+- [`NonNull::slice_from_raw_parts`](https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.slice_from_raw_parts)\n+- [`Result::is_ok_and`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.is_ok_and)\n+- [`Result::is_err_and`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.is_err_and)\n+- [`std::sync::atomic::Atomic*::as_ptr`](https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicU8.html#method.as_ptr)\n+- [`std::io::IsTerminal`](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html)\n+- [`std::os::linux::net::SocketAddrExt`](https://doc.rust-lang.org/stable/std/os/linux/net/trait.SocketAddrExt.html)\n+- [`std::os::unix::net::UnixDatagram::bind_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html#method.bind_addr)\n+- [`std::os::unix::net::UnixDatagram::connect_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html#method.connect_addr)\n+- [`std::os::unix::net::UnixDatagram::send_to_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html#method.send_to_addr)\n+- [`std::os::unix::net::UnixListener::bind_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixListener.html#method.bind_addr)\n+- [`std::path::Path::as_mut_os_str`](https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.as_mut_os_str)\n+- [`std::sync::OnceLock`](https://doc.rust-lang.org/stable/std/sync/struct.OnceLock.html)\n+\n+<a id=\"1.70.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Add `CARGO_PKG_README`](https://github.com/rust-lang/cargo/pull/11645/)\n+- [Make `sparse` the default protocol for crates.io](https://github.com/rust-lang/cargo/pull/11791/)\n+- [Accurately show status when downgrading dependencies](https://github.com/rust-lang/cargo/pull/11839/)\n+- [Use registry.default for login/logout](https://github.com/rust-lang/cargo/pull/11949/)\n+- [Stabilize `cargo logout`](https://github.com/rust-lang/cargo/pull/11950/)\n+\n+<a id=\"1.70.0-Misc\"></a>\n+\n+Misc\n+----\n+\n+- [Stabilize rustdoc `--test-run-directory`](https://github.com/rust-lang/rust/pull/103682/)\n+\n+<a id=\"1.70.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Prevent stable `libtest` from supporting `-Zunstable-options`](https://github.com/rust-lang/rust/pull/109044/)\n+- [Perform const and unsafe checking for expressions in `let _ = expr` position.](https://github.com/rust-lang/rust/pull/102256/)\n+- [WebAssembly targets enable `sign-ext` and `mutable-globals` features in codegen](https://github.com/rust-lang/rust/issues/109807)\n+  This may cause incompatibility with older execution environments.\n+- [Insert alignment checks for pointer dereferences as debug assertions](https://github.com/rust-lang/rust/pull/98112)\n+  This catches undefined behavior at runtime, and may cause existing code to fail.\n+\n+<a id=\"1.70.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Upgrade to LLVM 16](https://github.com/rust-lang/rust/pull/109474/)\n+- [Use SipHash-1-3 instead of SipHash-2-4 for StableHasher](https://github.com/rust-lang/rust/pull/107925/)\n+\n Version 1.69.0 (2023-04-20)\n ==========================\n "}, {"sha": "6646fa9446fb1c2ac57ac1a515d47c1b24aa16dc", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -11,6 +11,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::{kw, sym};\n+#[cfg_attr(not(bootstrap), allow(hidden_glob_reexports))]\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;"}, {"sha": "15d73ed732f502b7db33c80d4c3f024c858c59ac", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1635,34 +1635,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             })\n     }\n \n-    /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n-    ///\n-    /// Depending on the origin of the StorageDeadOrDrop, this may be\n-    /// reported as either a drop or an illegal mutation of a borrowed value.\n-    /// The latter is preferred when the this is a drop triggered by a\n-    /// reassignment, as it's more user friendly to report a problem with the\n-    /// explicit assignment than the implicit drop.\n-    #[instrument(level = \"debug\", skip(self))]\n-    pub(crate) fn report_storage_dead_or_drop_of_borrowed(\n-        &mut self,\n-        location: Location,\n-        place_span: (Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        // It's sufficient to check the last desugaring as Replace is the last\n-        // one to be applied.\n-        if let Some(DesugaringKind::Replace) = place_span.1.desugaring_kind() {\n-            self.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n-        } else {\n-            self.report_borrowed_value_does_not_live_long_enough(\n-                location,\n-                borrow,\n-                place_span,\n-                Some(WriteKind::StorageDeadOrDrop),\n-            )\n-        }\n-    }\n-\n     /// This means that some data referenced by `borrow` needs to live\n     /// past the point where the StorageDeadOrDrop of `place` occurs.\n     /// This is usually interpreted as meaning that `place` has too"}, {"sha": "d0e17bf5a08489267b701fddb384161ad94c06a6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -641,13 +641,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let Some(hir::Node::Item(item)) = node else { return; };\n             let hir::ItemKind::Fn(.., body_id) = item.kind else { return; };\n             let body = self.infcx.tcx.hir().body(body_id);\n-            let mut assign_span = span;\n-            // Drop desugaring is done at MIR build so it's not in the HIR\n-            if let Some(DesugaringKind::Replace) = span.desugaring_kind() {\n-                assign_span.remove_mark();\n-            }\n \n-            let mut v = V { assign_span, err, ty, suggested: false };\n+            let mut v = V { assign_span: span, err, ty, suggested: false };\n             v.visit_body(body);\n             if !v.suggested {\n                 err.help(format!("}, {"sha": "b2ff25ecb96f4e47e1efeccaa0610a21d8d6320f", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -112,11 +112,13 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             TerminatorKind::SwitchInt { discr, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n-            TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place: drop_place, target: _, unwind: _, replace } => {\n+                let write_kind =\n+                    if *replace { WriteKind::Replace } else { WriteKind::StorageDeadOrDrop };\n                 self.access_place(\n                     location,\n                     *drop_place,\n-                    (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n+                    (AccessDepth::Drop, Write(write_kind)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }"}, {"sha": "a53ea100c224219c8de6b4ac8bcd8ce7edc0da25", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -685,17 +685,19 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             TerminatorKind::SwitchInt { discr, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n-            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place, target: _, unwind: _, replace } => {\n                 debug!(\n                     \"visit_terminator_drop \\\n                      loc: {:?} term: {:?} place: {:?} span: {:?}\",\n                     loc, term, place, span\n                 );\n \n+                let write_kind =\n+                    if *replace { WriteKind::Replace } else { WriteKind::StorageDeadOrDrop };\n                 self.access_place(\n                     loc,\n                     (*place, span),\n-                    (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n+                    (AccessDepth::Drop, Write(write_kind)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n@@ -885,6 +887,7 @@ enum ReadKind {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n     StorageDeadOrDrop,\n+    Replace,\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n@@ -1132,13 +1135,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             this.buffer_error(err);\n                         }\n                         WriteKind::StorageDeadOrDrop => this\n-                            .report_storage_dead_or_drop_of_borrowed(location, place_span, borrow),\n+                            .report_borrowed_value_does_not_live_long_enough(\n+                                location,\n+                                borrow,\n+                                place_span,\n+                                Some(WriteKind::StorageDeadOrDrop),\n+                            ),\n                         WriteKind::Mutate => {\n                             this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n                         }\n                         WriteKind::Move => {\n                             this.report_move_out_while_borrowed(location, place_span, borrow)\n                         }\n+                        WriteKind::Replace => {\n+                            this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n+                        }\n                     }\n                     Control::Break\n                 }\n@@ -1982,12 +1993,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Reservation(\n                 WriteKind::Move\n+                | WriteKind::Replace\n                 | WriteKind::StorageDeadOrDrop\n                 | WriteKind::MutableBorrow(BorrowKind::Shared)\n                 | WriteKind::MutableBorrow(BorrowKind::Shallow),\n             )\n             | Write(\n                 WriteKind::Move\n+                | WriteKind::Replace\n                 | WriteKind::StorageDeadOrDrop\n                 | WriteKind::MutableBorrow(BorrowKind::Shared)\n                 | WriteKind::MutableBorrow(BorrowKind::Shallow),"}, {"sha": "eb02604b9d925e4b4a076da6eac89ad8a3c623ff", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,9 +3,9 @@ use rustc_index::bit_set::HybridBitSet;\n use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n+use rustc_middle::traits::query::DropckOutlivesResult;\n use rustc_middle::ty::{Ty, TyCtxt, TypeVisitable, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n-use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n use std::rc::Rc;"}, {"sha": "b619e80e15f3c36041d1645c9274ae86b209b8ec", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -233,10 +233,19 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             ExprKind::Cast(local_expr, _) => {\n                 self.manage_cond_expr(local_expr);\n             }\n+            ExprKind::If(local_expr, _, _) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n             ExprKind::Index(prefix, suffix) => {\n                 self.manage_cond_expr(prefix);\n                 self.manage_cond_expr(suffix);\n             }\n+            ExprKind::Let(_, local_expr, _) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n+            ExprKind::Match(local_expr, _) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n             ExprKind::MethodCall(call) => {\n                 for arg in &mut call.args {\n                     self.manage_cond_expr(arg);\n@@ -295,17 +304,14 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Continue(_)\n             | ExprKind::Err\n             | ExprKind::Field(_, _)\n-            | ExprKind::FormatArgs(_)\n             | ExprKind::ForLoop(_, _, _, _)\n-            | ExprKind::If(_, _, _)\n+            | ExprKind::FormatArgs(_)\n             | ExprKind::IncludedBytes(..)\n             | ExprKind::InlineAsm(_)\n-            | ExprKind::OffsetOf(_, _)\n-            | ExprKind::Let(_, _, _)\n             | ExprKind::Lit(_)\n             | ExprKind::Loop(_, _, _)\n             | ExprKind::MacCall(_)\n-            | ExprKind::Match(_, _)\n+            | ExprKind::OffsetOf(_, _)\n             | ExprKind::Path(_, _)\n             | ExprKind::Ret(_)\n             | ExprKind::Try(_)"}, {"sha": "fcfa0b862d4b5a8755a13374945a7e57766af4af", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -473,7 +473,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop { place, target, unwind: _ } => {\n+            TerminatorKind::Drop { place, target, unwind: _, replace: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, source_info, drop_place);\n "}, {"sha": "70cb6dfd66f27bde23afcad51e6027c34520b165", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -361,7 +361,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            ty::EarlyBinder(value),\n+            ty::EarlyBinder::new(value),\n         )\n     }\n "}, {"sha": "6d00464e0a0b31cbf3755568c25ee34e044e8e7a", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -88,6 +88,9 @@ pub fn sanitize_attrs<'ll>(\n \n         attrs.push(llvm::AttributeKind::SanitizeMemTag.create_attr(cx.llcx));\n     }\n+    if enabled.contains(SanitizerSet::SAFESTACK) {\n+        attrs.push(llvm::AttributeKind::SanitizeSafeStack.create_attr(cx.llcx));\n+    }\n     attrs\n }\n "}, {"sha": "6cb9e163b404ece9395249f6cf8e9db5e7b33693", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -93,7 +93,7 @@ fn make_mir_scope<'ll, 'tcx>(\n             let callee = cx.tcx.subst_and_normalize_erasing_regions(\n                 instance.substs,\n                 ty::ParamEnv::reveal_all(),\n-                ty::EarlyBinder(callee),\n+                ty::EarlyBinder::new(callee),\n             );\n             let callee_fn_abi = cx.fn_abi_of_instance(callee, ty::List::empty());\n             cx.dbg_scope_fn(callee, callee_fn_abi, None)"}, {"sha": "6ef3418cc5f77a0dd1c078b8321dbca73056a588", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -196,6 +196,7 @@ pub enum AttributeKind {\n     AllocSize = 37,\n     AllocatedPointer = 38,\n     AllocAlign = 39,\n+    SanitizeSafeStack = 40,\n }\n \n /// LLVMIntPredicate"}, {"sha": "5cc234268b0160b3f31ffecbbf9bece26623b63a", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1188,6 +1188,9 @@ fn add_sanitizer_libraries(sess: &Session, crate_type: CrateType, linker: &mut d\n     if sanitizer.contains(SanitizerSet::HWADDRESS) {\n         link_sanitizer_runtime(sess, linker, \"hwasan\");\n     }\n+    if sanitizer.contains(SanitizerSet::SAFESTACK) {\n+        link_sanitizer_runtime(sess, linker, \"safestack\");\n+    }\n }\n \n fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {"}, {"sha": "3f0b64b1103d6a58c2903f146f0c66ca98112853", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1256,7 +1256,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 MergingSucc::False\n             }\n \n-            mir::TerminatorKind::Drop { place, target, unwind } => {\n+            mir::TerminatorKind::Drop { place, target, unwind, replace: _ } => {\n                 self.codegen_drop_terminator(helper, bx, place, target, unwind, mergeable_succ())\n             }\n "}, {"sha": "51393a5d774dc58e37cfc8001bc12091f61f00fb", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.cx.tcx(),\n             ty::ParamEnv::reveal_all(),\n-            ty::EarlyBinder(value),\n+            ty::EarlyBinder::new(value),\n         )\n     }\n }"}, {"sha": "9195ae163bc6134bf86660ad4ecfaebe99eed8bb", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -497,7 +497,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .try_subst_mir_and_normalize_erasing_regions(\n                 *self.tcx,\n                 self.param_env,\n-                ty::EarlyBinder(value),\n+                ty::EarlyBinder::new(value),\n             )\n             .map_err(|_| err_inval!(TooGeneric))\n     }"}, {"sha": "586e8f063eeefa588f58d75981f177904be37049", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -114,7 +114,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Drop { place, target, unwind } => {\n+            Drop { place, target, unwind, replace: _ } => {\n                 let frame = self.frame();\n                 let ty = place.ty(&frame.body.local_decls, *self.tcx).ty;\n                 let ty = self.subst_from_frame_and_normalize_erasing_regions(frame, ty)?;"}, {"sha": "40cbf14958e77de715935be419a6e6531b757893", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,4 +1,6 @@\n use crate::fx::{FxHashMap, FxHasher};\n+#[cfg(parallel_compiler)]\n+use crate::sync::is_dyn_thread_safe;\n use crate::sync::{CacheAligned, Lock, LockGuard};\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n@@ -18,6 +20,11 @@ pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n pub struct Sharded<T> {\n+    /// This mask is used to ensure that accesses are inbounds of `shards`.\n+    /// When dynamic thread safety is off, this field is set to 0 causing only\n+    /// a single shard to be used for greater cache efficiency.\n+    #[cfg(parallel_compiler)]\n+    mask: usize,\n     shards: [CacheAligned<Lock<T>>; SHARDS],\n }\n \n@@ -31,31 +38,54 @@ impl<T: Default> Default for Sharded<T> {\n impl<T> Sharded<T> {\n     #[inline]\n     pub fn new(mut value: impl FnMut() -> T) -> Self {\n-        Sharded { shards: [(); SHARDS].map(|()| CacheAligned(Lock::new(value()))) }\n+        Sharded {\n+            #[cfg(parallel_compiler)]\n+            mask: if is_dyn_thread_safe() { SHARDS - 1 } else { 0 },\n+            shards: [(); SHARDS].map(|()| CacheAligned(Lock::new(value()))),\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn mask(&self) -> usize {\n+        #[cfg(parallel_compiler)]\n+        {\n+            if SHARDS == 1 { 0 } else { self.mask }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            0\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn count(&self) -> usize {\n+        // `self.mask` is always one below the used shard count\n+        self.mask() + 1\n     }\n \n     /// The shard is selected by hashing `val` with `FxHasher`.\n     #[inline]\n     pub fn get_shard_by_value<K: Hash + ?Sized>(&self, val: &K) -> &Lock<T> {\n-        if SHARDS == 1 { &self.shards[0].0 } else { self.get_shard_by_hash(make_hash(val)) }\n+        self.get_shard_by_hash(if SHARDS == 1 { 0 } else { make_hash(val) })\n     }\n \n     #[inline]\n     pub fn get_shard_by_hash(&self, hash: u64) -> &Lock<T> {\n-        &self.shards[get_shard_index_by_hash(hash)].0\n+        self.get_shard_by_index(get_shard_hash(hash))\n     }\n \n     #[inline]\n     pub fn get_shard_by_index(&self, i: usize) -> &Lock<T> {\n-        &self.shards[i].0\n+        // SAFETY: The index get ANDed with the mask, ensuring it is always inbounds.\n+        unsafe { &self.shards.get_unchecked(i & self.mask()).0 }\n     }\n \n     pub fn lock_shards(&self) -> Vec<LockGuard<'_, T>> {\n-        (0..SHARDS).map(|i| self.shards[i].0.lock()).collect()\n+        (0..self.count()).map(|i| self.get_shard_by_index(i).lock()).collect()\n     }\n \n     pub fn try_lock_shards(&self) -> Option<Vec<LockGuard<'_, T>>> {\n-        (0..SHARDS).map(|i| self.shards[i].0.try_lock()).collect()\n+        (0..self.count()).map(|i| self.get_shard_by_index(i).try_lock()).collect()\n     }\n }\n \n@@ -136,11 +166,9 @@ pub fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n /// `hash` can be computed with any hasher, so long as that hasher is used\n /// consistently for each `Sharded` instance.\n #[inline]\n-#[allow(clippy::modulo_one)]\n-pub fn get_shard_index_by_hash(hash: u64) -> usize {\n+fn get_shard_hash(hash: u64) -> usize {\n     let hash_len = mem::size_of::<usize>();\n     // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits.\n     // hashbrown also uses the lowest bits, so we can't use those\n-    let bits = (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize;\n-    bits % SHARDS\n+    (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize\n }"}, {"sha": "eb92ccc17b20ff84cdcd715b3b95b5ea78b4528d", "filename": "compiler/rustc_driver_impl/src/args.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -18,6 +18,9 @@ fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     }\n }\n \n+/// **Note:** This function doesn't interpret argument 0 in any special way.\n+/// If this function is intended to be used with command line arguments,\n+/// `argv[0]` must be removed prior to calling it manually.\n pub fn arg_expand_all(at_args: &[String]) -> Vec<String> {\n     let mut args = Vec::new();\n     for arg in at_args {"}, {"sha": "0b5d737091e4c20444a5916e024ea8a8607a7cb2", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -250,6 +250,16 @@ fn run_compiler(\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n     >,\n ) -> interface::Result<()> {\n+    // Throw away the first argument, the name of the binary.\n+    // In case of at_args being empty, as might be the case by\n+    // passing empty argument array to execve under some platforms,\n+    // just use an empty slice.\n+    //\n+    // This situation was possible before due to arg_expand_all being\n+    // called before removing the argument, enabling a crash by calling\n+    // the compiler with @empty_file as argv[0] and no more arguments.\n+    let at_args = at_args.get(1..).unwrap_or_default();\n+\n     let args = args::arg_expand_all(at_args);\n \n     let Some(matches) = handle_options(&args) else { return Ok(()) };\n@@ -1074,9 +1084,6 @@ fn print_flag_list<T>(\n /// So with all that in mind, the comments below have some more detail about the\n /// contortions done here to get things to work out correctly.\n pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n-    // Throw away the first argument, the name of the binary\n-    let args = &args[1..];\n-\n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not\n         // include that extra information."}, {"sha": "284ae0e1e58a27539095ab8640d6c3bd80d0a852", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1159,7 +1159,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // those that do.\n             self.one_bound_for_assoc_type(\n                 || traits::supertraits(tcx, trait_ref),\n-                trait_ref.print_only_trait_path(),\n+                trait_ref.skip_binder().print_only_trait_name(),\n                 binding.item_name,\n                 path_span,\n                 match binding.kind {\n@@ -1278,7 +1278,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // params (and trait ref's late bound params). This logic is very similar to\n             // `Predicate::subst_supertrait`, and it's no coincidence why.\n             let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n-            let subst_output = ty::EarlyBinder(shifted_output).subst(tcx, substs);\n+            let subst_output = ty::EarlyBinder::new(shifted_output).subst(tcx, substs);\n \n             let bound_vars = tcx.late_bound_vars(binding.hir_id);\n             ty::Binder::bind_with_vars(subst_output, bound_vars)"}, {"sha": "7df811ccdb5c1804afccdb7a60fa224661ac18e5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -794,14 +794,14 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                     })\n                 });\n                 debug!(%ty);\n-                collected_tys.insert(def_id, ty::EarlyBinder(ty));\n+                collected_tys.insert(def_id, ty::EarlyBinder::new(ty));\n             }\n             Err(err) => {\n                 let reported = tcx.sess.delay_span_bug(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, ty::EarlyBinder(tcx.ty_error(reported)));\n+                collected_tys.insert(def_id, ty::EarlyBinder::new(tcx.ty_error(reported)));\n             }\n         }\n     }\n@@ -901,7 +901,7 @@ fn report_trait_method_mismatch<'tcx>(\n             if trait_m.fn_has_self_parameter =>\n         {\n             let ty = trait_sig.inputs()[0];\n-            let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+            let sugg = match ExplicitSelf::determine(ty, |ty| ty == impl_trait_ref.self_ty()) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n                 ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n                 ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),"}, {"sha": "eeb69c389cd804c207e0e38ae63c7b5cba607334", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -128,7 +128,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // We don't need to normalize this param-env or anything, since we're only\n     // substituting it with free params, so no additional param-env normalization\n     // can occur on top of what has been done in the param_env query itself.\n-    let param_env = ty::EarlyBinder(tcx.param_env(adt_def_id))\n+    let param_env = ty::EarlyBinder::new(tcx.param_env(adt_def_id))\n         .subst(tcx, adt_to_impl_substs)\n         .with_constness(tcx.constness(drop_impl_def_id));\n "}, {"sha": "4c513c4d8cc6a046976e4f7e46d1f080b254f4e9", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1398,7 +1398,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = ty::EarlyBinder(pred).subst(tcx, substs);\n+            let substituted_pred = ty::EarlyBinder::new(pred).subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_non_region_param() || param_count.params.len() > 1 || has_region"}, {"sha": "75d99fee152ea686af60ef549b1896982f2e733d", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1124,7 +1124,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<ty::PolyFnSig<\n             bug!(\"unexpected sort of node in fn_sig(): {:?}\", x);\n         }\n     };\n-    ty::EarlyBinder(output)\n+    ty::EarlyBinder::new(output)\n }\n \n fn infer_return_ty_for_fn_sig<'tcx>(\n@@ -1312,7 +1312,7 @@ fn impl_trait_ref(\n                 check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n             )\n         })\n-        .map(ty::EarlyBinder)\n+        .map(ty::EarlyBinder::new)\n }\n \n fn check_impl_constness("}, {"sha": "03c8c59402e76d86bb218d6d7dc086b97cf68eed", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -86,7 +86,7 @@ pub(super) fn explicit_item_bounds(\n         Some(ty::ImplTraitInTraitData::Trait { opaque_def_id, .. }) => {\n             let item = tcx.hir().get_by_def_id(opaque_def_id.expect_local()).expect_item();\n             let opaque_ty = item.expect_opaque_ty();\n-            return ty::EarlyBinder(opaque_type_bounds(\n+            return ty::EarlyBinder::new(opaque_type_bounds(\n                 tcx,\n                 opaque_def_id.expect_local(),\n                 opaque_ty.bounds,\n@@ -124,7 +124,7 @@ pub(super) fn explicit_item_bounds(\n         }\n         _ => bug!(\"item_bounds called on {:?}\", def_id),\n     };\n-    ty::EarlyBinder(bounds)\n+    ty::EarlyBinder::new(bounds)\n }\n \n pub(super) fn item_bounds("}, {"sha": "0b57d6965856314d7d19673210738b81694dc581", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -323,7 +323,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                 return map[&assoc_item.trait_item_def_id.unwrap()];\n             }\n             Err(_) => {\n-                return ty::EarlyBinder(tcx.ty_error_with_message(\n+                return ty::EarlyBinder::new(tcx.ty_error_with_message(\n                     DUMMY_SP,\n                     \"Could not collect return position impl trait in trait tys\",\n                 ));\n@@ -497,7 +497,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n             bug!(\"unexpected sort of node in type_of(): {:?}\", x);\n         }\n     };\n-    ty::EarlyBinder(output)\n+    ty::EarlyBinder::new(output)\n }\n \n fn infer_placeholder_type<'a>("}, {"sha": "d7f11d3fd9d38b53f91bc21068178564dd47e55e", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                 }\n             }\n \n-            ty::EarlyBinder(required_predicates)\n+            ty::EarlyBinder::new(required_predicates)\n         })\n     }\n }"}, {"sha": "ced994aa6366eb7b6e900c714ff9c65aafe22196", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -68,12 +68,13 @@ pub(super) fn infer_predicates(\n             // Therefore mark `predicates_added` as true and which will ensure\n             // we walk the crates again and re-calculate predicates for all\n             // items.\n-            let item_predicates_len: usize =\n-                global_inferred_outlives.get(&item_did.to_def_id()).map_or(0, |p| p.0.len());\n+            let item_predicates_len: usize = global_inferred_outlives\n+                .get(&item_did.to_def_id())\n+                .map_or(0, |p| p.as_ref().skip_binder().len());\n             if item_required_predicates.len() > item_predicates_len {\n                 predicates_added = true;\n                 global_inferred_outlives\n-                    .insert(item_did.to_def_id(), ty::EarlyBinder(item_required_predicates));\n+                    .insert(item_did.to_def_id(), ty::EarlyBinder::new(item_required_predicates));\n             }\n         }\n \n@@ -137,7 +138,9 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // 'a` holds for `Foo`.\n                 debug!(\"Adt\");\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did()) {\n-                    for (unsubstituted_predicate, &span) in &unsubstituted_predicates.0 {\n+                    for (unsubstituted_predicate, &span) in\n+                        unsubstituted_predicates.as_ref().skip_binder()\n+                    {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n                         // example above. So apply the substitution to\n                         // get `T: 'a` (or `predicate`):\n@@ -251,7 +254,7 @@ fn check_explicit_predicates<'tcx>(\n     );\n     let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n-    for (outlives_predicate, &span) in &explicit_predicates.0 {\n+    for (outlives_predicate, &span) in explicit_predicates.as_ref().skip_binder() {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n \n         // Careful: If we are inferring the effects of a `dyn Trait<..>`"}, {"sha": "2106d6ff07dcc929a2efc9c912089de05c75ecf9", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -98,24 +98,27 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, (): ()) -> CratePredicatesMap<'_> {\n     let predicates = global_inferred_outlives\n         .iter()\n         .map(|(&def_id, set)| {\n-            let predicates = &*tcx.arena.alloc_from_iter(set.0.iter().filter_map(\n-                |(ty::OutlivesPredicate(kind1, region2), &span)| {\n-                    match kind1.unpack() {\n-                        GenericArgKind::Type(ty1) => Some((\n-                            ty::Clause::TypeOutlives(ty::OutlivesPredicate(ty1, *region2)),\n-                            span,\n-                        )),\n-                        GenericArgKind::Lifetime(region1) => Some((\n-                            ty::Clause::RegionOutlives(ty::OutlivesPredicate(region1, *region2)),\n-                            span,\n-                        )),\n-                        GenericArgKind::Const(_) => {\n-                            // Generic consts don't impose any constraints.\n-                            None\n+            let predicates =\n+                &*tcx.arena.alloc_from_iter(set.as_ref().skip_binder().iter().filter_map(\n+                    |(ty::OutlivesPredicate(kind1, region2), &span)| {\n+                        match kind1.unpack() {\n+                            GenericArgKind::Type(ty1) => Some((\n+                                ty::Clause::TypeOutlives(ty::OutlivesPredicate(ty1, *region2)),\n+                                span,\n+                            )),\n+                            GenericArgKind::Lifetime(region1) => Some((\n+                                ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                                    region1, *region2,\n+                                )),\n+                                span,\n+                            )),\n+                            GenericArgKind::Const(_) => {\n+                                // Generic consts don't impose any constraints.\n+                                None\n+                            }\n                         }\n-                    }\n-                },\n-            ));\n+                    },\n+                ));\n             (def_id, predicates)\n         })\n         .collect();"}, {"sha": "aab432eee571b77464c74cd0d52d1bceb95e3df1", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -25,6 +25,8 @@ hir_typeck_const_select_must_be_fn = this argument must be a function item\n \n hir_typeck_convert_to_str = try converting the passed type into a `&str`\n \n+hir_typeck_ctor_is_private = tuple struct constructor `{$def}` is private\n+\n hir_typeck_expected_default_return_type = expected `()` because of default return type\n \n hir_typeck_expected_return_type = expected `{$expected}` because of return type\n@@ -59,8 +61,8 @@ hir_typeck_lang_start_incorrect_param = parameter {$param_num} of the `start` la\n hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang item is incorrect\n     .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n \n-hir_typeck_method_call_on_unknown_type =\n-    the type of this value must be known to call a method on a raw pointer on it\n+hir_typeck_method_call_on_unknown_raw_pointee =\n+    cannot call a method on a raw pointer with an unknown pointee type\n \n hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n "}, {"sha": "4222205c84106742d78ceb029a268cb318789d92", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -49,8 +49,8 @@ pub struct StructExprNonExhaustive {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_typeck_method_call_on_unknown_type, code = \"E0699\")]\n-pub struct MethodCallOnUnknownType {\n+#[diag(hir_typeck_method_call_on_unknown_raw_pointee, code = \"E0699\")]\n+pub struct MethodCallOnUnknownRawPointee {\n     #[primary_span]\n     pub span: Span,\n }\n@@ -319,3 +319,11 @@ pub struct CandidateTraitNote {\n     pub item_name: Ident,\n     pub action_or_ty: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_ctor_is_private, code = \"E0603\")]\n+pub struct CtorIsPrivate {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def: String,\n+}"}, {"sha": "38ddb7e76041091dc48f642a7386b85b9456aa93", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,4 +1,5 @@\n use crate::callee::{self, DeferredCallResolution};\n+use crate::errors::CtorIsPrivate;\n use crate::method::{self, MethodCallee, SelfSource};\n use crate::rvalue_scopes;\n use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, RawTy};\n@@ -1207,6 +1208,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.normalized.ty_adt_def() {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let (ctor_kind, ctor_def_id) = adt_def.non_enum_variant().ctor.unwrap();\n+                    // Check the visibility of the ctor.\n+                    let vis = tcx.visibility(ctor_def_id);\n+                    if !vis.is_accessible_from(tcx.parent_module(hir_id).to_def_id(), tcx) {\n+                        tcx.sess\n+                            .emit_err(CtorIsPrivate { span, def: tcx.def_path_str(adt_def.did()) });\n+                    }\n                     let new_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n                     let user_substs = Self::user_substs_for_adt(ty);\n                     user_self_ty = user_substs.user_self_ty;\n@@ -1379,7 +1386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // the referenced item.\n         let ty = tcx.type_of(def_id);\n         assert!(!substs.has_escaping_bound_vars());\n-        assert!(!ty.0.has_escaping_bound_vars());\n+        assert!(!ty.skip_binder().has_escaping_bound_vars());\n         let ty_substituted = self.normalize(span, ty.subst(tcx, substs));\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {"}, {"sha": "9f3d35a77dc759faf6783bc2938c85b9417d7748", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,7 +3,7 @@ use super::CandidateSource;\n use super::MethodError;\n use super::NoMatchData;\n \n-use crate::errors::MethodCallOnUnknownType;\n+use crate::errors::MethodCallOnUnknownRawPointee;\n use crate::FnCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // so we do a future-compat lint here for the 2015 edition\n                 // (see https://github.com/rust-lang/rust/issues/46906)\n                 if self.tcx.sess.rust_2018() {\n-                    self.tcx.sess.emit_err(MethodCallOnUnknownType { span });\n+                    self.tcx.sess.emit_err(MethodCallOnUnknownRawPointee { span });\n                 } else {\n                     self.tcx.struct_span_lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,"}, {"sha": "59ae2ce6c603ec3bb6085a051b75ca14768a6313", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -293,7 +293,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n         let bounds = tcx.item_bounds(alias_ty.def_id);\n-        trace!(\"{:#?}\", bounds.0);\n+        trace!(\"{:#?}\", bounds.skip_binder());\n         bounds\n             .subst_iter(tcx, alias_ty.substs)\n             .filter_map(|p| p.to_opt_type_outlives())"}, {"sha": "947530a1b65a9dbf4433cb28559acc59b4d14fc5", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -952,6 +952,10 @@ pub trait LintContext: Sized {\n                     db.span_label(first_reexport_span, format!(\"the name `{}` in the {} namespace is first re-exported here\", name, namespace));\n                     db.span_label(duplicate_reexport_span, format!(\"but the name `{}` in the {} namespace is also re-exported here\", name, namespace));\n                 }\n+                BuiltinLintDiagnostics::HiddenGlobReexports { name, namespace, glob_reexport_span, private_item_span } => {\n+                    db.span_label(glob_reexport_span, format!(\"the name `{}` in the {} namespace is supposed to be publicly re-exported here\", name, namespace));\n+                    db.span_label(private_item_span, \"but the private item here shadows it\");\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(db)"}, {"sha": "8376835f52cfa2de0bcff6b67e0933be6270bf85", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -242,7 +242,9 @@ impl LintLevelsProvider for LintLevelQueryMap<'_> {\n \n struct QueryMapExpectationsWrapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    /// HirId of the currently investigated element.\n     cur: HirId,\n+    /// Level map for `cur`.\n     specs: ShallowLintLevelMap,\n     expectations: Vec<(LintExpectationId, LintExpectation)>,\n     unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n@@ -255,11 +257,11 @@ impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n         self.specs.specs.get(&self.cur.local_id).unwrap_or(&self.empty)\n     }\n     fn insert(&mut self, id: LintId, lvl: LevelAndSource) {\n-        let specs = self.specs.specs.get_mut_or_insert_default(self.cur.local_id);\n-        specs.clear();\n-        specs.insert(id, lvl);\n+        self.specs.specs.get_mut_or_insert_default(self.cur.local_id).insert(id, lvl);\n     }\n     fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n+        // We cannot use `tcx.lint_level_at_node` because we want to know in which order the\n+        // attributes have been inserted, in particular whether an `expect` follows a `forbid`.\n         self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n     }\n     fn push_expectation(&mut self, id: LintExpectationId, expectation: LintExpectation) {\n@@ -355,7 +357,9 @@ impl<'tcx> Visitor<'tcx> for LintLevelsBuilder<'_, LintLevelQueryMap<'tcx>> {\n \n impl<'tcx> LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n     fn add_id(&mut self, hir_id: HirId) {\n+        // Change both the `HirId` and the associated specs.\n         self.provider.cur = hir_id;\n+        self.provider.specs.specs.clear();\n         self.add(self.provider.tcx.hir().attrs(hir_id), hir_id == hir::CRATE_HIR_ID, Some(hir_id));\n     }\n }"}, {"sha": "1507087bdd4f3f34ae72a67c156f7a1623bee00f", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3272,6 +3272,43 @@ declare_lint! {\n     \"ambiguous glob re-exports\",\n }\n \n+declare_lint! {\n+    /// The `hidden_glob_reexports` lint detects cases where glob re-export items are shadowed by\n+    /// private items.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(hidden_glob_reexports)]\n+    ///\n+    /// pub mod upstream {\n+    ///     mod inner { pub struct Foo {}; pub struct Bar {}; }\n+    ///     pub use self::inner::*;\n+    ///     struct Foo {} // private item shadows `inner::Foo`\n+    /// }\n+    ///\n+    /// // mod downstream {\n+    /// //     fn test() {\n+    /// //         let _ = crate::upstream::Foo; // inaccessible\n+    /// //     }\n+    /// // }\n+    ///\n+    /// pub fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This was previously accepted without any errors or warnings but it could silently break a\n+    /// crate's downstream user code. If the `struct Foo` was added, `dep::inner::Foo` would\n+    /// silently become inaccessible and trigger a \"`struct `Foo` is private`\" visibility error at\n+    /// the downstream use site.\n+    pub HIDDEN_GLOB_REEXPORTS,\n+    Warn,\n+    \"name introduced by a private item shadows a name introduced by a public glob re-export\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -3304,6 +3341,7 @@ declare_lint_pass! {\n         FORBIDDEN_LINT_GROUPS,\n         FUNCTION_ITEM_REFERENCES,\n         FUZZY_PROVENANCE_CASTS,\n+        HIDDEN_GLOB_REEXPORTS,\n         ILL_FORMED_ATTRIBUTE_INPUT,\n         ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n         IMPLIED_BOUNDS_ENTAILMENT,"}, {"sha": "5a5031b7919643a92b42d79343dd9f0fa3458444", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -540,6 +540,16 @@ pub enum BuiltinLintDiagnostics {\n         /// Span where the same name is also re-exported.\n         duplicate_reexport_span: Span,\n     },\n+    HiddenGlobReexports {\n+        /// The name of the local binding which shadows the glob re-export.\n+        name: String,\n+        /// The namespace for which the shadowing occurred in.\n+        namespace: String,\n+        /// The glob reexport that is shadowed by the local binding.\n+        glob_reexport_span: Span,\n+        /// The local binding that shadows the glob reexport.\n+        private_item_span: Span,\n+    },\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "af6f4d5eaf998b900c77d4562eecc2ffa2b348b6", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -96,6 +96,7 @@ enum LLVMRustAttribute {\n   AllocatedPointer = 38,\n   AllocAlign = 39,\n #endif\n+  SanitizeSafeStack = 40,\n };\n \n typedef struct OpaqueRustString *RustStringRef;"}, {"sha": "ea04899ab6872a0f517c47d0257ad3fe5c61849c", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -234,6 +234,8 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n   case AllocAlign:\n     return Attribute::AllocAlign;\n #endif\n+  case SanitizeSafeStack:\n+    return Attribute::SafeStack;\n   }\n   report_fatal_error(\"bad AttributeKind\");\n }"}, {"sha": "731bbb1edfb70776ce9bea3e28d0717959e0c897", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -851,7 +851,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         } else {\n             tcx.arena.alloc_from_iter(lazy.decode((self, tcx)))\n         };\n-        ty::EarlyBinder(&*output)\n+        ty::EarlyBinder::new(&*output)\n     }\n \n     fn get_variant("}, {"sha": "e3a0ce373879b3ff2ecdc1e83416d54264a5fadd", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1727,7 +1727,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::Closure(_, substs) => {\n                 let constness = self.tcx.constness(def_id.to_def_id());\n                 self.tables.constness.set_some(def_id.to_def_id().index, constness);\n-                record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder(substs.as_closure().sig()));\n+                record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder::new(substs.as_closure().sig()));\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),"}, {"sha": "34e47de969c1750c26cff908bbd1d61b40f8c389", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -476,7 +476,7 @@ impl<'tcx> Body<'tcx> {\n     /// Returns the return type; it always return first element from `local_decls` array.\n     #[inline]\n     pub fn bound_return_ty(&self) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.local_decls[RETURN_PLACE].ty)\n+        ty::EarlyBinder::new(self.local_decls[RETURN_PLACE].ty)\n     }\n \n     /// Gets the location of the terminator for the given block."}, {"sha": "6d6d71bc87b1438a1108cf79f7ec1ee81fa87ca9", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -603,7 +603,11 @@ pub enum TerminatorKind<'tcx> {\n     /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n     /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n     /// > consider indirect assignments.\n-    Drop { place: Place<'tcx>, target: BasicBlock, unwind: UnwindAction },\n+    ///\n+    /// The `replace` flag indicates whether this terminator was created as part of an assignment.\n+    /// This should only be used for diagnostic purposes, and does not have any operational\n+    /// meaning.\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: UnwindAction, replace: bool },\n \n     /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n     /// the referred to function. The operand types must match the argument types of the function."}, {"sha": "561ef371b09048c413cd5442a89b4d5387540797", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -105,7 +105,7 @@ pub struct Terminator<'tcx> {\n     pub kind: TerminatorKind<'tcx>,\n }\n \n-pub type Successors<'a> = impl Iterator<Item = BasicBlock> + 'a;\n+pub type Successors<'a> = impl DoubleEndedIterator<Item = BasicBlock> + 'a;\n pub type SuccessorsMut<'a> =\n     iter::Chain<std::option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n "}, {"sha": "99ead14139aec1e6441268ec3abeaf08e7b46bf8", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         //      B     C\n         //      |     |\n         //      |     |\n-        //      D     |\n+        //      |     D\n         //       \\   /\n         //        \\ /\n         //         E\n@@ -159,26 +159,26 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         //\n         // When the first call to `traverse_successor` happens, the following happens:\n         //\n-        //     [(B, [D]),  // `B` taken from the successors of `A`, pushed to the\n-        //                 // top of the stack along with the successors of `B`\n-        //      (A, [C])]\n+        //     [(C, [D]),  // `C` taken from the successors of `A`, pushed to the\n+        //                 // top of the stack along with the successors of `C`\n+        //      (A, [B])]\n         //\n-        //     [(D, [E]),  // `D` taken from successors of `B`, pushed to stack\n-        //      (B, []),\n-        //      (A, [C])]\n+        //     [(D, [E]),  // `D` taken from successors of `C`, pushed to stack\n+        //      (C, []),\n+        //      (A, [B])]\n         //\n         //     [(E, []),   // `E` taken from successors of `D`, pushed to stack\n         //      (D, []),\n-        //      (B, []),\n-        //      (A, [C])]\n+        //      (C, []),\n+        //      (A, [B])]\n         //\n         // Now that the top of the stack has no successors we can traverse, each item will\n-        // be popped off during iteration until we get back to `A`. This yields [E, D, B].\n+        // be popped off during iteration until we get back to `A`. This yields [E, D, C].\n         //\n-        // When we yield `B` and call `traverse_successor`, we push `C` to the stack, but\n+        // When we yield `C` and call `traverse_successor`, we push `B` to the stack, but\n         // since we've already visited `E`, that child isn't added to the stack. The last\n-        // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n-        while let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() && let Some(bb) = iter.next() {\n+        // two iterations yield `B` and finally `A` for a final traversal of [E, D, C, B, A]\n+        while let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() && let Some(bb) = iter.next_back() {\n             if self.visited.insert(bb) {\n                 if let Some(term) = &self.basic_blocks[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));"}, {"sha": "942654b30749c3c1ea7792140713c6b07291141b", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -504,6 +504,7 @@ macro_rules! make_mir_visitor {\n                         place,\n                         target: _,\n                         unwind: _,\n+                        replace: _,\n                     } => {\n                         self.visit_place(\n                             place,"}, {"sha": "2b99fcad26758f06025cef48700339dee4cf01f0", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -573,7 +573,7 @@ impl<'tcx> AdtDef<'tcx> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n     pub fn sized_constraint(self, tcx: TyCtxt<'tcx>) -> ty::EarlyBinder<&'tcx [Ty<'tcx>]> {\n-        ty::EarlyBinder(tcx.adt_sized_constraint(self.did()))\n+        ty::EarlyBinder::new(tcx.adt_sized_constraint(self.did()))\n     }\n }\n "}, {"sha": "5fcbc4a9ed49ad3d593da28efb723c2d6cf54570", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -254,5 +254,5 @@ pub fn const_param_default(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBind\n             \"`const_param_default` expected a generic parameter with a constant\"\n         ),\n     };\n-    ty::EarlyBinder(Const::from_anon_const(tcx, default_def_id))\n+    ty::EarlyBinder::new(Const::from_anon_const(tcx, default_def_id))\n }"}, {"sha": "b27ee8cbad0fded2910ff963d6f4789660b471e2", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -343,7 +343,7 @@ impl<'tcx> GenericPredicates<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> impl Iterator<Item = (Predicate<'tcx>, Span)> + DoubleEndedIterator + ExactSizeIterator\n     {\n-        EarlyBinder(self.predicates).subst_iter_copied(tcx, substs)\n+        EarlyBinder::new(self.predicates).subst_iter_copied(tcx, substs)\n     }\n \n     #[instrument(level = \"debug\", skip(self, tcx))]\n@@ -358,7 +358,7 @@ impl<'tcx> GenericPredicates<'tcx> {\n         }\n         instantiated\n             .predicates\n-            .extend(self.predicates.iter().map(|(p, _)| EarlyBinder(*p).subst(tcx, substs)));\n+            .extend(self.predicates.iter().map(|(p, _)| EarlyBinder::new(*p).subst(tcx, substs)));\n         instantiated.spans.extend(self.predicates.iter().map(|(_, sp)| *sp));\n     }\n "}, {"sha": "b3cc27e3f78381713a48338dc2728fef775a3ad3", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n     fn subst_opt(self, tcx: TyCtxt<'tcx>, substs: ty::SubstsRef<'tcx>) -> Option<Self> {\n         match self {\n             Self::ConstIsZero(c) => {\n-                let c = ty::EarlyBinder(c).subst(tcx, substs);\n+                let c = ty::EarlyBinder::new(c).subst(tcx, substs);\n                 let pred = match c.kind().try_to_target_usize(tcx) {\n                     Some(0) => Self::True,\n                     Some(1..) => Self::False,\n@@ -167,7 +167,7 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n                 Some(pred)\n             }\n             Self::GenericType(t) => {\n-                Some(ty::EarlyBinder(t).subst(tcx, substs).inhabited_predicate(tcx))\n+                Some(ty::EarlyBinder::new(t).subst(tcx, substs).inhabited_predicate(tcx))\n             }\n             Self::And(&[a, b]) => match a.subst_opt(tcx, substs) {\n                 None => b.subst_opt(tcx, substs).map(|b| a.and(tcx, b)),"}, {"sha": "4b2c7e8ef311037294141a5fd0602584bad2e2e9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -53,7 +53,6 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, ExpnKind, Span};\n use rustc_target::abi::{Align, FieldIdx, Integer, IntegerType, VariantIdx};\n pub use rustc_target::abi::{ReprFlags, ReprOptions};\n-use rustc_type_ir::WithCachedTypeInfo;\n pub use subst::*;\n pub use vtable::*;\n \n@@ -145,6 +144,7 @@ mod opaque_types;\n mod parameterized;\n mod rvalue_scopes;\n mod structural_impls;\n+#[cfg_attr(not(bootstrap), allow(hidden_glob_reexports))]\n mod sty;\n mod typeck_results;\n \n@@ -764,7 +764,7 @@ impl<'tcx> Predicate<'tcx> {\n         let shifted_pred =\n             tcx.shift_bound_var_indices(trait_bound_vars.len(), bound_pred.skip_binder());\n         // 2) Self: Bar1<'a, '^0.1> -> T: Bar1<'^0.0, '^0.1>\n-        let new = EarlyBinder(shifted_pred).subst(tcx, trait_ref.skip_binder().substs);\n+        let new = EarlyBinder::new(shifted_pred).subst(tcx, trait_ref.skip_binder().substs);\n         // 3) ['x] + ['b] -> ['x, 'b]\n         let bound_vars =\n             tcx.mk_bound_variable_kinds_from_iter(trait_bound_vars.iter().chain(pred_bound_vars));"}, {"sha": "2de0a3f75dcf60c9f8756c0bf1844244ff8d537a", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -123,7 +123,7 @@ pub trait Printer<'tcx>: Sized {\n                         impl_trait_ref.map(|i| i.subst(self.tcx(), substs)),\n                     )\n                 } else {\n-                    (self_ty.0, impl_trait_ref.map(|i| i.0))\n+                    (self_ty.subst_identity(), impl_trait_ref.map(|i| i.subst_identity()))\n                 };\n                 self.print_impl_path(def_id, substs, self_ty, impl_trait_ref)\n             }"}, {"sha": "d6c88ea96ca4300bed186a848953cf0db081fd4c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -700,7 +700,7 @@ pub trait PrettyPrinter<'tcx>:\n                     if verbose { p!(write(\"{:?}\", infer_ty)) } else { p!(write(\"{}\", infer_ty)) }\n                 }\n             }\n-            ty::Error(_) => p!(\"[type error]\"),\n+            ty::Error(_) => p!(\"{{type error}}\"),\n             ty::Param(ref param_ty) => p!(print(param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n                 ty::BoundTyKind::Anon => debug_bound_var(&mut self, debruijn, bound_ty.var)?,\n@@ -1379,8 +1379,8 @@ pub trait PrettyPrinter<'tcx>:\n             },\n             // FIXME(generic_const_exprs):\n             // write out some legible representation of an abstract const?\n-            ty::ConstKind::Expr(_) => p!(\"[const expr]\"),\n-            ty::ConstKind::Error(_) => p!(\"[const error]\"),\n+            ty::ConstKind::Expr(_) => p!(\"{{const expr}}\"),\n+            ty::ConstKind::Error(_) => p!(\"{{const error}}\"),\n         };\n         Ok(self)\n     }"}, {"sha": "82f79a0c0887b3bb81f959b2f17d9baead701389", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -568,7 +568,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         let layout = tcx.generator_layout(def_id).unwrap();\n         layout.variant_fields.iter().map(move |variant| {\n             variant.iter().map(move |field| {\n-                ty::EarlyBinder(layout.field_tys[*field].ty).subst(tcx, self.substs)\n+                ty::EarlyBinder::new(layout.field_tys[*field].ty).subst(tcx, self.substs)\n             })\n         })\n     }\n@@ -2366,7 +2366,7 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Tuple(tys) => tys.iter().all(|ty| ty.is_trivially_sized(tcx)),\n \n-            ty::Adt(def, _substs) => def.sized_constraint(tcx).0.is_empty(),\n+            ty::Adt(def, _substs) => def.sized_constraint(tcx).skip_binder().is_empty(),\n \n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) => false,\n "}, {"sha": "8691a3070bcf67a8e7dea79603132bf927a5c69e", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -538,13 +538,17 @@ impl<'tcx, T: TypeVisitable<TyCtxt<'tcx>>> TypeVisitable<TyCtxt<'tcx>> for &'tcx\n /// [`subst_identity`](EarlyBinder::subst_identity) or [`skip_binder`](EarlyBinder::skip_binder).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[derive(Encodable, Decodable, HashStable)]\n-pub struct EarlyBinder<T>(pub T);\n+pub struct EarlyBinder<T>(T);\n \n /// For early binders, you should first call `subst` before using any visitors.\n impl<'tcx, T> !TypeFoldable<TyCtxt<'tcx>> for ty::EarlyBinder<T> {}\n impl<'tcx, T> !TypeVisitable<TyCtxt<'tcx>> for ty::EarlyBinder<T> {}\n \n impl<T> EarlyBinder<T> {\n+    pub fn new(inner: T) -> EarlyBinder<T> {\n+        EarlyBinder(inner)\n+    }\n+\n     pub fn as_ref(&self) -> EarlyBinder<&T> {\n         EarlyBinder(&self.0)\n     }\n@@ -582,6 +586,9 @@ impl<T> EarlyBinder<T> {\n     /// arguments of an `FnSig`). Otherwise, consider using\n     /// [`subst_identity`](EarlyBinder::subst_identity).\n     ///\n+    /// To skip the binder on `x: &EarlyBinder<T>` to obtain `&T`, leverage\n+    /// [`EarlyBinder::as_ref`](EarlyBinder::as_ref): `x.as_ref().skip_binder()`.\n+    ///\n     /// See also [`Binder::skip_binder`](super::Binder::skip_binder), which is\n     /// the analogous operation on [`super::Binder`].\n     pub fn skip_binder(self) -> T {"}, {"sha": "dade50df5d962c98de239822b0512f5a20b8f149", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -709,7 +709,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             .as_ref()\n             .map_or_else(|| [].iter(), |l| l.field_tys.iter())\n             .filter(|decl| !decl.ignore_for_traits)\n-            .map(|decl| ty::EarlyBinder(decl.ty))\n+            .map(|decl| ty::EarlyBinder::new(decl.ty))\n     }\n \n     /// Normalizes all opaque types in the given value, replacing them"}, {"sha": "58374f6b3bd7851e19c58ac4eb5d37b99dffe0b7", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -96,13 +96,13 @@ impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Representability {\n \n impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::EarlyBinder<Ty<'_>> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n-        ty::EarlyBinder(Ty::from_cycle_error(tcx, cycle))\n+        ty::EarlyBinder::new(Ty::from_cycle_error(tcx, cycle))\n     }\n }\n \n impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::EarlyBinder<ty::Binder<'_, ty::FnSig<'_>>> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n-        ty::EarlyBinder(ty::Binder::from_cycle_error(tcx, cycle))\n+        ty::EarlyBinder::new(ty::Binder::from_cycle_error(tcx, cycle))\n     }\n }\n "}, {"sha": "ebf830cb9c1f6a2da2120a1266adb3b82cf1ba50", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -57,6 +57,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                     place: self.parse_place(args[0])?,\n                     target: self.parse_block(args[1])?,\n                     unwind: UnwindAction::Continue,\n+                    replace: false,\n                 })\n             },\n             @call(\"mir_call\", args) => {"}, {"sha": "3742d640e3b58927caa09c5af385c5661cddfad2", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -725,6 +725,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         place: to_drop,\n                         target: success,\n                         unwind: UnwindAction::Continue,\n+                        replace: false,\n                     },\n                 );\n                 this.diverge_from(block);"}, {"sha": "7c0fbc6f81c94721d0a7ad2d1df4f35260921728", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -91,7 +91,7 @@ use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::thir::{Expr, LintLevel};\n \n-use rustc_span::{DesugaringKind, Span, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Debug)]\n pub struct Scopes<'tcx> {\n@@ -371,6 +371,7 @@ impl DropTree {\n                         // The caller will handle this if needed.\n                         unwind: UnwindAction::Terminate,\n                         place: drop_data.0.local.into(),\n+                        replace: false,\n                     };\n                     cfg.terminate(block, drop_data.0.source_info, terminator);\n                 }\n@@ -1128,9 +1129,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: Place<'tcx>,\n         value: Rvalue<'tcx>,\n     ) -> BlockAnd<()> {\n-        let span = self.tcx.with_stable_hashing_context(|hcx| {\n-            span.mark_with_reason(None, DesugaringKind::Replace, self.tcx.sess.edition(), hcx)\n-        });\n         let source_info = self.source_info(span);\n \n         // create the new block for the assignment\n@@ -1148,6 +1146,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 place,\n                 target: assign,\n                 unwind: UnwindAction::Cleanup(assign_unwind),\n+                replace: true,\n             },\n         );\n         self.diverge_from(block);\n@@ -1261,6 +1260,7 @@ fn build_scope_drops<'tcx>(\n                         place: local.into(),\n                         target: next,\n                         unwind: UnwindAction::Continue,\n+                        replace: false,\n                     },\n                 );\n                 block = next;"}, {"sha": "d615c83d621915e6bf05235b840d3f55394d1ac1", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -237,6 +237,7 @@ where\n                         place: self.place,\n                         target: self.succ,\n                         unwind: self.unwind.into_action(),\n+                        replace: false,\n                     },\n                 );\n             }\n@@ -719,6 +720,7 @@ where\n                 place: tcx.mk_place_deref(ptr),\n                 target: loop_block,\n                 unwind: unwind.into_action(),\n+                replace: false,\n             },\n         );\n \n@@ -963,8 +965,12 @@ where\n     }\n \n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n-        let block =\n-            TerminatorKind::Drop { place: self.place, target, unwind: unwind.into_action() };\n+        let block = TerminatorKind::Drop {\n+            place: self.place,\n+            target,\n+            unwind: unwind.into_action(),\n+            replace: false,\n+        };\n         self.new_block(unwind, block)\n     }\n "}, {"sha": "ba328e78040a51e06b9e29d987607ae779215ceb", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -479,7 +479,7 @@ impl Direction for Forward {\n             Goto { target } => propagate(target, exit_state),\n \n             Assert { target, unwind, expected: _, msg: _, cond: _ }\n-            | Drop { target, unwind, place: _ }\n+            | Drop { target, unwind, place: _, replace: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n                 if let UnwindAction::Cleanup(unwind) = unwind {\n                     propagate(unwind, exit_state);"}, {"sha": "ef2a0c790e9459eab462aee9a09ed8b9c5b2c73f", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -80,7 +80,7 @@ fn add_move_for_packed_drop<'tcx>(\n     is_cleanup: bool,\n ) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n-    let TerminatorKind::Drop { ref place, target, unwind } = terminator.kind else {\n+    let TerminatorKind::Drop { ref place, target, unwind, replace } = terminator.kind else {\n         unreachable!();\n     };\n \n@@ -98,6 +98,11 @@ fn add_move_for_packed_drop<'tcx>(\n     patch.add_assign(loc, Place::from(temp), Rvalue::Use(Operand::Move(*place)));\n     patch.patch_terminator(\n         loc.block,\n-        TerminatorKind::Drop { place: Place::from(temp), target: storage_dead_block, unwind },\n+        TerminatorKind::Drop {\n+            place: Place::from(temp),\n+            target: storage_dead_block,\n+            unwind,\n+            replace,\n+        },\n     );\n }"}, {"sha": "1fe8ea0789286780a7684d16715c89e5ecb6aa6f", "filename": "compiler/rustc_mir_transform/src/check_alignment.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -75,6 +75,14 @@ struct PointerFinder<'tcx, 'a> {\n }\n \n impl<'tcx, 'a> Visitor<'tcx> for PointerFinder<'tcx, 'a> {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        if let Rvalue::AddressOf(..) = rvalue {\n+            // Ignore dereferences inside of an AddressOf\n+            return;\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         if let PlaceContext::NonUse(_) = context {\n             return;"}, {"sha": "fda0e1023f7c58fc9696a44af29ec3a1648de52e", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -14,7 +14,7 @@ use rustc_mir_dataflow::un_derefer::UnDerefer;\n use rustc_mir_dataflow::MoveDataParamEnv;\n use rustc_mir_dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n-use rustc_span::{DesugaringKind, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{FieldIdx, VariantIdx};\n use std::fmt;\n \n@@ -401,7 +401,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             let terminator = data.terminator();\n \n             match terminator.kind {\n-                TerminatorKind::Drop { mut place, target, unwind } => {\n+                TerminatorKind::Drop { mut place, target, unwind, replace } => {\n                     if let Some(new_place) = self.un_derefer.derefer(place.as_ref(), self.body) {\n                         place = new_place;\n                     }\n@@ -434,10 +434,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             )\n                         }\n                         LookupResult::Parent(..) => {\n-                            if !matches!(\n-                                terminator.source_info.span.desugaring_kind(),\n-                                Some(DesugaringKind::Replace),\n-                            ) {\n+                            if !replace {\n                                 self.tcx.sess.delay_span_bug(\n                                     terminator.source_info.span,\n                                     format!(\"drop of untracked value {:?}\", bb),"}, {"sha": "c0458126840da0667efab697c8136118a38d2b8e", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n                         // If the inner type matches the type bound by `Pointer`\n                         if inner_ty == bound_ty {\n                             // Do a substitution using the parameters from the callsite\n-                            let subst_ty = EarlyBinder(inner_ty).subst(self.tcx, substs_ref);\n+                            let subst_ty = EarlyBinder::new(inner_ty).subst(self.tcx, substs_ref);\n                             if let Some((fn_id, fn_substs)) =\n                                 FunctionItemRefChecker::is_fn_ref(subst_ty)\n                             {"}, {"sha": "89567ed0ab88278c8cc51ccbf608a32fc7bcb9ed", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1045,7 +1045,10 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     for (block, block_data) in body.basic_blocks.iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            Terminator { source_info, kind: TerminatorKind::Drop { place, target, unwind } } => {\n+            Terminator {\n+                source_info,\n+                kind: TerminatorKind::Drop { place, target, unwind, replace: _ },\n+            } => {\n                 if let Some(local) = place.as_local() {\n                     if local == SELF_ARG {\n                         (target, unwind, source_info)\n@@ -1304,6 +1307,7 @@ fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n         place: Place::from(SELF_ARG),\n         target: return_block,\n         unwind: UnwindAction::Continue,\n+        replace: false,\n     };\n     let source_info = SourceInfo::outermost(body.span);\n "}, {"sha": "e27d48fa8f65aaf7d9b48e8b333ee30fe5912374", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> Inliner<'tcx> {\n         let Ok(callee_body) = callsite.callee.try_subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             self.param_env,\n-            ty::EarlyBinder(callee_body.clone()),\n+            ty::EarlyBinder::new(callee_body.clone()),\n         ) else {\n             return Err(\"failed to normalize callee body\");\n         };\n@@ -449,16 +449,16 @@ impl<'tcx> Inliner<'tcx> {\n             checker.visit_basic_block_data(bb, blk);\n \n             let term = blk.terminator();\n-            if let TerminatorKind::Drop { ref place, target, unwind } = term.kind {\n+            if let TerminatorKind::Drop { ref place, target, unwind, replace: _ } = term.kind {\n                 work_list.push(target);\n \n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = callsite\n                     .callee\n-                    .subst_mir(self.tcx, ty::EarlyBinder(&place.ty(callee_body, tcx).ty));\n+                    .subst_mir(self.tcx, ty::EarlyBinder::new(&place.ty(callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) && let UnwindAction::Cleanup(unwind) = unwind {\n-                        work_list.push(unwind);\n-                    }\n+                    work_list.push(unwind);\n+                }\n             } else if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set\n                 && matches!(term.kind, TerminatorKind::InlineAsm { .. })\n             {\n@@ -790,7 +790,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = self\n                     .instance\n-                    .subst_mir(tcx, ty::EarlyBinder(&place.ty(self.callee_body, tcx).ty));\n+                    .subst_mir(tcx, ty::EarlyBinder::new(&place.ty(self.callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) {\n                     self.cost += CALL_PENALTY;\n                     if let UnwindAction::Cleanup(_) = unwind {\n@@ -801,7 +801,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                 }\n             }\n             TerminatorKind::Call { func: Operand::Constant(ref f), unwind, .. } => {\n-                let fn_ty = self.instance.subst_mir(tcx, ty::EarlyBinder(&f.literal.ty()));\n+                let fn_ty = self.instance.subst_mir(tcx, ty::EarlyBinder::new(&f.literal.ty()));\n                 self.cost += if let ty::FnDef(def_id, _) = *fn_ty.kind() && tcx.is_intrinsic(def_id) {\n                     // Don't give intrinsics the extra penalty for calls\n                     INSTR_COST"}, {"sha": "00842e9d66596a9ed07279e09865ed89ba360dc2", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -47,7 +47,7 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n             let Ok(substs) = caller.try_subst_mir_and_normalize_erasing_regions(\n                 tcx,\n                 param_env,\n-                ty::EarlyBinder(substs),\n+                ty::EarlyBinder::new(substs),\n             ) else {\n                 trace!(?caller, ?param_env, ?substs, \"cannot normalize, skipping\");\n                 continue;"}, {"sha": "54c138b6fbd4cf481957c72216359ac07dba95e4", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,6 +3,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(is_sorted)]\n #![feature(let_chains)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n@@ -84,6 +85,7 @@ mod match_branches;\n mod multiple_return_terminators;\n mod normalize_array_len;\n mod nrvo;\n+mod prettify;\n mod ref_prop;\n mod remove_noop_landing_pads;\n mod remove_storage_markers;\n@@ -581,6 +583,9 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &large_enums::EnumSizeOpt { discrepancy: 128 },\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n             &add_call_guards::CriticalCallEdges,\n+            // Cleanup for human readability, off by default.\n+            &prettify::ReorderBasicBlocks,\n+            &prettify::ReorderLocals,\n             // Dump the end result for testing and debugging purposes.\n             &dump_mir::Marker(\"PreCodegen\"),\n         ],"}, {"sha": "6eb4849827447a7d772017e2b140c8d8bf8ffeca", "filename": "compiler/rustc_mir_transform/src/match_branches.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -41,7 +41,7 @@ pub struct MatchBranchSimplification;\n \n impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() >= 3\n+        sess.mir_opt_level() >= 1\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -62,7 +62,12 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     ..\n                 } if targets.iter().len() == 1 => {\n                     let (value, target) = targets.iter().next().unwrap();\n-                    if target == targets.otherwise() {\n+                    // We require that this block and the two possible target blocks all be\n+                    // distinct.\n+                    if target == targets.otherwise()\n+                        || bb_idx == target\n+                        || bb_idx == targets.otherwise()\n+                    {\n                         continue;\n                     }\n                     (discr, value, target, targets.otherwise())"}, {"sha": "6f46974ea0053eb049442ecf90b8c936a9386306", "filename": "compiler/rustc_mir_transform/src/prettify.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fprettify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fprettify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fprettify.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,150 @@\n+//! These two passes provide no value to the compiler, so are off at every level.\n+//!\n+//! However, they can be enabled on the command line\n+//! (`-Zmir-enable-passes=+ReorderBasicBlocks,+ReorderLocals`)\n+//! to make the MIR easier to read for humans.\n+\n+use crate::MirPass;\n+use rustc_index::{bit_set::BitSet, IndexSlice, IndexVec};\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n+\n+/// Rearranges the basic blocks into a *reverse post-order*.\n+///\n+/// Thus after this pass, all the successors of a block are later than it in the\n+/// `IndexVec`, unless that successor is a back-edge (such as from a loop).\n+pub struct ReorderBasicBlocks;\n+\n+impl<'tcx> MirPass<'tcx> for ReorderBasicBlocks {\n+    fn is_enabled(&self, _session: &Session) -> bool {\n+        false\n+    }\n+\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let rpo: IndexVec<BasicBlock, BasicBlock> =\n+            body.basic_blocks.postorder().iter().copied().rev().collect();\n+        if rpo.iter().is_sorted() {\n+            return;\n+        }\n+\n+        let mut updater = BasicBlockUpdater { map: rpo.invert_bijective_mapping(), tcx };\n+        debug_assert_eq!(updater.map[START_BLOCK], START_BLOCK);\n+        updater.visit_body(body);\n+\n+        permute(body.basic_blocks.as_mut(), &updater.map);\n+    }\n+}\n+\n+/// Rearranges the locals into *use* order.\n+///\n+/// Thus after this pass, a local with a smaller [`Location`] where it was first\n+/// assigned or referenced will have a smaller number.\n+///\n+/// (Does not reorder arguments nor the [`RETURN_PLACE`].)\n+pub struct ReorderLocals;\n+\n+impl<'tcx> MirPass<'tcx> for ReorderLocals {\n+    fn is_enabled(&self, _session: &Session) -> bool {\n+        false\n+    }\n+\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let mut finder =\n+            LocalFinder { map: IndexVec::new(), seen: BitSet::new_empty(body.local_decls.len()) };\n+\n+        // We can't reorder the return place or the arguments\n+        for local in (0..=body.arg_count).map(Local::from_usize) {\n+            finder.track(local);\n+        }\n+\n+        for (bb, bbd) in body.basic_blocks.iter_enumerated() {\n+            finder.visit_basic_block_data(bb, bbd);\n+        }\n+\n+        // track everything in case there are some locals that we never saw,\n+        // such as in non-block things like debug info or in non-uses.\n+        for local in body.local_decls.indices() {\n+            finder.track(local);\n+        }\n+\n+        if finder.map.iter().is_sorted() {\n+            return;\n+        }\n+\n+        let mut updater = LocalUpdater { map: finder.map.invert_bijective_mapping(), tcx };\n+\n+        for local in (0..=body.arg_count).map(Local::from_usize) {\n+            debug_assert_eq!(updater.map[local], local);\n+        }\n+\n+        updater.visit_body_preserves_cfg(body);\n+\n+        permute(&mut body.local_decls, &updater.map);\n+    }\n+}\n+\n+fn permute<I: rustc_index::Idx + Ord, T>(data: &mut IndexVec<I, T>, map: &IndexSlice<I, I>) {\n+    // FIXME: It would be nice to have a less-awkward way to apply permutations,\n+    // but I don't know one that exists.  `sort_by_cached_key` has logic for it\n+    // internally, but not in a way that we're allowed to use here.\n+    let mut enumerated: Vec<_> = std::mem::take(data).into_iter_enumerated().collect();\n+    enumerated.sort_by_key(|p| map[p.0]);\n+    *data = enumerated.into_iter().map(|p| p.1).collect();\n+}\n+\n+struct BasicBlockUpdater<'tcx> {\n+    map: IndexVec<BasicBlock, BasicBlock>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for BasicBlockUpdater<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, _location: Location) {\n+        for succ in terminator.successors_mut() {\n+            *succ = self.map[*succ];\n+        }\n+    }\n+}\n+\n+struct LocalFinder {\n+    map: IndexVec<Local, Local>,\n+    seen: BitSet<Local>,\n+}\n+\n+impl LocalFinder {\n+    fn track(&mut self, l: Local) {\n+        if self.seen.insert(l) {\n+            self.map.push(l);\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LocalFinder {\n+    fn visit_local(&mut self, l: Local, context: PlaceContext, _location: Location) {\n+        // Exclude non-uses to keep `StorageLive` from controlling where we put\n+        // a `Local`, since it might not actually be assigned until much later.\n+        if context.is_use() {\n+            self.track(l);\n+        }\n+    }\n+}\n+\n+struct LocalUpdater<'tcx> {\n+    pub map: IndexVec<Local, Local>,\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_local(&mut self, l: &mut Local, _: PlaceContext, _: Location) {\n+        *l = self.map[*l];\n+    }\n+}"}, {"sha": "522220f3d77c12b5f85328cb6ddc2bc0abd9be09", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -69,7 +69,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             // of this function. Is this intentional?\n             if let Some(ty::Generator(gen_def_id, substs, _)) = ty.map(Ty::kind) {\n                 let body = tcx.optimized_mir(*gen_def_id).generator_drop().unwrap();\n-                let body = EarlyBinder(body.clone()).subst(tcx, substs);\n+                let body = EarlyBinder::new(body.clone()).subst(tcx, substs);\n                 debug!(\"make_shim({:?}) = {:?}\", instance, body);\n                 return body;\n             }\n@@ -544,6 +544,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n                     place: dest_field,\n                     target: unwind,\n                     unwind: UnwindAction::Terminate,\n+                    replace: false,\n                 },\n                 true,\n             );\n@@ -643,8 +644,11 @@ fn build_call_shim<'tcx>(\n     let sig = sig.map_bound(|sig| tcx.erase_late_bound_regions(sig));\n \n     assert_eq!(sig_substs.is_some(), !instance.has_polymorphic_mir_body());\n-    let mut sig =\n-        if let Some(sig_substs) = sig_substs { sig.subst(tcx, &sig_substs) } else { sig.0 };\n+    let mut sig = if let Some(sig_substs) = sig_substs {\n+        sig.subst(tcx, &sig_substs)\n+    } else {\n+        sig.skip_binder()\n+    };\n \n     if let CallKind::Indirect(fnty) = call_kind {\n         // `sig` determines our local decls, and thus the callee type in the `Call` terminator. This\n@@ -800,6 +804,7 @@ fn build_call_shim<'tcx>(\n                 place: rcvr_place(),\n                 target: BasicBlock::new(2),\n                 unwind: UnwindAction::Continue,\n+                replace: false,\n             },\n             false,\n         );\n@@ -815,6 +820,7 @@ fn build_call_shim<'tcx>(\n                 place: rcvr_place(),\n                 target: BasicBlock::new(4),\n                 unwind: UnwindAction::Terminate,\n+                replace: false,\n             },\n             true,\n         );"}, {"sha": "8874aa7d3ca9ba3c73c77c6398a1dccb1a5207a9", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -677,7 +677,7 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            ty::EarlyBinder(value),\n+            ty::EarlyBinder::new(value),\n         )\n     }\n }"}, {"sha": "772f15201536c032ada9bc4f2370c74ee348fd73", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -29,12 +29,12 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n         let before_feature_tys = tcx.subst_and_normalize_erasing_regions(\n             closure_instance.substs,\n             param_env,\n-            ty::EarlyBinder(before_feature_tys),\n+            ty::EarlyBinder::new(before_feature_tys),\n         );\n         let after_feature_tys = tcx.subst_and_normalize_erasing_regions(\n             closure_instance.substs,\n             param_env,\n-            ty::EarlyBinder(after_feature_tys),\n+            ty::EarlyBinder::new(after_feature_tys),\n         );\n \n         let new_size = tcx"}, {"sha": "c23420661fa595f871327b272fe7226f61dc2f34", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -536,7 +536,9 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token.kind) {\n             // leave it in the input\n             Ok(false)\n-        } else if self.last_unexpected_token_span == Some(self.token.span) {\n+        } else if self.token.kind != token::Eof\n+            && self.last_unexpected_token_span == Some(self.token.span)\n+        {\n             FatalError.raise();\n         } else {\n             self.expected_one_of_not_found(edible, inedible)"}, {"sha": "c1bb262c0d4077276a0a5e734b3cf827b9147480", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -21,7 +21,8 @@ use rustc_middle::metadata::Reexport;\n use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{\n-    AMBIGUOUS_GLOB_REEXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS,\n+    AMBIGUOUS_GLOB_REEXPORTS, HIDDEN_GLOB_REEXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+    UNUSED_IMPORTS,\n };\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::edit_distance::find_best_match_for_name;\n@@ -526,31 +527,71 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn check_reexport_ambiguities(\n+    pub(crate) fn check_hidden_glob_reexports(\n         &mut self,\n         exported_ambiguities: FxHashSet<Interned<'a, NameBinding<'a>>>,\n     ) {\n         for module in self.arenas.local_modules().iter() {\n-            module.for_each_child(self, |this, ident, ns, binding| {\n-                if let NameBindingKind::Import { import, .. } = binding.kind\n-                && let Some((amb_binding, _)) = binding.ambiguity\n-                && binding.res() != Res::Err\n-                && exported_ambiguities.contains(&Interned::new_unchecked(binding))\n-                {\n-                    this.lint_buffer.buffer_lint_with_diagnostic(\n-                        AMBIGUOUS_GLOB_REEXPORTS,\n-                        import.root_id,\n-                        import.root_span,\n-                        \"ambiguous glob re-exports\",\n-                        BuiltinLintDiagnostics::AmbiguousGlobReexports {\n-                            name: ident.to_string(),\n-                            namespace: ns.descr().to_string(),\n-                            first_reexport_span: import.root_span,\n-                            duplicate_reexport_span: amb_binding.span,\n-                        },\n-                    );\n+            for (key, resolution) in self.resolutions(module).borrow().iter() {\n+                let resolution = resolution.borrow();\n+\n+                if let Some(binding) = resolution.binding {\n+                    if let NameBindingKind::Import { import, .. } = binding.kind\n+                        && let Some((amb_binding, _)) = binding.ambiguity\n+                        && binding.res() != Res::Err\n+                        && exported_ambiguities.contains(&Interned::new_unchecked(binding))\n+                    {\n+                        self.lint_buffer.buffer_lint_with_diagnostic(\n+                            AMBIGUOUS_GLOB_REEXPORTS,\n+                            import.root_id,\n+                            import.root_span,\n+                            \"ambiguous glob re-exports\",\n+                            BuiltinLintDiagnostics::AmbiguousGlobReexports {\n+                                name: key.ident.to_string(),\n+                                namespace: key.ns.descr().to_string(),\n+                                first_reexport_span: import.root_span,\n+                                duplicate_reexport_span: amb_binding.span,\n+                            },\n+                        );\n+                    }\n+\n+                    if let Some(glob_binding) = resolution.shadowed_glob {\n+                        let binding_id = match binding.kind {\n+                            NameBindingKind::Res(res) => {\n+                                Some(self.def_id_to_node_id[res.def_id().expect_local()])\n+                            }\n+                            NameBindingKind::Module(module) => {\n+                                Some(self.def_id_to_node_id[module.def_id().expect_local()])\n+                            }\n+                            NameBindingKind::Import { import, .. } => import.id(),\n+                        };\n+\n+                        if binding.res() != Res::Err\n+                            && glob_binding.res() != Res::Err\n+                            && let NameBindingKind::Import { import: glob_import, .. } = glob_binding.kind\n+                            && let Some(binding_id) = binding_id\n+                            && let Some(glob_import_id) = glob_import.id()\n+                            && let glob_import_def_id = self.local_def_id(glob_import_id)\n+                            && self.effective_visibilities.is_exported(glob_import_def_id)\n+                            && glob_binding.vis.is_public()\n+                            && !binding.vis.is_public()\n+                        {\n+                            self.lint_buffer.buffer_lint_with_diagnostic(\n+                                HIDDEN_GLOB_REEXPORTS,\n+                                binding_id,\n+                                binding.span,\n+                                \"private item shadows public glob re-export\",\n+                                BuiltinLintDiagnostics::HiddenGlobReexports {\n+                                    name: key.ident.name.to_string(),\n+                                    namespace: key.ns.descr().to_owned(),\n+                                    glob_reexport_span: glob_binding.span,\n+                                    private_item_span: binding.span,\n+                                },\n+                            );\n+                        }\n+                    }\n                 }\n-            });\n+            }\n         }\n     }\n "}, {"sha": "fd977e8e254a29bb46decb5d053fc6b2f25d936e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1496,8 +1496,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             let exported_ambiguities = self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n-            self.tcx.sess.time(\"check_reexport_ambiguities\", || {\n-                self.check_reexport_ambiguities(exported_ambiguities)\n+            self.tcx.sess.time(\"check_hidden_glob_reexports\", || {\n+                self.check_hidden_glob_reexports(exported_ambiguities)\n             });\n             self.tcx.sess.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n             self.tcx.sess.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));"}, {"sha": "007e720823bfaf37ae5ba76676ae25ed198d4a83", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -372,7 +372,7 @@ mod desc {\n     pub const parse_opt_panic_strategy: &str = parse_panic_strategy;\n     pub const parse_oom_strategy: &str = \"either `panic` or `abort`\";\n     pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n-    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `kcfi`, `kernel-address`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n+    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `kcfi`, `kernel-address`, `leak`, `memory`, `memtag`, `safestack`, `shadow-call-stack`, or `thread`\";\n     pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n     pub const parse_cfguard: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n@@ -694,6 +694,7 @@ mod parse {\n                     \"shadow-call-stack\" => SanitizerSet::SHADOWCALLSTACK,\n                     \"thread\" => SanitizerSet::THREAD,\n                     \"hwaddress\" => SanitizerSet::HWADDRESS,\n+                    \"safestack\" => SanitizerSet::SAFESTACK,\n                     _ => return false,\n                 }\n             }"}, {"sha": "5572108f49567ea5b84f5f40a3dd2e288da4da69", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -309,7 +309,7 @@ fn rustc_terminator_to_terminator(\n         Terminate => Terminator::Abort,\n         Return => Terminator::Return,\n         Unreachable => Terminator::Unreachable,\n-        Drop { place, target, unwind } => Terminator::Drop {\n+        Drop { place, target, unwind, replace: _ } => Terminator::Drop {\n             place: rustc_place_to_place(place),\n             target: target.as_usize(),\n             unwind: rustc_unwind_to_unwind(unwind),"}, {"sha": "b219fde4da9a17c0aacfa6bf53c29f0de52c12af", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1147,7 +1147,6 @@ pub enum DesugaringKind {\n     Await,\n     ForLoop,\n     WhileLoop,\n-    Replace,\n }\n \n impl DesugaringKind {\n@@ -1163,7 +1162,6 @@ impl DesugaringKind {\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop => \"`for` loop\",\n             DesugaringKind::WhileLoop => \"`while` loop\",\n-            DesugaringKind::Replace => \"drop and replace\",\n         }\n     }\n }"}, {"sha": "55901bfbde9cf254b56b946268a342a46c837cd3", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -274,7 +274,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n         let mut param_env = self.tcx.param_env_reveal_all_normalized(impl_def_id);\n         if !substs.is_empty() {\n-            param_env = EarlyBinder(param_env).subst(self.tcx, substs);\n+            param_env = EarlyBinder::new(param_env).subst(self.tcx, substs);\n         }\n \n         match &mut impl_trait_ref {"}, {"sha": "62f94209cf04dd687ee767ccdf0793c144d93643", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -815,6 +815,7 @@ bitflags::bitflags! {\n         const SHADOWCALLSTACK = 1 << 7;\n         const KCFI    = 1 << 8;\n         const KERNELADDRESS = 1 << 9;\n+        const SAFESTACK = 1 << 10;\n     }\n }\n \n@@ -831,6 +832,7 @@ impl SanitizerSet {\n             SanitizerSet::LEAK => \"leak\",\n             SanitizerSet::MEMORY => \"memory\",\n             SanitizerSet::MEMTAG => \"memtag\",\n+            SanitizerSet::SAFESTACK => \"safestack\",\n             SanitizerSet::SHADOWCALLSTACK => \"shadow-call-stack\",\n             SanitizerSet::THREAD => \"thread\",\n             SanitizerSet::HWADDRESS => \"hwaddress\",\n@@ -871,6 +873,7 @@ impl IntoIterator for SanitizerSet {\n             SanitizerSet::THREAD,\n             SanitizerSet::HWADDRESS,\n             SanitizerSet::KERNELADDRESS,\n+            SanitizerSet::SAFESTACK,\n         ]\n         .iter()\n         .copied()\n@@ -2364,6 +2367,7 @@ impl Target {\n                                 Some(\"leak\") => SanitizerSet::LEAK,\n                                 Some(\"memory\") => SanitizerSet::MEMORY,\n                                 Some(\"memtag\") => SanitizerSet::MEMTAG,\n+                                Some(\"safestack\") => SanitizerSet::SAFESTACK,\n                                 Some(\"shadow-call-stack\") => SanitizerSet::SHADOWCALLSTACK,\n                                 Some(\"thread\") => SanitizerSet::THREAD,\n                                 Some(\"hwaddress\") => SanitizerSet::HWADDRESS,"}, {"sha": "deb15c02c68391e9e158e9be0f5515794c987beb", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -11,6 +11,7 @@ pub fn target() -> Target {\n         | SanitizerSet::CFI\n         | SanitizerSet::LEAK\n         | SanitizerSet::MEMORY\n+        | SanitizerSet::SAFESTACK\n         | SanitizerSet::THREAD;\n     base.supports_xray = true;\n "}, {"sha": "1071b8fc7026f49dd9cf0469ab3ac48050557eea", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -148,11 +148,7 @@ pub(in crate::solve) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n \n         ty::Adt(def, substs) => {\n             let sized_crit = def.sized_constraint(ecx.tcx());\n-            Ok(sized_crit\n-                .0\n-                .iter()\n-                .map(|ty| sized_crit.rebind(*ty).subst(ecx.tcx(), substs))\n-                .collect())\n+            Ok(sized_crit.subst_iter_copied(ecx.tcx(), substs).collect())\n         }\n     }\n }"}, {"sha": "56a254d9c07e124cc9afda57e7b7bea7571ff9af", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -231,13 +231,21 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n                 let mut candidates = Vec::new();\n                 // LHS normalizes-to RHS\n-                candidates.extend(\n-                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No).ok(),\n-                );\n+                candidates.extend(evaluate_normalizes_to(\n+                    self,\n+                    alias_lhs,\n+                    rhs,\n+                    direction,\n+                    Invert::No,\n+                ));\n                 // RHS normalizes-to RHS\n-                candidates.extend(\n-                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n-                );\n+                candidates.extend(evaluate_normalizes_to(\n+                    self,\n+                    alias_rhs,\n+                    lhs,\n+                    direction,\n+                    Invert::Yes,\n+                ));\n                 // Relate via substs\n                 let subst_relate_response = self.probe(|ecx| {\n                     let span = tracing::span!(\n@@ -265,10 +273,18 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n                 if let Some(merged) = self.try_merge_responses(&candidates) {\n                     Ok(merged)\n-                } else if let Ok(subst_relate_response) = subst_relate_response {\n-                    Ok(subst_relate_response)\n                 } else {\n-                    self.flounder(&candidates)\n+                    // When relating two aliases and we have ambiguity, we prefer\n+                    // relating the generic arguments of the aliases over normalizing\n+                    // them. This is necessary for inference during typeck.\n+                    //\n+                    // As this is incomplete, we must not do so during coherence.\n+                    match (self.solver_mode(), subst_relate_response) {\n+                        (SolverMode::Normal, Ok(response)) => Ok(response),\n+                        (SolverMode::Normal, Err(NoSolution)) | (SolverMode::Coherence, _) => {\n+                            self.flounder(&candidates)\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "88d2091de0f52d961dfb1c8266ffc6542d763295", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -116,6 +116,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n }\n \n impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n+    #[inline]\n     fn register_predicate_obligation(\n         &mut self,\n         infcx: &InferCtxt<'tcx>,"}, {"sha": "0f84032d9ef6d5727006f0f36d2a3107c3987683", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -14,10 +14,12 @@ mod object_safety;\n pub mod outlives_bounds;\n mod project;\n pub mod query;\n+#[cfg_attr(not(bootstrap), allow(hidden_glob_reexports))]\n mod select;\n mod specialize;\n mod structural_match;\n mod structural_normalize;\n+#[cfg_attr(not(bootstrap), allow(hidden_glob_reexports))]\n mod util;\n mod vtable;\n pub mod wf;\n@@ -485,7 +487,7 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n                 tcx,\n                 ObligationCause::dummy_with_span(*span),\n                 param_env,\n-                ty::EarlyBinder(*pred).subst(tcx, impl_trait_ref.substs),\n+                ty::EarlyBinder::new(*pred).subst(tcx, impl_trait_ref.substs),\n             )\n         })\n     });"}, {"sha": "0be21156b6c96c51c8034480338791f6e7f8f425", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -642,7 +642,7 @@ fn receiver_for_self_ty<'tcx>(\n         if param.index == 0 { self_ty.into() } else { tcx.mk_param_from_def(param) }\n     });\n \n-    let result = EarlyBinder(receiver_ty).subst(tcx, substs);\n+    let result = EarlyBinder::new(receiver_ty).subst(tcx, substs);\n     debug!(\n         \"receiver_for_self_ty({:?}, {:?}, {:?}) = {:?}\",\n         receiver_ty, self_ty, method_def_id, result"}, {"sha": "f8d056e321e656e28bf0fdf622fc2ee4ea57303c", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::InferCtxt;\n-use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::infer::canonical::{OriginalQueryValues, QueryRegionConstraints};\n use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n \n@@ -68,20 +68,29 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n             return vec![];\n         }\n \n-        let span = self.tcx.def_span(body_id);\n-        let result: Result<_, ErrorGuaranteed> = param_env\n-            .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n-            .fully_perform(self, span);\n-        let result = match result {\n-            Ok(r) => r,\n-            Err(_) => {\n-                return vec![];\n-            }\n+        let mut canonical_var_values = OriginalQueryValues::default();\n+        let canonical_ty =\n+            self.canonicalize_query_keep_static(param_env.and(ty), &mut canonical_var_values);\n+        let Ok(canonical_result) = self.tcx.implied_outlives_bounds(canonical_ty) else {\n+            return vec![];\n+        };\n+\n+        let mut constraints = QueryRegionConstraints::default();\n+        let Ok(InferOk { value, obligations }) = self\n+            .instantiate_nll_query_response_and_region_obligations(\n+                &ObligationCause::dummy(),\n+                param_env,\n+                &canonical_var_values,\n+                canonical_result,\n+                &mut constraints,\n+            ) else {\n+            return vec![];\n         };\n+        assert_eq!(&obligations, &[]);\n \n-        let TypeOpOutput { output, constraints, .. } = result;\n+        if !constraints.is_empty() {\n+            let span = self.tcx.def_span(body_id);\n \n-        if let Some(constraints) = constraints {\n             debug!(?constraints);\n             if !constraints.member_constraints.is_empty() {\n                 span_bug!(span, \"{:#?}\", constraints.member_constraints);\n@@ -108,7 +117,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n             }\n         };\n \n-        output\n+        value\n     }\n \n     fn implied_bounds_tys("}, {"sha": "0a1b1b10b00704e5eb28b347461fab4471b66a01", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 267, "deletions": 2, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,6 +1,11 @@\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use crate::traits::query::normalize::QueryNormalizeExt;\n+use crate::traits::query::NoSolution;\n+use crate::traits::{Normalized, ObligationCause, ObligationCtxt};\n \n-pub use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n+use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_span::source_map::{Span, DUMMY_SP};\n \n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n@@ -71,3 +76,263 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Generator(..) => false,\n     }\n }\n+\n+pub fn compute_dropck_outlives_inner<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Result<DropckOutlivesResult<'tcx>, NoSolution> {\n+    let tcx = ocx.infcx.tcx;\n+    let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+    // A stack of types left to process. Each round, we pop\n+    // something from the stack and invoke\n+    // `dtorck_constraint_for_ty_inner`. This may produce new types that\n+    // have to be pushed on the stack. This continues until we have explored\n+    // all the reachable types from the type `for_ty`.\n+    //\n+    // Example: Imagine that we have the following code:\n+    //\n+    // ```rust\n+    // struct A {\n+    //     value: B,\n+    //     children: Vec<A>,\n+    // }\n+    //\n+    // struct B {\n+    //     value: u32\n+    // }\n+    //\n+    // fn f() {\n+    //   let a: A = ...;\n+    //   ..\n+    // } // here, `a` is dropped\n+    // ```\n+    //\n+    // at the point where `a` is dropped, we need to figure out\n+    // which types inside of `a` contain region data that may be\n+    // accessed by any destructors in `a`. We begin by pushing `A`\n+    // onto the stack, as that is the type of `a`. We will then\n+    // invoke `dtorck_constraint_for_ty_inner` which will expand `A`\n+    // into the types of its fields `(B, Vec<A>)`. These will get\n+    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+    // lead to us trying to push `A` a second time -- to prevent\n+    // infinite recursion, we notice that `A` was already pushed\n+    // once and stop.\n+    let mut ty_stack = vec![(for_ty, 0)];\n+\n+    // Set used to detect infinite recursion.\n+    let mut ty_set = FxHashSet::default();\n+\n+    let cause = ObligationCause::dummy();\n+    let mut constraints = DropckConstraint::empty();\n+    while let Some((ty, depth)) = ty_stack.pop() {\n+        debug!(\n+            \"{} kinds, {} overflows, {} ty_stack\",\n+            result.kinds.len(),\n+            result.overflows.len(),\n+            ty_stack.len()\n+        );\n+        dtorck_constraint_for_ty_inner(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+        // \"outlives\" represent types/regions that may be touched\n+        // by a destructor.\n+        result.kinds.append(&mut constraints.outlives);\n+        result.overflows.append(&mut constraints.overflows);\n+\n+        // If we have even one overflow, we should stop trying to evaluate further --\n+        // chances are, the subsequent overflows for this evaluation won't provide useful\n+        // information and will just decrease the speed at which we can emit these errors\n+        // (since we'll be printing for just that much longer for the often enormous types\n+        // that result here).\n+        if !result.overflows.is_empty() {\n+            break;\n+        }\n+\n+        // dtorck types are \"types that will get dropped but which\n+        // do not themselves define a destructor\", more or less. We have\n+        // to push them onto the stack to be expanded.\n+        for ty in constraints.dtorck_types.drain(..) {\n+            let Normalized { value: ty, obligations } =\n+                ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n+            ocx.register_obligations(obligations);\n+\n+            debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+            match ty.kind() {\n+                // All parameters live for the duration of the\n+                // function.\n+                ty::Param(..) => {}\n+\n+                // A projection that we couldn't resolve - it\n+                // might have a destructor.\n+                ty::Alias(..) => {\n+                    result.kinds.push(ty.into());\n+                }\n+\n+                _ => {\n+                    if ty_set.insert(ty) {\n+                        ty_stack.push((ty, depth + 1));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"dropck_outlives: result = {:#?}\", result);\n+    Ok(result)\n+}\n+\n+/// Returns a set of constraints that needs to be satisfied in\n+/// order for `ty` to be valid for destruction.\n+pub fn dtorck_constraint_for_ty_inner<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    for_ty: Ty<'tcx>,\n+    depth: usize,\n+    ty: Ty<'tcx>,\n+    constraints: &mut DropckConstraint<'tcx>,\n+) -> Result<(), NoSolution> {\n+    debug!(\"dtorck_constraint_for_ty_inner({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        constraints.overflows.push(ty);\n+        return Ok(());\n+    }\n+\n+    if trivial_dropck_outlives(tcx, ty) {\n+        return Ok(());\n+    }\n+\n+    match ty.kind() {\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Str\n+        | ty::Never\n+        | ty::Foreign(..)\n+        | ty::RawPtr(..)\n+        | ty::Ref(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::GeneratorWitness(..)\n+        | ty::GeneratorWitnessMIR(..) => {\n+            // these types never have a destructor\n+        }\n+\n+        ty::Array(ety, _) | ty::Slice(ety) => {\n+            // single-element containers, behave like their element\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, *ety, constraints)\n+            })?;\n+        }\n+\n+        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+            for ty in tys.iter() {\n+                dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+            }\n+            Ok::<_, NoSolution>(())\n+        })?,\n+\n+        ty::Closure(_, substs) => {\n+            if !substs.as_closure().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                for ty in substs.as_closure().upvar_tys() {\n+                    dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+                }\n+                Ok::<_, NoSolution>(())\n+            })?\n+        }\n+\n+        ty::Generator(_, substs, _movability) => {\n+            // rust-lang/rust#49918: types can be constructed, stored\n+            // in the interior, and sit idle when generator yields\n+            // (and is subsequently dropped).\n+            //\n+            // It would be nice to descend into interior of a\n+            // generator to determine what effects dropping it might\n+            // have (by looking at any drop effects associated with\n+            // its interior).\n+            //\n+            // However, the interior's representation uses things like\n+            // GeneratorWitness that explicitly assume they are not\n+            // traversed in such a manner. So instead, we will\n+            // simplify things for now by treating all generators as\n+            // if they were like trait objects, where its upvars must\n+            // all be alive for the generator's (potential)\n+            // destructor.\n+            //\n+            // In particular, skipping over `_interior` is safe\n+            // because any side-effects from dropping `_interior` can\n+            // only take place through references with lifetimes\n+            // derived from lifetimes attached to the upvars and resume\n+            // argument, and we *do* incorporate those here.\n+\n+            if !substs.as_generator().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n+            constraints.outlives.extend(\n+                substs\n+                    .as_generator()\n+                    .upvar_tys()\n+                    .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n+            );\n+            constraints.outlives.push(substs.as_generator().resume_ty().into());\n+        }\n+\n+        ty::Adt(def, substs) => {\n+            let DropckConstraint { dtorck_types, outlives, overflows } =\n+                tcx.at(span).adt_dtorck_constraint(def.did())?;\n+            // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+            // there, but that needs some way to handle cycles.\n+            constraints\n+                .dtorck_types\n+                .extend(dtorck_types.iter().map(|t| EarlyBinder::new(*t).subst(tcx, substs)));\n+            constraints\n+                .outlives\n+                .extend(outlives.iter().map(|t| EarlyBinder::new(*t).subst(tcx, substs)));\n+            constraints\n+                .overflows\n+                .extend(overflows.iter().map(|t| EarlyBinder::new(*t).subst(tcx, substs)));\n+        }\n+\n+        // Objects must be alive in order for their destructor\n+        // to be called.\n+        ty::Dynamic(..) => {\n+            constraints.outlives.push(ty.into());\n+        }\n+\n+        // Types that can't be resolved. Pass them forward.\n+        ty::Alias(..) | ty::Param(..) => {\n+            constraints.dtorck_types.push(ty);\n+        }\n+\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n+            // By the time this code runs, all type variables ought to\n+            // be fully resolved.\n+            return Err(NoSolution);\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "01d7a1e7913b554850666bf0dcffc249d6d0e752", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,8 +1,13 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n+use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, UserSelfTy, UserSubsts, UserType};\n \n pub use rustc_middle::traits::query::type_op::AscribeUserType;\n+use rustc_span::{Span, DUMMY_SP};\n \n impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     type QueryResponse = ();\n@@ -20,4 +25,116 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        type_op_ascribe_user_type_with_span(ocx, key, None)\n+    }\n+}\n+\n+/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n+/// this query can be re-run to better track the span of the obligation cause, and improve the error\n+/// message. Do not call directly unless you're in that very specific context.\n+pub fn type_op_ascribe_user_type_with_span<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n+    span: Option<Span>,\n+) -> Result<(), NoSolution> {\n+    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n+    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n+    let span = span.unwrap_or(DUMMY_SP);\n+    match user_ty {\n+        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n+        UserType::TypeOf(def_id, user_substs) => {\n+            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n+        }\n+    };\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_ty<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    user_ty: Ty<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let cause = ObligationCause::dummy_with_span(span);\n+    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n+\n+    // FIXME(#104764): We should check well-formedness before normalization.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n+    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_substs<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    def_id: DefId,\n+    user_substs: UserSubsts<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let param_env = param_env.without_const();\n+    let UserSubsts { user_self_ty, substs } = user_substs;\n+    let tcx = ocx.infcx.tcx;\n+    let cause = ObligationCause::dummy_with_span(span);\n+\n+    let ty = tcx.type_of(def_id).subst(tcx, substs);\n+    let ty = ocx.normalize(&cause, param_env, ty);\n+    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n+\n+    ocx.eq(&cause, param_env, mir_ty, ty)?;\n+\n+    // Prove the predicates coming along with `def_id`.\n+    //\n+    // Also, normalize the `instantiated_predicates`\n+    // because otherwise we wind up with duplicate \"type\n+    // outlives\" error messages.\n+    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n+\n+    debug!(?instantiated_predicates);\n+    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n+        let span = if span == DUMMY_SP { predicate_span } else { span };\n+        let cause = ObligationCause::new(\n+            span,\n+            CRATE_DEF_ID,\n+            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+        );\n+        let instantiated_predicate =\n+            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n+\n+        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n+    }\n+\n+    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n+        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n+\n+        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n+        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n+    }\n+\n+    // In addition to proving the predicates, we have to\n+    // prove that `ty` is well-formed -- this is because\n+    // the WF of `ty` is predicated on the substs being\n+    // well-formed, and we haven't proven *that*. We don't\n+    // want to prove the WF of types from  `substs` directly because they\n+    // haven't been normalized.\n+    //\n+    // FIXME(nmatsakis): Well, perhaps we should normalize\n+    // them?  This would only be relevant if some input\n+    // type were ill-formed but did not appear in `ty`,\n+    // which...could happen with normalization...\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n+    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n+    Ok(())\n }"}, {"sha": "f65893088066ef057bb11f7cc5585540a69c0089", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/eq.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::Eq;\n@@ -20,4 +22,12 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_eq(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        ocx.eq(&ObligationCause::dummy(), key.param_env, key.value.a, key.value.b)?;\n+        Ok(())\n+    }\n }"}, {"sha": "9989fc9c479a38da498f29d3192b86a004d712aa", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 176, "deletions": 3, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,7 +1,15 @@\n-use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::query::NoSolution;\n+use crate::traits::wf;\n+use crate::traits::ObligationCtxt;\n+\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::traits::query::OutlivesBound;\n-use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_middle::infer::canonical::CanonicalQueryResponse;\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::def_id::CRATE_DEF_ID;\n+use rustc_span::source_map::DUMMY_SP;\n+use smallvec::{smallvec, SmallVec};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n@@ -39,4 +47,169 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n \n         tcx.implied_outlives_bounds(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        compute_implied_outlives_bounds_inner(ocx, key.param_env, key.value.ty)\n+    }\n+}\n+\n+pub fn compute_implied_outlives_bounds_inner<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n+    let tcx = ocx.infcx.tcx;\n+\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Because the resulting predicates aren't always\n+    // guaranteed to be a subset of the original type, so we need to store the\n+    // WF args we've computed in a set.\n+    let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n+    let mut wf_args = vec![ty.into()];\n+\n+    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n+        vec![];\n+\n+    while let Some(arg) = wf_args.pop() {\n+        if !checked_wf_args.insert(arg) {\n+            continue;\n+        }\n+\n+        // Compute the obligations for `arg` to be well-formed. If `arg` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        //\n+        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n+        // bounds can be backward incompatible, e.g. #101951 was caused by\n+        // us not dealing with inference vars in `TypeOutlives` predicates.\n+        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n+            .unwrap_or_default();\n+\n+        for obligation in obligations {\n+            debug!(?obligation);\n+            assert!(!obligation.has_escaping_bound_vars());\n+\n+            // While these predicates should all be implied by other parts of\n+            // the program, they are still relevant as they may constrain\n+            // inference variables, which is necessary to add the correct\n+            // implied bounds in some cases, mostly when dealing with projections.\n+            //\n+            // Another important point here: we only register `Projection`\n+            // predicates, since otherwise we might register outlives\n+            // predicates containing inference variables, and we don't\n+            // learn anything new from those.\n+            if obligation.predicate.has_non_region_infer() {\n+                match obligation.predicate.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                    | ty::PredicateKind::AliasRelate(..) => {\n+                        ocx.register_obligation(obligation.clone());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            let pred = match obligation.predicate.kind().no_bound_vars() {\n+                None => continue,\n+                Some(pred) => pred,\n+            };\n+            match pred {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n+                // if we ever support that\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::AliasRelate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+\n+                // We need to search through *all* WellFormed predicates\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    wf_args.push(arg);\n+                }\n+\n+                // We need to register region relationships\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    r_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n+\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    ty_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n+            }\n+        }\n+    }\n+\n+    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n+    // use further down when computing the implied bounds.\n+    match ocx.select_all_or_error().as_slice() {\n+        [] => (),\n+        _ => return Err(NoSolution),\n+    }\n+\n+    // We lazily compute the outlives components as\n+    // `select_all_or_error` constrains inference variables.\n+    let implied_bounds = outlives_bounds\n+        .into_iter()\n+        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n+            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n+            ty::GenericArgKind::Type(ty_a) => {\n+                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n+                let mut components = smallvec![];\n+                push_outlives_components(tcx, ty_a, &mut components);\n+                implied_bounds_from_components(r_b, components)\n+            }\n+            ty::GenericArgKind::Const(_) => unreachable!(),\n+        })\n+        .collect();\n+\n+    Ok(implied_bounds)\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components<'tcx>(\n+    sub_region: ty::Region<'tcx>,\n+    sup_components: SmallVec<[Component<'tcx>; 4]>,\n+) -> Vec<OutlivesBound<'tcx>> {\n+    sup_components\n+        .into_iter()\n+        .filter_map(|component| {\n+            match component {\n+                Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n+                Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n+                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n+                Component::EscapingAlias(_) =>\n+                // If the projection has escaping regions, don't\n+                // try to infer any implied bounds even for its\n+                // free components. This is conservative, because\n+                // the caller will still have to prove that those\n+                // free components outlive `sub_region`. But the\n+                // idea is that the WAY that the caller proves\n+                // that may change in the future and we want to\n+                // give ourselves room to get smarter here.\n+                {\n+                    None\n+                }\n+                Component::UnresolvedInferenceVariable(..) => None,\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "642fdec2d9ae33278c92f8f15a7b0a4409dca5d4", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2,7 +2,7 @@ use crate::infer::canonical::{\n     Canonical, CanonicalQueryResponse, OriginalQueryValues, QueryRegionConstraints,\n };\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::canonical::Certainty;\n use rustc_infer::traits::PredicateObligations;\n@@ -23,6 +23,8 @@ pub mod subtype;\n \n pub use rustc_middle::traits::query::type_op::*;\n \n+use self::custom::scrape_region_constraints;\n+\n /// \"Type ops\" are used in NLL to perform some particular action and\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n@@ -81,6 +83,17 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<TyCtxt<'tcx>> + 't\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution>;\n \n+    /// In the new trait solver, we already do caching in the solver itself,\n+    /// so there's no need to canonicalize and cache via the query system.\n+    /// Additionally, even if we were to canonicalize, we'd still need to\n+    /// make sure to feed it predefined opaque types and the defining anchor\n+    /// and that would require duplicating all of the tcx queries. Instead,\n+    /// just perform these ops locally.\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution>;\n+\n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'tcx>,\n@@ -133,6 +146,16 @@ where\n         infcx: &InferCtxt<'tcx>,\n         span: Span,\n     ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n+        if infcx.tcx.trait_solver_next() {\n+            return Ok(scrape_region_constraints(\n+                infcx,\n+                |ocx| QueryTypeOp::perform_locally_in_new_solver(ocx, self),\n+                \"query type op\",\n+                span,\n+            )?\n+            .0);\n+        }\n+\n         let mut region_constraints = QueryRegionConstraints::default();\n         let (output, error_info, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints).map_err(|_| {"}, {"sha": "57ca14aa492ffb036f5b4a5daf08ac8662bfbf78", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/normalize.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt, TypeVisitableExt};\n use std::fmt;\n@@ -22,6 +24,14 @@ where\n     ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution> {\n         T::type_op_method(tcx, canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        // FIXME(-Ztrait-solver=next): shouldn't be using old normalizer\n+        Ok(ocx.normalize(&ObligationCause::dummy(), key.param_env, key.value.value))\n+    }\n }\n \n pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<TyCtxt<'tcx>> + Lift<'tcx> + Copy {"}, {"sha": "9889426337476ff87ae2d15ef67c586abe6bf9c9", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/outlives.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,6 +1,9 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::dropck_outlives::{trivial_dropck_outlives, DropckOutlivesResult};\n-use rustc_middle::traits::query::NoSolution;\n+use crate::traits::query::dropck_outlives::{\n+    compute_dropck_outlives_inner, trivial_dropck_outlives,\n+};\n+use crate::traits::ObligationCtxt;\n+use rustc_middle::traits::query::{DropckOutlivesResult, NoSolution};\n use rustc_middle::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n@@ -48,4 +51,11 @@ impl<'tcx> super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n \n         tcx.dropck_outlives(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        compute_dropck_outlives_inner(ocx, key.param_env.and(key.value.dropped_ty))\n+    }\n }"}, {"sha": "47850bc330dab295c977225059c403728264dfe3", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,5 +1,8 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n+use rustc_infer::traits::Obligation;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::ProvePredicate;\n@@ -36,4 +39,17 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        ocx.register_obligation(Obligation::new(\n+            ocx.infcx.tcx,\n+            ObligationCause::dummy(),\n+            key.param_env,\n+            key.value.predicate,\n+        ));\n+        Ok(())\n+    }\n }"}, {"sha": "10976d5cd71625a7433eb195b3f3684886426ce1", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/subtype.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::Subtype;\n@@ -17,4 +19,12 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_subtype(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        ocx.sub(&ObligationCause::dummy(), key.param_env, key.value.sub, key.value.sup)?;\n+        Ok(())\n+    }\n }"}, {"sha": "3c223db5a0b7459d6da7bebeefdd84de64289081", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -360,7 +360,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // consider a \"quick reject\". This avoids creating more types\n                 // and so forth that we need to.\n                 let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n-                if !drcx.substs_refs_may_unify(obligation_substs, impl_trait_ref.0.substs) {\n+                if !drcx\n+                    .substs_refs_may_unify(obligation_substs, impl_trait_ref.skip_binder().substs)\n+                {\n                     return;\n                 }\n                 if self.reject_fn_ptr_impls("}, {"sha": "0245dfd333beebe82d1620798a761195c7f901b2", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -527,9 +527,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         substs.extend(trait_predicate.trait_ref.substs.iter());\n                         let mut bound_vars: smallvec::SmallVec<[ty::BoundVariableKind; 8]> =\n                             smallvec::SmallVec::with_capacity(\n-                                bound.0.kind().bound_vars().len() + defs.count(),\n+                                bound.skip_binder().kind().bound_vars().len() + defs.count(),\n                             );\n-                        bound_vars.extend(bound.0.kind().bound_vars().into_iter());\n+                        bound_vars.extend(bound.skip_binder().kind().bound_vars().into_iter());\n                         InternalSubsts::fill_single(&mut substs, defs, &mut |param, _| match param\n                             .kind\n                         {"}, {"sha": "ed380f32b72f41d987d887e87b75e4238a0bff5b", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2149,13 +2149,11 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(obligation.predicate.rebind({\n-                    sized_crit\n-                        .0\n-                        .iter()\n-                        .map(|ty| sized_crit.rebind(*ty).subst(self.tcx(), substs))\n-                        .collect()\n-                }))\n+                Where(\n+                    obligation\n+                        .predicate\n+                        .rebind(sized_crit.subst_iter_copied(self.tcx(), substs).collect()),\n+                )\n             }\n \n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) => None,"}, {"sha": "1d3ea96666f2f9b95dd0e3d01d6c87ab57e1aefa", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -294,7 +294,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         };\n         Arc::new(chalk_solve::rust_ir::FnDefDatum {\n             id: fn_def_id,\n-            sig: sig.0.lower_into(self.interner),\n+            sig: sig.skip_binder().lower_into(self.interner),\n             binders: chalk_ir::Binders::new(binders, bound),\n         })\n     }"}, {"sha": "f35c14eeac80139ecb2c29c56094a30de8648972", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 261, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,17 +3,14 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n use rustc_middle::ty::InternalSubsts;\n-use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_middle::ty::TyCtxt;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n-    DropckConstraint, DropckOutlivesResult,\n+    compute_dropck_outlives_inner, dtorck_constraint_for_ty_inner,\n };\n-use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -26,263 +23,10 @@ fn dropck_outlives<'tcx>(\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n     tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n-        let tcx = ocx.infcx.tcx;\n-        let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-        // A stack of types left to process. Each round, we pop\n-        // something from the stack and invoke\n-        // `dtorck_constraint_for_ty`. This may produce new types that\n-        // have to be pushed on the stack. This continues until we have explored\n-        // all the reachable types from the type `for_ty`.\n-        //\n-        // Example: Imagine that we have the following code:\n-        //\n-        // ```rust\n-        // struct A {\n-        //     value: B,\n-        //     children: Vec<A>,\n-        // }\n-        //\n-        // struct B {\n-        //     value: u32\n-        // }\n-        //\n-        // fn f() {\n-        //   let a: A = ...;\n-        //   ..\n-        // } // here, `a` is dropped\n-        // ```\n-        //\n-        // at the point where `a` is dropped, we need to figure out\n-        // which types inside of `a` contain region data that may be\n-        // accessed by any destructors in `a`. We begin by pushing `A`\n-        // onto the stack, as that is the type of `a`. We will then\n-        // invoke `dtorck_constraint_for_ty` which will expand `A`\n-        // into the types of its fields `(B, Vec<A>)`. These will get\n-        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-        // lead to us trying to push `A` a second time -- to prevent\n-        // infinite recursion, we notice that `A` was already pushed\n-        // once and stop.\n-        let mut ty_stack = vec![(for_ty, 0)];\n-\n-        // Set used to detect infinite recursion.\n-        let mut ty_set = FxHashSet::default();\n-\n-        let cause = ObligationCause::dummy();\n-        let mut constraints = DropckConstraint::empty();\n-        while let Some((ty, depth)) = ty_stack.pop() {\n-            debug!(\n-                \"{} kinds, {} overflows, {} ty_stack\",\n-                result.kinds.len(),\n-                result.overflows.len(),\n-                ty_stack.len()\n-            );\n-            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-            // \"outlives\" represent types/regions that may be touched\n-            // by a destructor.\n-            result.kinds.append(&mut constraints.outlives);\n-            result.overflows.append(&mut constraints.overflows);\n-\n-            // If we have even one overflow, we should stop trying to evaluate further --\n-            // chances are, the subsequent overflows for this evaluation won't provide useful\n-            // information and will just decrease the speed at which we can emit these errors\n-            // (since we'll be printing for just that much longer for the often enormous types\n-            // that result here).\n-            if !result.overflows.is_empty() {\n-                break;\n-            }\n-\n-            // dtorck types are \"types that will get dropped but which\n-            // do not themselves define a destructor\", more or less. We have\n-            // to push them onto the stack to be expanded.\n-            for ty in constraints.dtorck_types.drain(..) {\n-                let Normalized { value: ty, obligations } =\n-                    ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n-                ocx.register_obligations(obligations);\n-\n-                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                match ty.kind() {\n-                    // All parameters live for the duration of the\n-                    // function.\n-                    ty::Param(..) => {}\n-\n-                    // A projection that we couldn't resolve - it\n-                    // might have a destructor.\n-                    ty::Alias(..) => {\n-                        result.kinds.push(ty.into());\n-                    }\n-\n-                    _ => {\n-                        if ty_set.insert(ty) {\n-                            ty_stack.push((ty, depth + 1));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        debug!(\"dropck_outlives: result = {:#?}\", result);\n-        Ok(result)\n+        compute_dropck_outlives_inner(ocx, goal)\n     })\n }\n \n-/// Returns a set of constraints that needs to be satisfied in\n-/// order for `ty` to be valid for destruction.\n-fn dtorck_constraint_for_ty<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    for_ty: Ty<'tcx>,\n-    depth: usize,\n-    ty: Ty<'tcx>,\n-    constraints: &mut DropckConstraint<'tcx>,\n-) -> Result<(), NoSolution> {\n-    debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n-\n-    if !tcx.recursion_limit().value_within_limit(depth) {\n-        constraints.overflows.push(ty);\n-        return Ok(());\n-    }\n-\n-    if trivial_dropck_outlives(tcx, ty) {\n-        return Ok(());\n-    }\n-\n-    match ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Str\n-        | ty::Never\n-        | ty::Foreign(..)\n-        | ty::RawPtr(..)\n-        | ty::Ref(..)\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::GeneratorWitness(..)\n-        | ty::GeneratorWitnessMIR(..) => {\n-            // these types never have a destructor\n-        }\n-\n-        ty::Array(ety, _) | ty::Slice(ety) => {\n-            // single-element containers, behave like their element\n-            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, *ety, constraints)\n-            })?;\n-        }\n-\n-        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-            for ty in tys.iter() {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n-            }\n-            Ok::<_, NoSolution>(())\n-        })?,\n-\n-        ty::Closure(_, substs) => {\n-            if !substs.as_closure().is_valid() {\n-                // By the time this code runs, all type variables ought to\n-                // be fully resolved.\n-\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n-                );\n-                return Err(NoSolution);\n-            }\n-\n-            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                for ty in substs.as_closure().upvar_tys() {\n-                    dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n-                }\n-                Ok::<_, NoSolution>(())\n-            })?\n-        }\n-\n-        ty::Generator(_, substs, _movability) => {\n-            // rust-lang/rust#49918: types can be constructed, stored\n-            // in the interior, and sit idle when generator yields\n-            // (and is subsequently dropped).\n-            //\n-            // It would be nice to descend into interior of a\n-            // generator to determine what effects dropping it might\n-            // have (by looking at any drop effects associated with\n-            // its interior).\n-            //\n-            // However, the interior's representation uses things like\n-            // GeneratorWitness that explicitly assume they are not\n-            // traversed in such a manner. So instead, we will\n-            // simplify things for now by treating all generators as\n-            // if they were like trait objects, where its upvars must\n-            // all be alive for the generator's (potential)\n-            // destructor.\n-            //\n-            // In particular, skipping over `_interior` is safe\n-            // because any side-effects from dropping `_interior` can\n-            // only take place through references with lifetimes\n-            // derived from lifetimes attached to the upvars and resume\n-            // argument, and we *do* incorporate those here.\n-\n-            if !substs.as_generator().is_valid() {\n-                // By the time this code runs, all type variables ought to\n-                // be fully resolved.\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n-                );\n-                return Err(NoSolution);\n-            }\n-\n-            constraints.outlives.extend(\n-                substs\n-                    .as_generator()\n-                    .upvar_tys()\n-                    .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n-            );\n-            constraints.outlives.push(substs.as_generator().resume_ty().into());\n-        }\n-\n-        ty::Adt(def, substs) => {\n-            let DropckConstraint { dtorck_types, outlives, overflows } =\n-                tcx.at(span).adt_dtorck_constraint(def.did())?;\n-            // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n-            // there, but that needs some way to handle cycles.\n-            constraints\n-                .dtorck_types\n-                .extend(dtorck_types.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-            constraints\n-                .outlives\n-                .extend(outlives.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-            constraints\n-                .overflows\n-                .extend(overflows.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-        }\n-\n-        // Objects must be alive in order for their destructor\n-        // to be called.\n-        ty::Dynamic(..) => {\n-            constraints.outlives.push(ty.into());\n-        }\n-\n-        // Types that can't be resolved. Pass them forward.\n-        ty::Alias(..) | ty::Param(..) => {\n-            constraints.dtorck_types.push(ty);\n-        }\n-\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n-            // By the time this code runs, all type variables ought to\n-            // be fully resolved.\n-            return Err(NoSolution);\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n /// Calculates the dtorck constraint for a type.\n pub(crate) fn adt_dtorck_constraint(\n     tcx: TyCtxt<'_>,\n@@ -311,7 +55,7 @@ pub(crate) fn adt_dtorck_constraint(\n     let mut result = DropckConstraint::empty();\n     for field in def.all_fields() {\n         let fty = tcx.type_of(field.did).subst_identity();\n-        dtorck_constraint_for_ty(tcx, span, fty, 0, fty, &mut result)?;\n+        dtorck_constraint_for_ty_inner(tcx, span, fty, 0, fty, &mut result)?;\n     }\n     result.outlives.extend(tcx.destructor_constraints(def));\n     dedup_dtorck_constraint(&mut result);"}, {"sha": "959838ab348fd0026585d3bda06f1569dd847327", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 166, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,18 +3,13 @@\n //! [`rustc_trait_selection::traits::query::type_op::implied_outlives_bounds`].\n \n use rustc_infer::infer::canonical::{self, Canonical};\n-use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::query::OutlivesBound;\n use rustc_middle::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::source_map::DUMMY_SP;\n+use rustc_middle::ty::TyCtxt;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n+use rustc_trait_selection::traits::query::type_op::implied_outlives_bounds::compute_implied_outlives_bounds_inner;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::wf;\n-use rustc_trait_selection::traits::ObligationCtxt;\n-use smallvec::{smallvec, SmallVec};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { implied_outlives_bounds, ..*p };\n@@ -29,164 +24,6 @@ fn implied_outlives_bounds<'tcx>(\n > {\n     tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(ocx, param_env, ty)\n+        compute_implied_outlives_bounds_inner(ocx, param_env, ty)\n     })\n }\n-\n-fn compute_implied_outlives_bounds<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n-    let tcx = ocx.infcx.tcx;\n-\n-    // Sometimes when we ask what it takes for T: WF, we get back that\n-    // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Because the resulting predicates aren't always\n-    // guaranteed to be a subset of the original type, so we need to store the\n-    // WF args we've computed in a set.\n-    let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n-    let mut wf_args = vec![ty.into()];\n-\n-    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n-        vec![];\n-\n-    while let Some(arg) = wf_args.pop() {\n-        if !checked_wf_args.insert(arg) {\n-            continue;\n-        }\n-\n-        // Compute the obligations for `arg` to be well-formed. If `arg` is\n-        // an unresolved inference variable, just substituted an empty set\n-        // -- because the return type here is going to be things we *add*\n-        // to the environment, it's always ok for this set to be smaller\n-        // than the ultimate set. (Note: normally there won't be\n-        // unresolved inference variables here anyway, but there might be\n-        // during typeck under some circumstances.)\n-        //\n-        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n-        // bounds can be backward incompatible, e.g. #101951 was caused by\n-        // us not dealing with inference vars in `TypeOutlives` predicates.\n-        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n-            .unwrap_or_default();\n-\n-        for obligation in obligations {\n-            debug!(?obligation);\n-            assert!(!obligation.has_escaping_bound_vars());\n-\n-            // While these predicates should all be implied by other parts of\n-            // the program, they are still relevant as they may constrain\n-            // inference variables, which is necessary to add the correct\n-            // implied bounds in some cases, mostly when dealing with projections.\n-            //\n-            // Another important point here: we only register `Projection`\n-            // predicates, since otherwise we might register outlives\n-            // predicates containing inference variables, and we don't\n-            // learn anything new from those.\n-            if obligation.predicate.has_non_region_infer() {\n-                match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                    | ty::PredicateKind::AliasRelate(..) => {\n-                        ocx.register_obligation(obligation.clone());\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            let pred = match obligation.predicate.kind().no_bound_vars() {\n-                None => continue,\n-                Some(pred) => pred,\n-            };\n-            match pred {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n-                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n-                // if we ever support that\n-                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasRelate(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n-\n-                // We need to search through *all* WellFormed predicates\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    wf_args.push(arg);\n-                }\n-\n-                // We need to register region relationships\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                    r_a,\n-                    r_b,\n-                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n-\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                    ty_a,\n-                    r_b,\n-                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n-            }\n-        }\n-    }\n-\n-    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n-    // use further down when computing the implied bounds.\n-    match ocx.select_all_or_error().as_slice() {\n-        [] => (),\n-        _ => return Err(NoSolution),\n-    }\n-\n-    // We lazily compute the outlives components as\n-    // `select_all_or_error` constrains inference variables.\n-    let implied_bounds = outlives_bounds\n-        .into_iter()\n-        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n-            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n-            ty::GenericArgKind::Type(ty_a) => {\n-                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n-                let mut components = smallvec![];\n-                push_outlives_components(tcx, ty_a, &mut components);\n-                implied_bounds_from_components(r_b, components)\n-            }\n-            ty::GenericArgKind::Const(_) => unreachable!(),\n-        })\n-        .collect();\n-\n-    Ok(implied_bounds)\n-}\n-\n-/// When we have an implied bound that `T: 'a`, we can further break\n-/// this down to determine what relationships would have to hold for\n-/// `T: 'a` to hold. We get to assume that the caller has validated\n-/// those relationships.\n-fn implied_bounds_from_components<'tcx>(\n-    sub_region: ty::Region<'tcx>,\n-    sup_components: SmallVec<[Component<'tcx>; 4]>,\n-) -> Vec<OutlivesBound<'tcx>> {\n-    sup_components\n-        .into_iter()\n-        .filter_map(|component| {\n-            match component {\n-                Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n-                Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n-                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n-                Component::EscapingAlias(_) =>\n-                // If the projection has escaping regions, don't\n-                // try to infer any implied bounds even for its\n-                // free components. This is conservative, because\n-                // the caller will still have to prove that those\n-                // free components outlive `sub_region`. But the\n-                // idea is that the WAY that the caller proves\n-                // that may change in the future and we want to\n-                // give ourselves room to get smarter here.\n-                {\n-                    None\n-                }\n-                Component::UnresolvedInferenceVariable(..) => None,\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "907e2d39c518f057f3c33ddd503eaa16d95c68ed", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -21,7 +21,8 @@ mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n \n-pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n+pub use rustc_trait_selection::traits::query::type_op::ascribe_user_type::type_op_ascribe_user_type_with_span;\n+pub use type_op::type_op_prove_predicate_with_cause;\n \n use rustc_middle::query::Providers;\n "}, {"sha": "9904acb1c0d516ab2b56364ccb9ad3ea6bb565e9", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 5, "deletions": 112, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,17 +1,15 @@\n-use rustc_hir as hir;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::{DefiningAnchor, ObligationCauseCode};\n-use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::traits::DefiningAnchor;\n+use rustc_middle::ty::{FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ParamEnvAnd, Predicate};\n-use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n-use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n+use rustc_trait_selection::traits::query::type_op::ascribe_user_type::{\n+    type_op_ascribe_user_type_with_span, AscribeUserType,\n+};\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n@@ -42,111 +40,6 @@ fn type_op_ascribe_user_type<'tcx>(\n     })\n }\n \n-/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n-/// this query can be re-run to better track the span of the obligation cause, and improve the error\n-/// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_ascribe_user_type_with_span<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n-    span: Option<Span>,\n-) -> Result<(), NoSolution> {\n-    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n-    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n-    let span = span.unwrap_or(DUMMY_SP);\n-    match user_ty {\n-        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n-        UserType::TypeOf(def_id, user_substs) => {\n-            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n-        }\n-    };\n-    Ok(())\n-}\n-\n-#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n-fn relate_mir_and_user_ty<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-    mir_ty: Ty<'tcx>,\n-    user_ty: Ty<'tcx>,\n-) -> Result<(), NoSolution> {\n-    let cause = ObligationCause::dummy_with_span(span);\n-    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n-    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n-\n-    // FIXME(#104764): We should check well-formedness before normalization.\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n-    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n-    Ok(())\n-}\n-\n-#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n-fn relate_mir_and_user_substs<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-    mir_ty: Ty<'tcx>,\n-    def_id: hir::def_id::DefId,\n-    user_substs: UserSubsts<'tcx>,\n-) -> Result<(), NoSolution> {\n-    let param_env = param_env.without_const();\n-    let UserSubsts { user_self_ty, substs } = user_substs;\n-    let tcx = ocx.infcx.tcx;\n-    let cause = ObligationCause::dummy_with_span(span);\n-\n-    let ty = tcx.type_of(def_id).subst(tcx, substs);\n-    let ty = ocx.normalize(&cause, param_env, ty);\n-    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-\n-    ocx.eq(&cause, param_env, mir_ty, ty)?;\n-\n-    // Prove the predicates coming along with `def_id`.\n-    //\n-    // Also, normalize the `instantiated_predicates`\n-    // because otherwise we wind up with duplicate \"type\n-    // outlives\" error messages.\n-    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-    debug!(?instantiated_predicates);\n-    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n-        let span = if span == DUMMY_SP { predicate_span } else { span };\n-        let cause = ObligationCause::new(\n-            span,\n-            CRATE_DEF_ID,\n-            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-        );\n-        let instantiated_predicate =\n-            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n-\n-        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n-    }\n-\n-    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n-        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n-        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n-\n-        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n-        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n-        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n-    }\n-\n-    // In addition to proving the predicates, we have to\n-    // prove that `ty` is well-formed -- this is because\n-    // the WF of `ty` is predicated on the substs being\n-    // well-formed, and we haven't proven *that*. We don't\n-    // want to prove the WF of types from  `substs` directly because they\n-    // haven't been normalized.\n-    //\n-    // FIXME(nmatsakis): Well, perhaps we should normalize\n-    // them?  This would only be relevant if some input\n-    // type were ill-formed but did not appear in `ty`,\n-    // which...could happen with normalization...\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n-    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n-    Ok(())\n-}\n-\n fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,"}, {"sha": "0925b3956de369226c3c22b9e7692cba165b19dc", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -301,7 +301,7 @@ fn associated_type_for_impl_trait_in_trait(\n     trait_assoc_ty.impl_defaultness(tcx.impl_defaultness(fn_def_id));\n \n     // Copy type_of of the opaque.\n-    trait_assoc_ty.type_of(ty::EarlyBinder(tcx.mk_opaque(\n+    trait_assoc_ty.type_of(ty::EarlyBinder::new(tcx.mk_opaque(\n         opaque_ty_def_id.to_def_id(),\n         InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n     )));"}, {"sha": "bb723c9997ac110e278c43088add61300b8c5342", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -419,7 +419,7 @@ pub fn thir_abstract_const(\n \n     let root_span = body.exprs[body_id].span;\n \n-    Ok(Some(ty::EarlyBinder(recurse_build(tcx, body, body_id, root_span)?)))\n+    Ok(Some(ty::EarlyBinder::new(recurse_build(tcx, body, body_id, root_span)?)))\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "0e5b23ca423efefda4428a407c7f934c40c59936", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -610,7 +610,7 @@ fn generator_layout<'tcx>(\n ) -> Result<Layout<'tcx>, LayoutError<'tcx>> {\n     use SavedLocalEligibility::*;\n     let tcx = cx.tcx;\n-    let subst_field = |ty: Ty<'tcx>| EarlyBinder(ty).subst(tcx, substs);\n+    let subst_field = |ty: Ty<'tcx>| EarlyBinder::new(ty).subst(tcx, substs);\n \n     let Some(info) = tcx.generator_layout(def_id) else {\n         return Err(LayoutError::Unknown(ty));"}, {"sha": "075fde6ddb654293627ccad63793cabf733e7973", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -210,7 +210,7 @@ fn drop_tys_helper<'tcx>(\n             match subty.kind() {\n                 ty::Adt(adt_id, subst) => {\n                     for subty in tcx.adt_drop_tys(adt_id.did())? {\n-                        vec.push(EarlyBinder(subty).subst(tcx, subst));\n+                        vec.push(EarlyBinder::new(subty).subst(tcx, subst));\n                     }\n                 }\n                 _ => vec.push(subty),"}, {"sha": "52bc386cb009deaeb291c24e473aa9b1252fa32f", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -44,9 +44,7 @@ fn sized_constraint_for_ty<'tcx>(\n             let adt_tys = adt.sized_constraint(tcx);\n             debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\", ty, adt_tys);\n             adt_tys\n-                .0\n-                .iter()\n-                .map(|ty| adt_tys.rebind(*ty).subst(tcx, substs))\n+                .subst_iter_copied(tcx, substs)\n                 .flat_map(|ty| sized_constraint_for_ty(tcx, adtdef, ty))\n                 .collect()\n         }\n@@ -508,7 +506,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<EarlyBinder<Ty<'\n \n     if self_ty_matches {\n         debug!(\"issue33140_self_ty - MATCHES!\");\n-        Some(EarlyBinder(self_ty))\n+        Some(EarlyBinder::new(self_ty))\n     } else {\n         debug!(\"issue33140_self_ty - non-matching self type\");\n         None"}, {"sha": "c524d4c036709c4c8f4fb3f49adfb5cc9a330199", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1851,7 +1851,7 @@ impl String {\n     }\n \n     /// Consumes and leaks the `String`, returning a mutable reference to the contents,\n-    /// `&'static mut str`.\n+    /// `&'a mut str`.\n     ///\n     /// This is mainly useful for data that lives for the remainder of\n     /// the program's life. Dropping the returned reference will cause a memory\n@@ -1874,7 +1874,7 @@ impl String {\n     /// ```\n     #[unstable(feature = \"string_leak\", issue = \"102929\")]\n     #[inline]\n-    pub fn leak(self) -> &'static mut str {\n+    pub fn leak<'a>(self) -> &'a mut str {\n         let slice = self.vec.leak();\n         unsafe { from_utf8_unchecked_mut(slice) }\n     }"}, {"sha": "47661a3d38429ee549daa9e07154e00291304e36", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2662,7 +2662,6 @@ impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n /// as required by the `core::borrow::Borrow` implementation.\n ///\n /// ```\n-/// #![feature(build_hasher_simple_hash_one)]\n /// use std::hash::BuildHasher;\n ///\n /// let b = std::collections::hash_map::RandomState::new();"}, {"sha": "c582111701a998b70618ce5e48151cf0ea482d5b", "filename": "library/core/src/alloc/global.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fglobal.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -235,7 +235,8 @@ pub unsafe trait GlobalAlloc {\n     /// * `new_size` must be greater than zero.\n     ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n+    ///   must not overflow isize (i.e., the rounded value must be less than or\n+    ///   equal to `isize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n     /// behavior, e.g., guarantee a sentinel address or a null pointer"}, {"sha": "7969f4055dd2bbc8810cb85a4a1f505758489a80", "filename": "library/core/src/any.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -662,12 +662,20 @@ impl dyn Any + Send + Sync {\n /// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n /// noting that the hashes and ordering will vary between Rust releases. Beware\n /// of relying on them inside of your code!\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, Hash, Eq, PartialOrd, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialEq for TypeId {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.t == other.t\n+    }\n+}\n+\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with."}, {"sha": "fec92320a4b5e6de863ea062e486c3f1e0d62668", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -204,6 +204,7 @@ where\n {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n         <&Self>::try_from(slice).map(|r| *r)\n     }\n@@ -228,6 +229,7 @@ where\n {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &mut [T]) -> Result<[T; N], TryFromSliceError> {\n         <Self>::try_from(&*slice)\n     }\n@@ -249,6 +251,7 @@ where\n impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &'a [T]) -> Result<&'a [T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_ptr() as *const [T; N];\n@@ -276,6 +279,7 @@ impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N] {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &'a mut [T]) -> Result<&'a mut [T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_mut_ptr() as *mut [T; N];\n@@ -291,7 +295,6 @@ impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N] {\n /// as required by the `Borrow` implementation.\n ///\n /// ```\n-/// #![feature(build_hasher_simple_hash_one)]\n /// use std::hash::BuildHasher;\n ///\n /// let b = std::collections::hash_map::RandomState::new();"}, {"sha": "ca7c0772de86e0beb5b7ffa74fdff25ac840ce65", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -674,8 +674,6 @@ pub trait BuildHasher {\n     /// # Example\n     ///\n     /// ```\n-    /// #![feature(build_hasher_simple_hash_one)]\n-    ///\n     /// use std::cmp::{max, min};\n     /// use std::hash::{BuildHasher, Hash, Hasher};\n     /// struct OrderAmbivalentPair<T: Ord>(T, T);\n@@ -697,7 +695,7 @@ pub trait BuildHasher {\n     ///     bh.hash_one(&OrderAmbivalentPair(2, 10))\n     /// );\n     /// ```\n-    #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n+    #[stable(feature = \"build_hasher_simple_hash_one\", since = \"CURRENT_RUSTC_VERSION\")]\n     fn hash_one<T: Hash>(&self, x: T) -> u64\n     where\n         Self: Sized,"}, {"sha": "c4134dbcd2507681cb22645b9c3a8e7054b25482", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1427,7 +1427,7 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     #[rustc_diagnostic_item = \"assert_macro\"]\n-    #[allow_internal_unstable(core_panic, edition_panic)]\n+    #[allow_internal_unstable(core_panic, edition_panic, generic_assert_internals)]\n     macro_rules! assert {\n         ($cond:expr $(,)?) => {{ /* compiler built-in */ }};\n         ($cond:expr, $($arg:tt)+) => {{ /* compiler built-in */ }};"}, {"sha": "1f19555522974614173ff43bdd395f8625b21985", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3005,8 +3005,9 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n-    /// used for [`sort_unstable`].\n+    /// The current algorithm is an introselect implementation based on Pattern Defeating Quicksort, which is also\n+    /// the basis for [`sort_unstable`]. The fallback algorithm is Median of Medians using Tukey's Ninther for\n+    /// pivot selection, which guarantees linear runtime for all inputs.\n     ///\n     /// [`sort_unstable`]: slice::sort_unstable\n     ///\n@@ -3056,8 +3057,9 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n-    /// used for [`sort_unstable`].\n+    /// The current algorithm is an introselect implementation based on Pattern Defeating Quicksort, which is also\n+    /// the basis for [`sort_unstable`]. The fallback algorithm is Median of Medians using Tukey's Ninther for\n+    /// pivot selection, which guarantees linear runtime for all inputs.\n     ///\n     /// [`sort_unstable`]: slice::sort_unstable\n     ///"}, {"sha": "a6a370409c0e23425fd04e253203dc1f61d59cc9", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -298,8 +298,18 @@ pub mod panic_count {\n \n     pub const ALWAYS_ABORT_FLAG: usize = 1 << (usize::BITS - 1);\n \n-    // Panic count for the current thread.\n-    thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = const { Cell::new(0) } }\n+    /// A reason for forcing an immediate abort on panic.\n+    #[derive(Debug)]\n+    pub enum MustAbort {\n+        AlwaysAbort,\n+        PanicInHook,\n+    }\n+\n+    // Panic count for the current thread and whether a panic hook is currently\n+    // being executed..\n+    thread_local! {\n+        static LOCAL_PANIC_COUNT: Cell<(usize, bool)> = const { Cell::new((0, false)) }\n+    }\n \n     // Sum of panic counts from all threads. The purpose of this is to have\n     // a fast path in `count_is_zero` (which is used by `panicking`). In any particular\n@@ -328,34 +338,39 @@ pub mod panic_count {\n     // panicking thread consumes at least 2 bytes of address space.\n     static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n-    // Return the state of the ALWAYS_ABORT_FLAG and number of panics.\n+    // Increases the global and local panic count, and returns whether an\n+    // immediate abort is required.\n     //\n-    // If ALWAYS_ABORT_FLAG is not set, the number is determined on a per-thread\n-    // base (stored in LOCAL_PANIC_COUNT), i.e. it is the amount of recursive calls\n-    // of the calling thread.\n-    // If ALWAYS_ABORT_FLAG is set, the number equals the *global* number of panic\n-    // calls. See above why LOCAL_PANIC_COUNT is not used.\n-    pub fn increase() -> (bool, usize) {\n+    // This also updates thread-local state to keep track of whether a panic\n+    // hook is currently executing.\n+    pub fn increase(run_panic_hook: bool) -> Option<MustAbort> {\n         let global_count = GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n-        let must_abort = global_count & ALWAYS_ABORT_FLAG != 0;\n-        let panics = if must_abort {\n-            global_count & !ALWAYS_ABORT_FLAG\n-        } else {\n-            LOCAL_PANIC_COUNT.with(|c| {\n-                let next = c.get() + 1;\n-                c.set(next);\n-                next\n-            })\n-        };\n-        (must_abort, panics)\n+        if global_count & ALWAYS_ABORT_FLAG != 0 {\n+            return Some(MustAbort::AlwaysAbort);\n+        }\n+\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let (count, in_panic_hook) = c.get();\n+            if in_panic_hook {\n+                return Some(MustAbort::PanicInHook);\n+            }\n+            c.set((count + 1, run_panic_hook));\n+            None\n+        })\n+    }\n+\n+    pub fn finished_panic_hook() {\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let (count, _) = c.get();\n+            c.set((count, false));\n+        });\n     }\n \n     pub fn decrease() {\n         GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n         LOCAL_PANIC_COUNT.with(|c| {\n-            let next = c.get() - 1;\n-            c.set(next);\n-            next\n+            let (count, _) = c.get();\n+            c.set((count - 1, false));\n         });\n     }\n \n@@ -366,7 +381,7 @@ pub mod panic_count {\n     // Disregards ALWAYS_ABORT_FLAG\n     #[must_use]\n     pub fn get_count() -> usize {\n-        LOCAL_PANIC_COUNT.with(|c| c.get())\n+        LOCAL_PANIC_COUNT.with(|c| c.get().0)\n     }\n \n     // Disregards ALWAYS_ABORT_FLAG\n@@ -394,7 +409,7 @@ pub mod panic_count {\n     #[inline(never)]\n     #[cold]\n     fn is_zero_slow_path() -> bool {\n-        LOCAL_PANIC_COUNT.with(|c| c.get() == 0)\n+        LOCAL_PANIC_COUNT.with(|c| c.get().0 == 0)\n     }\n }\n \n@@ -655,23 +670,22 @@ fn rust_panic_with_hook(\n     location: &Location<'_>,\n     can_unwind: bool,\n ) -> ! {\n-    let (must_abort, panics) = panic_count::increase();\n-\n-    // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n-    // the panic hook probably triggered the last panic, otherwise the\n-    // double-panic check would have aborted the process. In this case abort the\n-    // process real quickly as we don't want to try calling it again as it'll\n-    // probably just panic again.\n-    if must_abort || panics > 2 {\n-        if panics > 2 {\n-            // Don't try to print the message in this case\n-            // - perhaps that is causing the recursive panics.\n-            rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n-        } else {\n-            // Unfortunately, this does not print a backtrace, because creating\n-            // a `Backtrace` will allocate, which we must to avoid here.\n-            let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n-            rtprintpanic!(\"{panicinfo}\\npanicked after panic::always_abort(), aborting.\\n\");\n+    let must_abort = panic_count::increase(true);\n+\n+    // Check if we need to abort immediately.\n+    if let Some(must_abort) = must_abort {\n+        match must_abort {\n+            panic_count::MustAbort::PanicInHook => {\n+                // Don't try to print the message in this case\n+                // - perhaps that is causing the recursive panics.\n+                rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n+            }\n+            panic_count::MustAbort::AlwaysAbort => {\n+                // Unfortunately, this does not print a backtrace, because creating\n+                // a `Backtrace` will allocate, which we must to avoid here.\n+                let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n+                rtprintpanic!(\"{panicinfo}\\npanicked after panic::always_abort(), aborting.\\n\");\n+            }\n         }\n         crate::sys::abort_internal();\n     }\n@@ -697,16 +711,16 @@ fn rust_panic_with_hook(\n     };\n     drop(hook);\n \n-    if panics > 1 || !can_unwind {\n-        // If a thread panics while it's already unwinding then we\n-        // have limited options. Currently our preference is to\n-        // just abort. In the future we may consider resuming\n-        // unwinding or otherwise exiting the thread cleanly.\n-        if !can_unwind {\n-            rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n-        } else {\n-            rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n-        }\n+    // Indicate that we have finished executing the panic hook. After this point\n+    // it is fine if there is a panic while executing destructors, as long as it\n+    // it contained within a `catch_unwind`.\n+    panic_count::finished_panic_hook();\n+\n+    if !can_unwind {\n+        // If a thread panics while running destructors or tries to unwind\n+        // through a nounwind function (e.g. extern \"C\") then we cannot continue\n+        // unwinding and have to abort immediately.\n+        rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n         crate::sys::abort_internal();\n     }\n \n@@ -716,7 +730,7 @@ fn rust_panic_with_hook(\n /// This is the entry point for `resume_unwind`.\n /// It just forwards the payload to the panic runtime.\n pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n-    panic_count::increase();\n+    panic_count::increase(false);\n \n     struct RewrapBox(Box<dyn Any + Send>);\n "}, {"sha": "3eaad59474a12a9e27f547d895fc15cb39fa6842", "filename": "library/test/src/options.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Ftest%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/library%2Ftest%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Foptions.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -16,19 +16,21 @@ pub enum ShouldPanic {\n }\n \n /// Whether should console output be colored or not\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Default, Debug)]\n pub enum ColorConfig {\n+    #[default]\n     AutoColor,\n     AlwaysColor,\n     NeverColor,\n }\n \n /// Format of the test results output\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n pub enum OutputFormat {\n     /// Verbose output\n     Pretty,\n     /// Quiet output\n+    #[default]\n     Terse,\n     /// JSON output\n     Json,"}, {"sha": "311ac1751606e4ffec4e2543b27fdffac44958fb", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -58,7 +58,6 @@ dependencies = [\n  \"once_cell\",\n  \"opener\",\n  \"pretty_assertions\",\n- \"semver\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n@@ -646,12 +645,6 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n-[[package]]\n-name = \"semver\"\n-version = \"1.0.17\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed\"\n-\n [[package]]\n name = \"serde\"\n version = \"1.0.160\""}, {"sha": "70ade776d7da77c0bb5db5108aab2fe66628d2cd", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -57,7 +57,6 @@ walkdir = \"2\"\n sysinfo = { version = \"0.26.0\", optional = true }\n clap = { version = \"4.2.4\", default-features = false, features = [\"std\", \"usage\", \"help\", \"derive\", \"error-context\"] }\n clap_complete = \"4.2.2\"\n-semver = \"1.0.17\"\n \n # Solaris doesn't support flock() and thus fd-lock is not option now\n [target.'cfg(not(target_os = \"solaris\"))'.dependencies]"}, {"sha": "58d1926ad96223f860abe30b4348b0e0b9042352", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 44, "deletions": 49, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -226,16 +226,13 @@ def format_build_time(duration):\n \n def default_build_triple(verbose):\n     \"\"\"Build triple as in LLVM\"\"\"\n-    # If the user already has a host build triple with an existing `rustc`\n-    # install, use their preference. This fixes most issues with Windows builds\n-    # being detected as GNU instead of MSVC.\n+    # If we're on Windows and have an existing `rustc` toolchain, use `rustc --version --verbose`\n+    # to find our host target triple. This fixes an issue with Windows builds being detected\n+    # as GNU instead of MSVC.\n+    # Otherwise, detect it via `uname`\n     default_encoding = sys.getdefaultencoding()\n \n-    if sys.platform == 'darwin':\n-        if verbose:\n-            print(\"not using rustc detection as it is unreliable on macOS\", file=sys.stderr)\n-            print(\"falling back to auto-detect\", file=sys.stderr)\n-    else:\n+    if platform_is_win32():\n         try:\n             version = subprocess.check_output([\"rustc\", \"--version\", \"--verbose\"],\n                     stderr=subprocess.DEVNULL)\n@@ -253,19 +250,17 @@ def default_build_triple(verbose):\n                 print(\"falling back to auto-detect\", file=sys.stderr)\n \n     required = not platform_is_win32()\n-    ostype = require([\"uname\", \"-s\"], exit=required)\n-    cputype = require(['uname', '-m'], exit=required)\n+    uname = require([\"uname\", \"-smp\"], exit=required)\n \n     # If we do not have `uname`, assume Windows.\n-    if ostype is None or cputype is None:\n+    if uname is None:\n         return 'x86_64-pc-windows-msvc'\n \n-    ostype = ostype.decode(default_encoding)\n-    cputype = cputype.decode(default_encoding)\n+    kernel, cputype, processor = uname.decode(default_encoding).split()\n \n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n-    ostype_mapper = {\n+    kerneltype_mapper = {\n         'Darwin': 'apple-darwin',\n         'DragonFly': 'unknown-dragonfly',\n         'FreeBSD': 'unknown-freebsd',\n@@ -275,17 +270,18 @@ def default_build_triple(verbose):\n     }\n \n     # Consider the direct transformation first and then the special cases\n-    if ostype in ostype_mapper:\n-        ostype = ostype_mapper[ostype]\n-    elif ostype == 'Linux':\n-        os_from_sp = subprocess.check_output(\n-            ['uname', '-o']).strip().decode(default_encoding)\n-        if os_from_sp == 'Android':\n-            ostype = 'linux-android'\n+    if kernel in kerneltype_mapper:\n+        kernel = kerneltype_mapper[kernel]\n+    elif kernel == 'Linux':\n+        # Apple doesn't support `-o` so this can't be used in the combined\n+        # uname invocation above\n+        ostype = require([\"uname\", \"-o\"], exit=required).decode(default_encoding)\n+        if ostype == 'Android':\n+            kernel = 'linux-android'\n         else:\n-            ostype = 'unknown-linux-gnu'\n-    elif ostype == 'SunOS':\n-        ostype = 'pc-solaris'\n+            kernel = 'unknown-linux-gnu'\n+    elif kernel == 'SunOS':\n+        kernel = 'pc-solaris'\n         # On Solaris, uname -m will return a machine classification instead\n         # of a cpu type, so uname -p is recommended instead.  However, the\n         # output from that option is too generic for our purposes (it will\n@@ -294,34 +290,34 @@ def default_build_triple(verbose):\n         cputype = require(['isainfo', '-k']).decode(default_encoding)\n         # sparc cpus have sun as a target vendor\n         if 'sparc' in cputype:\n-            ostype = 'sun-solaris'\n-    elif ostype.startswith('MINGW'):\n+            kernel = 'sun-solaris'\n+    elif kernel.startswith('MINGW'):\n         # msys' `uname` does not print gcc configuration, but prints msys\n         # configuration. so we cannot believe `uname -m`:\n         # msys1 is always i686 and msys2 is always x86_64.\n         # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n         # MINGW64 on x86_64.\n-        ostype = 'pc-windows-gnu'\n+        kernel = 'pc-windows-gnu'\n         cputype = 'i686'\n         if os.environ.get('MSYSTEM') == 'MINGW64':\n             cputype = 'x86_64'\n-    elif ostype.startswith('MSYS'):\n-        ostype = 'pc-windows-gnu'\n-    elif ostype.startswith('CYGWIN_NT'):\n+    elif kernel.startswith('MSYS'):\n+        kernel = 'pc-windows-gnu'\n+    elif kernel.startswith('CYGWIN_NT'):\n         cputype = 'i686'\n-        if ostype.endswith('WOW64'):\n+        if kernel.endswith('WOW64'):\n             cputype = 'x86_64'\n-        ostype = 'pc-windows-gnu'\n-    elif sys.platform == 'win32':\n+        kernel = 'pc-windows-gnu'\n+    elif platform_is_win32():\n         # Some Windows platforms might have a `uname` command that returns a\n         # non-standard string (e.g. gnuwin32 tools returns `windows32`). In\n         # these cases, fall back to using sys.platform.\n         return 'x86_64-pc-windows-msvc'\n     else:\n-        err = \"unknown OS type: {}\".format(ostype)\n+        err = \"unknown OS type: {}\".format(kernel)\n         sys.exit(err)\n \n-    if cputype in ['powerpc', 'riscv'] and ostype == 'unknown-freebsd':\n+    if cputype in ['powerpc', 'riscv'] and kernel == 'unknown-freebsd':\n         cputype = subprocess.check_output(\n               ['uname', '-p']).strip().decode(default_encoding)\n     cputype_mapper = {\n@@ -354,24 +350,23 @@ def default_build_triple(verbose):\n         cputype = cputype_mapper[cputype]\n     elif cputype in {'xscale', 'arm'}:\n         cputype = 'arm'\n-        if ostype == 'linux-android':\n-            ostype = 'linux-androideabi'\n-        elif ostype == 'unknown-freebsd':\n-            cputype = subprocess.check_output(\n-                ['uname', '-p']).strip().decode(default_encoding)\n-            ostype = 'unknown-freebsd'\n+        if kernel == 'linux-android':\n+            kernel = 'linux-androideabi'\n+        elif kernel == 'unknown-freebsd':\n+            cputype = processor\n+            kernel = 'unknown-freebsd'\n     elif cputype == 'armv6l':\n         cputype = 'arm'\n-        if ostype == 'linux-android':\n-            ostype = 'linux-androideabi'\n+        if kernel == 'linux-android':\n+            kernel = 'linux-androideabi'\n         else:\n-            ostype += 'eabihf'\n+            kernel += 'eabihf'\n     elif cputype in {'armv7l', 'armv8l'}:\n         cputype = 'armv7'\n-        if ostype == 'linux-android':\n-            ostype = 'linux-androideabi'\n+        if kernel == 'linux-android':\n+            kernel = 'linux-androideabi'\n         else:\n-            ostype += 'eabihf'\n+            kernel += 'eabihf'\n     elif cputype == 'mips':\n         if sys.byteorder == 'big':\n             cputype = 'mips'\n@@ -387,14 +382,14 @@ def default_build_triple(verbose):\n         else:\n             raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n         # only the n64 ABI is supported, indicate it\n-        ostype += 'abi64'\n+        kernel += 'abi64'\n     elif cputype == 'sparc' or cputype == 'sparcv9' or cputype == 'sparc64':\n         pass\n     else:\n         err = \"unknown cpu type: {}\".format(cputype)\n         sys.exit(err)\n \n-    return \"{}-{}\".format(cputype, ostype)\n+    return \"{}-{}\".format(cputype, kernel)\n \n \n @contextlib.contextmanager"}, {"sha": "2fa445506bc4a913a88ee57ce340b8a5b3c1e5b6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -264,7 +264,7 @@ impl PathSet {\n \n     /// A convenience wrapper for Steps which know they have no aliases and all their sets contain only a single path.\n     ///\n-    /// This can be used with [`ShouldRun::krate`], [`ShouldRun::path`], or [`ShouldRun::alias`].\n+    /// This can be used with [`ShouldRun::crate_or_deps`], [`ShouldRun::path`], or [`ShouldRun::alias`].\n     #[track_caller]\n     pub fn assert_single_path(&self) -> &TaskPath {\n         match self {\n@@ -689,7 +689,8 @@ impl<'a> Builder<'a> {\n                 tool::Miri,\n                 tool::CargoMiri,\n                 llvm::Lld,\n-                llvm::CrtBeginEnd\n+                llvm::CrtBeginEnd,\n+                tool::RustdocGUITest,\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n@@ -787,6 +788,7 @@ impl<'a> Builder<'a> {\n                 doc::EditionGuide,\n                 doc::StyleGuide,\n                 doc::Tidy,\n+                doc::Bootstrap,\n             ),\n             Kind::Dist => describe!(\n                 dist::Docs,\n@@ -1915,10 +1917,10 @@ impl<'a> Builder<'a> {\n         }\n \n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n-        // This replaces spaces with newlines because RUSTDOCFLAGS does not\n+        // This replaces spaces with tabs because RUSTDOCFLAGS does not\n         // support arguments with regular spaces. Hopefully someday Cargo will\n         // have space support.\n-        let rust_version = self.rust_version().replace(' ', \"\\n\");\n+        let rust_version = self.rust_version().replace(' ', \"\\t\");\n         rustdocflags.arg(\"--crate-version\").arg(&rust_version);\n \n         // Environment variables *required* throughout the build"}, {"sha": "41aca0210f677d07d960e1e507fbcf789ae8762f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -24,7 +24,6 @@ pub use crate::flags::Subcommand;\n use crate::flags::{Color, Flags, Warnings};\n use crate::util::{exe, output, t};\n use once_cell::sync::OnceCell;\n-use semver::Version;\n use serde::{Deserialize, Deserializer};\n use serde_derive::Deserialize;\n \n@@ -1118,7 +1117,6 @@ impl Config {\n             config.download_beta_toolchain();\n             config.out.join(config.build.triple).join(\"stage0/bin/rustc\")\n         });\n-\n         config.initial_cargo = build\n             .cargo\n             .map(|cargo| {\n@@ -1780,42 +1778,6 @@ impl Config {\n         self.rust_codegen_backends.get(0).cloned()\n     }\n \n-    pub fn check_build_rustc_version(&self) {\n-        if self.dry_run() {\n-            return;\n-        }\n-\n-        // check rustc version is same or lower with 1 apart from the building one\n-        let mut cmd = Command::new(&self.initial_rustc);\n-        cmd.arg(\"--version\");\n-        let rustc_output = output(&mut cmd)\n-            .lines()\n-            .next()\n-            .unwrap()\n-            .split(' ')\n-            .nth(1)\n-            .unwrap()\n-            .split('-')\n-            .next()\n-            .unwrap()\n-            .to_owned();\n-        let rustc_version = Version::parse(&rustc_output.trim()).unwrap();\n-        let source_version =\n-            Version::parse(&fs::read_to_string(self.src.join(\"src/version\")).unwrap().trim())\n-                .unwrap();\n-        if !(source_version == rustc_version\n-            || (source_version.major == rustc_version.major\n-                && source_version.minor == rustc_version.minor + 1))\n-        {\n-            let prev_version = format!(\"{}.{}.x\", source_version.major, source_version.minor - 1);\n-            eprintln!(\n-                \"Unexpected rustc version: {}, we should use {}/{} to build source with {}\",\n-                rustc_version, prev_version, source_version, source_version\n-            );\n-            crate::detail_exit(1);\n-        }\n-    }\n-\n     /// Returns the commit to download, or `None` if we shouldn't download CI artifacts.\n     fn download_ci_rustc_commit(&self, download_rustc: Option<StringOrBool>) -> Option<String> {\n         // If `download-rustc` is not set, default to rebuilding."}, {"sha": "b52c3b68cc4ff3d8d4555e2669d8c38fdf4a87a3", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -839,6 +839,8 @@ macro_rules! tool_doc {\n                 )+\n \n                 cargo.rustdocflag(\"--document-private-items\");\n+                // Since we always pass --document-private-items, there's no need to warn about linking to private items.\n+                cargo.rustdocflag(\"-Arustdoc::private-intra-doc-links\");\n                 cargo.rustdocflag(\"--enable-index-page\");\n                 cargo.rustdocflag(\"--show-type-layout\");\n                 cargo.rustdocflag(\"--generate-link-to-definition\");\n@@ -882,7 +884,8 @@ tool_doc!(\n         // \"cargo-credential-wincred\",\n     ]\n );\n-tool_doc!(Tidy, \"tidy\", \"src/tools/tidy\", [\"tidy\"]);\n+tool_doc!(Tidy, \"tidy\", \"src/tools/tidy\", rustc_tool = false, [\"tidy\"]);\n+tool_doc!(Bootstrap, \"bootstrap\", \"src/bootstrap\", rustc_tool = false, [\"bootstrap\"]);\n \n #[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {"}, {"sha": "c7969d2a2c7bed1e1b635c2b07d3f61deab9c446", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -123,7 +123,7 @@ impl Config {\n     /// This is only required on NixOS and uses the PatchELF utility to\n     /// change the interpreter/RPATH of ELF executables.\n     ///\n-    /// Please see https://nixos.org/patchelf.html for more information\n+    /// Please see <https://nixos.org/patchelf.html> for more information\n     fn fix_bin_or_dylib(&self, fname: &Path) {\n         assert_eq!(SHOULD_FIX_BINS_AND_DYLIBS.get(), Some(&true));\n         println!(\"attempting to patch {}\", fname.display());"}, {"sha": "fb76dffd071568f2ddeec34f2f260dcb1038f830", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -414,7 +414,6 @@ impl Build {\n                 bootstrap_out.display()\n             )\n         }\n-        config.check_build_rustc_version();\n \n         if rust_info.is_from_tarball() && config.description.is_none() {\n             config.description = Some(\"built from a source tarball\".to_owned());\n@@ -1011,6 +1010,8 @@ impl Build {\n     }\n \n     /// Return a `Group` guard for a [`Step`] that is built for each `--stage`.\n+    ///\n+    /// [`Step`]: crate::builder::Step\n     fn msg(\n         &self,\n         action: impl Into<Kind>,\n@@ -1035,6 +1036,8 @@ impl Build {\n     }\n \n     /// Return a `Group` guard for a [`Step`] that is only built once and isn't affected by `--stage`.\n+    ///\n+    /// [`Step`]: crate::builder::Step\n     fn msg_unstaged(\n         &self,\n         action: impl Into<Kind>,"}, {"sha": "3fd0cca40e522f354fd4c412c015acc11dbae298", "filename": "src/bootstrap/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fllvm.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1017,7 +1017,7 @@ fn supported_sanitizers(\n         \"x86_64-unknown-illumos\" => common_libs(\"illumos\", \"x86_64\", &[\"asan\"]),\n         \"x86_64-pc-solaris\" => common_libs(\"solaris\", \"x86_64\", &[\"asan\"]),\n         \"x86_64-unknown-linux-gnu\" => {\n-            common_libs(\"linux\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n+            common_libs(\"linux\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"safestack\", \"tsan\"])\n         }\n         \"x86_64-unknown-linux-musl\" => {\n             common_libs(\"linux\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])"}, {"sha": "5990f33b9bc6c87d18359c9288e0b0342653fe3a", "filename": "src/bootstrap/metrics.rs", "status": "modified", "additions": 95, "deletions": 24, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetrics.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -14,6 +14,25 @@ use std::io::BufWriter;\n use std::time::{Duration, Instant, SystemTime};\n use sysinfo::{CpuExt, System, SystemExt};\n \n+// Update this number whenever a breaking change is made to the build metrics.\n+//\n+// The output format is versioned for two reasons:\n+//\n+// - The metadata is intended to be consumed by external tooling, and exposing a format version\n+//   helps the tools determine whether they're compatible with a metrics file.\n+//\n+// - If a developer enables build metrics in their local checkout, making a breaking change to the\n+//   metrics format would result in a hard-to-diagnose error message when an existing metrics file\n+//   is not compatible with the new changes. With a format version number, bootstrap can discard\n+//   incompatible metrics files instead of appending metrics to them.\n+//\n+// Version changelog:\n+//\n+// - v0: initial version\n+// - v1: replaced JsonNode::Test with JsonNode::TestSuite\n+//\n+const CURRENT_FORMAT_VERSION: usize = 1;\n+\n pub(crate) struct BuildMetrics {\n     state: RefCell<MetricsState>,\n }\n@@ -57,7 +76,7 @@ impl BuildMetrics {\n             duration_excluding_children_sec: Duration::ZERO,\n \n             children: Vec::new(),\n-            tests: Vec::new(),\n+            test_suites: Vec::new(),\n         });\n     }\n \n@@ -84,19 +103,31 @@ impl BuildMetrics {\n         }\n     }\n \n+    pub(crate) fn begin_test_suite(&self, metadata: TestSuiteMetadata, builder: &Builder<'_>) {\n+        // Do not record dry runs, as they'd be duplicates of the actual steps.\n+        if builder.config.dry_run() {\n+            return;\n+        }\n+\n+        let mut state = self.state.borrow_mut();\n+        let step = state.running_steps.last_mut().unwrap();\n+        step.test_suites.push(TestSuite { metadata, tests: Vec::new() });\n+    }\n+\n     pub(crate) fn record_test(&self, name: &str, outcome: TestOutcome, builder: &Builder<'_>) {\n         // Do not record dry runs, as they'd be duplicates of the actual steps.\n         if builder.config.dry_run() {\n             return;\n         }\n \n         let mut state = self.state.borrow_mut();\n-        state\n-            .running_steps\n-            .last_mut()\n-            .unwrap()\n-            .tests\n-            .push(Test { name: name.to_string(), outcome });\n+        let step = state.running_steps.last_mut().unwrap();\n+\n+        if let Some(test_suite) = step.test_suites.last_mut() {\n+            test_suite.tests.push(Test { name: name.to_string(), outcome });\n+        } else {\n+            panic!(\"metrics.record_test() called without calling metrics.begin_test_suite() first\");\n+        }\n     }\n \n     fn collect_stats(&self, state: &mut MetricsState) {\n@@ -131,7 +162,20 @@ impl BuildMetrics {\n         // Some of our CI builds consist of multiple independent CI invocations. Ensure all the\n         // previous invocations are still present in the resulting file.\n         let mut invocations = match std::fs::read(&dest) {\n-            Ok(contents) => t!(serde_json::from_slice::<JsonRoot>(&contents)).invocations,\n+            Ok(contents) => {\n+                // We first parse just the format_version field to have the check succeed even if\n+                // the rest of the contents are not valid anymore.\n+                let version: OnlyFormatVersion = t!(serde_json::from_slice(&contents));\n+                if version.format_version == CURRENT_FORMAT_VERSION {\n+                    t!(serde_json::from_slice::<JsonRoot>(&contents)).invocations\n+                } else {\n+                    println!(\n+                        \"warning: overriding existing build/metrics.json, as it's not \\\n+                         compatible with build metrics format version {CURRENT_FORMAT_VERSION}.\"\n+                    );\n+                    Vec::new()\n+                }\n+            }\n             Err(err) => {\n                 if err.kind() != std::io::ErrorKind::NotFound {\n                     panic!(\"failed to open existing metrics file at {}: {err}\", dest.display());\n@@ -149,7 +193,7 @@ impl BuildMetrics {\n             children: steps.into_iter().map(|step| self.prepare_json_step(step)).collect(),\n         });\n \n-        let json = JsonRoot { system_stats, invocations };\n+        let json = JsonRoot { format_version: CURRENT_FORMAT_VERSION, system_stats, invocations };\n \n         t!(std::fs::create_dir_all(dest.parent().unwrap()));\n         let mut file = BufWriter::new(t!(File::create(&dest)));\n@@ -159,11 +203,7 @@ impl BuildMetrics {\n     fn prepare_json_step(&self, step: StepMetrics) -> JsonNode {\n         let mut children = Vec::new();\n         children.extend(step.children.into_iter().map(|child| self.prepare_json_step(child)));\n-        children.extend(\n-            step.tests\n-                .into_iter()\n-                .map(|test| JsonNode::Test { name: test.name, outcome: test.outcome }),\n-        );\n+        children.extend(step.test_suites.into_iter().map(JsonNode::TestSuite));\n \n         JsonNode::RustbuildStep {\n             type_: step.type_,\n@@ -198,17 +238,14 @@ struct StepMetrics {\n     duration_excluding_children_sec: Duration,\n \n     children: Vec<StepMetrics>,\n-    tests: Vec<Test>,\n-}\n-\n-struct Test {\n-    name: String,\n-    outcome: TestOutcome,\n+    test_suites: Vec<TestSuite>,\n }\n \n #[derive(Serialize, Deserialize)]\n #[serde(rename_all = \"snake_case\")]\n struct JsonRoot {\n+    #[serde(default)] // For version 0 the field was not present.\n+    format_version: usize,\n     system_stats: JsonInvocationSystemStats,\n     invocations: Vec<JsonInvocation>,\n }\n@@ -237,13 +274,41 @@ enum JsonNode {\n \n         children: Vec<JsonNode>,\n     },\n-    Test {\n-        name: String,\n-        #[serde(flatten)]\n-        outcome: TestOutcome,\n+    TestSuite(TestSuite),\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct TestSuite {\n+    metadata: TestSuiteMetadata,\n+    tests: Vec<Test>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(tag = \"kind\", rename_all = \"snake_case\")]\n+pub(crate) enum TestSuiteMetadata {\n+    CargoPackage {\n+        crates: Vec<String>,\n+        target: String,\n+        host: String,\n+        stage: u32,\n+    },\n+    Compiletest {\n+        suite: String,\n+        mode: String,\n+        compare_mode: Option<String>,\n+        target: String,\n+        host: String,\n+        stage: u32,\n     },\n }\n \n+#[derive(Serialize, Deserialize)]\n+pub(crate) struct Test {\n+    name: String,\n+    #[serde(flatten)]\n+    outcome: TestOutcome,\n+}\n+\n #[derive(Serialize, Deserialize)]\n #[serde(tag = \"outcome\", rename_all = \"snake_case\")]\n pub(crate) enum TestOutcome {\n@@ -266,3 +331,9 @@ struct JsonInvocationSystemStats {\n struct JsonStepSystemStats {\n     cpu_utilization_percent: f64,\n }\n+\n+#[derive(Deserialize)]\n+struct OnlyFormatVersion {\n+    #[serde(default)] // For version 0 the field was not present.\n+    format_version: usize,\n+}"}, {"sha": "44cd84be705ab1ed19fbc810ec184f86e079153e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 77, "deletions": 88, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -317,6 +317,17 @@ impl Step for Cargo {\n         cargo.env(\"CARGO_TEST_DISABLE_NIGHTLY\", \"1\");\n         cargo.env(\"PATH\", &path_for_cargo(builder, compiler));\n \n+        #[cfg(feature = \"build-metrics\")]\n+        builder.metrics.begin_test_suite(\n+            crate::metrics::TestSuiteMetadata::CargoPackage {\n+                crates: vec![\"cargo\".into()],\n+                target: self.host.triple.to_string(),\n+                host: self.host.triple.to_string(),\n+                stage: self.stage,\n+            },\n+            builder,\n+        );\n+\n         let _time = util::timeit(&builder);\n         add_flags_and_try_run_tests(builder, &mut cargo);\n     }\n@@ -944,28 +955,6 @@ fn get_browser_ui_test_version(npm: &Path) -> Option<String> {\n         .or_else(|| get_browser_ui_test_version_inner(npm, true))\n }\n \n-fn compare_browser_ui_test_version(installed_version: &str, src: &Path) {\n-    match fs::read_to_string(\n-        src.join(\"src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version\"),\n-    ) {\n-        Ok(v) => {\n-            if v.trim() != installed_version {\n-                eprintln!(\n-                    \"\u26a0\ufe0f Installed version of browser-ui-test (`{}`) is different than the \\\n-                     one used in the CI (`{}`)\",\n-                    installed_version, v\n-                );\n-                eprintln!(\n-                    \"You can install this version using `npm update browser-ui-test` or by using \\\n-                     `npm install browser-ui-test@{}`\",\n-                    v,\n-                );\n-            }\n-        }\n-        Err(e) => eprintln!(\"Couldn't find the CI browser-ui-test version: {:?}\", e),\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocGUI {\n     pub target: TargetSelection,\n@@ -997,94 +986,56 @@ impl Step for RustdocGUI {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let nodejs = builder.config.nodejs.as_ref().expect(\"nodejs isn't available\");\n-        let npm = builder.config.npm.as_ref().expect(\"npm isn't available\");\n-\n         builder.ensure(compile::Std::new(self.compiler, self.target));\n \n-        // The goal here is to check if the necessary packages are installed, and if not, we\n-        // panic.\n-        match get_browser_ui_test_version(&npm) {\n-            Some(version) => {\n-                // We also check the version currently used in CI and emit a warning if it's not the\n-                // same one.\n-                compare_browser_ui_test_version(&version, &builder.build.src);\n-            }\n-            None => {\n-                eprintln!(\n-                    \"error: rustdoc-gui test suite cannot be run because npm `browser-ui-test` \\\n-                     dependency is missing\",\n-                );\n-                eprintln!(\n-                    \"If you want to install the `{0}` dependency, run `npm install {0}`\",\n-                    \"browser-ui-test\",\n-                );\n-                panic!(\"Cannot run rustdoc-gui tests\");\n-            }\n-        }\n+        let mut cmd = builder.tool_cmd(Tool::RustdocGUITest);\n \n         let out_dir = builder.test_out(self.target).join(\"rustdoc-gui\");\n-\n-        // We remove existing folder to be sure there won't be artifacts remaining.\n         builder.clear_if_dirty(&out_dir, &builder.rustdoc(self.compiler));\n \n-        let src_path = builder.build.src.join(\"tests/rustdoc-gui/src\");\n-        // We generate docs for the libraries present in the rustdoc-gui's src folder.\n-        for entry in src_path.read_dir().expect(\"read_dir call failed\") {\n-            if let Ok(entry) = entry {\n-                let path = entry.path();\n+        if let Some(src) = builder.config.src.to_str() {\n+            cmd.arg(\"--rust-src\").arg(src);\n+        }\n \n-                if !path.is_dir() {\n-                    continue;\n-                }\n+        if let Some(out_dir) = out_dir.to_str() {\n+            cmd.arg(\"--out-dir\").arg(out_dir);\n+        }\n \n-                let mut cargo = Command::new(&builder.initial_cargo);\n-                cargo\n-                    .arg(\"doc\")\n-                    .arg(\"--target-dir\")\n-                    .arg(&out_dir)\n-                    .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-                    .env(\"RUSTDOC\", builder.rustdoc(self.compiler))\n-                    .env(\"RUSTC\", builder.rustc(self.compiler))\n-                    .current_dir(path);\n-                // FIXME: implement a `// compile-flags` command or similar\n-                //        instead of hard-coding this test\n-                if entry.file_name() == \"link_to_definition\" {\n-                    cargo.env(\"RUSTDOCFLAGS\", \"-Zunstable-options --generate-link-to-definition\");\n-                } else if entry.file_name() == \"scrape_examples\" {\n-                    cargo.arg(\"-Zrustdoc-scrape-examples\");\n-                } else if entry.file_name() == \"extend_css\" {\n-                    cargo.env(\"RUSTDOCFLAGS\", &format!(\"--extend-css extra.css\"));\n-                }\n-                builder.run(&mut cargo);\n-            }\n+        if let Some(initial_cargo) = builder.config.initial_cargo.to_str() {\n+            cmd.arg(\"--initial-cargo\").arg(initial_cargo);\n         }\n \n-        // We now run GUI tests.\n-        let mut command = Command::new(&nodejs);\n-        command\n-            .arg(builder.build.src.join(\"src/tools/rustdoc-gui/tester.js\"))\n-            .arg(\"--jobs\")\n-            .arg(&builder.jobs().to_string())\n-            .arg(\"--doc-folder\")\n-            .arg(out_dir.join(\"doc\"))\n-            .arg(\"--tests-folder\")\n-            .arg(builder.build.src.join(\"tests/rustdoc-gui\"));\n+        cmd.arg(\"--jobs\").arg(builder.jobs().to_string());\n+\n+        cmd.env(\"RUSTDOC\", builder.rustdoc(self.compiler))\n+            .env(\"RUSTC\", builder.rustc(self.compiler));\n+\n         for path in &builder.paths {\n             if let Some(p) = util::is_valid_test_suite_arg(path, \"tests/rustdoc-gui\", builder) {\n                 if !p.ends_with(\".goml\") {\n                     eprintln!(\"A non-goml file was given: `{}`\", path.display());\n                     panic!(\"Cannot run rustdoc-gui tests\");\n                 }\n                 if let Some(name) = path.file_name().and_then(|f| f.to_str()) {\n-                    command.arg(\"--file\").arg(name);\n+                    cmd.arg(\"--goml-file\").arg(name);\n                 }\n             }\n         }\n+\n         for test_arg in builder.config.test_args() {\n-            command.arg(test_arg);\n+            cmd.arg(\"--test-arg\").arg(test_arg);\n+        }\n+\n+        if let Some(ref nodejs) = builder.config.nodejs {\n+            cmd.arg(\"--nodejs\").arg(nodejs);\n+        }\n+\n+        if let Some(ref npm) = builder.config.npm {\n+            cmd.arg(\"--npm\").arg(npm);\n         }\n-        builder.run(&mut command);\n+\n+        let _time = util::timeit(&builder);\n+        crate::render_tests::try_run_tests(builder, &mut cmd);\n     }\n }\n \n@@ -1759,6 +1710,19 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n \n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n+        #[cfg(feature = \"build-metrics\")]\n+        builder.metrics.begin_test_suite(\n+            crate::metrics::TestSuiteMetadata::Compiletest {\n+                suite: suite.into(),\n+                mode: mode.into(),\n+                compare_mode: None,\n+                target: self.target.triple.to_string(),\n+                host: self.compiler.host.triple.to_string(),\n+                stage: self.compiler.stage,\n+            },\n+            builder,\n+        );\n+\n         builder.info(&format!(\n             \"Check compiletest suite={} mode={} ({} -> {})\",\n             suite, mode, &compiler.host, target\n@@ -1768,6 +1732,20 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n+\n+            #[cfg(feature = \"build-metrics\")]\n+            builder.metrics.begin_test_suite(\n+                crate::metrics::TestSuiteMetadata::Compiletest {\n+                    suite: suite.into(),\n+                    mode: mode.into(),\n+                    compare_mode: Some(compare_mode.into()),\n+                    target: self.target.triple.to_string(),\n+                    host: self.compiler.host.triple.to_string(),\n+                    stage: self.compiler.stage,\n+                },\n+                builder,\n+            );\n+\n             builder.info(&format!(\n                 \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n                 suite, mode, compare_mode, &compiler.host, target\n@@ -2094,6 +2072,17 @@ fn run_cargo_test(\n     let mut cargo =\n         prepare_cargo_test(cargo, libtest_args, crates, primary_crate, compiler, target, builder);\n     let _time = util::timeit(&builder);\n+\n+    #[cfg(feature = \"build-metrics\")]\n+    builder.metrics.begin_test_suite(\n+        crate::metrics::TestSuiteMetadata::CargoPackage {\n+            crates: crates.iter().map(|c| c.to_string()).collect(),\n+            target: target.triple.to_string(),\n+            host: compiler.host.triple.to_string(),\n+            stage: compiler.stage,\n+        },\n+        builder,\n+    );\n     add_flags_and_try_run_tests(builder, &mut cargo)\n }\n "}, {"sha": "b3791efaf58cfc43a601d1f5e03066eb854a3178", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -302,6 +302,7 @@ bootstrap_tool!(\n     GenerateCopyright, \"src/tools/generate-copyright\", \"generate-copyright\";\n     SuggestTests, \"src/tools/suggest-tests\", \"suggest-tests\";\n     GenerateWindowsSys, \"src/tools/generate-windows-sys\", \"generate-windows-sys\";\n+    RustdocGUITest, \"src/tools/rustdoc-gui-test\", \"rustdoc-gui-test\", is_unstable_tool = true, allow_features = \"test\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "9bfdc77e6b6cc39b50c2f5ab73c11fb4cdeed5ae", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -488,7 +488,7 @@ fn absolute_windows(path: &std::path::Path) -> std::io::Result<std::path::PathBu\n     }\n }\n \n-/// Adapted from https://github.com/llvm/llvm-project/blob/782e91224601e461c019e0a4573bbccc6094fbcd/llvm/cmake/modules/HandleLLVMOptions.cmake#L1058-L1079\n+/// Adapted from <https://github.com/llvm/llvm-project/blob/782e91224601e461c019e0a4573bbccc6094fbcd/llvm/cmake/modules/HandleLLVMOptions.cmake#L1058-L1079>\n ///\n /// When `clang-cl` is used with instrumentation, we need to add clang's runtime library resource\n /// directory to the linker flags, otherwise there will be linker errors about the profiler runtime"}, {"sha": "172048704f48d2ef7e45b0b067713af0f4aa093c", "filename": "src/doc/rustc/src/exploit-mitigations.md", "status": "modified", "additions": 31, "deletions": 88, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -55,88 +55,18 @@ Table I \\\n Summary of exploit mitigations supported by the Rust compiler when building\n programs for the Linux operating system on the AMD64 architecture and\n equivalent.\n-<table class=\"table\">\n-  <tr>\n-   <td><strong>Exploit mitigation</strong>\n-   </td>\n-   <td><strong>Supported and enabled by default</strong>\n-   </td>\n-   <td><strong>Since</strong>\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Position-independent executable\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>0.12.0 (2014-10-09)\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Integer overflow checks\n-   </td>\n-   <td>Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled)\n-   </td>\n-   <td>1.1.0 (2015-06-25)\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Non-executable memory regions\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>1.8.0 (2016-04-14)\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Stack clashing protection\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>1.20.0 (2017-08-31)\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Read-only relocations and immediate binding\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>1.21.0 (2017-10-12)\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Heap corruption protection\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>1.32.0 (2019-01-17) (via operating system default or specified allocator)\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Stack smashing protection\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>Nightly\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Forward-edge control flow protection\n-   </td>\n-   <td>Yes\n-   </td>\n-   <td>Nightly\n-   </td>\n-  </tr>\n-  <tr>\n-   <td>Backward-edge control flow protection (e.g., shadow and safe stack)\n-   </td>\n-   <td>No\n-   </td>\n-   <td>\n-   </td>\n-  </tr>\n-</table>\n+\n+| Exploit mitigation | Supported and enabled by default | Since |\n+| - | - | - |\n+| Position-independent executable | Yes | 0.12.0 (2014-10-09) |\n+| Integer overflow checks | Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled) | 1.1.0 (2015-06-25) |\n+| Non-executable memory regions | Yes | 1.8.0 (2016-04-14) |\n+| Stack clashing protection | Yes | 1.20.0 (2017-08-31) |\n+| Read-only relocations and immediate binding | Yes | 1.21.0 (2017-10-12) |\n+| Heap corruption protection | Yes | 1.32.0 (2019-01-17) (via operating system default or specified allocator) |\n+| Stack smashing protection | Yes | Nightly |\n+| Forward-edge control flow protection | Yes | Nightly |\n+| Backward-edge control flow protection (e.g., shadow and safe stack) | Yes | Nightly |\n \n <small id=\"fn:1\">1\\. See\n <https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec>\n@@ -513,20 +443,21 @@ Newer processors provide hardware assistance for backward-edge control flow\n protection, such as ARM Pointer Authentication, and Intel Shadow Stack as\n part of Intel CET.\n \n-The Rust compiler does not support shadow or safe stack. There is work\n-currently ongoing to add support for the sanitizers[40], which may or may\n-not include support for safe stack<sup id=\"fnref:7\" role=\"doc-noteref\"><a\n-href=\"#fn:7\" class=\"footnote\">7</a></sup>.\n+The Rust compiler supports shadow stack for aarch64 only\n+<sup id=\"fnref:7\" role=\"doc-noteref\"><a href=\"#fn:7\" class=\"footnote\">7</a></sup>\n+on nightly Rust compilers [43]-[44]. Safe stack is available on nightly\n+Rust compilers [45]-[46].\n \n ```text\n $ readelf -s target/release/hello-rust | grep __safestack_init\n+  1177: 00000000000057b0   444 FUNC    GLOBAL DEFAULT    9 __safestack_init\n ```\n Fig. 16.\u2003Checking if LLVM SafeStack is enabled for a given binary.\n \n The presence of the `__safestack_init` symbol indicates that LLVM SafeStack\n-is enabled for a given binary. Conversely, the absence of the\n+is enabled for a given binary (see Fig. 16). Conversely, the absence of the\n `__safestack_init` symbol indicates that LLVM SafeStack is not enabled for a\n-given binary (see Fig. 16).\n+given binary.\n \n <small id=\"fn:7\">7\\. The shadow stack implementation for the AMD64\n architecture and equivalent in LLVM was removed due to performance and\n@@ -698,3 +629,15 @@ defaults (unrelated to `READ_IMPLIES_EXEC`).\n \n 42. bbjornse. \u201cadd codegen option for using LLVM stack smash protection #84197.\u201d\n     GitHub. <https://github.com/rust-lang/rust/pull/84197>\n+\n+43. ivanloz. \u201cAdd support for LLVM ShadowCallStack. #98208.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/98208>.\n+\n+44. \u201cShadowCallStack.\u201d The Rust Unstable Book.\n+    [https://doc.rust-lang.org/unstable-book/compiler-flags/sanitizer.html#shadowcallstack](../unstable-book/compiler-flags/sanitizer.html#shadowcallstack).\n+\n+45. W. Wiser. \u201cAdd support for LLVM SafeStack #112000\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/112000>\n+\n+46. \u201cSafeStack.\u201d The Rust Unstable Book.\n+    [https://doc.rust-lang/org/unstable-book/compiler-flags/sanitizer.html#safestack](../unstable-book/compiler-flags/sanitizer.html#safestack)."}, {"sha": "49389b28c8fc7a06e47fd52c7705abc9e16d8218", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -21,7 +21,8 @@ This feature allows for use of one of following sanitizers:\n * [MemorySanitizer](#memorysanitizer) a detector of uninitialized reads.\n * [MemTagSanitizer](#memtagsanitizer) fast memory error detector based on\n   Armv8.5-A Memory Tagging Extension.\n-* [ShadowCallStack](#shadowcallstack) provides backward-edge control flow protection.\n+* [SafeStack](#safestack) provides backward-edge control flow protection by separating the stack into safe and unsafe regions.\n+* [ShadowCallStack](#shadowcallstack) provides backward-edge control flow protection (aarch64 only).\n * [ThreadSanitizer](#threadsanitizer) a fast data race detector.\n \n To enable a sanitizer compile with `-Zsanitizer=address`,`-Zsanitizer=cfi`,\n@@ -712,6 +713,16 @@ To enable this target feature compile with `-C target-feature=\"+mte\"`.\n \n See the [LLVM MemTagSanitizer documentation][llvm-memtag] for more details.\n \n+# SafeStack\n+\n+SafeStack provides backward edge control flow protection by separating the stack into data which is only accessed safely (the safe stack) and all other data (the unsafe stack).\n+\n+SafeStack can be enabled with the `-Zsanitizer=safestack` option and is supported on the following targets:\n+\n+* `x86_64-unknown-linux-gnu`\n+\n+See the [Clang SafeStack documentation][clang-safestack] for more details.\n+\n # ShadowCallStack\n \n ShadowCallStack provides backward edge control flow protection by storing a function's return address in a separately allocated 'shadow call stack' and loading the return address from that shadow call stack.\n@@ -828,6 +839,7 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n [clang-kcfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html#fsanitize-kcfi\n [clang-lsan]: https://clang.llvm.org/docs/LeakSanitizer.html\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html\n+[clang-safestack]: https://clang.llvm.org/docs/SafeStack.html\n [clang-scs]: https://clang.llvm.org/docs/ShadowCallStack.html\n [clang-tsan]: https://clang.llvm.org/docs/ThreadSanitizer.html\n [linux-kasan]: https://www.kernel.org/doc/html/latest/dev-tools/kasan.html"}, {"sha": "7d3ccb9def360e8c92fb8ab5ef916bb557a8b1cc", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         let mut impls = Vec::new();\n         for trait_def_id in cx.tcx.all_traits() {\n             if !cx.cache.effective_visibilities.is_reachable(cx.tcx, trait_def_id)\n-                || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n+                || cx.generated_synthetics.get(&(ty.skip_binder(), trait_def_id)).is_some()\n             {\n                 continue;\n             }\n@@ -34,13 +34,13 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     impl_def_id\n                 );\n                 let trait_ref = cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n-                if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n+                if !matches!(trait_ref.skip_binder().self_ty().kind(), ty::Param(_)) {\n                     continue;\n                 }\n                 let infcx = cx.tcx.infer_ctxt().build();\n                 let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n                 let impl_ty = ty.subst(infcx.tcx, substs);\n-                let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n+                let param_env = EarlyBinder::new(param_env).subst(infcx.tcx, substs);\n \n                 let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n                 let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     trait_ref, ty\n                 );\n \n-                cx.generated_synthetics.insert((ty.0, trait_def_id));\n+                cx.generated_synthetics.insert((ty.skip_binder(), trait_def_id));\n \n                 impls.push(Item {\n                     name: None,\n@@ -104,10 +104,10 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         // the post-inference `trait_ref`, as it's more accurate.\n                         trait_: Some(clean_trait_ref_with_bindings(\n                             cx,\n-                            ty::Binder::dummy(trait_ref.0),\n+                            ty::Binder::dummy(trait_ref.skip_binder()),\n                             ThinVec::new(),\n                         )),\n-                        for_: clean_middle_ty(ty::Binder::dummy(ty.0), cx, None),\n+                        for_: clean_middle_ty(ty::Binder::dummy(ty.skip_binder()), cx, None),\n                         items: cx\n                             .tcx\n                             .associated_items(impl_def_id)\n@@ -116,7 +116,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .collect::<Vec<_>>(),\n                         polarity: ty::ImplPolarity::Positive,\n                         kind: ImplKind::Blanket(Box::new(clean_middle_ty(\n-                            ty::Binder::dummy(trait_ref.0.self_ty()),\n+                            ty::Binder::dummy(trait_ref.skip_binder().self_ty()),\n                             cx,\n                             None,\n                         ))),"}, {"sha": "7dc08b3b1ffa672737049afc16c90c6776eebc1a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -355,9 +355,9 @@ pub(crate) fn build_impl(\n         return;\n     }\n \n-    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n-\n     let tcx = cx.tcx;\n+    let _prof_timer = tcx.sess.prof.generic_activity(\"build_impl\");\n+\n     let associated_trait = tcx.impl_trait_ref(did).map(ty::EarlyBinder::skip_binder);\n \n     // Only inline impl if the implemented trait is"}, {"sha": "03adc19e359c193279616a7c6b34e6643e15c82b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2592,7 +2592,8 @@ fn clean_use_statement_inner<'tcx>(\n     } else {\n         if inline_attr.is_none()\n             && let Res::Def(DefKind::Mod, did) = path.res\n-            && !did.is_local() && did.is_crate_root()\n+            && !did.is_local()\n+            && did.is_crate_root()\n         {\n             // if we're `pub use`ing an extern crate root, don't inline it unless we\n             // were specifically asked for it"}, {"sha": "366f93952963ff6faa7418989a3f0db6de72cd4b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -193,7 +193,7 @@ pub(crate) fn build_deref_target_impls(\n         };\n \n         if let Some(prim) = target.primitive_type() {\n-            let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n+            let _prof_timer = tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, did, None, ret);\n             }"}, {"sha": "9f08609a6d1a6bce27d9d0854be12724cc89110d", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -314,7 +314,6 @@ impl Options {\n         matches: &getopts::Matches,\n         args: Vec<String>,\n     ) -> Result<(Options, RenderOptions), i32> {\n-        let args = &args[1..];\n         // Check for unstable options.\n         nightly_options::check_nightly_options(matches, &opts());\n "}, {"sha": "8aaad8bce1b6e88be7a77a16f86e070eb545376d", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -147,7 +147,7 @@ impl Cache {\n \n         // Cache where all our extern crates are located\n         // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n-        for &crate_num in cx.tcx.crates(()) {\n+        for &crate_num in tcx.crates(()) {\n             let e = ExternalCrate { crate_num };\n \n             let name = e.name(tcx);"}, {"sha": "9bb20022cfd4c612acaa92e90c5b7dab3691a95a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 111, "deletions": 9, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1237,7 +1237,27 @@ pub(crate) fn plain_text_summary(md: &str, link_names: &[RenderedLink]) -> Strin\n pub(crate) struct MarkdownLink {\n     pub kind: LinkType,\n     pub link: String,\n-    pub range: Range<usize>,\n+    pub range: MarkdownLinkRange,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) enum MarkdownLinkRange {\n+    /// Normally, markdown link warnings point only at the destination.\n+    Destination(Range<usize>),\n+    /// In some cases, it's not possible to point at the destination.\n+    /// Usually, this happens because backslashes `\\\\` are used.\n+    /// When that happens, point at the whole link, and don't provide structured suggestions.\n+    WholeLink(Range<usize>),\n+}\n+\n+impl MarkdownLinkRange {\n+    /// Extracts the inner range.\n+    pub fn inner_range(&self) -> &Range<usize> {\n+        match self {\n+            MarkdownLinkRange::Destination(range) => range,\n+            MarkdownLinkRange::WholeLink(range) => range,\n+        }\n+    }\n }\n \n pub(crate) fn markdown_links<R>(\n@@ -1257,16 +1277,17 @@ pub(crate) fn markdown_links<R>(\n         if md_start <= s_start && s_end <= md_end {\n             let start = s_start.offset_from(md_start) as usize;\n             let end = s_end.offset_from(md_start) as usize;\n-            start..end\n+            MarkdownLinkRange::Destination(start..end)\n         } else {\n-            fallback\n+            MarkdownLinkRange::WholeLink(fallback)\n         }\n     };\n \n     let span_for_link = |link: &CowStr<'_>, span: Range<usize>| {\n         // For diagnostics, we want to underline the link's definition but `span` will point at\n         // where the link is used. This is a problem for reference-style links, where the definition\n         // is separate from the usage.\n+\n         match link {\n             // `Borrowed` variant means the string (the link's destination) may come directly from\n             // the markdown text and we can locate the original link destination.\n@@ -1275,8 +1296,80 @@ pub(crate) fn markdown_links<R>(\n             CowStr::Borrowed(s) => locate(s, span),\n \n             // For anything else, we can only use the provided range.\n-            CowStr::Boxed(_) | CowStr::Inlined(_) => span,\n+            CowStr::Boxed(_) | CowStr::Inlined(_) => MarkdownLinkRange::WholeLink(span),\n+        }\n+    };\n+\n+    let span_for_offset_backward = |span: Range<usize>, open: u8, close: u8| {\n+        let mut open_brace = !0;\n+        let mut close_brace = !0;\n+        for (i, b) in md.as_bytes()[span.clone()].iter().copied().enumerate().rev() {\n+            let i = i + span.start;\n+            if b == close {\n+                close_brace = i;\n+                break;\n+            }\n+        }\n+        if close_brace < span.start || close_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        let mut nesting = 1;\n+        for (i, b) in md.as_bytes()[span.start..close_brace].iter().copied().enumerate().rev() {\n+            let i = i + span.start;\n+            if b == close {\n+                nesting += 1;\n+            }\n+            if b == open {\n+                nesting -= 1;\n+            }\n+            if nesting == 0 {\n+                open_brace = i;\n+                break;\n+            }\n+        }\n+        assert!(open_brace != close_brace);\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        // do not actually include braces in the span\n+        let range = (open_brace + 1)..close_brace;\n+        MarkdownLinkRange::Destination(range.clone())\n+    };\n+\n+    let span_for_offset_forward = |span: Range<usize>, open: u8, close: u8| {\n+        let mut open_brace = !0;\n+        let mut close_brace = !0;\n+        for (i, b) in md.as_bytes()[span.clone()].iter().copied().enumerate() {\n+            let i = i + span.start;\n+            if b == open {\n+                open_brace = i;\n+                break;\n+            }\n+        }\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n         }\n+        let mut nesting = 0;\n+        for (i, b) in md.as_bytes()[open_brace..span.end].iter().copied().enumerate() {\n+            let i = i + open_brace;\n+            if b == close {\n+                nesting -= 1;\n+            }\n+            if b == open {\n+                nesting += 1;\n+            }\n+            if nesting == 0 {\n+                close_brace = i;\n+                break;\n+            }\n+        }\n+        assert!(open_brace != close_brace);\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        // do not actually include braces in the span\n+        let range = (open_brace + 1)..close_brace;\n+        MarkdownLinkRange::Destination(range.clone())\n     };\n \n     Parser::new_with_broken_link_callback(\n@@ -1287,11 +1380,20 @@ pub(crate) fn markdown_links<R>(\n     .into_offset_iter()\n     .filter_map(|(event, span)| match event {\n         Event::Start(Tag::Link(link_type, dest, _)) if may_be_doc_link(link_type) => {\n-            preprocess_link(MarkdownLink {\n-                kind: link_type,\n-                range: span_for_link(&dest, span),\n-                link: dest.into_string(),\n-            })\n+            let range = match link_type {\n+                // Link is pulled from the link itself.\n+                LinkType::ReferenceUnknown | LinkType::ShortcutUnknown => {\n+                    span_for_offset_backward(span, b'[', b']')\n+                }\n+                LinkType::CollapsedUnknown => span_for_offset_forward(span, b'[', b']'),\n+                LinkType::Inline => span_for_offset_backward(span, b'(', b')'),\n+                // Link is pulled from elsewhere in the document.\n+                LinkType::Reference | LinkType::Collapsed | LinkType::Shortcut => {\n+                    span_for_link(&dest, span)\n+                }\n+                LinkType::Autolink | LinkType::Email => unreachable!(),\n+            };\n+            preprocess_link(MarkdownLink { kind: link_type, range, link: dest.into_string() })\n         }\n         _ => None,\n     })"}, {"sha": "d2dc47af7ac4f95693a4de267f93265e7cb20d3b", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 82, "deletions": 58, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -9,6 +9,8 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use std::borrow::Borrow;\n+use std::cell::{RefCell, RefMut};\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -216,6 +218,53 @@ fn toggle_close(mut w: impl fmt::Write) {\n     w.write_str(\"</details>\").unwrap();\n }\n \n+trait ItemTemplate<'a, 'cx: 'a>: askama::Template + fmt::Display {\n+    fn item_and_mut_cx(&self) -> (&'a clean::Item, RefMut<'_, &'a mut Context<'cx>>);\n+}\n+\n+fn item_template_document<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, mut cx) = templ.item_and_mut_cx();\n+        let v = document(*cx, item, None, HeadingOffset::H2);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n+fn item_template_document_type_layout<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, cx) = templ.item_and_mut_cx();\n+        let def_id = item.item_id.expect_def_id();\n+        let v = document_type_layout(*cx, def_id);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n+fn item_template_render_attributes_in_pre<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, cx) = templ.item_and_mut_cx();\n+        let tcx = cx.tcx();\n+        let v = render_attributes_in_pre(item, \"\", tcx);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n+fn item_template_render_assoc_items<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, mut cx) = templ.item_and_mut_cx();\n+        let def_id = item.item_id.expect_def_id();\n+        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n     write!(w, \"{}\", document(cx, item, None, HeadingOffset::H2));\n \n@@ -356,18 +405,18 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n             clean::ImportItem(ref import) => {\n                 let stab_tags = if let Some(import_def_id) = import.source.did {\n-                    let ast_attrs = cx.tcx().get_attrs_unchecked(import_def_id);\n+                    let ast_attrs = tcx.get_attrs_unchecked(import_def_id);\n                     let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs));\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n                         item_id: import_def_id.into(),\n                         attrs: import_attrs,\n-                        cfg: ast_attrs.cfg(cx.tcx(), &cx.cache().hidden_cfg),\n+                        cfg: ast_attrs.cfg(tcx, &cx.cache().hidden_cfg),\n                         ..myitem.clone()\n                     };\n \n-                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()).to_string());\n+                    let stab_tags = Some(extra_info_tags(&import_item, item, tcx).to_string());\n                     stab_tags\n                 } else {\n                     None\n@@ -405,8 +454,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n                 let unsafety_flag = match *myitem.kind {\n                     clean::FunctionItem(_) | clean::ForeignFunctionItem(_)\n-                        if myitem.fn_header(cx.tcx()).unwrap().unsafety\n-                            == hir::Unsafety::Unsafe =>\n+                        if myitem.fn_header(tcx).unwrap().unsafety == hir::Unsafety::Unsafe =>\n                     {\n                         \"<sup title=\\\"unsafe function\\\">\u26a0</sup>\"\n                     }\n@@ -439,7 +487,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                      {docs_before}{docs}{docs_after}\",\n                     name = myitem.name.unwrap(),\n                     visibility_emoji = visibility_emoji,\n-                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n+                    stab_tags = extra_info_tags(myitem, item, tcx),\n                     class = myitem.type_(),\n                     unsafety_flag = unsafety_flag,\n                     href = item_path(myitem.type_(), myitem.name.unwrap().as_str()),\n@@ -886,7 +934,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n \n             for implementor in foreign {\n-                let provided_methods = implementor.inner_impl().provided_trait_methods(cx.tcx());\n+                let provided_methods = implementor.inner_impl().provided_trait_methods(tcx);\n                 let assoc_link =\n                     AssocItemLink::GotoSource(implementor.impl_item.item_id, &provided_methods);\n                 render_impl(\n@@ -919,7 +967,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         }\n         w.write_str(\"</div>\");\n \n-        if t.is_auto(cx.tcx()) {\n+        if t.is_auto(tcx) {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -948,7 +996,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             \"<div id=\\\"implementors-list\\\"></div>\",\n         );\n \n-        if t.is_auto(cx.tcx()) {\n+        if t.is_auto(tcx) {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -1131,55 +1179,25 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n     #[derive(Template)]\n     #[template(path = \"item_union.html\")]\n     struct ItemUnion<'a, 'cx> {\n-        cx: std::cell::RefCell<&'a mut Context<'cx>>,\n+        cx: RefCell<&'a mut Context<'cx>>,\n         it: &'a clean::Item,\n         s: &'a clean::Union,\n     }\n \n-    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {\n-        fn render_assoc_items<'b>(\n-            &'b self,\n-        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let def_id = self.it.item_id.expect_def_id();\n-                let mut cx = self.cx.borrow_mut();\n-                let v = render_assoc_items(*cx, self.it, def_id, AssocItemRender::All);\n-                write!(f, \"{v}\")\n-            })\n-        }\n-        fn document_type_layout<'b>(\n-            &'b self,\n-        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let def_id = self.it.item_id.expect_def_id();\n-                let cx = self.cx.borrow_mut();\n-                let v = document_type_layout(*cx, def_id);\n-                write!(f, \"{v}\")\n-            })\n+    impl<'a, 'cx: 'a> ItemTemplate<'a, 'cx> for ItemUnion<'a, 'cx> {\n+        fn item_and_mut_cx(&self) -> (&'a clean::Item, RefMut<'_, &'a mut Context<'cx>>) {\n+            (self.it, self.cx.borrow_mut())\n         }\n+    }\n+\n+    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {\n         fn render_union<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n             display_fn(move |f| {\n                 let cx = self.cx.borrow_mut();\n                 let v = render_union(self.it, Some(&self.s.generics), &self.s.fields, *cx);\n                 write!(f, \"{v}\")\n             })\n         }\n-        fn render_attributes_in_pre<'b>(\n-            &'b self,\n-        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let tcx = self.cx.borrow().tcx();\n-                let v = render_attributes_in_pre(self.it, \"\", tcx);\n-                write!(f, \"{v}\")\n-            })\n-        }\n-        fn document<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let mut cx = self.cx.borrow_mut();\n-                let v = document(*cx, self.it, None, HeadingOffset::H2);\n-                write!(f, \"{v}\")\n-            })\n-        }\n         fn document_field<'b>(\n             &'b self,\n             field: &'a clean::Item,\n@@ -1219,7 +1237,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n         }\n     }\n \n-    ItemUnion { cx: std::cell::RefCell::new(cx), it, s }.render_into(w).unwrap();\n+    ItemUnion { cx: RefCell::new(cx), it, s }.render_into(w).unwrap();\n }\n \n fn print_tuple_struct_fields<'a, 'cx: 'a>(\n@@ -1541,36 +1559,42 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n-fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Static) {\n-    wrap_item(w, |w| {\n-        render_attributes_in_code(w, it, cx.tcx());\n+fn item_static(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Static) {\n+    let mut buffer = Buffer::new();\n+    wrap_item(&mut buffer, |buffer| {\n+        render_attributes_in_code(buffer, it, cx.tcx());\n         write!(\n-            w,\n+            buffer,\n             \"{vis}static {mutability}{name}: {typ}\",\n             vis = visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n             mutability = s.mutability.print_with_space(),\n             name = it.name.unwrap(),\n             typ = s.type_.print(cx)\n         );\n     });\n-    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n+\n+    write!(w, \"{}\", buffer.into_inner()).unwrap();\n+\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n-    wrap_item(w, |w| {\n-        w.write_str(\"extern {\\n\");\n-        render_attributes_in_code(w, it, cx.tcx());\n+fn item_foreign_type(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Item) {\n+    let mut buffer = Buffer::new();\n+    wrap_item(&mut buffer, |buffer| {\n+        buffer.write_str(\"extern {\\n\");\n+        render_attributes_in_code(buffer, it, cx.tcx());\n         write!(\n-            w,\n+            buffer,\n             \"    {}type {};\\n}}\",\n             visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n             it.name.unwrap(),\n         );\n     });\n \n-    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n+    write!(w, \"{}{}\", buffer.into_inner(), document(cx, it, None, HeadingOffset::H2)).unwrap();\n \n     write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}, {"sha": "c9b95b1e64599fe42dc6056fec76cb33333ad3ad", "filename": "src/librustdoc/html/render/type_layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -54,13 +54,13 @@ pub(crate) fn document_type_layout<'a, 'cx: 'a>(\n                     } else if let Primitive::Int(i, _) = tag.primitive() {\n                         i.size().bytes()\n                     } else {\n-                        span_bug!(cx.tcx().def_span(ty_def_id), \"tag is neither niche nor int\")\n+                        span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n                     };\n                 variants\n                     .iter_enumerated()\n                     .map(|(variant_idx, variant_layout)| {\n                         let Adt(adt, _) = type_layout.ty.kind() else {\n-                            span_bug!(cx.tcx().def_span(ty_def_id), \"not an adt\")\n+                            span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n                         };\n                         let name = adt.variant(variant_idx).name;\n                         let is_unsized = variant_layout.abi.is_unsized();"}, {"sha": "c2196700513326a5970f87271514b48e1c55aad6", "filename": "src/librustdoc/html/templates/item_union.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,8 +1,8 @@\n <pre class=\"rust item-decl\"><code>\n-    {{ self.render_attributes_in_pre() | safe }}\n+    {{ self::item_template_render_attributes_in_pre(self.borrow()) | safe }}\n     {{ self.render_union() | safe }}\n </code></pre>\n-{{ self.document() | safe }}\n+{{ self::item_template_document(self.borrow()) | safe }}\n {% if self.fields_iter().peek().is_some() %}\n     <h2 id=\"fields\" class=\"fields small-section-header\">\n         Fields<a href=\"#fields\" class=\"anchor\">\u00a7</a>\n@@ -19,5 +19,5 @@ <h2 id=\"fields\" class=\"fields small-section-header\">\n         {{ self.document_field(field) | safe }}\n     {% endfor %}\n {% endif %}\n-{{ self.render_assoc_items() | safe }}\n-{{ self.document_type_layout() | safe }}\n+{{ self::item_template_render_assoc_items(self.borrow()) | safe }}\n+{{ self::item_template_document_type_layout(self.borrow()) | safe }}"}, {"sha": "12c622e026f1efabb599d9b758d0d70c6a0172a0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -712,13 +712,23 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n }\n \n fn main_args(at_args: &[String]) -> MainResult {\n+    // Throw away the first argument, the name of the binary.\n+    // In case of at_args being empty, as might be the case by\n+    // passing empty argument array to execve under some platforms,\n+    // just use an empty slice.\n+    //\n+    // This situation was possible before due to arg_expand_all being\n+    // called before removing the argument, enabling a crash by calling\n+    // the compiler with @empty_file as argv[0] and no more arguments.\n+    let at_args = at_args.get(1..).unwrap_or_default();\n+\n     let args = rustc_driver::args::arg_expand_all(at_args);\n \n     let mut options = getopts::Options::new();\n     for option in opts() {\n         (option.apply)(&mut options);\n     }\n-    let matches = match options.parse(&args[1..]) {\n+    let matches = match options.parse(&args) {\n         Ok(m) => m,\n         Err(err) => {\n             early_error(ErrorOutputType::default(), err.to_string());"}, {"sha": "061a572c46b6c5340b94aa07babe357242dfd83b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 114, "deletions": 64, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -31,7 +31,7 @@ use std::ops::Range;\n use crate::clean::{self, utils::find_nearest_parent_module};\n use crate::clean::{Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n-use crate::html::markdown::{markdown_links, MarkdownLink};\n+use crate::html::markdown::{markdown_links, MarkdownLink, MarkdownLinkRange};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n use crate::passes::Pass;\n use crate::visit::DocVisitor;\n@@ -248,7 +248,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Range<usize>,\n+    link_range: MarkdownLinkRange,\n }\n \n struct LinkCollector<'a, 'tcx> {\n@@ -723,7 +723,7 @@ fn resolve_associated_trait_item<'a>(\n         .iter()\n         .flat_map(|&(impl_, trait_)| {\n             filter_assoc_items_by_name_and_namespace(\n-                cx.tcx,\n+                tcx,\n                 trait_,\n                 Ident::with_dummy_span(item_name),\n                 ns,\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n enum PreprocessingError {\n     /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n-    Disambiguator(Range<usize>, String),\n+    Disambiguator(MarkdownLinkRange, String),\n     MalformedGenerics(MalformedGenerics, String),\n }\n \n@@ -873,6 +873,7 @@ pub(crate) struct PreprocessedMarkdownLink(\n /// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n fn preprocess_link(\n     ori_link: &MarkdownLink,\n+    dox: &str,\n ) -> Option<Result<PreprocessingInfo, PreprocessingError>> {\n     // [] is mostly likely not supposed to be a link\n     if ori_link.link.is_empty() {\n@@ -906,9 +907,15 @@ fn preprocess_link(\n         Err((err_msg, relative_range)) => {\n             // Only report error if we would not have ignored this link. See issue #83859.\n             if !should_ignore_link_with_disambiguators(link) {\n-                let no_backticks_range = range_between_backticks(ori_link);\n-                let disambiguator_range = (no_backticks_range.start + relative_range.start)\n-                    ..(no_backticks_range.start + relative_range.end);\n+                let disambiguator_range = match range_between_backticks(&ori_link.range, dox) {\n+                    MarkdownLinkRange::Destination(no_backticks_range) => {\n+                        MarkdownLinkRange::Destination(\n+                            (no_backticks_range.start + relative_range.start)\n+                                ..(no_backticks_range.start + relative_range.end),\n+                        )\n+                    }\n+                    mdlr @ MarkdownLinkRange::WholeLink(_) => mdlr,\n+                };\n                 return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n             } else {\n                 return None;\n@@ -947,7 +954,7 @@ fn preprocess_link(\n \n fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n     markdown_links(s, |link| {\n-        preprocess_link(&link).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n+        preprocess_link(&link, s).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n     })\n }\n \n@@ -1060,22 +1067,12 @@ impl LinkCollector<'_, '_> {\n                     // valid omission. See https://github.com/rust-lang/rust/pull/80660#discussion_r551585677\n                     // for discussion on the matter.\n                     let kind = self.cx.tcx.def_kind(id);\n-                    self.verify_disambiguator(\n-                        path_str,\n-                        ori_link,\n-                        kind,\n-                        id,\n-                        disambiguator,\n-                        item,\n-                        &diag_info,\n-                    )?;\n+                    self.verify_disambiguator(path_str, kind, id, disambiguator, item, &diag_info)?;\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n                         Some(other) => {\n-                            self.report_disambiguator_mismatch(\n-                                path_str, ori_link, other, res, &diag_info,\n-                            );\n+                            self.report_disambiguator_mismatch(path_str, other, res, &diag_info);\n                             return None;\n                         }\n                     }\n@@ -1096,7 +1093,6 @@ impl LinkCollector<'_, '_> {\n                 };\n                 self.verify_disambiguator(\n                     path_str,\n-                    ori_link,\n                     kind_for_dis,\n                     id_for_dis,\n                     disambiguator,\n@@ -1118,7 +1114,6 @@ impl LinkCollector<'_, '_> {\n     fn verify_disambiguator(\n         &self,\n         path_str: &str,\n-        ori_link: &MarkdownLink,\n         kind: DefKind,\n         id: DefId,\n         disambiguator: Option<Disambiguator>,\n@@ -1142,7 +1137,7 @@ impl LinkCollector<'_, '_> {\n                 => {}\n                 (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n                 (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                    self.report_disambiguator_mismatch(path_str,ori_link,specified, Res::Def(kind, id),diag_info);\n+                    self.report_disambiguator_mismatch(path_str, specified, Res::Def(kind, id), diag_info);\n                     return None;\n                 }\n             }\n@@ -1164,14 +1159,13 @@ impl LinkCollector<'_, '_> {\n     fn report_disambiguator_mismatch(\n         &self,\n         path_str: &str,\n-        ori_link: &MarkdownLink,\n         specified: Disambiguator,\n         resolved: Res,\n         diag_info: &DiagnosticInfo<'_>,\n     ) {\n         // The resolved item did not match the disambiguator; give a better error than 'not found'\n         let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>| {\n+        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>, link_range| {\n             let note = format!(\n                 \"this link resolved to {} {}, which is not {} {}\",\n                 resolved.article(),\n@@ -1184,14 +1178,24 @@ impl LinkCollector<'_, '_> {\n             } else {\n                 diag.note(note);\n             }\n-            suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n+            suggest_disambiguator(resolved, diag, path_str, link_range, sp, diag_info);\n         };\n         report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, callback);\n     }\n \n-    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n-        let span = super::source_span_for_markdown_range(self.cx.tcx, dox, ori_link, &item.attrs)\n-            .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+    fn report_rawptr_assoc_feature_gate(\n+        &self,\n+        dox: &str,\n+        ori_link: &MarkdownLinkRange,\n+        item: &Item,\n+    ) {\n+        let span = super::source_span_for_markdown_range(\n+            self.cx.tcx,\n+            dox,\n+            ori_link.inner_range(),\n+            &item.attrs,\n+        )\n+        .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n         rustc_session::parse::feature_err(\n             &self.cx.tcx.sess.parse_sess,\n             sym::intra_doc_pointers,\n@@ -1371,16 +1375,23 @@ impl LinkCollector<'_, '_> {\n /// [`Foo`]\n ///   ^^^\n /// ```\n-fn range_between_backticks(ori_link: &MarkdownLink) -> Range<usize> {\n-    let after_first_backtick_group = ori_link.link.bytes().position(|b| b != b'`').unwrap_or(0);\n-    let before_second_backtick_group = ori_link\n-        .link\n+///\n+/// This function does nothing if `ori_link.range` is a `MarkdownLinkRange::WholeLink`.\n+fn range_between_backticks(ori_link_range: &MarkdownLinkRange, dox: &str) -> MarkdownLinkRange {\n+    let range = match ori_link_range {\n+        mdlr @ MarkdownLinkRange::WholeLink(_) => return mdlr.clone(),\n+        MarkdownLinkRange::Destination(inner) => inner.clone(),\n+    };\n+    let ori_link_text = &dox[range.clone()];\n+    let after_first_backtick_group = ori_link_text.bytes().position(|b| b != b'`').unwrap_or(0);\n+    let before_second_backtick_group = ori_link_text\n         .bytes()\n         .skip(after_first_backtick_group)\n         .position(|b| b == b'`')\n-        .unwrap_or(ori_link.link.len());\n-    (ori_link.range.start + after_first_backtick_group)\n-        ..(ori_link.range.start + before_second_backtick_group)\n+        .unwrap_or(ori_link_text.len());\n+    MarkdownLinkRange::Destination(\n+        (range.start + after_first_backtick_group)..(range.start + before_second_backtick_group),\n+    )\n }\n \n /// Returns true if we should ignore `link` due to it being unlikely\n@@ -1530,14 +1541,23 @@ impl Suggestion {\n         sp: rustc_span::Span,\n     ) -> Vec<(rustc_span::Span, String)> {\n         let inner_sp = match ori_link.find('(') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => sp.with_hi(sp.lo() + BytePos(index as _)),\n             None => sp,\n         };\n         let inner_sp = match ori_link.find('!') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => inner_sp.with_hi(inner_sp.lo() + BytePos(index as _)),\n             None => inner_sp,\n         };\n         let inner_sp = match ori_link.find('@') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => inner_sp.with_lo(inner_sp.lo() + BytePos(index as u32 + 1)),\n             None => inner_sp,\n         };\n@@ -1584,7 +1604,7 @@ fn report_diagnostic(\n     lint: &'static Lint,\n     msg: impl Into<DiagnosticMessage> + Display,\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n-    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n+    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>, MarkdownLinkRange),\n ) {\n     let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n     else {\n@@ -1596,16 +1616,32 @@ fn report_diagnostic(\n     let sp = item.attr_span(tcx);\n \n     tcx.struct_span_lint_hir(lint, hir_id, sp, msg, |lint| {\n-        let span =\n-            super::source_span_for_markdown_range(tcx, dox, link_range, &item.attrs).map(|sp| {\n-                if dox.as_bytes().get(link_range.start) == Some(&b'`')\n-                    && dox.as_bytes().get(link_range.end - 1) == Some(&b'`')\n-                {\n-                    sp.with_lo(sp.lo() + BytePos(1)).with_hi(sp.hi() - BytePos(1))\n-                } else {\n-                    sp\n-                }\n-            });\n+        let (span, link_range) = match link_range {\n+            MarkdownLinkRange::Destination(md_range) => {\n+                let mut md_range = md_range.clone();\n+                let sp = super::source_span_for_markdown_range(tcx, dox, &md_range, &item.attrs)\n+                    .map(|mut sp| {\n+                        while dox.as_bytes().get(md_range.start) == Some(&b' ')\n+                            || dox.as_bytes().get(md_range.start) == Some(&b'`')\n+                        {\n+                            md_range.start += 1;\n+                            sp = sp.with_lo(sp.lo() + BytePos(1));\n+                        }\n+                        while dox.as_bytes().get(md_range.end - 1) == Some(&b' ')\n+                            || dox.as_bytes().get(md_range.end - 1) == Some(&b'`')\n+                        {\n+                            md_range.end -= 1;\n+                            sp = sp.with_hi(sp.hi() - BytePos(1));\n+                        }\n+                        sp\n+                    });\n+                (sp, MarkdownLinkRange::Destination(md_range))\n+            }\n+            MarkdownLinkRange::WholeLink(md_range) => (\n+                super::source_span_for_markdown_range(tcx, dox, &md_range, &item.attrs),\n+                link_range.clone(),\n+            ),\n+        };\n \n         if let Some(sp) = span {\n             lint.set_span(sp);\n@@ -1614,21 +1650,22 @@ fn report_diagnostic(\n             //                       ^     ~~~~\n             //                       |     link_range\n             //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let md_range = link_range.inner_range().clone();\n+            let last_new_line_offset = dox[..md_range.start].rfind('\\n').map_or(0, |n| n + 1);\n             let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            // Print the line containing the `md_range` and manually mark it with '^'s.\n             lint.note(format!(\n                 \"the link appears in this line:\\n\\n{line}\\n\\\n                      {indicator: <before$}{indicator:^<found$}\",\n                 line = line,\n                 indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n+                before = md_range.start - last_new_line_offset,\n+                found = md_range.len(),\n             ));\n         }\n \n-        decorate(lint, span);\n+        decorate(lint, span, link_range);\n \n         lint\n     });\n@@ -1652,7 +1689,7 @@ fn resolution_failure(\n         BROKEN_INTRA_DOC_LINKS,\n         format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n-        |diag, sp| {\n+        |diag, sp, link_range| {\n             let item = |res: Res| format!(\"the {} `{}`\", res.descr(), res.name(tcx),);\n             let assoc_item_not_allowed = |res: Res| {\n                 let name = res.name(tcx);\n@@ -1706,7 +1743,7 @@ fn resolution_failure(\n                             if let Ok(v_res) = collector.resolve(start, ns, item_id, module_id) {\n                                 debug!(\"found partial_res={:?}\", v_res);\n                                 if !v_res.is_empty() {\n-                                    *partial_res = Some(full_res(collector.cx.tcx, v_res[0]));\n+                                    *partial_res = Some(full_res(tcx, v_res[0]));\n                                     *unresolved = end.into();\n                                     break 'outer;\n                                 }\n@@ -1845,7 +1882,14 @@ fn resolution_failure(\n                 let note = match failure {\n                     ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n                     ResolutionFailure::WrongNamespace { res, expected_ns } => {\n-                        suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n+                        suggest_disambiguator(\n+                            res,\n+                            diag,\n+                            path_str,\n+                            link_range.clone(),\n+                            sp,\n+                            &diag_info,\n+                        );\n \n                         format!(\n                             \"this link resolves to {}, which is not in the {} namespace\",\n@@ -1882,7 +1926,7 @@ fn anchor_failure(\n     msg: String,\n     anchor_idx: usize,\n ) {\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp, _link_range| {\n         if let Some(mut sp) = sp {\n             if let Some((fragment_offset, _)) =\n                 diag_info.ori_link.char_indices().filter(|(_, x)| *x == '#').nth(anchor_idx)\n@@ -1898,11 +1942,11 @@ fn anchor_failure(\n fn disambiguator_error(\n     cx: &DocContext<'_>,\n     mut diag_info: DiagnosticInfo<'_>,\n-    disambiguator_range: Range<usize>,\n+    disambiguator_range: MarkdownLinkRange,\n     msg: impl Into<DiagnosticMessage> + Display,\n ) {\n     diag_info.link_range = disambiguator_range;\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp, _link_range| {\n         let msg = format!(\n             \"see {}/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\",\n             crate::DOC_RUST_LANG_ORG_CHANNEL\n@@ -1922,7 +1966,7 @@ fn report_malformed_generics(\n         BROKEN_INTRA_DOC_LINKS,\n         format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n-        |diag, sp| {\n+        |diag, sp, _link_range| {\n             let note = match err {\n                 MalformedGenerics::UnbalancedAngleBrackets => \"unbalanced angle brackets\",\n                 MalformedGenerics::MissingType => \"missing type for generic parameters\",\n@@ -1995,15 +2039,15 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp, link_range| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n             diag.note(\"ambiguous link\");\n         }\n \n         for res in kinds {\n-            suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n+            suggest_disambiguator(res, diag, path_str, link_range.clone(), sp, diag_info);\n         }\n     });\n     true\n@@ -2015,13 +2059,19 @@ fn suggest_disambiguator(\n     res: Res,\n     diag: &mut Diagnostic,\n     path_str: &str,\n-    ori_link: &str,\n+    link_range: MarkdownLinkRange,\n     sp: Option<rustc_span::Span>,\n+    diag_info: &DiagnosticInfo<'_>,\n ) {\n     let suggestion = res.disambiguator_suggestion();\n     let help = format!(\"to link to the {}, {}\", res.descr(), suggestion.descr());\n \n-    if let Some(sp) = sp {\n+    let ori_link = match link_range {\n+        MarkdownLinkRange::Destination(range) => Some(&diag_info.dox[range]),\n+        MarkdownLinkRange::WholeLink(_) => None,\n+    };\n+\n+    if let (Some(sp), Some(ori_link)) = (sp, ori_link) {\n         let mut spans = suggestion.as_help_span(path_str, ori_link, sp);\n         if spans.len() > 1 {\n             diag.multipart_suggestion(help, spans, Applicability::MaybeIncorrect);\n@@ -2047,7 +2097,7 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp, _link_range| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "fbf827cce0984cf101774bf55c7d5d49d51c7d65", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -19,9 +19,10 @@ pub(crate) const COLLECT_TRAIT_IMPLS: Pass = Pass {\n };\n \n pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let tcx = cx.tcx;\n     // We need to check if there are errors before running this pass because it would crash when\n     // we try to get auto and blanket implementations.\n-    if cx.tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n+    if tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n         return krate;\n     }\n \n@@ -32,8 +33,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     });\n \n     let local_crate = ExternalCrate { crate_num: LOCAL_CRATE };\n-    let prims: FxHashSet<PrimitiveType> =\n-        local_crate.primitives(cx.tcx).iter().map(|p| p.1).collect();\n+    let prims: FxHashSet<PrimitiveType> = local_crate.primitives(tcx).iter().map(|p| p.1).collect();\n \n     let crate_items = {\n         let mut coll = ItemCollector::new();\n@@ -46,24 +46,23 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // External trait impls.\n     {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n-        for &cnum in cx.tcx.crates(()) {\n-            for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n+        let _prof_timer = tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n+        for &cnum in tcx.crates(()) {\n+            for &impl_def_id in tcx.trait_impls_in_crate(cnum) {\n                 inline::build_impl(cx, impl_def_id, None, &mut new_items_external);\n             }\n         }\n     }\n \n     // Local trait impls.\n     {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let _prof_timer = tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n         let mut attr_buf = Vec::new();\n-        for &impl_def_id in cx.tcx.trait_impls_in_crate(LOCAL_CRATE) {\n-            let mut parent = Some(cx.tcx.parent(impl_def_id));\n+        for &impl_def_id in tcx.trait_impls_in_crate(LOCAL_CRATE) {\n+            let mut parent = Some(tcx.parent(impl_def_id));\n             while let Some(did) = parent {\n                 attr_buf.extend(\n-                    cx.tcx\n-                        .get_attrs(did, sym::doc)\n+                    tcx.get_attrs(did, sym::doc)\n                         .filter(|attr| {\n                             if let Some([attr]) = attr.meta_item_list().as_deref() {\n                                 attr.has_name(sym::cfg)\n@@ -73,25 +72,24 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                         })\n                         .cloned(),\n                 );\n-                parent = cx.tcx.opt_parent(did);\n+                parent = tcx.opt_parent(did);\n             }\n             inline::build_impl(cx, impl_def_id, Some((&attr_buf, None)), &mut new_items_local);\n             attr_buf.clear();\n         }\n     }\n \n-    cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n-        for def_id in PrimitiveType::all_impls(cx.tcx) {\n+    tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+        for def_id in PrimitiveType::all_impls(tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n                 inline::build_impl(cx, def_id, None, &mut new_items_external);\n             }\n         }\n-        for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {\n+        for (prim, did) in PrimitiveType::primitive_locations(tcx) {\n             // Do not calculate blanket impl list for docs that are not going to be rendered.\n             // While the `impl` blocks themselves are only in `libcore`, the module with `doc`\n             // attached is directly included in `libstd` as well.\n-            let tcx = cx.tcx;\n             if did.is_local() {\n                 for def_id in prim.impls(tcx).filter(|def_id| {\n                     // Avoid including impl blocks with filled-in generics.\n@@ -157,7 +155,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n         if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind &&\n-            trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait() &&\n+            trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() &&\n             cleaner.keep_impl(for_, true)\n         {\n             let target = items\n@@ -199,7 +197,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         if let ImplItem(box Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n-                trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n+                trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait(),\n             ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || kind.is_blanket()\n         } else {"}, {"sha": "865212205ed1885668cd4898cb3987b689032171", "filename": "src/librustdoc/passes/lint/unescaped_backticks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -56,7 +56,7 @@ pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n                 )\n                 .unwrap_or_else(|| item.attr_span(tcx));\n \n-                cx.tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n+                tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n                     let mut help_emitted = false;\n \n                     match element.prev_code_guess {"}, {"sha": "6b7ad4cf21ae71af4a0e0dbbada5341a7e97b7df", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -280,40 +280,55 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let is_private =\n-            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did, None);\n+        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(tcx, ori_res_did);\n+        let is_hidden = inherits_doc_hidden(tcx, res_did, None);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false;\n         }\n \n         if !please_inline &&\n-            let Some(item_def_id) = reexport_chain(self.cx.tcx, def_id, res_did).iter()\n+            let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n                 .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n                 .chain(iter::once(res_did)).nth(1) &&\n             item_def_id != def_id &&\n             self\n                 .cx\n                 .cache\n                 .effective_visibilities\n-                .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(self.cx.tcx, item_def_id, None)\n+                .is_directly_public(tcx, item_def_id.to_def_id()) &&\n+            !inherits_doc_hidden(tcx, item_def_id, None)\n         {\n             // The imported item is public and not `doc(hidden)` so no need to inline it.\n             return false;\n         }\n \n-        if !self.view_item_stack.insert(res_did) {\n+        let is_bang_macro = matches!(\n+            tcx.hir().get_by_def_id(res_did),\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Macro(_, MacroKind::Bang), .. })\n+        );\n+\n+        if !self.view_item_stack.insert(res_did) && !is_bang_macro {\n             return false;\n         }\n \n         let ret = match tcx.hir().get_by_def_id(res_did) {\n+            // Bang macros are handled a bit on their because of how they are handled by the\n+            // compiler. If they have `#[doc(hidden)]` and the re-export doesn't have\n+            // `#[doc(inline)]`, then we don't inline it.\n+            Node::Item(_)\n+                if is_bang_macro\n+                    && !please_inline\n+                    && renamed.is_some()\n+                    && self.cx.tcx.is_doc_hidden(ori_res_did) =>\n+            {\n+                return false;\n+            }\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n-                    let i = self.cx.tcx.hir().item(i);\n+                    let i = tcx.hir().item(i);\n                     self.visit_item_inner(i, None, Some(def_id));\n                 }\n                 self.inlining = prev;"}, {"sha": "a418a910ba8ea2f614eb1ea0d2603583b06fffb5", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1219,7 +1219,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n                 return false;\n             }\n \n-            let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n+            let predicate = EarlyBinder::new(predicate).subst(cx.tcx, &substs_with_referent_ty);\n             let obligation = Obligation::new(cx.tcx, ObligationCause::dummy(), cx.param_env, predicate);\n             let infcx = cx.tcx.infer_ctxt().build();\n             infcx.predicate_must_hold_modulo_regions(&obligation)"}, {"sha": "af2aac6ac0d0ace9cff23dde29baf40543c50053", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -243,7 +243,7 @@ fn get_ufcs_type_name<'tcx>(cx: &LateContext<'tcx>, method_def_id: DefId, substs\n                 | ty::Ref(..)\n                 | ty::Slice(_)\n                 | ty::Tuple(_) => {\n-                    format!(\"<{}>\", EarlyBinder(ty).subst(cx.tcx, substs))\n+                    format!(\"<{}>\", EarlyBinder::new(ty).subst(cx.tcx, substs))\n                 },\n                 _ => ty.to_string(),\n             }"}, {"sha": "d4cc14bb856327946ebdcf7281b7b46c9cb8392d", "filename": "src/tools/clippy/clippy_lints/src/methods/needless_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -241,7 +241,7 @@ fn is_contains_sig(cx: &LateContext<'_>, call_id: HirId, iter_expr: &Expr<'_>) -\n         && let proj_ty = cx.tcx.mk_projection(iter_item.def_id, substs)\n         && let Ok(item_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, proj_ty)\n     {\n-        item_ty == EarlyBinder(search_ty).subst(cx.tcx, cx.typeck_results().node_substs(call_id))\n+        item_ty == EarlyBinder::new(search_ty).subst(cx.tcx, cx.typeck_results().node_substs(call_id))\n     } else {\n         false\n     }"}, {"sha": "fdacfa49e92d54b08a23c37757ed33618732c7ed", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -428,7 +428,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                                      }));\n \n                         if trait_predicates.any(|predicate| {\n-                            let predicate = EarlyBinder(predicate).subst(cx.tcx, new_subst);\n+                            let predicate = EarlyBinder::new(predicate).subst(cx.tcx, new_subst);\n                             let obligation = Obligation::new(cx.tcx, ObligationCause::dummy(), cx.param_env, predicate);\n                             !cx.tcx.infer_ctxt().build().predicate_must_hold_modulo_regions(&obligation)\n                         }) {\n@@ -438,7 +438,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                         let output_ty = fn_sig.output();\n                         if output_ty.contains(*param_ty) {\n                             if let Ok(new_ty)  = cx.tcx.try_subst_and_normalize_erasing_regions(\n-                                new_subst, cx.param_env, EarlyBinder(output_ty)) {\n+                                new_subst, cx.param_env, EarlyBinder::new(output_ty)) {\n                                 expr = parent_expr;\n                                 ty = new_ty;\n                                 continue;"}, {"sha": "e6fd65f001a6e8ea4a8d7e02384ee6282358d66d", "filename": "src/tools/clippy/clippy_lints/src/multiple_unsafe_ops_per_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -138,7 +138,7 @@ fn collect_unsafe_exprs<'tcx>(\n                     .type_dependent_def_id(expr.hir_id)\n                     .map(|def_id| cx.tcx.fn_sig(def_id))\n                 {\n-                    if sig.0.unsafety() == Unsafety::Unsafe {\n+                    if sig.skip_binder().unsafety() == Unsafety::Unsafe {\n                         unsafe_ops.push((\"unsafe method call occurs here\", expr.span));\n                     }\n                 }"}, {"sha": "843538e1eb2db2c5638ab3c7d0d9df8b87910d90", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {\n-                    EarlyBinder(substs).subst(self.lcx.tcx, self.substs)\n+                    EarlyBinder::new(substs).subst(self.lcx.tcx, self.substs)\n                 };\n \n                 let result = self"}, {"sha": "d2f258320f086aa23c628f4a448bf94b8f78b0b2", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,6 +3,9 @@ name = \"compiletest\"\n version = \"0.0.0\"\n edition = \"2021\"\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n colored = \"2\"\n diff = \"0.1.10\""}, {"sha": "f796c898731117384e15e449f6f686e36fb50ec2", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -69,6 +69,12 @@ string_enum! {\n     }\n }\n \n+impl Default for Mode {\n+    fn default() -> Self {\n+        Mode::Ui\n+    }\n+}\n+\n impl Mode {\n     pub fn disambiguator(self) -> &'static str {\n         // Pretty-printing tests could run concurrently, and if they do,\n@@ -125,7 +131,7 @@ pub enum PanicStrategy {\n }\n \n /// Configuration for compiletest\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Default, Clone)]\n pub struct Config {\n     /// `true` to overwrite stderr/stdout files instead of complaining about changes in output.\n     pub bless: bool,"}, {"sha": "18b3b913a682fe65b75c9c9ac72a9f973c0e43ea", "filename": "src/tools/compiletest/src/header/needs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -70,6 +70,11 @@ pub(super) fn handle_needs(\n             condition: cache.sanitizer_shadow_call_stack,\n             ignore_reason: \"ignored on targets without shadow call stacks\",\n         },\n+        Need {\n+            name: \"needs-sanitizer-safestack\",\n+            condition: cache.sanitizer_safestack,\n+            ignore_reason: \"ignored on targets without SafeStack support\",\n+        },\n         Need {\n             name: \"needs-run-enabled\",\n             condition: config.run_enabled(),\n@@ -184,6 +189,7 @@ pub(super) struct CachedNeedsConditions {\n     sanitizer_hwaddress: bool,\n     sanitizer_memtag: bool,\n     sanitizer_shadow_call_stack: bool,\n+    sanitizer_safestack: bool,\n     xray: bool,\n     rust_lld: bool,\n     i686_dlltool: bool,\n@@ -220,6 +226,7 @@ impl CachedNeedsConditions {\n             sanitizer_hwaddress: util::HWASAN_SUPPORTED_TARGETS.contains(target),\n             sanitizer_memtag: util::MEMTAG_SUPPORTED_TARGETS.contains(target),\n             sanitizer_shadow_call_stack: util::SHADOWCALLSTACK_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_safestack: util::SAFESTACK_SUPPORTED_TARGETS.contains(target),\n             xray: util::XRAY_SUPPORTED_TARGETS.contains(target),\n \n             // For tests using the `needs-rust-lld` directive (e.g. for `-Zgcc-ld=lld`), we need to find"}, {"sha": "fc48d0159905b1ffc3dd60a8cb9d57586d8bce7f", "filename": "src/tools/compiletest/src/lib.rs", "status": "added", "additions": 1136, "deletions": 0, "changes": 1136, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,1136 @@\n+#![crate_name = \"compiletest\"]\n+// The `test` crate is the only unstable feature\n+// allowed here, just to share similar code.\n+#![feature(test)]\n+\n+extern crate test;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+pub mod common;\n+pub mod compute_diff;\n+pub mod errors;\n+pub mod header;\n+mod json;\n+mod raise_fd_limit;\n+mod read2;\n+pub mod runtest;\n+pub mod util;\n+\n+use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n+use crate::common::{Config, Debugger, Mode, PassMode, TestPaths};\n+use crate::util::logv;\n+use build_helper::git::{get_git_modified_files, get_git_untracked_files};\n+use core::panic;\n+use getopts::Options;\n+use lazycell::AtomicLazyCell;\n+use std::collections::BTreeSet;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, ErrorKind};\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n+use std::time::SystemTime;\n+use std::{env, vec};\n+use test::ColorConfig;\n+use tracing::*;\n+use walkdir::WalkDir;\n+\n+use self::header::{make_test_description, EarlyProps};\n+use crate::header::HeadersCache;\n+use std::sync::Arc;\n+\n+pub fn parse_config(args: Vec<String>) -> Config {\n+    let mut opts = Options::new();\n+    opts.reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\")\n+        .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n+        .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n+        .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n+        .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n+        .reqopt(\"\", \"python\", \"path to python to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondoclint-path\", \"path to jsondoclint to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n+        .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n+        .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n+        .optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\")\n+        .reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\")\n+        .reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\")\n+        .reqopt(\"\", \"sysroot-base\", \"directory containing the compiler sysroot\", \"PATH\")\n+        .reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\")\n+        .reqopt(\n+            \"\",\n+            \"mode\",\n+            \"which sort of compile tests to run\",\n+            \"run-pass-valgrind | pretty | debug-info | codegen | rustdoc \\\n+            | rustdoc-json | codegen-units | incremental | run-make | ui | js-doc-test | mir-opt | assembly\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"suite\",\n+            \"which suite of compile tests to run. used for nicer error reporting.\",\n+            \"SUITE\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"pass\",\n+            \"force {check,build,run}-pass tests to this mode.\",\n+            \"check | build | run\",\n+        )\n+        .optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\")\n+        .optflag(\"\", \"ignored\", \"run tests marked as ignored\")\n+        .optmulti(\"\", \"skip\", \"skip tests matching SUBSTRING. Can be passed multiple times\", \"SUBSTRING\")\n+        .optflag(\"\", \"exact\", \"filters match exactly\")\n+        .optopt(\n+            \"\",\n+            \"runtool\",\n+            \"supervisor program to run tests under \\\n+             (eg. emulator, valgrind)\",\n+            \"PROGRAM\",\n+        )\n+        .optmulti(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\")\n+        .optmulti(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\")\n+        .optflag(\"\", \"optimize-tests\", \"run tests with optimizations enabled\")\n+        .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n+        .optflag(\n+            \"\",\n+            \"bless\",\n+            \"overwrite stderr/stdout files instead of complaining about a mismatch\",\n+        )\n+        .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n+        .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n+        .optflag(\"\", \"json\", \"emit json output instead of plaintext output\")\n+        .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n+        .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n+        .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n+        .optopt(\"\", \"cdb\", \"path to CDB to use for CDB debuginfo tests\", \"PATH\")\n+        .optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\")\n+        .optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\")\n+        .optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\")\n+        .optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\")\n+        .optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\")\n+        .optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\")\n+        .optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\")\n+        .optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\")\n+        .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n+        .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n+        .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n+        .reqopt(\"\", \"cxxflags\", \"flags for the CXX compiler\", \"FLAGS\")\n+        .optopt(\"\", \"ar\", \"path to an archiver\", \"PATH\")\n+        .optopt(\"\", \"target-linker\", \"path to a linker for the target\", \"PATH\")\n+        .optopt(\"\", \"host-linker\", \"path to a linker for the host\", \"PATH\")\n+        .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n+        .optopt(\"\", \"llvm-bin-dir\", \"Path to LLVM's `bin` directory\", \"PATH\")\n+        .optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\")\n+        .optopt(\"\", \"npm\", \"the name of npm\", \"PATH\")\n+        .optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\")\n+        .optopt(\n+            \"\",\n+            \"compare-mode\",\n+            \"mode describing what file the actual ui output will be compared to\",\n+            \"COMPARE MODE\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"rustfix-coverage\",\n+            \"enable this to generate a Rustfix coverage file, which is saved in \\\n+            `./<build_base>/rustfix_missing_coverage.txt`\",\n+        )\n+        .optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\")\n+        .optflag(\"\", \"only-modified\", \"only run tests that result been modified\")\n+        .optflag(\"\", \"nocapture\", \"\")\n+        .optflag(\"h\", \"help\", \"show this message\")\n+        .reqopt(\"\", \"channel\", \"current Rust channel\", \"CHANNEL\")\n+        .optflag(\"\", \"git-hash\", \"run tests which rely on commit version being compiled into the binaries\")\n+        .optopt(\"\", \"edition\", \"default Rust edition\", \"EDITION\");\n+\n+    let (argv0, args_) = args.split_first().unwrap();\n+    if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n+        let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n+        println!(\"{}\", opts.usage(&message));\n+        println!();\n+        panic!()\n+    }\n+\n+    let matches = &match opts.parse(args_) {\n+        Ok(m) => m,\n+        Err(f) => panic!(\"{:?}\", f),\n+    };\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n+        println!(\"{}\", opts.usage(&message));\n+        println!();\n+        panic!()\n+    }\n+\n+    fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n+        match m.opt_str(nm) {\n+            Some(s) => PathBuf::from(&s),\n+            None => panic!(\"no option (=path) found for {}\", nm),\n+        }\n+    }\n+\n+    fn make_absolute(path: PathBuf) -> PathBuf {\n+        if path.is_relative() { env::current_dir().unwrap().join(path) } else { path }\n+    }\n+\n+    let target = opt_str2(matches.opt_str(\"target\"));\n+    let android_cross_path = opt_path(matches, \"android-cross-path\");\n+    let (cdb, cdb_version) = analyze_cdb(matches.opt_str(\"cdb\"), &target);\n+    let (gdb, gdb_version, gdb_native_rust) =\n+        analyze_gdb(matches.opt_str(\"gdb\"), &target, &android_cross_path);\n+    let (lldb_version, lldb_native_rust) = matches\n+        .opt_str(\"lldb-version\")\n+        .as_deref()\n+        .and_then(extract_lldb_version)\n+        .map(|(v, b)| (Some(v), b))\n+        .unwrap_or((None, false));\n+    let color = match matches.opt_str(\"color\").as_deref() {\n+        Some(\"auto\") | None => ColorConfig::AutoColor,\n+        Some(\"always\") => ColorConfig::AlwaysColor,\n+        Some(\"never\") => ColorConfig::NeverColor,\n+        Some(x) => panic!(\"argument for --color must be auto, always, or never, but found `{}`\", x),\n+    };\n+    let llvm_version =\n+        matches.opt_str(\"llvm-version\").as_deref().and_then(header::extract_llvm_version).or_else(\n+            || header::extract_llvm_version_from_binary(&matches.opt_str(\"llvm-filecheck\")?),\n+        );\n+\n+    let src_base = opt_path(matches, \"src-base\");\n+    let run_ignored = matches.opt_present(\"ignored\");\n+    let mode = matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\");\n+    let has_tidy = if mode == Mode::Rustdoc {\n+        Command::new(\"tidy\")\n+            .arg(\"--version\")\n+            .stdout(Stdio::null())\n+            .status()\n+            .map_or(false, |status| status.success())\n+    } else {\n+        // Avoid spawning an external command when we know tidy won't be used.\n+        false\n+    };\n+    Config {\n+        bless: matches.opt_present(\"bless\"),\n+        compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n+        run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n+        rustc_path: opt_path(matches, \"rustc-path\"),\n+        rustdoc_path: matches.opt_str(\"rustdoc-path\").map(PathBuf::from),\n+        rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n+        python: matches.opt_str(\"python\").unwrap(),\n+        jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n+        jsondoclint_path: matches.opt_str(\"jsondoclint-path\"),\n+        valgrind_path: matches.opt_str(\"valgrind-path\"),\n+        force_valgrind: matches.opt_present(\"force-valgrind\"),\n+        run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),\n+        llvm_filecheck: matches.opt_str(\"llvm-filecheck\").map(PathBuf::from),\n+        llvm_bin_dir: matches.opt_str(\"llvm-bin-dir\").map(PathBuf::from),\n+        src_base,\n+        build_base: opt_path(matches, \"build-base\"),\n+        sysroot_base: opt_path(matches, \"sysroot-base\"),\n+        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n+        mode,\n+        suite: matches.opt_str(\"suite\").unwrap(),\n+        debugger: None,\n+        run_ignored,\n+        filters: matches.free.clone(),\n+        skip: matches.opt_strs(\"skip\"),\n+        filter_exact: matches.opt_present(\"exact\"),\n+        force_pass_mode: matches.opt_str(\"pass\").map(|mode| {\n+            mode.parse::<PassMode>()\n+                .unwrap_or_else(|_| panic!(\"unknown `--pass` option `{}` given\", mode))\n+        }),\n+        run: matches.opt_str(\"run\").and_then(|mode| match mode.as_str() {\n+            \"auto\" => None,\n+            \"always\" => Some(true),\n+            \"never\" => Some(false),\n+            _ => panic!(\"unknown `--run` option `{}` given\", mode),\n+        }),\n+        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n+        runtool: matches.opt_str(\"runtool\"),\n+        host_rustcflags: matches.opt_strs(\"host-rustcflags\"),\n+        target_rustcflags: matches.opt_strs(\"target-rustcflags\"),\n+        optimize_tests: matches.opt_present(\"optimize-tests\"),\n+        target,\n+        host: opt_str2(matches.opt_str(\"host\")),\n+        cdb,\n+        cdb_version,\n+        gdb,\n+        gdb_version,\n+        gdb_native_rust,\n+        lldb_version,\n+        lldb_native_rust,\n+        llvm_version,\n+        system_llvm: matches.opt_present(\"system-llvm\"),\n+        android_cross_path,\n+        adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n+        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n+        adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n+            && \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\"))\n+            && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n+        lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n+        verbose: matches.opt_present(\"verbose\"),\n+        format: match (matches.opt_present(\"quiet\"), matches.opt_present(\"json\")) {\n+            (true, true) => panic!(\"--quiet and --json are incompatible\"),\n+            (true, false) => test::OutputFormat::Terse,\n+            (false, true) => test::OutputFormat::Json,\n+            (false, false) => test::OutputFormat::Pretty,\n+        },\n+        only_modified: matches.opt_present(\"only-modified\"),\n+        color,\n+        remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n+        compare_mode: matches\n+            .opt_str(\"compare-mode\")\n+            .map(|s| s.parse().expect(\"invalid --compare-mode provided\")),\n+        rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n+        has_tidy,\n+        channel: matches.opt_str(\"channel\").unwrap(),\n+        git_hash: matches.opt_present(\"git-hash\"),\n+        edition: matches.opt_str(\"edition\"),\n+\n+        cc: matches.opt_str(\"cc\").unwrap(),\n+        cxx: matches.opt_str(\"cxx\").unwrap(),\n+        cflags: matches.opt_str(\"cflags\").unwrap(),\n+        cxxflags: matches.opt_str(\"cxxflags\").unwrap(),\n+        ar: matches.opt_str(\"ar\").unwrap_or_else(|| String::from(\"ar\")),\n+        target_linker: matches.opt_str(\"target-linker\"),\n+        host_linker: matches.opt_str(\"host-linker\"),\n+        llvm_components: matches.opt_str(\"llvm-components\").unwrap(),\n+        nodejs: matches.opt_str(\"nodejs\"),\n+        npm: matches.opt_str(\"npm\"),\n+\n+        force_rerun: matches.opt_present(\"force-rerun\"),\n+\n+        target_cfgs: AtomicLazyCell::new(),\n+\n+        nocapture: matches.opt_present(\"nocapture\"),\n+    }\n+}\n+\n+pub fn log_config(config: &Config) {\n+    let c = config;\n+    logv(c, \"configuration:\".to_string());\n+    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n+    logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n+    logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n+    logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n+    logv(c, format!(\"rust_demangler_path: {:?}\", config.rust_demangler_path));\n+    logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n+    logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n+    logv(c, format!(\"stage_id: {}\", config.stage_id));\n+    logv(c, format!(\"mode: {}\", config.mode));\n+    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n+    logv(c, format!(\"filters: {:?}\", config.filters));\n+    logv(c, format!(\"skip: {:?}\", config.skip));\n+    logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n+    logv(\n+        c,\n+        format!(\"force_pass_mode: {}\", opt_str(&config.force_pass_mode.map(|m| format!(\"{}\", m))),),\n+    );\n+    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n+    logv(c, format!(\"host-rustcflags: {:?}\", config.host_rustcflags));\n+    logv(c, format!(\"target-rustcflags: {:?}\", config.target_rustcflags));\n+    logv(c, format!(\"target: {}\", config.target));\n+    logv(c, format!(\"host: {}\", config.host));\n+    logv(c, format!(\"android-cross-path: {:?}\", config.android_cross_path.display()));\n+    logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n+    logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n+    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n+    logv(c, format!(\"ar: {}\", config.ar));\n+    logv(c, format!(\"target-linker: {:?}\", config.target_linker));\n+    logv(c, format!(\"host-linker: {:?}\", config.host_linker));\n+    logv(c, format!(\"verbose: {}\", config.verbose));\n+    logv(c, format!(\"format: {:?}\", config.format));\n+    logv(c, \"\\n\".to_string());\n+}\n+\n+pub fn opt_str(maybestr: &Option<String>) -> &str {\n+    match *maybestr {\n+        None => \"(none)\",\n+        Some(ref s) => s,\n+    }\n+}\n+\n+pub fn opt_str2(maybestr: Option<String>) -> String {\n+    match maybestr {\n+        None => \"(none)\".to_owned(),\n+        Some(s) => s,\n+    }\n+}\n+\n+pub fn run_tests(config: Arc<Config>) {\n+    // If we want to collect rustfix coverage information,\n+    // we first make sure that the coverage file does not exist.\n+    // It will be created later on.\n+    if config.rustfix_coverage {\n+        let mut coverage_file_path = config.build_base.clone();\n+        coverage_file_path.push(\"rustfix_missing_coverage.txt\");\n+        if coverage_file_path.exists() {\n+            if let Err(e) = fs::remove_file(&coverage_file_path) {\n+                panic!(\"Could not delete {} due to {}\", coverage_file_path.display(), e)\n+            }\n+        }\n+    }\n+\n+    // sadly osx needs some file descriptor limits raised for running tests in\n+    // parallel (especially when we have lots and lots of child processes).\n+    // For context, see #8904\n+    unsafe {\n+        raise_fd_limit::raise_fd_limit();\n+    }\n+    // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n+    // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n+    env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n+\n+    // Let tests know which target they're running as\n+    env::set_var(\"TARGET\", &config.target);\n+\n+    let opts = test_opts(&config);\n+\n+    let mut configs = Vec::new();\n+    if let Mode::DebugInfo = config.mode {\n+        // Debugging emscripten code doesn't make sense today\n+        if !config.target.contains(\"emscripten\") {\n+            configs.extend(configure_cdb(&config));\n+            configs.extend(configure_gdb(&config));\n+            configs.extend(configure_lldb(&config));\n+        }\n+    } else {\n+        configs.push(config.clone());\n+    };\n+\n+    let mut tests = Vec::new();\n+    for c in configs {\n+        let mut found_paths = BTreeSet::new();\n+        make_tests(c, &mut tests, &mut found_paths);\n+        check_overlapping_tests(&found_paths);\n+    }\n+\n+    tests.sort_by(|a, b| a.desc.name.as_slice().cmp(&b.desc.name.as_slice()));\n+\n+    let res = test::run_tests_console(&opts, tests);\n+    match res {\n+        Ok(true) => {}\n+        Ok(false) => {\n+            // We want to report that the tests failed, but we also want to give\n+            // some indication of just what tests we were running. Especially on\n+            // CI, where there can be cross-compiled tests for a lot of\n+            // architectures, without this critical information it can be quite\n+            // easy to miss which tests failed, and as such fail to reproduce\n+            // the failure locally.\n+\n+            println!(\n+                \"Some tests failed in compiletest suite={}{} mode={} host={} target={}\",\n+                config.suite,\n+                config\n+                    .compare_mode\n+                    .as_ref()\n+                    .map(|c| format!(\" compare_mode={:?}\", c))\n+                    .unwrap_or_default(),\n+                config.mode,\n+                config.host,\n+                config.target\n+            );\n+\n+            std::process::exit(1);\n+        }\n+        Err(e) => {\n+            // We don't know if tests passed or not, but if there was an error\n+            // during testing we don't want to just succeed (we may not have\n+            // tested something), so fail.\n+            //\n+            // This should realistically \"never\" happen, so don't try to make\n+            // this a pretty error message.\n+            panic!(\"I/O failure during tests: {:?}\", e);\n+        }\n+    }\n+}\n+\n+fn configure_cdb(config: &Config) -> Option<Arc<Config>> {\n+    config.cdb.as_ref()?;\n+\n+    Some(Arc::new(Config { debugger: Some(Debugger::Cdb), ..config.clone() }))\n+}\n+\n+fn configure_gdb(config: &Config) -> Option<Arc<Config>> {\n+    config.gdb_version?;\n+\n+    if config.matches_env(\"msvc\") {\n+        return None;\n+    }\n+\n+    if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n+        println!(\n+            \"WARNING: debuginfo tests are not available when \\\n+             testing with remote\"\n+        );\n+        return None;\n+    }\n+\n+    if config.target.contains(\"android\") {\n+        println!(\n+            \"{} debug-info test uses tcp 5039 port.\\\n+             please reserve it\",\n+            config.target\n+        );\n+\n+        // android debug-info test uses remote debugger so, we test 1 thread\n+        // at once as they're all sharing the same TCP port to communicate\n+        // over.\n+        //\n+        // we should figure out how to lift this restriction! (run them all\n+        // on different ports allocated dynamically).\n+        env::set_var(\"RUST_TEST_THREADS\", \"1\");\n+    }\n+\n+    Some(Arc::new(Config { debugger: Some(Debugger::Gdb), ..config.clone() }))\n+}\n+\n+fn configure_lldb(config: &Config) -> Option<Arc<Config>> {\n+    config.lldb_python_dir.as_ref()?;\n+\n+    if let Some(350) = config.lldb_version {\n+        println!(\n+            \"WARNING: The used version of LLDB (350) has a \\\n+             known issue that breaks debuginfo tests. See \\\n+             issue #32520 for more information. Skipping all \\\n+             LLDB-based tests!\",\n+        );\n+        return None;\n+    }\n+\n+    Some(Arc::new(Config { debugger: Some(Debugger::Lldb), ..config.clone() }))\n+}\n+\n+pub fn test_opts(config: &Config) -> test::TestOpts {\n+    if env::var(\"RUST_TEST_NOCAPTURE\").is_ok() {\n+        eprintln!(\n+            \"WARNING: RUST_TEST_NOCAPTURE is no longer used. \\\n+                   Use the `--nocapture` flag instead.\"\n+        );\n+    }\n+\n+    test::TestOpts {\n+        exclude_should_panic: false,\n+        filters: config.filters.clone(),\n+        filter_exact: config.filter_exact,\n+        run_ignored: if config.run_ignored { test::RunIgnored::Yes } else { test::RunIgnored::No },\n+        format: config.format,\n+        logfile: config.logfile.clone(),\n+        run_tests: true,\n+        bench_benchmarks: true,\n+        nocapture: config.nocapture,\n+        color: config.color,\n+        shuffle: false,\n+        shuffle_seed: None,\n+        test_threads: None,\n+        skip: config.skip.clone(),\n+        list: false,\n+        options: test::Options::new(),\n+        time_options: None,\n+        force_run_in_process: false,\n+        fail_fast: std::env::var_os(\"RUSTC_TEST_FAIL_FAST\").is_some(),\n+    }\n+}\n+\n+pub fn make_tests(\n+    config: Arc<Config>,\n+    tests: &mut Vec<test::TestDescAndFn>,\n+    found_paths: &mut BTreeSet<PathBuf>,\n+) {\n+    debug!(\"making tests from {:?}\", config.src_base.display());\n+    let inputs = common_inputs_stamp(&config);\n+    let modified_tests = modified_tests(&config, &config.src_base).unwrap_or_else(|err| {\n+        panic!(\"modified_tests got error from dir: {}, error: {}\", config.src_base.display(), err)\n+    });\n+\n+    let cache = HeadersCache::load(&config);\n+    let mut poisoned = false;\n+    collect_tests_from_dir(\n+        config.clone(),\n+        &cache,\n+        &config.src_base,\n+        &PathBuf::new(),\n+        &inputs,\n+        tests,\n+        found_paths,\n+        &modified_tests,\n+        &mut poisoned,\n+    )\n+    .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n+\n+    if poisoned {\n+        eprintln!();\n+        panic!(\"there are errors in tests\");\n+    }\n+}\n+\n+/// Returns a stamp constructed from input files common to all test cases.\n+fn common_inputs_stamp(config: &Config) -> Stamp {\n+    let rust_src_dir = config.find_rust_src_root().expect(\"Could not find Rust source root\");\n+\n+    let mut stamp = Stamp::from_path(&config.rustc_path);\n+\n+    // Relevant pretty printer files\n+    let pretty_printer_files = [\n+        \"src/etc/rust_types.py\",\n+        \"src/etc/gdb_load_rust_pretty_printers.py\",\n+        \"src/etc/gdb_lookup.py\",\n+        \"src/etc/gdb_providers.py\",\n+        \"src/etc/lldb_batchmode.py\",\n+        \"src/etc/lldb_lookup.py\",\n+        \"src/etc/lldb_providers.py\",\n+    ];\n+    for file in &pretty_printer_files {\n+        let path = rust_src_dir.join(file);\n+        stamp.add_path(&path);\n+    }\n+\n+    stamp.add_dir(&rust_src_dir.join(\"src/etc/natvis\"));\n+\n+    stamp.add_dir(&config.run_lib_path);\n+\n+    if let Some(ref rustdoc_path) = config.rustdoc_path {\n+        stamp.add_path(&rustdoc_path);\n+        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n+    }\n+\n+    // Compiletest itself.\n+    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n+\n+    stamp\n+}\n+\n+fn modified_tests(config: &Config, dir: &Path) -> Result<Vec<PathBuf>, String> {\n+    if !config.only_modified {\n+        return Ok(vec![]);\n+    }\n+    let files =\n+        get_git_modified_files(Some(dir), &vec![\"rs\", \"stderr\", \"fixed\"])?.unwrap_or(vec![]);\n+    // Add new test cases to the list, it will be convenient in daily development.\n+    let untracked_files = get_git_untracked_files(None)?.unwrap_or(vec![]);\n+\n+    let all_paths = [&files[..], &untracked_files[..]].concat();\n+    let full_paths = {\n+        let mut full_paths: Vec<PathBuf> = all_paths\n+            .into_iter()\n+            .map(|f| PathBuf::from(f).with_extension(\"\").with_extension(\"rs\"))\n+            .filter_map(|f| if Path::new(&f).exists() { f.canonicalize().ok() } else { None })\n+            .collect();\n+        full_paths.dedup();\n+        full_paths.sort_unstable();\n+        full_paths\n+    };\n+    Ok(full_paths)\n+}\n+\n+fn collect_tests_from_dir(\n+    config: Arc<Config>,\n+    cache: &HeadersCache,\n+    dir: &Path,\n+    relative_dir_path: &Path,\n+    inputs: &Stamp,\n+    tests: &mut Vec<test::TestDescAndFn>,\n+    found_paths: &mut BTreeSet<PathBuf>,\n+    modified_tests: &Vec<PathBuf>,\n+    poisoned: &mut bool,\n+) -> io::Result<()> {\n+    // Ignore directories that contain a file named `compiletest-ignore-dir`.\n+    if dir.join(\"compiletest-ignore-dir\").exists() {\n+        return Ok(());\n+    }\n+\n+    if config.mode == Mode::RunMake && dir.join(\"Makefile\").exists() {\n+        let paths = TestPaths {\n+            file: dir.to_path_buf(),\n+            relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n+        };\n+        tests.extend(make_test(config, cache, &paths, inputs, poisoned));\n+        return Ok(());\n+    }\n+\n+    // If we find a test foo/bar.rs, we have to build the\n+    // output directory `$build/foo` so we can write\n+    // `$build/foo/bar` into it. We do this *now* in this\n+    // sequential loop because otherwise, if we do it in the\n+    // tests themselves, they race for the privilege of\n+    // creating the directories and sometimes fail randomly.\n+    let build_dir = output_relative_path(&config, relative_dir_path);\n+    fs::create_dir_all(&build_dir).unwrap();\n+\n+    // Add each `.rs` file as a test, and recurse further on any\n+    // subdirectories we find, except for `aux` directories.\n+    for file in fs::read_dir(dir)? {\n+        let file = file?;\n+        let file_path = file.path();\n+        let file_name = file.file_name();\n+        if is_test(&file_name) && (!config.only_modified || modified_tests.contains(&file_path)) {\n+            debug!(\"found test file: {:?}\", file_path.display());\n+            let rel_test_path = relative_dir_path.join(file_path.file_stem().unwrap());\n+            found_paths.insert(rel_test_path);\n+            let paths =\n+                TestPaths { file: file_path, relative_dir: relative_dir_path.to_path_buf() };\n+\n+            tests.extend(make_test(config.clone(), cache, &paths, inputs, poisoned))\n+        } else if file_path.is_dir() {\n+            let relative_file_path = relative_dir_path.join(file.file_name());\n+            if &file_name != \"auxiliary\" {\n+                debug!(\"found directory: {:?}\", file_path.display());\n+                collect_tests_from_dir(\n+                    config.clone(),\n+                    cache,\n+                    &file_path,\n+                    &relative_file_path,\n+                    inputs,\n+                    tests,\n+                    found_paths,\n+                    modified_tests,\n+                    poisoned,\n+                )?;\n+            }\n+        } else {\n+            debug!(\"found other file/directory: {:?}\", file_path.display());\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// Returns true if `file_name` looks like a proper test file name.\n+pub fn is_test(file_name: &OsString) -> bool {\n+    let file_name = file_name.to_str().unwrap();\n+\n+    if !file_name.ends_with(\".rs\") {\n+        return false;\n+    }\n+\n+    // `.`, `#`, and `~` are common temp-file prefixes.\n+    let invalid_prefixes = &[\".\", \"#\", \"~\"];\n+    !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n+}\n+\n+fn make_test(\n+    config: Arc<Config>,\n+    cache: &HeadersCache,\n+    testpaths: &TestPaths,\n+    inputs: &Stamp,\n+    poisoned: &mut bool,\n+) -> Vec<test::TestDescAndFn> {\n+    let test_path = if config.mode == Mode::RunMake {\n+        // Parse directives in the Makefile\n+        testpaths.file.join(\"Makefile\")\n+    } else {\n+        PathBuf::from(&testpaths.file)\n+    };\n+    let early_props = EarlyProps::from_file(&config, &test_path);\n+\n+    // Incremental tests are special, they inherently cannot be run in parallel.\n+    // `runtest::run` will be responsible for iterating over revisions.\n+    let revisions = if early_props.revisions.is_empty() || config.mode == Mode::Incremental {\n+        vec![None]\n+    } else {\n+        early_props.revisions.iter().map(Some).collect()\n+    };\n+\n+    revisions\n+        .into_iter()\n+        .map(|revision| {\n+            let src_file =\n+                std::fs::File::open(&test_path).expect(\"open test file to parse ignores\");\n+            let cfg = revision.map(|v| &**v);\n+            let test_name = crate::make_test_name(&config, testpaths, revision);\n+            let mut desc = make_test_description(\n+                &config, cache, test_name, &test_path, src_file, cfg, poisoned,\n+            );\n+            // Ignore tests that already run and are up to date with respect to inputs.\n+            if !config.force_rerun {\n+                desc.ignore |= is_up_to_date(\n+                    &config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                    inputs,\n+                );\n+            }\n+            test::TestDescAndFn {\n+                desc,\n+                testfn: make_test_closure(config.clone(), testpaths, revision),\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_base_dir(config, testpaths, revision).join(\"stamp\")\n+}\n+\n+fn files_related_to_test(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    props: &EarlyProps,\n+    revision: Option<&str>,\n+) -> Vec<PathBuf> {\n+    let mut related = vec![];\n+\n+    if testpaths.file.is_dir() {\n+        // run-make tests use their individual directory\n+        for entry in WalkDir::new(&testpaths.file) {\n+            let path = entry.unwrap().into_path();\n+            if path.is_file() {\n+                related.push(path);\n+            }\n+        }\n+    } else {\n+        related.push(testpaths.file.clone());\n+    }\n+\n+    for aux in &props.aux {\n+        let path = testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux);\n+        related.push(path);\n+    }\n+\n+    // UI test files.\n+    for extension in UI_EXTENSIONS {\n+        let path = expected_output_path(testpaths, revision, &config.compare_mode, extension);\n+        related.push(path);\n+    }\n+\n+    related\n+}\n+\n+fn is_up_to_date(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    props: &EarlyProps,\n+    revision: Option<&str>,\n+    inputs: &Stamp,\n+) -> bool {\n+    let stamp_name = stamp(config, testpaths, revision);\n+    // Check hash.\n+    let contents = match fs::read_to_string(&stamp_name) {\n+        Ok(f) => f,\n+        Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n+        Err(_) => return false,\n+    };\n+    let expected_hash = runtest::compute_stamp_hash(config);\n+    if contents != expected_hash {\n+        return false;\n+    }\n+\n+    // Check timestamps.\n+    let mut inputs = inputs.clone();\n+    for path in files_related_to_test(config, testpaths, props, revision) {\n+        inputs.add_path(&path);\n+    }\n+\n+    inputs < Stamp::from_path(&stamp_name)\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+struct Stamp {\n+    time: SystemTime,\n+}\n+\n+impl Stamp {\n+    fn from_path(path: &Path) -> Self {\n+        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n+        stamp.add_path(path);\n+        stamp\n+    }\n+\n+    fn add_path(&mut self, path: &Path) {\n+        let modified = fs::metadata(path)\n+            .and_then(|metadata| metadata.modified())\n+            .unwrap_or(SystemTime::UNIX_EPOCH);\n+        self.time = self.time.max(modified);\n+    }\n+\n+    fn add_dir(&mut self, path: &Path) {\n+        for entry in WalkDir::new(path) {\n+            let entry = entry.unwrap();\n+            if entry.file_type().is_file() {\n+                let modified = entry\n+                    .metadata()\n+                    .ok()\n+                    .and_then(|metadata| metadata.modified().ok())\n+                    .unwrap_or(SystemTime::UNIX_EPOCH);\n+                self.time = self.time.max(modified);\n+            }\n+        }\n+    }\n+}\n+\n+fn make_test_name(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestName {\n+    // Print the name of the file, relative to the repository root.\n+    // `src_base` looks like `/path/to/rust/tests/ui`\n+    let root_directory = config.src_base.parent().unwrap().parent().unwrap();\n+    let path = testpaths.file.strip_prefix(root_directory).unwrap();\n+    let debugger = match config.debugger {\n+        Some(d) => format!(\"-{}\", d),\n+        None => String::new(),\n+    };\n+    let mode_suffix = match config.compare_mode {\n+        Some(ref mode) => format!(\" ({})\", mode.to_str()),\n+        None => String::new(),\n+    };\n+\n+    test::DynTestName(format!(\n+        \"[{}{}{}] {}{}\",\n+        config.mode,\n+        debugger,\n+        mode_suffix,\n+        path.display(),\n+        revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n+    ))\n+}\n+\n+fn make_test_closure(\n+    config: Arc<Config>,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestFn {\n+    let config = config.clone();\n+    let testpaths = testpaths.clone();\n+    let revision = revision.cloned();\n+    test::DynTestFn(Box::new(move || {\n+        runtest::run(config, &testpaths, revision.as_deref());\n+        Ok(())\n+    }))\n+}\n+\n+/// Returns `true` if the given target is an Android target for the\n+/// purposes of GDB testing.\n+fn is_android_gdb_target(target: &str) -> bool {\n+    matches!(\n+        &target[..],\n+        \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\"\n+    )\n+}\n+\n+/// Returns `true` if the given target is a MSVC target for the purpouses of CDB testing.\n+fn is_pc_windows_msvc_target(target: &str) -> bool {\n+    target.ends_with(\"-pc-windows-msvc\")\n+}\n+\n+fn find_cdb(target: &str) -> Option<OsString> {\n+    if !(cfg!(windows) && is_pc_windows_msvc_target(target)) {\n+        return None;\n+    }\n+\n+    let pf86 = env::var_os(\"ProgramFiles(x86)\").or_else(|| env::var_os(\"ProgramFiles\"))?;\n+    let cdb_arch = if cfg!(target_arch = \"x86\") {\n+        \"x86\"\n+    } else if cfg!(target_arch = \"x86_64\") {\n+        \"x64\"\n+    } else if cfg!(target_arch = \"aarch64\") {\n+        \"arm64\"\n+    } else if cfg!(target_arch = \"arm\") {\n+        \"arm\"\n+    } else {\n+        return None; // No compatible CDB.exe in the Windows 10 SDK\n+    };\n+\n+    let mut path = PathBuf::new();\n+    path.push(pf86);\n+    path.push(r\"Windows Kits\\10\\Debuggers\"); // We could check 8.1 etc. too?\n+    path.push(cdb_arch);\n+    path.push(r\"cdb.exe\");\n+\n+    if !path.exists() {\n+        return None;\n+    }\n+\n+    Some(path.into_os_string())\n+}\n+\n+/// Returns Path to CDB\n+fn analyze_cdb(cdb: Option<String>, target: &str) -> (Option<OsString>, Option<[u16; 4]>) {\n+    let cdb = cdb.map(OsString::from).or_else(|| find_cdb(target));\n+\n+    let mut version = None;\n+    if let Some(cdb) = cdb.as_ref() {\n+        if let Ok(output) = Command::new(cdb).arg(\"/version\").output() {\n+            if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n+                version = extract_cdb_version(&first_line);\n+            }\n+        }\n+    }\n+\n+    (cdb, version)\n+}\n+\n+fn extract_cdb_version(full_version_line: &str) -> Option<[u16; 4]> {\n+    // Example full_version_line: \"cdb version 10.0.18362.1\"\n+    let version = full_version_line.rsplit(' ').next()?;\n+    let mut components = version.split('.');\n+    let major: u16 = components.next().unwrap().parse().unwrap();\n+    let minor: u16 = components.next().unwrap().parse().unwrap();\n+    let patch: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n+    let build: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n+    Some([major, minor, patch, build])\n+}\n+\n+/// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n+fn analyze_gdb(\n+    gdb: Option<String>,\n+    target: &str,\n+    android_cross_path: &PathBuf,\n+) -> (Option<String>, Option<u32>, bool) {\n+    #[cfg(not(windows))]\n+    const GDB_FALLBACK: &str = \"gdb\";\n+    #[cfg(windows)]\n+    const GDB_FALLBACK: &str = \"gdb.exe\";\n+\n+    const MIN_GDB_WITH_RUST: u32 = 7011010;\n+\n+    let fallback_gdb = || {\n+        if is_android_gdb_target(target) {\n+            let mut gdb_path = match android_cross_path.to_str() {\n+                Some(x) => x.to_owned(),\n+                None => panic!(\"cannot find android cross path\"),\n+            };\n+            gdb_path.push_str(\"/bin/gdb\");\n+            gdb_path\n+        } else {\n+            GDB_FALLBACK.to_owned()\n+        }\n+    };\n+\n+    let gdb = match gdb {\n+        None => fallback_gdb(),\n+        Some(ref s) if s.is_empty() => fallback_gdb(), // may be empty if configure found no gdb\n+        Some(ref s) => s.to_owned(),\n+    };\n+\n+    let mut version_line = None;\n+    if let Ok(output) = Command::new(&gdb).arg(\"--version\").output() {\n+        if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n+            version_line = Some(first_line.to_string());\n+        }\n+    }\n+\n+    let version = match version_line {\n+        Some(line) => extract_gdb_version(&line),\n+        None => return (None, None, false),\n+    };\n+\n+    let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n+\n+    (Some(gdb), version, gdb_native_rust)\n+}\n+\n+fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n+    let full_version_line = full_version_line.trim();\n+\n+    // GDB versions look like this: \"major.minor.patch?.yyyymmdd?\", with both\n+    // of the ? sections being optional\n+\n+    // We will parse up to 3 digits for each component, ignoring the date\n+\n+    // We skip text in parentheses.  This avoids accidentally parsing\n+    // the openSUSE version, which looks like:\n+    //  GNU gdb (GDB; openSUSE Leap 15.0) 8.1\n+    // This particular form is documented in the GNU coding standards:\n+    // https://www.gnu.org/prep/standards/html_node/_002d_002dversion.html#g_t_002d_002dversion\n+\n+    let unbracketed_part = full_version_line.split('[').next().unwrap();\n+    let mut splits = unbracketed_part.trim_end().rsplit(' ');\n+    let version_string = splits.next().unwrap();\n+\n+    let mut splits = version_string.split('.');\n+    let major = splits.next().unwrap();\n+    let minor = splits.next().unwrap();\n+    let patch = splits.next();\n+\n+    let major: u32 = major.parse().unwrap();\n+    let (minor, patch): (u32, u32) = match minor.find(not_a_digit) {\n+        None => {\n+            let minor = minor.parse().unwrap();\n+            let patch: u32 = match patch {\n+                Some(patch) => match patch.find(not_a_digit) {\n+                    None => patch.parse().unwrap(),\n+                    Some(idx) if idx > 3 => 0,\n+                    Some(idx) => patch[..idx].parse().unwrap(),\n+                },\n+                None => 0,\n+            };\n+            (minor, patch)\n+        }\n+        // There is no patch version after minor-date (e.g. \"4-2012\").\n+        Some(idx) => {\n+            let minor = minor[..idx].parse().unwrap();\n+            (minor, 0)\n+        }\n+    };\n+\n+    Some(((major * 1000) + minor) * 1000 + patch)\n+}\n+\n+/// Returns (LLDB version, LLDB is rust-enabled)\n+fn extract_lldb_version(full_version_line: &str) -> Option<(u32, bool)> {\n+    // Extract the major LLDB version from the given version string.\n+    // LLDB version strings are different for Apple and non-Apple platforms.\n+    // The Apple variant looks like this:\n+    //\n+    // LLDB-179.5 (older versions)\n+    // lldb-300.2.51 (new versions)\n+    //\n+    // We are only interested in the major version number, so this function\n+    // will return `Some(179)` and `Some(300)` respectively.\n+    //\n+    // Upstream versions look like:\n+    // lldb version 6.0.1\n+    //\n+    // There doesn't seem to be a way to correlate the Apple version\n+    // with the upstream version, and since the tests were originally\n+    // written against Apple versions, we make a fake Apple version by\n+    // multiplying the first number by 100.  This is a hack, but\n+    // normally fine because the only non-Apple version we test is\n+    // rust-enabled.\n+\n+    let full_version_line = full_version_line.trim();\n+\n+    if let Some(apple_ver) =\n+        full_version_line.strip_prefix(\"LLDB-\").or_else(|| full_version_line.strip_prefix(\"lldb-\"))\n+    {\n+        if let Some(idx) = apple_ver.find(not_a_digit) {\n+            let version: u32 = apple_ver[..idx].parse().unwrap();\n+            return Some((version, full_version_line.contains(\"rust-enabled\")));\n+        }\n+    } else if let Some(lldb_ver) = full_version_line.strip_prefix(\"lldb version \") {\n+        if let Some(idx) = lldb_ver.find(not_a_digit) {\n+            let version: u32 = lldb_ver[..idx].parse().ok()?;\n+            return Some((version * 100, full_version_line.contains(\"rust-enabled\")));\n+        }\n+    }\n+    None\n+}\n+\n+fn not_a_digit(c: char) -> bool {\n+    !c.is_digit(10)\n+}\n+\n+fn check_overlapping_tests(found_paths: &BTreeSet<PathBuf>) {\n+    let mut collisions = Vec::new();\n+    for path in found_paths {\n+        for ancestor in path.ancestors().skip(1) {\n+            if found_paths.contains(ancestor) {\n+                collisions.push((path, ancestor.clone()));\n+            }\n+        }\n+    }\n+    if !collisions.is_empty() {\n+        let collisions: String = collisions\n+            .into_iter()\n+            .map(|(path, check_parent)| format!(\"test {path:?} clashes with {check_parent:?}\\n\"))\n+            .collect();\n+        panic!(\n+            \"{collisions}\\n\\\n+            Tests cannot have overlapping names. Make sure they use unique prefixes.\"\n+        );\n+    }\n+}"}, {"sha": "34d48559c378da12748c63c7e0421b7bfd3d82cd", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 1135, "changes": 1137, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,45 +1,6 @@\n-#![crate_name = \"compiletest\"]\n-// The `test` crate is the only unstable feature\n-// allowed here, just to share similar code.\n-#![feature(test)]\n+use std::{env, sync::Arc};\n \n-extern crate test;\n-\n-use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n-use crate::common::{Config, Debugger, Mode, PassMode, TestPaths};\n-use crate::util::logv;\n-use build_helper::git::{get_git_modified_files, get_git_untracked_files};\n-use core::panic;\n-use getopts::Options;\n-use lazycell::AtomicLazyCell;\n-use std::collections::BTreeSet;\n-use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, ErrorKind};\n-use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio};\n-use std::time::SystemTime;\n-use std::{env, vec};\n-use test::ColorConfig;\n-use tracing::*;\n-use walkdir::WalkDir;\n-\n-use self::header::{make_test_description, EarlyProps};\n-use crate::header::HeadersCache;\n-use std::sync::Arc;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-pub mod common;\n-pub mod compute_diff;\n-pub mod errors;\n-pub mod header;\n-mod json;\n-mod raise_fd_limit;\n-mod read2;\n-pub mod runtest;\n-pub mod util;\n+use compiletest::{common::Mode, log_config, parse_config, run_tests};\n \n fn main() {\n     tracing_subscriber::fmt::init();\n@@ -57,1097 +18,3 @@ fn main() {\n     log_config(&config);\n     run_tests(config);\n }\n-\n-pub fn parse_config(args: Vec<String>) -> Config {\n-    let mut opts = Options::new();\n-    opts.reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\")\n-        .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n-        .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n-        .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n-        .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n-        .reqopt(\"\", \"python\", \"path to python to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"jsondoclint-path\", \"path to jsondoclint to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n-        .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n-        .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n-        .optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\")\n-        .reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\")\n-        .reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\")\n-        .reqopt(\"\", \"sysroot-base\", \"directory containing the compiler sysroot\", \"PATH\")\n-        .reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\")\n-        .reqopt(\n-            \"\",\n-            \"mode\",\n-            \"which sort of compile tests to run\",\n-            \"run-pass-valgrind | pretty | debug-info | codegen | rustdoc \\\n-            | rustdoc-json | codegen-units | incremental | run-make | ui | js-doc-test | mir-opt | assembly\",\n-        )\n-        .reqopt(\n-            \"\",\n-            \"suite\",\n-            \"which suite of compile tests to run. used for nicer error reporting.\",\n-            \"SUITE\",\n-        )\n-        .optopt(\n-            \"\",\n-            \"pass\",\n-            \"force {check,build,run}-pass tests to this mode.\",\n-            \"check | build | run\",\n-        )\n-        .optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\")\n-        .optflag(\"\", \"ignored\", \"run tests marked as ignored\")\n-        .optmulti(\"\", \"skip\", \"skip tests matching SUBSTRING. Can be passed multiple times\", \"SUBSTRING\")\n-        .optflag(\"\", \"exact\", \"filters match exactly\")\n-        .optopt(\n-            \"\",\n-            \"runtool\",\n-            \"supervisor program to run tests under \\\n-             (eg. emulator, valgrind)\",\n-            \"PROGRAM\",\n-        )\n-        .optmulti(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\")\n-        .optmulti(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\")\n-        .optflag(\"\", \"optimize-tests\", \"run tests with optimizations enabled\")\n-        .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n-        .optflag(\n-            \"\",\n-            \"bless\",\n-            \"overwrite stderr/stdout files instead of complaining about a mismatch\",\n-        )\n-        .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n-        .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n-        .optflag(\"\", \"json\", \"emit json output instead of plaintext output\")\n-        .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n-        .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n-        .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n-        .optopt(\"\", \"cdb\", \"path to CDB to use for CDB debuginfo tests\", \"PATH\")\n-        .optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\")\n-        .optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\")\n-        .optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\")\n-        .optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\")\n-        .optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\")\n-        .optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\")\n-        .optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\")\n-        .optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\")\n-        .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n-        .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n-        .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n-        .reqopt(\"\", \"cxxflags\", \"flags for the CXX compiler\", \"FLAGS\")\n-        .optopt(\"\", \"ar\", \"path to an archiver\", \"PATH\")\n-        .optopt(\"\", \"target-linker\", \"path to a linker for the target\", \"PATH\")\n-        .optopt(\"\", \"host-linker\", \"path to a linker for the host\", \"PATH\")\n-        .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n-        .optopt(\"\", \"llvm-bin-dir\", \"Path to LLVM's `bin` directory\", \"PATH\")\n-        .optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\")\n-        .optopt(\"\", \"npm\", \"the name of npm\", \"PATH\")\n-        .optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\")\n-        .optopt(\n-            \"\",\n-            \"compare-mode\",\n-            \"mode describing what file the actual ui output will be compared to\",\n-            \"COMPARE MODE\",\n-        )\n-        .optflag(\n-            \"\",\n-            \"rustfix-coverage\",\n-            \"enable this to generate a Rustfix coverage file, which is saved in \\\n-            `./<build_base>/rustfix_missing_coverage.txt`\",\n-        )\n-        .optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\")\n-        .optflag(\"\", \"only-modified\", \"only run tests that result been modified\")\n-        .optflag(\"\", \"nocapture\", \"\")\n-        .optflag(\"h\", \"help\", \"show this message\")\n-        .reqopt(\"\", \"channel\", \"current Rust channel\", \"CHANNEL\")\n-        .optflag(\"\", \"git-hash\", \"run tests which rely on commit version being compiled into the binaries\")\n-        .optopt(\"\", \"edition\", \"default Rust edition\", \"EDITION\");\n-\n-    let (argv0, args_) = args.split_first().unwrap();\n-    if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n-        let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", opts.usage(&message));\n-        println!();\n-        panic!()\n-    }\n-\n-    let matches = &match opts.parse(args_) {\n-        Ok(m) => m,\n-        Err(f) => panic!(\"{:?}\", f),\n-    };\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", opts.usage(&message));\n-        println!();\n-        panic!()\n-    }\n-\n-    fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n-        match m.opt_str(nm) {\n-            Some(s) => PathBuf::from(&s),\n-            None => panic!(\"no option (=path) found for {}\", nm),\n-        }\n-    }\n-\n-    fn make_absolute(path: PathBuf) -> PathBuf {\n-        if path.is_relative() { env::current_dir().unwrap().join(path) } else { path }\n-    }\n-\n-    let target = opt_str2(matches.opt_str(\"target\"));\n-    let android_cross_path = opt_path(matches, \"android-cross-path\");\n-    let (cdb, cdb_version) = analyze_cdb(matches.opt_str(\"cdb\"), &target);\n-    let (gdb, gdb_version, gdb_native_rust) =\n-        analyze_gdb(matches.opt_str(\"gdb\"), &target, &android_cross_path);\n-    let (lldb_version, lldb_native_rust) = matches\n-        .opt_str(\"lldb-version\")\n-        .as_deref()\n-        .and_then(extract_lldb_version)\n-        .map(|(v, b)| (Some(v), b))\n-        .unwrap_or((None, false));\n-    let color = match matches.opt_str(\"color\").as_deref() {\n-        Some(\"auto\") | None => ColorConfig::AutoColor,\n-        Some(\"always\") => ColorConfig::AlwaysColor,\n-        Some(\"never\") => ColorConfig::NeverColor,\n-        Some(x) => panic!(\"argument for --color must be auto, always, or never, but found `{}`\", x),\n-    };\n-    let llvm_version =\n-        matches.opt_str(\"llvm-version\").as_deref().and_then(header::extract_llvm_version).or_else(\n-            || header::extract_llvm_version_from_binary(&matches.opt_str(\"llvm-filecheck\")?),\n-        );\n-\n-    let src_base = opt_path(matches, \"src-base\");\n-    let run_ignored = matches.opt_present(\"ignored\");\n-    let mode = matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\");\n-    let has_tidy = if mode == Mode::Rustdoc {\n-        Command::new(\"tidy\")\n-            .arg(\"--version\")\n-            .stdout(Stdio::null())\n-            .status()\n-            .map_or(false, |status| status.success())\n-    } else {\n-        // Avoid spawning an external command when we know tidy won't be used.\n-        false\n-    };\n-    Config {\n-        bless: matches.opt_present(\"bless\"),\n-        compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n-        run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n-        rustc_path: opt_path(matches, \"rustc-path\"),\n-        rustdoc_path: matches.opt_str(\"rustdoc-path\").map(PathBuf::from),\n-        rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n-        python: matches.opt_str(\"python\").unwrap(),\n-        jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n-        jsondoclint_path: matches.opt_str(\"jsondoclint-path\"),\n-        valgrind_path: matches.opt_str(\"valgrind-path\"),\n-        force_valgrind: matches.opt_present(\"force-valgrind\"),\n-        run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),\n-        llvm_filecheck: matches.opt_str(\"llvm-filecheck\").map(PathBuf::from),\n-        llvm_bin_dir: matches.opt_str(\"llvm-bin-dir\").map(PathBuf::from),\n-        src_base,\n-        build_base: opt_path(matches, \"build-base\"),\n-        sysroot_base: opt_path(matches, \"sysroot-base\"),\n-        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode,\n-        suite: matches.opt_str(\"suite\").unwrap(),\n-        debugger: None,\n-        run_ignored,\n-        filters: matches.free.clone(),\n-        skip: matches.opt_strs(\"skip\"),\n-        filter_exact: matches.opt_present(\"exact\"),\n-        force_pass_mode: matches.opt_str(\"pass\").map(|mode| {\n-            mode.parse::<PassMode>()\n-                .unwrap_or_else(|_| panic!(\"unknown `--pass` option `{}` given\", mode))\n-        }),\n-        run: matches.opt_str(\"run\").and_then(|mode| match mode.as_str() {\n-            \"auto\" => None,\n-            \"always\" => Some(true),\n-            \"never\" => Some(false),\n-            _ => panic!(\"unknown `--run` option `{}` given\", mode),\n-        }),\n-        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n-        runtool: matches.opt_str(\"runtool\"),\n-        host_rustcflags: matches.opt_strs(\"host-rustcflags\"),\n-        target_rustcflags: matches.opt_strs(\"target-rustcflags\"),\n-        optimize_tests: matches.opt_present(\"optimize-tests\"),\n-        target,\n-        host: opt_str2(matches.opt_str(\"host\")),\n-        cdb,\n-        cdb_version,\n-        gdb,\n-        gdb_version,\n-        gdb_native_rust,\n-        lldb_version,\n-        lldb_native_rust,\n-        llvm_version,\n-        system_llvm: matches.opt_present(\"system-llvm\"),\n-        android_cross_path,\n-        adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n-        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n-        adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n-            && \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\"))\n-            && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n-        lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n-        verbose: matches.opt_present(\"verbose\"),\n-        format: match (matches.opt_present(\"quiet\"), matches.opt_present(\"json\")) {\n-            (true, true) => panic!(\"--quiet and --json are incompatible\"),\n-            (true, false) => test::OutputFormat::Terse,\n-            (false, true) => test::OutputFormat::Json,\n-            (false, false) => test::OutputFormat::Pretty,\n-        },\n-        only_modified: matches.opt_present(\"only-modified\"),\n-        color,\n-        remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n-        compare_mode: matches\n-            .opt_str(\"compare-mode\")\n-            .map(|s| s.parse().expect(\"invalid --compare-mode provided\")),\n-        rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n-        has_tidy,\n-        channel: matches.opt_str(\"channel\").unwrap(),\n-        git_hash: matches.opt_present(\"git-hash\"),\n-        edition: matches.opt_str(\"edition\"),\n-\n-        cc: matches.opt_str(\"cc\").unwrap(),\n-        cxx: matches.opt_str(\"cxx\").unwrap(),\n-        cflags: matches.opt_str(\"cflags\").unwrap(),\n-        cxxflags: matches.opt_str(\"cxxflags\").unwrap(),\n-        ar: matches.opt_str(\"ar\").unwrap_or_else(|| String::from(\"ar\")),\n-        target_linker: matches.opt_str(\"target-linker\"),\n-        host_linker: matches.opt_str(\"host-linker\"),\n-        llvm_components: matches.opt_str(\"llvm-components\").unwrap(),\n-        nodejs: matches.opt_str(\"nodejs\"),\n-        npm: matches.opt_str(\"npm\"),\n-\n-        force_rerun: matches.opt_present(\"force-rerun\"),\n-\n-        target_cfgs: AtomicLazyCell::new(),\n-\n-        nocapture: matches.opt_present(\"nocapture\"),\n-    }\n-}\n-\n-pub fn log_config(config: &Config) {\n-    let c = config;\n-    logv(c, \"configuration:\".to_string());\n-    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n-    logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n-    logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n-    logv(c, format!(\"rust_demangler_path: {:?}\", config.rust_demangler_path));\n-    logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n-    logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n-    logv(c, format!(\"stage_id: {}\", config.stage_id));\n-    logv(c, format!(\"mode: {}\", config.mode));\n-    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filters: {:?}\", config.filters));\n-    logv(c, format!(\"skip: {:?}\", config.skip));\n-    logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n-    logv(\n-        c,\n-        format!(\"force_pass_mode: {}\", opt_str(&config.force_pass_mode.map(|m| format!(\"{}\", m))),),\n-    );\n-    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n-    logv(c, format!(\"host-rustcflags: {:?}\", config.host_rustcflags));\n-    logv(c, format!(\"target-rustcflags: {:?}\", config.target_rustcflags));\n-    logv(c, format!(\"target: {}\", config.target));\n-    logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {:?}\", config.android_cross_path.display()));\n-    logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n-    logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n-    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n-    logv(c, format!(\"ar: {}\", config.ar));\n-    logv(c, format!(\"target-linker: {:?}\", config.target_linker));\n-    logv(c, format!(\"host-linker: {:?}\", config.host_linker));\n-    logv(c, format!(\"verbose: {}\", config.verbose));\n-    logv(c, format!(\"format: {:?}\", config.format));\n-    logv(c, \"\\n\".to_string());\n-}\n-\n-pub fn opt_str(maybestr: &Option<String>) -> &str {\n-    match *maybestr {\n-        None => \"(none)\",\n-        Some(ref s) => s,\n-    }\n-}\n-\n-pub fn opt_str2(maybestr: Option<String>) -> String {\n-    match maybestr {\n-        None => \"(none)\".to_owned(),\n-        Some(s) => s,\n-    }\n-}\n-\n-pub fn run_tests(config: Arc<Config>) {\n-    // If we want to collect rustfix coverage information,\n-    // we first make sure that the coverage file does not exist.\n-    // It will be created later on.\n-    if config.rustfix_coverage {\n-        let mut coverage_file_path = config.build_base.clone();\n-        coverage_file_path.push(\"rustfix_missing_coverage.txt\");\n-        if coverage_file_path.exists() {\n-            if let Err(e) = fs::remove_file(&coverage_file_path) {\n-                panic!(\"Could not delete {} due to {}\", coverage_file_path.display(), e)\n-            }\n-        }\n-    }\n-\n-    // sadly osx needs some file descriptor limits raised for running tests in\n-    // parallel (especially when we have lots and lots of child processes).\n-    // For context, see #8904\n-    unsafe {\n-        raise_fd_limit::raise_fd_limit();\n-    }\n-    // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n-    // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n-    env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n-\n-    // Let tests know which target they're running as\n-    env::set_var(\"TARGET\", &config.target);\n-\n-    let opts = test_opts(&config);\n-\n-    let mut configs = Vec::new();\n-    if let Mode::DebugInfo = config.mode {\n-        // Debugging emscripten code doesn't make sense today\n-        if !config.target.contains(\"emscripten\") {\n-            configs.extend(configure_cdb(&config));\n-            configs.extend(configure_gdb(&config));\n-            configs.extend(configure_lldb(&config));\n-        }\n-    } else {\n-        configs.push(config.clone());\n-    };\n-\n-    let mut tests = Vec::new();\n-    for c in configs {\n-        let mut found_paths = BTreeSet::new();\n-        make_tests(c, &mut tests, &mut found_paths);\n-        check_overlapping_tests(&found_paths);\n-    }\n-\n-    tests.sort_by(|a, b| a.desc.name.as_slice().cmp(&b.desc.name.as_slice()));\n-\n-    let res = test::run_tests_console(&opts, tests);\n-    match res {\n-        Ok(true) => {}\n-        Ok(false) => {\n-            // We want to report that the tests failed, but we also want to give\n-            // some indication of just what tests we were running. Especially on\n-            // CI, where there can be cross-compiled tests for a lot of\n-            // architectures, without this critical information it can be quite\n-            // easy to miss which tests failed, and as such fail to reproduce\n-            // the failure locally.\n-\n-            println!(\n-                \"Some tests failed in compiletest suite={}{} mode={} host={} target={}\",\n-                config.suite,\n-                config\n-                    .compare_mode\n-                    .as_ref()\n-                    .map(|c| format!(\" compare_mode={:?}\", c))\n-                    .unwrap_or_default(),\n-                config.mode,\n-                config.host,\n-                config.target\n-            );\n-\n-            std::process::exit(1);\n-        }\n-        Err(e) => {\n-            // We don't know if tests passed or not, but if there was an error\n-            // during testing we don't want to just succeed (we may not have\n-            // tested something), so fail.\n-            //\n-            // This should realistically \"never\" happen, so don't try to make\n-            // this a pretty error message.\n-            panic!(\"I/O failure during tests: {:?}\", e);\n-        }\n-    }\n-}\n-\n-fn configure_cdb(config: &Config) -> Option<Arc<Config>> {\n-    config.cdb.as_ref()?;\n-\n-    Some(Arc::new(Config { debugger: Some(Debugger::Cdb), ..config.clone() }))\n-}\n-\n-fn configure_gdb(config: &Config) -> Option<Arc<Config>> {\n-    config.gdb_version?;\n-\n-    if config.matches_env(\"msvc\") {\n-        return None;\n-    }\n-\n-    if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n-        println!(\n-            \"WARNING: debuginfo tests are not available when \\\n-             testing with remote\"\n-        );\n-        return None;\n-    }\n-\n-    if config.target.contains(\"android\") {\n-        println!(\n-            \"{} debug-info test uses tcp 5039 port.\\\n-             please reserve it\",\n-            config.target\n-        );\n-\n-        // android debug-info test uses remote debugger so, we test 1 thread\n-        // at once as they're all sharing the same TCP port to communicate\n-        // over.\n-        //\n-        // we should figure out how to lift this restriction! (run them all\n-        // on different ports allocated dynamically).\n-        env::set_var(\"RUST_TEST_THREADS\", \"1\");\n-    }\n-\n-    Some(Arc::new(Config { debugger: Some(Debugger::Gdb), ..config.clone() }))\n-}\n-\n-fn configure_lldb(config: &Config) -> Option<Arc<Config>> {\n-    config.lldb_python_dir.as_ref()?;\n-\n-    if let Some(350) = config.lldb_version {\n-        println!(\n-            \"WARNING: The used version of LLDB (350) has a \\\n-             known issue that breaks debuginfo tests. See \\\n-             issue #32520 for more information. Skipping all \\\n-             LLDB-based tests!\",\n-        );\n-        return None;\n-    }\n-\n-    Some(Arc::new(Config { debugger: Some(Debugger::Lldb), ..config.clone() }))\n-}\n-\n-pub fn test_opts(config: &Config) -> test::TestOpts {\n-    if env::var(\"RUST_TEST_NOCAPTURE\").is_ok() {\n-        eprintln!(\n-            \"WARNING: RUST_TEST_NOCAPTURE is no longer used. \\\n-                   Use the `--nocapture` flag instead.\"\n-        );\n-    }\n-\n-    test::TestOpts {\n-        exclude_should_panic: false,\n-        filters: config.filters.clone(),\n-        filter_exact: config.filter_exact,\n-        run_ignored: if config.run_ignored { test::RunIgnored::Yes } else { test::RunIgnored::No },\n-        format: config.format,\n-        logfile: config.logfile.clone(),\n-        run_tests: true,\n-        bench_benchmarks: true,\n-        nocapture: config.nocapture,\n-        color: config.color,\n-        shuffle: false,\n-        shuffle_seed: None,\n-        test_threads: None,\n-        skip: config.skip.clone(),\n-        list: false,\n-        options: test::Options::new(),\n-        time_options: None,\n-        force_run_in_process: false,\n-        fail_fast: std::env::var_os(\"RUSTC_TEST_FAIL_FAST\").is_some(),\n-    }\n-}\n-\n-pub fn make_tests(\n-    config: Arc<Config>,\n-    tests: &mut Vec<test::TestDescAndFn>,\n-    found_paths: &mut BTreeSet<PathBuf>,\n-) {\n-    debug!(\"making tests from {:?}\", config.src_base.display());\n-    let inputs = common_inputs_stamp(&config);\n-    let modified_tests = modified_tests(&config, &config.src_base).unwrap_or_else(|err| {\n-        panic!(\"modified_tests got error from dir: {}, error: {}\", config.src_base.display(), err)\n-    });\n-\n-    let cache = HeadersCache::load(&config);\n-    let mut poisoned = false;\n-    collect_tests_from_dir(\n-        config.clone(),\n-        &cache,\n-        &config.src_base,\n-        &PathBuf::new(),\n-        &inputs,\n-        tests,\n-        found_paths,\n-        &modified_tests,\n-        &mut poisoned,\n-    )\n-    .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n-\n-    if poisoned {\n-        eprintln!();\n-        panic!(\"there are errors in tests\");\n-    }\n-}\n-\n-/// Returns a stamp constructed from input files common to all test cases.\n-fn common_inputs_stamp(config: &Config) -> Stamp {\n-    let rust_src_dir = config.find_rust_src_root().expect(\"Could not find Rust source root\");\n-\n-    let mut stamp = Stamp::from_path(&config.rustc_path);\n-\n-    // Relevant pretty printer files\n-    let pretty_printer_files = [\n-        \"src/etc/rust_types.py\",\n-        \"src/etc/gdb_load_rust_pretty_printers.py\",\n-        \"src/etc/gdb_lookup.py\",\n-        \"src/etc/gdb_providers.py\",\n-        \"src/etc/lldb_batchmode.py\",\n-        \"src/etc/lldb_lookup.py\",\n-        \"src/etc/lldb_providers.py\",\n-    ];\n-    for file in &pretty_printer_files {\n-        let path = rust_src_dir.join(file);\n-        stamp.add_path(&path);\n-    }\n-\n-    stamp.add_dir(&rust_src_dir.join(\"src/etc/natvis\"));\n-\n-    stamp.add_dir(&config.run_lib_path);\n-\n-    if let Some(ref rustdoc_path) = config.rustdoc_path {\n-        stamp.add_path(&rustdoc_path);\n-        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n-    }\n-\n-    // Compiletest itself.\n-    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n-\n-    stamp\n-}\n-\n-fn modified_tests(config: &Config, dir: &Path) -> Result<Vec<PathBuf>, String> {\n-    if !config.only_modified {\n-        return Ok(vec![]);\n-    }\n-    let files =\n-        get_git_modified_files(Some(dir), &vec![\"rs\", \"stderr\", \"fixed\"])?.unwrap_or(vec![]);\n-    // Add new test cases to the list, it will be convenient in daily development.\n-    let untracked_files = get_git_untracked_files(None)?.unwrap_or(vec![]);\n-\n-    let all_paths = [&files[..], &untracked_files[..]].concat();\n-    let full_paths = {\n-        let mut full_paths: Vec<PathBuf> = all_paths\n-            .into_iter()\n-            .map(|f| PathBuf::from(f).with_extension(\"\").with_extension(\"rs\"))\n-            .filter_map(|f| if Path::new(&f).exists() { f.canonicalize().ok() } else { None })\n-            .collect();\n-        full_paths.dedup();\n-        full_paths.sort_unstable();\n-        full_paths\n-    };\n-    Ok(full_paths)\n-}\n-\n-fn collect_tests_from_dir(\n-    config: Arc<Config>,\n-    cache: &HeadersCache,\n-    dir: &Path,\n-    relative_dir_path: &Path,\n-    inputs: &Stamp,\n-    tests: &mut Vec<test::TestDescAndFn>,\n-    found_paths: &mut BTreeSet<PathBuf>,\n-    modified_tests: &Vec<PathBuf>,\n-    poisoned: &mut bool,\n-) -> io::Result<()> {\n-    // Ignore directories that contain a file named `compiletest-ignore-dir`.\n-    if dir.join(\"compiletest-ignore-dir\").exists() {\n-        return Ok(());\n-    }\n-\n-    if config.mode == Mode::RunMake && dir.join(\"Makefile\").exists() {\n-        let paths = TestPaths {\n-            file: dir.to_path_buf(),\n-            relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n-        };\n-        tests.extend(make_test(config, cache, &paths, inputs, poisoned));\n-        return Ok(());\n-    }\n-\n-    // If we find a test foo/bar.rs, we have to build the\n-    // output directory `$build/foo` so we can write\n-    // `$build/foo/bar` into it. We do this *now* in this\n-    // sequential loop because otherwise, if we do it in the\n-    // tests themselves, they race for the privilege of\n-    // creating the directories and sometimes fail randomly.\n-    let build_dir = output_relative_path(&config, relative_dir_path);\n-    fs::create_dir_all(&build_dir).unwrap();\n-\n-    // Add each `.rs` file as a test, and recurse further on any\n-    // subdirectories we find, except for `aux` directories.\n-    for file in fs::read_dir(dir)? {\n-        let file = file?;\n-        let file_path = file.path();\n-        let file_name = file.file_name();\n-        if is_test(&file_name) && (!config.only_modified || modified_tests.contains(&file_path)) {\n-            debug!(\"found test file: {:?}\", file_path.display());\n-            let rel_test_path = relative_dir_path.join(file_path.file_stem().unwrap());\n-            found_paths.insert(rel_test_path);\n-            let paths =\n-                TestPaths { file: file_path, relative_dir: relative_dir_path.to_path_buf() };\n-\n-            tests.extend(make_test(config.clone(), cache, &paths, inputs, poisoned))\n-        } else if file_path.is_dir() {\n-            let relative_file_path = relative_dir_path.join(file.file_name());\n-            if &file_name != \"auxiliary\" {\n-                debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(\n-                    config.clone(),\n-                    cache,\n-                    &file_path,\n-                    &relative_file_path,\n-                    inputs,\n-                    tests,\n-                    found_paths,\n-                    modified_tests,\n-                    poisoned,\n-                )?;\n-            }\n-        } else {\n-            debug!(\"found other file/directory: {:?}\", file_path.display());\n-        }\n-    }\n-    Ok(())\n-}\n-\n-/// Returns true if `file_name` looks like a proper test file name.\n-pub fn is_test(file_name: &OsString) -> bool {\n-    let file_name = file_name.to_str().unwrap();\n-\n-    if !file_name.ends_with(\".rs\") {\n-        return false;\n-    }\n-\n-    // `.`, `#`, and `~` are common temp-file prefixes.\n-    let invalid_prefixes = &[\".\", \"#\", \"~\"];\n-    !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n-}\n-\n-fn make_test(\n-    config: Arc<Config>,\n-    cache: &HeadersCache,\n-    testpaths: &TestPaths,\n-    inputs: &Stamp,\n-    poisoned: &mut bool,\n-) -> Vec<test::TestDescAndFn> {\n-    let test_path = if config.mode == Mode::RunMake {\n-        // Parse directives in the Makefile\n-        testpaths.file.join(\"Makefile\")\n-    } else {\n-        PathBuf::from(&testpaths.file)\n-    };\n-    let early_props = EarlyProps::from_file(&config, &test_path);\n-\n-    // Incremental tests are special, they inherently cannot be run in parallel.\n-    // `runtest::run` will be responsible for iterating over revisions.\n-    let revisions = if early_props.revisions.is_empty() || config.mode == Mode::Incremental {\n-        vec![None]\n-    } else {\n-        early_props.revisions.iter().map(Some).collect()\n-    };\n-\n-    revisions\n-        .into_iter()\n-        .map(|revision| {\n-            let src_file =\n-                std::fs::File::open(&test_path).expect(\"open test file to parse ignores\");\n-            let cfg = revision.map(|v| &**v);\n-            let test_name = crate::make_test_name(&config, testpaths, revision);\n-            let mut desc = make_test_description(\n-                &config, cache, test_name, &test_path, src_file, cfg, poisoned,\n-            );\n-            // Ignore tests that already run and are up to date with respect to inputs.\n-            if !config.force_rerun {\n-                desc.ignore |= is_up_to_date(\n-                    &config,\n-                    testpaths,\n-                    &early_props,\n-                    revision.map(|s| s.as_str()),\n-                    inputs,\n-                );\n-            }\n-            test::TestDescAndFn {\n-                desc,\n-                testfn: make_test_closure(config.clone(), testpaths, revision),\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n-    output_base_dir(config, testpaths, revision).join(\"stamp\")\n-}\n-\n-fn files_related_to_test(\n-    config: &Config,\n-    testpaths: &TestPaths,\n-    props: &EarlyProps,\n-    revision: Option<&str>,\n-) -> Vec<PathBuf> {\n-    let mut related = vec![];\n-\n-    if testpaths.file.is_dir() {\n-        // run-make tests use their individual directory\n-        for entry in WalkDir::new(&testpaths.file) {\n-            let path = entry.unwrap().into_path();\n-            if path.is_file() {\n-                related.push(path);\n-            }\n-        }\n-    } else {\n-        related.push(testpaths.file.clone());\n-    }\n-\n-    for aux in &props.aux {\n-        let path = testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux);\n-        related.push(path);\n-    }\n-\n-    // UI test files.\n-    for extension in UI_EXTENSIONS {\n-        let path = expected_output_path(testpaths, revision, &config.compare_mode, extension);\n-        related.push(path);\n-    }\n-\n-    related\n-}\n-\n-fn is_up_to_date(\n-    config: &Config,\n-    testpaths: &TestPaths,\n-    props: &EarlyProps,\n-    revision: Option<&str>,\n-    inputs: &Stamp,\n-) -> bool {\n-    let stamp_name = stamp(config, testpaths, revision);\n-    // Check hash.\n-    let contents = match fs::read_to_string(&stamp_name) {\n-        Ok(f) => f,\n-        Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n-        Err(_) => return false,\n-    };\n-    let expected_hash = runtest::compute_stamp_hash(config);\n-    if contents != expected_hash {\n-        return false;\n-    }\n-\n-    // Check timestamps.\n-    let mut inputs = inputs.clone();\n-    for path in files_related_to_test(config, testpaths, props, revision) {\n-        inputs.add_path(&path);\n-    }\n-\n-    inputs < Stamp::from_path(&stamp_name)\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-struct Stamp {\n-    time: SystemTime,\n-}\n-\n-impl Stamp {\n-    fn from_path(path: &Path) -> Self {\n-        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n-        stamp.add_path(path);\n-        stamp\n-    }\n-\n-    fn add_path(&mut self, path: &Path) {\n-        let modified = fs::metadata(path)\n-            .and_then(|metadata| metadata.modified())\n-            .unwrap_or(SystemTime::UNIX_EPOCH);\n-        self.time = self.time.max(modified);\n-    }\n-\n-    fn add_dir(&mut self, path: &Path) {\n-        for entry in WalkDir::new(path) {\n-            let entry = entry.unwrap();\n-            if entry.file_type().is_file() {\n-                let modified = entry\n-                    .metadata()\n-                    .ok()\n-                    .and_then(|metadata| metadata.modified().ok())\n-                    .unwrap_or(SystemTime::UNIX_EPOCH);\n-                self.time = self.time.max(modified);\n-            }\n-        }\n-    }\n-}\n-\n-fn make_test_name(\n-    config: &Config,\n-    testpaths: &TestPaths,\n-    revision: Option<&String>,\n-) -> test::TestName {\n-    // Print the name of the file, relative to the repository root.\n-    // `src_base` looks like `/path/to/rust/tests/ui`\n-    let root_directory = config.src_base.parent().unwrap().parent().unwrap();\n-    let path = testpaths.file.strip_prefix(root_directory).unwrap();\n-    let debugger = match config.debugger {\n-        Some(d) => format!(\"-{}\", d),\n-        None => String::new(),\n-    };\n-    let mode_suffix = match config.compare_mode {\n-        Some(ref mode) => format!(\" ({})\", mode.to_str()),\n-        None => String::new(),\n-    };\n-\n-    test::DynTestName(format!(\n-        \"[{}{}{}] {}{}\",\n-        config.mode,\n-        debugger,\n-        mode_suffix,\n-        path.display(),\n-        revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n-    ))\n-}\n-\n-fn make_test_closure(\n-    config: Arc<Config>,\n-    testpaths: &TestPaths,\n-    revision: Option<&String>,\n-) -> test::TestFn {\n-    let config = config.clone();\n-    let testpaths = testpaths.clone();\n-    let revision = revision.cloned();\n-    test::DynTestFn(Box::new(move || {\n-        runtest::run(config, &testpaths, revision.as_deref());\n-        Ok(())\n-    }))\n-}\n-\n-/// Returns `true` if the given target is an Android target for the\n-/// purposes of GDB testing.\n-fn is_android_gdb_target(target: &str) -> bool {\n-    matches!(\n-        &target[..],\n-        \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\"\n-    )\n-}\n-\n-/// Returns `true` if the given target is a MSVC target for the purpouses of CDB testing.\n-fn is_pc_windows_msvc_target(target: &str) -> bool {\n-    target.ends_with(\"-pc-windows-msvc\")\n-}\n-\n-fn find_cdb(target: &str) -> Option<OsString> {\n-    if !(cfg!(windows) && is_pc_windows_msvc_target(target)) {\n-        return None;\n-    }\n-\n-    let pf86 = env::var_os(\"ProgramFiles(x86)\").or_else(|| env::var_os(\"ProgramFiles\"))?;\n-    let cdb_arch = if cfg!(target_arch = \"x86\") {\n-        \"x86\"\n-    } else if cfg!(target_arch = \"x86_64\") {\n-        \"x64\"\n-    } else if cfg!(target_arch = \"aarch64\") {\n-        \"arm64\"\n-    } else if cfg!(target_arch = \"arm\") {\n-        \"arm\"\n-    } else {\n-        return None; // No compatible CDB.exe in the Windows 10 SDK\n-    };\n-\n-    let mut path = PathBuf::new();\n-    path.push(pf86);\n-    path.push(r\"Windows Kits\\10\\Debuggers\"); // We could check 8.1 etc. too?\n-    path.push(cdb_arch);\n-    path.push(r\"cdb.exe\");\n-\n-    if !path.exists() {\n-        return None;\n-    }\n-\n-    Some(path.into_os_string())\n-}\n-\n-/// Returns Path to CDB\n-fn analyze_cdb(cdb: Option<String>, target: &str) -> (Option<OsString>, Option<[u16; 4]>) {\n-    let cdb = cdb.map(OsString::from).or_else(|| find_cdb(target));\n-\n-    let mut version = None;\n-    if let Some(cdb) = cdb.as_ref() {\n-        if let Ok(output) = Command::new(cdb).arg(\"/version\").output() {\n-            if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n-                version = extract_cdb_version(&first_line);\n-            }\n-        }\n-    }\n-\n-    (cdb, version)\n-}\n-\n-fn extract_cdb_version(full_version_line: &str) -> Option<[u16; 4]> {\n-    // Example full_version_line: \"cdb version 10.0.18362.1\"\n-    let version = full_version_line.rsplit(' ').next()?;\n-    let mut components = version.split('.');\n-    let major: u16 = components.next().unwrap().parse().unwrap();\n-    let minor: u16 = components.next().unwrap().parse().unwrap();\n-    let patch: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n-    let build: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n-    Some([major, minor, patch, build])\n-}\n-\n-/// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n-fn analyze_gdb(\n-    gdb: Option<String>,\n-    target: &str,\n-    android_cross_path: &PathBuf,\n-) -> (Option<String>, Option<u32>, bool) {\n-    #[cfg(not(windows))]\n-    const GDB_FALLBACK: &str = \"gdb\";\n-    #[cfg(windows)]\n-    const GDB_FALLBACK: &str = \"gdb.exe\";\n-\n-    const MIN_GDB_WITH_RUST: u32 = 7011010;\n-\n-    let fallback_gdb = || {\n-        if is_android_gdb_target(target) {\n-            let mut gdb_path = match android_cross_path.to_str() {\n-                Some(x) => x.to_owned(),\n-                None => panic!(\"cannot find android cross path\"),\n-            };\n-            gdb_path.push_str(\"/bin/gdb\");\n-            gdb_path\n-        } else {\n-            GDB_FALLBACK.to_owned()\n-        }\n-    };\n-\n-    let gdb = match gdb {\n-        None => fallback_gdb(),\n-        Some(ref s) if s.is_empty() => fallback_gdb(), // may be empty if configure found no gdb\n-        Some(ref s) => s.to_owned(),\n-    };\n-\n-    let mut version_line = None;\n-    if let Ok(output) = Command::new(&gdb).arg(\"--version\").output() {\n-        if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n-            version_line = Some(first_line.to_string());\n-        }\n-    }\n-\n-    let version = match version_line {\n-        Some(line) => extract_gdb_version(&line),\n-        None => return (None, None, false),\n-    };\n-\n-    let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n-\n-    (Some(gdb), version, gdb_native_rust)\n-}\n-\n-fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n-    let full_version_line = full_version_line.trim();\n-\n-    // GDB versions look like this: \"major.minor.patch?.yyyymmdd?\", with both\n-    // of the ? sections being optional\n-\n-    // We will parse up to 3 digits for each component, ignoring the date\n-\n-    // We skip text in parentheses.  This avoids accidentally parsing\n-    // the openSUSE version, which looks like:\n-    //  GNU gdb (GDB; openSUSE Leap 15.0) 8.1\n-    // This particular form is documented in the GNU coding standards:\n-    // https://www.gnu.org/prep/standards/html_node/_002d_002dversion.html#g_t_002d_002dversion\n-\n-    let unbracketed_part = full_version_line.split('[').next().unwrap();\n-    let mut splits = unbracketed_part.trim_end().rsplit(' ');\n-    let version_string = splits.next().unwrap();\n-\n-    let mut splits = version_string.split('.');\n-    let major = splits.next().unwrap();\n-    let minor = splits.next().unwrap();\n-    let patch = splits.next();\n-\n-    let major: u32 = major.parse().unwrap();\n-    let (minor, patch): (u32, u32) = match minor.find(not_a_digit) {\n-        None => {\n-            let minor = minor.parse().unwrap();\n-            let patch: u32 = match patch {\n-                Some(patch) => match patch.find(not_a_digit) {\n-                    None => patch.parse().unwrap(),\n-                    Some(idx) if idx > 3 => 0,\n-                    Some(idx) => patch[..idx].parse().unwrap(),\n-                },\n-                None => 0,\n-            };\n-            (minor, patch)\n-        }\n-        // There is no patch version after minor-date (e.g. \"4-2012\").\n-        Some(idx) => {\n-            let minor = minor[..idx].parse().unwrap();\n-            (minor, 0)\n-        }\n-    };\n-\n-    Some(((major * 1000) + minor) * 1000 + patch)\n-}\n-\n-/// Returns (LLDB version, LLDB is rust-enabled)\n-fn extract_lldb_version(full_version_line: &str) -> Option<(u32, bool)> {\n-    // Extract the major LLDB version from the given version string.\n-    // LLDB version strings are different for Apple and non-Apple platforms.\n-    // The Apple variant looks like this:\n-    //\n-    // LLDB-179.5 (older versions)\n-    // lldb-300.2.51 (new versions)\n-    //\n-    // We are only interested in the major version number, so this function\n-    // will return `Some(179)` and `Some(300)` respectively.\n-    //\n-    // Upstream versions look like:\n-    // lldb version 6.0.1\n-    //\n-    // There doesn't seem to be a way to correlate the Apple version\n-    // with the upstream version, and since the tests were originally\n-    // written against Apple versions, we make a fake Apple version by\n-    // multiplying the first number by 100.  This is a hack, but\n-    // normally fine because the only non-Apple version we test is\n-    // rust-enabled.\n-\n-    let full_version_line = full_version_line.trim();\n-\n-    if let Some(apple_ver) =\n-        full_version_line.strip_prefix(\"LLDB-\").or_else(|| full_version_line.strip_prefix(\"lldb-\"))\n-    {\n-        if let Some(idx) = apple_ver.find(not_a_digit) {\n-            let version: u32 = apple_ver[..idx].parse().unwrap();\n-            return Some((version, full_version_line.contains(\"rust-enabled\")));\n-        }\n-    } else if let Some(lldb_ver) = full_version_line.strip_prefix(\"lldb version \") {\n-        if let Some(idx) = lldb_ver.find(not_a_digit) {\n-            let version: u32 = lldb_ver[..idx].parse().ok()?;\n-            return Some((version * 100, full_version_line.contains(\"rust-enabled\")));\n-        }\n-    }\n-    None\n-}\n-\n-fn not_a_digit(c: char) -> bool {\n-    !c.is_digit(10)\n-}\n-\n-fn check_overlapping_tests(found_paths: &BTreeSet<PathBuf>) {\n-    let mut collisions = Vec::new();\n-    for path in found_paths {\n-        for ancestor in path.ancestors().skip(1) {\n-            if found_paths.contains(ancestor) {\n-                collisions.push((path, ancestor.clone()));\n-            }\n-        }\n-    }\n-    if !collisions.is_empty() {\n-        let collisions: String = collisions\n-            .into_iter()\n-            .map(|(path, check_parent)| format!(\"test {path:?} clashes with {check_parent:?}\\n\"))\n-            .collect();\n-        panic!(\n-            \"{collisions}\\n\\\n-            Tests cannot have overlapping names. Make sure they use unique prefixes.\"\n-        );\n-    }\n-}"}, {"sha": "a799d93ce25c7294721cd13215778192234cc03c", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2045,7 +2045,10 @@ impl<'test> TestCx<'test> {\n                 if let Some(pass) = &self.props.mir_unit_test {\n                     rustc.args(&[\"-Zmir-opt-level=0\", &format!(\"-Zmir-enable-passes=+{}\", pass)]);\n                 } else {\n-                    rustc.arg(\"-Zmir-opt-level=4\");\n+                    rustc.args(&[\n+                        \"-Zmir-opt-level=4\",\n+                        \"-Zmir-enable-passes=+ReorderBasicBlocks,+ReorderLocals\",\n+                    ]);\n                 }\n \n                 let mir_dump_dir = self.get_mir_dump_dir();"}, {"sha": "17bed38b65e881c29bc52a0313b3ddc6b277dd12", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -104,6 +104,8 @@ pub const XRAY_SUPPORTED_TARGETS: &[&str] = &[\n     \"x86_64-unknown-openbsd\",\n ];\n \n+pub const SAFESTACK_SUPPORTED_TARGETS: &[&str] = &[\"x86_64-unknown-linux-gnu\"];\n+\n pub fn make_new_path(path: &str) -> String {\n     assert!(cfg!(windows));\n     // Windows just uses PATH as the library search path, so we have to"}, {"sha": "25c8df43ee26c8201523021c17a69fb352acc2d6", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -133,10 +133,15 @@ pub struct Thread<'mir, 'tcx> {\n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n-    /// The temporary used for storing the argument of\n-    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n+    /// Stack of active panic payloads for the current thread. Used for storing\n+    /// the argument of the call to `miri_start_panic` (the panic payload) when unwinding.\n     /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n-    pub(crate) panic_payload: Option<Scalar<Provenance>>,\n+    ///\n+    /// In real unwinding, the payload gets passed as an argument to the landing pad,\n+    /// which then forwards it to 'Resume'. However this argument is implicit in MIR,\n+    /// so we have to store it out-of-band. When there are multiple active unwinds,\n+    /// the innermost one is always caught first, so we can store them as a stack.\n+    pub(crate) panic_payloads: Vec<Scalar<Provenance>>,\n \n     /// Last OS error location in memory. It is a 32-bit integer.\n     pub(crate) last_error: Option<MPlaceTy<'tcx, Provenance>>,\n@@ -206,7 +211,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n             stack: Vec::new(),\n             top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n-            panic_payload: None,\n+            panic_payloads: Vec::new(),\n             last_error: None,\n             on_stack_empty,\n         }\n@@ -216,7 +221,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n impl VisitTags for Thread<'_, '_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Thread {\n-            panic_payload,\n+            panic_payloads: panic_payload,\n             last_error,\n             stack,\n             top_user_relevant_frame: _,\n@@ -226,7 +231,9 @@ impl VisitTags for Thread<'_, '_> {\n             on_stack_empty: _, // we assume the closure captures no GC-relevant state\n         } = self;\n \n-        panic_payload.visit_tags(visit);\n+        for payload in panic_payload {\n+            payload.visit_tags(visit);\n+        }\n         last_error.visit_tags(visit);\n         for frame in stack {\n             frame.visit_tags(visit)"}, {"sha": "7aefdfcb976afa6b7688daa1ded2c66c651e7b81", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -63,8 +63,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let [payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n         let payload = this.read_scalar(payload)?;\n         let thread = this.active_thread_mut();\n-        assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n-        thread.panic_payload = Some(payload);\n+        thread.panic_payloads.push(payload);\n \n         // Jump to the unwind block to begin unwinding.\n         this.unwind_to_block(unwind)?;\n@@ -146,7 +145,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             // The Thread's `panic_payload` holds what was passed to `miri_start_panic`.\n             // This is exactly the second argument we need to pass to `catch_fn`.\n-            let payload = this.active_thread_mut().panic_payload.take().unwrap();\n+            let payload = this.active_thread_mut().panic_payloads.pop().unwrap();\n \n             // Push the `catch_fn` stackframe.\n             let f_instance = this.get_ptr_fn(catch_unwind.catch_fn)?.as_instance()?;"}, {"sha": "adb30714269e8a1495405de728da57dd55eaafa5", "filename": "src/tools/miri/tests/fail/panic/double_panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,6 +1,4 @@\n-//@error-in-other-file: the program aborted\n //@normalize-stderr-test: \"\\| +\\^+\" -> \"| ^\"\n-//@normalize-stderr-test: \"unsafe \\{ libc::abort\\(\\) \\}|crate::intrinsics::abort\\(\\);\" -> \"ABORT();\"\n //@normalize-stderr-test: \"\\n  +[0-9]+:[^\\n]+\" -> \"$1\"\n //@normalize-stderr-test: \"\\n at [^\\n]+\" -> \"$1\"\n \n@@ -11,6 +9,7 @@ impl Drop for Foo {\n     }\n }\n fn main() {\n+    //~^ERROR: panic in a function that cannot unwind\n     let _foo = Foo;\n     panic!(\"first\");\n }"}, {"sha": "b6ac56f15d4b5033e28e8977d351408d1a2c9867", "filename": "src/tools/miri/tests/fail/panic/double_panic.stderr", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2,30 +2,17 @@ thread 'main' panicked at 'first', $DIR/double_panic.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n thread 'main' panicked at 'second', $DIR/double_panic.rs:LL:CC\n stack backtrace:\n-thread panicked while panicking. aborting.\n-error: abnormal termination: the program aborted execution\n-  --> RUSTLIB/std/src/sys/PLATFORM/mod.rs:LL:CC\n-   |\n-LL |     ABORT();\n-   | ^ the program aborted execution\n-   |\n-   = note: inside `std::sys::PLATFORM::abort_internal` at RUSTLIB/std/src/sys/PLATFORM/mod.rs:LL:CC\n-   = note: inside `std::panicking::rust_panic_with_hook` at RUSTLIB/std/src/panicking.rs:LL:CC\n-   = note: inside closure at RUSTLIB/std/src/panicking.rs:LL:CC\n-   = note: inside `std::sys_common::backtrace::__rust_end_short_backtrace::<[closure@std::panicking::begin_panic_handler::{closure#0}], !>` at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   = note: inside `std::panicking::begin_panic_handler` at RUSTLIB/std/src/panicking.rs:LL:CC\n-note: inside `<Foo as std::ops::Drop>::drop`\n+error: abnormal termination: panic in a function that cannot unwind\n   --> $DIR/double_panic.rs:LL:CC\n    |\n-LL |         panic!(\"second\");\n-   | ^\n-   = note: inside `std::ptr::drop_in_place::<Foo> - shim(Some(Foo))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-note: inside `main`\n-  --> $DIR/double_panic.rs:LL:CC\n+LL | / fn main() {\n+LL | |\n+LL | |     let _foo = Foo;\n+LL | |     panic!(\"first\");\n+LL | | }\n+   | |_^ panic in a function that cannot unwind\n    |\n-LL | }\n-   | ^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: inside `main` at $DIR/double_panic.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "884813150ad2adb2b88599cc0295cf2d5d070be8", "filename": "src/tools/miri/tests/pass/panic/nested_panic_caught.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,25 @@\n+//@normalize-stderr-test: \"\\| +\\^+\" -> \"| ^\"\n+//@normalize-stderr-test: \"\\n  +[0-9]+:[^\\n]+\" -> \"$1\"\n+//@normalize-stderr-test: \"\\n at [^\\n]+\" -> \"$1\"\n+\n+// Checks that nested panics work correctly.\n+\n+use std::panic::catch_unwind;\n+\n+fn double() {\n+    struct Double;\n+\n+    impl Drop for Double {\n+        fn drop(&mut self) {\n+            let _ = catch_unwind(|| panic!(\"twice\"));\n+        }\n+    }\n+\n+    let _d = Double;\n+\n+    panic!(\"once\");\n+}\n+\n+fn main() {\n+    assert!(catch_unwind(|| double()).is_err());\n+}"}, {"sha": "4e2593242df75ee81de35be48e23df2454ab8659", "filename": "src/tools/miri/tests/pass/panic/nested_panic_caught.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,4 @@\n+thread 'main' panicked at 'once', $DIR/nested_panic_caught.rs:LL:CC\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+thread 'main' panicked at 'twice', $DIR/nested_panic_caught.rs:LL:CC\n+stack backtrace:"}, {"sha": "f0c5b367117e1996f767ea5cbff3292e456b618f", "filename": "src/tools/rustdoc-gui-test/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"rustdoc-gui-test\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+compiletest = { path = \"../compiletest\" }\n+getopts = \"0.2\"\n+walkdir = \"2\""}, {"sha": "dc4c56a5e7abd67f6d718ff2df9a7efa0cb9cd5c", "filename": "src/tools/rustdoc-gui-test/src/config.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fconfig.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,62 @@\n+use getopts::Options;\n+use std::{env, path::PathBuf};\n+\n+pub(crate) struct Config {\n+    pub(crate) nodejs: PathBuf,\n+    pub(crate) npm: PathBuf,\n+    pub(crate) rust_src: PathBuf,\n+    pub(crate) out_dir: PathBuf,\n+    pub(crate) initial_cargo: PathBuf,\n+    pub(crate) jobs: String,\n+    pub(crate) test_args: Vec<PathBuf>,\n+    pub(crate) goml_files: Vec<PathBuf>,\n+    pub(crate) rustc: PathBuf,\n+    pub(crate) rustdoc: PathBuf,\n+    pub(crate) verbose: bool,\n+}\n+\n+impl Config {\n+    pub(crate) fn from_args(args: Vec<String>) -> Self {\n+        let mut opts = Options::new();\n+        opts.reqopt(\"\", \"nodejs\", \"absolute path of nodejs\", \"PATH\")\n+            .reqopt(\"\", \"npm\", \"absolute path of npm\", \"PATH\")\n+            .reqopt(\"\", \"out-dir\", \"output path of doc compilation\", \"PATH\")\n+            .reqopt(\"\", \"rust-src\", \"root source of the rust source\", \"PATH\")\n+            .reqopt(\n+                \"\",\n+                \"initial-cargo\",\n+                \"path to cargo to use for compiling tests/rustdoc-gui/src/*\",\n+                \"PATH\",\n+            )\n+            .reqopt(\"\", \"jobs\", \"jobs arg of browser-ui-test\", \"JOBS\")\n+            .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n+            .optmulti(\"\", \"test-arg\", \"args for browser-ui-test\", \"FLAGS\")\n+            .optmulti(\"\", \"goml-file\", \"goml files for testing with browser-ui-test\", \"LIST\");\n+\n+        let (argv0, args_) = args.split_first().unwrap();\n+        if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n+            let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n+            println!(\"{}\", opts.usage(&message));\n+            std::process::exit(1);\n+        }\n+\n+        let matches = &match opts.parse(args_) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"{:?}\", f),\n+        };\n+\n+        Self {\n+            nodejs: matches.opt_str(\"nodejs\").map(PathBuf::from).expect(\"nodejs isn't available\"),\n+            npm: matches.opt_str(\"npm\").map(PathBuf::from).expect(\"npm isn't available\"),\n+            rust_src: matches.opt_str(\"rust-src\").map(PathBuf::from).unwrap(),\n+            out_dir: matches.opt_str(\"out-dir\").map(PathBuf::from).unwrap(),\n+            initial_cargo: matches.opt_str(\"initial-cargo\").map(PathBuf::from).unwrap(),\n+            jobs: matches.opt_str(\"jobs\").unwrap(),\n+            goml_files: matches.opt_strs(\"goml-file\").iter().map(PathBuf::from).collect(),\n+            test_args: matches.opt_strs(\"test-arg\").iter().map(PathBuf::from).collect(),\n+            rustc: env::var(\"RUSTC\").map(PathBuf::from).unwrap(),\n+            rustdoc: env::var(\"RUSTDOC\").map(PathBuf::from).unwrap(),\n+            verbose: matches.opt_present(\"verbose\"),\n+        }\n+    }\n+}"}, {"sha": "8dc18dfaea2d6db5213fb99473ff0d6daed45e1b", "filename": "src/tools/rustdoc-gui-test/src/main.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,162 @@\n+use compiletest::header::TestProps;\n+use config::Config;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+use std::sync::Arc;\n+use std::{env, fs};\n+\n+mod config;\n+\n+fn get_browser_ui_test_version_inner(npm: &Path, global: bool) -> Option<String> {\n+    let mut command = Command::new(&npm);\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let lines = command\n+        .output()\n+        .map(|output| String::from_utf8_lossy(&output.stdout).into_owned())\n+        .unwrap_or(String::new());\n+    lines\n+        .lines()\n+        .find_map(|l| l.split(':').nth(1)?.strip_prefix(\"browser-ui-test@\"))\n+        .map(|v| v.to_owned())\n+}\n+\n+fn get_browser_ui_test_version(npm: &Path) -> Option<String> {\n+    get_browser_ui_test_version_inner(npm, false)\n+        .or_else(|| get_browser_ui_test_version_inner(npm, true))\n+}\n+\n+fn compare_browser_ui_test_version(installed_version: &str, src: &Path) {\n+    match fs::read_to_string(\n+        src.join(\"src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version\"),\n+    ) {\n+        Ok(v) => {\n+            if v.trim() != installed_version {\n+                eprintln!(\n+                    \"\u26a0\ufe0f Installed version of browser-ui-test (`{}`) is different than the \\\n+                     one used in the CI (`{}`)\",\n+                    installed_version, v\n+                );\n+                eprintln!(\n+                    \"You can install this version using `npm update browser-ui-test` or by using \\\n+                     `npm install browser-ui-test@{}`\",\n+                    v,\n+                );\n+            }\n+        }\n+        Err(e) => eprintln!(\"Couldn't find the CI browser-ui-test version: {:?}\", e),\n+    }\n+}\n+\n+fn find_librs<P: AsRef<Path>>(path: P) -> Option<PathBuf> {\n+    for entry in walkdir::WalkDir::new(path) {\n+        let entry = entry.ok()?;\n+        if entry.file_type().is_file() && entry.file_name() == \"lib.rs\" {\n+            return Some(entry.path().to_path_buf());\n+        }\n+    }\n+    None\n+}\n+\n+// FIXME: move `bootstrap::util::try_run` into `build_helper` crate\n+// and use that one instead of creating this function.\n+fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n+    let status = match cmd.status() {\n+        Ok(status) => status,\n+        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e),\n+    };\n+    if !status.success() && print_cmd_on_fail {\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\",\n+            cmd, status\n+        );\n+    }\n+    status.success()\n+}\n+\n+fn main() {\n+    let config = Arc::new(Config::from_args(env::args().collect()));\n+\n+    // The goal here is to check if the necessary packages are installed, and if not, we\n+    // panic.\n+    match get_browser_ui_test_version(&config.npm) {\n+        Some(version) => {\n+            // We also check the version currently used in CI and emit a warning if it's not the\n+            // same one.\n+            compare_browser_ui_test_version(&version, &config.rust_src);\n+        }\n+        None => {\n+            eprintln!(\n+                r#\"\n+error: rustdoc-gui test suite cannot be run because npm `browser-ui-test` dependency is missing.\n+\n+If you want to install the `browser-ui-test` dependency, run `npm install browser-ui-test`\n+\"#,\n+            );\n+\n+            panic!(\"Cannot run rustdoc-gui tests\");\n+        }\n+    }\n+\n+    let src_path = config.rust_src.join(\"tests/rustdoc-gui/src\");\n+    for entry in src_path.read_dir().expect(\"read_dir call failed\") {\n+        if let Ok(entry) = entry {\n+            let path = entry.path();\n+\n+            if !path.is_dir() {\n+                continue;\n+            }\n+\n+            let mut cargo = Command::new(&config.initial_cargo);\n+            cargo\n+                .arg(\"doc\")\n+                .arg(\"--target-dir\")\n+                .arg(&config.out_dir)\n+                .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                .env(\"RUSTDOC\", &config.rustdoc)\n+                .env(\"RUSTC\", &config.rustc)\n+                .current_dir(path);\n+\n+            if let Some(librs) = find_librs(entry.path()) {\n+                let compiletest_c = compiletest::common::Config {\n+                    edition: None,\n+                    mode: compiletest::common::Mode::Rustdoc,\n+                    ..Default::default()\n+                };\n+\n+                let test_props = TestProps::from_file(&librs, None, &compiletest_c);\n+\n+                if !test_props.compile_flags.is_empty() {\n+                    cargo.env(\"RUSTDOCFLAGS\", test_props.compile_flags.join(\" \"));\n+                }\n+\n+                if let Some(flags) = &test_props.run_flags {\n+                    cargo.arg(flags);\n+                }\n+            }\n+\n+            try_run(&mut cargo, config.verbose);\n+        }\n+    }\n+\n+    let mut command = Command::new(&config.nodejs);\n+    command\n+        .arg(config.rust_src.join(\"src/tools/rustdoc-gui/tester.js\"))\n+        .arg(\"--jobs\")\n+        .arg(&config.jobs)\n+        .arg(\"--doc-folder\")\n+        .arg(config.out_dir.join(\"doc\"))\n+        .arg(\"--tests-folder\")\n+        .arg(config.rust_src.join(\"tests/rustdoc-gui\"));\n+\n+    for file in &config.goml_files {\n+        command.arg(\"--file\").arg(file);\n+    }\n+\n+    command.args(&config.test_args);\n+\n+    try_run(&mut command, config.verbose);\n+}"}, {"sha": "0834888f55808dee5dbdfb88af3f29986c7acda5", "filename": "src/version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fversion", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/src%2Fversion", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fversion?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1 +1 @@\n-1.71.0\n+1.72.0"}, {"sha": "b73ed00e7308e1d260ff57ae2789d5034ea2f4e8", "filename": "tests/codegen/sanitizer-safestack-attr-check.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fcodegen%2Fsanitizer-safestack-attr-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fcodegen%2Fsanitizer-safestack-attr-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-safestack-attr-check.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,11 @@\n+// This tests that the safestack attribute is applied when enabling the safe-stack sanitizer.\n+//\n+// needs-sanitizer-safestack\n+// compile-flags: -Zsanitizer=safestack\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK: ; Function Attrs:{{.*}}safestack\n+pub fn tagged() {}\n+\n+// CHECK: attributes #0 = {{.*}}safestack"}, {"sha": "bcdb12011bcd5887ae831c9955f1df68125127f2", "filename": "tests/mir-opt/deref-patterns/string.foo.PreCodegen.after.mir", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,41 +3,33 @@\n fn foo(_1: Option<String>) -> i32 {\n     debug s => _1;                       // in scope 0 at $DIR/string.rs:+0:12: +0:13\n     let mut _0: i32;                     // return place in scope 0 at $DIR/string.rs:+0:34: +0:37\n-    let mut _2: &std::string::String;    // in scope 0 at $DIR/string.rs:+2:14: +2:17\n-    let mut _3: &str;                    // in scope 0 at $DIR/string.rs:+2:14: +2:17\n-    let mut _4: bool;                    // in scope 0 at $DIR/string.rs:+2:14: +2:17\n-    let mut _5: isize;                   // in scope 0 at $DIR/string.rs:+2:9: +2:18\n-    let _6: std::option::Option<std::string::String>; // in scope 0 at $DIR/string.rs:+3:9: +3:10\n-    let mut _7: bool;                    // in scope 0 at $DIR/string.rs:+5:1: +5:2\n+    let mut _2: bool;                    // in scope 0 at $DIR/string.rs:+5:1: +5:2\n+    let mut _3: isize;                   // in scope 0 at $DIR/string.rs:+2:9: +2:18\n+    let mut _4: &std::string::String;    // in scope 0 at $DIR/string.rs:+2:14: +2:17\n+    let mut _5: &str;                    // in scope 0 at $DIR/string.rs:+2:14: +2:17\n+    let mut _6: bool;                    // in scope 0 at $DIR/string.rs:+2:14: +2:17\n+    let _7: std::option::Option<std::string::String>; // in scope 0 at $DIR/string.rs:+3:9: +3:10\n     scope 1 {\n-        debug s => _6;                   // in scope 1 at $DIR/string.rs:+3:9: +3:10\n+        debug s => _7;                   // in scope 1 at $DIR/string.rs:+3:9: +3:10\n     }\n \n     bb0: {\n-        _7 = const false;                // scope 0 at $DIR/string.rs:+1:11: +1:12\n-        _7 = const true;                 // scope 0 at $DIR/string.rs:+1:11: +1:12\n-        _5 = discriminant(_1);           // scope 0 at $DIR/string.rs:+1:11: +1:12\n-        switchInt(move _5) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/string.rs:+1:5: +1:12\n+        _2 = const false;                // scope 0 at $DIR/string.rs:+1:11: +1:12\n+        _2 = const true;                 // scope 0 at $DIR/string.rs:+1:11: +1:12\n+        _3 = discriminant(_1);           // scope 0 at $DIR/string.rs:+1:11: +1:12\n+        switchInt(move _3) -> [1: bb1, otherwise: bb5]; // scope 0 at $DIR/string.rs:+1:5: +1:12\n     }\n \n     bb1: {\n-        StorageLive(_6);                 // scope 0 at $DIR/string.rs:+3:9: +3:10\n-        _7 = const false;                // scope 0 at $DIR/string.rs:+3:9: +3:10\n-        _6 = move _1;                    // scope 0 at $DIR/string.rs:+3:9: +3:10\n-        _0 = const 4321_i32;             // scope 1 at $DIR/string.rs:+3:14: +3:18\n-        drop(_6) -> [return: bb6, unwind unreachable]; // scope 0 at $DIR/string.rs:+3:17: +3:18\n-    }\n-\n-    bb2: {\n-        _2 = &((_1 as Some).0: std::string::String); // scope 0 at $DIR/string.rs:+2:14: +2:17\n-        _3 = <String as Deref>::deref(move _2) -> [return: bb3, unwind unreachable]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n+        _4 = &((_1 as Some).0: std::string::String); // scope 0 at $DIR/string.rs:+2:14: +2:17\n+        _5 = <String as Deref>::deref(move _4) -> [return: bb2, unwind unreachable]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n                                          // mir::Constant\n                                          // + span: $DIR/string.rs:9:14: 9:17\n                                          // + literal: Const { ty: for<'a> fn(&'a String) -> &'a <String as Deref>::Target {<String as Deref>::deref}, val: Value(<ZST>) }\n     }\n \n-    bb3: {\n-        _4 = <str as PartialEq>::eq(_3, const \"a\") -> [return: bb4, unwind unreachable]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n+    bb2: {\n+        _6 = <str as PartialEq>::eq(_5, const \"a\") -> [return: bb3, unwind unreachable]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n                                          // mir::Constant\n                                          // + span: $DIR/string.rs:9:14: 9:17\n                                          // + literal: Const { ty: for<'a, 'b> fn(&'a str, &'b str) -> bool {<str as PartialEq>::eq}, val: Value(<ZST>) }\n@@ -46,29 +38,37 @@ fn foo(_1: Option<String>) -> i32 {\n                                          // + literal: Const { ty: &str, val: Value(Slice(..)) }\n     }\n \n+    bb3: {\n+        switchInt(move _6) -> [0: bb5, otherwise: bb4]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n+    }\n+\n     bb4: {\n-        switchInt(move _4) -> [0: bb1, otherwise: bb5]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n+        _0 = const 1234_i32;             // scope 0 at $DIR/string.rs:+2:22: +2:26\n+        goto -> bb7;                     // scope 0 at $DIR/string.rs:+2:22: +2:26\n     }\n \n     bb5: {\n-        _0 = const 1234_i32;             // scope 0 at $DIR/string.rs:+2:22: +2:26\n-        goto -> bb9;                     // scope 0 at $DIR/string.rs:+2:22: +2:26\n+        StorageLive(_7);                 // scope 0 at $DIR/string.rs:+3:9: +3:10\n+        _2 = const false;                // scope 0 at $DIR/string.rs:+3:9: +3:10\n+        _7 = move _1;                    // scope 0 at $DIR/string.rs:+3:9: +3:10\n+        _0 = const 4321_i32;             // scope 1 at $DIR/string.rs:+3:14: +3:18\n+        drop(_7) -> [return: bb6, unwind unreachable]; // scope 0 at $DIR/string.rs:+3:17: +3:18\n     }\n \n     bb6: {\n-        StorageDead(_6);                 // scope 0 at $DIR/string.rs:+3:17: +3:18\n-        goto -> bb9;                     // scope 0 at $DIR/string.rs:+3:17: +3:18\n+        StorageDead(_7);                 // scope 0 at $DIR/string.rs:+3:17: +3:18\n+        goto -> bb7;                     // scope 0 at $DIR/string.rs:+3:17: +3:18\n     }\n \n     bb7: {\n-        return;                          // scope 0 at $DIR/string.rs:+5:2: +5:2\n+        switchInt(_2) -> [0: bb9, otherwise: bb8]; // scope 0 at $DIR/string.rs:+5:1: +5:2\n     }\n \n     bb8: {\n-        drop(_1) -> [return: bb7, unwind unreachable]; // scope 0 at $DIR/string.rs:+5:1: +5:2\n+        drop(_1) -> [return: bb9, unwind unreachable]; // scope 0 at $DIR/string.rs:+5:1: +5:2\n     }\n \n     bb9: {\n-        switchInt(_7) -> [0: bb7, otherwise: bb8]; // scope 0 at $DIR/string.rs:+5:1: +5:2\n+        return;                          // scope 0 at $DIR/string.rs:+5:2: +5:2\n     }\n }"}, {"sha": "53bf14a0ab6e92123f3bdd3cd1f3700fa8af38c1", "filename": "tests/mir-opt/inline/cycle.g.Inline.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,8 +8,8 @@\n +     let mut _5: ();                      // in scope 0 at $DIR/cycle.rs:6:5: 6:8\n +     scope 1 (inlined f::<fn() {main}>) { // at $DIR/cycle.rs:12:5: 12:12\n +         debug g => _2;                   // in scope 1 at $DIR/cycle.rs:5:6: 5:7\n-+         let _3: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         let mut _4: &fn() {main};        // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         let mut _3: &fn() {main};        // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         let _4: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         scope 2 (inlined <fn() {main} as Fn<()>>::call - shim(fn() {main})) { // at $DIR/cycle.rs:6:5: 6:8\n +         }\n +     }\n@@ -25,16 +25,16 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/cycle.rs:12:7: 12:11\n                                            // + literal: Const { ty: fn() {main}, val: Value(<ZST>) }\n-+         StorageLive(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n-+         StorageLive(_4);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n-+         _4 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         StorageLive(_4);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n++         StorageLive(_3);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         _3 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         StorageLive(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         _5 = const ();                   // scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         _3 = move (*_4)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n++         _4 = move (*_3)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n       }\n   \n       bb1: {\n-+         StorageDead(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n++         StorageDead(_4);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n +         StorageDead(_2);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n           StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:+1:12: +1:13\n           _0 = const ();                   // scope 0 at $DIR/cycle.rs:+0:8: +2:2\n@@ -51,7 +51,7 @@\n + \n +     bb4: {\n +         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n +         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n       }\n   }"}, {"sha": "fdf6337a9bee6e1648201c163bee3c155f491ebd", "filename": "tests/mir-opt/inline/cycle.main.Inline.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,8 +8,8 @@\n +     let mut _5: ();                      // in scope 0 at $DIR/cycle.rs:6:5: 6:8\n +     scope 1 (inlined f::<fn() {g}>) {    // at $DIR/cycle.rs:17:5: 17:9\n +         debug g => _2;                   // in scope 1 at $DIR/cycle.rs:5:6: 5:7\n-+         let _3: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         let mut _4: &fn() {g};           // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         let mut _3: &fn() {g};           // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         let _4: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         scope 2 (inlined <fn() {g} as Fn<()>>::call - shim(fn() {g})) { // at $DIR/cycle.rs:6:5: 6:8\n +         }\n +     }\n@@ -25,16 +25,16 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/cycle.rs:17:7: 17:8\n                                            // + literal: Const { ty: fn() {g}, val: Value(<ZST>) }\n-+         StorageLive(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n-+         StorageLive(_4);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n-+         _4 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         StorageLive(_4);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n++         StorageLive(_3);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n++         _3 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         StorageLive(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         _5 = const ();                   // scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         _3 = move (*_4)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n++         _4 = move (*_3)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n       }\n   \n       bb1: {\n-+         StorageDead(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n++         StorageDead(_4);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n +         StorageDead(_2);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n           StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:+1:9: +1:10\n           _0 = const ();                   // scope 0 at $DIR/cycle.rs:+0:11: +2:2\n@@ -51,7 +51,7 @@\n + \n +     bb4: {\n +         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n +         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n       }\n   }"}, {"sha": "33bf3b73b2372b85a2c59983a4699972e9e5166c", "filename": "tests/mir-opt/inline/inline_closure_captures.foo.Inline.after.mir", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -17,10 +17,10 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n             debug _q => _9;              // in scope 2 at $DIR/inline_closure_captures.rs:+1:14: +1:16\n             debug q => (*((*_6).0: &i32)); // in scope 2 at $DIR/inline_closure_captures.rs:+0:23: +0:24\n             debug t => (*((*_6).1: &T)); // in scope 2 at $DIR/inline_closure_captures.rs:+0:17: +0:18\n-            let mut _10: i32;            // in scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n-            let mut _11: T;              // in scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n-            let mut _12: &i32;           // in scope 2 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n-            let mut _13: &T;             // in scope 2 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n+            let mut _10: &i32;           // in scope 2 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n+            let mut _11: i32;            // in scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n+            let mut _12: &T;             // in scope 2 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n+            let mut _13: T;              // in scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n         }\n     }\n \n@@ -49,15 +49,15 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n         _7 = (move _8,);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         StorageLive(_9);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         _9 = move (_7.0: i32);           // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n-        StorageLive(_10);                // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n-        _12 = deref_copy ((*_6).0: &i32); // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n-        _10 = (*_12);                    // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n-        StorageLive(_11);                // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n-        _13 = deref_copy ((*_6).1: &T);  // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n-        _11 = (*_13);                    // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n-        _0 = (move _10, move _11);       // scope 2 at $DIR/inline_closure_captures.rs:+1:18: +1:24\n+        StorageLive(_11);                // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n+        _10 = deref_copy ((*_6).0: &i32); // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n+        _11 = (*_10);                    // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n+        StorageLive(_13);                // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n+        _12 = deref_copy ((*_6).1: &T);  // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n+        _13 = (*_12);                    // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n+        _0 = (move _11, move _13);       // scope 2 at $DIR/inline_closure_captures.rs:+1:18: +1:24\n+        StorageDead(_13);                // scope 2 at $DIR/inline_closure_captures.rs:+1:23: +1:24\n         StorageDead(_11);                // scope 2 at $DIR/inline_closure_captures.rs:+1:23: +1:24\n-        StorageDead(_10);                // scope 2 at $DIR/inline_closure_captures.rs:+1:23: +1:24\n         StorageDead(_9);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         StorageDead(_8);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:8: +2:9\n         StorageDead(_7);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:8: +2:9"}, {"sha": "255451e867030a95f3a28a069cb910be77d967f1", "filename": "tests/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,15 +8,15 @@\n +     let mut _8: ();                      // in scope 0 at $DIR/inline_diverging.rs:27:13: 27:16\n +     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline_diverging.rs:22:5: 22:22\n +         debug f => _2;                   // in scope 1 at $DIR/inline_diverging.rs:26:36: 26:37\n-+         let _3: !;                       // in scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n-+         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n++         let mut _3: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n++         let _4: !;                       // in scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n +         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:14\n-+         let mut _6: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         let mut _7: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:9: 29:10\n++         let mut _6: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:9: 29:10\n++         let mut _7: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:6: 29:7\n +         scope 2 {\n-+             debug a => _3;               // in scope 2 at $DIR/inline_diverging.rs:27:9: 27:10\n++             debug a => _4;               // in scope 2 at $DIR/inline_diverging.rs:27:9: 27:10\n +             scope 3 {\n-+                 debug b => _7;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n++                 debug b => _6;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n +             }\n +         }\n +         scope 4 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline_diverging.rs:27:13: 27:16\n@@ -34,22 +34,22 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline_diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(<ZST>) }\n-+         StorageLive(_7);                 // scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n-+         StorageLive(_3);                 // scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n-+         StorageLive(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n-+         _4 = &_2;                        // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n++         StorageLive(_6);                 // scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n++         StorageLive(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n++         StorageLive(_3);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n++         _3 = &_2;                        // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n +         StorageLive(_8);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n +         _8 = const ();                   // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n-+         _3 = move (*_4)() -> [return: bb6, unwind: bb4]; // scope 4 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n++         _4 = move (*_3)() -> [return: bb6, unwind: bb4]; // scope 4 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n +     }\n + \n +     bb1: {\n +         StorageDead(_5);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n-+         StorageLive(_6);                 // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         _6 = move _3;                    // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         _1 = (move _6, move _7);         // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n-+         StorageDead(_6);                 // scope 3 at $DIR/inline_diverging.rs:29:10: 29:11\n-+         StorageDead(_3);                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n++         StorageLive(_7);                 // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n++         _7 = move _4;                    // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n++         _1 = (move _7, move _6);         // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n++         StorageDead(_7);                 // scope 3 at $DIR/inline_diverging.rs:29:10: 29:11\n++         StorageDead(_4);                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n +         drop(_2) -> bb2;                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n +     }\n + \n@@ -58,7 +58,7 @@\n +     }\n + \n +     bb3 (cleanup): {\n-+         drop(_3) -> [return: bb4, unwind terminate]; // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n++         drop(_4) -> [return: bb4, unwind terminate]; // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n +     }\n + \n +     bb4 (cleanup): {\n@@ -71,10 +71,10 @@\n + \n +     bb6: {\n +         StorageDead(_8);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n-+         StorageDead(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:15: 27:16\n++         StorageDead(_3);                 // scope 1 at $DIR/inline_diverging.rs:27:15: 27:16\n +         StorageLive(_5);                 // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n +         _5 = &_2;                        // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n-+         _7 = <fn() -> ! {sleep} as Fn<()>>::call(move _5, const ()) -> [return: bb1, unwind: bb3]; // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n++         _6 = <fn() -> ! {sleep} as Fn<()>>::call(move _5, const ()) -> [return: bb1, unwind: bb3]; // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n +                                          // mir::Constant\n +                                          // + span: $DIR/inline_diverging.rs:28:13: 28:14\n +                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a fn() -> ! {sleep}, ()) -> <fn() -> ! {sleep} as FnOnce<()>>::Output {<fn() -> ! {sleep} as Fn<()>>::call}, val: Value(<ZST>) }"}, {"sha": "0dcae1e4d45f98a5c6a757b6b1e5d2152b53ee81", "filename": "tests/mir-opt/inline/inline_generator.main.Inline.diff", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -23,9 +23,9 @@\n +     }\n +     scope 6 (inlined g::{closure#0}) {   // at $DIR/inline_generator.rs:9:33: 9:46\n +         debug a => _5;                   // in scope 6 at $DIR/inline_generator.rs:15:6: 15:7\n-+         let mut _6: i32;                 // in scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n++         let mut _6: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         let mut _7: u32;                 // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         let mut _8: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _8: i32;                 // in scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n +         let mut _9: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         let mut _10: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +     }\n@@ -70,9 +70,9 @@\n -                                          // + literal: Const { ty: for<'a> fn(Pin<&'a mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>, bool) -> GeneratorState<<[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::Yield, <[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::Return> {<[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::resume}, val: Value(<ZST>) }\n +         StorageLive(_5);                 // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n +         _5 = const false;                // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n-+         _8 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         _7 = discriminant((*_8));        // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         switchInt(move _7) -> [0: bb3, 1: bb8, 3: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         _6 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         _7 = discriminant((*_6));        // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         switchInt(move _7) -> [0: bb3, 1: bb7, 3: bb8, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n       }\n   \n -     bb3: {\n@@ -91,40 +91,40 @@\n +     }\n + \n +     bb3: {\n-+         StorageLive(_6);                 // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n-+         switchInt(_5) -> [0: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n++         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n++         switchInt(_5) -> [0: bb4, otherwise: bb5]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n +     }\n + \n +     bb4: {\n-+         _6 = const 7_i32;                // scope 6 at $DIR/inline_generator.rs:15:24: 15:25\n++         _8 = const 13_i32;               // scope 6 at $DIR/inline_generator.rs:15:35: 15:37\n +         goto -> bb6;                     // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n +     }\n + \n +     bb5: {\n-+         _6 = const 13_i32;               // scope 6 at $DIR/inline_generator.rs:15:35: 15:37\n++         _8 = const 7_i32;                // scope 6 at $DIR/inline_generator.rs:15:24: 15:25\n +         goto -> bb6;                     // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n +     }\n + \n +     bb6: {\n-+         _1 = GeneratorState::<i32, bool>::Yielded(move _6); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         _1 = GeneratorState::<i32, bool>::Yielded(move _8); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         _9 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         discriminant((*_9)) = 3;         // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:11: 15:39\n +     }\n + \n +     bb7: {\n-+         StorageLive(_6);                 // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         StorageDead(_6);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n++         assert(const false, \"generator resumed after completion\") -> [success: bb7, unwind: bb2]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++     }\n++ \n++     bb8: {\n++         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         StorageDead(_8);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n +         _1 = GeneratorState::<i32, bool>::Complete(_5); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         _10 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         discriminant((*_10)) = 1;        // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:41: 15:41\n +     }\n + \n-+     bb8: {\n-+         assert(const false, \"generator resumed after completion\") -> [success: bb8, unwind: bb2]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+     }\n-+ \n +     bb9: {\n +         unreachable;                     // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n       }"}, {"sha": "5fed54f83a78863b497e4cb4752b593c07354d38", "filename": "tests/mir-opt/inline/issue_106141.outer.Inline.diff", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Fissue_106141.outer.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Fissue_106141.outer.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_106141.outer.Inline.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4,9 +4,9 @@\n   fn outer() -> usize {\n       let mut _0: usize;                   // return place in scope 0 at $DIR/issue_106141.rs:+0:19: +0:24\n +     scope 1 (inlined inner) {            // at $DIR/issue_106141.rs:3:5: 3:12\n-+         let mut _1: bool;                // in scope 1 at $DIR/issue_106141.rs:14:8: 14:21\n++         let mut _1: &[bool; 1];          // in scope 1 at $DIR/issue_106141.rs:12:18: 12:25\n +         let mut _2: bool;                // in scope 1 at $DIR/issue_106141.rs:14:8: 14:21\n-+         let mut _3: &[bool; 1];          // in scope 1 at $DIR/issue_106141.rs:12:18: 12:25\n++         let mut _3: bool;                // in scope 1 at $DIR/issue_106141.rs:14:8: 14:21\n +         scope 2 {\n +             debug buffer => const _;     // in scope 2 at $DIR/issue_106141.rs:12:9: 12:15\n +             scope 3 {\n@@ -17,8 +17,8 @@\n   \n       bb0: {\n -         _0 = inner() -> bb1;             // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n-+         StorageLive(_3);                 // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n-+         _3 = const _;                    // scope 1 at $DIR/issue_106141.rs:12:18: 12:25\n++         StorageLive(_1);                 // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n++         _1 = const _;                    // scope 1 at $DIR/issue_106141.rs:12:18: 12:25\n                                            // mir::Constant\n -                                          // + span: $DIR/issue_106141.rs:3:5: 3:10\n -                                          // + literal: Const { ty: fn() -> usize {inner}, val: Value(<ZST>) }\n@@ -31,14 +31,14 @@\n       }\n   \n       bb1: {\n-+         StorageLive(_1);                 // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n++         StorageLive(_3);                 // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n +         _2 = Lt(_0, const 1_usize);      // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n +         assert(move _2, \"index out of bounds: the length is {} but the index is {}\", const 1_usize, _0) -> bb2; // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n +     }\n + \n +     bb2: {\n-+         _1 = (*_3)[_0];                  // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n-+         switchInt(move _1) -> [0: bb3, otherwise: bb4]; // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n++         _3 = (*_1)[_0];                  // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n++         switchInt(move _3) -> [0: bb3, otherwise: bb4]; // scope 3 at $DIR/issue_106141.rs:14:8: 14:21\n +     }\n + \n +     bb3: {\n@@ -47,8 +47,8 @@\n +     }\n + \n +     bb4: {\n-+         StorageDead(_1);                 // scope 3 at $DIR/issue_106141.rs:18:5: 18:6\n-+         StorageDead(_3);                 // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n++         StorageDead(_3);                 // scope 3 at $DIR/issue_106141.rs:18:5: 18:6\n++         StorageDead(_1);                 // scope 0 at $DIR/issue_106141.rs:+1:5: +1:12\n           return;                          // scope 0 at $DIR/issue_106141.rs:+2:2: +2:2\n       }\n   }"}, {"sha": "f4b2416eaab11d674185b852289236c98e68fb16", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -7,38 +7,38 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n     scope 1 (inlined core::num::<impl u16>::unchecked_shl) { // at $DIR/unchecked_shifts.rs:11:7: 11:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n         debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        let mut _3: u16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _4: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _5: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _3: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _4: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _13: u16;                // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         scope 2 {\n             scope 3 (inlined core::num::<impl u16>::unchecked_shl::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                debug x => _5;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _6: std::option::Option<u16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _7: std::result::Result<u16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                debug x => _4;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _8: std::result::Result<u16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _11: std::option::Option<u16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n                 scope 4 {\n                     scope 5 (inlined <u32 as TryInto<u16>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _5; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                        debug self => _4; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n                         scope 6 (inlined convert::num::<impl TryFrom<u32> for u16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                            debug u => _5; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _8: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _9: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _10: u16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            debug u => _4; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _5: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _6: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _7: u16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                         }\n                     }\n                     scope 7 (inlined Result::<u16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _7; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let mut _11: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let _12: u16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        debug self => _8; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let mut _9: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let _10: u16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n                         scope 8 {\n-                            debug x => _12; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                            debug x => _10; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                         }\n                     }\n                     scope 9 (inlined #[track_caller] Option::<u16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _6; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _13: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _14: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        debug self => _11; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _12: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _14: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n                         scope 10 {\n-                            debug val => _3; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug val => _13; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                         scope 11 {\n                             scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n@@ -49,7 +49,7 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n                             }\n                         }\n                         scope 12 (inlined Option::<u16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                            debug self => _13; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug self => _14; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                     }\n                 }\n@@ -58,81 +58,81 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n     }\n \n     bb0: {\n+        StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _3 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _4 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _5 = move (_4.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _9 = const 65535_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _8 = Gt(_5, move _9);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        switchInt(move _8) -> [0: bb3, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _4 = move (_3.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _5 = const 65535_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _6 = Gt(_4, move _5);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        switchInt(move _6) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _7 = _4 as u16 (IntToInt);       // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _8 = Result::<u16, TryFromIntError>::Ok(move _7); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb2: {\n-        _7 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _8 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: no-location\n                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n-        goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _10 = _5 as u16 (IntToInt);      // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _7 = Result::<u16, TryFromIntError>::Ok(move _10); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _9 = discriminant(_8);           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb9]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb4: {\n-        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _11 = discriminant(_7);          // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _11) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _10 = move ((_8 as Ok).0: u16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _11 = Option::<u16>::Some(move _10); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+        goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb5: {\n-        _6 = Option::<u16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _11 = Option::<u16>::None;       // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb6: {\n-        unreachable;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _12 = discriminant(_11);         // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _12) -> [1: bb7, otherwise: bb9]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb7: {\n-        _12 = move ((_7 as Ok).0: u16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _6 = Option::<u16>::Some(move _12); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _13 = move ((_11 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _0 = unchecked_shl::<u16>(_1, move _13) -> [return: bb8, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n     }\n \n     bb8: {\n-        StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _14 = discriminant(_6);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _14) -> [1: bb9, otherwise: bb6]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n     }\n \n     bb9: {\n-        _3 = move ((_6 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _0 = unchecked_shl::<u16>(_1, move _3) -> [return: bb1, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n+        unreachable;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n }"}, {"sha": "67f0fe8932f4105773e8c4abe707c8dd714858cd", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -7,38 +7,38 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n     scope 1 (inlined core::num::<impl i16>::unchecked_shr) { // at $DIR/unchecked_shifts.rs:17:7: 17:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n         debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        let mut _3: i16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _4: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _5: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _3: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _4: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _13: i16;                // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         scope 2 {\n             scope 3 (inlined core::num::<impl i16>::unchecked_shr::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                debug x => _5;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _6: std::option::Option<i16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _7: std::result::Result<i16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                debug x => _4;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _8: std::result::Result<i16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _11: std::option::Option<i16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n                 scope 4 {\n                     scope 5 (inlined <u32 as TryInto<i16>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _5; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                        debug self => _4; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n                         scope 6 (inlined convert::num::<impl TryFrom<u32> for i16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                            debug u => _5; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _8: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _9: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _10: i16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            debug u => _4; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _5: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _6: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _7: i16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                         }\n                     }\n                     scope 7 (inlined Result::<i16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _7; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let mut _11: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let _12: i16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        debug self => _8; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let mut _9: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let _10: i16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n                         scope 8 {\n-                            debug x => _12; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                            debug x => _10; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                         }\n                     }\n                     scope 9 (inlined #[track_caller] Option::<i16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _6; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _13: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _14: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        debug self => _11; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _12: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _14: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n                         scope 10 {\n-                            debug val => _3; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug val => _13; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                         scope 11 {\n                             scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n@@ -49,7 +49,7 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n                             }\n                         }\n                         scope 12 (inlined Option::<i16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                            debug self => _13; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug self => _14; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                     }\n                 }\n@@ -58,81 +58,81 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n     }\n \n     bb0: {\n+        StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _3 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _4 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _5 = move (_4.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _9 = const 32767_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _8 = Gt(_5, move _9);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        switchInt(move _8) -> [0: bb3, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _4 = move (_3.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _5 = const 32767_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _6 = Gt(_4, move _5);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        switchInt(move _6) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _7 = _4 as i16 (IntToInt);       // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _8 = Result::<i16, TryFromIntError>::Ok(move _7); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb2: {\n-        _7 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _8 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: no-location\n                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n-        goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _10 = _5 as i16 (IntToInt);      // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _7 = Result::<i16, TryFromIntError>::Ok(move _10); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _9 = discriminant(_8);           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb9]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb4: {\n-        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _11 = discriminant(_7);          // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _11) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _10 = move ((_8 as Ok).0: i16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _11 = Option::<i16>::Some(move _10); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+        goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb5: {\n-        _6 = Option::<i16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _11 = Option::<i16>::None;       // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb6: {\n-        unreachable;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _12 = discriminant(_11);         // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _12) -> [1: bb7, otherwise: bb9]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb7: {\n-        _12 = move ((_7 as Ok).0: i16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _6 = Option::<i16>::Some(move _12); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _13 = move ((_11 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _0 = unchecked_shr::<i16>(_1, move _13) -> [return: bb8, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n     }\n \n     bb8: {\n-        StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _14 = discriminant(_6);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _14) -> [1: bb9, otherwise: bb6]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+        return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n     }\n \n     bb9: {\n-        _3 = move ((_6 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _0 = unchecked_shr::<i16>(_1, move _3) -> [return: bb1, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n+        unreachable;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n }"}, {"sha": "601d83702f435d787c95e41cdb23e91bab0077a6", "filename": "tests/mir-opt/inline/unwrap_unchecked.unwrap_unchecked.PreCodegen.after.mir", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Funwrap_unchecked.unwrap_unchecked.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Finline%2Funwrap_unchecked.unwrap_unchecked.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funwrap_unchecked.unwrap_unchecked.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -5,8 +5,8 @@ fn unwrap_unchecked(_1: Option<T>) -> T {\n     let mut _0: T;                       // return place in scope 0 at $DIR/unwrap_unchecked.rs:+0:54: +0:55\n     scope 1 (inlined #[track_caller] Option::<T>::unwrap_unchecked) { // at $DIR/unwrap_unchecked.rs:10:9: 10:27\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n-        let mut _2: &std::option::Option<T>; // in scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n-        let mut _3: isize;               // in scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n+        let mut _2: isize;               // in scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n+        let mut _3: &std::option::Option<T>; // in scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n         scope 2 {\n             debug val => _0;             // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n         }\n@@ -19,23 +19,23 @@ fn unwrap_unchecked(_1: Option<T>) -> T {\n             }\n         }\n         scope 4 (inlined Option::<T>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-            debug self => _2;            // in scope 4 at $SRC_DIR/core/src/option.rs:LL:COL\n+            debug self => _3;            // in scope 4 at $SRC_DIR/core/src/option.rs:LL:COL\n         }\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/unwrap_unchecked.rs:+1:9: +1:27\n-        _3 = discriminant(_1);           // scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _3) -> [1: bb2, otherwise: bb1]; // scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageLive(_3);                 // scope 0 at $DIR/unwrap_unchecked.rs:+1:9: +1:27\n+        _2 = discriminant(_1);           // scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _2) -> [1: bb1, otherwise: bb2]; // scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb1: {\n-        unreachable;                     // scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+        _0 = move ((_1 as Some).0: T);   // scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_3);                 // scope 0 at $DIR/unwrap_unchecked.rs:+1:9: +1:27\n+        return;                          // scope 0 at $DIR/unwrap_unchecked.rs:+2:2: +2:2\n     }\n \n     bb2: {\n-        _0 = move ((_1 as Some).0: T);   // scope 1 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_2);                 // scope 0 at $DIR/unwrap_unchecked.rs:+1:9: +1:27\n-        return;                          // scope 0 at $DIR/unwrap_unchecked.rs:+2:2: +2:2\n+        unreachable;                     // scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n     }\n }"}, {"sha": "2f68f65c87492f985ee27f4dcde603ae4d89dd53", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -18,8 +18,8 @@\n       let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:15:5: 15:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:6:13: 6:14\n-          let mut _14: u32;                // in scope 1 at $DIR/issue_101973.rs:8:12: 8:27\n-          let mut _15: u32;                // in scope 1 at $DIR/issue_101973.rs:8:12: 8:20\n+          let mut _14: u32;                // in scope 1 at $DIR/issue_101973.rs:8:12: 8:20\n+          let mut _15: u32;                // in scope 1 at $DIR/issue_101973.rs:8:12: 8:27\n           scope 2 {\n               debug out => _4;             // in scope 2 at $DIR/issue_101973.rs:7:9: 7:16\n           }\n@@ -33,13 +33,13 @@\n           StorageLive(_2);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageLive(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:58\n           StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n-          StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:8:12: 8:27\n-          StorageLive(_15);                // scope 2 at $DIR/issue_101973.rs:8:12: 8:20\n-          _15 = Shr(_1, const 0_i32);      // scope 2 at $DIR/issue_101973.rs:8:12: 8:20\n-          _14 = BitAnd(move _15, const 255_u32); // scope 2 at $DIR/issue_101973.rs:8:12: 8:27\n-          StorageDead(_15);                // scope 2 at $DIR/issue_101973.rs:8:26: 8:27\n-          _4 = BitOr(const 0_u32, move _14); // scope 2 at $DIR/issue_101973.rs:8:5: 8:27\n+          StorageLive(_15);                // scope 2 at $DIR/issue_101973.rs:8:12: 8:27\n+          StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:8:12: 8:20\n+          _14 = Shr(_1, const 0_i32);      // scope 2 at $DIR/issue_101973.rs:8:12: 8:20\n+          _15 = BitAnd(move _14, const 255_u32); // scope 2 at $DIR/issue_101973.rs:8:12: 8:27\n           StorageDead(_14);                // scope 2 at $DIR/issue_101973.rs:8:26: 8:27\n+          _4 = BitOr(const 0_u32, move _15); // scope 2 at $DIR/issue_101973.rs:8:5: 8:27\n+          StorageDead(_15);                // scope 2 at $DIR/issue_101973.rs:8:26: 8:27\n           StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45"}, {"sha": "fac4b8a2d25e08430ae8e11c932ddfa87c66df29", "filename": "tests/mir-opt/issues/issue_59352.num_to_digit.PreCodegen.after.mir", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,19 +3,19 @@\n fn num_to_digit(_1: char) -> u32 {\n     debug num => _1;                     // in scope 0 at $DIR/issue_59352.rs:+0:21: +0:24\n     let mut _0: u32;                     // return place in scope 0 at $DIR/issue_59352.rs:+0:35: +0:38\n-    let mut _2: std::option::Option<u32>; // in scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+    let mut _5: std::option::Option<u32>; // in scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n     scope 1 (inlined char::methods::<impl char>::is_digit) { // at $DIR/issue_59352.rs:15:12: 15:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         debug radix => const 8_u32;      // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        let _2: std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         let mut _3: &std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        let _4: std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         scope 2 (inlined Option::<u32>::is_some) { // at $SRC_DIR/core/src/char/methods.rs:LL:COL\n             debug self => _3;            // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n-            let mut _5: isize;           // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n+            let mut _4: isize;           // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n         }\n     }\n     scope 3 (inlined #[track_caller] Option::<u32>::unwrap) { // at $DIR/issue_59352.rs:15:42: 15:50\n-        debug self => _2;                // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        debug self => _5;                // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n         let mut _6: isize;               // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n         let mut _7: !;                   // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n         scope 4 {\n@@ -25,44 +25,35 @@ fn num_to_digit(_1: char) -> u32 {\n \n     bb0: {\n         StorageLive(_3);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageLive(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _4 = char::methods::<impl char>::to_digit(_1, const 8_u32) -> bb5; // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        StorageLive(_2);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        _2 = char::methods::<impl char>::to_digit(_1, const 8_u32) -> bb1; // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/char/methods.rs:LL:COL\n                                          // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageLive(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n-        _2 = char::methods::<impl char>::to_digit(_1, const 8_u32) -> bb2; // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n-                                         // mir::Constant\n-                                         // + span: $DIR/issue_59352.rs:15:30: 15:38\n-                                         // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n+        _3 = &_2;                        // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        _4 = discriminant((*_3));        // scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_3);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        StorageDead(_2);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        switchInt(move _4) -> [1: bb2, otherwise: bb7]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n     }\n \n     bb2: {\n-        _6 = discriminant(_2);           // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _6) -> [0: bb6, 1: bb8, otherwise: bb7]; // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageLive(_5);                 // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+        _5 = char::methods::<impl char>::to_digit(_1, const 8_u32) -> bb3; // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_59352.rs:15:30: 15:38\n+                                         // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n     }\n \n     bb3: {\n-        _0 = const 0_u32;                // scope 0 at $DIR/issue_59352.rs:+2:60: +2:61\n-        goto -> bb4;                     // scope 0 at $DIR/issue_59352.rs:+2:5: +2:63\n+        _6 = discriminant(_5);           // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb6]; // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb4: {\n-        return;                          // scope 0 at $DIR/issue_59352.rs:+3:2: +3:2\n-    }\n-\n-    bb5: {\n-        _3 = &_4;                        // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _5 = discriminant((*_3));        // scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_3);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageDead(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        switchInt(move _5) -> [1: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n-    }\n-\n-    bb6: {\n         _7 = core::panicking::panic(const \"called `Option::unwrap()` on a `None` value\"); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/option.rs:LL:COL\n@@ -72,13 +63,22 @@ fn num_to_digit(_1: char) -> u32 {\n                                          // + literal: Const { ty: &str, val: Value(Slice(..)) }\n     }\n \n-    bb7: {\n+    bb5: {\n+        _0 = move ((_5 as Some).0: u32); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_5);                 // scope 0 at $DIR/issue_59352.rs:+2:49: +2:50\n+        goto -> bb8;                     // scope 0 at $DIR/issue_59352.rs:+2:5: +2:63\n+    }\n+\n+    bb6: {\n         unreachable;                     // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n+    bb7: {\n+        _0 = const 0_u32;                // scope 0 at $DIR/issue_59352.rs:+2:60: +2:61\n+        goto -> bb8;                     // scope 0 at $DIR/issue_59352.rs:+2:5: +2:63\n+    }\n+\n     bb8: {\n-        _0 = move ((_2 as Some).0: u32); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:49: +2:50\n-        goto -> bb4;                     // scope 0 at $DIR/issue_59352.rs:+2:5: +2:63\n+        return;                          // scope 0 at $DIR/issue_59352.rs:+3:2: +3:2\n     }\n }"}, {"sha": "6b805166ba29ce70159e4ca5e96b038611b2ac31", "filename": "tests/mir-opt/pre-codegen/duplicate_switch_targets.ub_if_b.PreCodegen.after.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fduplicate_switch_targets.ub_if_b.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fduplicate_switch_targets.ub_if_b.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fduplicate_switch_targets.ub_if_b.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -13,15 +13,15 @@ fn ub_if_b(_1: Thing) -> Thing {\n \n     bb0: {\n         _2 = discriminant(_1);           // scope 0 at $DIR/duplicate_switch_targets.rs:+1:11: +1:12\n-        switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/duplicate_switch_targets.rs:+1:5: +1:12\n+        switchInt(move _2) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/duplicate_switch_targets.rs:+1:5: +1:12\n     }\n \n     bb1: {\n-        unreachable;                     // scope 2 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+        _0 = move _1;                    // scope 0 at $DIR/duplicate_switch_targets.rs:+2:21: +2:22\n+        return;                          // scope 0 at $DIR/duplicate_switch_targets.rs:+5:2: +5:2\n     }\n \n     bb2: {\n-        _0 = move _1;                    // scope 0 at $DIR/duplicate_switch_targets.rs:+2:21: +2:22\n-        return;                          // scope 0 at $DIR/duplicate_switch_targets.rs:+5:2: +5:2\n+        unreachable;                     // scope 2 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n     }\n }"}, {"sha": "9856cdd5688ba980247f61763561f8365b6a2ec6", "filename": "tests/mir-opt/pre-codegen/range_iter.forward_loop.PreCodegen.after.mir", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.forward_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.forward_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.forward_loop.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -7,20 +7,20 @@ fn forward_loop(_1: u32, _2: u32, _3: impl Fn(u32)) -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/range_iter.rs:+0:60: +0:60\n     let mut _4: std::ops::Range<u32>;    // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n     let mut _5: std::ops::Range<u32>;    // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n-    let _6: ();                          // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n+    let mut _6: &mut std::ops::Range<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n     let mut _7: std::option::Option<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n-    let mut _8: &mut std::ops::Range<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n-    let mut _9: isize;                   // in scope 0 at $DIR/range_iter.rs:+1:5: +3:6\n-    let mut _11: &impl Fn(u32);          // in scope 0 at $DIR/range_iter.rs:+2:9: +2:10\n-    let mut _12: (u32,);                 // in scope 0 at $DIR/range_iter.rs:+2:9: +2:13\n+    let mut _8: isize;                   // in scope 0 at $DIR/range_iter.rs:+1:5: +3:6\n+    let mut _10: &impl Fn(u32);          // in scope 0 at $DIR/range_iter.rs:+2:9: +2:10\n+    let mut _11: (u32,);                 // in scope 0 at $DIR/range_iter.rs:+2:9: +2:13\n+    let _12: ();                         // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n     scope 1 {\n         debug iter => _5;                // in scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        let _10: u32;                    // in scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n+        let _9: u32;                     // in scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n         scope 2 {\n-            debug x => _10;              // in scope 2 at $DIR/range_iter.rs:+1:9: +1:10\n+            debug x => _9;               // in scope 2 at $DIR/range_iter.rs:+1:9: +1:10\n         }\n         scope 4 (inlined iter::range::<impl Iterator for std::ops::Range<u32>>::next) { // at $DIR/range_iter.rs:21:14: 21:24\n-            debug self => _8;            // in scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            debug self => _6;            // in scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n         }\n     }\n     scope 3 (inlined <std::ops::Range<u32> as IntoIterator>::into_iter) { // at $DIR/range_iter.rs:21:14: 21:24\n@@ -36,56 +36,56 @@ fn forward_loop(_1: u32, _2: u32, _3: impl Fn(u32)) -> () {\n \n     bb1: {\n         StorageLive(_7);                 // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        _8 = &mut _5;                    // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        _7 = <std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next(_8) -> [return: bb9, unwind: bb7]; // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _6 = &mut _5;                    // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+        _7 = <std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next(_6) -> [return: bb2, unwind: bb8]; // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n                                          // + literal: Const { ty: for<'a> fn(&'a mut std::ops::Range<u32>) -> Option<<std::ops::Range<u32> as iter::range::RangeIteratorImpl>::Item> {<std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n-        _10 = ((_7 as Some).0: u32);     // scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n-        StorageLive(_11);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n-        _11 = &_3;                       // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n-        StorageLive(_12);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-        _12 = (_10,);                    // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-        _6 = <impl Fn(u32) as Fn<(u32,)>>::call(move _11, move _12) -> [return: bb5, unwind: bb7]; // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-                                         // mir::Constant\n-                                         // + span: $DIR/range_iter.rs:22:9: 22:10\n-                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(u32), (u32,)) -> <impl Fn(u32) as FnOnce<(u32,)>>::Output {<impl Fn(u32) as Fn<(u32,)>>::call}, val: Value(<ZST>) }\n+        _8 = discriminant(_7);           // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb7]; // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n     }\n \n     bb3: {\n-        unreachable;                     // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n+        StorageDead(_5);                 // scope 0 at $DIR/range_iter.rs:+3:5: +3:6\n+        drop(_3) -> bb4;                 // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n     }\n \n     bb4: {\n-        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n-        StorageDead(_5);                 // scope 0 at $DIR/range_iter.rs:+3:5: +3:6\n-        drop(_3) -> bb6;                 // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+        return;                          // scope 0 at $DIR/range_iter.rs:+4:2: +4:2\n     }\n \n     bb5: {\n-        StorageDead(_12);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n-        StorageDead(_11);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n-        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n-        goto -> bb1;                     // scope 1 at $DIR/range_iter.rs:+1:5: +3:6\n+        _9 = ((_7 as Some).0: u32);      // scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n+        StorageLive(_10);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n+        _10 = &_3;                       // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n+        StorageLive(_11);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        _11 = (_9,);                     // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        _12 = <impl Fn(u32) as Fn<(u32,)>>::call(move _10, move _11) -> [return: bb6, unwind: bb8]; // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+                                         // mir::Constant\n+                                         // + span: $DIR/range_iter.rs:22:9: 22:10\n+                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(u32), (u32,)) -> <impl Fn(u32) as FnOnce<(u32,)>>::Output {<impl Fn(u32) as Fn<(u32,)>>::call}, val: Value(<ZST>) }\n     }\n \n     bb6: {\n-        return;                          // scope 0 at $DIR/range_iter.rs:+4:2: +4:2\n+        StorageDead(_11);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n+        StorageDead(_10);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n+        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n+        goto -> bb1;                     // scope 1 at $DIR/range_iter.rs:+1:5: +3:6\n     }\n \n-    bb7 (cleanup): {\n-        drop(_3) -> [return: bb8, unwind terminate]; // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+    bb7: {\n+        unreachable;                     // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n     }\n \n     bb8 (cleanup): {\n-        resume;                          // scope 0 at $DIR/range_iter.rs:+0:1: +4:2\n+        drop(_3) -> [return: bb9, unwind terminate]; // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n     }\n \n-    bb9: {\n-        _9 = discriminant(_7);           // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        switchInt(move _9) -> [0: bb4, 1: bb2, otherwise: bb3]; // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+    bb9 (cleanup): {\n+        resume;                          // scope 0 at $DIR/range_iter.rs:+0:1: +4:2\n     }\n }"}, {"sha": "a187d650a77720c8eb024375cfb926f3ae96c6a3", "filename": "tests/mir-opt/pre-codegen/range_iter.inclusive_loop.PreCodegen.after.mir", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.inclusive_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.inclusive_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.inclusive_loop.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -7,20 +7,20 @@ fn inclusive_loop(_1: u32, _2: u32, _3: impl Fn(u32)) -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/range_iter.rs:+0:62: +0:62\n     let mut _4: std::ops::RangeInclusive<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n     let mut _5: std::ops::RangeInclusive<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n-    let _6: ();                          // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n+    let mut _6: &mut std::ops::RangeInclusive<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n     let mut _7: std::option::Option<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n-    let mut _8: &mut std::ops::RangeInclusive<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n-    let mut _9: isize;                   // in scope 0 at $DIR/range_iter.rs:+1:5: +3:6\n-    let mut _11: &impl Fn(u32);          // in scope 0 at $DIR/range_iter.rs:+2:9: +2:10\n-    let mut _12: (u32,);                 // in scope 0 at $DIR/range_iter.rs:+2:9: +2:13\n+    let mut _8: isize;                   // in scope 0 at $DIR/range_iter.rs:+1:5: +3:6\n+    let mut _10: &impl Fn(u32);          // in scope 0 at $DIR/range_iter.rs:+2:9: +2:10\n+    let mut _11: (u32,);                 // in scope 0 at $DIR/range_iter.rs:+2:9: +2:13\n+    let _12: ();                         // in scope 0 at $DIR/range_iter.rs:+1:14: +1:25\n     scope 1 {\n         debug iter => _5;                // in scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n-        let _10: u32;                    // in scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n+        let _9: u32;                     // in scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n         scope 2 {\n-            debug x => _10;              // in scope 2 at $DIR/range_iter.rs:+1:9: +1:10\n+            debug x => _9;               // in scope 2 at $DIR/range_iter.rs:+1:9: +1:10\n         }\n         scope 5 (inlined iter::range::<impl Iterator for RangeInclusive<u32>>::next) { // at $DIR/range_iter.rs:28:14: 28:25\n-            debug self => _8;            // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            debug self => _6;            // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n         }\n     }\n     scope 3 (inlined RangeInclusive::<u32>::new) { // at $DIR/range_iter.rs:28:14: 28:25\n@@ -40,56 +40,56 @@ fn inclusive_loop(_1: u32, _2: u32, _3: impl Fn(u32)) -> () {\n \n     bb1: {\n         StorageLive(_7);                 // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n-        _8 = &mut _5;                    // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n-        _7 = <RangeInclusive<u32> as iter::range::RangeInclusiveIteratorImpl>::spec_next(_8) -> [return: bb9, unwind: bb7]; // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _6 = &mut _5;                    // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n+        _7 = <RangeInclusive<u32> as iter::range::RangeInclusiveIteratorImpl>::spec_next(_6) -> [return: bb2, unwind: bb8]; // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n                                          // + literal: Const { ty: for<'a> fn(&'a mut RangeInclusive<u32>) -> Option<<RangeInclusive<u32> as iter::range::RangeInclusiveIteratorImpl>::Item> {<RangeInclusive<u32> as iter::range::RangeInclusiveIteratorImpl>::spec_next}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n-        _10 = ((_7 as Some).0: u32);     // scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n-        StorageLive(_11);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n-        _11 = &_3;                       // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n-        StorageLive(_12);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-        _12 = (_10,);                    // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-        _6 = <impl Fn(u32) as Fn<(u32,)>>::call(move _11, move _12) -> [return: bb5, unwind: bb7]; // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-                                         // mir::Constant\n-                                         // + span: $DIR/range_iter.rs:29:9: 29:10\n-                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(u32), (u32,)) -> <impl Fn(u32) as FnOnce<(u32,)>>::Output {<impl Fn(u32) as Fn<(u32,)>>::call}, val: Value(<ZST>) }\n+        _8 = discriminant(_7);           // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n+        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb7]; // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n     }\n \n     bb3: {\n-        unreachable;                     // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n+        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n+        StorageDead(_5);                 // scope 0 at $DIR/range_iter.rs:+3:5: +3:6\n+        drop(_3) -> bb4;                 // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n     }\n \n     bb4: {\n-        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n-        StorageDead(_5);                 // scope 0 at $DIR/range_iter.rs:+3:5: +3:6\n-        drop(_3) -> bb6;                 // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+        return;                          // scope 0 at $DIR/range_iter.rs:+4:2: +4:2\n     }\n \n     bb5: {\n-        StorageDead(_12);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n-        StorageDead(_11);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n-        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n-        goto -> bb1;                     // scope 1 at $DIR/range_iter.rs:+1:5: +3:6\n+        _9 = ((_7 as Some).0: u32);      // scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n+        StorageLive(_10);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n+        _10 = &_3;                       // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n+        StorageLive(_11);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        _11 = (_9,);                     // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        _12 = <impl Fn(u32) as Fn<(u32,)>>::call(move _10, move _11) -> [return: bb6, unwind: bb8]; // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+                                         // mir::Constant\n+                                         // + span: $DIR/range_iter.rs:29:9: 29:10\n+                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(u32), (u32,)) -> <impl Fn(u32) as FnOnce<(u32,)>>::Output {<impl Fn(u32) as Fn<(u32,)>>::call}, val: Value(<ZST>) }\n     }\n \n     bb6: {\n-        return;                          // scope 0 at $DIR/range_iter.rs:+4:2: +4:2\n+        StorageDead(_11);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n+        StorageDead(_10);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n+        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n+        goto -> bb1;                     // scope 1 at $DIR/range_iter.rs:+1:5: +3:6\n     }\n \n-    bb7 (cleanup): {\n-        drop(_3) -> [return: bb8, unwind terminate]; // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+    bb7: {\n+        unreachable;                     // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n     }\n \n     bb8 (cleanup): {\n-        resume;                          // scope 0 at $DIR/range_iter.rs:+0:1: +4:2\n+        drop(_3) -> [return: bb9, unwind terminate]; // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n     }\n \n-    bb9: {\n-        _9 = discriminant(_7);           // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n-        switchInt(move _9) -> [0: bb4, 1: bb2, otherwise: bb3]; // scope 1 at $DIR/range_iter.rs:+1:14: +1:25\n+    bb9 (cleanup): {\n+        resume;                          // scope 0 at $DIR/range_iter.rs:+0:1: +4:2\n     }\n }"}, {"sha": "089b0c23e2ce77ee4f23c445c7973fbcf345c575", "filename": "tests/mir-opt/pre-codegen/simple_option_map.ezmap.PreCodegen.after.mir", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fsimple_option_map.ezmap.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fsimple_option_map.ezmap.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fsimple_option_map.ezmap.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,54 +3,54 @@\n fn ezmap(_1: Option<i32>) -> Option<i32> {\n     debug x => _1;                       // in scope 0 at $DIR/simple_option_map.rs:+0:14: +0:15\n     let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/simple_option_map.rs:+0:33: +0:44\n-    let mut _6: i32;                     // in scope 0 at $DIR/simple_option_map.rs:11:25: 11:29\n+    let mut _5: i32;                     // in scope 0 at $DIR/simple_option_map.rs:11:25: 11:29\n     scope 1 (inlined map::<i32, i32, [closure@$DIR/simple_option_map.rs:18:12: 18:15]>) { // at $DIR/simple_option_map.rs:18:5: 18:22\n         debug slf => _1;                 // in scope 1 at $DIR/simple_option_map.rs:6:17: 6:20\n         debug f => const ZeroSized: [closure@$DIR/simple_option_map.rs:18:12: 18:15]; // in scope 1 at $DIR/simple_option_map.rs:6:33: 6:34\n         let mut _2: isize;               // in scope 1 at $DIR/simple_option_map.rs:11:9: 11:16\n         let _3: i32;                     // in scope 1 at $DIR/simple_option_map.rs:11:14: 11:15\n-        let mut _4: i32;                 // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n-        let mut _5: (i32,);              // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n+        let mut _4: (i32,);              // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n+        let mut _6: i32;                 // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n         scope 2 {\n             debug x => _3;               // in scope 2 at $DIR/simple_option_map.rs:11:14: 11:15\n             scope 3 (inlined ezmap::{closure#0}) { // at $DIR/simple_option_map.rs:11:25: 11:29\n-                debug n => _6;           // in scope 3 at $DIR/simple_option_map.rs:+1:13: +1:14\n+                debug n => _5;           // in scope 3 at $DIR/simple_option_map.rs:+1:13: +1:14\n             }\n         }\n     }\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/simple_option_map.rs:+1:5: +1:22\n         _2 = discriminant(_1);           // scope 1 at $DIR/simple_option_map.rs:10:11: 10:14\n-        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 1 at $DIR/simple_option_map.rs:10:5: 10:14\n+        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4]; // scope 1 at $DIR/simple_option_map.rs:10:5: 10:14\n     }\n \n     bb1: {\n         _0 = Option::<i32>::None;        // scope 1 at $DIR/simple_option_map.rs:12:17: 12:21\n-        goto -> bb4;                     // scope 1 at $DIR/simple_option_map.rs:12:17: 12:21\n+        goto -> bb3;                     // scope 1 at $DIR/simple_option_map.rs:12:17: 12:21\n     }\n \n     bb2: {\n-        unreachable;                     // scope 1 at $DIR/simple_option_map.rs:10:11: 10:14\n-    }\n-\n-    bb3: {\n         _3 = ((_1 as Some).0: i32);      // scope 1 at $DIR/simple_option_map.rs:11:14: 11:15\n+        StorageLive(_6);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n         StorageLive(_4);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n+        _4 = (move _3,);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n         StorageLive(_5);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        _5 = (move _3,);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        StorageLive(_6);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        _6 = move (_5.0: i32);           // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        _4 = Add(_6, const 1_i32);       // scope 3 at $DIR/simple_option_map.rs:+1:16: +1:21\n-        StorageDead(_6);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        StorageDead(_5);                 // scope 2 at $DIR/simple_option_map.rs:11:28: 11:29\n-        _0 = Option::<i32>::Some(move _4); // scope 2 at $DIR/simple_option_map.rs:11:20: 11:30\n-        StorageDead(_4);                 // scope 2 at $DIR/simple_option_map.rs:11:29: 11:30\n-        goto -> bb4;                     // scope 1 at $DIR/simple_option_map.rs:14:1: 14:2\n+        _5 = move (_4.0: i32);           // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n+        _6 = Add(_5, const 1_i32);       // scope 3 at $DIR/simple_option_map.rs:+1:16: +1:21\n+        StorageDead(_5);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n+        StorageDead(_4);                 // scope 2 at $DIR/simple_option_map.rs:11:28: 11:29\n+        _0 = Option::<i32>::Some(move _6); // scope 2 at $DIR/simple_option_map.rs:11:20: 11:30\n+        StorageDead(_6);                 // scope 2 at $DIR/simple_option_map.rs:11:29: 11:30\n+        goto -> bb3;                     // scope 1 at $DIR/simple_option_map.rs:14:1: 14:2\n     }\n \n-    bb4: {\n+    bb3: {\n         StorageDead(_3);                 // scope 0 at $DIR/simple_option_map.rs:+1:5: +1:22\n         return;                          // scope 0 at $DIR/simple_option_map.rs:+2:2: +2:2\n     }\n+\n+    bb4: {\n+        unreachable;                     // scope 1 at $DIR/simple_option_map.rs:10:11: 10:14\n+    }\n }"}, {"sha": "b05d44f4d60ab26a7f0ca4ccb2bed17db67c9d40", "filename": "tests/mir-opt/pre-codegen/slice_index.slice_get_mut_usize.PreCodegen.after.mir", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_mut_usize.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_mut_usize.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_mut_usize.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -10,17 +10,17 @@ fn slice_get_mut_usize(_1: &mut [u32], _2: usize) -> Option<&mut u32> {\n         scope 2 (inlined <usize as SliceIndex<[u32]>>::get_mut) { // at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n             debug self => _2;            // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n             debug slice => _1;           // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-            let mut _3: bool;            // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+            let mut _3: &[u32];          // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n             let mut _4: usize;           // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-            let mut _5: &[u32];          // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-            let mut _6: &mut u32;        // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-            let mut _7: *mut u32;        // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-            let mut _8: *mut [u32];      // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+            let mut _5: bool;            // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+            let mut _6: *mut [u32];      // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+            let mut _8: *mut u32;        // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+            let mut _9: &mut u32;        // in scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n             scope 3 {\n                 scope 4 (inlined <usize as SliceIndex<[u32]>>::get_unchecked_mut) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                     debug self => _2;    // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                    debug slice => _8;   // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                    let mut _9: *mut u32; // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                    debug slice => _6;   // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                    let mut _7: *mut u32; // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                     let mut _10: usize;  // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     let mut _11: *mut [u32]; // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     scope 5 {\n@@ -40,10 +40,10 @@ fn slice_get_mut_usize(_1: &mut [u32], _2: usize) -> Option<&mut u32> {\n                                 }\n                             }\n                             scope 11 (inlined ptr::mut_ptr::<impl *mut [u32]>::as_mut_ptr) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _8; // in scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _6; // in scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                             }\n                             scope 12 (inlined ptr::mut_ptr::<impl *mut u32>::add) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _9; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _7; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 debug count => _2; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 scope 13 {\n                                 }\n@@ -56,50 +56,50 @@ fn slice_get_mut_usize(_1: &mut [u32], _2: usize) -> Option<&mut u32> {\n     }\n \n     bb0: {\n-        StorageLive(_6);                 // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_9);                 // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _5 = &(*_1);                     // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _4 = Len((*_5));                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _3 = Lt(_2, move _4);            // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _3 = &(*_1);                     // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _4 = Len((*_3));                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _5 = Lt(_2, move _4);            // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        switchInt(move _5) -> [0: bb1, otherwise: bb2]; // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageLive(_7);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _0 = const Option::<&mut u32>::None; // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: no-location\n+                                         // + literal: Const { ty: Option<&mut u32>, val: Value(Scalar(0x0000000000000000)) }\n+        goto -> bb3;                     // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+    }\n+\n+    bb2: {\n         StorageLive(_8);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _8 = &raw mut (*_1);             // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _6 = &raw mut (*_1);             // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_10);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_11);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_12);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _9 = _8 as *mut u32 (PtrToPtr);  // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        _7 = Offset(_9, _2);             // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _7 = _6 as *mut u32 (PtrToPtr);  // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+        _8 = Offset(_7, _2);             // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_12);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_11);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_10);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_8);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _6 = &mut (*_7);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _0 = Option::<&mut u32>::Some(_6); // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_7);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        goto -> bb3;                     // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-    }\n-\n-    bb2: {\n-        _0 = const Option::<&mut u32>::None; // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: no-location\n-                                         // + literal: Const { ty: Option<&mut u32>, val: Value(Scalar(0x0000000000000000)) }\n+        StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _9 = &mut (*_8);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _0 = Option::<&mut u32>::Some(_9); // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_8);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         goto -> bb3;                     // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_6);                 // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_9);                 // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         return;                          // scope 0 at $DIR/slice_index.rs:+2:2: +2:2\n     }\n }"}, {"sha": "6d9ec5d9a27f51fa4ce2194e8eb1133b3df1540e", "filename": "tests/mir-opt/pre-codegen/slice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,61 +8,61 @@ fn slice_get_unchecked_mut_range(_1: &mut [u32], _2: std::ops::Range<usize>) ->\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         debug index => _2;               // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         let mut _3: *mut [u32];          // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        let mut _4: *mut [u32];          // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        let mut _15: *mut [u32];         // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         scope 2 {\n             scope 3 (inlined <std::ops::Range<usize> as SliceIndex<[u32]>>::get_unchecked_mut) { // at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n                 debug self => _2;        // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                debug slice => _4;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let _5: std::ops::Range<usize>; // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _7: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                debug slice => _3;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let mut _4: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let mut _5: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let mut _7: *mut u32;    // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                 let mut _8: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                 let mut _9: *mut u32;    // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _10: *mut u32;   // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _11: usize;      // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _12: usize;      // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _13: std::ops::Range<usize>; // in scope 3 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                let mut _14: *mut [u32]; // in scope 3 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                let mut _10: usize;      // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let _16: std::ops::Range<usize>; // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let mut _17: std::ops::Range<usize>; // in scope 3 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                let mut _18: *mut [u32]; // in scope 3 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                 scope 4 {\n-                    debug this => _5;    // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                    debug this => _16;   // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                     scope 5 {\n                         let _6: usize;   // in scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                         scope 6 {\n                             debug new_len => _6; // in scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                             scope 11 (inlined ptr::mut_ptr::<impl *mut [u32]>::as_mut_ptr) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _4; // in scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _3; // in scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                             }\n                             scope 12 (inlined ptr::mut_ptr::<impl *mut u32>::add) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _10; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                debug count => _11; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _7; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug count => _8; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 scope 13 {\n                                 }\n                             }\n                             scope 14 (inlined slice_from_raw_parts_mut::<u32>) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                                 debug data => _9; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                debug len => _12; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                let mut _16: *mut (); // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                                debug len => _10; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                                let mut _11: *mut (); // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                                 scope 15 (inlined ptr::mut_ptr::<impl *mut u32>::cast::<()>) { // at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                                     debug self => _9; // in scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 }\n                                 scope 16 (inlined std::ptr::from_raw_parts_mut::<[u32]>) { // at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                    debug data_address => _16; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    debug metadata => _12; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    let mut _17: std::ptr::metadata::PtrRepr<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    let mut _18: std::ptr::metadata::PtrComponents<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    let mut _19: *const (); // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    debug data_address => _11; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    debug metadata => _10; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    let mut _12: *const (); // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    let mut _13: std::ptr::metadata::PtrComponents<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    let mut _14: std::ptr::metadata::PtrRepr<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n                                     scope 17 {\n                                     }\n                                 }\n                             }\n                         }\n                         scope 7 (inlined <std::ops::Range<usize> as SliceIndex<[T]>>::get_unchecked_mut::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            debug this => _13; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            debug slice => _14; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug this => _17; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug slice => _18; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                             scope 8 (inlined ptr::mut_ptr::<impl *mut [u32]>::len) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _14; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                let mut _15: *const [u32]; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _18; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                let mut _19: *const [u32]; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 scope 9 (inlined std::ptr::metadata::<[u32]>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                    debug ptr => _15; // in scope 9 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    debug ptr => _19; // in scope 9 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n                                     scope 10 {\n                                     }\n                                 }\n@@ -75,60 +75,60 @@ fn slice_get_unchecked_mut_range(_1: &mut [u32], _2: std::ops::Range<usize>) ->\n     }\n \n     bb0: {\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _4 = &raw mut (*_1);             // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_14);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_15);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _3 = &raw mut (*_1);             // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_16);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_17);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_18);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_19);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_6);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_7);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _7 = (_2.1: usize);              // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_8);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _8 = (_2.0: usize);              // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _6 = unchecked_sub::<usize>(move _7, move _8) -> [return: bb1, unwind unreachable]; // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_4);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _4 = (_2.1: usize);              // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_5);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _5 = (_2.0: usize);              // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _6 = unchecked_sub::<usize>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/slice/index.rs:LL:COL\n                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(usize, usize) -> usize {unchecked_sub::<usize>}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_8);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_7);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_5);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_4);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _7 = _3 as *mut u32 (PtrToPtr);  // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _8 = (_2.0: usize);              // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _9 = Offset(_7, _8);             // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _10 = _4 as *mut u32 (PtrToPtr); // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        StorageLive(_11);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _11 = (_2.0: usize);             // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _9 = Offset(_10, _11);           // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        StorageDead(_11);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _10 = _6;                        // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_11);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        _11 = _9 as *mut () (PtrToPtr);  // scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+        StorageLive(_14);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageLive(_13);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageLive(_12);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _12 = _11 as *const () (Pointer(MutToConstPointer)); // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _13 = ptr::metadata::PtrComponents::<[u32]> { data_address: move _12, metadata: _10 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_12);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _14 = ptr::metadata::PtrRepr::<[u32]> { const_ptr: move _13 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_13);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _15 = (_14.1: *mut [u32]);       // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_14);                // scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_11);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n         StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _12 = _6;                        // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_16);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        _16 = _9 as *mut () (PtrToPtr);  // scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        StorageLive(_17);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageLive(_18);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageLive(_19);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _19 = _16 as *const () (Pointer(MutToConstPointer)); // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _18 = ptr::metadata::PtrComponents::<[u32]> { data_address: move _19, metadata: _12 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_19);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _17 = ptr::metadata::PtrRepr::<[u32]> { const_ptr: move _18 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_18);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _3 = (_17.1: *mut [u32]);        // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_17);                // scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_16);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_6);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_15);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_14);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _0 = &mut (*_3);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_3);                 // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_19);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_18);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_17);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_16);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _0 = &mut (*_15);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_15);                // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         return;                          // scope 0 at $DIR/slice_index.rs:+2:2: +2:2\n     }\n }"}, {"sha": "0cf1d68d18a2ec091ad61d034f7950cfaefd0eda", "filename": "tests/mir-opt/pre-codegen/slice_iter.forward_loop.PreCodegen.after.mir", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.forward_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.forward_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.forward_loop.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4,41 +4,41 @@ fn forward_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n     debug slice => _1;                   // in scope 0 at $DIR/slice_iter.rs:+0:28: +0:33\n     debug f => _2;                       // in scope 0 at $DIR/slice_iter.rs:+0:44: +0:45\n     let mut _0: ();                      // return place in scope 0 at $DIR/slice_iter.rs:+0:60: +0:60\n-    let mut _3: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-    let mut _4: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-    let _5: ();                          // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-    let mut _6: std::option::Option<&T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-    let mut _7: &mut std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-    let mut _8: isize;                   // in scope 0 at $DIR/slice_iter.rs:+1:5: +3:6\n-    let mut _10: &impl Fn(&T);           // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:10\n-    let mut _11: (&T,);                  // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:13\n+    let mut _13: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+    let mut _14: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+    let mut _15: &mut std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+    let mut _16: std::option::Option<&T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+    let mut _17: isize;                  // in scope 0 at $DIR/slice_iter.rs:+1:5: +3:6\n+    let mut _19: &impl Fn(&T);           // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:10\n+    let mut _20: (&T,);                  // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:13\n+    let _21: ();                         // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n     scope 1 {\n-        debug iter => _4;                // in scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n-        let _9: &T;                      // in scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n+        debug iter => _14;               // in scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+        let _18: &T;                     // in scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n         scope 2 {\n-            debug x => _9;               // in scope 2 at $DIR/slice_iter.rs:+1:9: +1:10\n+            debug x => _18;              // in scope 2 at $DIR/slice_iter.rs:+1:9: +1:10\n         }\n     }\n     scope 3 (inlined core::slice::<impl [T]>::iter) { // at $DIR/slice_iter.rs:28:20: 28:26\n         debug self => _1;                // in scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         scope 4 (inlined std::slice::Iter::<'_, T>::new) { // at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n             debug slice => _1;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let _12: *const T;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _14: bool;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _15: usize;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _16: usize;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _17: std::ptr::NonNull<T>; // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _18: *mut T;         // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _19: *const T;       // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let _4: *const T;            // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _5: bool;            // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _6: usize;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _8: usize;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _9: *mut T;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _11: std::ptr::NonNull<T>; // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _12: *const T;       // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n             scope 5 {\n-                debug ptr => _12;        // in scope 5 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                debug ptr => _4;         // in scope 5 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                 scope 6 {\n-                    let _13: *const T;   // in scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                    let _7: *const T;    // in scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                     scope 7 {\n-                        debug end => _13; // in scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                        debug end => _7; // in scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                         scope 13 (inlined NonNull::<T>::new_unchecked) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                            debug ptr => _18; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                            let mut _21: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                            debug ptr => _9; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                            let mut _10: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n                             let mut _22: *mut T; // in scope 13 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                             scope 14 {\n                                 scope 15 (inlined NonNull::<T>::new_unchecked::runtime::<T>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n@@ -65,139 +65,139 @@ fn forward_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n                         }\n                     }\n                     scope 9 (inlined invalid::<T>) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                        debug addr => _15; // in scope 9 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                        debug addr => _8; // in scope 9 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                         scope 10 {\n                         }\n                     }\n                     scope 11 (inlined ptr::const_ptr::<impl *const T>::add) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                        debug self => _12; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-                        debug count => _16; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+                        debug self => _4; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+                        debug count => _6; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n                         scope 12 {\n                         }\n                     }\n                 }\n             }\n             scope 8 (inlined core::slice::<impl [T]>::as_ptr) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                 debug self => _1;        // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-                let mut _20: *const [T]; // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+                let mut _3: *const [T];  // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n             }\n         }\n     }\n     scope 22 (inlined <std::slice::Iter<'_, T> as IntoIterator>::into_iter) { // at $DIR/slice_iter.rs:28:14: 28:26\n-        debug self => _3;                // in scope 22 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+        debug self => _13;               // in scope 22 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n     }\n \n     bb0: {\n-        StorageLive(_12);                // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_20);                // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _20 = &raw const (*_1);          // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _12 = move _20 as *const T (PtrToPtr); // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_20);                // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_13);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_14);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _14 = const _;                   // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        switchInt(move _14) -> [0: bb11, otherwise: bb10]; // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_3);                 // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _3 = &raw const (*_1);           // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _4 = move _3 as *const T (PtrToPtr); // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _5 = const _;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        switchInt(move _5) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageLive(_6);                 // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n-        _7 = &mut _4;                    // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n-        _6 = <std::slice::Iter<'_, T> as Iterator>::next(_7) -> [return: bb2, unwind: bb8]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n-                                         // mir::Constant\n-                                         // + span: $DIR/slice_iter.rs:28:14: 28:26\n-                                         // + literal: Const { ty: for<'a> fn(&'a mut std::slice::Iter<'_, T>) -> Option<<std::slice::Iter<'_, T> as Iterator>::Item> {<std::slice::Iter<'_, T> as Iterator>::next}, val: Value(<ZST>) }\n+        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _6 = Len((*_1));                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _7 = Offset(_4, _6);             // scope 12 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n     }\n \n     bb2: {\n-        _8 = discriminant(_6);           // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n-        switchInt(move _8) -> [0: bb5, 1: bb3, otherwise: bb4]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _8 = Len((*_1));                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _7 = _8 as *const T (Transmute); // scope 10 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n     }\n \n     bb3: {\n-        _9 = ((_6 as Some).0: &T);       // scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n-        StorageLive(_10);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n-        _10 = &_2;                       // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n-        StorageLive(_11);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n-        _11 = (_9,);                     // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n-        _5 = <impl Fn(&T) as Fn<(&T,)>>::call(move _10, move _11) -> [return: bb6, unwind: bb8]; // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_11);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _9 = _4 as *mut T (PtrToPtr);    // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _10 = _9 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+        _11 = NonNull::<T> { pointer: _10 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+        StorageDead(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_12);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _12 = _7;                        // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _13 = std::slice::Iter::<'_, T> { ptr: move _11, end: move _12, _marker: const ZeroSized: PhantomData<&T> }; // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                                          // mir::Constant\n-                                         // + span: $DIR/slice_iter.rs:29:9: 29:10\n-                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(&T), (&T,)) -> <impl Fn(&T) as FnOnce<(&T,)>>::Output {<impl Fn(&T) as Fn<(&T,)>>::call}, val: Value(<ZST>) }\n+                                         // + span: no-location\n+                                         // + literal: Const { ty: PhantomData<&T>, val: Value(<ZST>) }\n+                                         // adt\n+                                         // + user_ty: UserType(1)\n+        StorageDead(_12);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_11);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_14);                // scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+        _14 = move _13;                  // scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+        goto -> bb4;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n     }\n \n     bb4: {\n-        unreachable;                     // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+        StorageLive(_16);                // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+        _15 = &mut _14;                  // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+        _16 = <std::slice::Iter<'_, T> as Iterator>::next(_15) -> [return: bb5, unwind: bb11]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+                                         // mir::Constant\n+                                         // + span: $DIR/slice_iter.rs:28:14: 28:26\n+                                         // + literal: Const { ty: for<'a> fn(&'a mut std::slice::Iter<'_, T>) -> Option<<std::slice::Iter<'_, T> as Iterator>::Item> {<std::slice::Iter<'_, T> as Iterator>::next}, val: Value(<ZST>) }\n     }\n \n     bb5: {\n-        StorageDead(_6);                 // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n-        StorageDead(_4);                 // scope 0 at $DIR/slice_iter.rs:+3:5: +3:6\n-        drop(_2) -> bb7;                 // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n+        _17 = discriminant(_16);         // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n+        switchInt(move _17) -> [0: bb6, 1: bb8, otherwise: bb10]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n     }\n \n     bb6: {\n-        StorageDead(_11);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n-        StorageDead(_10);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n-        StorageDead(_6);                 // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n-        goto -> bb1;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n+        StorageDead(_16);                // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n+        StorageDead(_14);                // scope 0 at $DIR/slice_iter.rs:+3:5: +3:6\n+        drop(_2) -> bb7;                 // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n     }\n \n     bb7: {\n         return;                          // scope 0 at $DIR/slice_iter.rs:+4:2: +4:2\n     }\n \n-    bb8 (cleanup): {\n-        drop(_2) -> [return: bb9, unwind terminate]; // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n+    bb8: {\n+        _18 = ((_16 as Some).0: &T);     // scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n+        StorageLive(_19);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n+        _19 = &_2;                       // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n+        StorageLive(_20);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+        _20 = (_18,);                    // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+        _21 = <impl Fn(&T) as Fn<(&T,)>>::call(move _19, move _20) -> [return: bb9, unwind: bb11]; // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+                                         // mir::Constant\n+                                         // + span: $DIR/slice_iter.rs:29:9: 29:10\n+                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(&T), (&T,)) -> <impl Fn(&T) as FnOnce<(&T,)>>::Output {<impl Fn(&T) as Fn<(&T,)>>::call}, val: Value(<ZST>) }\n     }\n \n-    bb9 (cleanup): {\n-        resume;                          // scope 0 at $DIR/slice_iter.rs:+0:1: +4:2\n+    bb9: {\n+        StorageDead(_20);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n+        StorageDead(_19);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n+        StorageDead(_16);                // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n+        goto -> bb4;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n     }\n \n     bb10: {\n-        StorageLive(_15);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _15 = Len((*_1));                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _13 = _15 as *const T (Transmute); // scope 10 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_15);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        goto -> bb12;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        unreachable;                     // scope 1 at $DIR/slice_iter.rs:+1:14: +1:26\n     }\n \n-    bb11: {\n-        StorageLive(_16);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _16 = Len((*_1));                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _13 = Offset(_12, _16);          // scope 12 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-        StorageDead(_16);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        goto -> bb12;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+    bb11 (cleanup): {\n+        drop(_2) -> [return: bb12, unwind terminate]; // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n     }\n \n-    bb12: {\n-        StorageDead(_14);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_17);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _18 = _12 as *mut T (PtrToPtr);  // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_21);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _21 = _18 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-        _17 = NonNull::<T> { pointer: _21 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-        StorageDead(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_21);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_19);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _19 = _13;                       // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _3 = std::slice::Iter::<'_, T> { ptr: move _17, end: move _19, _marker: const ZeroSized: PhantomData<&T> }; // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: no-location\n-                                         // + literal: Const { ty: PhantomData<&T>, val: Value(<ZST>) }\n-                                         // adt\n-                                         // + user_ty: UserType(1)\n-        StorageDead(_19);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_17);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_13);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_12);                // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_4);                 // scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-        _4 = move _3;                    // scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-        goto -> bb1;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n+    bb12 (cleanup): {\n+        resume;                          // scope 0 at $DIR/slice_iter.rs:+0:1: +4:2\n     }\n }"}, {"sha": "4fde50c6fe43a0f1067635893b9134fc8e48525e", "filename": "tests/mir-opt/pre-codegen/slice_iter.reverse_loop.PreCodegen.after.mir", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.reverse_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.reverse_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.reverse_loop.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4,61 +4,61 @@ fn reverse_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n     debug slice => _1;                   // in scope 0 at $DIR/slice_iter.rs:+0:28: +0:33\n     debug f => _2;                       // in scope 0 at $DIR/slice_iter.rs:+0:44: +0:45\n     let mut _0: ();                      // return place in scope 0 at $DIR/slice_iter.rs:+0:60: +0:60\n-    let mut _3: std::iter::Rev<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-    let mut _4: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-    let mut _5: std::iter::Rev<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-    let _6: ();                          // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-    let mut _7: std::option::Option<&T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-    let mut _8: &mut std::iter::Rev<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-    let mut _9: isize;                   // in scope 0 at $DIR/slice_iter.rs:+1:5: +3:6\n-    let mut _11: &impl Fn(&T);           // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:10\n-    let mut _12: (&T,);                  // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:13\n+    let mut _13: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+    let mut _14: std::iter::Rev<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n+    let mut _15: std::iter::Rev<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n+    let mut _16: &mut std::iter::Rev<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n+    let mut _18: std::option::Option<&T>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n+    let mut _19: isize;                  // in scope 0 at $DIR/slice_iter.rs:+1:5: +3:6\n+    let mut _21: &impl Fn(&T);           // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:10\n+    let mut _22: (&T,);                  // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:13\n+    let _23: ();                         // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n     scope 1 {\n-        debug iter => _5;                // in scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n-        let _10: &T;                     // in scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n+        debug iter => _15;               // in scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n+        let _20: &T;                     // in scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n         scope 2 {\n-            debug x => _10;              // in scope 2 at $DIR/slice_iter.rs:+1:9: +1:10\n+            debug x => _20;              // in scope 2 at $DIR/slice_iter.rs:+1:9: +1:10\n         }\n         scope 25 (inlined <Rev<std::slice::Iter<'_, T>> as Iterator>::next) { // at $DIR/slice_iter.rs:35:14: 35:32\n-            debug self => _8;            // in scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-            let mut _25: &mut std::slice::Iter<'_, T>; // in scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+            debug self => _16;           // in scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+            let mut _17: &mut std::slice::Iter<'_, T>; // in scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n         }\n     }\n     scope 3 (inlined core::slice::<impl [T]>::iter) { // at $DIR/slice_iter.rs:35:20: 35:26\n         debug self => _1;                // in scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         scope 4 (inlined std::slice::Iter::<'_, T>::new) { // at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n             debug slice => _1;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let _13: *const T;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _15: bool;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _16: usize;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _17: usize;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _18: std::ptr::NonNull<T>; // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _19: *mut T;         // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-            let mut _20: *const T;       // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let _4: *const T;            // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _5: bool;            // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _6: usize;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _8: usize;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _9: *mut T;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _11: std::ptr::NonNull<T>; // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _12: *const T;       // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n             scope 5 {\n-                debug ptr => _13;        // in scope 5 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                debug ptr => _4;         // in scope 5 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                 scope 6 {\n-                    let _14: *const T;   // in scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                    let _7: *const T;    // in scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                     scope 7 {\n-                        debug end => _14; // in scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                        debug end => _7; // in scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                         scope 13 (inlined NonNull::<T>::new_unchecked) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                            debug ptr => _19; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                            let mut _22: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                            let mut _23: *mut T; // in scope 13 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug ptr => _9; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                            let mut _10: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                            let mut _24: *mut T; // in scope 13 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                             scope 14 {\n                                 scope 15 (inlined NonNull::<T>::new_unchecked::runtime::<T>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                                    debug ptr => _23; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                    debug ptr => _24; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                                     scope 16 (inlined ptr::mut_ptr::<impl *mut T>::is_null) { // at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                                        debug self => _23; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                        let mut _24: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        debug self => _24; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        let mut _25: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                         scope 17 {\n                                             scope 18 (inlined ptr::mut_ptr::<impl *mut T>::is_null::runtime_impl) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                debug ptr => _24; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                debug ptr => _25; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                 scope 19 (inlined ptr::mut_ptr::<impl *mut u8>::addr) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                    debug self => _24; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                    debug self => _25; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                     scope 20 {\n                                                         scope 21 (inlined ptr::mut_ptr::<impl *mut u8>::cast::<()>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                            debug self => _24; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                            debug self => _25; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                         }\n                                                     }\n                                                 }\n@@ -70,151 +70,151 @@ fn reverse_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n                         }\n                     }\n                     scope 9 (inlined invalid::<T>) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                        debug addr => _16; // in scope 9 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                        debug addr => _8; // in scope 9 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                         scope 10 {\n                         }\n                     }\n                     scope 11 (inlined ptr::const_ptr::<impl *const T>::add) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                        debug self => _13; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-                        debug count => _17; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+                        debug self => _4; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+                        debug count => _6; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n                         scope 12 {\n                         }\n                     }\n                 }\n             }\n             scope 8 (inlined core::slice::<impl [T]>::as_ptr) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                 debug self => _1;        // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-                let mut _21: *const [T]; // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+                let mut _3: *const [T];  // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n             }\n         }\n     }\n     scope 22 (inlined <std::slice::Iter<'_, T> as Iterator>::rev) { // at $DIR/slice_iter.rs:35:27: 35:32\n-        debug self => _4;                // in scope 22 at $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+        debug self => _13;               // in scope 22 at $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n         scope 23 (inlined Rev::<std::slice::Iter<'_, T>>::new) { // at $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-            debug iter => _4;            // in scope 23 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+            debug iter => _13;           // in scope 23 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n         }\n     }\n     scope 24 (inlined <Rev<std::slice::Iter<'_, T>> as IntoIterator>::into_iter) { // at $DIR/slice_iter.rs:35:14: 35:32\n-        debug self => _3;                // in scope 24 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+        debug self => _14;               // in scope 24 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n     }\n \n     bb0: {\n-        StorageLive(_4);                 // scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n-        StorageLive(_13);                // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_21);                // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _21 = &raw const (*_1);          // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _13 = move _21 as *const T (PtrToPtr); // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_21);                // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_14);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_15);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _15 = const _;                   // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        switchInt(move _15) -> [0: bb10, otherwise: bb9]; // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_13);                // scope 0 at $DIR/slice_iter.rs:+1:14: +1:26\n+        StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_3);                 // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _3 = &raw const (*_1);           // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _4 = move _3 as *const T (PtrToPtr); // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _5 = const _;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        switchInt(move _5) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageLive(_7);                 // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n-        _8 = &mut _5;                    // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n-        StorageLive(_25);                // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-        _25 = &mut ((*_8).0: std::slice::Iter<'_, T>); // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-        _7 = <std::slice::Iter<'_, T> as DoubleEndedIterator>::next_back(move _25) -> [return: bb12, unwind: bb7]; // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-                                         // + literal: Const { ty: for<'a> fn(&'a mut std::slice::Iter<'_, T>) -> Option<<std::slice::Iter<'_, T> as Iterator>::Item> {<std::slice::Iter<'_, T> as DoubleEndedIterator>::next_back}, val: Value(<ZST>) }\n+        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _6 = Len((*_1));                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _7 = Offset(_4, _6);             // scope 12 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n     }\n \n     bb2: {\n-        _10 = ((_7 as Some).0: &T);      // scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n-        StorageLive(_11);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n-        _11 = &_2;                       // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n-        StorageLive(_12);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n-        _12 = (_10,);                    // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n-        _6 = <impl Fn(&T) as Fn<(&T,)>>::call(move _11, move _12) -> [return: bb5, unwind: bb7]; // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n-                                         // mir::Constant\n-                                         // + span: $DIR/slice_iter.rs:36:9: 36:10\n-                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(&T), (&T,)) -> <impl Fn(&T) as FnOnce<(&T,)>>::Output {<impl Fn(&T) as Fn<(&T,)>>::call}, val: Value(<ZST>) }\n+        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _8 = Len((*_1));                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _7 = _8 as *const T (Transmute); // scope 10 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n     }\n \n     bb3: {\n-        unreachable;                     // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_11);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _9 = _4 as *mut T (PtrToPtr);    // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_25);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _10 = _9 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+        _11 = NonNull::<T> { pointer: _10 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+        StorageDead(_25);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_12);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _12 = _7;                        // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _13 = std::slice::Iter::<'_, T> { ptr: move _11, end: move _12, _marker: const ZeroSized: PhantomData<&T> }; // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: no-location\n+                                         // + literal: Const { ty: PhantomData<&T>, val: Value(<ZST>) }\n+                                         // adt\n+                                         // + user_ty: UserType(1)\n+        StorageDead(_12);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_11);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _14 = Rev::<std::slice::Iter<'_, T>> { iter: move _13 }; // scope 23 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+        StorageDead(_13);                // scope 0 at $DIR/slice_iter.rs:+1:31: +1:32\n+        StorageLive(_15);                // scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n+        _15 = move _14;                  // scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n+        goto -> bb4;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n     }\n \n     bb4: {\n-        StorageDead(_7);                 // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n-        StorageDead(_5);                 // scope 0 at $DIR/slice_iter.rs:+3:5: +3:6\n-        drop(_2) -> bb6;                 // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n+        StorageLive(_18);                // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n+        _16 = &mut _15;                  // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n+        StorageLive(_17);                // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+        _17 = &mut ((*_16).0: std::slice::Iter<'_, T>); // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+        _18 = <std::slice::Iter<'_, T> as DoubleEndedIterator>::next_back(move _17) -> [return: bb5, unwind: bb11]; // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+                                         // + literal: Const { ty: for<'a> fn(&'a mut std::slice::Iter<'_, T>) -> Option<<std::slice::Iter<'_, T> as Iterator>::Item> {<std::slice::Iter<'_, T> as DoubleEndedIterator>::next_back}, val: Value(<ZST>) }\n     }\n \n     bb5: {\n-        StorageDead(_12);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n-        StorageDead(_11);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n-        StorageDead(_7);                 // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n-        goto -> bb1;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n+        StorageDead(_17);                // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n+        _19 = discriminant(_18);         // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n+        switchInt(move _19) -> [0: bb6, 1: bb8, otherwise: bb10]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n     }\n \n     bb6: {\n-        return;                          // scope 0 at $DIR/slice_iter.rs:+4:2: +4:2\n+        StorageDead(_18);                // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n+        StorageDead(_15);                // scope 0 at $DIR/slice_iter.rs:+3:5: +3:6\n+        drop(_2) -> bb7;                 // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n     }\n \n-    bb7 (cleanup): {\n-        drop(_2) -> [return: bb8, unwind terminate]; // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n+    bb7: {\n+        return;                          // scope 0 at $DIR/slice_iter.rs:+4:2: +4:2\n     }\n \n-    bb8 (cleanup): {\n-        resume;                          // scope 0 at $DIR/slice_iter.rs:+0:1: +4:2\n+    bb8: {\n+        _20 = ((_18 as Some).0: &T);     // scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n+        StorageLive(_21);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n+        _21 = &_2;                       // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n+        StorageLive(_22);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+        _22 = (_20,);                    // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+        _23 = <impl Fn(&T) as Fn<(&T,)>>::call(move _21, move _22) -> [return: bb9, unwind: bb11]; // scope 2 at $DIR/slice_iter.rs:+2:9: +2:13\n+                                         // mir::Constant\n+                                         // + span: $DIR/slice_iter.rs:36:9: 36:10\n+                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(&T), (&T,)) -> <impl Fn(&T) as FnOnce<(&T,)>>::Output {<impl Fn(&T) as Fn<(&T,)>>::call}, val: Value(<ZST>) }\n     }\n \n     bb9: {\n-        StorageLive(_16);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _16 = Len((*_1));                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _14 = _16 as *const T (Transmute); // scope 10 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_16);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        goto -> bb11;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_22);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n+        StorageDead(_21);                // scope 2 at $DIR/slice_iter.rs:+2:12: +2:13\n+        StorageDead(_18);                // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n+        goto -> bb4;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n     }\n \n     bb10: {\n-        StorageLive(_17);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _17 = Len((*_1));                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _14 = Offset(_13, _17);          // scope 12 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-        StorageDead(_17);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        goto -> bb11;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        unreachable;                     // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n     }\n \n-    bb11: {\n-        StorageDead(_15);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_19);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _19 = _13 as *mut T (PtrToPtr);  // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _22 = _19 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-        _18 = NonNull::<T> { pointer: _22 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-        StorageDead(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_19);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_20);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _20 = _14;                       // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        _4 = std::slice::Iter::<'_, T> { ptr: move _18, end: move _20, _marker: const ZeroSized: PhantomData<&T> }; // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: no-location\n-                                         // + literal: Const { ty: PhantomData<&T>, val: Value(<ZST>) }\n-                                         // adt\n-                                         // + user_ty: UserType(1)\n-        StorageDead(_20);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_14);                // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageDead(_13);                // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _3 = Rev::<std::slice::Iter<'_, T>> { iter: move _4 }; // scope 23 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-        StorageDead(_4);                 // scope 0 at $DIR/slice_iter.rs:+1:31: +1:32\n-        StorageLive(_5);                 // scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-        _5 = move _3;                    // scope 0 at $DIR/slice_iter.rs:+1:14: +1:32\n-        goto -> bb1;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n+    bb11 (cleanup): {\n+        drop(_2) -> [return: bb12, unwind terminate]; // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n     }\n \n-    bb12: {\n-        StorageDead(_25);                // scope 25 at $SRC_DIR/core/src/iter/adapters/rev.rs:LL:COL\n-        _9 = discriminant(_7);           // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n-        switchInt(move _9) -> [0: bb4, 1: bb2, otherwise: bb3]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:32\n+    bb12 (cleanup): {\n+        resume;                          // scope 0 at $DIR/slice_iter.rs:+0:1: +4:2\n     }\n }"}, {"sha": "c3f8745b4220fd3bf3f3bb7fd1b187225679d466", "filename": "tests/mir-opt/pre-codegen/try_identity.new.PreCodegen.after.mir", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Ftry_identity.new.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Ftry_identity.new.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Ftry_identity.new.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,15 +3,15 @@\n fn new(_1: Result<T, E>) -> Result<T, E> {\n     debug x => _1;                       // in scope 0 at $DIR/try_identity.rs:+0:14: +0:15\n     let mut _0: std::result::Result<T, E>; // return place in scope 0 at $DIR/try_identity.rs:+0:34: +0:46\n-    let mut _2: std::ops::ControlFlow<E, T>; // in scope 0 at $DIR/try_identity.rs:+2:15: +7:10\n-    let mut _3: isize;                   // in scope 0 at $DIR/try_identity.rs:+4:17: +4:22\n-    let _4: T;                           // in scope 0 at $DIR/try_identity.rs:+4:20: +4:21\n+    let mut _2: isize;                   // in scope 0 at $DIR/try_identity.rs:+4:17: +4:22\n+    let _3: T;                           // in scope 0 at $DIR/try_identity.rs:+4:20: +4:21\n+    let mut _4: std::ops::ControlFlow<E, T>; // in scope 0 at $DIR/try_identity.rs:+2:15: +7:10\n     let _5: E;                           // in scope 0 at $DIR/try_identity.rs:+5:21: +5:22\n     let mut _6: isize;                   // in scope 0 at $DIR/try_identity.rs:+8:13: +8:37\n     let _7: T;                           // in scope 0 at $DIR/try_identity.rs:+8:35: +8:36\n     let _8: E;                           // in scope 0 at $DIR/try_identity.rs:+9:32: +9:33\n     scope 1 {\n-        debug v => _4;                   // in scope 1 at $DIR/try_identity.rs:+4:20: +4:21\n+        debug v => _3;                   // in scope 1 at $DIR/try_identity.rs:+4:20: +4:21\n     }\n     scope 2 {\n         debug e => _5;                   // in scope 2 at $DIR/try_identity.rs:+5:21: +5:22\n@@ -24,47 +24,47 @@ fn new(_1: Result<T, E>) -> Result<T, E> {\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/try_identity.rs:+2:15: +7:10\n-        _3 = discriminant(_1);           // scope 0 at $DIR/try_identity.rs:+3:19: +3:20\n-        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/try_identity.rs:+3:13: +3:20\n+        StorageLive(_4);                 // scope 0 at $DIR/try_identity.rs:+2:15: +7:10\n+        _2 = discriminant(_1);           // scope 0 at $DIR/try_identity.rs:+3:19: +3:20\n+        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb7]; // scope 0 at $DIR/try_identity.rs:+3:13: +3:20\n     }\n \n     bb1: {\n-        _5 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity.rs:+5:21: +5:22\n-        _2 = ControlFlow::<E, T>::Break(move _5); // scope 2 at $DIR/try_identity.rs:+5:27: +5:48\n-        goto -> bb4;                     // scope 0 at $DIR/try_identity.rs:+5:47: +5:48\n+        _3 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity.rs:+4:20: +4:21\n+        _4 = ControlFlow::<E, T>::Continue(move _3); // scope 1 at $DIR/try_identity.rs:+4:26: +4:50\n+        goto -> bb3;                     // scope 0 at $DIR/try_identity.rs:+4:49: +4:50\n     }\n \n     bb2: {\n-        unreachable;                     // scope 0 at $DIR/try_identity.rs:+3:19: +3:20\n+        _5 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity.rs:+5:21: +5:22\n+        _4 = ControlFlow::<E, T>::Break(move _5); // scope 2 at $DIR/try_identity.rs:+5:27: +5:48\n+        goto -> bb3;                     // scope 0 at $DIR/try_identity.rs:+5:47: +5:48\n     }\n \n     bb3: {\n-        _4 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity.rs:+4:20: +4:21\n-        _2 = ControlFlow::<E, T>::Continue(move _4); // scope 1 at $DIR/try_identity.rs:+4:26: +4:50\n-        goto -> bb4;                     // scope 0 at $DIR/try_identity.rs:+4:49: +4:50\n+        _6 = discriminant(_4);           // scope 0 at $DIR/try_identity.rs:+2:15: +7:10\n+        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb7]; // scope 0 at $DIR/try_identity.rs:+2:9: +7:10\n     }\n \n     bb4: {\n-        _6 = discriminant(_2);           // scope 0 at $DIR/try_identity.rs:+2:15: +7:10\n-        switchInt(move _6) -> [0: bb6, 1: bb5, otherwise: bb2]; // scope 0 at $DIR/try_identity.rs:+2:9: +7:10\n+        _7 = move ((_4 as Continue).0: T); // scope 0 at $DIR/try_identity.rs:+8:35: +8:36\n+        _0 = Result::<T, E>::Ok(move _7); // scope 0 at $DIR/try_identity.rs:+1:5: +11:6\n+        StorageDead(_4);                 // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n+        goto -> bb6;                     // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n     }\n \n     bb5: {\n-        _8 = move ((_2 as Break).0: E);  // scope 0 at $DIR/try_identity.rs:+9:32: +9:33\n+        _8 = move ((_4 as Break).0: E);  // scope 0 at $DIR/try_identity.rs:+9:32: +9:33\n         _0 = Result::<T, E>::Err(move _8); // scope 4 at $DIR/try_identity.rs:+9:45: +9:51\n-        StorageDead(_2);                 // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n-        goto -> bb7;                     // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n+        StorageDead(_4);                 // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n+        goto -> bb6;                     // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n     }\n \n     bb6: {\n-        _7 = move ((_2 as Continue).0: T); // scope 0 at $DIR/try_identity.rs:+8:35: +8:36\n-        _0 = Result::<T, E>::Ok(move _7); // scope 0 at $DIR/try_identity.rs:+1:5: +11:6\n-        StorageDead(_2);                 // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n-        goto -> bb7;                     // scope 0 at $DIR/try_identity.rs:+12:1: +12:2\n+        return;                          // scope 0 at $DIR/try_identity.rs:+12:2: +12:2\n     }\n \n     bb7: {\n-        return;                          // scope 0 at $DIR/try_identity.rs:+12:2: +12:2\n+        unreachable;                     // scope 0 at $DIR/try_identity.rs:+3:19: +3:20\n     }\n }"}, {"sha": "0487c6c3994a23f2b9c48d576910c1852ee78ef4", "filename": "tests/mir-opt/pre-codegen/try_identity.old.PreCodegen.after.mir", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Ftry_identity.old.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fpre-codegen%2Ftry_identity.old.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Ftry_identity.old.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -15,26 +15,26 @@ fn old(_1: Result<T, E>) -> Result<T, E> {\n \n     bb0: {\n         _2 = discriminant(_1);           // scope 0 at $DIR/try_identity.rs:+2:15: +2:16\n-        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/try_identity.rs:+2:9: +2:16\n+        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4]; // scope 0 at $DIR/try_identity.rs:+2:9: +2:16\n     }\n \n     bb1: {\n-        _4 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity.rs:+4:17: +4:18\n-        _0 = Result::<T, E>::Err(move _4); // scope 2 at $DIR/try_identity.rs:+4:30: +4:36\n-        goto -> bb4;                     // scope 0 at $DIR/try_identity.rs:+7:1: +7:2\n+        _3 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity.rs:+3:16: +3:17\n+        _0 = Result::<T, E>::Ok(move _3); // scope 0 at $DIR/try_identity.rs:+1:5: +6:6\n+        goto -> bb3;                     // scope 0 at $DIR/try_identity.rs:+7:1: +7:2\n     }\n \n     bb2: {\n-        unreachable;                     // scope 0 at $DIR/try_identity.rs:+2:15: +2:16\n+        _4 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity.rs:+4:17: +4:18\n+        _0 = Result::<T, E>::Err(move _4); // scope 2 at $DIR/try_identity.rs:+4:30: +4:36\n+        goto -> bb3;                     // scope 0 at $DIR/try_identity.rs:+7:1: +7:2\n     }\n \n     bb3: {\n-        _3 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity.rs:+3:16: +3:17\n-        _0 = Result::<T, E>::Ok(move _3); // scope 0 at $DIR/try_identity.rs:+1:5: +6:6\n-        goto -> bb4;                     // scope 0 at $DIR/try_identity.rs:+7:1: +7:2\n+        return;                          // scope 0 at $DIR/try_identity.rs:+7:2: +7:2\n     }\n \n     bb4: {\n-        return;                          // scope 0 at $DIR/try_identity.rs:+7:2: +7:2\n+        unreachable;                     // scope 0 at $DIR/try_identity.rs:+2:15: +2:16\n     }\n }"}, {"sha": "0b9ca29ceddc922b6c35a044f7e2797999084c00", "filename": "tests/mir-opt/simplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,8 +8,6 @@\n       let mut _3: std::option::Option<T>;  // in scope 0 at $DIR/simplify_locals_fixedpoint.rs:+1:51: +1:68\n       let mut _4: isize;                   // in scope 0 at $DIR/simplify_locals_fixedpoint.rs:+1:22: +1:26\n       let mut _5: isize;                   // in scope 0 at $DIR/simplify_locals_fixedpoint.rs:+1:13: +1:20\n--     let mut _7: bool;                    // in scope 0 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:20\n--     let mut _8: u8;                      // in scope 0 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:13\n       scope 1 {\n           debug a => _6;                   // in scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:18: +1:19\n           let _6: u8;                      // in scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:18: +1:19\n@@ -34,10 +32,9 @@\n       }\n   \n       bb2: {\n+          StorageLive(_6);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:18: +1:19\n           _6 = (((_1.0: std::option::Option<u8>) as Some).0: u8); // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:18: +1:19\n--         StorageLive(_7);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:20\n--         _7 = Gt(_6, const 42_u8);        // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:20\n--         StorageDead(_7);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+4:9: +4:10\n+          StorageDead(_6);                 // scope 0 at $DIR/simplify_locals_fixedpoint.rs:+5:5: +5:6\n           goto -> bb3;                     // scope 0 at $DIR/simplify_locals_fixedpoint.rs:+1:5: +5:6\n       }\n   "}, {"sha": "6678e4b3bd2e31ea653cd019cb202cf2631839ee", "filename": "tests/mir-opt/switch_to_self.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fswitch_to_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fswitch_to_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fswitch_to_self.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,21 @@\n+// Test that MatchBranchSimplification doesn't ICE on a SwitchInt where\n+// one of the targets is the block that the SwitchInt terminates.\n+#![crate_type = \"lib\"]\n+#![feature(core_intrinsics, custom_mir)]\n+use std::intrinsics::mir::*;\n+\n+// EMIT_MIR switch_to_self.test.MatchBranchSimplification.diff\n+#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\n+pub fn test(x: bool) {\n+    mir!(\n+        {\n+            Goto(bb0)\n+        }\n+        bb0 = {\n+            match x { false => bb0, _ => bb1 }\n+        }\n+        bb1 = {\n+            match x { false => bb0, _ => bb1 }\n+        }\n+    )\n+}"}, {"sha": "b0a4f9f018848743d8390d51c5e6afc00ac5c6b0", "filename": "tests/mir-opt/switch_to_self.test.MatchBranchSimplification.diff", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fswitch_to_self.test.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fswitch_to_self.test.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fswitch_to_self.test.MatchBranchSimplification.diff?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,19 @@\n+- // MIR for `test` before MatchBranchSimplification\n++ // MIR for `test` after MatchBranchSimplification\n+  \n+  fn test(_1: bool) -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/switch_to_self.rs:+0:22: +0:22\n+  \n+      bb0: {\n+          goto -> bb1;                     // scope 0 at $DIR/switch_to_self.rs:+3:13: +3:22\n+      }\n+  \n+      bb1: {\n+          switchInt(_1) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/switch_to_self.rs:+6:13: +6:47\n+      }\n+  \n+      bb2: {\n+          switchInt(_1) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/switch_to_self.rs:+9:13: +9:47\n+      }\n+  }\n+  "}, {"sha": "03618ae28149ce0e80afcf5028841ee24ed1824c", "filename": "tests/mir-opt/tls_access.main.PreCodegen.after.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Ftls_access.main.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Ftls_access.main.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Ftls_access.main.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2,27 +2,27 @@\n \n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/tls_access.rs:+0:11: +0:11\n-    let _2: *mut u8;                     // in scope 0 at $DIR/tls_access.rs:+2:18: +2:21\n+    let _1: *mut u8;                     // in scope 0 at $DIR/tls_access.rs:+2:18: +2:21\n     let mut _3: *mut u8;                 // in scope 0 at $DIR/tls_access.rs:+3:9: +3:12\n     scope 1 {\n-        let _1: &u8;                     // in scope 1 at $DIR/tls_access.rs:+2:13: +2:14\n+        let _2: &u8;                     // in scope 1 at $DIR/tls_access.rs:+2:13: +2:14\n         scope 2 {\n-            debug a => _1;               // in scope 2 at $DIR/tls_access.rs:+2:13: +2:14\n+            debug a => _2;               // in scope 2 at $DIR/tls_access.rs:+2:13: +2:14\n         }\n     }\n \n     bb0: {\n-        StorageLive(_1);                 // scope 1 at $DIR/tls_access.rs:+2:13: +2:14\n-        StorageLive(_2);                 // scope 1 at $DIR/tls_access.rs:+2:18: +2:21\n-        _2 = &/*tls*/ mut FOO;           // scope 1 at $DIR/tls_access.rs:+2:18: +2:21\n-        _1 = &(*_2);                     // scope 1 at $DIR/tls_access.rs:+2:17: +2:21\n+        StorageLive(_2);                 // scope 1 at $DIR/tls_access.rs:+2:13: +2:14\n+        StorageLive(_1);                 // scope 1 at $DIR/tls_access.rs:+2:18: +2:21\n+        _1 = &/*tls*/ mut FOO;           // scope 1 at $DIR/tls_access.rs:+2:18: +2:21\n+        _2 = &(*_1);                     // scope 1 at $DIR/tls_access.rs:+2:17: +2:21\n         StorageLive(_3);                 // scope 2 at $DIR/tls_access.rs:+3:9: +3:12\n         _3 = &/*tls*/ mut FOO;           // scope 2 at $DIR/tls_access.rs:+3:9: +3:12\n         (*_3) = const 42_u8;             // scope 2 at $DIR/tls_access.rs:+3:9: +3:17\n         StorageDead(_3);                 // scope 2 at $DIR/tls_access.rs:+3:17: +3:18\n         _0 = const ();                   // scope 1 at $DIR/tls_access.rs:+1:5: +4:6\n-        StorageDead(_2);                 // scope 1 at $DIR/tls_access.rs:+4:5: +4:6\n         StorageDead(_1);                 // scope 1 at $DIR/tls_access.rs:+4:5: +4:6\n+        StorageDead(_2);                 // scope 1 at $DIR/tls_access.rs:+4:5: +4:6\n         return;                          // scope 0 at $DIR/tls_access.rs:+5:2: +5:2\n     }\n }"}, {"sha": "8922eda07acfc483e532bfc97f3bd1692d61a632", "filename": "tests/mir-opt/while_storage.while_loop.PreCodegen.after.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -31,18 +31,18 @@ fn while_loop(_1: bool) -> () {\n     }\n \n     bb4: {\n-        switchInt(move _3) -> [0: bb6, otherwise: bb5]; // scope 0 at $DIR/while_storage.rs:+2:12: +2:23\n+        switchInt(move _3) -> [0: bb5, otherwise: bb6]; // scope 0 at $DIR/while_storage.rs:+2:12: +2:23\n     }\n \n     bb5: {\n         StorageDead(_3);                 // scope 0 at $DIR/while_storage.rs:+4:9: +4:10\n-        goto -> bb7;                     // scope 0 at no-location\n+        StorageDead(_2);                 // scope 0 at $DIR/while_storage.rs:+5:5: +5:6\n+        goto -> bb1;                     // scope 0 at $DIR/while_storage.rs:+1:5: +5:6\n     }\n \n     bb6: {\n         StorageDead(_3);                 // scope 0 at $DIR/while_storage.rs:+4:9: +4:10\n-        StorageDead(_2);                 // scope 0 at $DIR/while_storage.rs:+5:5: +5:6\n-        goto -> bb1;                     // scope 0 at $DIR/while_storage.rs:+1:5: +5:6\n+        goto -> bb7;                     // scope 0 at no-location\n     }\n \n     bb7: {"}, {"sha": "67f1497e70ce64d8c115ceca32abd7eecebcda4c", "filename": "tests/rustdoc-gui/source-anchor-scroll.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsource-anchor-scroll.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsource-anchor-scroll.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsource-anchor-scroll.goml?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,13 +8,13 @@ set-window-size: (600, 800)\n assert-property: (\"html\", {\"scrollTop\": \"0\"})\n \n click: '//a[text() = \"barbar\"]'\n-assert-property: (\"html\", {\"scrollTop\": \"125\"})\n+assert-property: (\"html\", {\"scrollTop\": \"149\"})\n click: '//a[text() = \"bar\"]'\n-assert-property: (\"html\", {\"scrollTop\": \"156\"})\n+assert-property: (\"html\", {\"scrollTop\": \"180\"})\n click: '//a[text() = \"sub_fn\"]'\n-assert-property: (\"html\", {\"scrollTop\": \"53\"})\n+assert-property: (\"html\", {\"scrollTop\": \"77\"})\n \n // We now check that clicking on lines doesn't change the scroll\n // Extra information: the \"sub_fn\" function header is on line 1.\n click: '//*[@id=\"6\"]'\n-assert-property: (\"html\", {\"scrollTop\": \"53\"})\n+assert-property: (\"html\", {\"scrollTop\": \"77\"})"}, {"sha": "2308c0932fd0e5329275a017f58f781669d50f46", "filename": "tests/rustdoc-gui/src/extend_css/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsrc%2Fextend_css%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsrc%2Fextend_css%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsrc%2Fextend_css%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1 +1,2 @@\n+// compile-flags: --extend-css extra.css\n //! <div class=\"extend\">text in red</div>"}, {"sha": "6fed79aedb890e91457a4f2b8a0128570eb98e5b", "filename": "tests/rustdoc-gui/src/link_to_definition/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsrc%2Flink_to_definition%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsrc%2Flink_to_definition%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsrc%2Flink_to_definition%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zunstable-options --generate-link-to-definition\n pub fn sub_fn() {\n     barbar();\n }"}, {"sha": "6666587ad541a08ee87696ea60dd7f6eab0e12be", "filename": "tests/rustdoc-gui/src/scrape_examples/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsrc%2Fscrape_examples%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-gui%2Fsrc%2Fscrape_examples%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsrc%2Fscrape_examples%2Fsrc%2Flib.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,3 +1,4 @@\n+// run-flags:-Zrustdoc-scrape-examples\n /// # Examples\n ///\n /// ```"}, {"sha": "6c834fd0a1b617ba9c4a5f2a0640f992a2b5bc92", "filename": "tests/rustdoc-ui/intra-doc/issue-110495-suffix-with-space.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -36,7 +36,7 @@ LL | //! [`Clone ()`].\n help: to link to the trait, prefix with `trait@`\n    |\n LL - //! [`Clone ()`].\n-LL + //! [`trait@Clone (`].\n+LL + //! [`trait@Clone `].\n    |\n \n error: incompatible link kind for `Clone`\n@@ -47,8 +47,9 @@ LL | //! [`Clone !`].\n    |\n help: to link to the derive macro, prefix with `derive@`\n    |\n-LL | //! [`derive@Clone !`].\n-   |       +++++++\n+LL - //! [`Clone !`].\n+LL + //! [`derive@Clone `].\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ca18842fb21c5e8199205c80919f7b6f9fa8aaef", "filename": "tests/rustdoc-ui/intra-doc/weird-syntax.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,140 @@\n+// Many examples are from\n+// https://github.com/rust-lang/rust/issues/110111#issuecomment-1517800781\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+//! This test case is closely linked to [raphlinus/pulldown-cmark#441], getting offsets of\n+//! link components. In particular, pulldown-cmark doesn't provide the offsets of the contents\n+//! of a link.\n+//!\n+//! To work around this, rustdoc parses parts of a link definition itself. This is basically a\n+//! test suite for that link syntax parser.\n+//!\n+//! [raphlinus/pulldown-cmark#441]: https://github.com/raphlinus/pulldown-cmark/issues/441\n+\n+use std::clone::Clone;\n+\n+// Basic version //\n+\n+/// [`struct@Clone`] //~ERROR link\n+pub struct LinkToCloneWithBackquotes;\n+\n+/// [```struct@Clone```] //~ERROR link\n+pub struct LinkToCloneWithMultipleBackquotes;\n+\n+/// [  `  struct@Clone  `  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesAndBackquotes;\n+\n+/// [  `Clone ()`  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesBackquotesAndParens;\n+\n+/// [`Clone ()`  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesEndBackquotesAndParens;\n+\n+/// [  `Clone ()`] //~ERROR link\n+pub struct LinkToCloneWithSpacesStartBackquotesAndParens;\n+\n+/// [```Clone ()```] //~ERROR link\n+pub struct LinkToCloneWithMultipleBackquotesAndParens;\n+\n+/// [```Clone \\(\\)```] // not URL-shaped enough\n+pub struct LinkToCloneWithMultipleBackquotesAndEscapedParens;\n+\n+/// [  ```  Clone ()  ```  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesMultipleBackquotesAndParens;\n+\n+/// [ x \\] ] // not URL-shaped enough\n+pub struct LinkWithEscapedCloseBrace;\n+\n+/// [ x \\[ ] // not URL-shaped enough\n+pub struct LinkWithEscapedOpenBrace;\n+\n+/// [ x \\( ] // not URL-shaped enough\n+pub struct LinkWithEscapedCloseParen;\n+\n+/// [ x \\) ] // not URL-shaped enough\n+pub struct LinkWithEscapedOpenParen;\n+\n+/// [ Clone \\(\\) ] // not URL-shaped enough\n+pub struct LinkWithEscapedParens;\n+\n+// [][] version //\n+\n+/// [x][ struct@Clone] //~ERROR link\n+pub struct XLinkToCloneWithStartSpace;\n+\n+/// [x][struct@Clone ] //~ERROR link\n+pub struct XLinkToCloneWithEndSpace;\n+\n+/// [x][Clone\\(\\)] not URL-shaped enough\n+pub struct XLinkToCloneWithEscapedParens;\n+\n+/// [x][`Clone`] not URL-shaped enough\n+pub struct XLinkToCloneWithBackquotes;\n+\n+/// [x][Clone()] //~ERROR link\n+pub struct XLinkToCloneWithUnescapedParens;\n+\n+/// [x][Clone  ()] //~ERROR link\n+pub struct XLinkToCloneWithUnescapedParensAndDoubleSpace;\n+\n+/// [x][Clone  [] //~ERROR unresolved link to `x`\n+pub struct XLinkToCloneWithUnmatchedOpenParenAndDoubleSpace;\n+\n+/// [x][Clone  \\[] // not URL-shaped enough\n+pub struct XLinkToCloneWithUnmatchedEscapedOpenParenAndDoubleSpace;\n+\n+/// [x][Clone  \\]] // not URL-shaped enough\n+pub struct XLinkToCloneWithUnmatchedEscapedCloseParenAndDoubleSpace;\n+\n+// []() version //\n+\n+/// [w]( struct@Clone) //~ERROR link\n+pub struct WLinkToCloneWithStartSpace;\n+\n+/// [w](struct@Clone ) //~ERROR link\n+pub struct WLinkToCloneWithEndSpace;\n+\n+/// [w](Clone\\(\\)) //~ERROR link\n+pub struct WLinkToCloneWithEscapedParens;\n+\n+/// [w](`Clone`) not URL-shaped enough\n+pub struct WLinkToCloneWithBackquotes;\n+\n+/// [w](Clone()) //~ERROR link\n+pub struct WLinkToCloneWithUnescapedParens;\n+\n+/// [w](Clone  ()) not URL-shaped enough\n+pub struct WLinkToCloneWithUnescapedParensAndDoubleSpace;\n+\n+/// [w](Clone  () //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedOpenParenAndDoubleSpace;\n+\n+/// [w](Clone  \\() //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedEscapedOpenParenAndDoubleSpace;\n+\n+/// [w](Clone  \\)) //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedEscapedCloseParenAndDoubleSpace;\n+\n+// References\n+\n+/// The [cln][] link here is going to be unresolved, because `Clone()` gets rejected //~ERROR link\n+/// in Markdown for not being URL-shaped enough.\n+///\n+/// [cln]: Clone() //~ERROR link\n+pub struct LinkToCloneWithParensInReference;\n+\n+/// The [cln][] link here is going to be unresolved, because `struct@Clone` gets //~ERROR link\n+/// rejected in Markdown for not being URL-shaped enough.\n+///\n+/// [cln]: struct@Clone //~ERROR link\n+pub struct LinkToCloneWithWrongPrefix;\n+\n+/// The [cln][] link here will produce a plain text suggestion //~ERROR link\n+///\n+/// [cln]: Clone\\(\\)\n+pub struct LinkToCloneWithEscapedParensInReference;\n+\n+/// The [cln][] link here will produce a plain text suggestion //~ERROR link\n+///\n+/// [cln]: struct\\@Clone\n+pub struct LinkToCloneWithEscapedAtsInReference;"}, {"sha": "f50feb57fccf2729d043a5e69ba13f3fe0958398", "filename": "tests/rustdoc-ui/intra-doc/weird-syntax.stderr", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,272 @@\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:18:7\n+   |\n+LL | /// [`struct@Clone`]\n+   |       ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+note: the lint level is defined here\n+  --> $DIR/weird-syntax.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@Clone`]\n+   |       ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:21:9\n+   |\n+LL | /// [```struct@Clone```]\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [```trait@Clone```]\n+   |         ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:24:11\n+   |\n+LL | /// [  `  struct@Clone  `  ]\n+   |           ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [  `  trait@Clone  `  ]\n+   |           ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:27:9\n+   |\n+LL | /// [  `Clone ()`  ]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  `Clone ()`  ]\n+LL + /// [  `trait@Clone `  ]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:30:7\n+   |\n+LL | /// [`Clone ()`  ]\n+   |       ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [`Clone ()`  ]\n+LL + /// [`trait@Clone `  ]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:33:9\n+   |\n+LL | /// [  `Clone ()`]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  `Clone ()`]\n+LL + /// [  `trait@Clone `]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:36:9\n+   |\n+LL | /// [```Clone ()```]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [```Clone ()```]\n+LL + /// [```trait@Clone ```]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:42:13\n+   |\n+LL | /// [  ```  Clone ()  ```  ]\n+   |             ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  ```  Clone ()  ```  ]\n+LL + /// [  ```  trait@Clone   ```  ]\n+   |\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:62:10\n+   |\n+LL | /// [x][ struct@Clone]\n+   |          ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [x][ trait@Clone]\n+   |          ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:65:9\n+   |\n+LL | /// [x][struct@Clone ]\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [x][trait@Clone ]\n+   |         ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:74:9\n+   |\n+LL | /// [x][Clone()]\n+   |         ^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [x][Clone()]\n+LL + /// [x][trait@Clone]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:77:9\n+   |\n+LL | /// [x][Clone  ()]\n+   |         ^^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [x][Clone  ()]\n+LL + /// [x][trait@Clone  ]\n+   |\n+\n+error: unresolved link to `x`\n+  --> $DIR/weird-syntax.rs:80:6\n+   |\n+LL | /// [x][Clone  []\n+   |      ^ no item named `x` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:91:10\n+   |\n+LL | /// [w]( struct@Clone)\n+   |          ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [w]( trait@Clone)\n+   |          ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:94:9\n+   |\n+LL | /// [w](struct@Clone )\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [w](trait@Clone )\n+   |         ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:97:9\n+   |\n+LL | /// [w](Clone\\(\\))\n+   |         ^^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [w](Clone\\(\\))\n+LL + /// [w](trait@Clone)\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:103:9\n+   |\n+LL | /// [w](Clone())\n+   |         ^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [w](Clone())\n+LL + /// [w](trait@Clone)\n+   |\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:109:6\n+   |\n+LL | /// [w](Clone  ()\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:112:6\n+   |\n+LL | /// [w](Clone  \\()\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:115:6\n+   |\n+LL | /// [w](Clone  \\))\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:120:10\n+   |\n+LL | /// The [cln][] link here is going to be unresolved, because `Clone()` gets rejected\n+   |          ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:123:6\n+   |\n+LL | /// [cln]: Clone()\n+   |      ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:126:10\n+   |\n+LL | /// The [cln][] link here is going to be unresolved, because `struct@Clone` gets\n+   |          ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:129:6\n+   |\n+LL | /// [cln]: struct@Clone\n+   |      ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:132:9\n+   |\n+LL | /// The [cln][] link here will produce a plain text suggestion\n+   |         ^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+   = help: to link to the trait, prefix with `trait@`: trait@Clone\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:137:9\n+   |\n+LL | /// The [cln][] link here will produce a plain text suggestion\n+   |         ^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+   = help: to link to the trait, prefix with `trait@`: trait@Clone\n+\n+error: aborting due to 26 previous errors\n+"}, {"sha": "d9ed954868e50a9b4b1d895f6598a15ec68aa368", "filename": "tests/rustdoc/reexport-doc-hidden.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc%2Freexport-doc-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc%2Freexport-doc-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-doc-hidden.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -21,6 +21,5 @@ macro_rules! foo {\n     () => {};\n }\n \n-// This is a bug: https://github.com/rust-lang/rust/issues/59368\n-// @!has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n+// @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n pub use crate::foo as Macro;"}, {"sha": "47a21e39462251473ebb9fd6e72eb7166df16ece", "filename": "tests/rustdoc/reexport-hidden-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc%2Freexport-hidden-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc%2Freexport-hidden-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-hidden-macro.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -5,6 +5,7 @@\n \n // @has 'foo/index.html'\n // @has - '//*[@id=\"main-content\"]//a[@href=\"macro.Macro2.html\"]' 'Macro2'\n+// @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n \n // @has 'foo/macro.Macro2.html'\n // @has - '//*[@class=\"docblock\"]' 'Displayed'\n@@ -15,7 +16,6 @@ macro_rules! foo {\n     () => {};\n }\n \n-/// not displayed\n pub use crate::foo as Macro;\n /// Displayed\n #[doc(inline)]"}, {"sha": "b733716c22a3b65f62c8a7f21436b184ffbf11ea", "filename": "tests/rustdoc/reexport-of-doc-hidden.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc%2Freexport-of-doc-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Frustdoc%2Freexport-of-doc-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-of-doc-hidden.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,42 @@\n+// This test ensures that all re-exports of doc hidden elements are displayed.\n+\n+#![crate_name = \"foo\"]\n+\n+#[doc(hidden)]\n+pub struct Bar;\n+\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! foo {\n+    () => {};\n+}\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n+pub use crate::foo as Macro;\n+// @has - '//*[@id=\"reexport.Macro2\"]/code' 'pub use crate::foo as Macro2;'\n+pub use crate::foo as Macro2;\n+// @has - '//*[@id=\"reexport.Boo\"]/code' 'pub use crate::Bar as Boo;'\n+pub use crate::Bar as Boo;\n+// @has - '//*[@id=\"reexport.Boo2\"]/code' 'pub use crate::Bar as Boo2;'\n+pub use crate::Bar as Boo2;\n+\n+pub fn fofo() {}\n+\n+// @has - '//*[@id=\"reexport.f1\"]/code' 'pub use crate::fofo as f1;'\n+pub use crate::fofo as f1;\n+// @has - '//*[@id=\"reexport.f2\"]/code' 'pub use crate::fofo as f2;'\n+pub use crate::fofo as f2;\n+\n+pub mod sub {\n+    // @has 'foo/sub/index.html'\n+    // @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n+    pub use crate::foo as Macro;\n+    // @has - '//*[@id=\"reexport.Macro2\"]/code' 'pub use crate::foo as Macro2;'\n+    pub use crate::foo as Macro2;\n+\n+    // @has - '//*[@id=\"reexport.f1\"]/code' 'pub use crate::fofo as f1;'\n+    pub use crate::fofo as f1;\n+    // @has - '//*[@id=\"reexport.f2\"]/code' 'pub use crate::fofo as f2;'\n+    pub use crate::fofo as f2;\n+}"}, {"sha": "66b378f62d63c738f76af9f661c5c4a8867c92e5", "filename": "tests/ui/backtrace.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbacktrace.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -104,13 +104,17 @@ fn runtest(me: &str) {\n                 \"bad output3: {}\", s);\n \n         // Make sure a stack trace isn't printed too many times\n+        //\n+        // Currently it is printed 3 times (\"once\", \"twice\" and \"panic in a\n+        // function that cannot unwind\") but in the future the last one may be\n+        // removed.\n         let p = template(me).arg(\"double-fail\")\n                                     .env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n         let out = p.wait_with_output().unwrap();\n         assert!(!out.status.success());\n         let s = str::from_utf8(&out.stderr).unwrap();\n         let mut i = 0;\n-        for _ in 0..2 {\n+        for _ in 0..3 {\n             i += s[i + 10..].find(\"stack backtrace\").unwrap() + 10;\n         }\n         assert!(s[i + 10..].find(\"stack backtrace\").is_none(),"}, {"sha": "2f397f6b5853232ce557d009b143cbcf70103eff", "filename": "tests/ui/borrowck/borrowck-thread-local-static-borrow-outlives-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4,7 +4,7 @@ error[E0712]: thread-local variable borrowed past end of function\n LL |      assert_static(&FOO);\n    |                    ^^^^ thread-local variables cannot be borrowed beyond the end of the function\n LL | }\n-   | - end of enclosing function is here\n+   |  - end of enclosing function is here\n \n error: aborting due to previous error\n "}, {"sha": "1bda7a4971375491003540a23cfc68c4a02887f5", "filename": "tests/ui/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -8,7 +8,6 @@ fn a() {\n         //~^ NOTE `vec[_]` is borrowed here\n             vec[0] = Box::new(4); //~ ERROR cannot assign\n             //~^ NOTE `vec[_]` is assigned to here\n-            //~| NOTE in this expansion of desugaring of drop and replace\n             _a.use_ref();\n             //~^ NOTE borrow later used here\n         }\n@@ -23,7 +22,6 @@ fn b() {\n         //~^ `vec[_]` is borrowed here\n             vec[0] = Box::new(4); //~ ERROR cannot assign\n             //~^ NOTE `vec[_]` is assigned to here\n-            //~| NOTE in this expansion of desugaring of drop and replace\n             _b.use_ref();\n             //~^ NOTE borrow later used here\n         }"}, {"sha": "70b9e4f4433b34e8ae6926e2fd507c658bf92c15", "filename": "tests/ui/borrowck/borrowck-vec-pattern-nesting.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -6,24 +6,24 @@ LL |         [box ref _a, _, _] => {\n LL |\n LL |             vec[0] = Box::new(4);\n    |             ^^^^^^ `vec[_]` is assigned to here but it was already borrowed\n-...\n+LL |\n LL |             _a.use_ref();\n    |             ------------ borrow later used here\n \n error[E0506]: cannot assign to `vec[_]` because it is borrowed\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:24:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:23:13\n    |\n LL |         &mut [ref _b @ ..] => {\n    |               ------ `vec[_]` is borrowed here\n LL |\n LL |             vec[0] = Box::new(4);\n    |             ^^^^^^ `vec[_]` is assigned to here but it was already borrowed\n-...\n+LL |\n LL |             _b.use_ref();\n    |             ------------ borrow later used here\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:36:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:34:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -41,7 +41,7 @@ LL +         [_a,\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:48:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:46:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^\n@@ -55,7 +55,7 @@ LL |     let a = &vec[0];\n    |             +\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:57:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:55:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -73,7 +73,7 @@ LL +         [\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:67:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:65:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^\n@@ -87,7 +87,7 @@ LL |     let a = &vec[0];\n    |             +\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:76:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:74:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -106,7 +106,7 @@ LL +         [_a, _b, _c] => {}\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:87:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:85:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^"}, {"sha": "ded46e56e34514c8d9010dff9e0c203370091ab1", "filename": "tests/ui/borrowck/issue-45199.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fissue-45199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fissue-45199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-45199.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -5,7 +5,6 @@ fn test_drop_replace() {\n     b = Box::new(1);    //~ NOTE first assignment\n     b = Box::new(2);    //~ ERROR cannot assign twice to immutable variable `b`\n                         //~| NOTE cannot assign twice to immutable\n-                        //~| NOTE in this expansion of desugaring of drop and replace\n }\n \n fn test_call() {\n@@ -14,14 +13,12 @@ fn test_call() {\n                             //~| SUGGESTION mut b\n     b = Box::new(2);        //~ ERROR cannot assign twice to immutable variable `b`\n                             //~| NOTE cannot assign twice to immutable\n-                            //~| NOTE in this expansion of desugaring of drop and replace\n }\n \n fn test_args(b: Box<i32>) {  //~ HELP consider making this binding mutable\n                                 //~| SUGGESTION mut b\n     b = Box::new(2);            //~ ERROR cannot assign to immutable argument `b`\n                                 //~| NOTE cannot assign to immutable argument\n-                                //~| NOTE in this expansion of desugaring of drop and replace\n }\n \n fn main() {}"}, {"sha": "47aa30908270d91b7ac9107dcf7318ea259b5e6a", "filename": "tests/ui/borrowck/issue-45199.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fissue-45199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fborrowck%2Fissue-45199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-45199.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -10,7 +10,7 @@ LL |     b = Box::new(2);\n    |     ^ cannot assign twice to immutable variable\n \n error[E0384]: cannot assign twice to immutable variable `b`\n-  --> $DIR/issue-45199.rs:15:5\n+  --> $DIR/issue-45199.rs:14:5\n    |\n LL |     let b = Box::new(1);\n    |         -\n@@ -22,7 +22,7 @@ LL |     b = Box::new(2);\n    |     ^ cannot assign twice to immutable variable\n \n error[E0384]: cannot assign to immutable argument `b`\n-  --> $DIR/issue-45199.rs:22:5\n+  --> $DIR/issue-45199.rs:20:5\n    |\n LL | fn test_args(b: Box<i32>) {\n    |              - help: consider making this binding mutable: `mut b`"}, {"sha": "b22cab7c7ffad044ada7b7de105c49e78157cc06", "filename": "tests/ui/const-generics/generic_const_exprs/typeid-equality-by-subtyping.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,7 +1,7 @@\n-// check-pass\n+// known-bug: #110395\n // known-bug: #97156\n \n-#![feature(const_type_id, generic_const_exprs)]\n+#![feature(const_type_id, const_trait_impl, generic_const_exprs)]\n #![allow(incomplete_features)]\n \n use std::any::TypeId;\n@@ -26,7 +26,10 @@ impl<T: 'static> AssocCt for T {\n trait WithAssoc<U> {\n     type Assoc;\n }\n-impl<T: 'static> WithAssoc<()> for T where [(); <T as AssocCt>::ASSOC]: {\n+impl<T: 'static> WithAssoc<()> for T\n+where\n+    [(); <T as AssocCt>::ASSOC]:,\n+{\n     type Assoc = [u8; <T as AssocCt>::ASSOC];\n }\n \n@@ -38,7 +41,6 @@ where\n     x\n }\n \n-\n fn unsound<T>(x: <One as WithAssoc<T>>::Assoc) -> <Two as WithAssoc<T>>::Assoc\n where\n     One: WithAssoc<T>,"}, {"sha": "8cbd12654480ab09b5fd4e7c9702562a692a853c", "filename": "tests/ui/const-generics/generic_const_exprs/typeid-equality-by-subtyping.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,11 @@\n+error: to use a constant of type `TypeId` in a pattern, `TypeId` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/typeid-equality-by-subtyping.rs:18:9\n+   |\n+LL |         WHAT_A_TYPE => 0,\n+   |         ^^^^^^^^^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: aborting due to previous error\n+"}, {"sha": "3d1197afd0f79a5d0b06d0e91b557f1aed109362", "filename": "tests/ui/const-generics/transmute-fail.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4,8 +4,8 @@ error[E0512]: cannot transmute between types of different sizes, or dependently-\n LL |     std::mem::transmute(v)\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: source type: `[[u32; H+1]; W]` (generic size [const expr])\n-   = note: target type: `[[u32; W+1]; H]` (generic size [const expr])\n+   = note: source type: `[[u32; H+1]; W]` (generic size {const expr})\n+   = note: target type: `[[u32; W+1]; H]` (generic size {const expr})\n \n error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --> $DIR/transmute-fail.rs:16:5\n@@ -34,8 +34,8 @@ error[E0512]: cannot transmute between types of different sizes, or dependently-\n LL |     std::mem::transmute(v)\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: source type: `[[u32; H]; W]` (generic size [const expr])\n-   = note: target type: `[u32; W * H * H]` (generic size [const expr])\n+   = note: source type: `[[u32; H]; W]` (generic size {const expr})\n+   = note: target type: `[u32; W * H * H]` (generic size {const expr})\n \n error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --> $DIR/transmute-fail.rs:30:5"}, {"sha": "dc2c702d885ace995ab6149b8caf22d39d1dd0fa", "filename": "tests/ui/consts/const_cmp_type_id.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -20,7 +20,6 @@ LL |     assert!(TypeId::of::<u8>() == TypeId::of::<u8>());\n note: impl defined here, but it is not `const`\n   --> $SRC_DIR/core/src/any.rs:LL:COL\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `TypeId` with `TypeId` in const contexts\n   --> $DIR/const_cmp_type_id.rs:9:13\n@@ -44,7 +43,6 @@ LL |     assert!(TypeId::of::<()>() != TypeId::of::<u8>());\n note: impl defined here, but it is not `const`\n   --> $SRC_DIR/core/src/any.rs:LL:COL\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `TypeId` with `TypeId` in const contexts\n   --> $DIR/const_cmp_type_id.rs:10:22"}, {"sha": "09661d3f3440d60709f86b71fcfe5f16c5591e1d", "filename": "tests/ui/consts/issue-73976-monomorphic.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -20,7 +20,6 @@ LL |     GetTypeId::<T>::VALUE == GetTypeId::<usize>::VALUE\n note: impl defined here, but it is not `const`\n   --> $SRC_DIR/core/src/any.rs:LL:COL\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0bae65a9ae53d8819e924e29942fdbe58b560820", "filename": "tests/ui/editions/edition-raw-pointer-method-2018.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Feditions%2Fedition-raw-pointer-method-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Feditions%2Fedition-raw-pointer-method-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feditions%2Fedition-raw-pointer-method-2018.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     let x = 0;\n     let y = &x as *const _;\n     let _ = y.is_null();\n-    //~^ error: the type of this value must be known to call a method on a raw pointer on it [E0699]\n+    //~^ error: cannot call a method on a raw pointer with an unknown pointee type [E0699]\n }"}, {"sha": "b9afa0133cac3e2b67cc1be59745a81718a28ad5", "filename": "tests/ui/editions/edition-raw-pointer-method-2018.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Feditions%2Fedition-raw-pointer-method-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Feditions%2Fedition-raw-pointer-method-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feditions%2Fedition-raw-pointer-method-2018.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,4 +1,4 @@\n-error[E0699]: the type of this value must be known to call a method on a raw pointer on it\n+error[E0699]: cannot call a method on a raw pointer with an unknown pointee type\n   --> $DIR/edition-raw-pointer-method-2018.rs:9:15\n    |\n LL |     let _ = y.is_null();"}, {"sha": "6f8d0cf8ae2a27121e1ab37f6a4b14188e8b9677", "filename": "tests/ui/imports/issue-55884-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fimports%2Fissue-55884-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fimports%2Fissue-55884-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-55884-2.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -6,6 +6,7 @@ mod parser {\n     pub use options::*;\n     // Private single import shadows public glob import, but arrives too late for initial\n     // resolution of `use parser::ParseOptions` because it depends on that resolution itself.\n+    #[allow(hidden_glob_reexports)]\n     use ParseOptions;\n }\n "}, {"sha": "67d4114149a4b512ccc6527768c0878d380c98fa", "filename": "tests/ui/imports/issue-55884-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fimports%2Fissue-55884-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fimports%2Fissue-55884-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-55884-2.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,16 +1,16 @@\n error[E0603]: struct import `ParseOptions` is private\n-  --> $DIR/issue-55884-2.rs:12:17\n+  --> $DIR/issue-55884-2.rs:13:17\n    |\n LL | pub use parser::ParseOptions;\n    |                 ^^^^^^^^^^^^ private struct import\n    |\n note: the struct import `ParseOptions` is defined here...\n-  --> $DIR/issue-55884-2.rs:9:9\n+  --> $DIR/issue-55884-2.rs:10:9\n    |\n LL |     use ParseOptions;\n    |         ^^^^^^^^^^^^\n note: ...and refers to the struct import `ParseOptions` which is defined here...\n-  --> $DIR/issue-55884-2.rs:12:9\n+  --> $DIR/issue-55884-2.rs:13:9\n    |\n LL | pub use parser::ParseOptions;\n    |         ^^^^^^^^^^^^^^^^^^^^ consider importing it directly"}, {"sha": "3e3706bcb7de9fc36aba1b45f11438c12716c5d0", "filename": "tests/ui/issues/issue-17954.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fissues%2Fissue-17954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fissues%2Fissue-17954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-17954.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -5,7 +5,7 @@ LL |     let a = &FOO;\n    |             ^^^^ thread-local variables cannot be borrowed beyond the end of the function\n ...\n LL | }\n-   | - end of enclosing function is here\n+   |  - end of enclosing function is here\n \n error: aborting due to previous error\n "}, {"sha": "0812976cf40924d2ef327571f3717d7c1568af58", "filename": "tests/ui/issues/issue-52049.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fissues%2Fissue-52049.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fissues%2Fissue-52049.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-52049.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2,12 +2,10 @@ error[E0716]: temporary value dropped while borrowed\n   --> $DIR/issue-52049.rs:6:10\n    |\n LL |     foo(&unpromotable(5u32));\n-   |     -----^^^^^^^^^^^^^^^^^^-\n+   |     -----^^^^^^^^^^^^^^^^^^-- temporary value is freed at the end of this statement\n    |     |    |\n    |     |    creates a temporary value which is freed while still in use\n    |     argument requires that borrow lasts for `'static`\n-LL | }\n-   | - temporary value is freed at the end of this statement\n \n error: aborting due to previous error\n "}, {"sha": "598f14241913768d2ff6c6fe370eefbcef595629", "filename": "tests/ui/lifetimes/issue-90600-expected-return-static-indirect.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Flifetimes%2Fissue-90600-expected-return-static-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Flifetimes%2Fissue-90600-expected-return-static-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-90600-expected-return-static-indirect.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -10,7 +10,7 @@ LL |     let read = &refcell as &RefCell<dyn Read>;\n    |                -------- cast requires that `foo` is borrowed for `'static`\n ...\n LL | }\n-   | - `foo` dropped here while still borrowed\n+   |  - `foo` dropped here while still borrowed\n \n error: lifetime may not live long enough\n   --> $DIR/issue-90600-expected-return-static-indirect.rs:9:16"}, {"sha": "0cade7fef02fd5af8387ac7d6918a06e61f836a3", "filename": "tests/ui/lint/rfc-2383-lint-reason/root-attribute-confusion.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Flint%2Frfc-2383-lint-reason%2Froot-attribute-confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Flint%2Frfc-2383-lint-reason%2Froot-attribute-confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Frfc-2383-lint-reason%2Froot-attribute-confusion.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+// compile-flags: -Dunused_attributes\n+\n+#![deny(unused_crate_dependencies)]\n+#![feature(lint_reasons)]\n+\n+fn main() {}"}, {"sha": "c9b16e43910e8e9f6215acc0ed4ed4b3ecca2c64", "filename": "tests/ui/liveness/liveness-assign/liveness-assign-imm-local-with-drop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fliveness%2Fliveness-assign%2Fliveness-assign-imm-local-with-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fliveness%2Fliveness-assign%2Fliveness-assign-imm-local-with-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliveness%2Fliveness-assign%2Fliveness-assign-imm-local-with-drop.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -5,7 +5,6 @@ fn test() {\n     drop(b);\n     b = Box::new(2); //~ ERROR cannot assign twice to immutable variable `b`\n                      //~| NOTE cannot assign twice to immutable\n-                     //~| NOTE in this expansion of desugaring of drop and replace\n     drop(b);\n }\n "}, {"sha": "b1db05afd080ba8a738f07e9df1e5c0aa3957393", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs", "status": "modified", "additions": 11, "deletions": 74, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -5,7 +5,7 @@\n // needs-unwind Asserting on contents of error message\n \n #![allow(path_statements, unused_allocation)]\n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n \n macro_rules! test {\n   (\n@@ -51,6 +51,7 @@ macro_rules! tests {\n \n const FOO: Foo = Foo { bar: 1 };\n \n+\n #[derive(Clone, Copy, Debug, PartialEq)]\n struct Foo {\n   bar: i32\n@@ -83,9 +84,18 @@ fn main() {\n     // cast\n     [ elem as i32 == 3 ] => \"Assertion failed: elem as i32 == 3\\nWith captures:\\n  elem = 1\\n\"\n \n+    // if\n+    [ if elem == 3 { true } else { false } ] => \"Assertion failed: if elem == 3 { true } else { false }\\nWith captures:\\n  elem = 1\\n\"\n+\n     // index\n     [ [1i32, 1][elem as usize] == 3 ] => \"Assertion failed: [1i32, 1][elem as usize] == 3\\nWith captures:\\n  elem = 1\\n\"\n \n+    // let\n+    [ if let 3 = elem { true } else { false } ] => \"Assertion failed: if let 3 = elem { true } else { false }\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // match\n+    [ match elem { 3 => true, _ => false, } ] => \"Assertion failed: match elem { 3 => true, _ => false, }\\nWith captures:\\n  elem = 1\\n\"\n+\n     // method call\n     [ FOO.add(elem, elem) == 3 ] => \"Assertion failed: FOO.add(elem, elem) == 3\\nWith captures:\\n  elem = 1\\n\"\n \n@@ -107,77 +117,4 @@ fn main() {\n     // unary\n     [ -elem == -3 ] => \"Assertion failed: -elem == -3\\nWith captures:\\n  elem = 1\\n\"\n   );\n-\n-  // ***** Disallowed *****\n-\n-  tests!(\n-    let mut elem = 1i32;\n-\n-    // assign\n-    [ { let local = elem; local } == 3 ] => \"Assertion failed: { let local = elem; local } == 3\"\n-\n-    // assign op\n-    [ { elem += 1; elem } == 3 ] => \"Assertion failed: { elem += 1; elem } == 3\"\n-\n-    // async\n-    [ { let _ = async { elem }; elem } == 3 ] => \"Assertion failed: { let _ = async { elem }; elem } == 3\"\n-\n-    // await\n-\n-    // block\n-    [ { elem } == 3 ] => \"Assertion failed: { elem } == 3\"\n-\n-    // break\n-    [ loop { break elem; } ==  3 ] => \"Assertion failed: loop { break elem; } == 3\"\n-\n-    // closure\n-    [(|| elem)() ==  3 ] => \"Assertion failed: (|| elem)() == 3\"\n-\n-    // const block\n-\n-    // continue\n-\n-    // err\n-\n-    // field\n-    [ FOO.bar ==  3 ] => \"Assertion failed: FOO.bar == 3\"\n-\n-    // for loop\n-    [ { for _ in 0..elem { elem; } elem } ==  3 ] => \"Assertion failed: { for _ in 0..elem { elem; } elem } == 3\"\n-\n-    // if\n-    [ if true { elem } else { elem } == 3 ] => \"Assertion failed: if true { elem } else { elem } == 3\"\n-\n-    // inline asm\n-\n-    // let\n-    [ if let true = true { elem } else { elem } == 3 ] => \"Assertion failed: if let true = true { elem } else { elem } == 3\"\n-\n-    // lit\n-\n-    // loop\n-    [ loop { elem; break elem; } == 3 ] => \"Assertion failed: loop { elem; break elem; } == 3\"\n-\n-    // mac call\n-\n-    // match\n-    [ match elem { _ => elem } == 3 ] => \"Assertion failed: (match elem { _ => elem, }) == 3\"\n-\n-    // ret\n-    [ (|| { return elem; })() == 3 ] => \"Assertion failed: (|| { return elem; })() == 3\"\n-\n-    // try\n-    [ (|| { Some(Some(elem)?) })() == Some(3) ] => \"Assertion failed: (|| { Some(Some(elem)?) })() == Some(3)\"\n-\n-    // try block\n-\n-    // underscore\n-\n-    // while\n-    [ { while false { elem; break; } elem } == 3 ] => \"Assertion failed: { while false { elem; break; } elem } == 3\"\n-\n-    // yeet\n-\n-    // yield\n-  );\n }"}, {"sha": "fcf4f367d042865bf43aabbd883aa1b5089a12dd", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-not-available-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-not-available-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-not-available-cases.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -4,7 +4,7 @@\n // run-pass\n // needs-unwind Asserting on contents of error message\n \n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n \n extern crate common;\n "}, {"sha": "c8408d16fbb0d5bab35d1f007c1073f00e17000d", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/assert-with-custom-errors-does-not-create-unnecessary-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-with-custom-errors-does-not-create-unnecessary-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-with-custom-errors-does-not-create-unnecessary-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-with-custom-errors-does-not-create-unnecessary-code.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: --test\n // run-pass\n \n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n \n #[should_panic(expected = \"Custom user message\")]\n #[test]"}, {"sha": "0e3c14a5770eaa021c44cb2ed5aef7eab43d3a80", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-without-captures-does-not-create-unnecessary-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-without-captures-does-not-create-unnecessary-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-without-captures-does-not-create-unnecessary-code.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,7 +3,7 @@\n // run-pass\n // needs-unwind Asserting on contents of error message\n \n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n \n extern crate common;\n "}, {"sha": "0d2518dc25317a694590aa23b19ec4d4e7cedb84", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/feature-gate-generic_assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Ffeature-gate-generic_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Ffeature-gate-generic_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Ffeature-gate-generic_assert.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2,7 +2,7 @@\n // ignore-tidy-linelength\n // run-pass\n \n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n \n use std::fmt::{Debug, Formatter};\n "}, {"sha": "57b79a56b7bfbf3023cf881dc7ad0665466807d2", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,7 +1,7 @@\n // check-pass\n // compile-flags: -Z unpretty=expanded\n \n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n \n fn arbitrary_consuming_method_for_demonstration_purposes() {\n     let elem = 1i32;"}, {"sha": "66321bc35f01c59464e15fab6b9859989f98a762", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -3,7 +3,7 @@\n // check-pass\n // compile-flags: -Z unpretty=expanded\n \n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#![feature(core_intrinsics, generic_assert)]\n #[prelude_import]\n use ::std::prelude::rust_2015::*;\n #[macro_use]"}, {"sha": "fe4275f5367a9224cf0125b1ab884fffea214ad5", "filename": "tests/ui/methods/call_method_unknown_pointee.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmethods%2Fcall_method_unknown_pointee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmethods%2Fcall_method_unknown_pointee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fcall_method_unknown_pointee.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,28 @@\n+// edition: 2018\n+\n+// tests that the pointee type of a raw pointer must be known to call methods on it\n+// see also: `tests/ui/editions/edition-raw-pointer-method-2018.rs`\n+\n+fn main() {\n+    let val = 1_u32;\n+    let ptr = &val as *const u32;\n+    unsafe {\n+        let _a: i32 = (ptr as *const _).read();\n+        //~^ ERROR cannot call a method on a raw pointer with an unknown pointee type [E0699]\n+        let b = ptr as *const _;\n+        let _b: u8 = b.read();\n+        //~^ ERROR cannot call a method on a raw pointer with an unknown pointee type [E0699]\n+        let _c = (ptr as *const u8).read(); // we know the type here\n+    }\n+\n+    let mut val = 2_u32;\n+    let ptr = &mut val as *mut u32;\n+    unsafe {\n+        let _a: i32 = (ptr as *mut _).read();\n+        //~^ ERROR cannot call a method on a raw pointer with an unknown pointee type [E0699]\n+        let b = ptr as *mut _;\n+        b.write(10);\n+        //~^ ERROR cannot call a method on a raw pointer with an unknown pointee type [E0699]\n+        (ptr as *mut i32).write(1000); // we know the type here\n+    }\n+}"}, {"sha": "84ecf046e7ac21ec828612e24d1ede5357465b51", "filename": "tests/ui/methods/call_method_unknown_pointee.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmethods%2Fcall_method_unknown_pointee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmethods%2Fcall_method_unknown_pointee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fcall_method_unknown_pointee.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,27 @@\n+error[E0699]: cannot call a method on a raw pointer with an unknown pointee type\n+  --> $DIR/call_method_unknown_pointee.rs:10:41\n+   |\n+LL |         let _a: i32 = (ptr as *const _).read();\n+   |                                         ^^^^\n+\n+error[E0699]: cannot call a method on a raw pointer with an unknown pointee type\n+  --> $DIR/call_method_unknown_pointee.rs:13:24\n+   |\n+LL |         let _b: u8 = b.read();\n+   |                        ^^^^\n+\n+error[E0699]: cannot call a method on a raw pointer with an unknown pointee type\n+  --> $DIR/call_method_unknown_pointee.rs:21:39\n+   |\n+LL |         let _a: i32 = (ptr as *mut _).read();\n+   |                                       ^^^^\n+\n+error[E0699]: cannot call a method on a raw pointer with an unknown pointee type\n+  --> $DIR/call_method_unknown_pointee.rs:24:11\n+   |\n+LL |         b.write(10);\n+   |           ^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0699`."}, {"sha": "892638bfb92bdba8507a4137faf4ceddd3707ac5", "filename": "tests/ui/mir/addrof_alignment.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmir%2Faddrof_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmir%2Faddrof_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Faddrof_alignment.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+// ignore-wasm32-bare: No panic messages\n+// compile-flags: -C debug-assertions\n+\n+struct Misalignment {\n+    a: u32,\n+}\n+\n+fn main() {\n+    let items: [Misalignment; 2] = [Misalignment { a: 0 }, Misalignment { a: 1 }];\n+    unsafe {\n+        let ptr: *const Misalignment = items.as_ptr().cast::<u8>().add(1).cast::<Misalignment>();\n+        let _ptr = core::ptr::addr_of!((*ptr).a);\n+    }\n+}"}, {"sha": "d0bd5b46cf59f9f6851e2c048caf39528fc1e489", "filename": "tests/ui/mismatched_types/E0053.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmismatched_types%2FE0053.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmismatched_types%2FE0053.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2FE0053.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -22,7 +22,7 @@ LL |     fn bar(&mut self) { }\n    |            ^^^^^^^^^\n    |            |\n    |            types differ in mutability\n-   |            help: change the self-receiver type to match the trait: `self: &Bar`\n+   |            help: change the self-receiver type to match the trait: `&self`\n    |\n note: type in trait\n   --> $DIR/E0053.rs:3:12"}, {"sha": "e63471e974771d5b5e05f57e9d961ac5d46ec45e", "filename": "tests/ui/mismatched_types/issue-112036.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmismatched_types%2Fissue-112036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmismatched_types%2Fissue-112036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fissue-112036.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,7 @@\n+struct Foo;\n+\n+impl Drop for Foo {\n+    fn drop(self) {} //~ ERROR method `drop` has an incompatible type for trait\n+}\n+\n+fn main() {}"}, {"sha": "a883aba35bfba170f0080e868a57d415cb18b0d6", "filename": "tests/ui/mismatched_types/issue-112036.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmismatched_types%2Fissue-112036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fmismatched_types%2Fissue-112036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fissue-112036.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,15 @@\n+error[E0053]: method `drop` has an incompatible type for trait\n+  --> $DIR/issue-112036.rs:4:13\n+   |\n+LL |     fn drop(self) {}\n+   |             ^^^^\n+   |             |\n+   |             expected `&mut Foo`, found `Foo`\n+   |             help: change the self-receiver type to match the trait: `&mut self`\n+   |\n+   = note: expected signature `fn(&mut Foo)`\n+              found signature `fn(Foo)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "d43886e809579aac4154f75aaf5e593e08b2b714", "filename": "tests/ui/panics/nested_panic_caught.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+// needs-unwind\n+\n+// Checks that nested panics work correctly.\n+\n+use std::panic::catch_unwind;\n+\n+fn double() {\n+    struct Double;\n+\n+    impl Drop for Double {\n+        fn drop(&mut self) {\n+            let _ = catch_unwind(|| panic!(\"twice\"));\n+        }\n+    }\n+\n+    let _d = Double;\n+\n+    panic!(\"once\");\n+}\n+\n+fn main() {\n+    assert!(catch_unwind(|| double()).is_err());\n+}"}, {"sha": "2502beab443738adfad219b2dac7ffb0057b26a1", "filename": "tests/ui/parser/issues/issue-111148.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,2 @@\n+fn a<<i<Y<w<>#\n+//~^ ERROR expected one of `#`, `>`, `const`, identifier, or lifetime, found `<`"}, {"sha": "e6595a5cbcc45cfa879fc6accdcdf9b78b7a7d64", "filename": "tests/ui/parser/issues/issue-111148.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `<`\n+  --> $DIR/issue-111148.rs:1:6\n+   |\n+LL | fn a<<i<Y<w<>#\n+   |      ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "f413b50277861bae8afdf297d84d56cdea139038", "filename": "tests/ui/privacy/issue-111220-2-tuple-struct-fields-projection.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-2-tuple-struct-fields-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-2-tuple-struct-fields-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprivacy%2Fissue-111220-2-tuple-struct-fields-projection.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,33 @@\n+mod b {\n+    pub struct A(u32);\n+}\n+\n+trait Id {\n+    type Assoc;\n+}\n+impl Id for b::A {\n+    type Assoc = b::A;\n+}\n+impl Id for u32 {\n+    type Assoc = u32;\n+}\n+\n+\n+trait Trait<T> {\n+    fn method(&self)\n+    where\n+        T: Id<Assoc = b::A>;\n+}\n+\n+impl<T: Id> Trait<T> for <T as Id>::Assoc {\n+    fn method(&self)\n+    where\n+        T: Id<Assoc = b::A>,\n+    {\n+        let Self(a) = self;\n+        //~^ ERROR: tuple struct constructor `A` is private\n+        println!(\"{a}\");\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "231a4da8b5f7f480beaf12286b9a7bccb0a2074a", "filename": "tests/ui/privacy/issue-111220-2-tuple-struct-fields-projection.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-2-tuple-struct-fields-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-2-tuple-struct-fields-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprivacy%2Fissue-111220-2-tuple-struct-fields-projection.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,9 @@\n+error[E0603]: tuple struct constructor `A` is private\n+  --> $DIR/issue-111220-2-tuple-struct-fields-projection.rs:27:13\n+   |\n+LL |         let Self(a) = self;\n+   |             ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "78d35fd96da3d5c93fabe8b35690ee865317e48a", "filename": "tests/ui/privacy/issue-111220-tuple-struct-fields.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-tuple-struct-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-tuple-struct-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprivacy%2Fissue-111220-tuple-struct-fields.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,46 @@\n+mod b {\n+    #[derive(Default)]\n+    pub struct A(u32);\n+}\n+\n+impl b::A {\n+    fn inherent_bypass(&self) {\n+        let Self(x) = self;\n+        //~^ ERROR: tuple struct constructor `A` is private\n+        println!(\"{x}\");\n+    }\n+}\n+\n+pub trait B {\n+    fn f(&self);\n+}\n+\n+impl B for b::A {\n+    fn f(&self) {\n+        let Self(a) = self;\n+        //~^ ERROR: tuple struct constructor `A` is private\n+        println!(\"{}\", a);\n+    }\n+}\n+\n+pub trait Projector {\n+    type P;\n+}\n+\n+impl Projector for () {\n+    type P = b::A;\n+}\n+\n+pub trait Bypass2 {\n+    fn f2(&self);\n+}\n+\n+impl Bypass2 for <() as Projector>::P {\n+    fn f2(&self) {\n+        let Self(a) = self;\n+        //~^ ERROR: tuple struct constructor `A` is private\n+        println!(\"{}\", a);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "17a32379cc0a82a2b778c7dce20892eb55069362", "filename": "tests/ui/privacy/issue-111220-tuple-struct-fields.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-tuple-struct-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fprivacy%2Fissue-111220-tuple-struct-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprivacy%2Fissue-111220-tuple-struct-fields.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,21 @@\n+error[E0603]: tuple struct constructor `A` is private\n+  --> $DIR/issue-111220-tuple-struct-fields.rs:8:13\n+   |\n+LL |         let Self(x) = self;\n+   |             ^^^^^^^\n+\n+error[E0603]: tuple struct constructor `A` is private\n+  --> $DIR/issue-111220-tuple-struct-fields.rs:20:13\n+   |\n+LL |         let Self(a) = self;\n+   |             ^^^^^^^\n+\n+error[E0603]: tuple struct constructor `A` is private\n+  --> $DIR/issue-111220-tuple-struct-fields.rs:40:13\n+   |\n+LL |         let Self(a) = self;\n+   |             ^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "361243fcd7bdfc3caf31855f9d269a25cc878793", "filename": "tests/ui/resolve/hidden_glob_reexports.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fresolve%2Fhidden_glob_reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fresolve%2Fhidden_glob_reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fhidden_glob_reexports.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,52 @@\n+// check-pass\n+\n+pub mod upstream_a {\n+    mod inner {\n+        pub struct Foo {}\n+        pub struct Bar {}\n+    }\n+\n+    pub use self::inner::*;\n+\n+    struct Foo;\n+    //~^ WARN private item shadows public glob re-export\n+}\n+\n+pub mod upstream_b {\n+    mod inner {\n+        pub struct Foo {}\n+        pub struct Qux {}\n+    }\n+\n+    mod other {\n+        pub struct Foo;\n+    }\n+\n+    pub use self::inner::*;\n+\n+    use self::other::Foo;\n+    //~^ WARN private item shadows public glob re-export\n+}\n+\n+pub mod upstream_c {\n+    mod no_def_id {\n+        #![allow(non_camel_case_types)]\n+        pub struct u8;\n+        pub struct World;\n+    }\n+\n+    pub use self::no_def_id::*;\n+\n+    use std::primitive::u8;\n+    //~^ WARN private item shadows public glob re-export\n+}\n+\n+// Downstream crate\n+// mod downstream {\n+//     fn proof() {\n+//         let _ = crate::upstream_a::Foo;\n+//         let _ = crate::upstream_b::Foo;\n+//     }\n+// }\n+\n+pub fn main() {}"}, {"sha": "ddf7bcda827a8e2c3b78925a4462f0fdce6572cd", "filename": "tests/ui/resolve/hidden_glob_reexports.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fresolve%2Fhidden_glob_reexports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Fresolve%2Fhidden_glob_reexports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fhidden_glob_reexports.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -0,0 +1,31 @@\n+warning: private item shadows public glob re-export\n+  --> $DIR/hidden_glob_reexports.rs:11:5\n+   |\n+LL |     pub use self::inner::*;\n+   |             -------------- the name `Foo` in the type namespace is supposed to be publicly re-exported here\n+LL |\n+LL |     struct Foo;\n+   |     ^^^^^^^^^^^ but the private item here shadows it\n+   |\n+   = note: `#[warn(hidden_glob_reexports)]` on by default\n+\n+warning: private item shadows public glob re-export\n+  --> $DIR/hidden_glob_reexports.rs:27:9\n+   |\n+LL |     pub use self::inner::*;\n+   |             -------------- the name `Foo` in the type namespace is supposed to be publicly re-exported here\n+LL |\n+LL |     use self::other::Foo;\n+   |         ^^^^^^^^^^^^^^^^ but the private item here shadows it\n+\n+warning: private item shadows public glob re-export\n+  --> $DIR/hidden_glob_reexports.rs:40:9\n+   |\n+LL |     pub use self::no_def_id::*;\n+   |             ------------------ the name `u8` in the type namespace is supposed to be publicly re-exported here\n+LL |\n+LL |     use std::primitive::u8;\n+   |         ^^^^^^^^^^^^^^^^^^ but the private item here shadows it\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "e7f7fdc513bb79bc37efb0c46deb8f87c03573d1", "filename": "tests/ui/unboxed-closures/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -2,7 +2,7 @@\n \n trait One<A> { fn foo(&self) -> A; }\n \n-fn foo(_: &dyn One()) //~ ERROR associated type `Output` not found for `One<()>`\n+fn foo(_: &dyn One()) //~ ERROR associated type `Output` not found for `One`\n {}\n \n fn main() { }"}, {"sha": "e4772478bd91056e0ac4eb7075ee92515c2b4aaa", "filename": "tests/ui/unboxed-closures/unboxed-closure-sugar-wrong-number-number-type-parameters-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -1,4 +1,4 @@\n-error[E0220]: associated type `Output` not found for `One<()>`\n+error[E0220]: associated type `Output` not found for `One`\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs:5:16\n    |\n LL | fn foo(_: &dyn One())"}, {"sha": "eb18b121957c4258fd49b5b26d5f2c72ac0efc18", "filename": "tests/ui/unboxed-closures/unboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -12,7 +12,7 @@ note: trait defined here, with 3 generic parameters: `A`, `B`, `C`\n LL | trait Three<A,B,C> { fn dummy(&self) -> (A,B,C); }\n    |       ^^^^^ - - -\n \n-error[E0220]: associated type `Output` not found for `Three<(), [type error], [type error]>`\n+error[E0220]: associated type `Output` not found for `Three`\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs:5:16\n    |\n LL | fn foo(_: &dyn Three())"}, {"sha": "c160c83cc9590fd863b00ce124869a153d627dca", "filename": "triagebot.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69acfdf0592e15bc0df3caffd922748d0ab70e/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe69acfdf0592e15bc0df3caffd922748d0ab70e/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=fe69acfdf0592e15bc0df3caffd922748d0ab70e", "patch": "@@ -190,6 +190,7 @@ trigger_files = [\n     \"src/stage0.json\",\n     \"src/tools/compiletest\",\n     \"src/tools/tidy\",\n+    \"src/tools/rustdoc-gui-test\",\n ]\n \n [autolabel.\"T-infra\"]\n@@ -640,3 +641,4 @@ style-team = [\n \"/src/tools/rustdoc-themes\" =                [\"rustdoc\"]\n \"/src/tools/tidy\" =                          [\"bootstrap\"]\n \"/src/tools/x\" =                             [\"bootstrap\"]\n+\"/src/tools/rustdoc-gui-test\" =              [\"bootstrap\", \"@ozkanonur\"]"}]}