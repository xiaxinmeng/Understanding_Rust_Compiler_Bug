{"sha": "7ccf492ae616b4d06eab283ab604938fd234415a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjY2Y0OTJhZTYxNmI0ZDA2ZWFiMjgzYWI2MDQ5MzhmZDIzNDQxNWE=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-10-12T14:01:59Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-10-15T22:38:18Z"}, "message": "Package non-rust objects", "tree": {"sha": "3d58c4708cd9120dd63501b8325846794f43761a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d58c4708cd9120dd63501b8325846794f43761a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ccf492ae616b4d06eab283ab604938fd234415a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ccf492ae616b4d06eab283ab604938fd234415a", "html_url": "https://github.com/rust-lang/rust/commit/7ccf492ae616b4d06eab283ab604938fd234415a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ccf492ae616b4d06eab283ab604938fd234415a/comments", "author": null, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c906dc84ec78fad35405d5c0f2b2d58f9f26288", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c906dc84ec78fad35405d5c0f2b2d58f9f26288", "html_url": "https://github.com/rust-lang/rust/commit/4c906dc84ec78fad35405d5c0f2b2d58f9f26288"}], "stats": {"total": 68, "additions": 46, "deletions": 22}, "files": [{"sha": "df1c72575846b0a69e17944473805299af834649", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ccf492ae616b4d06eab283ab604938fd234415a/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccf492ae616b4d06eab283ab604938fd234415a/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7ccf492ae616b4d06eab283ab604938fd234415a", "patch": "@@ -55,6 +55,7 @@ impl Step for Std {\n                   cargo,\n                   args(builder.kind),\n                   &libstd_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n@@ -103,6 +104,7 @@ impl Step for Rustc {\n                   cargo,\n                   args(builder.kind),\n                   &librustc_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n@@ -155,6 +157,7 @@ impl Step for CodegenBackend {\n                   cargo,\n                   args(builder.kind),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n+                  vec![],\n                   true);\n     }\n }\n@@ -199,6 +202,7 @@ impl Step for Rustdoc {\n                   cargo,\n                   args(builder.kind),\n                   &rustdoc_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);"}, {"sha": "d48927f9bf78f8472d72c337ee0d73f23895655e", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7ccf492ae616b4d06eab283ab604938fd234415a/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccf492ae616b4d06eab283ab604938fd234415a/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=7ccf492ae616b4d06eab283ab604938fd234415a", "patch": "@@ -69,7 +69,7 @@ impl Step for Std {\n             return;\n         }\n \n-        builder.ensure(StartupObjects { compiler, target });\n+        let mut target_deps = builder.ensure(StartupObjects { compiler, target });\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n@@ -91,7 +91,7 @@ impl Step for Std {\n             return;\n         }\n \n-        copy_third_party_objects(builder, &compiler, target);\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n@@ -102,6 +102,7 @@ impl Step for Std {\n                   cargo,\n                   vec![],\n                   &libstd_stamp(builder, compiler, target),\n+                  target_deps,\n                   false);\n \n         builder.ensure(StdLink {\n@@ -113,29 +114,36 @@ impl Step for Std {\n }\n \n /// Copies third pary objects needed by various targets.\n-fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>) {\n+fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>)\n+    -> Vec<PathBuf>\n+{\n     let libdir = builder.sysroot_libdir(*compiler, target);\n \n+    let mut target_deps = vec![];\n+\n+    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n+        let target = libdir.join(name);\n+        builder.copy(\n+            &sourcedir.join(name),\n+            &target,\n+        );\n+        target_deps.push(target);\n+    };\n+\n     // Copies the crt(1,i,n).o startup objects\n     //\n     // Since musl supports fully static linking, we can cross link for it even\n     // with a glibc-targeting toolchain, given we have the appropriate startup\n     // files. As those shipped with glibc won't work, copy the ones provided by\n     // musl so we have them on linux-gnu hosts.\n     if target.contains(\"musl\") {\n+        let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n         for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-            builder.copy(\n-                &builder.musl_root(target).unwrap().join(\"lib\").join(obj),\n-                &libdir.join(obj),\n-            );\n+            copy_and_stamp(&srcdir, obj);\n         }\n     } else if target.ends_with(\"-wasi\") {\n-        for &obj in &[\"crt1.o\"] {\n-            builder.copy(\n-                &builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\").join(obj),\n-                &libdir.join(obj),\n-            );\n-        }\n+        let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n+        copy_and_stamp(&srcdir, \"crt1.o\");\n     }\n \n     // Copies libunwind.a compiled to be linked wit x86_64-fortanix-unknown-sgx.\n@@ -145,11 +153,11 @@ fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target:\n     // which is provided by std for this target.\n     if target == \"x86_64-fortanix-unknown-sgx\" {\n         let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let obj = \"libunwind.a\";\n         let src = env::var(src_path_env).expect(&format!(\"{} not found in env\", src_path_env));\n-        let src = Path::new(&src).join(obj);\n-        builder.copy(&src, &libdir.join(obj));\n+        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n     }\n+\n+    target_deps\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n@@ -307,7 +315,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = ();\n+    type Output = Vec<PathBuf>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -326,13 +334,15 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) {\n+    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n-            return\n+            return vec![]\n         }\n \n+        let mut target_deps = vec![];\n+\n         let src_dir = &builder.src.join(\"src/rtstartup\");\n         let dst_dir = &builder.native_dir(target).join(\"rtstartup\");\n         let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n@@ -351,16 +361,22 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            builder.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            let target = sysroot_dir.join(file.to_string() + \".o\");\n+            builder.copy(dst_file, &target);\n+            target_deps.push(target);\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(builder,\n                                     builder.cc(target),\n                                     target,\n                                     obj);\n-            builder.copy(&src, &sysroot_dir.join(obj));\n+            let target = sysroot_dir.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push(target);\n         }\n+\n+        target_deps\n     }\n }\n \n@@ -438,6 +454,7 @@ impl Step for Rustc {\n                   cargo,\n                   vec![],\n                   &librustc_stamp(builder, compiler, target),\n+                  vec![],\n                   false);\n \n         builder.ensure(RustcLink {\n@@ -586,7 +603,7 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, false);\n+        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false);\n         if builder.config.dry_run {\n             return;\n         }\n@@ -954,6 +971,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: Cargo,\n                  tail_args: Vec<String>,\n                  stamp: &Path,\n+                 additional_target_deps: Vec<PathBuf>,\n                  is_check: bool)\n     -> Vec<PathBuf>\n {\n@@ -1070,6 +1088,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n+    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n     deps.sort();\n     let mut new_contents = Vec::new();\n     for (dep, proc_macro) in deps.iter() {"}, {"sha": "ad0bdd0f425f1eb4861a5fb33fc1c4dfa4f9b33d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ccf492ae616b4d06eab283ab604938fd234415a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccf492ae616b4d06eab283ab604938fd234415a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7ccf492ae616b4d06eab283ab604938fd234415a", "patch": "@@ -1144,6 +1144,7 @@ impl Build {\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run { return; }\n         self.verbose_than(1, &format!(\"Copy {:?} to {:?}\", src, dst));\n+        if src == dst { return; }\n         let _ = fs::remove_file(&dst);\n         let metadata = t!(src.symlink_metadata());\n         if metadata.file_type().is_symlink() {"}]}