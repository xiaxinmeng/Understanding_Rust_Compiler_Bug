{"sha": "da7d405357600a76f2b93b8aa41fe5ee5da7885d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhN2Q0MDUzNTc2MDBhNzZmMmI5M2I4YWE0MWZlNWVlNWRhNzg4NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-20T10:56:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-20T10:56:08Z"}, "message": "Auto merge of #87244 - jackh726:issue-71883, r=estebank\n\nBetter diagnostics with mismatched types due to implicit static lifetime\n\nFixes #78113\n\nI think this is my first diagnostics PR...definitely happy to hear thoughts on the direction/implementation here.\n\nI was originally just trying to solve the error above, where the lifetime on a GAT was causing a cryptic \"mismatched types\" error. But as I was writing this, I realized that this (unintentionally) also applied to a different case: `wf-in-foreign-fn-decls-issue-80468.rs`. I'm not sure if this diagnostic should get a new error code, or even reuse an existing one. And, there might be some ways to make this even more generalized. Also, the error is a bit more lengthy and verbose than probably needed. So thoughts there are welcome too.\n\nThis PR essentially ended up adding a new nice region error pass that triggers if a type doesn't match the self type of an impl which is selected because of a predicate because of an implicit static bound on that self type.\n\nr? `@estebank`", "tree": {"sha": "9763cf30603b2489abef4a9fefe570465c287b29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9763cf30603b2489abef4a9fefe570465c287b29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da7d405357600a76f2b93b8aa41fe5ee5da7885d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da7d405357600a76f2b93b8aa41fe5ee5da7885d", "html_url": "https://github.com/rust-lang/rust/commit/da7d405357600a76f2b93b8aa41fe5ee5da7885d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da7d405357600a76f2b93b8aa41fe5ee5da7885d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "718d53b0cb7dde93499cb92950d60b412f5a3d05", "url": "https://api.github.com/repos/rust-lang/rust/commits/718d53b0cb7dde93499cb92950d60b412f5a3d05", "html_url": "https://github.com/rust-lang/rust/commit/718d53b0cb7dde93499cb92950d60b412f5a3d05"}, {"sha": "ae024919845a44473c22b8c3f1dfa075c9c5c75d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae024919845a44473c22b8c3f1dfa075c9c5c75d", "html_url": "https://github.com/rust-lang/rust/commit/ae024919845a44473c22b8c3f1dfa075c9c5c75d"}], "stats": {"total": 337, "additions": 299, "deletions": 38}, "files": [{"sha": "55173c6f8696e419545ef1e8c9a6d8f2157db138", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -336,6 +336,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             insertion_sp,\n                             suggestion,\n                         );\n+                        err.note(\"assuming a `'static` lifetime...\");\n                         err.emit();\n                     }\n                     AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {"}, {"sha": "670129937be2b9f7981da55968549b214dae2db2", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -1590,17 +1590,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         };\n         if let Some((expected, found)) = expected_found {\n-            let expected_label = match exp_found {\n-                Mismatch::Variable(ef) => ef.expected.prefix_string(self.tcx),\n-                Mismatch::Fixed(s) => s.into(),\n-            };\n-            let found_label = match exp_found {\n-                Mismatch::Variable(ef) => ef.found.prefix_string(self.tcx),\n-                Mismatch::Fixed(s) => s.into(),\n-            };\n-            let exp_found = match exp_found {\n-                Mismatch::Variable(exp_found) => Some(exp_found),\n-                Mismatch::Fixed(_) => None,\n+            let (expected_label, found_label, exp_found) = match exp_found {\n+                Mismatch::Variable(ef) => (\n+                    ef.expected.prefix_string(self.tcx),\n+                    ef.found.prefix_string(self.tcx),\n+                    Some(ef),\n+                ),\n+                Mismatch::Fixed(s) => (s.into(), s.into(), None),\n             };\n             match (&terr, expected == found) {\n                 (TypeError::Sorts(values), extra) => {"}, {"sha": "cca195417270bd5289d45d8e82f921ec06572094", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -0,0 +1,103 @@\n+//! Error Reporting for when the lifetime for a type doesn't match the `impl` selected for a predicate\n+//! to hold.\n+\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::error_reporting::note_and_explain_region;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::{SubregionOrigin, TypeTrace};\n+use crate::traits::ObligationCauseCode;\n+use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_errors::{Applicability, ErrorReported};\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_middle::ty::{self, TypeVisitor};\n+use rustc_span::MultiSpan;\n+\n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n+    pub(super) fn try_report_mismatched_static_lifetime(&self) -> Option<ErrorReported> {\n+        let error = self.error.as_ref()?;\n+        debug!(\"try_report_mismatched_static_lifetime {:?}\", error);\n+\n+        let (origin, sub, sup) = match error.clone() {\n+            RegionResolutionError::ConcreteFailure(origin, sub, sup) => (origin, sub, sup),\n+            _ => return None,\n+        };\n+        if *sub != ty::RegionKind::ReStatic {\n+            return None;\n+        }\n+        let cause = match origin {\n+            SubregionOrigin::Subtype(box TypeTrace { ref cause, .. }) => cause,\n+            _ => return None,\n+        };\n+        let (parent, impl_def_id) = match &cause.code {\n+            ObligationCauseCode::MatchImpl(parent, impl_def_id) => (parent, impl_def_id),\n+            _ => return None,\n+        };\n+        let binding_span = match **parent {\n+            ObligationCauseCode::BindingObligation(_def_id, binding_span) => binding_span,\n+            _ => return None,\n+        };\n+        let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n+        // FIXME: we should point at the lifetime\n+        let mut multi_span: MultiSpan = vec![binding_span].into();\n+        multi_span\n+            .push_span_label(binding_span, \"introduces a `'static` lifetime requirement\".into());\n+        err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n+        note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\");\n+        if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n+            // If an impl is local, then maybe this isn't what they want. Try to\n+            // be as helpful as possible with implicit lifetimes.\n+\n+            // First, let's get the hir self type of the impl\n+            let impl_self_ty = match impl_node {\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                    ..\n+                }) => self_ty,\n+                _ => bug!(\"Node not an impl.\"),\n+            };\n+\n+            // Next, let's figure out the set of trait objects with implict static bounds\n+            let ty = self.tcx().type_of(*impl_def_id);\n+            let mut v = super::static_impl_trait::TraitObjectVisitor(FxHashSet::default());\n+            v.visit_ty(ty);\n+            let mut traits = vec![];\n+            for matching_def_id in v.0 {\n+                let mut hir_v =\n+                    super::static_impl_trait::HirTraitObjectVisitor(&mut traits, matching_def_id);\n+                hir_v.visit_ty(&impl_self_ty);\n+            }\n+\n+            if traits.is_empty() {\n+                // If there are no trait object traits to point at, either because\n+                // there aren't trait objects or because none are implicit, then just\n+                // write a single note on the impl itself.\n+\n+                let impl_span = self.tcx().def_span(*impl_def_id);\n+                err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+            } else {\n+                // Otherwise, point at all implicit static lifetimes\n+\n+                err.note(\"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+                for span in &traits {\n+                    err.span_note(*span, \"this has an implicit `'static` lifetime requirement\");\n+                    // It would be nice to put this immediately under the above note, but they get\n+                    // pushed to the end.\n+                    err.span_suggestion_verbose(\n+                        span.shrink_to_hi(),\n+                        \"consider relaxing the implicit `'static` requirement\",\n+                        \" + '_\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        } else {\n+            // Otherwise just point out the impl.\n+\n+            let impl_span = self.tcx().def_span(*impl_def_id);\n+            err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+        }\n+        err.emit();\n+        Some(ErrorReported)\n+    }\n+}"}, {"sha": "3f27bf67b59a91d357eb88806d2186b881d49b9b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -7,6 +7,7 @@ use rustc_span::source_map::Span;\n \n mod different_lifetimes;\n pub mod find_anon_type;\n+mod mismatched_static_lifetime;\n mod named_anon_conflict;\n mod placeholder_error;\n mod static_impl_trait;\n@@ -58,6 +59,7 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n             .or_else(|| self.try_report_impl_not_conforming_to_trait())\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_static_impl_trait())\n+            .or_else(|| self.try_report_mismatched_static_lifetime())\n     }\n \n     pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {"}, {"sha": "fde4ec05ffc867f74ec0aeced86aa748bc26d07e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -4,6 +4,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n@@ -185,17 +186,20 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin {\n-            if let ObligationCauseCode::ItemObligation(item_def_id) = cause.code {\n+            let code = match &cause.code {\n+                ObligationCauseCode::MatchImpl(parent, ..) => &**parent,\n+                _ => &cause.code,\n+            };\n+            if let ObligationCauseCode::ItemObligation(item_def_id) = *code {\n                 // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n                 // lifetime as above, but called using a fully-qualified path to the method:\n                 // `Foo::qux(bar)`.\n-                let mut v = TraitObjectVisitor(vec![]);\n+                let mut v = TraitObjectVisitor(FxHashSet::default());\n                 v.visit_ty(param.param_ty);\n                 if let Some((ident, self_ty)) =\n-                    self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0[..])\n+                    self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n                 {\n-                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0[..], ident, self_ty)\n-                    {\n+                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty) {\n                         override_error_code = Some(ident);\n                     }\n                 }\n@@ -336,7 +340,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     fn get_impl_ident_and_self_ty_from_trait(\n         &self,\n         def_id: DefId,\n-        trait_objects: &[DefId],\n+        trait_objects: &FxHashSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n@@ -373,9 +377,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                         // multiple `impl`s for the same trait like\n                                         // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n                                         // In that case, only the first one will get suggestions.\n-                                        let mut hir_v = HirTraitObjectVisitor(vec![], *did);\n+                                        let mut traits = vec![];\n+                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n                                         hir_v.visit_ty(self_ty);\n-                                        !hir_v.0.is_empty()\n+                                        !traits.is_empty()\n                                     }) =>\n                                     {\n                                         Some(self_ty)\n@@ -417,33 +422,34 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             _ => return false,\n         };\n \n-        let mut v = TraitObjectVisitor(vec![]);\n+        let mut v = TraitObjectVisitor(FxHashSet::default());\n         v.visit_ty(ty);\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n         let (ident, self_ty) =\n-            match self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0[..]) {\n+            match self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) {\n                 Some((ident, self_ty)) => (ident, self_ty),\n                 None => return false,\n             };\n \n         // Find the trait object types in the argument, so we point at *only* the trait object.\n-        self.suggest_constrain_dyn_trait_in_impl(err, &v.0[..], ident, self_ty)\n+        self.suggest_constrain_dyn_trait_in_impl(err, &v.0, ident, self_ty)\n     }\n \n     fn suggest_constrain_dyn_trait_in_impl(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        found_dids: &[DefId],\n+        found_dids: &FxHashSet<DefId>,\n         ident: Ident,\n         self_ty: &hir::Ty<'_>,\n     ) -> bool {\n         let mut suggested = false;\n         for found_did in found_dids {\n-            let mut hir_v = HirTraitObjectVisitor(vec![], *found_did);\n+            let mut traits = vec![];\n+            let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n             hir_v.visit_ty(&self_ty);\n-            for span in &hir_v.0 {\n+            for span in &traits {\n                 let mut multi_span: MultiSpan = vec![*span].into();\n                 multi_span.push_span_label(\n                     *span,\n@@ -468,14 +474,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n }\n \n /// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n-struct TraitObjectVisitor(Vec<DefId>);\n+pub(super) struct TraitObjectVisitor(pub(super) FxHashSet<DefId>);\n \n impl TypeVisitor<'_> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Dynamic(preds, RegionKind::ReStatic) => {\n                 if let Some(def_id) = preds.principal_def_id() {\n-                    self.0.push(def_id);\n+                    self.0.insert(def_id);\n                 }\n                 ControlFlow::CONTINUE\n             }\n@@ -485,9 +491,9 @@ impl TypeVisitor<'_> for TraitObjectVisitor {\n }\n \n /// Collect all `hir::Ty<'_>` `Span`s for trait objects with an implicit lifetime.\n-struct HirTraitObjectVisitor(Vec<Span>, DefId);\n+pub(super) struct HirTraitObjectVisitor<'a>(pub(super) &'a mut Vec<Span>, pub(super) DefId);\n \n-impl<'tcx> Visitor<'tcx> for HirTraitObjectVisitor {\n+impl<'a, 'tcx> Visitor<'tcx> for HirTraitObjectVisitor<'a> {\n     type Map = ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "f951e43fbfa3538c163e24eb35447cef734d62f1", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -333,6 +333,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// This is purely for diagnostic purposes - it is always\n     /// correct to use `MiscObligation` instead\n     WellFormed(Option<hir::HirId>),\n+\n+    /// From `match_impl`. The cause for us having to match an impl, and the DefId we are matching against.\n+    MatchImpl(Lrc<ObligationCauseCode<'tcx>>, DefId),\n }\n \n impl ObligationCauseCode<'_> {"}, {"sha": "1c6a83b578305cce376304f40c9a956deedbbb37", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -1903,7 +1903,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::UnifyReceiver(..)\n             | ObligationCauseCode::OpaqueType\n             | ObligationCauseCode::MiscObligation\n-            | ObligationCauseCode::WellFormed(..) => {}\n+            | ObligationCauseCode::WellFormed(..)\n+            | ObligationCauseCode::MatchImpl(..) => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "1bdc8b34cf6ba7da8f5f5a909264156ee5ace152", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -1903,9 +1903,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?impl_trait_ref, ?placeholder_obligation_trait_ref);\n \n+        let cause = ObligationCause::new(\n+            obligation.cause.span,\n+            obligation.cause.body_id,\n+            ObligationCauseCode::MatchImpl(Lrc::new(obligation.cause.code.clone()), impl_def_id),\n+        );\n+\n         let InferOk { obligations, .. } = self\n             .infcx\n-            .at(&obligation.cause, obligation.param_env)\n+            .at(&cause, obligation.param_env)\n             .eq(placeholder_obligation_trait_ref, impl_trait_ref)\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);"}, {"sha": "36fb73a8dde247e5b8b03bc273512fab66b36605", "filename": "src/test/ui/async-await/async-fn-path-elision.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | async fn error(lt: HasLifetime) {\n    |                    ^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: aborting due to previous error\n "}, {"sha": "850d83be6845dc44b1e54c876cd8264d960a2d2c", "filename": "src/test/ui/generic-associated-types/issue-78113-lifetime-mismatch-dyn-trait-box.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -0,0 +1,40 @@\n+// Test for diagnostics when we have mismatched lifetime due to implict 'static lifetime in GATs\n+\n+// check-fail\n+\n+#![feature(generic_associated_types)]\n+\n+pub trait A {}\n+impl A for &dyn A {}\n+impl A for Box<dyn A> {}\n+\n+pub trait B {\n+    type T<'a>: A;\n+}\n+\n+impl B for () {\n+    // `'a` doesn't match implicit `'static`: suggest `'_`\n+    type T<'a> = Box<dyn A + 'a>; //~ incompatible lifetime on type\n+}\n+\n+trait C {}\n+impl C for Box<dyn A + 'static> {}\n+pub trait D {\n+    type T<'a>: C;\n+}\n+impl D for () {\n+    // `'a` doesn't match explicit `'static`: we *should* suggest removing `'static`\n+    type T<'a> = Box<dyn A + 'a>; //~ incompatible lifetime on type\n+}\n+\n+trait E {}\n+impl E for (Box<dyn A>, Box<dyn A>) {}\n+pub trait F {\n+    type T<'a>: E;\n+}\n+impl F for () {\n+    // `'a` doesn't match explicit `'static`: suggest `'_`\n+    type T<'a> = (Box<dyn A + 'a>, Box<dyn A + 'a>); //~ incompatible lifetime on type\n+}\n+\n+fn main() {}"}, {"sha": "fedc6a341cad3d53f12a09817e811a2ffc6016d8", "filename": "src/test/ui/generic-associated-types/issue-78113-lifetime-mismatch-dyn-trait-box.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.stderr?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -0,0 +1,87 @@\n+error: incompatible lifetime on type\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:17:5\n+   |\n+LL |     type T<'a> = Box<dyn A + 'a>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: because this has an unmet lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:12:17\n+   |\n+LL |     type T<'a>: A;\n+   |                 ^ introduces a `'static` lifetime requirement\n+note: the lifetime `'a` as defined on the associated item at 17:12...\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:17:12\n+   |\n+LL |     type T<'a> = Box<dyn A + 'a>;\n+   |            ^^\n+   = note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+note: this has an implicit `'static` lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:9:20\n+   |\n+LL | impl A for Box<dyn A> {}\n+   |                    ^\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL | impl A for Box<dyn A + '_> {}\n+   |                      ^^^^\n+\n+error: incompatible lifetime on type\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:27:5\n+   |\n+LL |     type T<'a> = Box<dyn A + 'a>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: because this has an unmet lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:23:17\n+   |\n+LL |     type T<'a>: C;\n+   |                 ^ introduces a `'static` lifetime requirement\n+note: the lifetime `'a` as defined on the associated item at 27:12...\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:27:12\n+   |\n+LL |     type T<'a> = Box<dyn A + 'a>;\n+   |            ^^\n+note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:21:1\n+   |\n+LL | impl C for Box<dyn A + 'static> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: incompatible lifetime on type\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:37:5\n+   |\n+LL |     type T<'a> = (Box<dyn A + 'a>, Box<dyn A + 'a>);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: because this has an unmet lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:33:17\n+   |\n+LL |     type T<'a>: E;\n+   |                 ^ introduces a `'static` lifetime requirement\n+note: the lifetime `'a` as defined on the associated item at 37:12...\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:37:12\n+   |\n+LL |     type T<'a> = (Box<dyn A + 'a>, Box<dyn A + 'a>);\n+   |            ^^\n+   = note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+note: this has an implicit `'static` lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:31:21\n+   |\n+LL | impl E for (Box<dyn A>, Box<dyn A>) {}\n+   |                     ^\n+note: this has an implicit `'static` lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:31:33\n+   |\n+LL | impl E for (Box<dyn A>, Box<dyn A>) {}\n+   |                                 ^\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL | impl E for (Box<dyn A + '_>, Box<dyn A>) {}\n+   |                       ^^^^\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL | impl E for (Box<dyn A>, Box<dyn A + '_>) {}\n+   |                                   ^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "1c81c69620165df971959f6fc3ecb7d024f75f99", "filename": "src/test/ui/impl-header-lifetime-elision/path-elided.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl MyTrait for Foo {\n    |                  ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: aborting due to previous error\n "}, {"sha": "735f01379f09fc4f50ceb45157e0543f25d9a483", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl MyTrait for u32 {\n    |      ^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: aborting due to previous error\n "}, {"sha": "9d181eab7fbcdf1cd51989d3143f792224b6b557", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -45,6 +45,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n    |             ^^^^^^^^^^^^^^^^^ help: indicate the anonymous lifetime: `Serializable<'_, str>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> $DIR/issue-10412.rs:6:13"}, {"sha": "4fcf8f403bbb6e38ac9da13de6627395f38a7c15", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.rs?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -13,5 +13,5 @@ pub struct Ref<'a>(&'a u8);\n impl Trait for Ref {} //~ ERROR:  implicit elided lifetime not allowed here\n \n extern \"C\" {\n-    pub fn repro(_: Wrapper<Ref>); //~ ERROR: mismatched types\n+    pub fn repro(_: Wrapper<Ref>); //~ ERROR: incompatible lifetime on type\n }"}, {"sha": "4e927cd983d0d4d906defe475a6d98e19fe3c4cc", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7d405357600a76f2b93b8aa41fe5ee5da7885d/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr?ref=da7d405357600a76f2b93b8aa41fe5ee5da7885d", "patch": "@@ -3,22 +3,30 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl Trait for Ref {}\n    |                ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n-error[E0308]: mismatched types\n+error: incompatible lifetime on type\n   --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:21\n    |\n LL |     pub fn repro(_: Wrapper<Ref>);\n-   |                     ^^^^^^^^^^^^ lifetime mismatch\n+   |                     ^^^^^^^^^^^^\n+   |\n+note: because this has an unmet lifetime requirement\n+  --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:8:23\n    |\n-   = note: expected trait `Trait`\n-              found trait `Trait`\n+LL | pub struct Wrapper<T: Trait>(T);\n+   |                       ^^^^^ introduces a `'static` lifetime requirement\n note: the anonymous lifetime #1 defined on the method body at 16:5...\n   --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:5\n    |\n LL |     pub fn repro(_: Wrapper<Ref>);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...does not necessarily outlive the static lifetime\n+note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+  --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:13:1\n+   |\n+LL | impl Trait for Ref {}\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}]}