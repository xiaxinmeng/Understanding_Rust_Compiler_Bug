{"sha": "62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZmU1ODdmODExNGFjYTE5ZTFhYTZhYjQyMWQwNmIzMjBhYzFiNGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T05:44:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T21:37:30Z"}, "message": "revisit error message; create spill map", "tree": {"sha": "35bdd27eb6f18b8b740e4858e4f8100de9b4f7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35bdd27eb6f18b8b740e4858e4f8100de9b4f7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "html_url": "https://github.com/rust-lang/rust/commit/62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "123c5c43151bda6fd28ced76237acd99d9b4e791", "url": "https://api.github.com/repos/rust-lang/rust/commits/123c5c43151bda6fd28ced76237acd99d9b4e791", "html_url": "https://github.com/rust-lang/rust/commit/123c5c43151bda6fd28ced76237acd99d9b4e791"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "d7318143adf1a0c07644507d5e1124ba64a7353b", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 89, "deletions": 15, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "patch": "@@ -58,8 +58,20 @@ import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n export check_crate;\n export last_use_map;\n \n+// Maps from an expr id to a list of variable ids for which this expr\n+// is the last use.  Typically, the expr is a path and the node id is\n+// the local/argument/etc that the path refers to.  However, it also\n+// possible for the expr to be a closure, in which case the list is a\n+// list of closed over variables that can be moved into the closure.\n type last_use_map = hashmap<node_id, @dvec<node_id>>;\n \n+// A set of variable ids which must be spilled (stored on the stack).\n+// We add in any variables or arguments where:\n+// (1) the variables are moved;\n+// (2) the address of the variable/argument is taken;\n+// or (3) we find a last use (as they may be moved).\n+type spill_map = hashmap<node_id, ()>;\n+\n enum variable = uint;\n enum live_node = uint;\n \n@@ -81,7 +93,9 @@ fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = int_hash();\n-    let initial_maps = @ir_maps(tcx, method_map, last_use_map);\n+    let spill_map = int_hash();\n+    let initial_maps = @ir_maps(tcx, method_map,\n+                                last_use_map, spill_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n     ret last_use_map;\n@@ -141,6 +155,7 @@ class ir_maps {\n     let tcx: ty::ctxt;\n     let method_map: typeck::method_map;\n     let last_use_map: last_use_map;\n+    let spill_map: spill_map;\n \n     let mut num_live_nodes: uint;\n     let mut num_vars: uint;\n@@ -152,10 +167,11 @@ class ir_maps {\n     let mut lnks: [live_node_kind];\n \n     new(tcx: ty::ctxt, method_map: typeck::method_map,\n-        last_use_map: hashmap<node_id, @dvec<node_id>>) {\n+        last_use_map: last_use_map, spill_map: spill_map) {\n         self.tcx = tcx;\n         self.method_map = method_map;\n         self.last_use_map = last_use_map;\n+        self.spill_map = spill_map;\n \n         self.num_live_nodes = 0u;\n         self.num_vars = 0u;\n@@ -236,6 +252,11 @@ class ir_maps {\n                expr_id, id, name];\n         (*v).push(id);\n     }\n+\n+    fn add_spill(var: variable) {\n+        let id = self.var_infos[*var].id;\n+        if id != 0 { self.spill_map.insert(id, ()); }\n+    }\n }\n \n fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n@@ -245,7 +266,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @ir_maps(self.tcx, self.method_map,\n-                           self.last_use_map);\n+                           self.last_use_map, self.spill_map);\n \n     #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n \n@@ -453,6 +474,18 @@ class liveness {\n         }\n     }\n \n+    fn variable_from_path(expr: @expr) -> option<variable> {\n+        alt expr.node {\n+          expr_path(_) {\n+            let def = self.tcx.def_map.get(expr.id);\n+            relevant_def(def).map { |rdef|\n+                self.variable_from_rdef(rdef, expr.span)\n+            }\n+          }\n+          _ {none}\n+        }\n+    }\n+\n     fn variable(node_id: node_id, span: span) -> variable {\n         (*self.ir).variable(node_id, span)\n     }\n@@ -682,11 +715,18 @@ class liveness {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each { |arg|\n             alt ty::resolved_mode(self.tcx, arg.mode) {\n-              by_mutbl_ref {\n+              by_mutbl_ref | by_ref | by_val {\n+                // These are \"non-owned\" modes, so register a read at\n+                // the end.  This will prevent us from moving out of\n+                // such variables but also prevent us from registering\n+                // last uses and so forth.\n                 let var = self.variable(arg.id, blk.span);\n                 self.acc(self.s.exit_ln, var, ACC_READ);\n               }\n-              by_val | by_ref | by_move | by_copy {}\n+              by_move | by_copy {\n+                // These are owned modes.  If we don't use the\n+                // variable, nobody will.\n+              }\n             }\n         }\n \n@@ -1325,7 +1365,11 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         vt.visit_expr(f, self, vt);\n         vec::iter2(args, targs) { |arg_expr, arg_ty|\n             alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n-              by_val | by_ref | by_mutbl_ref | by_copy {\n+              by_val | by_copy {\n+                vt.visit_expr(arg_expr, self, vt);\n+              }\n+              by_ref | by_mutbl_ref {\n+                self.spill_expr(arg_expr);\n                 vt.visit_expr(arg_expr, self, vt);\n               }\n               by_move {\n@@ -1335,13 +1379,17 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         }\n       }\n \n+      expr_addr_of(_, arg_expr) {\n+        self.spill_expr(arg_expr);\n+      }\n+\n       // no correctness conditions related to liveness\n       expr_if_check(*) | expr_if(*) | expr_alt(*) |\n       expr_while(*) | expr_loop(*) |\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n       expr_vec(*) | expr_rec(*) | expr_tup(*) |\n       expr_bind(*) | expr_new(*) | expr_log(*) | expr_binary(*) |\n-      expr_assert(*) | expr_check(*) | expr_addr_of(*) | expr_copy(*) |\n+      expr_assert(*) | expr_check(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_cont | expr_lit(_) |\n       expr_block(*) | expr_swap(*) | expr_mac(*) {\n@@ -1411,7 +1459,10 @@ impl check_methods for @liveness {\n                ln.to_str(), var.to_str()];\n \n         alt (*self).live_on_exit(ln, var) {\n-          none {}\n+          none {\n+            // update spill map to include this variable, as it is moved:\n+            (*self.ir).add_spill(var);\n+          }\n           some(lnk) {\n             self.report_illegal_read(span, lnk, var, moved_variable);\n             self.tcx.sess.span_note(\n@@ -1426,10 +1477,20 @@ impl check_methods for @liveness {\n           some(_) {}\n           none {\n             (*self.ir).add_last_use(expr.id, var);\n+\n+            // update spill map to include this variable, as it may be moved:\n+            (*self.ir).add_spill(var);\n           }\n        }\n     }\n \n+    fn spill_expr(expr: @expr) {\n+        alt (*self).variable_from_path(expr) {\n+          some(var) {(*self.ir).add_spill(var)}\n+          none {}\n+        }\n+    }\n+\n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n         #debug[\"check_move_from_expr(node %d: %s)\",\n                expr.id, expr_to_str(expr)];\n@@ -1441,12 +1502,9 @@ impl check_methods for @liveness {\n \n         alt expr.node {\n           expr_path(_) {\n-            let def = self.tcx.def_map.get(expr.id);\n-            alt relevant_def(def) {\n-              some(rdef) {\n-                // Moving from a variable is allowed if is is not live.\n+            alt (*self).variable_from_path(expr) {\n+              some(var) {\n                 let ln = (*self).live_node(expr.id, expr.span);\n-                let var = (*self).variable_from_rdef(rdef, expr.span);\n                 self.check_move_from_var(expr.span, ln, var);\n               }\n               none {}\n@@ -1606,8 +1664,24 @@ impl check_methods for @liveness {\n     fn warn_about_unused(sp: span, ln: live_node, var: variable) -> bool {\n         if !(*self).used_on_entry(ln, var) {\n             for self.should_warn(var).each { |name|\n-                self.tcx.sess.span_warn(\n-                    sp, #fmt[\"unused variable: `%s`\", name]);\n+\n+                // annoying: for parameters in funcs like `fn(x: int)\n+                // {ret}`, there is only one node, so asking about\n+                // assigned_on_exit() is not meaningful.\n+                let is_assigned = if ln == self.s.exit_ln {\n+                    false\n+                } else {\n+                    (*self).assigned_on_exit(ln, var).is_some()\n+                };\n+\n+                if is_assigned {\n+                    self.tcx.sess.span_warn(\n+                        sp, #fmt[\"variable `%s` is assigned to, \\\n+                                  but never used\", name]);\n+                } else {\n+                    self.tcx.sess.span_warn(\n+                        sp, #fmt[\"unused variable: `%s`\", name]);\n+                }\n             }\n             ret true;\n         }"}, {"sha": "a1ad07f6ecb95b09286d28f8b24258390acc7aa2", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "patch": "@@ -13,14 +13,14 @@ fn f2() {\n \n fn f3() {\n     let mut x = 3;\n-    //!^ WARNING unused variable: `x`\n+    //!^ WARNING variable `x` is assigned to, but never used\n     x += 4;\n     //!^ WARNING value assigned to `x` is never read\n }\n \n fn f3b() {\n     let mut z = 3;\n-    //!^ WARNING unused variable: `z`\n+    //!^ WARNING variable `z` is assigned to, but never used\n     loop {\n         z += 4;\n     }"}]}