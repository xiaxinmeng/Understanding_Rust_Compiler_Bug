{"sha": "5d2225f4bc82c4cd551db5a53500e7a076bf5586", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMjIyNWY0YmM4MmM0Y2Q1NTFkYjVhNTM1MDBlN2EwNzZiZjU1ODY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-07T15:38:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-07T15:38:02Z"}, "message": "Fix symbol search in salsa\n\nPrevious solution for binning paths into disjoint directories was\nsimple and fast -- just a single binary search.\n\nUnfortunatelly, it wasn't coorrect: if the ditr are\n\n  /d\n  /d/a\n  /d/c\n\nthen partitioning the file /d/b/lib.rs won't pick /d as a correct\ndirectory.\n\nThe correct solution here is a trie, but it requires exposing path\ncomponents.\n\nSo, we use a poor man's substitution -- a *vector* of sorted paths,\nsuch that each bucket is prefix-free\n\ncloses #5246", "tree": {"sha": "31bb591b935992d7f30e0fabe8633018ddbf6d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31bb591b935992d7f30e0fabe8633018ddbf6d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d2225f4bc82c4cd551db5a53500e7a076bf5586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2225f4bc82c4cd551db5a53500e7a076bf5586", "html_url": "https://github.com/rust-lang/rust/commit/5d2225f4bc82c4cd551db5a53500e7a076bf5586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d2225f4bc82c4cd551db5a53500e7a076bf5586/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7407636568c791b39cd12f9176f667dac2deef1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7407636568c791b39cd12f9176f667dac2deef1b", "html_url": "https://github.com/rust-lang/rust/commit/7407636568c791b39cd12f9176f667dac2deef1b"}], "stats": {"total": 109, "additions": 90, "deletions": 19}, "files": [{"sha": "b0130017e77a4bb55ca0ad980a0e9811bf17cfeb", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 90, "deletions": 19, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5d2225f4bc82c4cd551db5a53500e7a076bf5586/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2225f4bc82c4cd551db5a53500e7a076bf5586/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=5d2225f4bc82c4cd551db5a53500e7a076bf5586", "patch": "@@ -2,7 +2,7 @@\n //!\n //! Files which do not belong to any explicitly configured `FileSet` belong to\n //! the default `FileSet`.\n-use std::{fmt, iter};\n+use std::{fmt, mem};\n \n use rustc_hash::FxHashMap;\n \n@@ -15,6 +15,9 @@ pub struct FileSet {\n }\n \n impl FileSet {\n+    pub fn len(&self) -> usize {\n+        self.files.len()\n+    }\n     pub fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n         let mut base = self.paths[&anchor].clone();\n         base.pop();\n@@ -37,10 +40,15 @@ impl fmt::Debug for FileSet {\n     }\n }\n \n+// Invariant: if k1 is a prefix of k2, then they are in different buckets (k2\n+// is closer to 0th bucket).\n+// FIXME: replace with an actual trie some day.\n+type BadTrie<K, V> = Vec<Vec<(K, V)>>;\n+\n #[derive(Debug)]\n pub struct FileSetConfig {\n     n_file_sets: usize,\n-    roots: Vec<(VfsPath, usize)>,\n+    trie: BadTrie<VfsPath, usize>,\n }\n \n impl Default for FileSetConfig {\n@@ -65,15 +73,7 @@ impl FileSetConfig {\n         self.n_file_sets\n     }\n     fn classify(&self, path: &VfsPath) -> usize {\n-        let idx = match self.roots.binary_search_by(|(p, _)| p.cmp(path)) {\n-            Ok(it) => it,\n-            Err(it) => it.saturating_sub(1),\n-        };\n-        if !self.roots.is_empty() && path.starts_with(&self.roots[idx].0) {\n-            self.roots[idx].1\n-        } else {\n-            self.len() - 1\n-        }\n+        find_ancestor(&self.trie, path, is_prefix).copied().unwrap_or(self.len() - 1)\n     }\n }\n \n@@ -96,13 +96,84 @@ impl FileSetConfigBuilder {\n     }\n     pub fn build(self) -> FileSetConfig {\n         let n_file_sets = self.roots.len() + 1;\n-        let mut roots: Vec<(VfsPath, usize)> = self\n-            .roots\n-            .into_iter()\n-            .enumerate()\n-            .flat_map(|(i, paths)| paths.into_iter().zip(iter::repeat(i)))\n-            .collect();\n-        roots.sort();\n-        FileSetConfig { n_file_sets, roots }\n+\n+        let mut trie = BadTrie::new();\n+\n+        for (i, paths) in self.roots.into_iter().enumerate() {\n+            for p in paths {\n+                insert(&mut trie, p, i, is_prefix);\n+            }\n+        }\n+        trie.iter_mut().for_each(|it| it.sort());\n+        FileSetConfig { n_file_sets, trie }\n+    }\n+}\n+\n+fn is_prefix(short: &VfsPath, long: &VfsPath) -> bool {\n+    long.starts_with(short)\n+}\n+\n+fn insert<K: Ord, V, P: Fn(&K, &K) -> bool>(\n+    trie: &mut BadTrie<K, V>,\n+    mut key: K,\n+    mut value: V,\n+    is_prefix: P,\n+) {\n+    'outer: for level in 0.. {\n+        if trie.len() == level {\n+            trie.push(Vec::new())\n+        }\n+        for (k, v) in trie[level].iter_mut() {\n+            if is_prefix(&key, k) {\n+                continue 'outer;\n+            }\n+            if is_prefix(k, &key) {\n+                mem::swap(k, &mut key);\n+                mem::swap(v, &mut value);\n+                continue 'outer;\n+            }\n+        }\n+        trie[level].push((key, value));\n+        return;\n+    }\n+}\n+\n+fn find_ancestor<'t, K: Ord, V, P: Fn(&K, &K) -> bool>(\n+    trie: &'t BadTrie<K, V>,\n+    key: &K,\n+    is_prefix: P,\n+) -> Option<&'t V> {\n+    for bucket in trie {\n+        let idx = match bucket.binary_search_by(|(k, _)| k.cmp(key)) {\n+            Ok(it) => it,\n+            Err(it) => it.saturating_sub(1),\n+        };\n+        if !bucket.is_empty() && is_prefix(&bucket[idx].0, key) {\n+            return Some(&bucket[idx].1);\n+        }\n     }\n+    None\n+}\n+\n+#[test]\n+fn test_partitioning() {\n+    let mut file_set = FileSetConfig::builder();\n+    file_set.add_file_set(vec![VfsPath::new_virtual_path(\"/foo\".into())]);\n+    file_set.add_file_set(vec![VfsPath::new_virtual_path(\"/foo/bar/baz\".into())]);\n+    let file_set = file_set.build();\n+\n+    let mut vfs = Vfs::default();\n+    vfs.set_file_contents(VfsPath::new_virtual_path(\"/foo/src/lib.rs\".into()), Some(Vec::new()));\n+    vfs.set_file_contents(\n+        VfsPath::new_virtual_path(\"/foo/src/bar/baz/lib.rs\".into()),\n+        Some(Vec::new()),\n+    );\n+    vfs.set_file_contents(\n+        VfsPath::new_virtual_path(\"/foo/bar/baz/lib.rs\".into()),\n+        Some(Vec::new()),\n+    );\n+    vfs.set_file_contents(VfsPath::new_virtual_path(\"/quux/lib.rs\".into()), Some(Vec::new()));\n+\n+    let partition = file_set.partition(&vfs).into_iter().map(|it| it.len()).collect::<Vec<_>>();\n+    assert_eq!(partition, vec![2, 1, 1]);\n }"}]}