{"sha": "743384204055fcf20ec8957e056215b4d9fb36f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MzM4NDIwNDA1NWZjZjIwZWM4OTU3ZTA1NjIxNWI0ZDlmYjM2ZjI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-20T13:00:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-21T08:27:01Z"}, "message": "fix a ton of typos", "tree": {"sha": "b7088dbb0dcdbc7452d2b992a94561cadca74ef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7088dbb0dcdbc7452d2b992a94561cadca74ef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/743384204055fcf20ec8957e056215b4d9fb36f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/743384204055fcf20ec8957e056215b4d9fb36f2", "html_url": "https://github.com/rust-lang/rust/commit/743384204055fcf20ec8957e056215b4d9fb36f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/743384204055fcf20ec8957e056215b4d9fb36f2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "068db9fd6d8faa269af39447bd2667fe766afa05", "url": "https://api.github.com/repos/rust-lang/rust/commits/068db9fd6d8faa269af39447bd2667fe766afa05", "html_url": "https://github.com/rust-lang/rust/commit/068db9fd6d8faa269af39447bd2667fe766afa05"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "d5ae2d1e025f0e7bf13b2d62bbd6338b212dc03c", "filename": "guide.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/743384204055fcf20ec8957e056215b4d9fb36f2/guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/743384204055fcf20ec8957e056215b4d9fb36f2/guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/guide.md?ref=743384204055fcf20ec8957e056215b4d9fb36f2", "patch": "@@ -2,7 +2,7 @@\n \n ## About the guide\n \n-This guide describes the current start of the rust-analyzer as of 2019-01-20\n+This guide describes the current state of `rust-analyzer` as of 2019-01-20\n (git tag [guide-2019-01]). Its purpose is to document various problems and\n architectural solutions related to the problem of building IDE-first compiler\n for Rust.\n@@ -11,24 +11,24 @@ for Rust.\n \n ## The big picture\n \n-On the highest possible level, rust analyzer is a stateful component. Client may\n+On the highest possible level, rust analyzer is a stateful component. A client may\n apply changes to the analyzer (new contents of `foo.rs` file is \"fn main() {}\")\n and it may ask semantic questions about the current state (what is the\n definition of the identifier with offset 92 in file `bar.rs`?). Two important\n properties hold:\n \n-* Analyzer does not do any IO. It starts in an empty state and all input data is\n+* Analyzer does not do any I/O. It starts in an empty state and all input data is\n   provided via `apply_change` API.\n \n * Only queries about the current state are supported. One can, of course,\n-  simulate undo and redo by keeping log of changes and inverse-changes.\n+  simulate undo and redo by keeping a log of changes and inverse changes respectively.\n \n ## IDE API\n \n-To see this big picture, let's take a look at the [`AnalysisHost`] and\n+To see the bigger picture of how the IDE features works, let's take a look at the [`AnalysisHost`] and\n [`Analysis`] pair of types. `AnalysisHost` has three methods:\n \n-* `default` for creating an empty analysis\n+* `default()` for creating an empty analysis instance\n * `apply_change(&mut self)` to make changes (this is how you get from an empty\n   state to something interesting)\n * `analysis(&self)` to get an instance of `Analysis`\n@@ -42,28 +42,28 @@ stack, we'll talk about it later.\n [`AnalysisHost`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L265-L284\n [`Analysis`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L291-L478\n \n-The reason for `Analysis` and `AnalysisHost` separation is that we want apply\n-changes \"uniquely\", but we might want to fork an `Analysis` and send it to\n+The reason for this separation of `Analysis` and `AnalysisHost` is that we want to apply\n+changes \"uniquely\", but we might also want to fork an `Analysis` and send it to\n another thread for background processing. That is, there is only a single\n `AnalysisHost`, but there may be several (equivalent) `Analysis`.\n \n Note that all of the `Analysis` API return `Cancelable<T>`. This is required to\n-be responsive in IDE setting. Sometimes a long-running query is being computed\n+be responsive in an IDE setting. Sometimes a long-running query is being computed\n and the user types something in the editor and asks for completion. In this\n case, we cancel the long-running computation (so it returns `Err(Canceled)`),\n apply the change and execute request for completion. We never use stale data to\n answer requests. Under the cover, `AnalysisHost` \"remembers\" all outstanding\n-`Analysis` instances. `AnalysisHost::apply_change` method cancels all\n-`Analysis`es, blocks until of them are `Dropped` and then applies change\n-in-place. This is the familiar to rustaceans read-write lock interior\n+`Analysis` instances. The `AnalysisHost::apply_change` method cancels all\n+`Analysis`es, blocks until all of them are `Dropped` and then applies changes\n+in-place. This may be familiar to Rustaceans who use read-write locks for interior\n mutability.\n \n-Next, lets talk about what are inputs to the Analysis, precisely.\n+Next, let's talk about what the inputs to the `Analysis` are, precisely.\n \n ## Inputs\n \n-Rust Analyzer never does any IO itself, all inputs get passed explicitly via\n-`AnalysisHost::apply_change` method, which accepts a single argument:\n+Rust Analyzer never does any I/O itself, all inputs get passed explicitly via\n+the `AnalysisHost::apply_change` method, which accepts a single argument, a\n `AnalysisChange`. [`AnalysisChange`] is a builder for a single change\n \"transaction\", so it suffices to study its methods to understand all of the\n input data.\n@@ -72,12 +72,12 @@ input data.\n \n The `(add|change|remove)_file` methods control the set of the input files, where\n each file has an integer id (`FileId`, picked by the client), text (`String`)\n-and a filesystem path. Paths are tricky, they'll be explained in source roots\n-section, together with `add_root` method. `add_library` method allows to add a\n+and a filesystem path. Paths are tricky; they'll be explained below, in source roots\n+section, together with the `add_root` method. The `add_library` method allows us to add a\n group of files which are assumed to rarely change. It's mostly an optimization\n-and does not change fundamental picture.\n+and does not change the fundamental picture.\n \n-`set_crate_graph` method allows to control how the input files are partitioned\n+The `set_crate_graph` method allows us to control how the input files are partitioned\n into compilation unites -- crates. It also controls (in theory, not implemented\n yet) `cfg` flags. `CrateGraph` is a directed acyclic graph of crates. Each crate\n has a root `FileId`, a set of active `cfg` flags and a set of dependencies. Each\n@@ -220,21 +220,21 @@ of type V. Queries come in two basic varieties:\n \n * **Functions**: pure functions (no side effects) that transform your inputs\n   into other values. The results of queries is memoized to avoid recomputing\n-  them a lot. When you make changes to the inputs, we'll figure out (fairlywe\n-  intelligently) when we can re-use these memoized values and when we have we\n+  them a lot. When you make changes to the inputs, we'll figure out (fairly\n+  intelligently) when we can re-use these memoized values and when we have to\n   recompute them.\n \n \n For further discussion, its important to understand one bit of \"fairly\n-intelligently\". Suppose we have to functions, `f1` and `f2`, and one input,we\n+intelligently\". Suppose we have two functions, `f1` and `f2`, and one input, `z`.\n We call `f1(X)` which in turn calls `f2(Y)` which inspects `i(Z)`. `i(Z)`\n-returns some value `V1`, `f2` uses that and returns `R1`, `f1` uses that anwe\n-returns `O`. Now, let's change `i` at `Z` to `V2` from `V1` and try to compwe\n-`f1(X)` again. Because `f1(X)` (transitively) depends on `i(Z)`, we can't jwe\n-reuse its value as is. However, if `f2(Y)` is *still* equal to `R1` (despitwe\n-`i`'s change), we, in fact, *can* reuse `O` as result of `f1(X)`. And that'we\n-salsa works: it recomputes results in *reverse* order, starting from inputswe\n-progressing towards outputs, stopping as soon as it sees an intermediate vawe\n+returns some value `V1`, `f2` uses that and returns `R1`, `f1` uses that and\n+returns `O`. Now, let's change `i` at `Z` to `V2` from `V1` and try to compute\n+`f1(X)` again. Because `f1(X)` (transitively) depends on `i(Z)`, we can't just\n+reuse its value as is. However, if `f2(Y)` is *still* equal to `R1` (despite\n+`i`'s change), we, in fact, *can* reuse `O` as result of `f1(X)`. And that's how\n+salsa works: it recomputes results in *reverse* order, starting from inputs and\n+progressing towards outputs, stopping as soon as it sees an intermediate value\n that hasn't changed.\n \n ## Salsa Input Queries\n@@ -312,7 +312,7 @@ of the syntax trees:\n   `Option`s. The tree for `fn foo` will contain a function declaration with\n   `None` for parameter list and body.\n \n-* Syntax trees do not know the file they are build from, they only know about\n+* Syntax trees do not know the file they are built from, they only know about\n   the text.\n \n The implementation is based on the generic [rowan] crate on top of which a\n@@ -335,10 +335,10 @@ declarations and recursively process child modules. This is handled by the\n \n First, rust analyzer builds a module tree for all crates in a source root\n simultaneously. The main reason for this is historical (`module_tree` predates\n-`CrateGraph`), but this approach also allows to account for files which are not\n+`CrateGraph`), but this approach also enables accounting for files which are not\n part of any crate. That is, if you create a file but do not include it as a\n submodule anywhere, you still get semantic completion, and you get a warning\n-about free-floating module (the actual warning is not implemented yet).\n+about a free-floating module (the actual warning is not implemented yet).\n \n The second difference is that `module_tree_query` does not *directly* depend on\n the \"parse\" query (which is confusingly called `source_file`). Why would calling\n@@ -347,14 +347,14 @@ an insignificant whitespace. Adding whitespace changes the parse tree (because\n it includes whitespace), and that means recomputing the whole module tree.\n \n We deal with this problem by introducing an intermediate [`submodules_query`].\n-This query processes the syntax tree an extract a set of declared submodule\n+This query processes the syntax tree and extracts a set of declared submodule\n names. Now, changing the whitespace results in `submodules_query` being\n re-executed for a *single* module, but because the result of this query stays\n the same, we don't have to re-execute [`module_tree_query`]. In fact, we only\n need to re-execute it when we add/remove new files or when we change mod\n declarations.\n \n-[`submodules_query`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L41)\n+[`submodules_query`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L41\n \n We store the resulting modules in a `Vec`-based indexed arena. The indices in\n the arena becomes module ids. And this brings us to the next topic:\n@@ -445,7 +445,7 @@ we modify bodies of the items. After that we [loop] resolving all imports until\n we've reached a fixed point.\n \n [lower]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L113-L117\n-[loop]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L113-L117\n+[loop]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres.rs#L186-L196\n \n And, given all our preparation with ids and position-independent representation,\n it is satisfying to [test] that typing inside function body does not invalidate\n@@ -514,7 +514,7 @@ construct a mapping from `ExprId`s to types.\n [lower ast]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs\n [positional id]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L13-L15\n [a source map]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L41-L44\n-[type-inference]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/ty.rs#L1208-L1223\n+[type inference]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/ty.rs#L1208-L1223\n \n ## Tying it all together: completion\n "}]}