{"sha": "787b70592fc611732c4b27da2c32cf2c4f361832", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4N2I3MDU5MmZjNjExNzMyYzRiMjdkYTJjMzJjZjJjNGYzNjE4MzI=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-14T01:05:01Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-17T15:54:10Z"}, "message": "Turn some comments into doccomments", "tree": {"sha": "9027d70cbc449ef2d51007eb10884cdee418b149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9027d70cbc449ef2d51007eb10884cdee418b149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/787b70592fc611732c4b27da2c32cf2c4f361832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/787b70592fc611732c4b27da2c32cf2c4f361832", "html_url": "https://github.com/rust-lang/rust/commit/787b70592fc611732c4b27da2c32cf2c4f361832", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/787b70592fc611732c4b27da2c32cf2c4f361832/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59778186789a6b5e1a835b3faa52475f6bd319d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/59778186789a6b5e1a835b3faa52475f6bd319d8", "html_url": "https://github.com/rust-lang/rust/commit/59778186789a6b5e1a835b3faa52475f6bd319d8"}], "stats": {"total": 107, "additions": 54, "deletions": 53}, "files": [{"sha": "671856c4e549e34507dc8dbf18d5eaaf83a50e30", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/787b70592fc611732c4b27da2c32cf2c4f361832/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787b70592fc611732c4b27da2c32cf2c4f361832/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=787b70592fc611732c4b27da2c32cf2c4f361832", "patch": "@@ -962,38 +962,38 @@ enum TypeParameters<'a, 'b> {\n                       RibKind<'a>),\n }\n \n-// The rib kind controls the translation of local\n-// definitions (`Def::Local`) to upvars (`Def::Upvar`).\n+/// The rib kind controls the translation of local\n+/// definitions (`Def::Local`) to upvars (`Def::Upvar`).\n #[derive(Copy, Clone, Debug)]\n enum RibKind<'a> {\n-    // No translation needs to be applied.\n+    /// No translation needs to be applied.\n     NormalRibKind,\n \n-    // We passed through a closure scope at the given node ID.\n-    // Translate upvars as appropriate.\n+    /// We passed through a closure scope at the given node ID.\n+    /// Translate upvars as appropriate.\n     ClosureRibKind(NodeId /* func id */),\n \n-    // We passed through an impl or trait and are now in one of its\n-    // methods or associated types. Allow references to ty params that impl or trait\n-    // binds. Disallow any other upvars (including other ty params that are\n-    // upvars).\n+    /// We passed through an impl or trait and are now in one of its\n+    /// methods or associated types. Allow references to ty params that impl or trait\n+    /// binds. Disallow any other upvars (including other ty params that are\n+    /// upvars).\n     TraitOrImplItemRibKind,\n \n-    // We passed through an item scope. Disallow upvars.\n+    /// We passed through an item scope. Disallow upvars.\n     ItemRibKind,\n \n-    // We're in a constant item. Can't refer to dynamic stuff.\n+    /// We're in a constant item. Can't refer to dynamic stuff.\n     ConstantItemRibKind,\n \n-    // We passed through a module.\n+    /// We passed through a module.\n     ModuleRibKind(Module<'a>),\n \n-    // We passed through a `macro_rules!` statement\n+    /// We passed through a `macro_rules!` statement\n     MacroDefinition(DefId),\n \n-    // All bindings in this rib are type parameters that can't be used\n-    // from the default of a type parameter because they're not declared\n-    // before said type parameter. Also see the `visit_generics` override.\n+    /// All bindings in this rib are type parameters that can't be used\n+    /// from the default of a type parameter because they're not declared\n+    /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n }\n \n@@ -1198,7 +1198,7 @@ impl<'a> fmt::Debug for ModuleData<'a> {\n     }\n }\n \n-// Records a possibly-private value, type, or module definition.\n+/// Records a possibly-private value, type, or module definition.\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n@@ -1408,36 +1408,36 @@ pub struct Resolver<'a> {\n \n     prelude: Option<Module<'a>>,\n \n-    // n.b. This is used only for better diagnostics, not name resolution itself.\n+    /// n.b. This is used only for better diagnostics, not name resolution itself.\n     has_self: FxHashSet<DefId>,\n \n-    // Names of fields of an item `DefId` accessible with dot syntax.\n-    // Used for hints during error reporting.\n+    /// Names of fields of an item `DefId` accessible with dot syntax.\n+    /// Used for hints during error reporting.\n     field_names: FxHashMap<DefId, Vec<Name>>,\n \n-    // All imports known to succeed or fail.\n+    /// All imports known to succeed or fail.\n     determined_imports: Vec<&'a ImportDirective<'a>>,\n \n-    // All non-determined imports.\n+    /// All non-determined imports.\n     indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n \n-    // The module that represents the current item scope.\n+    /// The module that represents the current item scope.\n     current_module: Module<'a>,\n \n-    // The current set of local scopes for types and values.\n-    // FIXME #4948: Reuse ribs to avoid allocation.\n+    /// The current set of local scopes for types and values.\n+    /// FIXME #4948: Reuse ribs to avoid allocation.\n     ribs: PerNS<Vec<Rib<'a>>>,\n \n-    // The current set of local scopes, for labels.\n+    /// The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a>>,\n \n-    // The trait that the current context can refer to.\n+    /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n-    // The current self type if inside an impl (used for better errors).\n+    /// The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n \n-    // The idents for the primitive types.\n+    /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n@@ -1446,20 +1446,20 @@ pub struct Resolver<'a> {\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n \n-    // A map from nodes to anonymous modules.\n-    // Anonymous modules are pseudo-modules that are implicitly created around items\n-    // contained within blocks.\n-    //\n-    // For example, if we have this:\n-    //\n-    //  fn f() {\n-    //      fn g() {\n-    //          ...\n-    //      }\n-    //  }\n-    //\n-    // There will be an anonymous module created around `g` with the ID of the\n-    // entry block for `f`.\n+    /// A map from nodes to anonymous modules.\n+    /// Anonymous modules are pseudo-modules that are implicitly created around items\n+    /// contained within blocks.\n+    ///\n+    /// For example, if we have this:\n+    ///\n+    ///  fn f() {\n+    ///      fn g() {\n+    ///          ...\n+    ///      }\n+    ///  }\n+    ///\n+    /// There will be an anonymous module created around `g` with the ID of the\n+    /// entry block for `f`.\n     block_map: NodeMap<Module<'a>>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n     extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n@@ -1487,7 +1487,8 @@ pub struct Resolver<'a> {\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n-    use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n+    /// true if `#![feature(use_extern_macros)]`\n+    use_extern_macros: bool,\n \n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Ident>,\n@@ -1501,29 +1502,29 @@ pub struct Resolver<'a> {\n     pub whitelisted_legacy_custom_derives: Vec<Name>,\n     pub found_unresolved_macro: bool,\n \n-    // List of crate local macros that we need to warn about as being unused.\n-    // Right now this only includes macro_rules! macros, and macros 2.0.\n+    /// List of crate local macros that we need to warn about as being unused.\n+    /// Right now this only includes macro_rules! macros, and macros 2.0.\n     unused_macros: FxHashSet<DefId>,\n \n-    // Maps the `Mark` of an expansion to its containing module or block.\n+    /// Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n \n-    // Avoid duplicated errors for \"name already defined\".\n+    /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n \n-    // If `#![feature(proc_macro)]` is set\n+    /// If `#![feature(proc_macro)]` is set\n     proc_macro_enabled: bool,\n \n-    // A set of procedural macros imported by `#[macro_use]` that have already been warned about\n+    /// A set of procedural macros imported by `#[macro_use]` that have already been warned about\n     warned_proc_macros: FxHashSet<Name>,\n \n     potentially_unused_imports: Vec<&'a ImportDirective<'a>>,\n \n-    // This table maps struct IDs into struct constructor IDs,\n-    // it's not used during normal resolution, only for better error reporting.\n+    /// This table maps struct IDs into struct constructor IDs,\n+    /// it's not used during normal resolution, only for better error reporting.\n     struct_constructors: DefIdMap<(Def, ty::Visibility)>,\n \n-    // Only used for better errors on `fn(): fn()`\n+    /// Only used for better errors on `fn(): fn()`\n     current_type_ascription: Vec<Span>,\n \n     injected_crate: Option<Module<'a>>,"}]}