{"sha": "32d330df30c079c8d0bcdeff9049152a65c36b31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZDMzMGRmMzBjMDc5YzhkMGJjZGVmZjkwNDkxNTJhNjVjMzZiMzE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-08T20:10:06Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-03-15T13:22:34Z"}, "message": "Avoid ICEs when we emit errors constructing the specialization graph", "tree": {"sha": "05b573336499b79797d488397b49a61346e76e27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05b573336499b79797d488397b49a61346e76e27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32d330df30c079c8d0bcdeff9049152a65c36b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32d330df30c079c8d0bcdeff9049152a65c36b31", "html_url": "https://github.com/rust-lang/rust/commit/32d330df30c079c8d0bcdeff9049152a65c36b31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32d330df30c079c8d0bcdeff9049152a65c36b31/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c24b4bf41098edd860d03463e00f2590293196dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c24b4bf41098edd860d03463e00f2590293196dc", "html_url": "https://github.com/rust-lang/rust/commit/c24b4bf41098edd860d03463e00f2590293196dc"}], "stats": {"total": 135, "additions": 79, "deletions": 56}, "files": [{"sha": "1847326a742eb7897b2c83726ad84114da3c91c6", "filename": "src/librustc/traits/specialization_graph.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs?ref=32d330df30c079c8d0bcdeff9049152a65c36b31", "patch": "@@ -4,6 +4,7 @@ use crate::ty::{self, TyCtxt};\n use rustc_ast::ast::Ident;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::ErrorReported;\n use rustc_hir::def_id::{DefId, DefIdMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n@@ -23,17 +24,20 @@ use rustc_hir::def_id::{DefId, DefIdMap};\n ///   has at most one parent.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Graph {\n-    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n-    // of the trait.\n+    /// All impls have a parent; the \"root\" impls have as their parent the `def_id`\n+    /// of the trait.\n     pub parent: DefIdMap<DefId>,\n \n-    // The \"root\" impls are found by looking up the trait's def_id.\n+    /// The \"root\" impls are found by looking up the trait's def_id.\n     pub children: DefIdMap<Children>,\n+\n+    /// Whether an error was emitted while constructing the graph.\n+    pub has_errored: bool,\n }\n \n impl Graph {\n     pub fn new() -> Graph {\n-        Graph { parent: Default::default(), children: Default::default() }\n+        Graph { parent: Default::default(), children: Default::default(), has_errored: false }\n     }\n \n     /// The parent of a given impl, which is the `DefId` of the trait when the\n@@ -179,17 +183,22 @@ impl<'tcx> Ancestors<'tcx> {\n }\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n-/// impl itself.\n+/// impl itself. Returns `None` if an error was reported while building the\n+/// specialization graph.\n pub fn ancestors(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n     start_from_impl: DefId,\n-) -> Ancestors<'tcx> {\n+) -> Result<Ancestors<'tcx>, ErrorReported> {\n     let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n-    Ancestors {\n-        trait_def_id,\n-        specialization_graph,\n-        current_source: Some(Node::Impl(start_from_impl)),\n+    if specialization_graph.has_errored {\n+        Err(ErrorReported)\n+    } else {\n+        Ok(Ancestors {\n+            trait_def_id,\n+            specialization_graph,\n+            current_source: Some(Node::Impl(start_from_impl)),\n+        })\n     }\n }\n "}, {"sha": "948f1b8501d539c00f7bbc3423c6ae65125e2455", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=32d330df30c079c8d0bcdeff9049152a65c36b31", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::ErrorReported;\n use rustc_macros::HashStable;\n \n /// A trait's definition with type information.\n@@ -92,7 +93,7 @@ impl<'tcx> TraitDef {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         of_impl: DefId,\n-    ) -> specialization_graph::Ancestors<'tcx> {\n+    ) -> Result<specialization_graph::Ancestors<'tcx>, ErrorReported> {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n }"}, {"sha": "3f079b286b4740c570313d485a5b44baf23746fb", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=32d330df30c079c8d0bcdeff9049152a65c36b31", "patch": "@@ -1077,12 +1077,13 @@ impl EncodeContext<'tcx> {\n                 let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(self.tcx, def_id).nth(1).and_then(|node| {\n-                        match node {\n-                            specialization_graph::Node::Impl(parent) => Some(parent),\n-                            _ => None,\n-                        }\n-                    })\n+                    trait_def.ancestors(self.tcx, def_id).ok()\n+                        .and_then(|mut an| an.nth(1).and_then(|node| {\n+                            match node {\n+                                specialization_graph::Node::Impl(parent) => Some(parent),\n+                                _ => None,\n+                            }\n+                        }))\n                 } else {\n                     None\n                 };"}, {"sha": "1ad915742127ea93f7b8bb474f493950e4789c80", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=32d330df30c079c8d0bcdeff9049152a65c36b31", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_ast::ast::Ident;\n+use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n@@ -1010,7 +1011,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc::ty::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id);\n+                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n+                        .map_err(|ErrorReported| ())?;\n \n                 let is_default = if node_item.node.is_from_trait() {\n                     // If true, the impl inherited a `type Foo = Bar`\n@@ -1405,7 +1407,10 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let assoc_ty = assoc_ty_def(selcx, impl_def_id, assoc_item_id);\n+    let assoc_ty = match assoc_ty_def(selcx, impl_def_id, assoc_item_id) {\n+        Ok(assoc_ty) => assoc_ty,\n+        Err(ErrorReported) => return Progress { ty: tcx.types.err, obligations: nested },\n+    };\n \n     if !assoc_ty.item.defaultness.has_value() {\n         // This means that the impl is missing a definition for the\n@@ -1444,14 +1449,14 @@ fn assoc_ty_def(\n     selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n     assoc_ty_def_id: DefId,\n-) -> specialization_graph::NodeItem<ty::AssocItem> {\n+) -> Result<specialization_graph::NodeItem<ty::AssocItem>, ErrorReported> {\n     let tcx = selcx.tcx();\n     let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     // This function may be called while we are still building the\n-    // specialization graph that is queried below (via TraidDef::ancestors()),\n+    // specialization graph that is queried below (via TraitDef::ancestors()),\n     // so, in order to avoid unnecessary infinite recursion, we manually look\n     // for the associated item at the given impl.\n     // If there is no such item in that impl, this function will fail with a\n@@ -1461,17 +1466,16 @@ fn assoc_ty_def(\n         if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n-            return specialization_graph::NodeItem {\n+            return Ok(specialization_graph::NodeItem {\n                 node: specialization_graph::Node::Impl(impl_def_id),\n                 item: *item,\n-            };\n+            });\n         }\n     }\n \n-    if let Some(assoc_item) =\n-        trait_def.ancestors(tcx, impl_def_id).leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type)\n-    {\n-        assoc_item\n+    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type) {\n+        Ok(assoc_item)\n     } else {\n         // This is saying that neither the trait nor\n         // the impl contain a definition for this"}, {"sha": "b763851b86ef63cf7f5387fed3fc502df820f580", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=32d330df30c079c8d0bcdeff9049152a65c36b31", "patch": "@@ -130,24 +130,27 @@ pub fn find_associated_item<'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.trait_def(trait_def_id);\n \n-    let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n-    match ancestors.leaf_def(tcx, item.ident, item.kind) {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = param_env.with_reveal_all();\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                let substs = translate_substs(\n-                    &infcx,\n-                    param_env,\n-                    impl_data.impl_def_id,\n-                    substs,\n-                    node_item.node,\n-                );\n-                infcx.tcx.erase_regions(&substs)\n-            });\n-            (node_item.item.def_id, substs)\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_data.impl_def_id) {\n+        match ancestors.leaf_def(tcx, item.ident, item.kind) {\n+            Some(node_item) => {\n+                let substs = tcx.infer_ctxt().enter(|infcx| {\n+                    let param_env = param_env.with_reveal_all();\n+                    let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                    let substs = translate_substs(\n+                        &infcx,\n+                        param_env,\n+                        impl_data.impl_def_id,\n+                        substs,\n+                        node_item.node,\n+                    );\n+                    infcx.tcx.erase_regions(&substs)\n+                });\n+                (node_item.item.def_id, substs)\n+            }\n+            None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id),\n         }\n-        None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id),\n+    } else {\n+        (item.def_id, substs)\n     }\n }\n \n@@ -382,6 +385,7 @@ pub(super) fn specialization_graph_provider(\n \n                 match used_to_be_allowed {\n                     None => {\n+                        sg.has_errored = true;\n                         let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n                         decorate(LintDiagnosticBuilder::new(err));\n                     }"}, {"sha": "9e20dcec1af91674c2dbef7e1665c18fe973d253", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d330df30c079c8d0bcdeff9049152a65c36b31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=32d330df30c079c8d0bcdeff9049152a65c36b31", "patch": "@@ -1901,8 +1901,11 @@ fn check_specialization_validity<'tcx>(\n         hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n     };\n \n-    let mut ancestor_impls = trait_def\n-        .ancestors(tcx, impl_id)\n+    let ancestors = match trait_def.ancestors(tcx, impl_id) {\n+        Ok(ancestors) => ancestors,\n+        Err(_) => return,\n+    };\n+    let mut ancestor_impls = ancestors\n         .skip(1)\n         .filter_map(|parent| {\n             if parent.is_from_trait() {\n@@ -2083,16 +2086,17 @@ fn check_impl_items_against_trait<'tcx>(\n \n     // Check for missing items from trait\n     let mut missing_items = Vec::new();\n-    for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n-        let is_implemented = trait_def\n-            .ancestors(tcx, impl_id)\n-            .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-            .map(|node_item| !node_item.node.is_from_trait())\n-            .unwrap_or(false);\n-\n-        if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n-            if !trait_item.defaultness.has_value() {\n-                missing_items.push(*trait_item);\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) {\n+        for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n+            let is_implemented = ancestors\n+                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .map(|node_item| !node_item.node.is_from_trait())\n+                .unwrap_or(false);\n+\n+            if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n+                if !trait_item.defaultness.has_value() {\n+                    missing_items.push(*trait_item);\n+                }\n             }\n         }\n     }"}]}