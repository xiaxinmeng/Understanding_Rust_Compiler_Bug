{"sha": "a5f4a40f24109f94b4c1e568bf312105f07b1734", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZjRhNDBmMjQxMDlmOTRiNGMxZTU2OGJmMzEyMTA1ZjA3YjE3MzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T00:29:57Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T21:01:30Z"}, "message": "librustc: De-`@mut` the inference context", "tree": {"sha": "6fd813cbc8b7a540b5462d1cdae4931bc6cbb34e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fd813cbc8b7a540b5462d1cdae4931bc6cbb34e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5f4a40f24109f94b4c1e568bf312105f07b1734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5f4a40f24109f94b4c1e568bf312105f07b1734", "html_url": "https://github.com/rust-lang/rust/commit/a5f4a40f24109f94b4c1e568bf312105f07b1734", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5f4a40f24109f94b4c1e568bf312105f07b1734/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2d16e119093d98ab2d8fa1802e7e200475c729", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2d16e119093d98ab2d8fa1802e7e200475c729", "html_url": "https://github.com/rust-lang/rust/commit/ff2d16e119093d98ab2d8fa1802e7e200475c729"}], "stats": {"total": 202, "additions": 99, "deletions": 103}, "files": [{"sha": "b605791128dffe6fbb65f1cb86495d35a3ea58a3", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -1326,7 +1326,7 @@ impl<'a> LookupContext<'a> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&self) -> @mut infer::InferCtxt {\n+    fn infcx(&self) -> @infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n "}, {"sha": "e085a707d5984e7f466b3fe17d0d0c6bcaa45bee", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -157,7 +157,7 @@ pub struct SelfInfo {\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct Inherited {\n-    infcx: @mut infer::InferCtxt,\n+    infcx: @infer::InferCtxt,\n     locals: @mut HashMap<ast::NodeId, ty::t>,\n     param_env: ty::ParameterEnvironment,\n \n@@ -1045,7 +1045,7 @@ impl AstConv for FnCtxt {\n }\n \n impl FnCtxt {\n-    pub fn infcx(&self) -> @mut infer::InferCtxt {\n+    pub fn infcx(&self) -> @infer::InferCtxt {\n         self.inh.infcx\n     }\n \n@@ -1061,7 +1061,7 @@ impl FnCtxt {\n     }\n }\n \n-impl RegionScope for @mut infer::InferCtxt {\n+impl RegionScope for @infer::InferCtxt {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint) -> Result<~[ty::Region], ()> {"}, {"sha": "a773a3a19757124d14654d4420a7872399de9ec4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -70,7 +70,7 @@ pub struct LocationInfo {\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n-    infcx: @mut infer::InferCtxt,\n+    infcx: @infer::InferCtxt,\n     param_env: &'a ty::ParameterEnvironment,\n }\n "}, {"sha": "481d815fe7b3602a66e0f6cfe8bab8fc4c320165", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -55,7 +55,7 @@ pub struct UniversalQuantificationResult {\n     type_param_defs: @~[ty::TypeParameterDef]\n }\n \n-pub fn get_base_type(inference_context: @mut InferCtxt,\n+pub fn get_base_type(inference_context: @InferCtxt,\n                      span: Span,\n                      original_type: t)\n                   -> Option<t> {\n@@ -118,7 +118,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n }\n \n // Returns the def ID of the base type, if there is one.\n-pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n+pub fn get_base_type_def_id(inference_context: @InferCtxt,\n                             span: Span,\n                             original_type: t)\n                          -> Option<DefId> {\n@@ -151,7 +151,7 @@ pub fn CoherenceChecker(crate_context: @CrateCtxt) -> CoherenceChecker {\n \n pub struct CoherenceChecker {\n     crate_context: @CrateCtxt,\n-    inference_context: @mut InferCtxt,\n+    inference_context: @InferCtxt,\n }\n \n struct CoherenceCheckVisitor { cc: CoherenceChecker }"}, {"sha": "c35852d37c97e1a8c2ee3d3fb50f0778ee2abd33", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -67,7 +67,7 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n \n pub trait Combine {\n-    fn infcx(&self) -> @mut InferCtxt;\n+    fn infcx(&self) -> @InferCtxt;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n@@ -328,7 +328,7 @@ pub trait Combine {\n }\n \n pub struct CombineFields {\n-    infcx: @mut InferCtxt,\n+    infcx: @InferCtxt,\n     a_is_expected: bool,\n     trace: TypeTrace,\n }"}, {"sha": "1744c1176156cea557da23f6d9e9a17007b99ce3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -77,33 +77,33 @@ use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n-    fn report_region_errors(@mut self,\n+    fn report_region_errors(@self,\n                             errors: &OptVec<RegionResolutionError>);\n \n-    fn report_and_explain_type_error(@mut self,\n+    fn report_and_explain_type_error(@self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err);\n \n-    fn values_str(@mut self, values: &ValuePairs) -> Option<~str>;\n+    fn values_str(@self, values: &ValuePairs) -> Option<~str>;\n \n     fn expected_found_str<T:UserString+Resolvable>(\n-        @mut self,\n+        @self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<~str>;\n \n-    fn report_concrete_failure(@mut self,\n+    fn report_concrete_failure(@self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n                                sup: Region);\n \n-    fn report_sub_sup_conflict(@mut self,\n+    fn report_sub_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n                                sub_region: Region,\n                                sup_origin: SubregionOrigin,\n                                sup_region: Region);\n \n-    fn report_sup_sup_conflict(@mut self,\n+    fn report_sup_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                origin1: SubregionOrigin,\n                                region1: Region,\n@@ -112,15 +112,15 @@ pub trait ErrorReporting {\n }\n \n trait ErrorReportingHelpers {\n-    fn report_inference_failure(@mut self,\n+    fn report_inference_failure(@self,\n                                 var_origin: RegionVariableOrigin);\n \n-    fn note_region_origin(@mut self,\n+    fn note_region_origin(@self,\n                           origin: SubregionOrigin);\n }\n \n impl ErrorReporting for InferCtxt {\n-    fn report_region_errors(@mut self,\n+    fn report_region_errors(@self,\n                             errors: &OptVec<RegionResolutionError>) {\n         for error in errors.iter() {\n             match *error {\n@@ -147,7 +147,7 @@ impl ErrorReporting for InferCtxt {\n         }\n     }\n \n-    fn report_and_explain_type_error(@mut self,\n+    fn report_and_explain_type_error(@self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err) {\n         let tcx = self.tcx;\n@@ -179,7 +179,7 @@ impl ErrorReporting for InferCtxt {\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(@mut self, values: &ValuePairs) -> Option<~str> {\n+    fn values_str(@self, values: &ValuePairs) -> Option<~str> {\n         /*!\n          * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n@@ -195,7 +195,7 @@ impl ErrorReporting for InferCtxt {\n     }\n \n     fn expected_found_str<T:UserString+Resolvable>(\n-        @mut self,\n+        @self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<~str>\n     {\n@@ -214,7 +214,7 @@ impl ErrorReporting for InferCtxt {\n                   found.user_string(self.tcx)))\n     }\n \n-    fn report_concrete_failure(@mut self,\n+    fn report_concrete_failure(@self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n                                sup: Region) {\n@@ -400,7 +400,7 @@ impl ErrorReporting for InferCtxt {\n         }\n     }\n \n-    fn report_sub_sup_conflict(@mut self,\n+    fn report_sub_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n                                sub_region: Region,\n@@ -425,7 +425,7 @@ impl ErrorReporting for InferCtxt {\n         self.note_region_origin(sub_origin);\n     }\n \n-    fn report_sup_sup_conflict(@mut self,\n+    fn report_sup_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                origin1: SubregionOrigin,\n                                region1: Region,\n@@ -452,7 +452,7 @@ impl ErrorReporting for InferCtxt {\n }\n \n impl ErrorReportingHelpers for InferCtxt {\n-    fn report_inference_failure(@mut self,\n+    fn report_inference_failure(@self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n             infer::MiscVariable(_) => ~\"\",\n@@ -484,8 +484,7 @@ impl ErrorReportingHelpers for InferCtxt {\n                     var_description));\n     }\n \n-    fn note_region_origin(@mut self,\n-                          origin: SubregionOrigin) {\n+    fn note_region_origin(@self, origin: SubregionOrigin) {\n         match origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n@@ -612,12 +611,12 @@ impl ErrorReportingHelpers for InferCtxt {\n }\n \n trait Resolvable {\n-    fn resolve(&self, infcx: @mut InferCtxt) -> Self;\n+    fn resolve(&self, infcx: @InferCtxt) -> Self;\n     fn contains_error(&self) -> bool;\n }\n \n impl Resolvable for ty::t {\n-    fn resolve(&self, infcx: @mut InferCtxt) -> ty::t {\n+    fn resolve(&self, infcx: @InferCtxt) -> ty::t {\n         infcx.resolve_type_vars_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {\n@@ -626,7 +625,7 @@ impl Resolvable for ty::t {\n }\n \n impl Resolvable for @ty::TraitRef {\n-    fn resolve(&self, infcx: @mut InferCtxt) -> @ty::TraitRef {\n+    fn resolve(&self, infcx: @InferCtxt) -> @ty::TraitRef {\n         @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {"}, {"sha": "a9aaa5df2ca99c446eb6b11b90fcea0be9574999", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -30,7 +30,7 @@ use util::ppaux::mt_to_str;\n pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n impl Combine for Glb {\n-    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.trace }"}, {"sha": "5af8c5571957d1a35d6d28527fdd7652cf6913e6", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -36,7 +36,7 @@ impl Lub {\n }\n \n impl Combine for Lub {\n-    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.trace }"}, {"sha": "8a95f9d1bff3fdd72f6a0686e44f44317b2ed669", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -258,8 +258,8 @@ fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     }\n }\n \n-pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n-    @mut InferCtxt {\n+pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n+    @InferCtxt {\n         tcx: tcx,\n \n         ty_var_bindings: RefCell::new(new_ValsAndBindings()),\n@@ -275,7 +275,7 @@ pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n     }\n }\n \n-pub fn common_supertype(cx: @mut InferCtxt,\n+pub fn common_supertype(cx: @InferCtxt,\n                         origin: TypeOrigin,\n                         a_is_expected: bool,\n                         a: ty::t,\n@@ -303,7 +303,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n     }\n }\n \n-pub fn mk_subty(cx: @mut InferCtxt,\n+pub fn mk_subty(cx: @InferCtxt,\n                 a_is_expected: bool,\n                 origin: TypeOrigin,\n                 a: ty::t,\n@@ -321,7 +321,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n     }).to_ures()\n }\n \n-pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     indent(|| {\n         cx.probe(|| {\n@@ -334,7 +334,7 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     }).to_ures()\n }\n \n-pub fn mk_subr(cx: @mut InferCtxt,\n+pub fn mk_subr(cx: @InferCtxt,\n                _a_is_expected: bool,\n                origin: SubregionOrigin,\n                a: ty::Region,\n@@ -345,7 +345,7 @@ pub fn mk_subr(cx: @mut InferCtxt,\n     cx.region_vars.commit();\n }\n \n-pub fn mk_eqty(cx: @mut InferCtxt,\n+pub fn mk_eqty(cx: @InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n                a: ty::t,\n@@ -364,7 +364,7 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n     }).to_ures()\n }\n \n-pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n+pub fn mk_sub_trait_refs(cx: @InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n                          a: @ty::TraitRef,\n@@ -395,7 +395,7 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-pub fn mk_coercety(cx: @mut InferCtxt,\n+pub fn mk_coercety(cx: @InferCtxt,\n                    a_is_expected: bool,\n                    origin: TypeOrigin,\n                    a: ty::t,\n@@ -413,7 +413,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n     })\n }\n \n-pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     indent(|| {\n         cx.probe(|| {\n@@ -427,15 +427,15 @@ pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n // See comment on the type `resolve_state` below\n-pub fn resolve_type(cx: @mut InferCtxt,\n+pub fn resolve_type(cx: @InferCtxt,\n                     a: ty::t,\n                     modes: uint)\n                  -> fres<ty::t> {\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_type_chk(a)\n }\n \n-pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n+pub fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n                    -> fres<ty::Region> {\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_region_chk(r)\n@@ -502,28 +502,26 @@ struct Snapshot {\n }\n \n impl InferCtxt {\n-    pub fn combine_fields(@mut self,\n-                          a_is_expected: bool,\n-                          trace: TypeTrace)\n+    pub fn combine_fields(@self, a_is_expected: bool, trace: TypeTrace)\n                           -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn sub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n+    pub fn sub(@self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n+    pub fn lub(@self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    pub fn start_snapshot(&mut self) -> Snapshot {\n+    pub fn start_snapshot(&self) -> Snapshot {\n         let ty_var_bindings = self.ty_var_bindings.borrow();\n         let int_var_bindings = self.int_var_bindings.borrow();\n         let float_var_bindings = self.float_var_bindings.borrow();\n@@ -535,7 +533,7 @@ impl InferCtxt {\n         }\n     }\n \n-    pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n+    pub fn rollback_to(&self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n         let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n         let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n@@ -549,7 +547,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn commit<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -566,7 +564,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    pub fn try<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -581,7 +579,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         indent(|| {\n             let snapshot = self.start_snapshot();\n@@ -603,7 +601,7 @@ fn next_simple_var<V:Clone,T:Clone>(counter: &mut uint,\n }\n \n impl InferCtxt {\n-    pub fn next_ty_var_id(&mut self) -> TyVid {\n+    pub fn next_ty_var_id(&self) -> TyVid {\n         let id = self.ty_var_counter.get();\n         self.ty_var_counter.set(id + 1);\n         {\n@@ -614,15 +612,15 @@ impl InferCtxt {\n         return TyVid(id);\n     }\n \n-    pub fn next_ty_var(&mut self) -> ty::t {\n+    pub fn next_ty_var(&self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    pub fn next_ty_vars(&mut self, n: uint) -> ~[ty::t] {\n+    pub fn next_ty_vars(&self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    pub fn next_int_var_id(&mut self) -> IntVid {\n+    pub fn next_int_var_id(&self) -> IntVid {\n         let mut int_var_counter = self.int_var_counter.get();\n         let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n         let result = IntVid(next_simple_var(&mut int_var_counter,\n@@ -631,11 +629,11 @@ impl InferCtxt {\n         result\n     }\n \n-    pub fn next_int_var(&mut self) -> ty::t {\n+    pub fn next_int_var(&self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    pub fn next_float_var_id(&mut self) -> FloatVid {\n+    pub fn next_float_var_id(&self) -> FloatVid {\n         let mut float_var_counter = self.float_var_counter.get();\n         let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n         let result = FloatVid(next_simple_var(&mut float_var_counter,\n@@ -644,53 +642,53 @@ impl InferCtxt {\n         result\n     }\n \n-    pub fn next_float_var(&mut self) -> ty::t {\n+    pub fn next_float_var(&self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    pub fn next_region_var(&mut self, origin: RegionVariableOrigin) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n-    pub fn next_region_vars(&mut self,\n+    pub fn next_region_vars(&self,\n                             origin: RegionVariableOrigin,\n                             count: uint)\n                             -> ~[ty::Region] {\n         vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n \n-    pub fn fresh_bound_region(&mut self, binder_id: ast::NodeId) -> ty::Region {\n+    pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n         self.region_vars.new_bound(binder_id)\n     }\n \n-    pub fn resolve_regions(@mut self) {\n+    pub fn resolve_regions(@self) {\n         let errors = self.region_vars.resolve_regions();\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(@self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_str(@mut self, ts: &[ty::t]) -> ~str {\n+    pub fn tys_to_str(@self, ts: &[ty::t]) -> ~str {\n         let tstrs = ts.map(|t| self.ty_to_str(*t));\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n+    pub fn trait_ref_to_str(@self, t: &ty::TraitRef) -> ~str {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)\n     }\n \n-    pub fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type_vars_if_possible(@self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n-    pub fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n+    pub fn resolve_type_vars_in_trait_ref_if_possible(@self,\n                                                       trait_ref:\n                                                       &ty::TraitRef)\n                                                       -> ty::TraitRef {\n@@ -730,15 +728,15 @@ impl InferCtxt {\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str(@mut self,\n+    pub fn type_error_message_str(@self,\n                                   sp: Span,\n                                   mk_msg: |Option<~str>, ~str| -> ~str,\n                                   actual_ty: ~str,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n-    pub fn type_error_message_str_with_expected(@mut self,\n+    pub fn type_error_message_str_with_expected(@self,\n                                                 sp: Span,\n                                                 mk_msg: |Option<~str>,\n                                                          ~str|\n@@ -769,7 +767,7 @@ impl InferCtxt {\n         }\n     }\n \n-    pub fn type_error_message(@mut self,\n+    pub fn type_error_message(@self,\n                               sp: Span,\n                               mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n@@ -784,7 +782,7 @@ impl InferCtxt {\n         self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_str(actual_ty), err);\n     }\n \n-    pub fn report_mismatched_types(@mut self,\n+    pub fn report_mismatched_types(@self,\n                                    sp: Span,\n                                    e: ty::t,\n                                    a: ty::t,\n@@ -805,7 +803,7 @@ impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    pub fn replace_bound_regions_with_fresh_regions(&mut self,\n+    pub fn replace_bound_regions_with_fresh_regions(&self,\n                                                     trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n                                                     -> (ty::FnSig,"}, {"sha": "93ac3d8c2544534b412ee674770b5aea3d926bfa", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -80,14 +80,14 @@ pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n pub struct ResolveState {\n-    infcx: @mut InferCtxt,\n+    infcx: @InferCtxt,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: ~[TyVid],\n     type_depth: uint\n }\n \n-pub fn resolver(infcx: @mut InferCtxt, modes: uint) -> ResolveState {\n+pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,"}, {"sha": "68fa625f08c40937c9b1b8a4234ffb1952789af6", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{Onceness, purity};\n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n impl Combine for Sub {\n-    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.trace }"}, {"sha": "1ec9b49ba4b32d94e89a58dafbf09769e9d3aa84", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -37,25 +37,24 @@ pub struct Node<V, T> {\n }\n \n pub trait UnifyVid<T> {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-                                      -> &'v mut RefCell<ValsAndBindings<Self,\n-                                                                         T>>;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+                                     -> &'v RefCell<ValsAndBindings<Self, T>>;\n }\n \n pub trait UnifyInferCtxtMethods {\n     fn get<T:Clone,\n            V:Clone + Eq + Vid + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V)\n            -> Node<V, T>;\n     fn set<T:Clone + InferStr,\n            V:Clone + Vid + ToStr + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V,\n            new_v: VarValue<V, T>);\n     fn unify<T:Clone + InferStr,\n              V:Clone + Vid + ToStr + UnifyVid<T>>(\n-             &mut self,\n+             &self,\n              node_a: &Node<V, T>,\n              node_b: &Node<V, T>)\n              -> (V, uint);\n@@ -64,7 +63,7 @@ pub trait UnifyInferCtxtMethods {\n impl UnifyInferCtxtMethods for InferCtxt {\n     fn get<T:Clone,\n            V:Clone + Eq + Vid + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V)\n            -> Node<V, T> {\n         /*!\n@@ -111,7 +110,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n \n     fn set<T:Clone + InferStr,\n            V:Clone + Vid + ToStr + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V,\n            new_v: VarValue<V, T>) {\n         /*!\n@@ -131,7 +130,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n \n     fn unify<T:Clone + InferStr,\n              V:Clone + Vid + ToStr + UnifyVid<T>>(\n-             &mut self,\n+             &self,\n              node_a: &Node<V, T>,\n              node_b: &Node<V, T>)\n              -> (V, uint) {\n@@ -186,14 +185,14 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n pub trait InferCtxtMethods {\n     fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                   &mut self,\n+                   &self,\n                    a_is_expected: bool,\n                    a_id: V,\n                    b_id: V)\n                    -> ures;\n     fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n                     V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                    &mut self,\n+                    &self,\n                     a_is_expected: bool,\n                     a_id: V,\n                     b: T)\n@@ -203,7 +202,7 @@ pub trait InferCtxtMethods {\n impl InferCtxtMethods for InferCtxt {\n     fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                   &mut self,\n+                   &self,\n                    a_is_expected: bool,\n                    a_id: V,\n                    b_id: V)\n@@ -243,7 +242,7 @@ impl InferCtxtMethods for InferCtxt {\n \n     fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n                     V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                    &mut self,\n+                    &self,\n                     a_is_expected: bool,\n                     a_id: V,\n                     b: T)\n@@ -278,16 +277,16 @@ impl InferCtxtMethods for InferCtxt {\n // ______________________________________________________________________\n \n impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-        -> &'v mut RefCell<ValsAndBindings<ty::TyVid, Bounds<ty::t>>> {\n-        return &mut infcx.ty_var_bindings;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<ValsAndBindings<ty::TyVid, Bounds<ty::t>>> {\n+        return &infcx.ty_var_bindings;\n     }\n }\n \n impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-        -> &'v mut RefCell<ValsAndBindings<ty::IntVid, Option<IntVarValue>>> {\n-        return &mut infcx.int_var_bindings;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<ValsAndBindings<ty::IntVid, Option<IntVarValue>>> {\n+        return &infcx.int_var_bindings;\n     }\n }\n \n@@ -298,10 +297,10 @@ impl SimplyUnifiable for IntVarValue {\n }\n \n impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-        -> &'v mut RefCell<ValsAndBindings<ty::FloatVid,\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<ValsAndBindings<ty::FloatVid,\n                                            Option<ast::float_ty>>> {\n-        return &mut infcx.float_var_bindings;\n+        return &infcx.float_var_bindings;\n     }\n }\n "}, {"sha": "8a22c64a584c0f2d24d1e9283ec4faafd38e9cd1", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f4a40f24109f94b4c1e568bf312105f07b1734/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a5f4a40f24109f94b4c1e568bf312105f07b1734", "patch": "@@ -287,7 +287,7 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n }\n \n pub fn require_same_types(tcx: ty::ctxt,\n-                          maybe_infcx: Option<@mut infer::InferCtxt>,\n+                          maybe_infcx: Option<@infer::InferCtxt>,\n                           t1_is_expected: bool,\n                           span: Span,\n                           t1: ty::t,"}]}