{"sha": "a4f022e1099c712fdcc8555fd10caccb1a631877", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZjAyMmUxMDk5YzcxMmZkY2M4NTU1ZmQxMGNhY2NiMWE2MzE4Nzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-14T08:46:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-14T08:46:55Z"}, "message": "Auto merge of #78259 - plaflamme:fix-49660, r=KodrAus\n\nFix #49660 - Adds checks to ensure existence of arithmetic trait implementations\n\nThe first 2 commits fix an issue with the existing `wrapping.rs` tests. It wasn't referred to from the module, so the file was being ignored. This is fixed in https://github.com/rust-lang/rust/pull/78259/commits/872dc60ed203d16d43140c1d1623474cf8a9aedc This surfaced a bug in its macro which is fixed in https://github.com/rust-lang/rust/pull/78259/commits/8ddad18283e304753e09ef651209b4a6b54148b0\n\nLastly, commit https://github.com/rust-lang/rust/pull/78259/commits/64d695b753bfe09797b5f95c7b9b72948da01710 is the actual tests for fixing #49660\n\nThe following checks are done:\n\n* `Add`, `Sub`, `Mul`, `Div`, `Rem`\n  * `T op T`, `T op &T`, `&T op T` and `&T op &T`\n  * for all integer and floating point types\n* `AddAssign`, `SubAssign`, `MulAssign`, `DivAssign`, `RemAssign`\n  * `&mut T op T` and `&mut T op &T`\n  * for all integer and floating point types\n* `Neg`\n  * `op T` and `op &T`\n  * for all signed integer and floating point types\n* `Not`\n  * `op T` and `op &T`\n  * for `bool`\n* `BitAnd`, `BitOr`, `BitXor`\n  * `T op T`, `T op &T`, `&T op T` and `&T op &T`\n  * for all integer types and bool\n* `BitAndAssign`, `BitOrAssign`, `BitXorAssign`\n  * `&mut T op T` and `&mut T op &T`\n  * for all integer types and bool\n* `Shl`, `Shr`\n  * `L op R`, `L op &R`, `&L op R` and `&L op &R`\n  * for all pairs of integer types\n* `ShlAssign`, `ShrAssign`\n  * `&mut L op R`, `&mut L op &R`\n  * for all pairs of integer types\n\nNOTE: I'd like some feedback on improving the macros. I'm not familiar with the idioms and patterns there and composing them has been a challenge for me.\n\n[EDIT]: updated links to commits after rebase.", "tree": {"sha": "15aa94ce8e608f5d98f7eea7bf570bfe33c6120b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15aa94ce8e608f5d98f7eea7bf570bfe33c6120b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4f022e1099c712fdcc8555fd10caccb1a631877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f022e1099c712fdcc8555fd10caccb1a631877", "html_url": "https://github.com/rust-lang/rust/commit/a4f022e1099c712fdcc8555fd10caccb1a631877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4f022e1099c712fdcc8555fd10caccb1a631877/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7b0ddbffebee1cb06f184e815ca637706c53053", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7b0ddbffebee1cb06f184e815ca637706c53053", "html_url": "https://github.com/rust-lang/rust/commit/c7b0ddbffebee1cb06f184e815ca637706c53053"}, {"sha": "64d695b753bfe09797b5f95c7b9b72948da01710", "url": "https://api.github.com/repos/rust-lang/rust/commits/64d695b753bfe09797b5f95c7b9b72948da01710", "html_url": "https://github.com/rust-lang/rust/commit/64d695b753bfe09797b5f95c7b9b72948da01710"}], "stats": {"total": 275, "additions": 261, "deletions": 14}, "files": [{"sha": "e66a73ac1289b22201cbc7ee0ef1a4906f15c571", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4f022e1099c712fdcc8555fd10caccb1a631877/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f022e1099c712fdcc8555fd10caccb1a631877/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=a4f022e1099c712fdcc8555fd10caccb1a631877", "patch": "@@ -29,6 +29,8 @@ mod u8;\n mod bignum;\n mod dec2flt;\n mod flt2dec;\n+mod ops;\n+mod wrapping;\n \n mod nan;\n "}, {"sha": "9979cc8fde4341d3579cdc600a3412c6ac3b7246", "filename": "library/core/tests/num/ops.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/a4f022e1099c712fdcc8555fd10caccb1a631877/library%2Fcore%2Ftests%2Fnum%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f022e1099c712fdcc8555fd10caccb1a631877/library%2Fcore%2Ftests%2Fnum%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fops.rs?ref=a4f022e1099c712fdcc8555fd10caccb1a631877", "patch": "@@ -0,0 +1,244 @@\n+use core::ops::*;\n+\n+// For types L and R, checks that a trait implementation exists for\n+//   * binary ops: L op R, L op &R, &L op R and &L op &R\n+//   * assign ops: &mut L op R, &mut L op &R\n+macro_rules! impl_defined {\n+    ($op:ident, $method:ident($lhs:literal, $rhs:literal), $result:literal, $lt:ty, $rt:ty) => {\n+        let lhs = $lhs as $lt;\n+        let rhs = $rhs as $rt;\n+        assert_eq!($result as $lt, $op::$method(lhs, rhs));\n+        assert_eq!($result as $lt, $op::$method(lhs, &rhs));\n+        assert_eq!($result as $lt, $op::$method(&lhs, rhs));\n+        assert_eq!($result as $lt, $op::$method(&lhs, &rhs));\n+    };\n+    ($op:ident, $method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $lt:ty, $rt:ty) => {\n+        let rhs = $rhs as $rt;\n+        let mut lhs = $lhs as $lt;\n+        $op::$method(&mut lhs, rhs);\n+        assert_eq!($result as $lt, lhs);\n+\n+        let mut lhs = $lhs as $lt;\n+        $op::$method(&mut lhs, &rhs);\n+        assert_eq!($result as $lt, lhs);\n+    };\n+}\n+\n+// For all specified types T, checks that a trait implementation exists for\n+//   * binary ops: T op T, T op &T, &T op T and &T op &T\n+//   * assign ops: &mut T op T, &mut T op &T\n+//   * unary ops: op T and op &T\n+macro_rules! impls_defined {\n+    ($op:ident, $method:ident($lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {$(\n+        impl_defined!($op, $method($lhs, $rhs), $result, $t, $t);\n+    )+};\n+    ($op:ident, $method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {$(\n+        impl_defined!($op, $method(&mut $lhs, $rhs), $result, $t, $t);\n+    )+};\n+    ($op:ident, $method:ident($operand:literal), $result:literal, $($t:ty),+) => {$(\n+        let operand = $operand as $t;\n+        assert_eq!($result as $t, $op::$method(operand));\n+        assert_eq!($result as $t, $op::$method(&operand));\n+    )+};\n+}\n+\n+macro_rules! test_op {\n+    ($fn_name:ident, $op:ident::$method:ident($lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!($op, $method($lhs, $rhs), $result, $($t),+);\n+        }\n+    };\n+    ($fn_name:ident, $op:ident::$method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!($op, $method(&mut $lhs, $rhs), $result, $($t),+);\n+        }\n+    };\n+    ($fn_name:ident, $op:ident::$method:ident($lhs:literal), $result:literal, $($t:ty),+) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!($op, $method($lhs), $result, $($t),+);\n+        }\n+    };\n+}\n+\n+test_op!(test_neg_defined, Neg::neg(0), 0, i8, i16, i32, i64, f32, f64);\n+#[cfg(not(target_os = \"emscripten\"))]\n+test_op!(test_neg_defined_128, Neg::neg(0), 0, i128);\n+\n+test_op!(test_not_defined_bool, Not::not(true), false, bool);\n+\n+macro_rules! test_arith_op {\n+    ($fn_name:ident, $op:ident::$method:ident($lhs:literal, $rhs:literal)) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!(\n+                $op,\n+                $method($lhs, $rhs),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize,\n+                f32,\n+                f64\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method($lhs, $rhs), 0, i128, u128);\n+        }\n+    };\n+    ($fn_name:ident, $op:ident::$method:ident(&mut $lhs:literal, $rhs:literal)) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!(\n+                $op,\n+                $method(&mut $lhs, $rhs),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize,\n+                f32,\n+                f64\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method(&mut $lhs, $rhs), 0, i128, u128);\n+        }\n+    };\n+}\n+\n+test_arith_op!(test_add_defined, Add::add(0, 0));\n+test_arith_op!(test_add_assign_defined, AddAssign::add_assign(&mut 0, 0));\n+test_arith_op!(test_sub_defined, Sub::sub(0, 0));\n+test_arith_op!(test_sub_assign_defined, SubAssign::sub_assign(&mut 0, 0));\n+test_arith_op!(test_mul_defined, Mul::mul(0, 0));\n+test_arith_op!(test_mul_assign_defined, MulAssign::mul_assign(&mut 0, 0));\n+test_arith_op!(test_div_defined, Div::div(0, 1));\n+test_arith_op!(test_div_assign_defined, DivAssign::div_assign(&mut 0, 1));\n+test_arith_op!(test_rem_defined, Rem::rem(0, 1));\n+test_arith_op!(test_rem_assign_defined, RemAssign::rem_assign(&mut 0, 1));\n+\n+macro_rules! test_bitop {\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            impls_defined!(\n+                $op,\n+                $method(0, 0),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method(0, 0), 0, i128, u128);\n+            impls_defined!($op, $method(false, false), false, bool);\n+        }\n+    };\n+}\n+macro_rules! test_bitop_assign {\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            impls_defined!(\n+                $op,\n+                $method(&mut 0, 0),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method(&mut 0, 0), 0, i128, u128);\n+            impls_defined!($op, $method(&mut false, false), false, bool);\n+        }\n+    };\n+}\n+\n+test_bitop!(test_bitand_defined, BitAnd::bitand);\n+test_bitop_assign!(test_bitand_assign_defined, BitAndAssign::bitand_assign);\n+test_bitop!(test_bitor_defined, BitOr::bitor);\n+test_bitop_assign!(test_bitor_assign_defined, BitOrAssign::bitor_assign);\n+test_bitop!(test_bitxor_defined, BitXor::bitxor);\n+test_bitop_assign!(test_bitxor_assign_defined, BitXorAssign::bitxor_assign);\n+\n+macro_rules! test_shift_inner {\n+    ($op:ident::$method:ident, $lt:ty, $($rt:ty),+) => {\n+        $(impl_defined!($op, $method(0,0), 0, $lt, $rt);)+\n+    };\n+    ($op:ident::$method:ident, $lt:ty) => {\n+        test_shift_inner!($op::$method, $lt, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+        #[cfg(not(target_os = \"emscripten\"))]\n+        test_shift_inner!($op::$method, $lt, i128, u128);\n+    };\n+}\n+\n+macro_rules! test_shift {\n+    ($op:ident::$method:ident, $($lt:ty),+) => {\n+        $(test_shift_inner!($op::$method, $lt);)+\n+    };\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            test_shift!($op::$method, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            test_shift!($op::$method, i128, u128);\n+        }\n+    };\n+}\n+\n+macro_rules! test_shift_assign_inner {\n+    ($op:ident::$method:ident, $lt:ty, $($rt:ty),+) => {\n+        $(impl_defined!($op, $method(&mut 0,0), 0, $lt, $rt);)+\n+    };\n+    ($op:ident::$method:ident, $lt:ty) => {\n+        test_shift_assign_inner!($op::$method, $lt, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+        #[cfg(not(target_os = \"emscripten\"))]\n+        test_shift_assign_inner!($op::$method, $lt, i128, u128);\n+    };\n+}\n+\n+macro_rules! test_shift_assign {\n+    ($op:ident::$method:ident, $($lt:ty),+) => {\n+        $(test_shift_assign_inner!($op::$method, $lt);)+\n+    };\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            test_shift_assign!($op::$method, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            test_shift_assign!($op::$method, i128, u128);\n+        }\n+    };\n+}\n+test_shift!(test_shl_defined, Shl::shl);\n+test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n+test_shift!(test_shr_defined, Shr::shr);\n+test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);"}, {"sha": "c4fb321ef26cff9d4e5146fe8e1c380800f9827f", "filename": "library/core/tests/num/wrapping.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a4f022e1099c712fdcc8555fd10caccb1a631877/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f022e1099c712fdcc8555fd10caccb1a631877/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs?ref=a4f022e1099c712fdcc8555fd10caccb1a631877", "patch": "@@ -26,9 +26,9 @@ macro_rules! wrapping_assignment {\n }\n \n macro_rules! wrapping_test {\n-    ($type:ty, $min:expr, $max:expr) => {\n+    ($fn_name:ident, $type:ty, $min:expr, $max:expr) => {\n         #[test]\n-        fn wrapping_$type() {\n+        fn $fn_name() {\n             let zero: Wrapping<$type> = Wrapping(0);\n             let one: Wrapping<$type> = Wrapping(1);\n             let min: Wrapping<$type> = Wrapping($min);\n@@ -60,23 +60,24 @@ macro_rules! wrapping_test {\n     };\n }\n \n-wrapping_test!(i8, i8::MIN, i8::MAX);\n-wrapping_test!(i16, i16::MIN, i16::MAX);\n-wrapping_test!(i32, i32::MIN, i32::MAX);\n-wrapping_test!(i64, i64::MIN, i64::MAX);\n+wrapping_test!(test_wrapping_i8, i8, i8::MIN, i8::MAX);\n+wrapping_test!(test_wrapping_i16, i16, i16::MIN, i16::MAX);\n+wrapping_test!(test_wrapping_i32, i32, i32::MIN, i32::MAX);\n+wrapping_test!(test_wrapping_i64, i64, i64::MIN, i64::MAX);\n #[cfg(not(target_os = \"emscripten\"))]\n-wrapping_test!(i128, i128::MIN, i128::MAX);\n-wrapping_test!(isize, isize::MIN, isize::MAX);\n-wrapping_test!(u8, u8::MIN, u8::MAX);\n-wrapping_test!(u16, u16::MIN, u16::MAX);\n-wrapping_test!(u32, u32::MIN, u32::MAX);\n-wrapping_test!(u64, u64::MIN, u64::MAX);\n+wrapping_test!(test_wrapping_i128, i128, i128::MIN, i128::MAX);\n+wrapping_test!(test_wrapping_isize, isize, isize::MIN, isize::MAX);\n+wrapping_test!(test_wrapping_u8, u8, u8::MIN, u8::MAX);\n+wrapping_test!(test_wrapping_u16, u16, u16::MIN, u16::MAX);\n+wrapping_test!(test_wrapping_u32, u32, u32::MIN, u32::MAX);\n+wrapping_test!(test_wrapping_u64, u64, u64::MIN, u64::MAX);\n #[cfg(not(target_os = \"emscripten\"))]\n-wrapping_test!(u128, u128::MIN, u128::MAX);\n-wrapping_test!(usize, usize::MIN, usize::MAX);\n+wrapping_test!(test_wrapping_u128, u128, u128::MIN, u128::MAX);\n+wrapping_test!(test_wrapping_usize, usize, usize::MIN, usize::MAX);\n \n // Don't warn about overflowing ops on 32-bit platforms\n #[cfg_attr(target_pointer_width = \"32\", allow(const_err))]\n+#[test]\n fn wrapping_int_api() {\n     assert_eq!(i8::MAX.wrapping_add(1), i8::MIN);\n     assert_eq!(i16::MAX.wrapping_add(1), i16::MIN);"}]}