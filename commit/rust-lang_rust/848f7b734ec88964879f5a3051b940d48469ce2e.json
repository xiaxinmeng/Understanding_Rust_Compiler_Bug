{"sha": "848f7b734ec88964879f5a3051b940d48469ce2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0OGY3YjczNGVjODg5NjQ4NzlmNWEzMDUxYjk0MGQ0ODQ2OWNlMmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-16T08:08:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-18T20:51:29Z"}, "message": "rustdoc: Implement cross-crate searching\n\nA major discoverability issue with rustdoc is that all crates have their\ndocumentation built in isolation, so it's difficult when looking at the\ndocumentation for libstd to learn that there's a libcollections crate with a\nHashMap in it.\n\nThis commit moves rustdoc a little closer to improving the multiple crate\nexperience. This unifies all search indexes for all crates into one file so all\npages share the same search index. This allows searching to work across crates\nin the same documentation directory (as the standard distribution is currently\nbuilt).\n\nThis strategy involves updating a shared file amongst many rustdoc processes, so\nI implemented a simple file locking API for handling synchronization for updates\nto the shared files.\n\ncc #12554", "tree": {"sha": "deff6aaa5aae6147b392b508f11852bc70bc9d64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deff6aaa5aae6147b392b508f11852bc70bc9d64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/848f7b734ec88964879f5a3051b940d48469ce2e", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/848f7b734ec88964879f5a3051b940d48469ce2e", "html_url": "https://github.com/rust-lang/rust/commit/848f7b734ec88964879f5a3051b940d48469ce2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/848f7b734ec88964879f5a3051b940d48469ce2e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d717d613e34482d7ddb738cea927900ca6601094", "url": "https://api.github.com/repos/rust-lang/rust/commits/d717d613e34482d7ddb738cea927900ca6601094", "html_url": "https://github.com/rust-lang/rust/commit/d717d613e34482d7ddb738cea927900ca6601094"}], "stats": {"total": 540, "additions": 383, "deletions": 157}, "files": [{"sha": "f5f755751133cad9e6c461081fc8ce1cd4db17d1", "filename": "src/librustdoc/flock.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=848f7b734ec88964879f5a3051b940d48469ce2e", "patch": "@@ -0,0 +1,191 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Simple file-locking apis for each OS.\n+//!\n+//! This is not meant to be in the standard library, it does nothing with\n+//! green/native threading. This is just a bare-bones enough solution for\n+//! librustdoc, it is not production quality at all.\n+\n+#[allow(non_camel_case_types)];\n+\n+pub use self::imp::Lock;\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::libc;\n+\n+    #[cfg(target_os = \"linux\")]\n+    mod os {\n+        use std::libc;\n+\n+        pub struct flock {\n+            l_type: libc::c_short,\n+            l_whence: libc::c_short,\n+            l_start: libc::off_t,\n+            l_len: libc::off_t,\n+            l_pid: libc::pid_t,\n+\n+            // not actually here, but brings in line with freebsd\n+            l_sysid: libc::c_int,\n+        }\n+\n+        pub static F_WRLCK: libc::c_short = 1;\n+        pub static F_UNLCK: libc::c_short = 2;\n+        pub static F_SETLK: libc::c_int = 6;\n+        pub static F_SETLKW: libc::c_int = 7;\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    mod os {\n+        use std::libc;\n+\n+        pub struct flock {\n+            l_start: libc::off_t,\n+            l_len: libc::off_t,\n+            l_pid: libc::pid_t,\n+            l_type: libc::c_short,\n+            l_whence: libc::c_short,\n+            l_sysid: libc::c_int,\n+        }\n+\n+        pub static F_UNLCK: libc::c_short = 2;\n+        pub static F_WRLCK: libc::c_short = 3;\n+        pub static F_SETLK: libc::c_int = 12;\n+        pub static F_SETLKW: libc::c_int = 13;\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    mod os {\n+        use std::libc;\n+\n+        pub struct flock {\n+            l_start: libc::off_t,\n+            l_len: libc::off_t,\n+            l_pid: libc::pid_t,\n+            l_type: libc::c_short,\n+            l_whence: libc::c_short,\n+\n+            // not actually here, but brings in line with freebsd\n+            l_sysid: libc::c_int,\n+        }\n+\n+        pub static F_UNLCK: libc::c_short = 2;\n+        pub static F_WRLCK: libc::c_short = 3;\n+        pub static F_SETLK: libc::c_int = 8;\n+        pub static F_SETLKW: libc::c_int = 9;\n+    }\n+\n+    pub struct Lock {\n+        priv fd: libc::c_int,\n+    }\n+\n+    impl Lock {\n+        pub fn new(p: &Path) -> Lock {\n+            let fd = p.with_c_str(|s| unsafe {\n+                libc::open(s, libc::O_RDWR | libc::O_CREAT, libc::S_IRWXU)\n+            });\n+            assert!(fd > 0);\n+            let flock = os::flock {\n+                l_start: 0,\n+                l_len: 0,\n+                l_pid: 0,\n+                l_whence: libc::SEEK_SET as libc::c_short,\n+                l_type: os::F_WRLCK,\n+                l_sysid: 0,\n+            };\n+            let ret = unsafe {\n+                libc::fcntl(fd, os::F_SETLKW, &flock as *os::flock)\n+            };\n+            if ret == -1 {\n+                unsafe { libc::close(fd); }\n+                fail!(\"could not lock `{}`\", p.display())\n+            }\n+            Lock { fd: fd }\n+        }\n+    }\n+\n+    impl Drop for Lock {\n+        fn drop(&mut self) {\n+            let flock = os::flock {\n+                l_start: 0,\n+                l_len: 0,\n+                l_pid: 0,\n+                l_whence: libc::SEEK_SET as libc::c_short,\n+                l_type: os::F_UNLCK,\n+                l_sysid: 0,\n+            };\n+            unsafe {\n+                libc::fcntl(self.fd, os::F_SETLK, &flock as *os::flock);\n+                libc::close(self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use std::libc;\n+    use std::mem;\n+    use std::os::win32::as_utf16_p;\n+    use std::ptr;\n+\n+    static LOCKFILE_EXCLUSIVE_LOCK: libc::DWORD = 0x00000002;\n+\n+    extern \"system\" {\n+        fn LockFileEx(hFile: libc::HANDLE,\n+                      dwFlags: libc::DWORD,\n+                      dwReserved: libc::DWORD,\n+                      nNumberOfBytesToLockLow: libc::DWORD,\n+                      nNumberOfBytesToLockHigh: libc::DWORD,\n+                      lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n+        fn UnlockFileEx(hFile: libc::HANDLE,\n+                        dwReserved: libc::DWORD,\n+                        nNumberOfBytesToLockLow: libc::DWORD,\n+                        nNumberOfBytesToLockHigh: libc::DWORD,\n+                        lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n+    }\n+\n+    pub struct Lock {\n+        priv handle: libc::HANDLE,\n+    }\n+\n+    impl Lock {\n+        pub fn new(p: &Path) -> Lock {\n+            let handle = as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+                libc::CreateFileW(p, libc::GENERIC_READ, 0, ptr::mut_null(),\n+                                  libc::CREATE_ALWAYS,\n+                                  libc::FILE_ATTRIBUTE_NORMAL,\n+                                  ptr::mut_null())\n+            });\n+            assert!(handle as uint != libc::INVALID_HANDLE_VALUE as uint);\n+            let mut overlapped: libc::OVERLAPPED = unsafe { mem::init() };\n+            let ret = unsafe {\n+                LockFileEx(handle, LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n+                           &mut overlapped)\n+            };\n+            if ret == 0 {\n+                unsafe { libc::CloseHandle(handle); }\n+                fail!(\"could not lock `{}`\", p.display())\n+            }\n+            Lock { handle: handle }\n+        }\n+    }\n+\n+    impl Drop for Lock {\n+        fn drop(&mut self) {\n+            let mut overlapped: libc::OVERLAPPED = unsafe { mem::init() };\n+            unsafe {\n+                UnlockFileEx(self.handle, 0, 100, 0, &mut overlapped);\n+                libc::CloseHandle(self.handle);\n+            }\n+        }\n+    }\n+}"}, {"sha": "317571ebc3ff6b078ec65db0dfcac3e5dd51b78d", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=848f7b734ec88964879f5a3051b940d48469ce2e", "patch": "@@ -37,7 +37,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n \n     <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'\n           rel='stylesheet' type='text/css'>\n-    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}{krate}/main.css\\\">\n+    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}main.css\\\">\n \n     {favicon, select, none{} other{<link rel=\\\"shortcut icon\\\" href=\\\"#\\\" />}}\n </head>\n@@ -74,13 +74,6 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n \n     <section class=\\\"footer\\\"></section>\n \n-    <script>\n-        var rootPath = \\\"{root_path}\\\";\n-    </script>\n-    <script src=\\\"{root_path}{krate}/jquery.js\\\"></script>\n-    <script src=\\\"{root_path}{krate}/search-index.js\\\"></script>\n-    <script src=\\\"{root_path}{krate}/main.js\\\"></script>\n-\n     <div id=\\\"help\\\" class=\\\"hidden\\\">\n         <div class=\\\"shortcuts\\\">\n             <h1>Keyboard shortcuts</h1>\n@@ -111,6 +104,14 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n             </p>\n         </div>\n     </div>\n+\n+    <script>\n+        var rootPath = \\\"{root_path}\\\";\n+        var currentCrate = \\\"{krate}\\\";\n+    </script>\n+    <script src=\\\"{root_path}jquery.js\\\"></script>\n+    <script src=\\\"{root_path}main.js\\\"></script>\n+    <script async src=\\\"{root_path}search-index.js\\\"></script>\n </body>\n </html>\n \","}, {"sha": "26723482595cd5d9f9adff88150dbd09ad84beaa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=848f7b734ec88964879f5a3051b940d48469ce2e", "patch": "@@ -36,7 +36,7 @@\n use std::fmt;\n use std::local_data;\n use std::io;\n-use std::io::{fs, File, BufferedWriter};\n+use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::str;\n use std::vec;\n use std::vec_ng::Vec;\n@@ -283,48 +283,75 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         };\n     }\n \n-    // Add all the static files\n-    let mut dst = cx.dst.join(krate.name.as_slice());\n-    try!(mkdir(&dst));\n-    try!(write(dst.join(\"jquery.js\"),\n-                 include_str!(\"static/jquery-2.1.0.min.js\")));\n-    try!(write(dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n-    try!(write(dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n-    try!(write(dst.join(\"normalize.css\"),\n-                 include_str!(\"static/normalize.css\")));\n-\n     // Publish the search index\n-    {\n-        dst.push(\"search-index.js\");\n-        let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n-        let w = &mut w as &mut Writer;\n-        try!(write!(w, \"var searchIndex = [\"));\n+    let index = {\n+        let mut w = MemWriter::new();\n+        try!(write!(&mut w, \"searchIndex['{}'] = [\", krate.name));\n         for (i, item) in cache.search_index.iter().enumerate() {\n             if i > 0 {\n-                try!(write!(w, \",\"));\n+                try!(write!(&mut w, \",\"));\n             }\n-            try!(write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n-                          item.ty, item.name, item.path,\n-                          item.desc.to_json().to_str()));\n+            try!(write!(&mut w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n+                        item.ty, item.name, item.path,\n+                        item.desc.to_json().to_str()));\n             match item.parent {\n                 Some(id) => {\n-                    try!(write!(w, \",parent:'{}'\", id));\n+                    try!(write!(&mut w, \",parent:'{}'\", id));\n                 }\n                 None => {}\n             }\n-            try!(write!(w, \"\\\\}\"));\n+            try!(write!(&mut w, \"\\\\}\"));\n         }\n-        try!(write!(w, \"];\"));\n-        try!(write!(w, \"var allPaths = \\\\{\"));\n+        try!(write!(&mut w, \"];\"));\n+        try!(write!(&mut w, \"allPaths['{}'] = \\\\{\", krate.name));\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n             if i > 0 {\n-                try!(write!(w, \",\"));\n+                try!(write!(&mut w, \",\"));\n             }\n-            try!(write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                          id, short, *fqp.last().unwrap()));\n+            try!(write!(&mut w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n+                        id, short, *fqp.last().unwrap()));\n         }\n-        try!(write!(w, \"\\\\};\"));\n-        try!(w.flush());\n+        try!(write!(&mut w, \"\\\\};\"));\n+\n+        str::from_utf8_owned(w.unwrap()).unwrap()\n+    };\n+\n+    // Write out the shared files. Note that these are shared among all rustdoc\n+    // docs placed in the output directory, so this needs to be a synchronized\n+    // operation with respect to all other rustdocs running around.\n+    {\n+        try!(mkdir(&cx.dst));\n+        let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n+\n+        // Add all the static files. These may already exist, but we just\n+        // overwrite them anyway to make sure that they're fresh and up-to-date.\n+        try!(write(cx.dst.join(\"jquery.js\"),\n+                   include_str!(\"static/jquery-2.1.0.min.js\")));\n+        try!(write(cx.dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n+        try!(write(cx.dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n+        try!(write(cx.dst.join(\"normalize.css\"),\n+                   include_str!(\"static/normalize.css\")));\n+\n+        // Update the search index\n+        let dst = cx.dst.join(\"search-index.js\");\n+        let mut all_indexes = Vec::new();\n+        all_indexes.push(index);\n+        if dst.exists() {\n+            for line in BufferedReader::new(File::open(&dst)).lines() {\n+                let line = try!(line);\n+                if !line.starts_with(\"searchIndex\") { continue }\n+                if line.starts_with(format!(\"searchIndex['{}']\", krate.name)) {\n+                    continue\n+                }\n+                all_indexes.push(line);\n+            }\n+        }\n+        let mut w = try!(File::create(&dst));\n+        try!(writeln!(&mut w, r\"var searchIndex = \\{\\}; var allPaths = \\{\\};\"));\n+        for index in all_indexes.iter() {\n+            try!(writeln!(&mut w, \"{}\", *index));\n+        }\n+        try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n     }\n \n     // Render all source files (this may turn into a giant no-op)"}, {"sha": "ffdf67e56cf7fd67a84db1442c922ed5f745355a", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 125, "deletions": 119, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=848f7b734ec88964879f5a3051b940d48469ce2e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n /*jslint browser: true, es5: true */\n-/*globals $: true, searchIndex: true, rootPath: true, allPaths: true */\n+/*globals $: true, rootPath: true, allPaths: true */\n \n (function() {\n     \"use strict\";\n@@ -23,7 +23,8 @@\n             map(function(s) {\n                 var pair = s.split(\"=\");\n                 params[decodeURIComponent(pair[0])] =\n-                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n+                    typeof pair[1] === \"undefined\" ?\n+                            null : decodeURIComponent(pair[1]);\n             });\n         return params;\n     }\n@@ -111,8 +112,9 @@\n         document.location.href = url;\n     });\n \n-    function initSearch(searchIndex) {\n-        var currentResults, index, params = getQueryStringParams();\n+    function initSearch(rawSearchIndex) {\n+        var currentResults, index, searchIndex;\n+        var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n         // but only if the input bar is empty. This avoid the obnoxious issue\n@@ -126,7 +128,8 @@\n          * Executes the query and builds an index of results\n          * @param  {[Object]} query     [The user query]\n          * @param  {[type]} max         [The maximum results returned]\n-         * @param  {[type]} searchWords [The list of search words to query against]\n+         * @param  {[type]} searchWords [The list of search words to query\n+         *                               against]\n          * @return {[type]}             [A search index of results]\n          */\n         function execQuery(query, max, searchWords) {\n@@ -148,7 +151,9 @@\n \n             // quoted values mean literal search\n             bb = searchWords.length;\n-            if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") && val.charAt(val.length - 1) === val.charAt(0)) {\n+            if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n+                val.charAt(val.length - 1) === val.charAt(0))\n+            {\n                 val = val.substr(1, val.length - 2);\n                 for (aa = 0; aa < bb; aa += 1) {\n                     if (searchWords[aa] === val) {\n@@ -166,7 +171,10 @@\n                 val = val.replace(/\\_/g, \"\");\n                 for (var i = 0; i < split.length; i++) {\n                     for (aa = 0; aa < bb; aa += 1) {\n-                        if (searchWords[aa].indexOf(split[i]) > -1 || searchWords[aa].indexOf(val) > -1 || searchWords[aa].replace(/_/g, \"\").indexOf(val) > -1) {\n+                        if (searchWords[aa].indexOf(split[i]) > -1 ||\n+                            searchWords[aa].indexOf(val) > -1 ||\n+                            searchWords[aa].replace(/_/g, \"\").indexOf(val) > -1)\n+                        {\n                             // filter type: ... queries\n                             if (!typeFilter || typeFilter === searchIndex[aa].ty) {\n                                 results.push([aa, searchWords[aa].replace(/_/g, \"\").indexOf(val)]);\n@@ -185,6 +193,7 @@\n                 results[aa].push(searchIndex[results[aa][0]].path);\n                 results[aa].push(searchIndex[results[aa][0]].name);\n                 results[aa].push(searchIndex[results[aa][0]].parent);\n+                results[aa].push(searchIndex[results[aa][0]].crate);\n             }\n             // if there are no results then return to default and fail\n             if (results.length === 0) {\n@@ -193,7 +202,8 @@\n \n             // sort by exact match\n             results.sort(function search_complete_sort0(aaa, bbb) {\n-                if (searchWords[aaa[0]] === valLower && searchWords[bbb[0]] !== valLower) {\n+                if (searchWords[aaa[0]] === valLower &&\n+                    searchWords[bbb[0]] !== valLower) {\n                     return 1;\n                 }\n             });\n@@ -207,7 +217,8 @@\n             // second sorting attempt\n             // sort by item name\n             results.sort(function search_complete_sort1(aaa, bbb) {\n-                if (searchWords[aaa[0]].length === searchWords[bbb[0]].length && searchWords[aaa[0]] > searchWords[bbb[0]]) {\n+                if (searchWords[aaa[0]].length === searchWords[bbb[0]].length &&\n+                    searchWords[aaa[0]] > searchWords[bbb[0]]) {\n                     return 1;\n                 }\n             });\n@@ -223,29 +234,34 @@\n             // fourth sorting attempt\n             // sort by type\n             results.sort(function search_complete_sort3(aaa, bbb) {\n-                if (searchWords[aaa[0]] === searchWords[bbb[0]] && aaa[2] > bbb[2]) {\n+                if (searchWords[aaa[0]] === searchWords[bbb[0]] &&\n+                    aaa[2] > bbb[2]) {\n                     return 1;\n                 }\n             });\n             // fifth sorting attempt\n             // sort by path\n             results.sort(function search_complete_sort4(aaa, bbb) {\n-                if (searchWords[aaa[0]] === searchWords[bbb[0]] && aaa[2] === bbb[2] && aaa[3] > bbb[3]) {\n+                if (searchWords[aaa[0]] === searchWords[bbb[0]] &&\n+                    aaa[2] === bbb[2] && aaa[3] > bbb[3]) {\n                     return 1;\n                 }\n             });\n             // sixth sorting attempt\n             // remove duplicates, according to the data provided\n             for (aa = results.length - 1; aa > 0; aa -= 1) {\n-                if (searchWords[results[aa][0]] === searchWords[results[aa - 1][0]] && results[aa][2] === results[aa - 1][2] && results[aa][3] === results[aa - 1][3]) {\n+                if (searchWords[results[aa][0]] === searchWords[results[aa - 1][0]] &&\n+                    results[aa][2] === results[aa - 1][2] &&\n+                    results[aa][3] === results[aa - 1][3])\n+                {\n                     results[aa][0] = -1;\n                 }\n             }\n             for (var i = 0; i < results.length; i++) {\n                 var result = results[i],\n                     name = result[4].toLowerCase(),\n                     path = result[3].toLowerCase(),\n-                    parent = allPaths[result[5]];\n+                    parent = allPaths[result[6]][result[5]];\n \n                 var valid = validateResult(name, path, split, parent);\n                 if (!valid) {\n@@ -256,11 +272,14 @@\n         }\n \n         /**\n-         * Validate performs the following boolean logic. For example: \"File::open\" will give\n-         * IF A PARENT EXISTS => (\"file\" && \"open\") exists in (name || path || parent)\n-         * OR => (\"file\" && \"open\") exists in (name || path )\n+         * Validate performs the following boolean logic. For example:\n+         * \"File::open\" will give IF A PARENT EXISTS => (\"file\" && \"open\")\n+         * exists in (name || path || parent) OR => (\"file\" && \"open\") exists in\n+         * (name || path )\n+         *\n+         * This could be written functionally, but I wanted to minimise\n+         * functions on stack.\n          *\n-         * This could be written functionally, but I wanted to minimise functions on stack.\n          * @param  {[string]} name   [The name of the result]\n          * @param  {[string]} path   [The path of the result]\n          * @param  {[string]} keys   [The keys to be used ([\"file\", \"open\"])]\n@@ -273,17 +292,26 @@\n             //if there is a parent, then validate against parent\n             if (parent !== undefined) {\n                 for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the path, name or parent\n-                    if ((validate) && (name.toLowerCase().indexOf(keys[i]) > -1 || path.toLowerCase().indexOf(keys[i]) > -1 || parent.name.toLowerCase().indexOf(keys[i]) > -1)) {\n+                    // if previous keys are valid and current key is in the\n+                    // path, name or parent\n+                    if ((validate) &&\n+                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                         path.toLowerCase().indexOf(keys[i]) > -1 ||\n+                         parent.name.toLowerCase().indexOf(keys[i]) > -1))\n+                    {\n                         validate = true;\n                     } else {\n                         validate = false;\n                     }\n                 }\n             } else {\n                 for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the path, name\n-                    if ((validate) && (name.toLowerCase().indexOf(keys[i]) > -1 || path.toLowerCase().indexOf(keys[i]) > -1)) {\n+                    // if previous keys are valid and current key is in the\n+                    // path, name\n+                    if ((validate) &&\n+                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                         path.toLowerCase().indexOf(keys[i]) > -1))\n+                    {\n                         validate = true;\n                     } else {\n                         validate = false;\n@@ -298,7 +326,10 @@\n \n             matches = query.match(/^(fn|mod|str(uct)?|enum|trait|t(ype)?d(ef)?)\\s*:\\s*/i);\n             if (matches) {\n-                type = matches[1].replace(/^td$/, 'typedef').replace(/^str$/, 'struct').replace(/^tdef$/, 'typedef').replace(/^typed$/, 'typedef');\n+                type = matches[1].replace(/^td$/, 'typedef')\n+                                 .replace(/^str$/, 'struct')\n+                                 .replace(/^tdef$/, 'typedef')\n+                                 .replace(/^typed$/, 'typedef');\n                 query = query.substring(matches[0].length);\n             }\n \n@@ -314,7 +345,6 @@\n \n             $results.on('click', function() {\n                 var dst = $(this).find('a')[0];\n-                console.log(window.location.pathname, dst.pathname);\n                 if (window.location.pathname == dst.pathname) {\n                     $('#search').addClass('hidden');\n                     $('#main').removeClass('hidden');\n@@ -362,7 +392,8 @@\n             var output, shown, query = getQuery();\n \n             currentResults = query.id;\n-            output = '<h1>Results for ' + query.query + (query.type ? ' (type: ' + query.type + ')' : '') + '</h1>';\n+            output = '<h1>Results for ' + query.query +\n+                    (query.type ? ' (type: ' + query.type + ')' : '') + '</h1>';\n             output += '<table class=\"search-results\">';\n \n             if (results.length > 0) {\n@@ -394,7 +425,7 @@\n                             '/index.html\" class=\"' + type +\n                             '\">' + name + '</a>';\n                     } else if (item.parent !== undefined) {\n-                        var myparent = allPaths[item.parent];\n+                        var myparent = allPaths[item.crate][item.parent];\n                         var anchor = '#' + type + '.' + name;\n                         output += item.path + '::' + myparent.name +\n                             '::<a href=\"' + rootPath +\n@@ -449,13 +480,15 @@\n                 return;\n             }\n \n-            // Because searching is incremental by character, only the most recent search query\n-            // is added to the browser history.\n+            // Because searching is incremental by character, only the most\n+            // recent search query is added to the browser history.\n             if (browserSupportsHistoryApi()) {\n                 if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", \"?search=\" + encodeURIComponent(query.query));\n+                    history.pushState(query, \"\", \"?search=\" +\n+                                                encodeURIComponent(query.query));\n                 } else {\n-                    history.replaceState(query, \"\", \"?search=\" + encodeURIComponent(query.query));\n+                    history.replaceState(query, \"\", \"?search=\" +\n+                                                encodeURIComponent(query.query));\n                 }\n             }\n \n@@ -472,91 +505,33 @@\n                 }\n             }\n \n-            // TODO add sorting capability through this function?\n-            //\n-            //            // the handler for the table heading filtering\n-            //            filterdraw = function search_complete_filterdraw(node) {\n-            //                var name = \"\",\n-            //                    arrow = \"\",\n-            //                    op = 0,\n-            //                    tbody = node.parentNode.parentNode.nextSibling,\n-            //                    anchora = {},\n-            //                    tra = {},\n-            //                    tha = {},\n-            //                    td1a = {},\n-            //                    td2a = {},\n-            //                    td3a = {},\n-            //                    aaa = 0,\n-            //                    bbb = 0;\n-            //\n-            //                // the 4 following conditions set the rules for each\n-            //                // table heading\n-            //                if (node === ths[0]) {\n-            //                    op = 0;\n-            //                    name = \"name\";\n-            //                    ths[1].innerHTML = ths[1].innerHTML.split(\" \")[0];\n-            //                    ths[2].innerHTML = ths[2].innerHTML.split(\" \")[0];\n-            //                    ths[3].innerHTML = ths[3].innerHTML.split(\" \")[0];\n-            //                }\n-            //                if (node === ths[1]) {\n-            //                    op = 1;\n-            //                    name = \"type\";\n-            //                    ths[0].innerHTML = ths[0].innerHTML.split(\" \")[0];\n-            //                    ths[2].innerHTML = ths[2].innerHTML.split(\" \")[0];\n-            //                    ths[3].innerHTML = ths[3].innerHTML.split(\" \")[0];\n-            //                }\n-            //                if (node === ths[2]) {\n-            //                    op = 2;\n-            //                    name = \"path\";\n-            //                    ths[0].innerHTML = ths[0].innerHTML.split(\" \")[0];\n-            //                    ths[1].innerHTML = ths[1].innerHTML.split(\" \")[0];\n-            //                    ths[3].innerHTML = ths[3].innerHTML.split(\" \")[0];\n-            //                }\n-            //                if (node === ths[3]) {\n-            //                    op = 3;\n-            //                    name = \"description\";\n-            //                    ths[0].innerHTML = ths[0].innerHTML.split(\" \")[0];\n-            //                    ths[1].innerHTML = ths[1].innerHTML.split(\" \")[0];\n-            //                    ths[2].innerHTML = ths[2].innerHTML.split(\" \")[0];\n-            //                }\n-            //\n-            //                // ascending or descending search\n-            //                arrow = node.innerHTML.split(\" \")[1];\n-            //                if (arrow === undefined || arrow === \"\\u25b2\") {\n-            //                    arrow = \"\\u25bc\";\n-            //                } else {\n-            //                    arrow = \"\\u25b2\";\n-            //                }\n-            //\n-            //                // filter the data\n-            //                filterdata.sort(function search_complete_filterDraw_sort(xx, yy) {\n-            //                    if ((arrow === \"\\u25b2\" && xx[op].toLowerCase() < yy[op].toLowerCase()) || (arrow === \"\\u25bc\" && xx[op].toLowerCase() > yy[op].toLowerCase())) {\n-            //                        return 1;\n-            //                    }\n-            //                });\n-            //            };\n-\n             showResults(results);\n         }\n \n-        function buildIndex(searchIndex) {\n-            var len = searchIndex.length,\n-                i = 0,\n-                searchWords = [];\n-\n-            // before any analysis is performed lets gather the search terms to\n-            // search against apart from the rest of the data.  This is a quick\n-            // operation that is cached for the life of the page state so that\n-            // all other search operations have access to this cached data for\n-            // faster analysis operations\n-            for (i = 0; i < len; i += 1) {\n-                if (typeof searchIndex[i].name === \"string\") {\n-                    searchWords.push(searchIndex[i].name.toLowerCase());\n-                } else {\n-                    searchWords.push(\"\");\n+        function buildIndex(rawSearchIndex) {\n+            searchIndex = [];\n+            var searchWords = [];\n+            for (var crate in rawSearchIndex) {\n+                if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n+                var len = rawSearchIndex[crate].length;\n+                var i = 0;\n+\n+                // before any analysis is performed lets gather the search terms to\n+                // search against apart from the rest of the data.  This is a quick\n+                // operation that is cached for the life of the page state so that\n+                // all other search operations have access to this cached data for\n+                // faster analysis operations\n+                for (i = 0; i < len; i += 1) {\n+                    rawSearchIndex[crate][i].crate = crate;\n+                    searchIndex.push(rawSearchIndex[crate][i]);\n+                    if (typeof rawSearchIndex[crate][i].name === \"string\") {\n+                        var word = rawSearchIndex[crate][i].name.toLowerCase();\n+                        searchWords.push(word);\n+                    } else {\n+                        searchWords.push(\"\");\n+                    }\n                 }\n             }\n-\n             return searchWords;\n         }\n \n@@ -567,37 +542,68 @@\n                 clearTimeout(keyUpTimeout);\n                 keyUpTimeout = setTimeout(search, 100);\n             });\n-            // Push and pop states are used to add search results to the browser history.\n+\n+            // Push and pop states are used to add search results to the browser\n+            // history.\n             if (browserSupportsHistoryApi()) {\n                 $(window).on('popstate', function(e) {\n                     var params = getQueryStringParams();\n-                    // When browsing back from search results the main page visibility must be reset.\n+                    // When browsing back from search results the main page\n+                    // visibility must be reset.\n                     if (!params.search) {\n                         $('#main.content').removeClass('hidden');\n                         $('#search.content').addClass('hidden');\n                     }\n-                    // When browsing forward to search results the previous search will be repeated,\n-                    // so the currentResults are cleared to ensure the search is successful.\n+                    // When browsing forward to search results the previous\n+                    // search will be repeated, so the currentResults are\n+                    // cleared to ensure the search is successful.\n                     currentResults = null;\n                     // Synchronize search bar with query string state and\n                     // perform the search, but don't empty the bar if there's\n                     // nothing there.\n                     if (params.search !== undefined) {\n                         $('.search-input').val(params.search);\n                     }\n-                    // Some browsers fire 'onpopstate' for every page load (Chrome), while others fire the\n-                    // event only when actually popping a state (Firefox), which is why search() is called\n-                    // both here and at the end of the startSearch() function.\n+                    // Some browsers fire 'onpopstate' for every page load\n+                    // (Chrome), while others fire the event only when actually\n+                    // popping a state (Firefox), which is why search() is\n+                    // called both here and at the end of the startSearch()\n+                    // function.\n                     search();\n                 });\n             }\n             search();\n         }\n \n-        index = buildIndex(searchIndex);\n+        index = buildIndex(rawSearchIndex);\n         startSearch();\n-    }\n \n-    initSearch(searchIndex);\n+        // Draw a convenient sidebar of known crates if we have a listing\n+        if (rootPath == '../') {\n+            console.log('here');\n+            var sidebar = $('.sidebar');\n+            var div = $('<div>').attr('class', 'block crate');\n+            div.append($('<h2>').text('Crates'));\n+\n+            var crates = [];\n+            for (var crate in rawSearchIndex) {\n+                if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n+                crates.push(crate);\n+            }\n+            crates.sort();\n+            for (var i = 0; i < crates.length; i++) {\n+                var klass = 'crate';\n+                if (crates[i] == window.currentCrate) {\n+                    klass += ' current';\n+                }\n+                div.append($('<a>', {'href': '../' + crates[i] + '/index.html',\n+                                    'class': klass}).text(crates[i]));\n+                div.append($('<br>'));\n+            }\n+            sidebar.append(div);\n+        }\n+    }\n \n+    window.initSearch = initSearch;\n }());\n+"}, {"sha": "6dc3c2073f176ff6674c681c3de387d29ad4438c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=848f7b734ec88964879f5a3051b940d48469ce2e", "patch": "@@ -52,6 +52,7 @@ pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n pub mod test;\n+mod flock;\n \n pub static SCHEMA_VERSION: &'static str = \"0.8.1\";\n "}, {"sha": "42221f074491d0cd6c3be0a1654a86523ce2f720", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848f7b734ec88964879f5a3051b940d48469ce2e/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=848f7b734ec88964879f5a3051b940d48469ce2e", "patch": "@@ -3643,7 +3643,7 @@ pub mod funcs {\n                 pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n                 pub fn creat(path: *c_char, mode: mode_t) -> c_int;\n-                pub fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n+                pub fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;\n             }\n         }\n "}]}