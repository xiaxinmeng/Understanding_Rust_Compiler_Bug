{"sha": "c737c0702134888a88cb847c5286c600a78ffea9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MzdjMDcwMjEzNDg4OGE4OGNiODQ3YzUyODZjNjAwYTc4ZmZlYTk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-01T10:22:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-27T18:20:28Z"}, "message": "Lowering for hir::Ty.", "tree": {"sha": "f30bfb65d44aa5a38885dc74b18a21e721a073ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f30bfb65d44aa5a38885dc74b18a21e721a073ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c737c0702134888a88cb847c5286c600a78ffea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c737c0702134888a88cb847c5286c600a78ffea9", "html_url": "https://github.com/rust-lang/rust/commit/c737c0702134888a88cb847c5286c600a78ffea9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c737c0702134888a88cb847c5286c600a78ffea9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5865d563eacaff1b0d3836390f4ce3e1e78b849e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5865d563eacaff1b0d3836390f4ce3e1e78b849e", "html_url": "https://github.com/rust-lang/rust/commit/5865d563eacaff1b0d3836390f4ce3e1e78b849e"}], "stats": {"total": 477, "additions": 231, "deletions": 246}, "files": [{"sha": "f551d9e31a6583a80ee2b8c94d89279bb7110d3f", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=c737c0702134888a88cb847c5286c600a78ffea9", "patch": "@@ -128,7 +128,12 @@ macro_rules! arena_types {\n             [] arm: rustc::hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n             [] block: rustc::hir::Block<$tcx>,\n+            [] bare_fn_ty: rustc::hir::BareFnTy<$tcx>,\n             [few] global_asm: rustc::hir::GlobalAsm,\n+            [] generic_arg: rustc::hir::GenericArg<$tcx>,\n+            [] generic_args: rustc::hir::GenericArgs<$tcx>,\n+            [] generic_bound: rustc::hir::GenericBound<$tcx>,\n+            [] generic_param: rustc::hir::GenericParam<$tcx>,\n             [] expr: rustc::hir::Expr<$tcx>,\n             [] field: rustc::hir::Field<$tcx>,\n             [] field_pat: rustc::hir::FieldPat<$tcx>,\n@@ -142,12 +147,15 @@ macro_rules! arena_types {\n             [] pat: rustc::hir::Pat<$tcx>,\n             [] path: rustc::hir::Path<$tcx>,\n             [] path_segment: rustc::hir::PathSegment<$tcx>,\n+            [] poly_trait_ref: rustc::hir::PolyTraitRef<$tcx>,\n             [] qpath: rustc::hir::QPath<$tcx>,\n             [] stmt: rustc::hir::Stmt<$tcx>,\n             [] struct_field: rustc::hir::StructField<$tcx>,\n             [] trait_item_ref: rustc::hir::TraitItemRef,\n             [] ty: rustc::hir::Ty<$tcx>,\n+            [] type_binding: rustc::hir::TypeBinding<$tcx>,\n             [] variant: rustc::hir::Variant<$tcx>,\n+            [] where_predicate: rustc::hir::WherePredicate<$tcx>,\n         ], $tcx);\n     )\n }"}, {"sha": "110788c66c759280fda5ed4b696fdcc08784b525", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 175, "deletions": 157, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c737c0702134888a88cb847c5286c600a78ffea9", "patch": "@@ -206,13 +206,13 @@ type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n-enum ImplTraitContext<'a> {\n+enum ImplTraitContext<'b, 'a> {\n     /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n     /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'a mut Vec<hir::GenericParam<'a>>),\n+    Universal(&'b mut Vec<hir::GenericParam<'a>>),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -237,13 +237,13 @@ enum ImplTraitPosition {\n     Other,\n }\n \n-impl<'a> ImplTraitContext<'a> {\n+impl<'b, 'a> ImplTraitContext<'b, 'a> {\n     #[inline]\n     fn disallowed() -> Self {\n         ImplTraitContext::Disallowed(ImplTraitPosition::Other)\n     }\n \n-    fn reborrow(&'b mut self) -> ImplTraitContext<'b> {\n+    fn reborrow(&'c mut self) -> ImplTraitContext<'c, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n@@ -741,7 +741,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         f: F,\n     ) -> (Vec<hir::GenericParam<'hir>>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> (Vec<hir::GenericParam<'hir>>, T),\n+        F: FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n@@ -796,8 +796,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             name: hir_name,\n-            attrs: hir_vec![],\n-            bounds: hir_vec![],\n+            attrs: &[],\n+            bounds: &[],\n             span,\n             pure_wrt_drop: false,\n             kind: hir::GenericParamKind::Lifetime { kind },\n@@ -847,7 +847,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // for them.\n     fn with_in_scope_lifetime_defs<T, F>(&mut self, params: &[GenericParam], f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, 'hir>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n@@ -876,7 +876,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         f: F,\n     ) -> (hir::Generics<'hir>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>, &mut Vec<hir::GenericParam<'hir>>) -> T,\n+        F: FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     {\n         let (in_band_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.params, |this| {\n@@ -897,7 +897,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             });\n \n         let mut lowered_params: Vec<_> =\n-            lowered_generics.params.into_iter().chain(in_band_defs).collect();\n+            lowered_generics.params.into_iter().chain(in_band_defs.into_iter()).collect();\n \n         // FIXME(const_generics): the compiler doesn't always cope with\n         // unsorted generic parameters at the moment, so we make sure\n@@ -916,7 +916,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let was_in_dyn_type = self.is_in_dyn_type;\n         self.is_in_dyn_type = in_scope;\n@@ -1025,7 +1025,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_assoc_ty_constraint(\n         &mut self,\n         constraint: &AssocTyConstraint,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n@@ -1122,7 +1122,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_arg(\n         &mut self,\n         arg: &ast::GenericArg,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::GenericArg<'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n@@ -1178,8 +1178,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_>) -> P<hir::Ty<'hir>> {\n-        P(self.lower_ty_direct(t, itctx))\n+    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_, 'hir>) -> &'hir hir::Ty<'hir> {\n+        self.arena.alloc(self.lower_ty_direct(t, itctx))\n     }\n \n     fn lower_path_ty(\n@@ -1188,7 +1188,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         path: &Path,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::Ty<'hir> {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n@@ -1203,11 +1203,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Ty { hir_id: self.next_id(), kind, span }\n     }\n \n-    fn ty_tup(&mut self, span: Span, tys: HirVec<hir::Ty<'hir>>) -> hir::Ty<'hir> {\n+    fn ty_tup(&mut self, span: Span, tys: &'hir [hir::Ty<'hir>]) -> hir::Ty<'hir> {\n         self.ty(span, hir::TyKind::Tup(tys))\n     }\n \n-    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty<'hir> {\n+    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_, 'hir>) -> hir::Ty<'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n@@ -1223,23 +1223,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n                 this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-                    hir::TyKind::BareFn(P(hir::BareFnTy {\n-                        generic_params: this.lower_generic_params(\n-                            &f.generic_params,\n-                            &NodeMap::default(),\n-                            ImplTraitContext::disallowed(),\n-                        ),\n-                        unsafety: f.unsafety,\n-                        abi: this.lower_extern(f.ext),\n-                        decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                        param_names: this.lower_fn_params_to_names(&f.decl),\n-                    }))\n+                    hir::TyKind::BareFn(\n+                        this.arena.alloc(hir::BareFnTy {\n+                            generic_params: this.arena.alloc_from_iter(\n+                                this.lower_generic_params(\n+                                    &f.generic_params,\n+                                    &NodeMap::default(),\n+                                    ImplTraitContext::disallowed(),\n+                                )\n+                                .into_iter(),\n+                            ),\n+                            unsafety: f.unsafety,\n+                            abi: this.lower_extern(f.ext),\n+                            decl: this.lower_fn_decl(&f.decl, None, false, None),\n+                            param_names: this.arena.alloc_from_iter(\n+                                this.lower_fn_params_to_names(&f.decl).into_iter(),\n+                            ),\n+                        }),\n+                    )\n                 })\n             }),\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n-                tys.iter().map(|ty| self.lower_ty_direct(ty, itctx.reborrow())).collect(),\n-            ),\n+            TyKind::Tup(ref tys) => {\n+                hir::TyKind::Tup(self.arena.alloc_from_iter(\n+                    tys.iter().map(|ty| self.lower_ty_direct(ty, itctx.reborrow())),\n+                ))\n+            }\n             TyKind::Paren(ref ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n@@ -1251,11 +1260,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let res = self.lower_res(res);\n                 hir::TyKind::Path(hir::QPath::Resolved(\n                     None,\n-                    P(hir::Path {\n+                    self.arena.alloc(hir::Path {\n                         res,\n-                        segments: hir_vec![hir::PathSegment::from_ident(Ident::with_dummy_span(\n-                            kw::SelfUpper\n-                        ))],\n+                        segments: arena_vec![self; hir::PathSegment::from_ident(\n+                            Ident::with_dummy_span(kw::SelfUpper)\n+                        )],\n                         span: t.span,\n                     }),\n                 ))\n@@ -1267,21 +1276,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n-                    let bounds = bounds\n-                        .iter()\n-                        .filter_map(|bound| match *bound {\n-                            GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n-                                Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n-                            }\n-                            GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n-                            GenericBound::Outlives(ref lifetime) => {\n-                                if lifetime_bound.is_none() {\n-                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n+                    let bounds =\n+                        this.arena.alloc_from_iter(bounds.iter().filter_map(\n+                            |bound| match *bound {\n+                                GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n+                                    Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n                                 }\n-                                None\n-                            }\n-                        })\n-                        .collect();\n+                                GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                GenericBound::Outlives(ref lifetime) => {\n+                                    if lifetime_bound.is_none() {\n+                                        lifetime_bound = Some(this.lower_lifetime(lifetime));\n+                                    }\n+                                    None\n+                                }\n+                            },\n+                        ));\n                     let lifetime_bound =\n                         lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n                     (bounds, lifetime_bound)\n@@ -1314,7 +1323,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n-                            attrs: hir_vec![],\n+                            attrs: &[],\n                             bounds: hir_bounds,\n                             span,\n                             kind: hir::GenericParamKind::Type {\n@@ -1325,10 +1334,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                         hir::TyKind::Path(hir::QPath::Resolved(\n                             None,\n-                            P(hir::Path {\n+                            self.arena.alloc(hir::Path {\n                                 span,\n                                 res: Res::Def(DefKind::TyParam, DefId::local(def_index)),\n-                                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n                     }\n@@ -1376,7 +1385,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         fn_def_id: Option<DefId>,\n         opaque_ty_node_id: NodeId,\n-        lower_bounds: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::GenericBounds<'hir>,\n+        lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n         debug!(\n             \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n@@ -1411,7 +1420,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n-                    where_clause: hir::WhereClause { predicates: hir_vec![], span },\n+                    where_clause: hir::WhereClause { predicates: &[], span },\n                     span,\n                 },\n                 bounds: hir_bounds,\n@@ -1461,8 +1470,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         opaque_ty_id: NodeId,\n         parent_index: DefIndex,\n-        bounds: &hir::GenericBounds<'hir>,\n-    ) -> (HirVec<hir::GenericArg<'hir>>, HirVec<hir::GenericParam<'hir>>) {\n+        bounds: hir::GenericBounds<'hir>,\n+    ) -> (&'hir [hir::GenericArg<'hir>], HirVec<hir::GenericParam<'hir>>) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n              parent_index={:?}, \\\n@@ -1603,8 +1612,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name,\n                         span: lifetime.span,\n                         pure_wrt_drop: false,\n-                        attrs: hir_vec![],\n-                        bounds: hir_vec![],\n+                        attrs: &[],\n+                        bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     });\n                 }\n@@ -1626,10 +1635,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n         }\n \n-        (\n-            lifetime_collector.output_lifetimes.into(),\n-            lifetime_collector.output_lifetime_params.into(),\n-        )\n+        let ImplTraitLifetimeCollector { output_lifetimes, output_lifetime_params, .. } =\n+            lifetime_collector;\n+\n+        (self.arena.alloc_from_iter(output_lifetimes), output_lifetime_params.into())\n     }\n \n     fn lower_qpath(\n@@ -1638,7 +1647,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         p: &Path,\n         param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_>,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::QPath<'hir> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n@@ -1647,12 +1656,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n \n         let proj_start = p.segments.len() - partial_res.unresolved_segments();\n-        let path = P(hir::Path {\n+        let path = self.arena.alloc(hir::Path {\n             res: self.lower_res(partial_res.base_res()),\n-            segments: p.segments[..proj_start]\n-                .iter()\n-                .enumerate()\n-                .map(|(i, segment)| {\n+            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n+                |(i, segment)| {\n                     let param_mode = match (qself_position, param_mode) {\n                         (Some(j), ParamMode::Optional) if i < j => {\n                             // This segment is part of the trait path in a\n@@ -1728,8 +1735,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         itctx.reborrow(),\n                         None,\n                     )\n-                })\n-                .collect(),\n+                },\n+            )),\n             span: p.span,\n         });\n \n@@ -1749,7 +1756,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n             let new_id = self.next_id();\n-            P(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -1763,7 +1770,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(\n+            let segment = self.arena.alloc(self.lower_path_segment(\n                 p.span,\n                 segment,\n                 param_mode,\n@@ -1781,7 +1788,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             // Wrap the associated extension in another type node.\n             let new_id = self.next_id();\n-            ty = P(self.ty_path(new_id, p.span, qpath));\n+            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n         }\n \n         // We should've returned in the for loop above.\n@@ -1802,21 +1809,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::Path<'hir> {\n         hir::Path {\n             res,\n-            segments: p\n-                .segments\n-                .iter()\n-                .map(|segment| {\n-                    self.lower_path_segment(\n-                        p.span,\n-                        segment,\n-                        param_mode,\n-                        0,\n-                        ParenthesizedGenericArgs::Err,\n-                        ImplTraitContext::disallowed(),\n-                        explicit_owner,\n-                    )\n-                })\n-                .collect(),\n+            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n+                self.lower_path_segment(\n+                    p.span,\n+                    segment,\n+                    param_mode,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    explicit_owner,\n+                )\n+            })),\n             span: p.span,\n         }\n     }\n@@ -1834,7 +1837,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param_mode: ParamMode,\n         expected_lifetimes: usize,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::PathSegment<'hir> {\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n@@ -1967,20 +1970,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             segment.ident, segment.id, id,\n         );\n \n-        hir::PathSegment::new(\n-            segment.ident,\n-            Some(id),\n-            Some(self.lower_res(res)),\n-            generic_args,\n+        hir::PathSegment {\n+            ident: segment.ident,\n+            hir_id: Some(id),\n+            res: Some(self.lower_res(res)),\n             infer_args,\n-        )\n+            args: if generic_args.is_empty() { None } else { Some(self.arena.alloc(generic_args)) },\n+        }\n     }\n \n     fn lower_angle_bracketed_parameter_data(\n         &mut self,\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_>,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> (hir::GenericArgs<'hir>, bool) {\n         let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n         let has_non_lt_args = args.iter().any(|arg| match arg {\n@@ -1991,10 +1994,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         (\n             hir::GenericArgs {\n                 args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: constraints\n-                    .iter()\n-                    .map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow()))\n-                    .collect(),\n+                bindings: self.arena.alloc_from_iter(\n+                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n+                ),\n                 parenthesized: false,\n             },\n             !has_non_lt_args && param_mode == ParamMode::Optional,\n@@ -2012,13 +2014,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // we generally don't permit such things (see #51008).\n         self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n             let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n-            let inputs = inputs\n-                .iter()\n-                .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n-                .collect();\n+            let inputs = this.arena.alloc_from_iter(\n+                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n+            );\n             let output_ty = match output {\n                 FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                FunctionRetTy::Default(_) => P(this.ty_tup(span, hir::HirVec::new())),\n+                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n             };\n             let args = hir_vec![GenericArg::Type(this.ty_tup(span, inputs))];\n             let binding = hir::TypeBinding {\n@@ -2027,7 +2028,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 span: output_ty.span,\n                 kind: hir::TypeBindingKind::Equality { ty: output_ty },\n             };\n-            (hir::GenericArgs { args, bindings: hir_vec![binding], parenthesized: true }, false)\n+            (\n+                hir::GenericArgs { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                false,\n+            )\n         })\n     }\n \n@@ -2050,7 +2054,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 },\n             )\n         });\n-        let ty = ty.map(|ty| &*self.arena.alloc(ty.into_inner()));\n         let init = l.init.as_ref().map(|e| self.lower_expr(e));\n         (\n             hir::Local {\n@@ -2101,7 +2104,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam<'hir>>)>,\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n-    ) -> P<hir::FnDecl<'hir>> {\n+    ) -> &'hir hir::FnDecl<'hir> {\n         debug!(\n             \"lower_fn_decl(\\\n             fn_decl: {:?}, \\\n@@ -2131,16 +2134,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             if c_variadic {\n                 inputs = &inputs[..inputs.len() - 1];\n             }\n-            inputs\n-                .iter()\n-                .map(|param| {\n-                    if let Some((_, ibty)) = &mut in_band_ty_params {\n-                        this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n-                    } else {\n-                        this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n-                    }\n-                })\n-                .collect::<HirVec<_>>()\n+            this.arena.alloc_from_iter(inputs.iter().map(|param| {\n+                if let Some((_, ibty)) = &mut in_band_ty_params {\n+                    this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n+                } else {\n+                    this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n+                }\n+            }))\n         });\n \n         let output = if let Some(ret_id) = make_ret_async {\n@@ -2161,7 +2161,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         };\n \n-        P(hir::FnDecl {\n+        self.arena.alloc(hir::FnDecl {\n             inputs,\n             output,\n             c_variadic,\n@@ -2309,19 +2309,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             let generic_params = lifetime_params\n                 .iter()\n-                .cloned()\n                 .map(|(span, hir_name)| {\n-                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_index)\n+                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_index)\n                 })\n                 .collect();\n \n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: generic_params,\n-                    where_clause: hir::WhereClause { predicates: hir_vec![], span },\n+                    where_clause: hir::WhereClause { predicates: &[], span },\n                     span,\n                 },\n-                bounds: hir_vec![future_bound],\n+                bounds: arena_vec![this; future_bound],\n                 impl_trait_fn: Some(fn_def_id),\n                 origin: hir::OpaqueTyOrigin::AsyncFn,\n             };\n@@ -2360,22 +2359,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 })\n             })\n             .collect();\n-        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)| {\n+        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)|\n             // Output lifetime like `'_`.\n             GenericArg::Lifetime(hir::Lifetime {\n                 hir_id: self.next_id(),\n                 span,\n                 name: hir::LifetimeName::Implicit,\n-            })\n-        }));\n+            })));\n+        let generic_args = self.arena.alloc_from_iter(generic_args);\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n+        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n-        hir::FunctionRetTy::Return(P(opaque_ty))\n+        hir::FunctionRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n \n     /// Transforms `-> T` into `Future<Output = T>`\n@@ -2388,13 +2387,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n             FunctionRetTy::Ty(ty) => self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id))),\n-            FunctionRetTy::Default(ret_ty_span) => P(self.ty_tup(*ret_ty_span, hir_vec![])),\n+            FunctionRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n         };\n \n         // \"<Output = T>\"\n-        let future_params = P(hir::GenericArgs {\n-            args: hir_vec![],\n-            bindings: hir_vec![hir::TypeBinding {\n+        let future_params = self.arena.alloc(hir::GenericArgs {\n+            args: HirVec::new(),\n+            bindings: arena_vec![self; hir::TypeBinding {\n                 ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 kind: hir::TypeBindingKind::Equality { ty: output_ty },\n                 hir_id: self.next_id(),\n@@ -2404,13 +2403,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         });\n \n         // ::std::future::Future<future_params>\n-        let future_path =\n-            P(self.std_path(span, &[sym::future, sym::Future], Some(future_params), false));\n+        let future_path = self.arena.alloc(self.std_path(\n+            span,\n+            &[sym::future, sym::Future],\n+            Some(future_params),\n+            false,\n+        ));\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n                 trait_ref: hir::TraitRef { path: future_path, hir_ref_id: self.next_id() },\n-                bound_generic_params: hir_vec![],\n+                bound_generic_params: &[],\n                 span,\n             },\n             hir::TraitBoundModifier::None,\n@@ -2420,7 +2423,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::GenericBound<'hir> {\n         match *tpb {\n             GenericBound::Trait(ref ty, modifier) => hir::GenericBound::Trait(\n@@ -2472,8 +2475,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         params: &[GenericParam],\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n-        mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::HirVec<hir::GenericParam<'hir>> {\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> HirVec<hir::GenericParam<'hir>> {\n         params\n             .iter()\n             .map(|param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n@@ -2484,11 +2487,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         param: &GenericParam,\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n-        mut itctx: ImplTraitContext<'_>,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::GenericParam<'hir> {\n         let mut bounds = self\n             .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n-                this.lower_param_bounds(&param.bounds, itctx.reborrow())\n+                this.lower_param_bounds_mut(&param.bounds, itctx.reborrow())\n             });\n \n         let (name, kind) = match param.kind {\n@@ -2524,8 +2527,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericParamKind::Type { ref default, .. } => {\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n-                    let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n-                    bounds = bounds.into_iter().chain(params).collect();\n+                    let params = self.lower_param_bounds_mut(add_bounds, itctx.reborrow());\n+                    bounds.extend(params);\n                 }\n \n                 let kind = hir::GenericParamKind::Type {\n@@ -2555,16 +2558,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             name,\n             span: param.ident.span,\n             pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n-            attrs: self.lower_attrs(&param.attrs),\n-            bounds,\n+            attrs: self.lower_attrs_arena(&param.attrs),\n+            bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n     }\n \n     fn lower_trait_ref(\n         &mut self,\n         p: &TraitRef,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n@@ -2576,7 +2579,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_poly_trait_ref(\n         &mut self,\n         p: &PolyTraitRef,\n-        mut itctx: ImplTraitContext<'_>,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PolyTraitRef<'hir> {\n         let bound_generic_params = self.lower_generic_params(\n             &p.bound_generic_params,\n@@ -2587,18 +2590,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             this.lower_trait_ref(&p.trait_ref, itctx)\n         });\n \n-        hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }\n+        hir::PolyTraitRef {\n+            bound_generic_params: self.arena.alloc_from_iter(bound_generic_params.into_iter()),\n+            trait_ref,\n+            span: p.span,\n+        }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy<'hir> {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_, 'hir>) -> hir::MutTy<'hir> {\n         hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n     fn lower_param_bounds(\n         &mut self,\n         bounds: &[GenericBound],\n-        mut itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::GenericBounds<'hir> {\n+        self.arena.alloc_from_iter(self.lower_param_bounds_mut(bounds, itctx))\n+    }\n+\n+    fn lower_param_bounds_mut(\n+        &mut self,\n+        bounds: &[GenericBound],\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> Vec<hir::GenericBound<'hir>> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n@@ -2836,10 +2851,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n                 None,\n-                P(hir::Path {\n+                self.arena.alloc(hir::Path {\n                     span: ident.span,\n                     res: self.lower_res(res),\n-                    segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n                 }),\n             )),\n         }\n@@ -3035,7 +3050,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         subpats: &'hir [&'hir hir::Pat<'hir>],\n     ) -> &'hir hir::Pat<'hir> {\n         let path = self.std_path(span, components, None, true);\n-        let qpath = hir::QPath::Resolved(None, P(path));\n+        let qpath = hir::QPath::Resolved(None, self.arena.alloc(path));\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n         } else {\n@@ -3081,7 +3096,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        params: Option<P<hir::GenericArgs<'hir>>>,\n+        params: Option<&'hir hir::GenericArgs<'hir>>,\n         is_value: bool,\n     ) -> hir::Path<'hir> {\n         let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n@@ -3106,7 +3121,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Path {\n             span,\n             res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n-            segments: segments.into(),\n+            segments: self.arena.alloc_from_iter(segments),\n         }\n     }\n \n@@ -3122,15 +3137,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 match path.res {\n                     Res::Def(DefKind::Trait, _) | Res::Def(DefKind::TraitAlias, _) => {\n                         let principal = hir::PolyTraitRef {\n-                            bound_generic_params: hir::HirVec::new(),\n+                            bound_generic_params: &[],\n                             trait_ref: hir::TraitRef { path, hir_ref_id: hir_id },\n                             span,\n                         };\n \n                         // The original ID is taken by the `PolyTraitRef`,\n                         // so the `Ty` itself needs a different one.\n                         hir_id = self.next_id();\n-                        hir::TyKind::TraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n+                        hir::TyKind::TraitObject(\n+                            arena_vec![self; principal],\n+                            self.elided_dyn_bound(span),\n+                        )\n                     }\n                     _ => hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 }"}, {"sha": "c32cfdd07e0b867d3a1313e3d0883e1e46fd42ef", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=c737c0702134888a88cb847c5286c600a78ffea9", "patch": "@@ -1,7 +1,6 @@\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::hir;\n use crate::hir::def::Res;\n-use crate::hir::ptr::P;\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -64,12 +63,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = self.lower_expr(expr);\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                hir::ExprKind::Cast(expr, self.arena.alloc(ty.into_inner()))\n+                hir::ExprKind::Cast(expr, ty)\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = self.lower_expr(expr);\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                hir::ExprKind::Type(expr, self.arena.alloc(ty.into_inner()))\n+                hir::ExprKind::Type(expr, ty)\n             }\n             ExprKind::AddrOf(k, m, ref ohs) => {\n                 let ohs = self.lower_expr(ohs);\n@@ -490,9 +489,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             None => FunctionRetTy::Default(span),\n         };\n         let ast_decl = FnDecl { inputs: vec![], output };\n-        let decl = self.arena.alloc(\n-            self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None).into_inner(),\n-        );\n+        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n             this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n             body(this)\n@@ -670,7 +667,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n-        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n         self.with_new_scopes(move |this| {\n             let prev = this.current_item;\n@@ -733,7 +729,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n         let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n-        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n         self.with_new_scopes(move |this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n@@ -816,7 +811,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let is_unit = fields.is_empty();\n         let struct_path = [sym::ops, path];\n         let struct_path = self.std_path(span, &struct_path, None, is_unit);\n-        let struct_path = hir::QPath::Resolved(None, P(struct_path));\n+        let struct_path = hir::QPath::Resolved(None, self.arena.alloc(struct_path));\n \n         if is_unit {\n             hir::ExprKind::Path(struct_path)\n@@ -1325,9 +1320,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         assoc_fn_name: &str,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::ExprKind<'hir> {\n-        let ty_path = P(self.std_path(span, ty_path_components, None, false));\n-        let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n-        let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n+        let ty_path = self.arena.alloc(self.std_path(span, ty_path_components, None, false));\n+        let ty =\n+            self.arena.alloc(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n+        let fn_seg = self.arena.alloc(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n         let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n         let fn_expr =\n             self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n@@ -1338,11 +1334,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        params: Option<P<hir::GenericArgs<'hir>>>,\n+        params: Option<&'hir hir::GenericArgs<'hir>>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         let path = self.std_path(span, components, params, true);\n-        self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))), attrs)\n+        self.expr(\n+            span,\n+            hir::ExprKind::Path(hir::QPath::Resolved(None, self.arena.alloc(path))),\n+            attrs,\n+        )\n     }\n \n     pub(super) fn expr_ident(\n@@ -1372,10 +1372,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::Expr<'hir> {\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n-            P(hir::Path {\n+            self.arena.alloc(hir::Path {\n                 span,\n                 res: Res::Local(binding),\n-                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n             }),\n         ));\n "}, {"sha": "2fd59c4a1b114dd0062acb5d89df3d59680a34e2", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=c737c0702134888a88cb847c5286c600a78ffea9", "patch": "@@ -8,7 +8,6 @@ use super::ParamMode;\n use crate::hir;\n use crate::hir::def::{DefKind, Res};\n use crate::hir::def_id::DefId;\n-use crate::hir::ptr::P;\n use crate::util::nodemap::NodeMap;\n \n use rustc_target::spec::abi;\n@@ -278,11 +277,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     },\n                 );\n-                hir::ItemKind::Static(\n-                    self.arena.alloc(ty.into_inner()),\n-                    m,\n-                    self.lower_const_body(span, Some(e)),\n-                )\n+                hir::ItemKind::Static(ty, m, self.lower_const_body(span, Some(e)))\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let ty = self.lower_ty(\n@@ -293,10 +288,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     },\n                 );\n-                hir::ItemKind::Const(\n-                    self.arena.alloc(ty.into_inner()),\n-                    self.lower_const_body(span, Some(e)),\n-                )\n+                hir::ItemKind::Const(ty, self.lower_const_body(span, Some(e)))\n             }\n             ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -323,7 +315,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             )\n                         },\n                     );\n-                    let decl = this.arena.alloc(decl.into_inner());\n                     let sig = hir::FnSig { decl, header: this.lower_fn_header(header) };\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n@@ -335,7 +326,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 None => {\n                     let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                     let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n-                    hir::ItemKind::TyAlias(self.arena.alloc(ty.into_inner()), generics)\n+                    hir::ItemKind::TyAlias(ty, generics)\n                 }\n                 Some(bounds) => {\n                     let ty = hir::OpaqueTy {\n@@ -431,7 +422,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_defaultness(defaultness, true /* [1] */),\n                     generics,\n                     trait_ref,\n-                    self.arena.alloc(lowered_ty.into_inner()),\n+                    lowered_ty,\n                     new_impl_items,\n                 )\n             }\n@@ -637,17 +628,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// `NodeId`s. (See, e.g., #56128.)\n     fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> hir::Path<'hir> {\n         debug!(\"rebuild_use_path(path = {:?})\", path);\n-        let segments = path\n-            .segments\n-            .iter()\n-            .map(|seg| hir::PathSegment {\n+        let segments =\n+            self.arena.alloc_from_iter(path.segments.iter().map(|seg| hir::PathSegment {\n                 ident: seg.ident,\n                 hir_id: seg.hir_id.map(|_| self.next_id()),\n                 res: seg.res,\n                 args: None,\n                 infer_args: seg.infer_args,\n-            })\n-            .collect();\n+            }));\n         hir::Path { span: path.span, res: path.res, segments }\n     }\n \n@@ -658,7 +646,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n             hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                 hir::VisibilityKind::Restricted {\n-                    path: P(self.rebuild_use_path(path)),\n+                    path: self.arena.alloc(self.rebuild_use_path(path)),\n                     hir_id: self.next_id(),\n                 }\n             }\n@@ -686,14 +674,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             )\n                         },\n                     );\n-                    let fn_dec = self.arena.alloc(fn_dec.into_inner());\n                     let fn_args = self.arena.alloc_from_iter(fn_args.into_iter());\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n                     let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n-                    hir::ForeignItemKind::Static(self.arena.alloc(ty.into_inner()), m)\n+                    hir::ForeignItemKind::Static(ty, m)\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n@@ -752,8 +739,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             );\n             self.arena.alloc(t)\n         } else {\n-            let t = self.lower_ty(&f.ty, ImplTraitContext::disallowed());\n-            self.arena.alloc(t.into_inner())\n+            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n         };\n         hir::StructField {\n             span: f.span,\n@@ -776,7 +762,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Const(ref ty, ref default) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                let ty = self.arena.alloc(ty.into_inner());\n                 (\n                     generics,\n                     hir::TraitItemKind::Const(\n@@ -799,11 +784,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(ref bounds, ref default) => {\n-                let ty = default.as_ref().map(|x| {\n-                    &*self\n-                        .arena\n-                        .alloc(self.lower_ty(x, ImplTraitContext::disallowed()).into_inner())\n-                });\n+                let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n@@ -855,7 +836,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Const(ref ty, ref expr) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                let ty = self.arena.alloc(ty.into_inner());\n                 (\n                     generics,\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -890,7 +870,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     Some(ty) => match ty.kind.opaque_top_hack() {\n                         None => {\n                             let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                            let ty = self.arena.alloc(ty.into_inner());\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                         Some(bs) => {\n@@ -966,7 +945,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let res = self.expect_full_res(id);\n                 let res = self.lower_res(res);\n                 hir::VisibilityKind::Restricted {\n-                    path: P(self.lower_path_extra(res, path, ParamMode::Explicit, explicit_owner)),\n+                    path: self.arena.alloc(self.lower_path_extra(\n+                        res,\n+                        path,\n+                        ParamMode::Explicit,\n+                        explicit_owner,\n+                    )),\n                     hir_id: lowered_id,\n                 }\n             }\n@@ -1270,7 +1254,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 )\n             },\n         );\n-        let decl = self.arena.alloc(decl.into_inner());\n         (generics, hir::FnSig { header, decl })\n     }\n \n@@ -1315,7 +1298,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_generics(\n         &mut self,\n         generics: &Generics,\n-        itctx: ImplTraitContext<'_>,\n+        itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::Generics<'hir> {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         // FIXME: this could probably be done with less rightward drift. It also looks like two\n@@ -1382,11 +1365,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n         self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n             hir::WhereClause {\n-                predicates: wc\n-                    .predicates\n-                    .iter()\n-                    .map(|predicate| this.lower_where_predicate(predicate))\n-                    .collect(),\n+                predicates: this.arena.alloc_from_iter(\n+                    wc.predicates.iter().map(|predicate| this.lower_where_predicate(predicate)),\n+                ),\n                 span: wc.span,\n             }\n         })\n@@ -1402,23 +1383,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }) => {\n                 self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n                     hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                        bound_generic_params: this.lower_generic_params(\n-                            bound_generic_params,\n-                            &NodeMap::default(),\n-                            ImplTraitContext::disallowed(),\n+                        bound_generic_params: this.arena.alloc_from_iter(\n+                            this.lower_generic_params(\n+                                bound_generic_params,\n+                                &NodeMap::default(),\n+                                ImplTraitContext::disallowed(),\n+                            )\n+                            .into_iter(),\n                         ),\n                         bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n-                        bounds: bounds\n-                            .iter()\n-                            .filter_map(|bound| match *bound {\n+                        bounds: this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| {\n+                            match *bound {\n                                 // Ignore `?Trait` bounds.\n                                 // They were copied into type parameters already.\n                                 GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n                                 _ => Some(\n                                     this.lower_param_bound(bound, ImplTraitContext::disallowed()),\n                                 ),\n-                            })\n-                            .collect(),\n+                            }\n+                        })),\n                         span,\n                     })\n                 })"}, {"sha": "13ae89e77b26cc1ad7a75cd5a8a336c22bbf4ec9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c737c0702134888a88cb847c5286c600a78ffea9", "patch": "@@ -364,22 +364,6 @@ impl<'hir> PathSegment<'hir> {\n         PathSegment { ident, hir_id: None, res: None, infer_args: true, args: None }\n     }\n \n-    pub fn new(\n-        ident: Ident,\n-        hir_id: Option<HirId>,\n-        res: Option<Res>,\n-        args: GenericArgs<'_>,\n-        infer_args: bool,\n-    ) -> Self {\n-        PathSegment {\n-            ident,\n-            hir_id,\n-            res,\n-            infer_args,\n-            args: if args.is_empty() { None } else { Some(P(args)) },\n-        }\n-    }\n-\n     pub fn generic_args(&self) -> &GenericArgs<'hir> {\n         if let Some(ref args) = self.args {\n             args"}, {"sha": "b43817c9601b305b0053125f86444a3235df6962", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c737c0702134888a88cb847c5286c600a78ffea9/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=c737c0702134888a88cb847c5286c600a78ffea9", "patch": "@@ -22,14 +22,6 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n     P { ptr: box value }\n }\n \n-impl<T: 'static> P<T> {\n-    // HACK(eddyb) used by HIR lowering in a few places still.\n-    // NOTE: do not make this more public than `pub(super)`.\n-    pub(super) fn into_inner(self) -> T {\n-        *self.ptr\n-    }\n-}\n-\n impl<T: ?Sized> Deref for P<T> {\n     type Target = T;\n "}]}