{"sha": "2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "node_id": "C_kwDOAAsO6NoAKDJlMmMzOGU1OWJlN2QwMzA4YzhhNThjMDg0M2U3YWY4ZDcyMTFlZTc", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2021-10-10T18:02:42Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2021-10-10T18:13:39Z"}, "message": "Mark `Arc::from_inner` / `Rc::from_inner` as unsafe\n\nWhile it's an internal function, it is easy to create invalid Arc/Rcs to\na dangling pointer with it.\n\nFixes https://github.com/rust-lang/rust/issues/89740", "tree": {"sha": "31dcedc218004f0a08258940679967a34de3d623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31dcedc218004f0a08258940679967a34de3d623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "html_url": "https://github.com/rust-lang/rust/commit/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c87288f92b7e6365d61cfbcbc453ea4c696c030", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c87288f92b7e6365d61cfbcbc453ea4c696c030", "html_url": "https://github.com/rust-lang/rust/commit/0c87288f92b7e6365d61cfbcbc453ea4c696c030"}], "stats": {"total": 77, "additions": 45, "deletions": 32}, "files": [{"sha": "eff20efccc8be180bfb8cfa4077838213261f36e", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "patch": "@@ -333,12 +333,12 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { self.ptr.as_ref() }\n     }\n \n-    fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n+    unsafe fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n         Self { ptr, phantom: PhantomData }\n     }\n \n     unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n-        Self::from_inner(unsafe { NonNull::new_unchecked(ptr) })\n+        unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }\n     }\n }\n \n@@ -359,9 +359,11 @@ impl<T> Rc<T> {\n         // pointers, which ensures that the weak destructor never frees\n         // the allocation while the strong destructor is running, even\n         // if the weak pointer is stored inside the strong one.\n-        Self::from_inner(\n-            Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),\n-        )\n+        unsafe {\n+            Self::from_inner(\n+                Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),\n+            )\n+        }\n     }\n \n     /// Constructs a new `Rc<T>` using a weak reference to itself. Attempting\n@@ -412,16 +414,16 @@ impl<T> Rc<T> {\n         // otherwise.\n         let data = data_fn(&weak);\n \n-        unsafe {\n+        let strong = unsafe {\n             let inner = init_ptr.as_ptr();\n             ptr::write(ptr::addr_of_mut!((*inner).value), data);\n \n             let prev_value = (*inner).strong.get();\n             debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n             (*inner).strong.set(1);\n-        }\n \n-        let strong = Rc::from_inner(init_ptr);\n+            Rc::from_inner(init_ptr)\n+        };\n \n         // Strong references should collectively own a shared weak reference,\n         // so don't run the destructor for our old weak reference.\n@@ -511,10 +513,12 @@ impl<T> Rc<T> {\n         // pointers, which ensures that the weak destructor never frees\n         // the allocation while the strong destructor is running, even\n         // if the weak pointer is stored inside the strong one.\n-        Ok(Self::from_inner(\n-            Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n-                .into(),\n-        ))\n+        unsafe {\n+            Ok(Self::from_inner(\n+                Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n+                    .into(),\n+            ))\n+        }\n     }\n \n     /// Constructs a new `Rc` with uninitialized contents, returning an error if the allocation fails\n@@ -733,7 +737,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Rc<T> {\n-        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+        unsafe { Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast()) }\n     }\n }\n \n@@ -1199,9 +1203,11 @@ impl Rc<dyn Any> {\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {\n-            let ptr = self.ptr.cast::<RcBox<T>>();\n-            forget(self);\n-            Ok(Rc::from_inner(ptr))\n+            unsafe {\n+                let ptr = self.ptr.cast::<RcBox<T>>();\n+                forget(self);\n+                Ok(Rc::from_inner(ptr))\n+            }\n         } else {\n             Err(self)\n         }\n@@ -1474,8 +1480,10 @@ impl<T: ?Sized> Clone for Rc<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n-        self.inner().inc_strong();\n-        Self::from_inner(self.ptr)\n+        unsafe {\n+            self.inner().inc_strong();\n+            Self::from_inner(self.ptr)\n+        }\n     }\n }\n \n@@ -2225,11 +2233,14 @@ impl<T: ?Sized> Weak<T> {\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         let inner = self.inner()?;\n+\n         if inner.strong() == 0 {\n             None\n         } else {\n-            inner.inc_strong();\n-            Some(Rc::from_inner(self.ptr))\n+            unsafe {\n+                inner.inc_strong();\n+                Some(Rc::from_inner(self.ptr))\n+            }\n         }\n     }\n "}, {"sha": "258557acdaa99026d26e6fddc88eaf34254a7447", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "patch": "@@ -252,7 +252,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Arc<U>> for Arc<T> {}\n \n impl<T: ?Sized> Arc<T> {\n-    fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {\n+    unsafe fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {\n         Self { ptr, phantom: PhantomData }\n     }\n \n@@ -348,7 +348,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         };\n-        Self::from_inner(Box::leak(x).into())\n+        unsafe { Self::from_inner(Box::leak(x).into()) }\n     }\n \n     /// Constructs a new `Arc<T>` using a weak reference to itself. Attempting\n@@ -397,7 +397,7 @@ impl<T> Arc<T> {\n \n         // Now we can properly initialize the inner value and turn our weak\n         // reference into a strong reference.\n-        unsafe {\n+        let strong = unsafe {\n             let inner = init_ptr.as_ptr();\n             ptr::write(ptr::addr_of_mut!((*inner).data), data);\n \n@@ -415,9 +415,9 @@ impl<T> Arc<T> {\n             // possible with safe code alone.\n             let prev_value = (*inner).strong.fetch_add(1, Release);\n             debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n-        }\n \n-        let strong = Arc::from_inner(init_ptr);\n+            Arc::from_inner(init_ptr)\n+        };\n \n         // Strong references should collectively own a shared weak reference,\n         // so don't run the destructor for our old weak reference.\n@@ -526,7 +526,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         })?;\n-        Ok(Self::from_inner(Box::leak(x).into()))\n+        unsafe { Ok(Self::from_inner(Box::leak(x).into())) }\n     }\n \n     /// Constructs a new `Arc` with uninitialized contents, returning an error\n@@ -737,7 +737,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Arc<T> {\n-        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+        unsafe { Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast()) }\n     }\n }\n \n@@ -1327,7 +1327,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n             abort();\n         }\n \n-        Self::from_inner(self.ptr)\n+        unsafe { Self::from_inner(self.ptr) }\n     }\n }\n \n@@ -1654,9 +1654,11 @@ impl Arc<dyn Any + Send + Sync> {\n         T: Any + Send + Sync + 'static,\n     {\n         if (*self).is::<T>() {\n-            let ptr = self.ptr.cast::<ArcInner<T>>();\n-            mem::forget(self);\n-            Ok(Arc::from_inner(ptr))\n+            unsafe {\n+                let ptr = self.ptr.cast::<ArcInner<T>>();\n+                mem::forget(self);\n+                Ok(Arc::from_inner(ptr))\n+            }\n         } else {\n             Err(self)\n         }\n@@ -1880,7 +1882,7 @@ impl<T: ?Sized> Weak<T> {\n             // value can be initialized after `Weak` references have already been created. In that case, we\n             // expect to observe the fully initialized value.\n             match inner.strong.compare_exchange_weak(n, n + 1, Acquire, Relaxed) {\n-                Ok(_) => return Some(Arc::from_inner(self.ptr)), // null checked above\n+                Ok(_) => return Some(unsafe { Arc::from_inner(self.ptr) }), // null checked above\n                 Err(old) => n = old,\n             }\n         }"}]}