{"sha": "2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkODgyMDc4NTNhMzhmYTNmNzNjMDNlZjFmOWQ1YTFiOGNlOTkyNGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T10:46:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "reshuffle", "tree": {"sha": "744ec60e60884684f391a2e8f4f99c9030b30dc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/744ec60e60884684f391a2e8f4f99c9030b30dc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "html_url": "https://github.com/rust-lang/rust/commit/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce3636798bc9481ec712b84b5cad9973b7844425", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3636798bc9481ec712b84b5cad9973b7844425", "html_url": "https://github.com/rust-lang/rust/commit/ce3636798bc9481ec712b84b5cad9973b7844425"}], "stats": {"total": 410, "additions": 210, "deletions": 200}, "files": [{"sha": "8c284fa719c4a7676c8cea03f15fe83ba240a08f", "filename": "crates/ra_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/crates%2Fra_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/crates%2Fra_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Flib.rs?ref=2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "patch": "@@ -12,3 +12,4 @@ macro_rules! impl_froms {\n \n pub mod tt;\n pub mod mbe;\n+mod mbe_parser;"}, {"sha": "72d6707aa12e8dc72d80040adee240319ee4f00f", "filename": "crates/ra_macros/src/mbe.rs", "status": "modified", "additions": 25, "deletions": 200, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/crates%2Fra_macros%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/crates%2Fra_macros%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe.rs?ref=2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "patch": "@@ -2,27 +2,29 @@ use smol_str::SmolStr;\n \n use crate::tt::{self, Delimiter};\n \n+pub use crate::mbe_parser::parse;\n+\n #[derive(Debug)]\n pub struct MacroRules {\n-    rules: Vec<Rule>,\n+    pub(crate) rules: Vec<Rule>,\n }\n \n #[derive(Debug)]\n-struct Rule {\n-    lhs: Subtree,\n-    rhs: Subtree,\n+pub(crate) struct Rule {\n+    pub(crate) lhs: Subtree,\n+    pub(crate) rhs: Subtree,\n }\n \n #[derive(Debug)]\n-enum TokenTree {\n+pub(crate) enum TokenTree {\n     Leaf(Leaf),\n     Subtree(Subtree),\n     Repeat(Repeat),\n }\n impl_froms!(TokenTree: Leaf, Subtree, Repeat);\n \n #[derive(Debug)]\n-enum Leaf {\n+pub(crate) enum Leaf {\n     Literal(Literal),\n     Punct(Punct),\n     Ident(Ident),\n@@ -31,219 +33,42 @@ enum Leaf {\n impl_froms!(Leaf: Literal, Punct, Ident, Var);\n \n #[derive(Debug)]\n-struct Subtree {\n-    delimiter: Delimiter,\n-    token_trees: Vec<TokenTree>,\n+pub(crate) struct Subtree {\n+    pub(crate) delimiter: Delimiter,\n+    pub(crate) token_trees: Vec<TokenTree>,\n }\n \n #[derive(Debug)]\n-struct Repeat {\n-    subtree: Subtree,\n-    kind: RepeatKind,\n-    separator: Option<Punct>,\n+pub(crate) struct Repeat {\n+    pub(crate) subtree: Subtree,\n+    pub(crate) kind: RepeatKind,\n+    pub(crate) separator: Option<Punct>,\n }\n \n #[derive(Debug)]\n-enum RepeatKind {\n+pub(crate) enum RepeatKind {\n     ZeroOrMore,\n     OneOrMore,\n     ZeroOrOne,\n }\n \n #[derive(Debug)]\n-struct Literal {\n-    text: SmolStr,\n+pub(crate) struct Literal {\n+    pub(crate) text: SmolStr,\n }\n \n #[derive(Debug)]\n-struct Punct {\n-    char: char,\n+pub(crate) struct Punct {\n+    pub(crate) char: char,\n }\n \n #[derive(Debug)]\n-struct Ident {\n-    text: SmolStr,\n+pub(crate) struct Ident {\n+    pub(crate) text: SmolStr,\n }\n \n #[derive(Debug)]\n-struct Var {\n-    text: SmolStr,\n-    kind: Option<SmolStr>,\n-}\n-\n-pub fn parse(tt: &tt::Subtree) -> Option<MacroRules> {\n-    let mut parser = RulesParser::new(tt);\n-    let mut rules = Vec::new();\n-    while !parser.is_eof() {\n-        rules.push(parse_rule(&mut parser)?)\n-    }\n-    Some(MacroRules { rules })\n-}\n-\n-fn parse_rule(p: &mut RulesParser) -> Option<Rule> {\n-    let lhs = parse_subtree(p.eat_subtree()?)?;\n-    p.expect_char('=')?;\n-    p.expect_char('>')?;\n-    let rhs = parse_subtree(p.eat_subtree()?)?;\n-    Some(Rule { lhs, rhs })\n-}\n-\n-fn parse_subtree(tt: &tt::Subtree) -> Option<Subtree> {\n-    let mut token_trees = Vec::new();\n-    let mut p = RulesParser::new(tt);\n-    while let Some(tt) = p.eat() {\n-        let child: TokenTree = match tt {\n-            tt::TokenTree::Leaf(leaf) => match leaf {\n-                tt::Leaf::Punct(tt::Punct { char: '$' }) => {\n-                    if p.at_ident().is_some() {\n-                        Leaf::from(parse_var(&mut p)?).into()\n-                    } else {\n-                        parse_repeat(&mut p)?.into()\n-                    }\n-                }\n-                tt::Leaf::Punct(tt::Punct { char }) => Leaf::from(Punct { char: *char }).into(),\n-                tt::Leaf::Ident(tt::Ident { text }) => {\n-                    Leaf::from(Ident { text: text.clone() }).into()\n-                }\n-                tt::Leaf::Literal(tt::Literal { text }) => {\n-                    Leaf::from(Literal { text: text.clone() }).into()\n-                }\n-            },\n-            tt::TokenTree::Subtree(subtree) => parse_subtree(subtree)?.into(),\n-        };\n-        token_trees.push(child);\n-    }\n-    Some(Subtree {\n-        token_trees,\n-        delimiter: tt.delimiter,\n-    })\n-}\n-\n-fn parse_var(p: &mut RulesParser) -> Option<Var> {\n-    let ident = p.eat_ident().unwrap();\n-    let text = ident.text.clone();\n-    let kind = if p.at_char(':') {\n-        p.bump();\n-        if let Some(ident) = p.eat_ident() {\n-            Some(ident.text.clone())\n-        } else {\n-            // ugly as hell :(\n-            p.pos -= 1;\n-            None\n-        }\n-    } else {\n-        None\n-    };\n-    Some(Var { text, kind })\n-}\n-\n-fn parse_repeat(p: &mut RulesParser) -> Option<Repeat> {\n-    let subtree = p.eat_subtree().unwrap();\n-    let subtree = parse_subtree(subtree)?;\n-    let sep = p.eat_punct()?;\n-    let (separator, rep) = match sep.char {\n-        '*' | '+' | '?' => (None, sep.char),\n-        char => (Some(Punct { char }), p.eat_punct()?.char),\n-    };\n-\n-    let kind = match rep {\n-        '*' => RepeatKind::ZeroOrMore,\n-        '+' => RepeatKind::OneOrMore,\n-        '?' => RepeatKind::ZeroOrMore,\n-        _ => return None,\n-    };\n-    p.bump();\n-    Some(Repeat {\n-        subtree,\n-        kind,\n-        separator,\n-    })\n-}\n-\n-struct RulesParser<'a> {\n-    subtree: &'a tt::Subtree,\n-    pos: usize,\n-}\n-\n-impl<'a> RulesParser<'a> {\n-    fn new(subtree: &'a tt::Subtree) -> RulesParser<'a> {\n-        RulesParser { subtree, pos: 0 }\n-    }\n-\n-    fn is_eof(&self) -> bool {\n-        self.pos == self.subtree.token_trees.len()\n-    }\n-\n-    fn current(&self) -> Option<&'a tt::TokenTree> {\n-        self.subtree.token_trees.get(self.pos)\n-    }\n-\n-    fn at_punct(&self) -> Option<&'a tt::Punct> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    fn at_char(&self, char: char) -> bool {\n-        match self.at_punct() {\n-            Some(tt::Punct { char: c }) if *c == char => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n-            _ => None,\n-        }\n-    }\n-\n-    fn bump(&mut self) {\n-        self.pos += 1;\n-    }\n-\n-    fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n-        match self.current() {\n-            Some(it) => {\n-                self.bump();\n-                Some(it)\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n-        match self.current()? {\n-            tt::TokenTree::Subtree(sub) => {\n-                self.bump();\n-                Some(sub)\n-            }\n-            _ => return None,\n-        }\n-    }\n-\n-    fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n-        if let Some(it) = self.at_punct() {\n-            self.bump();\n-            return Some(it);\n-        }\n-        None\n-    }\n-\n-    fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n-        if let Some(i) = self.at_ident() {\n-            self.bump();\n-            return Some(i);\n-        }\n-        None\n-    }\n-\n-    fn expect_char(&mut self, char: char) -> Option<()> {\n-        if self.at_char(char) {\n-            self.bump();\n-            return Some(());\n-        }\n-        None\n-    }\n+pub(crate) struct Var {\n+    pub(crate) text: SmolStr,\n+    pub(crate) kind: Option<SmolStr>,\n }"}, {"sha": "93c2d40b4a77aaf4cd6f035e992ddbf1b632549c", "filename": "crates/ra_macros/src/mbe_parser.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs?ref=2d88207853a38fa3f73c03ef1f9d5a1b8ce9924a", "patch": "@@ -0,0 +1,184 @@\n+use crate::{tt, mbe};\n+\n+/// This module parses a raw `tt::TokenStream` into macro-by-example token\n+/// stream. This is a *mostly* identify function, expect for handling of\n+/// `$var:tt_kind` and `$(repeat),*` constructs.\n+\n+struct RulesParser<'a> {\n+    subtree: &'a tt::Subtree,\n+    pos: usize,\n+}\n+\n+impl<'a> RulesParser<'a> {\n+    fn new(subtree: &'a tt::Subtree) -> RulesParser<'a> {\n+        RulesParser { subtree, pos: 0 }\n+    }\n+\n+    fn is_eof(&self) -> bool {\n+        self.pos == self.subtree.token_trees.len()\n+    }\n+\n+    fn current(&self) -> Option<&'a tt::TokenTree> {\n+        self.subtree.token_trees.get(self.pos)\n+    }\n+\n+    fn at_punct(&self) -> Option<&'a tt::Punct> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn at_char(&self, char: char) -> bool {\n+        match self.at_punct() {\n+            Some(tt::Punct { char: c }) if *c == char => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n+            _ => None,\n+        }\n+    }\n+\n+    fn bump(&mut self) {\n+        self.pos += 1;\n+    }\n+\n+    fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n+        match self.current() {\n+            Some(it) => {\n+                self.bump();\n+                Some(it)\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n+        match self.current()? {\n+            tt::TokenTree::Subtree(sub) => {\n+                self.bump();\n+                Some(sub)\n+            }\n+            _ => return None,\n+        }\n+    }\n+\n+    fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n+        if let Some(it) = self.at_punct() {\n+            self.bump();\n+            return Some(it);\n+        }\n+        None\n+    }\n+\n+    fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n+        if let Some(i) = self.at_ident() {\n+            self.bump();\n+            return Some(i);\n+        }\n+        None\n+    }\n+\n+    fn expect_char(&mut self, char: char) -> Option<()> {\n+        if self.at_char(char) {\n+            self.bump();\n+            return Some(());\n+        }\n+        None\n+    }\n+}\n+\n+pub fn parse(tt: &tt::Subtree) -> Option<mbe::MacroRules> {\n+    let mut parser = RulesParser::new(tt);\n+    let mut rules = Vec::new();\n+    while !parser.is_eof() {\n+        rules.push(parse_rule(&mut parser)?)\n+    }\n+    Some(mbe::MacroRules { rules })\n+}\n+\n+fn parse_rule(p: &mut RulesParser) -> Option<mbe::Rule> {\n+    let lhs = parse_subtree(p.eat_subtree()?)?;\n+    p.expect_char('=')?;\n+    p.expect_char('>')?;\n+    let rhs = parse_subtree(p.eat_subtree()?)?;\n+    Some(mbe::Rule { lhs, rhs })\n+}\n+\n+fn parse_subtree(tt: &tt::Subtree) -> Option<mbe::Subtree> {\n+    let mut token_trees = Vec::new();\n+    let mut p = RulesParser::new(tt);\n+    while let Some(tt) = p.eat() {\n+        let child: mbe::TokenTree = match tt {\n+            tt::TokenTree::Leaf(leaf) => match leaf {\n+                tt::Leaf::Punct(tt::Punct { char: '$' }) => {\n+                    if p.at_ident().is_some() {\n+                        mbe::Leaf::from(parse_var(&mut p)?).into()\n+                    } else {\n+                        parse_repeat(&mut p)?.into()\n+                    }\n+                }\n+                tt::Leaf::Punct(tt::Punct { char }) => {\n+                    mbe::Leaf::from(mbe::Punct { char: *char }).into()\n+                }\n+                tt::Leaf::Ident(tt::Ident { text }) => {\n+                    mbe::Leaf::from(mbe::Ident { text: text.clone() }).into()\n+                }\n+                tt::Leaf::Literal(tt::Literal { text }) => {\n+                    mbe::Leaf::from(mbe::Literal { text: text.clone() }).into()\n+                }\n+            },\n+            tt::TokenTree::Subtree(subtree) => parse_subtree(subtree)?.into(),\n+        };\n+        token_trees.push(child);\n+    }\n+    Some(mbe::Subtree {\n+        token_trees,\n+        delimiter: tt.delimiter,\n+    })\n+}\n+\n+fn parse_var(p: &mut RulesParser) -> Option<mbe::Var> {\n+    let ident = p.eat_ident().unwrap();\n+    let text = ident.text.clone();\n+    let kind = if p.at_char(':') {\n+        p.bump();\n+        if let Some(ident) = p.eat_ident() {\n+            Some(ident.text.clone())\n+        } else {\n+            // ugly as hell :(\n+            p.pos -= 1;\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+    Some(mbe::Var { text, kind })\n+}\n+\n+fn parse_repeat(p: &mut RulesParser) -> Option<mbe::Repeat> {\n+    let subtree = p.eat_subtree().unwrap();\n+    let subtree = parse_subtree(subtree)?;\n+    let sep = p.eat_punct()?;\n+    let (separator, rep) = match sep.char {\n+        '*' | '+' | '?' => (None, sep.char),\n+        char => (Some(mbe::Punct { char }), p.eat_punct()?.char),\n+    };\n+\n+    let kind = match rep {\n+        '*' => mbe::RepeatKind::ZeroOrMore,\n+        '+' => mbe::RepeatKind::OneOrMore,\n+        '?' => mbe::RepeatKind::ZeroOrMore,\n+        _ => return None,\n+    };\n+    p.bump();\n+    Some(mbe::Repeat {\n+        subtree,\n+        kind,\n+        separator,\n+    })\n+}"}]}