{"sha": "6a901409410fc2fbc6722eb7b352008135252cec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOTAxNDA5NDEwZmMyZmJjNjcyMmViN2IzNTIwMDgxMzUyNTJjZWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-20T19:03:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-21T14:14:35Z"}, "message": "Make { || ... } sugar for any type of closure, inferred", "tree": {"sha": "e44ce0f63bfb27feb95109256f8ec6262b3c45d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e44ce0f63bfb27feb95109256f8ec6262b3c45d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a901409410fc2fbc6722eb7b352008135252cec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a901409410fc2fbc6722eb7b352008135252cec", "html_url": "https://github.com/rust-lang/rust/commit/6a901409410fc2fbc6722eb7b352008135252cec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a901409410fc2fbc6722eb7b352008135252cec/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e4de333740690357a8f58883c5c69bf58be1424", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4de333740690357a8f58883c5c69bf58be1424", "html_url": "https://github.com/rust-lang/rust/commit/1e4de333740690357a8f58883c5c69bf58be1424"}], "stats": {"total": 634, "additions": 392, "deletions": 242}, "files": [{"sha": "4e9d1c4d343d83c33ded7c30aa2c442b1a24a8c5", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -61,7 +61,7 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n                copy_map: std::map::new_int_hash(),\n                ref_map: std::map::new_int_hash(),\n                mutable silent: false};\n-    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n+    let v = @{visit_fn_body: bind visit_fn_body(cx, _, _, _, _, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n@@ -71,10 +71,12 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n     ret (cx.copy_map, cx.ref_map);\n }\n \n-fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], sp: span,\n-            _name: fn_ident, id: ast::node_id, sc: scope, v: vt<scope>) {\n-    visit::visit_fn_decl(f.decl, sc, v);\n-    let args = ty::ty_fn_args(cx.tcx, ty::node_id_to_type(cx.tcx, id));\n+fn visit_fn_body(cx: @ctx, decl: ast::fn_decl, body: ast::blk,\n+                 sp: span, _name: ast::fn_ident,\n+                 id: ast::node_id, sc: scope, v: vt<scope>) {\n+    visit::visit_fn_decl(decl, sc, v);\n+    let fty = ty::node_id_to_type(cx.tcx, id);\n+    let args = ty::ty_fn_args(cx.tcx, fty);\n     for arg in args {\n         if arg.mode == ast::by_val &&\n            ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n@@ -84,11 +86,12 @@ fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], sp: span,\n \n     // Blocks need to obey any restrictions from the enclosing scope, and may\n     // be called multiple times.\n-    if f.proto == ast::proto_block {\n-        check_loop(*cx, sc) {|| v.visit_block(f.body, sc, v);}\n+    let proto = ty::ty_fn_proto(cx.tcx, fty);\n+    if proto == ast::proto_block {\n+        check_loop(*cx, sc) {|| v.visit_block(body, sc, v);}\n     } else {\n         let sc = {bs: [], invalid: @mutable list::nil};\n-        v.visit_block(f.body, sc, v);\n+        v.visit_block(body, sc, v);\n     }\n }\n "}, {"sha": "a18267569a3c0386bfec93e6c5fb972a921ef8b7", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -32,17 +32,17 @@ fn map_crate(c: crate) -> map {\n         (@{visit_item: bind map_item(cx, _),\n            visit_native_item: bind map_native_item(cx, _),\n            visit_expr: bind map_expr(cx, _),\n-           visit_fn: bind map_fn(cx, _, _, _, _, _),\n+           visit_fn_body: bind map_fn_body(cx, _, _, _, _, _),\n            visit_local: bind map_local(cx, _),\n            visit_arm: bind map_arm(cx, _)\n            with *visit::default_simple_visitor()});\n     visit::visit_crate(c, (), v_map);\n     ret cx.map;\n }\n \n-fn map_fn(cx: ctx, f: _fn, _tp: [ty_param], _sp: codemap::span,\n-          _name: fn_ident, _id: node_id) {\n-    for a in f.decl.inputs {\n+fn map_fn_body(cx: ctx, decl: fn_decl, _body: blk,\n+               _sp: codemap::span, _n: fn_ident, _id: node_id) {\n+    for a in decl.inputs {\n         cx.map.insert(a.id, node_arg(a, cx.local_id));\n         cx.local_id += 1u;\n     }"}, {"sha": "96868cd0bf03a1403c5451fd29446a0378166f07", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -740,6 +740,9 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           ast::expr_fn(f, _) {\n             (dbg_cx.names.next(\"fn\"), f.decl.output, expr.id)\n           }\n+          ast::expr_fn_block(decl, _) {\n+            (dbg_cx.names.next(\"fn\"), decl.output, expr.id)\n+          }\n         }\n       }\n     };"}, {"sha": "f7688d3507711fd616e66dbd95feb3ca1f655e24", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -28,8 +28,8 @@ type freevar_map = hashmap<ast::node_id, freevar_info>;\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::def_map, walker: fn@(visit::vt<int>)) ->\n-   freevar_info {\n+fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n+    -> freevar_info {\n     let seen = new_int_hash();\n     let refs = @mutable [];\n \n@@ -43,6 +43,9 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn@(visit::vt<int>)) ->\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }\n+              ast::expr_fn_block(_, _) {\n+                visit::visit_expr(expr, depth + 1, v);\n+              }\n               ast::expr_path(path) {\n                 let def = def_map.get(expr.id), i = 0;\n                 while i < depth {\n@@ -64,8 +67,9 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn@(visit::vt<int>)) ->\n             }\n         };\n \n-    walker(visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr\n-                             with *visit::default_visitor()}));\n+    let v = visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr\n+                           with *visit::default_visitor()});\n+    v.visit_block(blk, 1, v);\n     ret @*refs;\n }\n \n@@ -78,20 +82,16 @@ fn annotate_freevars(def_map: resolve::def_map, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = new_int_hash();\n \n-    let walk_fn =\n-        lambda (f: ast::_fn, tps: [ast::ty_param], sp: span, i: ast::fn_ident,\n-                nid: ast::node_id) {\n-            let start_walk =\n-                lambda (v: visit::vt<int>) {\n-                    v.visit_fn(f, tps, sp, i, nid, 1, v);\n-                };\n-            let vars = collect_freevars(def_map, start_walk);\n-            freevars.insert(nid, vars);\n-        };\n+    let walk_fn_body = lambda (_decl: ast::fn_decl, blk: ast::blk,\n+                               _sp: span, _nm: ast::fn_ident,\n+                               nid: ast::node_id) {\n+        let vars = collect_freevars(def_map, blk);\n+        freevars.insert(nid, vars);\n+    };\n \n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn: walk_fn\n-                                      with *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(@{visit_fn_body: walk_fn_body\n+                                   with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n \n     ret freevars;"}, {"sha": "7423cc70f0eb5dd9c21223e5d24e5b59a2303c05", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -1,5 +1,6 @@\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n+import syntax::codemap::span;\n import std::list::{list, nil, cons, tail};\n import core::{vec, option};\n import std::list;\n@@ -42,7 +43,7 @@ type ctx = {last_uses: std::map::hashmap<node_id, bool>,\n fn find_last_uses(c: @crate, def_map: resolve::def_map,\n                   ref_map: alias::ref_map, tcx: ty::ctxt) -> last_uses {\n     let v = visit::mk_vt(@{visit_expr: visit_expr,\n-                           visit_fn: visit_fn\n+                           visit_fn_body: visit_fn_body\n                            with *visit::default_visitor()});\n     let cx = {last_uses: std::map::new_int_hash(),\n               def_map: def_map,\n@@ -136,6 +137,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n             alt arg.node {\n               //NDM--register captured as uses\n               expr_fn(_, captured) { fns += [arg]; }\n+              expr_fn_block(_, _) { fns += [arg]; }\n               _ {\n                 alt arg_ts[i].mode {\n                   by_mut_ref. { clear_if_path(cx, arg, v, false); }\n@@ -151,16 +153,19 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     }\n }\n \n-fn visit_fn(f: _fn, tps: [ty_param], sp: syntax::codemap::span,\n-            ident: fn_ident, id: node_id, cx: ctx, v: visit::vt<ctx>) {\n-    if f.proto == proto_block {\n+fn visit_fn_body(decl: fn_decl, body: blk,\n+                 sp: span, nm: fn_ident, id: node_id,\n+                 cx: ctx, v: visit::vt<ctx>) {\n+    let fty = ty::node_id_to_type(cx.tcx, id);\n+    let proto = ty::ty_fn_proto(cx.tcx, fty);\n+    if proto == proto_block {\n         visit_block(func, cx, {||\n-            visit::visit_fn(f, tps, sp, ident, id, cx, v);\n+            visit::visit_fn_body(decl, body, sp, nm, id, cx, v);\n         });\n     } else {\n         let old = nil;\n         cx.blocks <-> old;\n-        visit::visit_fn(f, tps, sp, ident, id, cx, v);\n+        visit::visit_fn_body(decl, body, sp, nm, id, cx, v);\n         cx.blocks <-> old;\n         leave_fn(cx);\n     }"}, {"sha": "41bc218e1769c5ee845f00628fb7990d5c0fe2ba", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -171,7 +171,7 @@ fn check_lval(cx: @ctx, dest: @expr, msg: msg) {\n     alt dest.node {\n       expr_path(p) {\n         let def = cx.tcx.def_map.get(dest.id);\n-        alt is_immutable_def(def) {\n+        alt is_immutable_def(cx, def) {\n           some(name) { mk_err(cx, dest.span, msg, name); }\n           _ { }\n         }\n@@ -258,7 +258,7 @@ fn check_bind(cx: @ctx, f: @expr, args: [option::t<@expr>]) {\n     }\n }\n \n-fn is_immutable_def(def: def) -> option::t<str> {\n+fn is_immutable_def(cx: @ctx, def: def) -> option::t<str> {\n     alt def {\n       def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n       def_use(_) {\n@@ -268,8 +268,13 @@ fn is_immutable_def(def: def) -> option::t<str> {\n       def_arg(_, mode_infer.) { some(\"argument\") }\n       def_obj_field(_, imm.) { some(\"immutable object field\") }\n       def_self(_) { some(\"self argument\") }\n-      def_upvar(_, inner, mut) {\n-        if !mut { some(\"upvar\") } else { is_immutable_def(*inner) }\n+      def_upvar(_, inner, node_id) {\n+        let ty = ty::node_id_to_monotype(cx.tcx, node_id);\n+        let proto = ty::ty_fn_proto(cx.tcx, ty);\n+        ret alt proto {\n+          proto_block. { is_immutable_def(cx, *inner) }\n+          _ { some(\"upvar\") }\n+        };\n       }\n       def_binding(_) { some(\"binding\") }\n       def_local(_, let_ref.) { some(\"by-reference binding\") }"}, {"sha": "384b44a24cf711b7f402831219462c4e0a07cc52", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -31,7 +31,8 @@ export _impl, iscopes, method_info;\n tag scope {\n     scope_crate;\n     scope_item(@ast::item);\n-    scope_fn(ast::fn_decl, ast::proto, [ast::ty_param]);\n+    scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]);\n+    scope_fn_expr(ast::fn_decl, node_id, [ast::ty_param]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n     scope_block(ast::blk, @mutable uint, @mutable uint);\n@@ -335,8 +336,11 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_expr: bind walk_expr(e, _, _, _),\n           visit_ty: bind walk_ty(e, _, _, _),\n           visit_constr: bind walk_constr(e, _, _, _, _, _),\n-          visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n-             with *visit::default_visitor()};\n+          visit_fn_proto:\n+              bind visit_fn_proto_with_scope(e, _, _, _, _, _, _, _),\n+          visit_fn_block:\n+              bind visit_fn_block_with_scope(e, _, _, _, _, _, _)\n+          with *visit::default_visitor()};\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n     e.used_imports.track = false;\n     e.sess.abort_if_errors();\n@@ -400,8 +404,8 @@ fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n       ast::item_impl(tps, sty, methods) {\n         visit::visit_ty(sty, sc, v);\n         for m in methods {\n-            v.visit_fn(m.node.meth, tps + m.node.tps, m.span,\n-                       some(m.node.ident), m.node.id, sc, v);\n+            v.visit_fn_proto(m.node.meth, tps + m.node.tps, m.span,\n+                             some(m.node.ident), m.node.id, sc, v);\n         }\n       }\n       _ { visit::visit_item(i, sc, v); }\n@@ -413,9 +417,9 @@ fn visit_native_item_with_scope(ni: @ast::native_item, sc: scopes,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param], sp: span,\n-                       name: fn_ident, id: node_id, sc: scopes,\n-                       v: vt<scopes>) {\n+fn visit_fn_proto_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param],\n+                             sp: span, name: fn_ident, id: node_id,\n+                             sc: scopes, v: vt<scopes>) {\n     // is this a main fn declaration?\n     alt name {\n       some(nm) {\n@@ -431,8 +435,21 @@ fn visit_fn_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param], sp: span,\n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n     for c: @ast::constr in f.decl.constraints { resolve_constr(e, c, sc, v); }\n-    visit::visit_fn(f, tp, sp, name, id,\n-                    cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n+    let scope = alt f.proto {\n+      ast::proto_bare. { scope_bare_fn(f.decl, id, tp) }\n+      _ { scope_fn_expr(f.decl, id, tp) }\n+    };\n+\n+    visit::visit_fn_proto(f, tp, sp, name, id, cons(scope, @sc), v);\n+}\n+\n+fn visit_fn_block_with_scope(_e: @env, decl: fn_decl, blk: ast::blk,\n+                             span: span, id: node_id,\n+                             sc: scopes, v: vt<scopes>) {\n+    let scope = scope_fn_expr(decl, id, []);\n+    log (\"scope=\", scope);\n+    visit::visit_fn_block(decl, blk, span, id, cons(scope, @sc), v);\n+    log (\"unscope\");\n }\n \n fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n@@ -648,7 +665,8 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             alt sc {\n               cons(cur, rest) {\n                 alt cur {\n-                  scope_crate. | scope_fn(_, _, _) |\n+                  scope_crate. | scope_bare_fn(_, _, _) |\n+                  scope_fn_expr(_, _, _) |\n                   scope_item(@{node: ast::item_mod(_), _}) {\n                     ret some(cur);\n                   }\n@@ -734,23 +752,17 @@ fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n \n fn scope_is_fn(sc: scope) -> bool {\n     ret alt sc {\n-          scope_fn(_, ast::proto_bare., _) |\n-          scope_native_item(_) {\n-            true\n-          }\n-          _ { false }\n-        };\n+      scope_bare_fn(_, _, _) | scope_native_item(_) { true }\n+      _ { false }\n+    };\n }\n \n // Returns:\n //   none - does not close\n-//   some(true) - closes and permits mutation\n-//   some(false) - closes but no mutation\n-fn scope_closes(sc: scope) -> option::t<bool> {\n+//   some(node_id) - closes via the expr w/ node_id\n+fn scope_closes(sc: scope) -> option::t<node_id> {\n     alt sc {\n-      scope_fn(_, ast::proto_block., _) { some(true) }\n-      scope_fn(_, ast::proto_send., _) { some(false) }\n-      scope_fn(_, ast::proto_shared(_), _) { some(false) }\n+      scope_fn_expr(_, node_id, _) { some(node_id) }\n       _ { none }\n     }\n }\n@@ -823,7 +835,8 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               }\n             }\n           }\n-          scope_fn(decl, _, ty_params) {\n+          scope_bare_fn(decl, _, ty_params) |\n+          scope_fn_expr(decl, _, ty_params) {\n             ret lookup_in_fn(name, decl, ty_params, ns);\n           }\n           scope_loop(local) {\n@@ -887,7 +900,10 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                 left_fn_level2 = true;\n             } else if ns == ns_value || ns == ns_type {\n                 left_fn = scope_is_fn(hd);\n-                alt scope_closes(hd) { some(mut) { closing += [mut]; } _ { } }\n+                alt scope_closes(hd) {\n+                  some(node_id) { closing += [node_id]; }\n+                  _ { }\n+                }\n             }\n             sc = *tl;\n           }"}, {"sha": "8ccda0daa4df6ac2b85f2c26013ee649a779365f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -3558,6 +3558,19 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_closure::trans_expr_fn(\n             bcx, f, e.span, e.id, *cap_clause, dest);\n       }\n+      ast::expr_fn_block(decl, body) {\n+        alt ty::struct(tcx, ty::expr_ty(tcx, e)) {\n+          ty::ty_fn(proto, _, _, _, _) {\n+            let f: ast::_fn = { decl: decl, proto: proto, body: body };\n+            let cap_clause = { copies: [], moves: [] };\n+            ret trans_closure::trans_expr_fn(\n+                bcx, f, e.span, e.id, cap_clause, dest);\n+          }\n+          _ {\n+            fail \"Type of fn block is not a function!\";\n+          }\n+        }\n+      }\n       ast::expr_bind(f, args) {\n         ret trans_closure::trans_bind(\n             bcx, f, args, e.id, dest);"}, {"sha": "389fbf1c76d9aa42cf1341c043cf2110f0709a89", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -32,15 +32,14 @@ fn collect_ids_local(l: @local, rs: @mutable [node_id]) {\n     *rs += pat_binding_ids(l.node.pat);\n }\n \n-fn node_ids_in_fn(f: _fn, tps: [ty_param], sp: span, i: fn_ident, id: node_id,\n-                  rs: @mutable [node_id]) {\n+fn node_ids_in_fn(body: blk, rs: @mutable [node_id]) {\n     let collect_ids =\n         visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n                                    visit_block: bind collect_ids_block(_, rs),\n                                    visit_stmt: bind collect_ids_stmt(_, rs),\n                                    visit_local: bind collect_ids_local(_, rs)\n                                       with *visit::default_simple_visitor()});\n-    visit::visit_fn(f, tps, sp, i, id, (), collect_ids);\n+    collect_ids.visit_block(body, (), collect_ids);\n }\n \n fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n@@ -50,25 +49,24 @@ fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n     }\n }\n \n-fn visit_fn(ccx: crate_ctxt, num_constraints: uint, f: _fn, tps: [ty_param],\n-            sp: span, i: fn_ident, id: node_id) {\n+fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n     let node_ids: @mutable [node_id] = @mutable [];\n-    node_ids_in_fn(f, tps, sp, i, id, node_ids);\n+    node_ids_in_fn(body, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(ccx: crate_ctxt, f: _fn, tps: [ty_param], sp: span,\n-                  i: fn_ident, id: node_id) {\n+fn annotate_in_fn_body(ccx: crate_ctxt, _decl: fn_decl, body: blk,\n+                       _sp: span, _n: fn_ident, id: node_id) {\n     let f_info = get_fn_info(ccx, id);\n-    visit_fn(ccx, num_constraints(f_info), f, tps, sp, i, id);\n+    visit_fn(ccx, num_constraints(f_info), body);\n }\n \n fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n     let do_ann =\n-        visit::mk_simple_visitor(@{visit_fn:\n-                                       bind annotate_in_fn(ccx, _, _, _, _, _)\n-                                      with *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(\n+            @{visit_fn_body: bind annotate_in_fn_body(ccx, _, _, _, _, _)\n+              with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), do_ann);\n }\n //"}, {"sha": "c2d1732c86ec46f1de835ac77680d1b23feacb80", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -1003,8 +1003,9 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n }\n \n // default function visitor\n-fn do_nothing<T>(_f: _fn, _tp: [ty_param], _sp: span, _i: fn_ident,\n-                 _iid: node_id, _cx: T, _v: visit::vt<T>) {\n+fn do_nothing<T>(_decl: fn_decl, _body: blk,\n+                 _sp: span, _i: fn_ident, _id: node_id,\n+                 _t: T, _v: visit::vt<T>) {\n }\n \n "}, {"sha": "ac21c5929512cd52672b8a90c209e28cc40c0018", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -151,7 +151,7 @@ fn relax_precond_block(fcx: fn_ctxt, i: node_id, b: blk) {\n           visit_stmt: relax_precond_stmt,\n           visit_item:\n               fn (_i: @item, _cx: relax_ctxt, _vt: visit::vt<relax_ctxt>) { },\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n+          visit_fn_body: bind do_nothing(_, _, _, _, _, _, _)\n              with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);"}, {"sha": "72b5d6fbab322ca44b9431c6092160ec7d42da60", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -95,75 +95,82 @@ fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     }\n }\n \n-fn check_states_against_conditions(fcx: fn_ctxt, f: _fn, tps: [ast::ty_param],\n-                                   id: node_id, sp: span, i: fn_ident) {\n+fn check_states_against_conditions(fcx: fn_ctxt,\n+                                   f_decl: ast::fn_decl,\n+                                   f_body: ast::blk,\n+                                   sp: span,\n+                                   nm: fn_ident,\n+                                   id: node_id) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n        or expression. */\n \n-    let visitor = visit::default_visitor::<fn_ctxt>();\n-\n-    visitor =\n+    let visitor = visit::mk_vt(\n         @{visit_stmt: check_states_stmt,\n           visit_expr: check_states_expr,\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n-              with *visitor};\n-    visit::visit_fn(f, tps, sp, i, id, fcx, visit::mk_vt(visitor));\n+          visit_fn_body: bind do_nothing::<fn_ctxt>(_, _, _, _, _, _, _)\n+          with *visit::default_visitor::<fn_ctxt>()});\n+    visit::visit_fn_body(f_decl, f_body, sp, nm, id, fcx, visitor);\n \n     /* Check that the return value is initialized */\n-    let post = aux::block_poststate(fcx.ccx, f.body);\n+    let post = aux::block_poststate(fcx.ccx, f_body);\n     if !promises(fcx, post, fcx.enclosing.i_return) &&\n        !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n-       f.decl.cf == return_val {\n-        fcx.ccx.tcx.sess.span_err(f.body.span,\n+       f_decl.cf == return_val {\n+        fcx.ccx.tcx.sess.span_err(f_body.span,\n                                   \"In function \" + fcx.name +\n                                       \", not all control paths \\\n                                         return a value\");\n-        fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n+        fcx.ccx.tcx.sess.span_fatal(f_decl.output.span,\n                                     \"see declared return type of '\" +\n-                                        ty_to_str(f.decl.output) + \"'\");\n-    } else if f.decl.cf == noreturn {\n+                                    ty_to_str(f_decl.output) + \"'\");\n+    } else if f_decl.cf == noreturn {\n \n         // check that this really always fails\n         // Note that it's ok for i_diverge and i_return to both be true.\n         // In fact, i_diverge implies i_return. (But not vice versa!)\n \n         if !promises(fcx, post, fcx.enclosing.i_diverge) {\n-            fcx.ccx.tcx.sess.span_fatal(f.body.span,\n+            fcx.ccx.tcx.sess.span_fatal(f_body.span,\n                                         \"In non-returning function \" +\n-                                            fcx.name +\n-                                            \", some control paths may \\\n-                                           return to the caller\");\n+                                        fcx.name +\n+                                        \", some control paths may \\\n+                                         return to the caller\");\n         }\n     }\n \n     /* Finally, check for unused variables */\n     check_unused_vars(fcx);\n }\n \n-fn check_fn_states(fcx: fn_ctxt, f: _fn, tps: [ast::ty_param], id: node_id,\n-                   sp: span, i: fn_ident) {\n+fn check_fn_states(fcx: fn_ctxt,\n+                   f_decl: ast::fn_decl,\n+                   f_body: ast::blk,\n+                   sp: span,\n+                   nm: fn_ident,\n+                   id: node_id) {\n     /* Compute the pre- and post-states for this function */\n \n     // Fixpoint iteration\n-    while find_pre_post_state_fn(fcx, f) { }\n+    while find_pre_post_state_fn(fcx, f_decl, f_body) { }\n \n     /* Now compare each expr's pre-state to its precondition\n        and post-state to its postcondition */\n \n-    check_states_against_conditions(fcx, f, tps, id, sp, i);\n+    check_states_against_conditions(fcx, f_decl, f_body, sp, nm, id);\n }\n \n-fn fn_states(f: _fn, tps: [ast::ty_param], sp: span, i: fn_ident, id: node_id,\n+fn fn_states(f_decl: ast::fn_decl, f_body: ast::blk,\n+             sp: span, i: ast::fn_ident, id: node_id,\n              ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n-    visit::visit_fn(f, tps, sp, i, id, ccx, v);\n+    visit::visit_fn_body(f_decl, f_body, sp, i, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */\n \n     assert (ccx.fm.contains_key(id));\n     let f_info = ccx.fm.get(id);\n-    let name = option::from_maybe(\"anon\", i);\n+    let name = option::from_maybe(\"anon\", i); // XXXX\n     let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n-    check_fn_states(fcx, f, tps, id, sp, i);\n+    check_fn_states(fcx, f_decl, f_body, sp, i, id)\n }\n \n fn check_crate(cx: ty::ctxt, crate: @crate) {\n@@ -177,12 +184,13 @@ fn check_crate(cx: ty::ctxt, crate: @crate) {\n     /* Compute the pre and postcondition for every subexpression */\n \n     let vtor = visit::default_visitor::<crate_ctxt>();\n-    vtor = @{visit_fn: fn_pre_post with *vtor};\n+    vtor = @{visit_fn_body: fn_pre_post with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n \n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n-    vtor = @{visit_fn: fn_states with *vtor};\n+    let vtor = visit::default_visitor::<crate_ctxt>();\n+    vtor = @{visit_fn_body: fn_states with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n }\n //"}, {"sha": "125a165b9aabe77b7fb6c958427e7c56e491beeb", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -44,17 +44,22 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn find_locals(tcx: ty::ctxt, f: _fn, tps: [ty_param], sp: span, i: fn_ident,\n+fn find_locals(tcx: ty::ctxt,\n+               f_decl: fn_decl,\n+               f_body: blk,\n+               sp: span,\n+               n: fn_ident,\n                id: node_id) -> ctxt {\n     let cx: ctxt = {cs: @mutable [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n \n     visitor =\n         @{visit_local: collect_local,\n           visit_expr: collect_pred,\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n-              with *visitor};\n-    visit::visit_fn(f, tps, sp, i, id, cx, visit::mk_vt(visitor));\n+          visit_fn_body: bind do_nothing(_, _, _, _, _, _, _)\n+          with *visitor};\n+    visit::visit_fn_body(f_decl, f_body, sp,\n+                         n, id, cx, visit::mk_vt(visitor));\n     ret cx;\n }\n \n@@ -90,13 +95,17 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(ccx: crate_ctxt, f: _fn, tp: [ty_param], f_sp: span,\n-              f_name: fn_ident, id: node_id) {\n+fn mk_fn_info(ccx: crate_ctxt,\n+              f_decl: fn_decl,\n+              f_body: blk,\n+              f_sp: span,\n+              f_name: fn_ident,\n+              id: node_id) {\n     let name = fn_ident_to_string(id, f_name);\n     let res_map = @new_def_hash::<constraint>();\n     let next: uint = 0u;\n \n-    let cx: ctxt = find_locals(ccx.tcx, f, tp, f_sp, f_name, id);\n+    let cx: ctxt = find_locals(ccx.tcx, f_decl, f_body, f_sp, f_name, id);\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n@@ -106,17 +115,19 @@ fn mk_fn_info(ccx: crate_ctxt, f: _fn, tp: [ty_param], f_sp: span,\n     /* if this function has any constraints, instantiate them to the\n        argument names and add them */\n     let sc;\n-    for c: @constr in f.decl.constraints {\n-        sc = ast_constr_to_sp_constr(cx.tcx, f.decl.inputs, c);\n+    for c: @constr in f_decl.constraints {\n+        sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n         next = add_constraint(cx.tcx, sc, next, res_map);\n     }\n \n     /* Need to add constraints for args too, b/c they\n     can be deinitialized */\n-    for a: arg in f.decl.inputs {\n-        next =\n-            add_constraint(cx.tcx, respan(f_sp, ninit(a.id, a.ident)), next,\n-                           res_map);\n+    for a: arg in f_decl.inputs {\n+        next = add_constraint(\n+            cx.tcx,\n+            respan(f_sp, ninit(a.id, a.ident)),\n+            next,\n+            res_map);\n     }\n \n     /* add the special i_diverge and i_return constraints\n@@ -137,7 +148,7 @@ fn mk_fn_info(ccx: crate_ctxt, f: _fn, tp: [ty_param], f_sp: span,\n     let rslt =\n         {constrs: res_map,\n          num_constraints: next,\n-         cf: f.decl.cf,\n+         cf: f_decl.cf,\n          i_return: ninit(id, name),\n          i_diverge: ninit(diverges_id, diverges_name),\n          used_vars: v};\n@@ -152,9 +163,9 @@ fn mk_fn_info(ccx: crate_ctxt, f: _fn, tp: [ty_param], f_sp: span,\n    to bit number) */\n fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn:\n+        visit::mk_simple_visitor(@{visit_fn_body:\n                                        bind mk_fn_info(ccx, _, _, _, _, _)\n-                                      with *visit::default_simple_visitor()});\n+                                   with *visit::default_simple_visitor()});\n     visit::visit_crate(*c, (), visitor);\n }\n //"}, {"sha": "5a89a8fd0172b9c8369d84914588f5d70819eae0", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -33,7 +33,7 @@ fn find_pre_post_method(ccx: crate_ctxt, m: @method) {\n          id: m.node.id,\n          name: m.node.ident,\n          ccx: ccx};\n-    find_pre_post_fn(fcx, m.node.meth);\n+    find_pre_post_fn(fcx, m.node.meth.body);\n }\n \n fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n@@ -60,7 +60,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n         assert (ccx.fm.contains_key(i.id));\n         let fcx =\n             {enclosing: ccx.fm.get(i.id), id: i.id, name: i.ident, ccx: ccx};\n-        find_pre_post_fn(fcx, f);\n+        find_pre_post_fn(fcx, f.body);\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n@@ -72,7 +72,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n              id: dtor_id,\n              name: i.ident,\n              ccx: ccx};\n-        find_pre_post_fn(fcx, dtor);\n+        find_pre_post_fn(fcx, dtor.body);\n       }\n       item_obj(o, _, _) {for m in o.methods { find_pre_post_method(ccx, m); }}\n       item_impl(_, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n@@ -298,6 +298,15 @@ fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [ty::mode],\n     }\n }\n \n+fn find_pre_post_expr_fn_upvars(fcx: fn_ctxt, e: @expr) {\n+    let rslt = expr_pp(fcx.ccx, e);\n+    clear_pp(rslt);\n+    for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {\n+        log (\"handle_var_def: def=\", def);\n+        handle_var_def(fcx, rslt, def.def, \"upvar\");\n+    }\n+}\n+\n /* Fills in annotations as a side effect. Does not rebuild the expr */\n fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n     let enclosing = fcx.enclosing;\n@@ -340,12 +349,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         copy_pre_post(fcx.ccx, e.id, arg);\n       }\n       expr_fn(f, cap_clause) {\n-        let rslt = expr_pp(fcx.ccx, e);\n-        clear_pp(rslt);\n-        for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {\n-            log (\"handle_var_def: def=\", def);\n-            handle_var_def(fcx, rslt, def.def, \"upvar\");\n-        }\n+        find_pre_post_expr_fn_upvars(fcx, e);\n \n         let use_cap_item = lambda(&&cap_item: @capture_item) {\n             let d = local_node_id_to_local_def_id(fcx, cap_item.id);\n@@ -358,9 +362,9 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             log (\"forget_in_postcond: \", cap_item);\n             forget_in_postcond(fcx, e.id, cap_item.id);\n         }\n-\n-        let ann = node_id_to_ts_ann(fcx.ccx, e.id);\n-        log_cond(tritv::to_vec(ann.conditions.postcondition));\n+      }\n+      expr_fn_block(_, _) {\n+        find_pre_post_expr_fn_upvars(fcx, e);\n       }\n       expr_block(b) {\n         find_pre_post_block(fcx, b);\n@@ -711,32 +715,33 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n }\n \n-fn find_pre_post_fn(fcx: fn_ctxt, f: _fn) {\n+fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n     // hack\n     use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_return));\n     use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_diverge));\n \n-    find_pre_post_block(fcx, f.body);\n-\n+    find_pre_post_block(fcx, body);\n \n     // Treat the tail expression as a return statement\n-    alt f.body.node.expr {\n+    alt body.node.expr {\n       some(tailexpr) { set_postcond_false(fcx.ccx, tailexpr.id); }\n       none. {/* fallthrough */ }\n     }\n }\n \n-fn fn_pre_post(f: _fn, tps: [ty_param], sp: span, i: fn_ident, id: node_id,\n+fn fn_pre_post(decl: fn_decl, body: blk, sp: span,\n+               i: fn_ident, id: node_id,\n                ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n-    visit::visit_fn(f, tps, sp, i, id, ccx, v);\n+    visit::visit_fn_body(decl, body, sp, i, id, ccx, v);\n     assert (ccx.fm.contains_key(id));\n     let fcx =\n         {enclosing: ccx.fm.get(id),\n          id: id,\n          name: fn_ident_to_string(id, i),\n          ccx: ccx};\n-    find_pre_post_fn(fcx, f);\n+    find_pre_post_fn(fcx, body);\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "16bf445790d21515d42ac590c9a2f573e4d0ffd2", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -374,6 +374,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_fn(_, cap_clause) {\n         ret find_pre_post_state_cap_clause(fcx, e.id, pres, *cap_clause);\n       }\n+      expr_fn_block(_, _) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_block(b) {\n         ret find_pre_post_state_block(fcx, pres, b) |\n                 set_prestate_ann(fcx.ccx, e.id, pres) |\n@@ -732,28 +733,30 @@ fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n     ret changed;\n }\n \n-fn find_pre_post_state_fn(fcx: fn_ctxt, f: _fn) -> bool {\n+fn find_pre_post_state_fn(fcx: fn_ctxt,\n+                          f_decl: fn_decl,\n+                          f_body: blk) -> bool {\n     let num_constrs = num_constraints(fcx.enclosing);\n     // All constraints are considered false until proven otherwise.\n     // This ensures that intersect works correctly.\n-    kill_all_prestate(fcx, f.body.node.id);\n+    kill_all_prestate(fcx, f_body.node.id);\n \n     // Arguments start out initialized\n-    let block_pre = block_prestate(fcx.ccx, f.body);\n-    for a: arg in f.decl.inputs {\n+    let block_pre = block_prestate(fcx.ccx, f_body);\n+    for a: arg in f_decl.inputs {\n         set_in_prestate_constr(fcx, ninit(a.id, a.ident), block_pre);\n     }\n \n     // Instantiate any constraints on the arguments so we can use them\n-    for c: @constr in f.decl.constraints {\n-        let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f.decl.inputs, c);\n+    for c: @constr in f_decl.constraints {\n+        let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f_decl.inputs, c);\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }\n \n-    let changed = find_pre_post_state_block(fcx, block_pre, f.body);\n+    let changed = find_pre_post_state_block(fcx, block_pre, f_body);\n \n     // Treat the tail expression as a return statement\n-    alt f.body.node.expr {\n+    alt f_body.node.expr {\n       some(tailexpr) {\n \n         // We don't want to clear the diverges bit for bottom typed things,\n@@ -763,7 +766,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt, f: _fn) -> bool {\n             let post = false_postcond(num_constrs);\n             // except for the \"diverges\" bit...\n             kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n-            set_poststate_ann(fcx.ccx, f.body.node.id, post);\n+            set_poststate_ann(fcx.ccx, f_body.node.id, post);\n         }\n       }\n       none. {/* fallthrough */ }\n@@ -772,7 +775,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt, f: _fn) -> bool {\n     /*\n         log_err \"find_pre_post_state_fn\";\n         log_err changed;\n-        fcx.ccx.tcx.sess.span_note(f.body.span, fcx.name);\n+        fcx.ccx.tcx.sess.span_note(f_body.span, fcx.name);\n     */\n \n     ret changed;"}, {"sha": "d852e8938009ab4c82b3526ac0a2a3f535f86329", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 67, "deletions": 33, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -999,8 +999,9 @@ mod writeback {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n         alt e.node {\n-          ast::expr_fn(f, _) { // NDM captures?\n-            for input in f.decl.inputs {\n+          ast::expr_fn({decl: decl, _}, _) |\n+          ast::expr_fn_block(decl, _) {\n+            for input in decl.inputs {\n                 resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n           }\n@@ -1077,7 +1078,10 @@ type gather_result =\n      next_var_id: @mutable int};\n \n // Used only as a helper for check_fn.\n-fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n+fn gather_locals(ccx: @crate_ctxt,\n+                 decl: ast::fn_decl,\n+                 body: ast::blk,\n+                 id: ast::node_id,\n                  old_fcx: option::t<@fn_ctxt>) -> gather_result {\n     let {vb: vb, locals: locals, nvi: nvi} =\n         alt old_fcx {\n@@ -1121,7 +1125,7 @@ fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg in args {\n-        assign(f.decl.inputs[i].id, some(arg.ty));\n+        assign(decl.inputs[i].id, some(arg.ty));\n         i += 1u;\n     }\n \n@@ -1144,20 +1148,20 @@ fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n         };\n \n     // Don't descend into fns and items\n-    fn visit_fn<E>(_f: ast::_fn, _tp: [ast::ty_param], _sp: span,\n-                   _i: ast::fn_ident, _id: ast::node_id, _e: E,\n-                   _v: visit::vt<E>) {\n+    fn visit_fn_body<T>(_decl: ast::fn_decl, _body: ast::blk,\n+                        _sp: span, _nm: ast::fn_ident, _id: ast::node_id,\n+                        _t: T, _v: visit::vt<T>) {\n     }\n     fn visit_item<E>(_i: @ast::item, _e: E, _v: visit::vt<E>) { }\n \n     let visit =\n         @{visit_local: visit_local,\n           visit_pat: visit_pat,\n-          visit_fn: bind visit_fn(_, _, _, _, _, _, _),\n+          visit_fn_body: bind visit_fn_body(_, _, _, _, _, _, _),\n           visit_item: bind visit_item(_, _, _)\n               with *visit::default_visitor()};\n \n-    visit::visit_block(f.body, (), visit::mk_vt(visit));\n+    visit::visit_block(body, (), visit::mk_vt(visit));\n     ret {var_bindings: vb,\n          locals: locals,\n          next_var_id: nvi};\n@@ -1496,6 +1500,32 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n     result\n }\n \n+fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n+                              expr: @ast::expr,\n+                              decl: ast::fn_decl,\n+                              proto: ast::proto,\n+                              body: ast::blk,\n+                              unify: unifier,\n+                              expected: ty::t) {\n+    let tcx = fcx.ccx.tcx;\n+\n+    let fty = ty_of_fn_decl(tcx, m_check_tyvar(fcx), decl,\n+                            proto, [], none).ty;\n+\n+    write::ty_only_fixup(fcx, expr.id, fty);\n+\n+    // Unify the type of the function with the expected type before we\n+    // typecheck the body so that we have more information about the\n+    // argument types in the body. This is needed to make binops and\n+    // record projection work on type inferred arguments.\n+    unify(fcx, expr.span, expected, fty);\n+\n+    check_fn1(fcx.ccx, decl, proto, body, expr.id, some(fcx));\n+    if proto == ast::proto_block {\n+        write::ty_only_fixup(fcx, expr.id, expected);\n+    }\n+}\n+\n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n     //log_err \"typechecking expr \" + syntax::print::pprust::expr_to_str(expr);\n@@ -1563,7 +1593,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                       some(a) {\n                         let is_block =\n                             alt a.node {\n-                              ast::expr_fn(_, _) { true }\n+                              ast::expr_fn_block(_, _) { true }\n                               _ { false }\n                             };\n                         if is_block == check_blocks {\n@@ -1940,24 +1970,21 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n       ast::expr_fn(f, captures) {\n-        let fty = ty_of_fn_decl(tcx, m_check_tyvar(fcx), f.decl,\n-                                 f.proto, [], none).ty;\n-\n-        write::ty_only_fixup(fcx, id, fty);\n-\n-        // Unify the type of the function with the expected type before we\n-        // typecheck the body so that we have more information about the\n-        // argument types in the body. This is needed to make binops and\n-        // record projection work on type inferred arguments.\n-        unify(fcx, expr.span, expected, fty);\n-\n-        check_fn(fcx.ccx, f, id, some(fcx));\n-        if f.proto == ast::proto_block {\n-            write::ty_only_fixup(fcx, id, expected);\n-        }\n-\n+        check_expr_fn_with_unifier(fcx, expr, f.decl,\n+                                   f.proto, f.body,\n+                                   unify, expected);\n         capture::check_capture_clause(tcx, expr.id, f.proto, *captures);\n       }\n+      ast::expr_fn_block(decl, body) {\n+        // Take the prototype from the expected type, but default to block:\n+        let proto = alt ty::struct(tcx, expected) {\n+          ty::ty_fn(proto, _, _, _, _) { proto }\n+          _ { ast::proto_block }\n+        };\n+        check_expr_fn_with_unifier(fcx, expr, decl,\n+                                   proto, body,\n+                                   unify, expected);\n+      }\n       ast::expr_block(b) {\n         // If this is an unchecked block, turn off purity-checking\n         bot = check_block(fcx, b);\n@@ -2581,25 +2608,32 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n     }\n }\n \n-fn check_fn(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n+fn check_fn(ccx: @crate_ctxt,\n+            f: ast::_fn,\n+            id: ast::node_id,\n             old_fcx: option::t<@fn_ctxt>) {\n+    check_fn1(ccx, f.decl, f.proto, f.body, id, old_fcx);\n+}\n \n-    let decl = f.decl;\n-    let body = f.body;\n-\n+fn check_fn1(ccx: @crate_ctxt,\n+             decl: ast::fn_decl,\n+             proto: ast::proto,\n+             body: ast::blk,\n+             id: ast::node_id,\n+             old_fcx: option::t<@fn_ctxt>) {\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n     let purity = alt old_fcx {\n       none. { decl.purity }\n       some(f) { assert decl.purity == ast::impure_fn; f.purity }\n     };\n \n-    let gather_result = gather_locals(ccx, f, id, old_fcx);\n+    let gather_result = gather_locals(ccx, decl, body, id, old_fcx);\n     let fixups: [ast::node_id] = [];\n     let fcx: @fn_ctxt =\n         @{ret_ty: ty::ty_fn_ret(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)),\n           purity: purity,\n-          proto: f.proto,\n+          proto: proto,\n           var_bindings: gather_result.var_bindings,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n@@ -2622,7 +2656,7 @@ fn check_fn(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg in args {\n-        write::ty_only_fixup(fcx, f.decl.inputs[i].id, arg.ty);\n+        write::ty_only_fixup(fcx, decl.inputs[i].id, arg.ty);\n         i += 1u;\n     }\n "}, {"sha": "ed9349166ed7cb2dcc39a14ff48d3b8df9ba9fc2", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -42,7 +42,7 @@ tag def {\n     def_use(def_id);\n     def_native_ty(def_id);\n     def_native_fn(def_id, purity);\n-    def_upvar(def_id, @def, /* writable */bool);\n+    def_upvar(def_id, @def, node_id); // node_id == expr_fn or expr_fn_block\n }\n \n // The set of meta_items that define the compilation environment of the crate,\n@@ -227,6 +227,7 @@ tag expr_ {\n     expr_do_while(blk, @expr);\n     expr_alt(@expr, [arm]);\n     expr_fn(_fn, @capture_clause);\n+    expr_fn_block(fn_decl, blk);\n     expr_block(blk);\n \n     /*\n@@ -261,10 +262,6 @@ tag expr_ {\n     expr_mac(mac);\n }\n \n-// AST nodes that represent a capture clause, which is used to declare\n-// variables that are copied or moved explicitly into the closure.  In some\n-// cases, local variables can also be copied implicitly into the closure if\n-// they are used in the closure body.\n type capture_item = {\n     id: int,\n     name: ident, // Currently, can only capture a local var."}, {"sha": "c3caa56a9e41f2ad021c5eca2e3fc20b535f9f55", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -145,6 +145,14 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n          span: m.span};\n }\n \n+fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n+    ret {inputs: vec::map(decl.inputs, bind fold_arg_(_, fld)),\n+         output: fld.fold_ty(decl.output),\n+         purity: decl.purity,\n+         il: decl.il,\n+         cf: decl.cf,\n+         constraints: vec::map(decl.constraints, fld.fold_constr)}\n+}\n \n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n@@ -385,8 +393,10 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_alt(expr, arms) {\n             expr_alt(fld.fold_expr(expr), vec::map(arms, fld.fold_arm))\n           }\n-          // NDM fold_captures\n           expr_fn(f, captures) { expr_fn(fld.fold_fn(f), captures) }\n+          expr_fn_block(decl, body) {\n+            expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body))\n+          }\n           expr_block(blk) { expr_block(fld.fold_block(blk)) }\n           expr_move(el, er) {\n             expr_move(fld.fold_expr(el), fld.fold_expr(er))\n@@ -437,15 +447,7 @@ fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n \n // functions just don't get spans, for some reason\n fn noop_fold_fn(f: _fn, fld: ast_fold) -> _fn {\n-    let fold_arg = bind fold_arg_(_, fld);\n-\n-    ret {decl:\n-             {inputs: vec::map(f.decl.inputs, fold_arg),\n-              output: fld.fold_ty(f.decl.output),\n-              purity: f.decl.purity,\n-              il: f.decl.il,\n-              cf: f.decl.cf,\n-              constraints: vec::map(f.decl.constraints, fld.fold_constr)},\n+    ret {decl: fold_fn_decl(f.decl, fld),\n          proto: f.proto,\n          body: fld.fold_block(f.body)};\n }"}, {"sha": "0a436a521c9c6e952df430b55134a1bbf26497bc", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -1317,9 +1317,7 @@ fn parse_fn_block_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let decl = parse_fn_block_decl(p);\n     let body = parse_block_tail(p, lo, ast::default_blk);\n-    let _fn = {decl: decl, proto: ast::proto_block, body: body};\n-    let captures = @{copies: [], moves: []};\n-    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, captures));\n+    ret mk_expr(p, lo, body.span.hi, ast::expr_fn_block(decl, body));\n }\n \n fn parse_else_expr(p: parser) -> @ast::expr {"}, {"sha": "5832140b230567893728393454114a936593173f", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -827,24 +827,19 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n       ast::expr_fn(f, captures) { // NDM captures\n-\n-        // If the return type is the magic ty_infer, then we need to\n-        // pretty print as a lambda-block\n-        if f.decl.output.node == ast::ty_infer {\n-            // containing cbox, will be closed by print-block at }\n-            cbox(s, indent_unit);\n-            // head-box, will be closed by print-block at start\n-            ibox(s, 0u);\n-            word(s.s, \"{\");\n-            print_fn_block_args(s, f.decl);\n-            print_possibly_embedded_block(s, f.body, block_block_fn,\n-                                          indent_unit);\n-        } else {\n-            head(s, proto_to_str(f.proto));\n-            print_fn_args_and_ret(s, f.decl, []);\n-            space(s.s);\n-            print_block(s, f.body);\n-        }\n+        head(s, proto_to_str(f.proto));\n+        print_fn_args_and_ret(s, f.decl, []);\n+        space(s.s);\n+        print_block(s, f.body);\n+      }\n+      ast::expr_fn_block(decl, body) {\n+        // containing cbox, will be closed by print-block at }\n+        cbox(s, indent_unit);\n+        // head-box, will be closed by print-block at start\n+        ibox(s, 0u);\n+        word(s.s, \"{\");\n+        print_fn_block_args(s, decl);\n+        print_possibly_embedded_block(s, body, block_block_fn, indent_unit);\n       }\n       ast::expr_block(blk) {\n         // containing cbox, will be closed by print-block at }"}, {"sha": "3f0d7a27a5157fc14957f0e33007b9ef6db48f4d", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a901409410fc2fbc6722eb7b352008135252cec/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=6a901409410fc2fbc6722eb7b352008135252cec", "patch": "@@ -31,7 +31,15 @@ type visitor<E> =\n       visit_expr: fn@(@expr, E, vt<E>),\n       visit_ty: fn@(@ty, E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n-      visit_fn: fn@(_fn, [ty_param], span, fn_ident, node_id, E, vt<E>)};\n+\n+      // A function with a fully specified prototype:\n+      visit_fn_proto: fn@(_fn, [ty_param], span, fn_ident, node_id, E, vt<E>),\n+\n+      // Function sugar like { || ... }:\n+      visit_fn_block: fn@(fn_decl, blk, span, node_id, E, vt<E>),\n+\n+      // Invoked by both visit_fn_proto and visit_fn_block above.\n+      visit_fn_body: fn@(fn_decl, blk, span, fn_ident, node_id, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod::<E>(_, _, _, _),\n@@ -47,7 +55,9 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_expr: bind visit_expr::<E>(_, _, _),\n           visit_ty: bind skip_ty::<E>(_, _, _),\n           visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n-          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _)};\n+          visit_fn_proto: bind visit_fn_proto::<E>(_, _, _, _, _, _, _),\n+          visit_fn_block: bind visit_fn_block::<E>(_, _, _, _, _, _),\n+          visit_fn_body: bind visit_fn_body::<E>(_, _, _, _, _, _, _)};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -83,15 +93,16 @@ fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n-      item_fn(f, tp) { v.visit_fn(f, tp, i.span, some(i.ident), i.id, e, v); }\n+      item_fn(f, tp) { v.visit_fn_proto(f, tp, i.span,\n+                                        some(i.ident), i.id, e, v); }\n       item_mod(m) { v.visit_mod(m, i.span, e, v); }\n       item_native_mod(nm) {\n         for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n         for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n       }\n       item_ty(t, _) { v.visit_ty(t, e, v); }\n       item_res(f, dtor_id, tps, _) {\n-        v.visit_fn(f, tps, i.span, some(i.ident), dtor_id, e, v);\n+        v.visit_fn_proto(f, tps, i.span, some(i.ident), dtor_id, e, v);\n       }\n       item_tag(variants, _) {\n         for vr: variant in variants {\n@@ -101,15 +112,15 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       item_obj(ob, _, _) {\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n-            v.visit_fn(m.node.meth, m.node.tps, m.span, some(m.node.ident),\n-                       m.node.id, e, v);\n+            v.visit_fn_proto(m.node.meth, m.node.tps, m.span,\n+                             some(m.node.ident), m.node.id, e, v);\n         }\n       }\n       item_impl(_, ty, methods) {\n         visit_ty(ty, e, v);\n         for m in methods {\n-            v.visit_fn(m.node.meth, m.node.tps, m.span, some(m.node.ident),\n-                       m.node.id, e, v);\n+            v.visit_fn_proto(m.node.meth, m.node.tps, m.span,\n+                             some(m.node.ident), m.node.id, e, v);\n         }\n       }\n     }\n@@ -193,10 +204,21 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn<E>(f: _fn, _tp: [ty_param], _sp: span, _i: fn_ident, _id: node_id,\n-               e: E, v: vt<E>) {\n-    visit_fn_decl(f.decl, e, v);\n-    v.visit_block(f.body, e, v);\n+fn visit_fn_proto<E>(f: _fn, _tp: [ty_param], sp: span, i: fn_ident,\n+                     id: node_id, e: E, v: vt<E>) {\n+    v.visit_fn_body(f.decl, f.body, sp, i, id, e, v);\n+}\n+\n+fn visit_fn_block<E>(decl: fn_decl, body: blk, sp: span, id: node_id,\n+                     e: E, v: vt<E>) {\n+    v.visit_fn_body(decl, body, sp, option::none, id, e, v);\n+}\n+\n+fn visit_fn_body<E>(decl: fn_decl, body: blk, _sp: span,\n+                    _name: fn_ident, _id: node_id,\n+                    e: E, v: vt<E>) {\n+    visit_fn_decl(decl, e, v);\n+    v.visit_block(body, e, v);\n }\n \n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n@@ -284,8 +306,12 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(x, e, v);\n         for a: arm in arms { v.visit_arm(a, e, v); }\n       }\n-      // NDM add visit routine?\n-      expr_fn(f, captures) { v.visit_fn(f, [], ex.span, none, ex.id, e, v); }\n+      expr_fn(f, captures) {\n+        v.visit_fn_proto(f, [], ex.span, none, ex.id, e, v);\n+      }\n+      expr_fn_block(decl, body) {\n+        v.visit_fn_block(decl, body, ex.span, ex.id, e, v);\n+      }\n       expr_block(b) { v.visit_block(b, e, v); }\n       expr_assign(a, b) { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n       expr_copy(a) { v.visit_expr(a, e, v); }\n@@ -324,8 +350,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n           some(ex) { v.visit_expr(ex, e, v); }\n         }\n         for m: @method in anon_obj.methods {\n-            v.visit_fn(m.node.meth, m.node.tps, m.span, some(m.node.ident),\n-                       m.node.id, e, v);\n+            v.visit_fn_proto(m.node.meth, m.node.tps, m.span,\n+                             some(m.node.ident), m.node.id, e, v);\n         }\n       }\n       expr_mac(mac) { visit_mac(mac, e, v); }\n@@ -357,7 +383,9 @@ type simple_visitor =\n       visit_expr: fn@(@expr),\n       visit_ty: fn@(@ty),\n       visit_constr: fn@(@path, span, node_id),\n-      visit_fn: fn@(_fn, [ty_param], span, fn_ident, node_id)};\n+      visit_fn_proto: fn@(_fn, [ty_param], span, fn_ident, node_id),\n+      visit_fn_block: fn@(fn_decl, blk, span, node_id),\n+      visit_fn_body: fn@(fn_decl, blk, span, fn_ident, node_id)};\n \n fn simple_ignore_ty(_t: @ty) {}\n \n@@ -375,10 +403,15 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_expr: fn(_e: @expr) { },\n           visit_ty: simple_ignore_ty,\n           visit_constr: fn(_p: @path, _sp: span, _id: node_id) { },\n-          visit_fn:\n+          visit_fn_proto:\n               fn(_f: _fn, _tps: [ty_param], _sp: span, _ident: fn_ident,\n-                  _id: node_id) {\n-              }};\n+                  _id: node_id) { },\n+          visit_fn_block:\n+              fn(_f: fn_decl, _b: blk, _sp: span, _node_id: node_id) { },\n+          visit_fn_body:\n+              fn(_f: fn_decl, _b: blk, _sp: span,\n+                 _nm: fn_ident, _node_id: node_id) { }\n+         };\n }\n \n fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n@@ -440,7 +473,21 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n             tps: [ty_param], sp: span, ident: fn_ident, id: node_id, &&e: (),\n             v: vt<()>) {\n         f(ff, tps, sp, ident, id);\n-        visit_fn(ff, tps, sp, ident, id, e, v);\n+        visit_fn_proto(ff, tps, sp, ident, id, e, v);\n+    }\n+    fn v_fn_block(f: fn@(fn_decl, blk, span, node_id),\n+                  fn_decl: fn_decl, blk: blk,\n+                  sp: span, node_id: node_id,\n+                  &&e: (), v: vt<()>) {\n+        f(fn_decl, blk, sp, node_id);\n+        visit_fn_block(fn_decl, blk, sp, node_id, e, v);\n+    }\n+    fn v_fn_body(f: fn@(fn_decl, blk, span, fn_ident, node_id),\n+                 fn_decl: fn_decl, blk: blk,\n+                 sp: span, name: fn_ident, node_id: node_id,\n+                 &&e: (), v: vt<()>) {\n+        f(fn_decl, blk, sp, name, node_id);\n+        visit_fn_body(fn_decl, blk, sp, name, node_id, e, v);\n     }\n     let visit_ty = if v.visit_ty == simple_ignore_ty {\n         bind skip_ty(_, _, _)\n@@ -461,7 +508,13 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_expr: bind v_expr(v.visit_expr, _, _, _),\n                 visit_ty: visit_ty,\n                 visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n-                visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _)});\n+                visit_fn_proto:\n+                    bind v_fn(v.visit_fn_proto, _, _, _, _, _, _, _),\n+                visit_fn_block:\n+                    bind v_fn_block(v.visit_fn_block, _, _, _, _, _, _),\n+                visit_fn_body:\n+                    bind v_fn_body(v.visit_fn_body, _, _, _, _, _, _, _),\n+               });\n }\n \n // Local Variables:"}]}