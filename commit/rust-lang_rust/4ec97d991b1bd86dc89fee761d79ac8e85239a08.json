{"sha": "4ec97d991b1bd86dc89fee761d79ac8e85239a08", "node_id": "C_kwDOAAsO6NoAKDRlYzk3ZDk5MWIxYmQ4NmRjODlmZWU3NjFkNzlhYzhlODUyMzlhMDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-10T08:54:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-10T08:54:32Z"}, "message": "Auto merge of #95295 - CAD97:layout-isize, r=scottmcm\n\nEnforce that layout size fits in isize in Layout\n\nAs it turns out, enforcing this _in APIs that already enforce `usize` overflow_ is fairly trivial. `Layout::from_size_align_unchecked` continues to \"allow\" sizes which (when rounded up) would overflow `isize`, but these are now declared as library UB for `Layout`, meaning that consumers of `Layout` no longer have to check this before making an allocation.\n\n(Note that this is \"immediate library UB;\" IOW it is valid for a future release to make this immediate \"language UB,\" and there is an extant patch to do so, to allow Miri to catch this misuse.)\n\nSee also #95252, [Zulip discussion](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule).\nFixes https://github.com/rust-lang/rust/issues/95334\n\nSome relevant quotes:\n\n`@eddyb,` https://github.com/rust-lang/rust/pull/95252#issuecomment-1078513769\n\n> [B]ecause of the non-trivial presence of both of these among code published on e.g. crates.io:\n>\n>   1. **`Layout` \"producers\" / `GlobalAlloc` \"users\"**: smart pointers (including `alloc::rc` copies with small tweaks), collections, etc.\n>   2. **`Layout` \"consumers\" / `GlobalAlloc` \"providers\"**: perhaps fewer of these, but anything built on top of OS APIs like `mmap` will expose `> isize::MAX` allocations (on 32-bit hosts) if they lack extra checks\n>\n> IMO the only responsible option is to enforce the `isize::MAX` limit in `Layout`, which:\n>\n>   * makes `Layout` _sound_ in terms of only ever allowing allocations where `(alloc_base_ptr: *mut u8).offset(size)` is never UB\n>   * frees both \"producers\" and \"consumers\" of `Layout` from manually reimplementing the checks\n>     * manual checks can be risky, e.g. if the final size passed to the allocator isn't the one being checked\n>     * this applies retroactively, fixing the overall soundness of existing code with zero transition period or _any_ changes required from users (as long as going through `Layout` is mandatory, making a \"choke point\")\n>\n>\n> Feel free to quote this comment onto any relevant issue, I might not be able to keep track of developments.\n\n`@Gankra,` https://github.com/rust-lang/rust/pull/95252#issuecomment-1078556371\n\n> As someone who spent way too much time optimizing libcollections checks for this stuff and tried to splatter docs about it everywhere on the belief that it was a reasonable thing for people to manually take care of: I concede the point, it is not reasonable. I am wholy spiritually defeated by the fact that _liballoc_ of all places is getting this stuff wrong. This isn't throwing shade at the folks who implemented these Rc features, but rather a statement of how impractical it is to expect anyone out in the wider ecosystem to enforce them if _some of the most audited rust code in the library that defines the very notion of allocating memory_ can't even reliably do it.\n>\n> We need the nuclear option of Layout enforcing this rule. Code that breaks this rule is _deeply_ broken and any \"regressions\" from changing Layout's contract is a _correctness_ fix. Anyone who disagrees and is sufficiently motivated can go around our backs but the standard library should 100% refuse to enable them.\n\ncc also `@RalfJung` `@rust-lang/wg-allocators.` Even though this technically supersedes #95252, those potential failure points should almost certainly still get nicer panics than just \"unwrap failed\" (which they would get by this PR).\n\nIt might additionally be worth recommending to users of the `Layout` API that they should ideally use `.and_then`/`?` to complete the entire layout calculation, and then `panic!` from a single location at the end of `Layout` manipulation, to reduce the overhead of the checks and optimizations preserving the exact location of each `panic` which are conceptually just one failure: allocation too big.\n\nProbably deserves a T-lang and/or T-libs-api FCP (this technically solidifies the [objects must be no larger than `isize::MAX`](https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html#isize-and-usize) rule further, and the UCG document says this hasn't been RFCd) and a crater run. Ideally, no code exists that will start failing with this addition; if it does, it was _likely_ (but not certainly) causing UB.\n\nChanges the raw_vec allocation path, thus deserves a perf run as well.\n\nI suggest hiding whitespace-only changes in the diff view.", "tree": {"sha": "1ca6b62bc8c438713cca99270a09d937bfc23530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ca6b62bc8c438713cca99270a09d937bfc23530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ec97d991b1bd86dc89fee761d79ac8e85239a08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec97d991b1bd86dc89fee761d79ac8e85239a08", "html_url": "https://github.com/rust-lang/rust/commit/4ec97d991b1bd86dc89fee761d79ac8e85239a08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ec97d991b1bd86dc89fee761d79ac8e85239a08/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95e77648e466c780a9adce2fa3d3eb5e423dc04e", "url": "https://api.github.com/repos/rust-lang/rust/commits/95e77648e466c780a9adce2fa3d3eb5e423dc04e", "html_url": "https://github.com/rust-lang/rust/commit/95e77648e466c780a9adce2fa3d3eb5e423dc04e"}, {"sha": "344b99bd9f6415c08bee367ecc12fb3a5f84ac76", "url": "https://api.github.com/repos/rust-lang/rust/commits/344b99bd9f6415c08bee367ecc12fb3a5f84ac76", "html_url": "https://github.com/rust-lang/rust/commit/344b99bd9f6415c08bee367ecc12fb3a5f84ac76"}], "stats": {"total": 487, "additions": 156, "deletions": 331}, "files": [{"sha": "99d1296a4c92564faf34bd1f8fdfc3542c57a7c5", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 38, "deletions": 88, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=4ec97d991b1bd86dc89fee761d79ac8e85239a08", "patch": "@@ -693,12 +693,6 @@ fn test_try_reserve() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n-    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n-    // Any platform that succeeds for these requests is technically broken with\n-    // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = usize::BITS < 64;\n-\n     {\n         // Note: basic stuff is checked by test_reserve\n         let mut empty_string: String = String::new();\n@@ -712,35 +706,19 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            // Check isize::MAX + 1 does count as overflow\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            // Check usize::MAX does count as overflow\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX + 1 is an OOM\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            // Check usize::MAX is an OOM\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        // Check isize::MAX + 1 does count as overflow\n+        assert_matches!(\n+            empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        // Check usize::MAX does count as overflow\n+        assert_matches!(\n+            empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -753,19 +731,13 @@ fn test_try_reserve() {\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should always overflow in the add-to-len\n         assert_matches!(\n             ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n@@ -785,8 +757,6 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = usize::BITS < 64;\n-\n     {\n         let mut empty_string: String = String::new();\n \n@@ -799,31 +769,17 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        assert_matches!(\n+            empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        assert_matches!(\n+            empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -839,19 +795,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n             Err(CapacityOverflow),"}, {"sha": "699567be5a004224252367d7c0daf4799b444d01", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 52, "deletions": 114, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=4ec97d991b1bd86dc89fee761d79ac8e85239a08", "patch": "@@ -1517,12 +1517,6 @@ fn test_try_reserve() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n-    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n-    // Any platform that succeeds for these requests is technically broken with\n-    // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = usize::BITS < 64;\n-\n     {\n         // Note: basic stuff is checked by test_reserve\n         let mut empty_bytes: Vec<u8> = Vec::new();\n@@ -1536,35 +1530,19 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            // Check isize::MAX + 1 does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            // Check usize::MAX does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX + 1 is an OOM\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            // Check usize::MAX is an OOM\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        // Check isize::MAX + 1 does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        // Check usize::MAX does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1577,19 +1555,13 @@ fn test_try_reserve() {\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should always overflow in the add-to-len\n         assert_matches!(\n             ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n@@ -1610,19 +1582,13 @@ fn test_try_reserve() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should fail in the mul-by-size\n         assert_matches!(\n             ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n@@ -1642,8 +1608,6 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = size_of::<usize>() < 8;\n-\n     {\n         let mut empty_bytes: Vec<u8> = Vec::new();\n \n@@ -1656,31 +1620,17 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1696,19 +1646,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n             Err(CapacityOverflow),\n@@ -1729,19 +1673,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n             Err(CapacityOverflow),"}, {"sha": "019d73c0b16bbb03b43281aad5d0a56983cf9e9a", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 52, "deletions": 109, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=4ec97d991b1bd86dc89fee761d79ac8e85239a08", "patch": "@@ -2,7 +2,6 @@ use std::assert_matches::assert_matches;\n use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n-use std::mem::size_of;\n use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n@@ -1161,12 +1160,6 @@ fn test_try_reserve() {\n     const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n-    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n-    // Any platform that succeeds for these requests is technically broken with\n-    // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = size_of::<usize>() < 8;\n-\n     {\n         // Note: basic stuff is checked by test_reserve\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n@@ -1180,31 +1173,19 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            // Check isize::MAX + 1 does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            // Check usize::MAX does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX is an OOM\n-            // VecDeque starts with capacity 7, always adds 1 to the capacity\n-            // and also rounds the number to next power of 2 so this is the\n-            // furthest we can go without triggering CapacityOverflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+        // Check isize::MAX + 1 does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        // Check usize::MAX does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1217,19 +1198,13 @@ fn test_try_reserve() {\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should always overflow in the add-to-len\n         assert_matches!(\n             ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n@@ -1250,19 +1225,13 @@ fn test_try_reserve() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should fail in the mul-by-size\n         assert_matches!(\n             ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n@@ -1282,8 +1251,6 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = size_of::<usize>() < 8;\n-\n     {\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n \n@@ -1296,29 +1263,17 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX is an OOM\n-            // VecDeque starts with capacity 7, always adds 1 to the capacity\n-            // and also rounds the number to next power of 2 so this is the\n-            // furthest we can go without triggering CapacityOverflow\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1334,19 +1289,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n             Err(CapacityOverflow),\n@@ -1367,19 +1316,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n             Err(CapacityOverflow),"}, {"sha": "39bccdb854c30421ae32ddacc6038df05ba89639", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec97d991b1bd86dc89fee761d79ac8e85239a08/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=4ec97d991b1bd86dc89fee761d79ac8e85239a08", "patch": "@@ -52,8 +52,8 @@ impl Layout {\n     /// * `align` must be a power of two,\n     ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n-    ///    must not overflow (i.e., the rounded value must be less than\n-    ///    or equal to `usize::MAX`).\n+    ///    must not overflow isize (i.e., the rounded value must be\n+    ///    less than or equal to `isize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[rustc_const_stable(feature = \"const_alloc_layout_size_align\", since = \"1.50.0\")]\n     #[inline]\n@@ -76,7 +76,7 @@ impl Layout {\n         //\n         // Above implies that checking for summation overflow is both\n         // necessary and sufficient.\n-        if size > usize::MAX - (align - 1) {\n+        if size > isize::MAX as usize - (align - 1) {\n             return Err(LayoutError);\n         }\n \n@@ -276,8 +276,8 @@ impl Layout {\n         let pad = self.padding_needed_for(self.align());\n         // This cannot overflow. Quoting from the invariant of Layout:\n         // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n+        // > must not overflow isize (i.e., the rounded value must be\n+        // > less than or equal to `isize::MAX`)\n         let new_size = self.size() + pad;\n \n         // SAFETY: self.align is already known to be valid and new_size has been\n@@ -298,14 +298,13 @@ impl Layout {\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {\n         // This cannot overflow. Quoting from the invariant of Layout:\n         // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n+        // > must not overflow isize (i.e., the rounded value must be\n+        // > less than or equal to `isize::MAX`)\n         let padded_size = self.size() + self.padding_needed_for(self.align());\n         let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;\n \n-        // SAFETY: self.align is already known to be valid and alloc_size has been\n-        // padded already.\n-        unsafe { Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size)) }\n+        // The safe constructor is called here to enforce the isize size limit.\n+        Layout::from_size_align(alloc_size, self.align()).map(|layout| (layout, padded_size))\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -362,6 +361,7 @@ impl Layout {\n         let offset = self.size().checked_add(pad).ok_or(LayoutError)?;\n         let new_size = offset.checked_add(next.size()).ok_or(LayoutError)?;\n \n+        // The safe constructor is called here to enforce the isize size limit.\n         let layout = Layout::from_size_align(new_size, new_align)?;\n         Ok((layout, offset))\n     }\n@@ -382,6 +382,7 @@ impl Layout {\n     #[inline]\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n         let size = self.size().checked_mul(n).ok_or(LayoutError)?;\n+        // The safe constructor is called here to enforce the isize size limit.\n         Layout::from_size_align(size, self.align())\n     }\n \n@@ -395,6 +396,7 @@ impl Layout {\n     #[inline]\n     pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n         let new_size = self.size().checked_add(next.size()).ok_or(LayoutError)?;\n+        // The safe constructor is called here to enforce the isize size limit.\n         Layout::from_size_align(new_size, self.align())\n     }\n \n@@ -405,16 +407,8 @@ impl Layout {\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutError> {\n         let array_size = mem::size_of::<T>().checked_mul(n).ok_or(LayoutError)?;\n-\n-        // SAFETY:\n-        // - Size: `array_size` cannot be too big because `size_of::<T>()` must\n-        //   be a multiple of `align_of::<T>()`. Therefore, `array_size`\n-        //   rounded up to the nearest multiple of `align_of::<T>()` is just\n-        //   `array_size`. And `array_size` cannot be too big because it was\n-        //   just checked by the `checked_mul()`.\n-        // - Alignment: `align_of::<T>()` will always give an acceptable\n-        //   (non-zero, power of two) alignment.\n-        Ok(unsafe { Layout::from_size_align_unchecked(array_size, mem::align_of::<T>()) })\n+        // The safe constructor is called here to enforce the isize size limit.\n+        Layout::from_size_align(array_size, mem::align_of::<T>())\n     }\n }\n "}]}