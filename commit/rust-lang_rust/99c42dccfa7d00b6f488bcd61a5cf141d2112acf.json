{"sha": "99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YzQyZGNjZmE3ZDAwYjZmNDg4YmNkNjFhNWNmMTQxZDIxMTJhY2Y=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-03-01T19:43:03Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-03-01T19:43:03Z"}, "message": "rustfmt over error_reporting, explain_borrow and region_infer mods", "tree": {"sha": "2efddcedf6f04b6e3d0212c17a6d0e18f316cbca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2efddcedf6f04b6e3d0212c17a6d0e18f316cbca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlqYV8cACgkQiMlBzaHU\nZDLRPRAArylNw0m4e2/UAJLieSfxqyfB9x5s2p/I33NKRjI+DnkfEFyU459l889b\nRgptDWfrtI8yrUhyoK+NJZzuLMtsinqyq9EzhZmpfMBao6+H9DJkUd5gMQoGYMru\nv44EbsqjQrErW2FWoLtr2J6iZ/rIeee4Hnq57U0xSvgbRYLEhGy9I+wq3HRKCq6P\nNycVQ7Z1eVOidXElsDS+6/sIbObdOv0C+aSBMtPyveke8xa6GPTLc7P2AVbNgJZp\nnvskhTMFLK6ibhG2J4Dx9NIhTAsP4Yl9Fe0orq8pv01uqnWTjdcn6zIGEu/oQS4N\nz9pGjqYR8v8MmjCiokdZuYGqBKgJfxG6t4fOO8GH5R7LOfkhe9pnk+6v+kWIkir0\nnAY/jE/PMPfCmBL52AXh+39q89BWkQkIbQtpejZadjKWn+nzA9YhmZsIufSUaFfm\nkYz7T3zSr9zBxXvO/Au1YgkDpJIT5vxNbCdwcrBaa/GNxleAmkvOBwm+r7XPTWd3\nwF33ehZg8HzujGnH/FWFDQyaz1uwTrQBvCJm6aDNNYlB/NIDLF35Lf7mQLbsILIj\nThcIxSMC79FyJbJ1fyRyDWRUbw6SGeelApoLGnOsnIRrbcTyGhXwnF+aRUsd3luF\n5hLPa/l3ffd678ieaZKXwUZTk60d/tH0UB2ImJCD25CN/DBKXRg=\n=qefN\n-----END PGP SIGNATURE-----", "payload": "tree 2efddcedf6f04b6e3d0212c17a6d0e18f316cbca\nparent ff7dca50a47d03764c74cac6d803e17c9d9f2a7b\nauthor Santiago Pastorino <spastorino@gmail.com> 1519933383 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1519933383 -0300\n\nrustfmt over error_reporting, explain_borrow and region_infer mods\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "html_url": "https://github.com/rust-lang/rust/commit/99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff7dca50a47d03764c74cac6d803e17c9d9f2a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff7dca50a47d03764c74cac6d803e17c9d9f2a7b", "html_url": "https://github.com/rust-lang/rust/commit/ff7dca50a47d03764c74cac6d803e17c9d9f2a7b"}], "stats": {"total": 967, "additions": 513, "deletions": 454}, "files": [{"sha": "37a84361aea2d0d8ad56200781e31846ab5ae49f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 404, "deletions": 334, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "patch": "@@ -56,7 +56,7 @@\n //! time of error detection.\n \n use infer;\n-use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n+use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n \n@@ -81,18 +81,22 @@ mod need_type_info;\n pub mod nice_region_error;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn note_and_explain_region(self,\n-                                   region_scope_tree: &region::ScopeTree,\n-                                   err: &mut DiagnosticBuilder,\n-                                   prefix: &str,\n-                                   region: ty::Region<'tcx>,\n-                                   suffix: &str) {\n+    pub fn note_and_explain_region(\n+        self,\n+        region_scope_tree: &region::ScopeTree,\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        region: ty::Region<'tcx>,\n+        suffix: &str,\n+    ) {\n         let (description, span) = match *region {\n             ty::ReScope(scope) => {\n                 let new_string;\n                 let unknown_scope = || {\n-                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n-                            prefix, scope, suffix)\n+                    format!(\n+                        \"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                        prefix, scope, suffix\n+                    )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n@@ -101,8 +105,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprCall(..) => \"call\",\n                         hir::ExprMethodCall(..) => \"method call\",\n                         hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n                         hir::ExprMatch(..) => \"match\",\n                         _ => \"expression\",\n                     },\n@@ -117,29 +121,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let scope_decorated_tag = match scope.data() {\n                     region::ScopeData::Node(_) => tag,\n-                    region::ScopeData::CallSite(_) => {\n-                        \"scope of call-site for function\"\n-                    }\n-                    region::ScopeData::Arguments(_) => {\n-                        \"scope of function body\"\n-                    }\n+                    region::ScopeData::CallSite(_) => \"scope of call-site for function\",\n+                    region::ScopeData::Arguments(_) => \"scope of function body\",\n                     region::ScopeData::Destruction(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n                     region::ScopeData::Remainder(r) => {\n-                        new_string = format!(\"block suffix following statement {}\",\n-                                             r.first_statement_index.index());\n+                        new_string = format!(\n+                            \"block suffix following statement {}\",\n+                            r.first_statement_index.index()\n+                        );\n                         &new_string[..]\n                     }\n                 };\n                 self.explain_span(scope_decorated_tag, span)\n             }\n \n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(_) => {\n-                self.msg_span_from_free_region(region)\n-            }\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => self.msg_span_from_free_region(region),\n \n             ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n \n@@ -150,92 +149,93 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             //\n             // We shouldn't really be having unification failures with ReVar\n             // and ReLateBound though.\n-            ty::ReSkolemized(..) |\n-            ty::ReVar(_) |\n-            ty::ReLateBound(..) |\n-            ty::ReErased => {\n+            ty::ReSkolemized(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n             ty::ReClosureBound(..) => {\n-                bug!(\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n-                    region,\n-                );\n+                bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n             }\n         };\n \n         TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n     }\n \n-    pub fn note_and_explain_free_region(self,\n-                                        err: &mut DiagnosticBuilder,\n-                                        prefix: &str,\n-                                        region: ty::Region<'tcx>,\n-                                        suffix: &str) {\n+    pub fn note_and_explain_free_region(\n+        self,\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        region: ty::Region<'tcx>,\n+        suffix: &str,\n+    ) {\n         let (description, span) = self.msg_span_from_free_region(region);\n \n-\n         TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n     }\n \n-    fn msg_span_from_free_region(self,\n-                                 region: ty::Region<'tcx>)\n-        -> (String, Option<Span>) {\n+    fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n         let scope = region.free_region_binding_scope(self);\n-        let node = self.hir.as_local_node_id(scope)\n-            .unwrap_or(DUMMY_NODE_ID);\n+        let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let unknown;\n         let tag = match self.hir.find(node) {\n-            Some(hir_map::NodeBlock(_)) |\n-                Some(hir_map::NodeExpr(_)) => \"body\",\n+            Some(hir_map::NodeBlock(_)) | Some(hir_map::NodeExpr(_)) => \"body\",\n             Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n             Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n             Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n \n             // this really should not happen, but it does:\n             // FIXME(#27942)\n             Some(_) => {\n-                unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n-                                           Please report a bug.\",\n-                                           self.hir.node_to_string(node), scope);\n+                unknown = format!(\n+                    \"unexpected node ({}) for scope {:?}.  \\\n+                     Please report a bug.\",\n+                    self.hir.node_to_string(node),\n+                    scope\n+                );\n                 &unknown\n             }\n             None => {\n-                unknown = format!(\"unknown node for scope {:?}.  \\\n-                                           Please report a bug.\", scope);\n+                unknown = format!(\n+                    \"unknown node for scope {:?}.  \\\n+                     Please report a bug.\",\n+                    scope\n+                );\n                 &unknown\n             }\n         };\n         let (prefix, span) = match *region {\n-            ty::ReEarlyBound(ref br) => {\n-                (format!(\"the lifetime {} as defined on\", br.name),\n-                self.sess.codemap().def_span(self.hir.span(node)))\n-            }\n-            ty::ReFree(ref fr) => {\n-                match fr.bound_region {\n-                    ty::BrAnon(idx) => {\n-                        (format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                        self.hir.span(node))\n-                    }\n-                    ty::BrFresh(_) => (\"an anonymous lifetime defined on\".to_owned(),\n-                    self.hir.span(node)),\n-                    _ => (format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                    self.sess.codemap().def_span(self.hir.span(node))),\n-                }\n-            }\n-            _ => bug!()\n+            ty::ReEarlyBound(ref br) => (\n+                format!(\"the lifetime {} as defined on\", br.name),\n+                self.sess.codemap().def_span(self.hir.span(node)),\n+            ),\n+            ty::ReFree(ref fr) => match fr.bound_region {\n+                ty::BrAnon(idx) => (\n+                    format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n+                    self.hir.span(node),\n+                ),\n+                ty::BrFresh(_) => (\n+                    \"an anonymous lifetime defined on\".to_owned(),\n+                    self.hir.span(node),\n+                ),\n+                _ => (\n+                    format!(\"the lifetime {} as defined on\", fr.bound_region),\n+                    self.sess.codemap().def_span(self.hir.span(node)),\n+                ),\n+            },\n+            _ => bug!(),\n         };\n         let (msg, opt_span) = self.explain_span(tag, span);\n         (format!(\"{} {}\", prefix, msg), opt_span)\n     }\n \n-    fn emit_msg_span(err: &mut DiagnosticBuilder,\n-                     prefix: &str,\n-                     description: String,\n-                     span: Option<Span>,\n-                     suffix: &str) {\n+    fn emit_msg_span(\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        description: String,\n+        span: Option<Span>,\n+        suffix: &str,\n+    ) {\n         let message = format!(\"{}{}{}\", prefix, description, suffix);\n \n         if let Some(span) = span {\n@@ -253,40 +253,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::ItemEnum(..) => \"enum\",\n             hir::ItemTrait(..) => \"trait\",\n             hir::ItemFn(..) => \"function body\",\n-            _ => \"item\"\n+            _ => \"item\",\n         }\n     }\n \n     fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n         match item.node {\n             hir::TraitItemKind::Method(..) => \"method body\",\n-            hir::TraitItemKind::Const(..) |\n-                hir::TraitItemKind::Type(..) => \"associated item\"\n+            hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n         }\n     }\n \n     fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n         match item.node {\n             hir::ImplItemKind::Method(..) => \"method body\",\n-            hir::ImplItemKind::Const(..) |\n-                hir::ImplItemKind::Type(_) => \"associated item\"\n+            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) => \"associated item\",\n         }\n     }\n \n-    fn explain_span(self,\n-                    heading: &str, span: Span)\n-        -> (String, Option<Span>) {\n+    fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n         let lo = self.sess.codemap().lookup_char_pos_adj(span.lo());\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n-         Some(span))\n+        (\n+            format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n+            Some(span),\n+        )\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_region_errors(&self,\n-                                region_scope_tree: &region::ScopeTree,\n-                                errors: &Vec<RegionResolutionError<'tcx>>,\n-                                will_later_be_reported_by_nll: bool) {\n+    pub fn report_region_errors(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        errors: &Vec<RegionResolutionError<'tcx>>,\n+        will_later_be_reported_by_nll: bool,\n+    ) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         if will_later_be_reported_by_nll && self.tcx.sess.nll() {\n@@ -300,17 +300,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // But with -Znll, it's nice to have some note for later.\n             for error in errors {\n                 match *error {\n-                    RegionResolutionError::ConcreteFailure(ref origin, ..) |\n-                    RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n-                        self.tcx.sess.span_warn(\n-                            origin.span(),\n-                            \"not reporting region error due to -Znll\");\n+                    RegionResolutionError::ConcreteFailure(ref origin, ..)\n+                    | RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n+                        self.tcx\n+                            .sess\n+                            .span_warn(origin.span(), \"not reporting region error due to -Znll\");\n                     }\n \n                     RegionResolutionError::SubSupConflict(ref rvo, ..) => {\n-                        self.tcx.sess.span_warn(\n-                            rvo.span(),\n-                            \"not reporting region error due to -Znll\");\n+                        self.tcx\n+                            .sess\n+                            .span_warn(rvo.span(), \"not reporting region error due to -Znll\");\n                     }\n                 }\n             }\n@@ -322,7 +322,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);\n \n-        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+        debug!(\n+            \"report_region_errors: {} errors after preprocessing\",\n+            errors.len()\n+        );\n \n         for error in errors {\n             debug!(\"report_region_errors: error = {:?}\", error);\n@@ -337,7 +340,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // the error. If all of these fails, we fall back to a rather\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n-                        self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n+                        self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n+                            .emit();\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n@@ -350,17 +354,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         );\n                     }\n \n-                    RegionResolutionError::SubSupConflict(var_origin,\n-                                                          sub_origin,\n-                                                          sub_r,\n-                                                          sup_origin,\n-                                                          sup_r) => {\n-                        self.report_sub_sup_conflict(region_scope_tree,\n-                                                     var_origin,\n-                                                     sub_origin,\n-                                                     sub_r,\n-                                                     sup_origin,\n-                                                     sup_r);\n+                    RegionResolutionError::SubSupConflict(\n+                        var_origin,\n+                        sub_origin,\n+                        sub_r,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        self.report_sub_sup_conflict(\n+                            region_scope_tree,\n+                            var_origin,\n+                            sub_origin,\n+                            sub_r,\n+                            sup_origin,\n+                            sup_r,\n+                        );\n                     }\n                 }\n             }\n@@ -377,8 +385,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // The method also attempts to weed out messages that seem like\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>> {\n+    fn process_errors(\n+        &self,\n+        errors: &Vec<RegionResolutionError<'tcx>>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n \n         // We want to avoid reporting generic-bound failures if we can\n@@ -395,15 +405,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n-            RegionResolutionError::ConcreteFailure(..) |\n-            RegionResolutionError::SubSupConflict(..) => false,\n+            RegionResolutionError::ConcreteFailure(..)\n+            | RegionResolutionError::SubSupConflict(..) => false,\n         };\n \n-\n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n             errors.clone()\n         } else {\n-            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n+            errors\n+                .iter()\n+                .filter(|&e| !is_bound_failure(e))\n+                .cloned()\n+                .collect()\n         };\n \n         // sort the errors by span, for better error message stability.\n@@ -416,10 +429,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(&self,\n-                                         err: &mut DiagnosticBuilder,\n-                                         terr: &TypeError<'tcx>,\n-                                         sp: Span) {\n+    fn check_and_note_conflicting_crates(\n+        &self,\n+        err: &mut DiagnosticBuilder,\n+        terr: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         let report_path_match = |err: &mut DiagnosticBuilder, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n@@ -430,12 +445,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let found_abs_path = self.tcx.absolute_item_path_str(did2);\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n-                if exp_path == found_path\n-                || exp_abs_path == found_abs_path {\n+                if exp_path == found_path || exp_abs_path == found_abs_path {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n-                    err.span_note(sp, &format!(\"Perhaps two different versions \\\n-                                                of crate `{}` are being used?\",\n-                                               crate_name));\n+                    err.span_note(\n+                        sp,\n+                        &format!(\n+                            \"Perhaps two different versions \\\n+                             of crate `{}` are being used?\",\n+                            crate_name\n+                        ),\n+                    );\n                 }\n             }\n         };\n@@ -446,24 +465,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n                     (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 }\n-            },\n+            }\n             TypeError::Traits(ref exp_found) => {\n                 report_path_match(err, exp_found.expected, exp_found.found);\n-            },\n-            _ => () // FIXME(#22750) handle traits and stuff\n+            }\n+            _ => (), // FIXME(#22750) handle traits and stuff\n         }\n     }\n \n-    fn note_error_origin(&self,\n-                         err: &mut DiagnosticBuilder<'tcx>,\n-                         cause: &ObligationCause<'tcx>)\n-    {\n+    fn note_error_origin(&self, err: &mut DiagnosticBuilder<'tcx>, cause: &ObligationCause<'tcx>) {\n         match cause.code {\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n-                hir::MatchSource::IfLetDesugar {..} => {\n+                hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";\n                     if self.tcx.sess.codemap().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n@@ -480,7 +496,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -497,13 +513,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Bar<Qux>\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n-    fn highlight_outer(&self,\n-                       value: &mut DiagnosticStyledString,\n-                       other_value: &mut DiagnosticStyledString,\n-                       name: String,\n-                       sub: &ty::subst::Substs<'tcx>,\n-                       pos: usize,\n-                       other_ty: &Ty<'tcx>) {\n+    fn highlight_outer(\n+        &self,\n+        value: &mut DiagnosticStyledString,\n+        other_value: &mut DiagnosticStyledString,\n+        name: String,\n+        sub: &ty::subst::Substs<'tcx>,\n+        pos: usize,\n+        other_ty: &Ty<'tcx>,\n+    ) {\n         // `value` and `other_value` hold two incomplete type representation for display.\n         // `name` is the path of both types being compared. `sub`\n         value.push_highlighted(name);\n@@ -513,14 +531,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Output the lifetimes fot the first type\n-        let lifetimes = sub.regions().map(|lifetime| {\n-            let s = format!(\"{}\", lifetime);\n-            if s.is_empty() {\n-                \"'_\".to_string()\n-            } else {\n-                s\n-            }\n-        }).collect::<Vec<_>>().join(\", \");\n+        let lifetimes = sub.regions()\n+            .map(|lifetime| {\n+                let s = format!(\"{}\", lifetime);\n+                if s.is_empty() {\n+                    \"'_\".to_string()\n+                } else {\n+                    s\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n         if !lifetimes.is_empty() {\n             if sub.regions().count() < len {\n                 value.push_normal(lifetimes + &\", \");\n@@ -570,13 +591,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Bar<Qux>\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n-    fn cmp_type_arg(&self,\n-                    mut t1_out: &mut DiagnosticStyledString,\n-                    mut t2_out: &mut DiagnosticStyledString,\n-                    path: String,\n-                    sub: &ty::subst::Substs<'tcx>,\n-                    other_path: String,\n-                    other_ty: &Ty<'tcx>) -> Option<()> {\n+    fn cmp_type_arg(\n+        &self,\n+        mut t1_out: &mut DiagnosticStyledString,\n+        mut t2_out: &mut DiagnosticStyledString,\n+        path: String,\n+        sub: &ty::subst::Substs<'tcx>,\n+        other_path: String,\n+        other_ty: &Ty<'tcx>,\n+    ) -> Option<()> {\n         for (i, ta) in sub.types().enumerate() {\n             if &ta == other_ty {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -594,11 +617,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Add a `,` to the type representation only if it is appropriate.\n-    fn push_comma(&self,\n-                  value: &mut DiagnosticStyledString,\n-                  other_value: &mut DiagnosticStyledString,\n-                  len: usize,\n-                  pos: usize) {\n+    fn push_comma(\n+        &self,\n+        value: &mut DiagnosticStyledString,\n+        other_value: &mut DiagnosticStyledString,\n+        len: usize,\n+        pos: usize,\n+    ) {\n         if len > 0 && pos != len - 1 {\n             value.push_normal(\", \");\n             other_value.push_normal(\", \");\n@@ -607,39 +632,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Compare two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n-    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>)\n-        -> (DiagnosticStyledString, DiagnosticStyledString)\n-    {\n+    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n                 (a, b) if *a == *b => true,\n-                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_))) |\n-                (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_)) |\n-                (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_))) |\n-                (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_))) |\n-                (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_)) |\n-                (&ty::TyInfer(ty::InferTy::FloatVar(_)),\n-                 &ty::TyInfer(ty::InferTy::FloatVar(_))) => true,\n+                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_))\n+                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_)))\n+                | (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_))\n+                | (\n+                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                ) => true,\n                 _ => false,\n             }\n         }\n \n-        fn push_ty_ref<'tcx>(r: &ty::Region<'tcx>,\n-                             tnm: &ty::TypeAndMut<'tcx>,\n-                             s: &mut DiagnosticStyledString) {\n+        fn push_ty_ref<'tcx>(\n+            r: &ty::Region<'tcx>,\n+            tnm: &ty::TypeAndMut<'tcx>,\n+            s: &mut DiagnosticStyledString,\n+        ) {\n             let r = &format!(\"{}\", r);\n-            s.push_highlighted(format!(\"&{}{}{}\",\n-                                       r,\n-                                       if r == \"\" {\n-                                           \"\"\n-                                       } else {\n-                                           \" \"\n-                                       },\n-                                       if tnm.mutbl == hir::MutMutable {\n-                                          \"mut \"\n-                                       } else {\n-                                           \"\"\n-                                       }));\n+            s.push_highlighted(format!(\n+                \"&{}{}{}\",\n+                r,\n+                if r == \"\" { \"\" } else { \" \" },\n+                if tnm.mutbl == hir::MutMutable {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                }\n+            ));\n             s.push_normal(format!(\"{}\", tnm.ty));\n         }\n \n@@ -732,32 +757,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //     Foo<Bar<Qux>\n                     //         ------- this type argument is exactly the same as the other type\n                     //     Bar<Qux>\n-                    if self.cmp_type_arg(&mut values.0,\n-                                         &mut values.1,\n-                                         path1.clone(),\n-                                         sub1,\n-                                         path2.clone(),\n-                                         &t2).is_some() {\n+                    if self.cmp_type_arg(\n+                        &mut values.0,\n+                        &mut values.1,\n+                        path1.clone(),\n+                        sub1,\n+                        path2.clone(),\n+                        &t2,\n+                    ).is_some()\n+                    {\n                         return values;\n                     }\n                     // Check for case:\n                     //     let x: Bar<Qux> = y:<Foo<Bar<Qux>>>();\n                     //     Bar<Qux>\n                     //     Foo<Bar<Qux>>\n                     //         ------- this type argument is exactly the same as the other type\n-                    if self.cmp_type_arg(&mut values.1,\n-                                         &mut values.0,\n-                                         path2,\n-                                         sub2,\n-                                         path1,\n-                                         &t1).is_some() {\n+                    if self.cmp_type_arg(&mut values.1, &mut values.0, path2, sub2, path1, &t1)\n+                        .is_some()\n+                    {\n                         return values;\n                     }\n \n                     // We couldn't find anything in common, highlight everything.\n                     //     let x: Bar<Qux> = y::<Foo<Zar>>();\n-                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n-                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                    (\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t2)),\n+                    )\n                 }\n             }\n \n@@ -786,37 +813,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 if t1 == t2 {\n                     // The two types are the same, elide and don't highlight.\n-                    (DiagnosticStyledString::normal(\"_\"), DiagnosticStyledString::normal(\"_\"))\n+                    (\n+                        DiagnosticStyledString::normal(\"_\"),\n+                        DiagnosticStyledString::normal(\"_\"),\n+                    )\n                 } else {\n                     // We couldn't find anything in common, highlight everything.\n-                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n-                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                    (\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t2)),\n+                    )\n                 }\n             }\n         }\n     }\n \n-    pub fn note_type_err(&self,\n-                         diag: &mut DiagnosticBuilder<'tcx>,\n-                         cause: &ObligationCause<'tcx>,\n-                         secondary_span: Option<(Span, String)>,\n-                         mut values: Option<ValuePairs<'tcx>>,\n-                         terr: &TypeError<'tcx>)\n-    {\n+    pub fn note_type_err(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        secondary_span: Option<(Span, String)>,\n+        mut values: Option<ValuePairs<'tcx>>,\n+        terr: &TypeError<'tcx>,\n+    ) {\n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n         match terr {\n-            TypeError::CyclicTy(_) => { values = None; }\n-            _ => { }\n+            TypeError::CyclicTy(_) => {\n+                values = None;\n+            }\n+            _ => {}\n         }\n \n         let (expected_found, exp_found, is_simple_error) = match values {\n             None => (None, None, false),\n             Some(values) => {\n                 let (is_simple_error, exp_found) = match values {\n                     ValuePairs::Types(exp_found) => {\n-                        let is_simple_err = exp_found.expected.is_primitive()\n-                            && exp_found.found.is_primitive();\n+                        let is_simple_err =\n+                            exp_found.expected.is_primitive() && exp_found.found.is_primitive();\n \n                         (is_simple_err, Some(exp_found))\n                     }\n@@ -827,7 +862,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     None => {\n                         // Derived error. Cancel the emitter.\n                         self.tcx.sess.diagnostic().cancel(diag);\n-                        return\n+                        return;\n                     }\n                 };\n                 (vals, exp_found, is_simple_error)\n@@ -845,22 +880,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             match (terr, is_simple_error, expected == found) {\n                 (&TypeError::Sorts(ref values), false, true) => {\n                     diag.note_expected_found_extra(\n-                        &\"type\", expected, found,\n+                        &\"type\",\n+                        expected,\n+                        found,\n                         &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n-                        &format!(\" ({})\", values.found.sort_string(self.tcx)));\n+                        &format!(\" ({})\", values.found.sort_string(self.tcx)),\n+                    );\n                 }\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         let (def_id, ret_ty) = match exp_found.found.sty {\n                             TypeVariants::TyFnDef(def, _) => {\n                                 (Some(def), Some(self.tcx.fn_sig(def).output()))\n                             }\n-                            _ => (None, None)\n+                            _ => (None, None),\n                         };\n \n                         let exp_is_struct = match exp_found.expected.sty {\n                             TypeVariants::TyAdt(def, _) => def.is_struct(),\n-                            _ => false\n+                            _ => false,\n                         };\n \n                         if let (Some(def_id), Some(ret_ty)) = (def_id, ret_ty) {\n@@ -888,14 +926,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_error_origin(diag, &cause);\n     }\n \n-    pub fn report_and_explain_type_error(&self,\n-                                         trace: TypeTrace<'tcx>,\n-                                         terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx>\n-    {\n-        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\",\n-               trace,\n-               terr);\n+    pub fn report_and_explain_type_error(\n+        &self,\n+        trace: TypeTrace<'tcx>,\n+        terr: &TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        debug!(\n+            \"report_and_explain_type_error(trace={:?}, terr={:?})\",\n+            trace, terr\n+        );\n \n         let span = trace.cause.span(&self.tcx);\n         let failure_code = trace.cause.as_failure_code(terr);\n@@ -917,19 +956,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         diag\n     }\n \n-    fn values_str(&self, values: &ValuePairs<'tcx>)\n-        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n-    {\n+    fn values_str(\n+        &self,\n+        values: &ValuePairs<'tcx>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n             infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str_ty(&self,\n-                             exp_found: &ty::error::ExpectedFound<Ty<'tcx>>)\n-                             -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    fn expected_found_str_ty(\n+        &self,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n@@ -941,25 +982,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n-        exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n-    {\n+        exp_found: &ty::error::ExpectedFound<T>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n-              DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found))))\n+        Some((\n+            DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n+            DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found)),\n+        ))\n     }\n \n-    pub fn report_generic_bound_failure(&self,\n-                                        region_scope_tree: &region::ScopeTree,\n-                                        span: Span,\n-                                        origin: Option<SubregionOrigin<'tcx>>,\n-                                        bound_kind: GenericKind<'tcx>,\n-                                        sub: Region<'tcx>)\n-    {\n+    pub fn report_generic_bound_failure(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        span: Span,\n+        origin: Option<SubregionOrigin<'tcx>>,\n+        bound_kind: GenericKind<'tcx>,\n+        sub: Region<'tcx>,\n+    ) {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n@@ -985,8 +1028,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // `sp` only covers `T`, change it so that it covers\n                             // `T:` when appropriate\n                             let sp = if has_lifetimes {\n-                                sp.to(self.tcx.sess.codemap().next_point(\n-                                        self.tcx.sess.codemap().next_point(sp)))\n+                                sp.to(self.tcx\n+                                    .sess\n+                                    .codemap()\n+                                    .next_point(self.tcx.sess.codemap().next_point(sp)))\n                             } else {\n                                 sp\n                             };\n@@ -1001,37 +1046,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let labeled_user_string = match bound_kind {\n-            GenericKind::Param(ref p) =>\n-                format!(\"the parameter type `{}`\", p),\n-            GenericKind::Projection(ref p) =>\n-                format!(\"the associated type `{}`\", p),\n+            GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n+            GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n         };\n \n         if let Some(SubregionOrigin::CompareImplMethodObligation {\n-            span, item_name, impl_item_def_id, trait_item_def_id,\n-        }) = origin {\n-            self.report_extra_impl_obligation(span,\n-                                              item_name,\n-                                              impl_item_def_id,\n-                                              trait_item_def_id,\n-                                              &format!(\"`{}: {}`\", bound_kind, sub))\n-                .emit();\n+            span,\n+            item_name,\n+            impl_item_def_id,\n+            trait_item_def_id,\n+        }) = origin\n+        {\n+            self.report_extra_impl_obligation(\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+                &format!(\"`{}: {}`\", bound_kind, sub),\n+            ).emit();\n             return;\n         }\n \n-        fn binding_suggestion<'tcx, S: fmt::Display>(err: &mut DiagnosticBuilder<'tcx>,\n-                                                     type_param_span: Option<(Span, bool)>,\n-                                                     bound_kind: GenericKind<'tcx>,\n-                                                     sub: S) {\n-            let consider = &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n-                                    bound_kind,\n-                                    sub);\n+        fn binding_suggestion<'tcx, S: fmt::Display>(\n+            err: &mut DiagnosticBuilder<'tcx>,\n+            type_param_span: Option<(Span, bool)>,\n+            bound_kind: GenericKind<'tcx>,\n+            sub: S,\n+        ) {\n+            let consider = &format!(\n+                \"consider adding an explicit lifetime bound `{}: {}`...\",\n+                bound_kind, sub\n+            );\n             if let Some((sp, has_lifetimes)) = type_param_span {\n-                let tail = if has_lifetimes {\n-                    \" + \"\n-                } else {\n-                    \"\"\n-                };\n+                let tail = if has_lifetimes { \" + \" } else { \"\" };\n                 let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n                 err.span_suggestion_short(sp, consider, suggestion);\n             } else {\n@@ -1040,44 +1087,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut err = match *sub {\n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n+            ty::ReEarlyBound(_)\n+            | ty::ReFree(ty::FreeRegion {\n+                bound_region: ty::BrNamed(..),\n+                ..\n+            }) => {\n                 // Does the required lifetime have a nice name we can print?\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0309,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0309,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n                 binding_suggestion(&mut err, type_param_span, bound_kind, sub);\n                 err\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0310,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0310,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n                 binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\");\n                 err\n             }\n \n             _ => {\n                 // If not, be less specific.\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0311,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n-                err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n-                                  bound_kind));\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0311,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n+                err.help(&format!(\n+                    \"consider adding an explicit lifetime bound for `{}`\",\n+                    bound_kind\n+                ));\n                 self.tcx.note_and_explain_region(\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n-                    \"...\");\n+                    \"...\",\n+                );\n                 err\n             }\n         };\n@@ -1088,26 +1147,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_sub_sup_conflict(&self,\n-                               region_scope_tree: &region::ScopeTree,\n-                               var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region<'tcx>,\n-                               sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region<'tcx>) {\n-\n+    fn report_sub_sup_conflict(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        var_origin: RegionVariableOrigin,\n+        sub_origin: SubregionOrigin<'tcx>,\n+        sub_region: Region<'tcx>,\n+        sup_origin: SubregionOrigin<'tcx>,\n+        sup_region: Region<'tcx>,\n+    ) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+        self.tcx.note_and_explain_region(\n+            region_scope_tree,\n+            &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n-            \"...\");\n+            \"...\",\n+        );\n \n         match (&sup_origin, &sub_origin) {\n             (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) => {\n-                if let (Some((sup_expected, sup_found)),\n-                        Some((sub_expected, sub_found))) = (self.values_str(&sup_trace.values),\n-                                                            self.values_str(&sub_trace.values)) {\n+                if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) = (\n+                    self.values_str(&sup_trace.values),\n+                    self.values_str(&sub_trace.values),\n+                ) {\n                     if sub_expected == sup_expected && sub_found == sup_found {\n                         self.tcx.note_and_explain_region(\n                             region_scope_tree,\n@@ -1116,10 +1180,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             sub_region,\n                             \"...\",\n                         );\n-                        err.note(&format!(\"...so that the {}:\\nexpected {}\\n   found {}\",\n-                                          sup_trace.cause.as_requirement_str(),\n-                                          sup_expected.content(),\n-                                          sup_found.content()));\n+                        err.note(&format!(\n+                            \"...so that the {}:\\nexpected {}\\n   found {}\",\n+                            sup_trace.cause.as_requirement_str(),\n+                            sup_expected.content(),\n+                            sup_found.content()\n+                        ));\n                         err.emit();\n                         return;\n                     }\n@@ -1130,20 +1196,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+        self.tcx.note_and_explain_region(\n+            region_scope_tree,\n+            &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n-            \"...\");\n+            \"...\",\n+        );\n \n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin)\n-                                -> DiagnosticBuilder<'tcx> {\n+    fn report_inference_failure(\n+        &self,\n+        var_origin: RegionVariableOrigin,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let br_string = |br: ty::BoundRegion| {\n             let mut s = br.to_string();\n             if !s.is_empty() {\n@@ -1158,23 +1228,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {\n-                format!(\" for lifetime parameter {}in function call\",\n-                        br_string(br))\n+                format!(\" for lifetime parameter {}in function call\", br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n                 format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n-            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => {\n-                format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n-                        br_string(br), self.tcx.associated_item(def_id).name)\n-            }\n-            infer::EarlyBoundRegion(_, name) => {\n-                format!(\" for lifetime parameter `{}`\",\n-                        name)\n-            }\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => format!(\n+                \" for lifetime parameter {}in trait containing associated type `{}`\",\n+                br_string(br),\n+                self.tcx.associated_item(def_id).name\n+            ),\n+            infer::EarlyBoundRegion(_, name) => format!(\" for lifetime parameter `{}`\", name),\n             infer::BoundRegionInCoherence(name) => {\n-                format!(\" for lifetime parameter `{}` in coherence check\",\n-                        name)\n+                format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n@@ -1184,10 +1250,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n         };\n \n-        struct_span_err!(self.tcx.sess, var_origin.span(), E0495,\n-                  \"cannot infer an appropriate lifetime{} \\\n-                   due to conflicting requirements\",\n-                  var_description)\n+        struct_span_err!(\n+            self.tcx.sess,\n+            var_origin.span(),\n+            E0495,\n+            \"cannot infer an appropriate lifetime{} \\\n+             due to conflicting requirements\",\n+            var_description\n+        )\n     }\n }\n \n@@ -1205,7 +1275,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n                 _ => \"match arms have incompatible types\",\n             }),\n             IfExpression => Error0308(\"if and else have incompatible types\"),\n@@ -1220,11 +1290,11 @@ impl<'tcx> ObligationCause<'tcx> {\n             // say, also take a look at the error code, maybe we can\n             // tailor to that.\n             _ => match terr {\n-                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() =>\n-                    Error0644(\"closure/generator type that references itself\"),\n-                _ =>\n-                    Error0308(\"mismatched types\"),\n-            }\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n+                    Error0644(\"closure/generator type that references itself\")\n+                }\n+                _ => Error0308(\"mismatched types\"),\n+            },\n         }\n     }\n \n@@ -1234,7 +1304,7 @@ impl<'tcx> ObligationCause<'tcx> {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n             MatchExpressionArm { source, .. } => match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have compatible types\",\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n             IfExpression => \"if and else have compatible types\","}, {"sha": "eed2a2284ea117ae1c7f12cdc44fb21257db9256", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 93, "deletions": 78, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use std::rc::Rc;\n \n-use super::{MirBorrowckCtxt, Context};\n+use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n use dataflow::{ActiveBorrows, BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n@@ -97,7 +97,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         } else {\n                             true\n                         }\n-                    },\n+                    }\n                     _ => true,\n                 };\n \n@@ -107,9 +107,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         None => \"value\".to_owned(),\n                     };\n \n-                    err.note(&format!(\"move occurs because {} has type `{}`, \\\n-                                       which does not implement the `Copy` trait\",\n-                                       note_msg, ty));\n+                    err.note(&format!(\n+                        \"move occurs because {} has type `{}`, \\\n+                         which does not implement the `Copy` trait\",\n+                        note_msg, ty\n+                    ));\n                 }\n             }\n \n@@ -155,7 +157,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n-            &self.describe_place(&borrow.borrowed_place).unwrap_or(\"_\".to_owned()),\n+            &self.describe_place(&borrow.borrowed_place)\n+                .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n@@ -176,8 +179,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         use rustc::hir::ExprClosure;\n         use rustc::mir::AggregateKind;\n \n-        let local = match self.mir[location.block].statements.get(location.statement_index) {\n-            Some(&Statement { kind: StatementKind::Assign(Place::Local(local), _), .. }) => local,\n+        let local = match self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n+            Some(&Statement {\n+                kind: StatementKind::Assign(Place::Local(local), _),\n+                ..\n+            }) => local,\n             _ => return None,\n         };\n \n@@ -203,8 +212,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             .with_freevars(node_id, |freevars| {\n                                 for (v, place) in freevars.iter().zip(places) {\n                                     match *place {\n-                                        Operand::Copy(Place::Local(l)) |\n-                                        Operand::Move(Place::Local(l)) if local == l =>\n+                                        Operand::Copy(Place::Local(l))\n+                                        | Operand::Move(Place::Local(l)) if local == l =>\n                                         {\n                                             debug!(\n                                                 \"find_closure_span: found captured local {:?}\",\n@@ -256,8 +265,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"immutable\",\n             \"mutable\",\n         ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) |\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n                 .cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n@@ -356,25 +365,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>\n+        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>,\n     ) {\n         let end_span = borrows.opt_region_end_span(&borrow.region);\n         let scope_tree = borrows.0.scope_tree();\n-        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All).last().unwrap();\n+        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+            .last()\n+            .unwrap();\n \n         let borrow_span = self.mir.source_info(borrow.location).span;\n         let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => drop_span,\n         };\n \n-        if self.access_place_error_reported.contains(&(root_place.clone(), borrow_span)) {\n-            debug!(\"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n-                   borrow_span);\n+        if self.access_place_error_reported\n+            .contains(&(root_place.clone(), borrow_span))\n+        {\n+            debug!(\n+                \"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n+                borrow_span\n+            );\n             return;\n         }\n \n-        self.access_place_error_reported.insert((root_place.clone(), borrow_span));\n+        self.access_place_error_reported\n+            .insert((root_place.clone(), borrow_span));\n \n         match (borrow.region, &self.describe_place(&borrow.borrowed_place)) {\n             (RegionKind::ReScope(_), Some(name)) => {\n@@ -386,9 +402,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span\n+                    end_span,\n                 );\n-            },\n+            }\n             (RegionKind::ReScope(_), None) => {\n                 self.report_scoped_temporary_value_does_not_live_long_enough(\n                     context,\n@@ -397,14 +413,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span\n+                    end_span,\n                 );\n-            },\n-            (RegionKind::ReEarlyBound(_), Some(name)) |\n-            (RegionKind::ReFree(_), Some(name)) |\n-            (RegionKind::ReStatic, Some(name)) |\n-            (RegionKind::ReEmpty, Some(name)) |\n-            (RegionKind::ReVar(_), Some(name)) => {\n+            }\n+            (RegionKind::ReEarlyBound(_), Some(name))\n+            | (RegionKind::ReFree(_), Some(name))\n+            | (RegionKind::ReStatic, Some(name))\n+            | (RegionKind::ReEmpty, Some(name))\n+            | (RegionKind::ReVar(_), Some(name)) => {\n                 self.report_unscoped_local_value_does_not_live_long_enough(\n                     context,\n                     name,\n@@ -415,12 +431,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     proper_span,\n                     end_span,\n                 );\n-            },\n-            (RegionKind::ReEarlyBound(_), None) |\n-            (RegionKind::ReFree(_), None) |\n-            (RegionKind::ReStatic, None) |\n-            (RegionKind::ReEmpty, None) |\n-            (RegionKind::ReVar(_), None) => {\n+            }\n+            (RegionKind::ReEarlyBound(_), None)\n+            | (RegionKind::ReFree(_), None)\n+            | (RegionKind::ReStatic, None)\n+            | (RegionKind::ReEmpty, None)\n+            | (RegionKind::ReVar(_), None) => {\n                 self.report_unscoped_temporary_value_does_not_live_long_enough(\n                     context,\n                     &scope_tree,\n@@ -430,13 +446,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     proper_span,\n                     end_span,\n                 );\n-            },\n-            (RegionKind::ReLateBound(_, _), _) |\n-            (RegionKind::ReSkolemized(_, _), _) |\n-            (RegionKind::ReClosureBound(_), _) |\n-            (RegionKind::ReErased, _) => {\n+            }\n+            (RegionKind::ReLateBound(_, _), _)\n+            | (RegionKind::ReSkolemized(_, _), _)\n+            | (RegionKind::ReClosureBound(_), _)\n+            | (RegionKind::ReErased, _) => {\n                 span_bug!(drop_span, \"region does not make sense in this context\");\n-            },\n+            }\n         }\n     }\n \n@@ -451,11 +467,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n-                                                              &format!(\"`{}`\", name),\n-                                                              Origin::Mir);\n+        let mut err = self.tcx.path_does_not_live_long_enough(\n+            borrow_span,\n+            &format!(\"`{}`\", name),\n+            Origin::Mir,\n+        );\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-        err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n+        err.span_label(\n+            drop_span,\n+            format!(\"`{}` dropped here while still borrowed\", name),\n+        );\n         if let Some(end) = end_span {\n             err.span_label(end, \"borrowed value needs to live until here\");\n         }\n@@ -473,11 +494,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n-                                                              \"borrowed value\",\n-                                                              Origin::Mir);\n+        let mut err =\n+            self.tcx\n+                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n-        err.span_label(drop_span, \"temporary value dropped here while still borrowed\");\n+        err.span_label(\n+            drop_span,\n+            \"temporary value dropped here while still borrowed\",\n+        );\n         err.note(\"consider using a `let` binding to increase its lifetime\");\n         if let Some(end) = end_span {\n             err.span_label(end, \"temporary value needs to live until here\");\n@@ -499,19 +523,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"report_unscoped_local_value_does_not_live_long_enough(\\\n-                {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n-            )\",\n-            context,\n-            name,\n-            scope_tree,\n-            borrow,\n-            drop_span,\n-            borrow_span\n+             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            context, name, scope_tree, borrow, drop_span, borrow_span\n         );\n \n-        let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n-                                                              &format!(\"`{}`\", name),\n-                                                              Origin::Mir);\n+        let mut err = self.tcx.path_does_not_live_long_enough(\n+            borrow_span,\n+            &format!(\"`{}`\", name),\n+            Origin::Mir,\n+        );\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n@@ -537,22 +558,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         _borrow_span: Span,\n         proper_span: Span,\n-        _end_span: Option<Span>\n+        _end_span: Option<Span>,\n     ) {\n         debug!(\n             \"report_unscoped_temporary_value_does_not_live_long_enough(\\\n-                {:?}, {:?}, {:?}, {:?}, {:?}\\\n-            )\",\n-            context,\n-            scope_tree,\n-            borrow,\n-            drop_span,\n-            proper_span\n+             {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            context, scope_tree, borrow, drop_span, proper_span\n         );\n \n-        let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n-                                                              \"borrowed value\",\n-                                                              Origin::Mir);\n+        let mut err =\n+            self.tcx\n+                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n@@ -746,9 +763,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field)\n                 }\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n+                ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n                     format!(\"{}\", self.describe_field(&proj.base, field))\n                 }\n             },\n@@ -805,13 +822,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[*local];\n                 Some(local.ty)\n-            },\n+            }\n             Place::Static(ref st) => Some(st.ty),\n-            Place::Projection(ref proj) => {\n-                match proj.elem {\n-                    ProjectionElem::Field(_, ty) => Some(ty),\n-                    _ => None,\n-                }\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(_, ty) => Some(ty),\n+                _ => None,\n             },\n         }\n     }"}, {"sha": "40826d3044d30c66e50e59f572b584035aea122c", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "patch": "@@ -72,7 +72,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                     Cause::UniversalRegion(region_vid) => {\n                         if let Some(region) = regioncx.to_error_region(region_vid) {\n-\n                             self.tcx.note_and_explain_free_region(\n                                 err,\n                                 \"borrowed value must be valid for \",\n@@ -82,8 +81,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                     }\n \n-                    _ => {\n-                    }\n+                    _ => {}\n                 }\n             }\n         }"}, {"sha": "3ffb4370359bf81dad95334ea71787d363940854", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c42dccfa7d00b6f488bcd61a5cf141d2112acf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=99c42dccfa7d00b6f488bcd61a5cf141d2112acf", "patch": "@@ -573,10 +573,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // an error that multiple bounds are required.\n                 tcx.sess.span_err(\n                     type_test.span,\n-                    &format!(\n-                        \"`{}` does not live long enough\",\n-                        type_test.generic_kind,\n-                    ),\n+                    &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n                 );\n             }\n         }\n@@ -593,8 +590,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return self.definitions[r].external_name;\n         } else {\n             let inferred_values = self.inferred_values\n-                                      .as_ref()\n-                                      .expect(\"region values not yet inferred\");\n+                .as_ref()\n+                .expect(\"region values not yet inferred\");\n             let upper_bound = self.universal_upper_bound(r);\n             if inferred_values.contains(r, upper_bound) {\n                 self.to_error_region(upper_bound)\n@@ -806,9 +803,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         debug!(\n             \"eval_region_test(point={:?}, lower_bound={:?}, test={:?})\",\n-            point,\n-            lower_bound,\n-            test\n+            point, lower_bound, test\n         );\n \n         match test {\n@@ -840,9 +835,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         debug!(\n             \"eval_outlives({:?}: {:?} @ {:?})\",\n-            sup_region,\n-            sub_region,\n-            point\n+            sup_region, sub_region, point\n         );\n \n         // Roughly speaking, do a DFS of all region elements reachable\n@@ -947,8 +940,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             debug!(\n                 \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n-                longer_fr,\n-                shorter_fr,\n+                longer_fr, shorter_fr,\n             );\n \n             let blame_span = self.blame_span(longer_fr, shorter_fr);\n@@ -1123,10 +1115,7 @@ impl fmt::Debug for Constraint {\n         write!(\n             formatter,\n             \"({:?}: {:?} @ {:?}) due to {:?}\",\n-            self.sup,\n-            self.sub,\n-            self.point,\n-            self.span\n+            self.sup, self.sub, self.point, self.span\n         )\n     }\n }\n@@ -1176,9 +1165,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n \n         debug!(\n             \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n-            location,\n-            closure_def_id,\n-            closure_substs\n+            location, closure_def_id, closure_substs\n         );\n \n         // Get Tu.\n@@ -1206,9 +1193,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n                         \"apply_requirements: region={:?} \\\n                          outlived_region={:?} \\\n                          outlives_requirement={:?}\",\n-                        region,\n-                        outlived_region,\n-                        outlives_requirement,\n+                        region, outlived_region, outlives_requirement,\n                     );\n                     infcx.sub_regions(origin, outlived_region, region);\n                 }\n@@ -1219,9 +1204,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n                         \"apply_requirements: ty={:?} \\\n                          outlived_region={:?} \\\n                          outlives_requirement={:?}\",\n-                        ty,\n-                        outlived_region,\n-                        outlives_requirement,\n+                        ty, outlived_region, outlives_requirement,\n                     );\n                     infcx.register_region_obligation(\n                         body_id,\n@@ -1276,19 +1259,12 @@ impl CauseExt for Rc<Cause> {\n impl Cause {\n     pub(crate) fn root_cause(&self) -> &Cause {\n         match self {\n-            Cause::LiveVar(..) |\n-            Cause::DropVar(..) |\n-            Cause::LiveOther(..) |\n-            Cause::UniversalRegion(..) => {\n-                self\n-            }\n+            Cause::LiveVar(..)\n+            | Cause::DropVar(..)\n+            | Cause::LiveOther(..)\n+            | Cause::UniversalRegion(..) => self,\n \n-            Cause::Outlives {\n-                original_cause,\n-                ..\n-            } => {\n-                original_cause.root_cause()\n-            }\n+            Cause::Outlives { original_cause, .. } => original_cause.root_cause(),\n         }\n     }\n }"}]}