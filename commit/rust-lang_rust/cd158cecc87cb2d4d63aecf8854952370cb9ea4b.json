{"sha": "cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMTU4Y2VjYzg3Y2IyZDRkNjNhZWNmODg1NDk1MjM3MGNiOWVhNGI=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2016-05-09T18:11:25Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2016-05-12T19:15:06Z"}, "message": "Add try macro to try shorthand conversion tests", "tree": {"sha": "8d1cc8700cd73e5892d7bb8208ee067d5c3a2dbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d1cc8700cd73e5892d7bb8208ee067d5c3a2dbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "html_url": "https://github.com/rust-lang/rust/commit/cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee7b5805fcb1e4bc6334b7a6a814769d4606541d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7b5805fcb1e4bc6334b7a6a814769d4606541d", "html_url": "https://github.com/rust-lang/rust/commit/ee7b5805fcb1e4bc6334b7a6a814769d4606541d"}], "stats": {"total": 183, "additions": 134, "deletions": 49}, "files": [{"sha": "3f306abfdcab3d1752f2e536bba6575527667f96", "filename": "src/chains.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -86,18 +86,18 @@ use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, first_line_width};\n use expr::rewrite_call;\n use config::BlockIndentStyle;\n+use macros::convert_try_mac;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n \n-\n pub fn rewrite_chain(expr: &ast::Expr,\n                      context: &RewriteContext,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n     let total_span = expr.span;\n-    let (parent, subexpr_list) = make_subexpr_list(expr);\n+    let (parent, subexpr_list) = make_subexpr_list(expr, context);\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_block_indent = chain_base_indent(context, offset);\n@@ -106,19 +106,16 @@ pub fn rewrite_chain(expr: &ast::Expr,\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n+    let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(&parent) ||\n                               parent_rewrite.len() <= context.config.tab_spaces {\n-// <<<<<<< HEAD\n-//         // Try and put at least the first two items on the same line.\n-//         (chain_indent(context, offset + Indent::new(0, parent_rewrite.len())), true)\n-// =======\n+\n         let indent = if let ast::ExprKind::Try(..) = subexpr_list.last().unwrap().node {\n             parent_block_indent.block_indent(context.config)\n         } else {\n-            offset + Indent::new(0, parent_rewrite.len())\n+            chain_indent(context, offset + Indent::new(0, parent_rewrite.len()))\n         };\n         (indent, true)\n-    } else if is_block_expr(parent, &parent_rewrite) {\n+    } else if is_block_expr(&parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n         (parent_block_indent, false)\n@@ -197,11 +194,13 @@ pub fn rewrite_chain(expr: &ast::Expr,\n              offset)\n }\n \n-fn join_rewrites(rewrites: &[String], subexps: &[&ast::Expr], connector: &str) -> String {\n+fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n     let mut rewrite_iter = rewrites.iter();\n     let mut result = rewrite_iter.next().unwrap().clone();\n+    let mut subexpr_iter = subexps.iter().rev();\n+    subexpr_iter.next();\n \n-    for (rewrite, expr) in rewrite_iter.zip(subexps.iter()) {\n+    for (rewrite, expr) in rewrite_iter.zip(subexpr_iter) {\n         match expr.node {\n             ast::ExprKind::Try(_) => (),\n             _ => result.push_str(connector),\n@@ -235,21 +234,11 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n \n // Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n // E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n-fn make_subexpr_list(mut expr: &ast::Expr) -> (&ast::Expr, Vec<&ast::Expr>) {\n-    fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n-        match expr.node {\n-            ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n-            ast::ExprKind::TupField(ref subexpr, _) |\n-            ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n-            _ => None,\n-        }\n-    }\n-\n-    let mut subexpr_list = vec![expr];\n+fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr, Vec<ast::Expr>) {\n+    let mut subexpr_list = vec![expr.clone()];\n \n-    while let Some(subexpr) = pop_expr_chain(expr) {\n-        subexpr_list.push(subexpr);\n-        expr = subexpr;\n+    while let Some(subexpr) = pop_expr_chain(subexpr_list.last().unwrap(), context) {\n+        subexpr_list.push(subexpr.clone());\n     }\n \n     let parent = subexpr_list.pop().unwrap();\n@@ -315,16 +304,33 @@ fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n     }\n }\n \n-fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n+// Returns the expression's subexpression, if it exists. When the subexpr\n+// is a try! macro, we'll convert it to shorthand when the option is set.\n+fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n     match expr.node {\n-        ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n+        ast::ExprKind::MethodCall(_, _, ref expressions) => {\n+            Some(convert_try(&expressions[0], context))\n+        }\n         ast::ExprKind::TupField(ref subexpr, _) |\n         ast::ExprKind::Field(ref subexpr, _) |\n-        ast::ExprKind::Try(ref subexpr) => Some(subexpr),\n+        ast::ExprKind::Try(ref subexpr) => Some(convert_try(subexpr, context)),\n         _ => None,\n     }\n }\n \n+fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n+    match expr.node {\n+        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand => {\n+            if let Some(subexpr) = convert_try_mac(mac, context) {\n+                subexpr\n+            } else {\n+                expr.clone()\n+            }\n+        }\n+        _ => expr.clone(),\n+    }\n+}\n+\n // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n // `.c`.\n fn rewrite_chain_subexpr(expr: &ast::Expr,"}, {"sha": "5e4dbefad45cad688293c245e897b3f010828298", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -392,6 +392,7 @@ create_config! {\n     match_wildcard_trailing_comma: bool, true, \"Put a trailing comma after a wildcard arm\";\n     closure_block_indent_threshold: isize, 5, \"How many lines a closure must have before it is \\\n                                                block indented. -1 means never use block indent.\";\n+    use_try_shorthand: bool, false, \"Replace uses of the try! macro by the ? shorthand\";\n     write_mode: WriteMode, WriteMode::Replace,\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n }"}, {"sha": "1edacbf765d6a1643244c902c67888d89484e90d", "filename": "src/expr.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -148,7 +148,7 @@ impl Rewrite for ast::Expr {\n             ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n-            // ast::ExprKind::Try(..) |\n+            ast::ExprKind::Try(..) |\n             ast::ExprKind::Field(..) |\n             ast::ExprKind::TupField(..) |\n             ast::ExprKind::MethodCall(..) => rewrite_chain(self, context, width, offset),\n@@ -205,15 +205,10 @@ impl Rewrite for ast::Expr {\n                     (None, None) => wrap_str(delim.into(), context.config.max_width, width, offset),\n                 }\n             }\n-            ast::ExprKind::Try(ref expr) => {\n-                rewrite_unary_suffix(context, \"?\", &**expr, width, offset)\n-            }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n             ast::ExprKind::InPlace(..) |\n-            ast::ExprKind::InlineAsm(..) |\n-            // TODO(#848): Handle type ascription\n-            ast::ExprKind::Type(_, _) => {\n+            ast::ExprKind::InlineAsm(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n                          width,\n@@ -1832,24 +1827,41 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n     let max_width = try_opt!(width.checked_sub(last_line_width + 1));\n     let rhs = ex.rewrite(&context, max_width, offset + last_line_width + 1);\n \n+    fn count_line_breaks(src: &str) -> usize {\n+        src.chars().filter(|&x| x == '\\n').count()\n+    }\n+\n     match rhs {\n-        Some(new_str) => {\n+        Some(ref new_str) if count_line_breaks(new_str) < 2 => {\n             result.push(' ');\n-            result.push_str(&new_str)\n+            result.push_str(new_str);\n         }\n-        None => {\n-            // Expression did not fit on the same line as the identifier. Retry\n-            // on the next line.\n+        _ => {\n+            // Expression did not fit on the same line as the identifier or is\n+            // at least three lines big. Try splitting the line and see\n+            // if that works better.\n             let new_offset = offset.block_indent(context.config);\n-            result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n-\n-            // FIXME: we probably should related max_width to width instead of\n-            // config.max_width where is the 1 coming from anyway?\n-            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset.width() + 1));\n+            let max_width = try_opt!((width + offset.width()).checked_sub(new_offset.width()));\n             let inner_context = context.nested_context();\n-            let rhs = ex.rewrite(&inner_context, max_width, new_offset);\n-\n-            result.push_str(&&try_opt!(rhs));\n+            let new_rhs = ex.rewrite(&inner_context, max_width, new_offset);\n+\n+            // FIXME: DRY!\n+            match (rhs, new_rhs) {\n+                (Some(ref orig_rhs), Some(ref replacement_rhs))\n+                    if count_line_breaks(orig_rhs) > count_line_breaks(replacement_rhs) + 1 => {\n+                    result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n+                    result.push_str(replacement_rhs);\n+                }\n+                (None, Some(ref final_rhs)) => {\n+                    result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n+                    result.push_str(final_rhs);\n+                }\n+                (None, None) => return None,\n+                (Some(ref orig_rhs), _) => {\n+                    result.push(' ');\n+                    result.push_str(orig_rhs);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "e9992fb0eb0134a76dfdc3e206ecba6fb096a0e9", "filename": "src/macros.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -25,7 +25,7 @@ use syntax::parse::tts_to_parser;\n use syntax::codemap::{mk_sp, BytePos};\n \n use Indent;\n-use rewrite::RewriteContext;\n+use rewrite::{Rewrite, RewriteContext};\n use expr::{rewrite_call, rewrite_array};\n use comment::{FindUncommented, contains_comment};\n use utils::{CodeMapSpanUtils, wrap_str};\n@@ -56,6 +56,12 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n+    if context.config.use_try_shorthand {\n+        if let Some(expr) = convert_try_mac(mac, context) {\n+            return expr.rewrite(context, width, offset);\n+        }\n+    }\n+\n     let original_style = macro_style(mac, context);\n     let macro_name = match extra_ident {\n         None |\n@@ -141,6 +147,24 @@ pub fn rewrite_macro(mac: &ast::Mac,\n     }\n }\n \n+/// Tries to convert a macro use into a short hand try expression. Returns None\n+/// when the macro is not an instance of try! (or parsing the inner expression\n+/// failed).\n+pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::Expr> {\n+    if &format!(\"{}\", mac.node.path)[..] == \"try\" {\n+        let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone(), Vec::new());\n+\n+        Some(ast::Expr {\n+            id: 0, // dummy value\n+            node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n+            span: mac.span, // incorrect span, but shouldn't matter too much\n+            attrs: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> MacroStyle {\n     let snippet = context.snippet(mac.span);\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());"}, {"sha": "48de948865bc9e33a6b433becda813199c0ebe36", "filename": "tests/source/chains.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -120,4 +120,8 @@ fn try_shorthand() {\n     let yyyy = expr?.another?.another?.another?.another?.another?.another?.another?.another?.test();\n     let zzzz = expr?.another?.another?.another?.another?;\n     let aaa =  x ????????????  ?????????????? ???? ?????  ?????????????? ?????????  ?????????????? ??;\n+\n+    let y = a.very .loooooooooooooooooooooooooooooooooooooong()  .chain()\n+             .inside()          .weeeeeeeeeeeeeee()? .test()  .0\n+        .x;\n }"}, {"sha": "addf2f5d5e8fa1a31fe2d92635a21a038a7dc7ba", "filename": "tests/source/try-conversion.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Fsource%2Ftry-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Fsource%2Ftry-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftry-conversion.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -0,0 +1,11 @@\n+// rustfmt-use_try_shorthand: true\n+\n+fn main() {\n+    let x = try!(some_expr());\n+\n+    let y = try!(a.very.loooooooooooooooooooooooooooooooooooooong().chain().inside().weeeeeeeeeeeeeee()).test().0.x;\n+}\n+\n+fn test() {\n+    a?\n+}"}, {"sha": "2298b5e17148250d5762b874104727d3f3d8158c", "filename": "tests/target/chains.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -145,4 +145,13 @@ fn try_shorthand() {\n     let yyyy = expr?.another?.another?.another?.another?.another?.another?.another?.another?.test();\n     let zzzz = expr?.another?.another?.another?.another?;\n     let aaa = x??????????????????????????????????????????????????????????????????????????;\n+\n+    let y = a.very\n+             .loooooooooooooooooooooooooooooooooooooong()\n+             .chain()\n+             .inside()\n+             .weeeeeeeeeeeeeee()?\n+             .test()\n+             .0\n+             .x;\n }"}, {"sha": "2daaba88490752a0af9f9aa580a4ed602717df30", "filename": "tests/target/try-conversion.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Ftarget%2Ftry-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd158cecc87cb2d4d63aecf8854952370cb9ea4b/tests%2Ftarget%2Ftry-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftry-conversion.rs?ref=cd158cecc87cb2d4d63aecf8854952370cb9ea4b", "patch": "@@ -0,0 +1,18 @@\n+// rustfmt-use_try_shorthand: true\n+\n+fn main() {\n+    let x = some_expr()?;\n+\n+    let y = a.very\n+             .loooooooooooooooooooooooooooooooooooooong()\n+             .chain()\n+             .inside()\n+             .weeeeeeeeeeeeeee()?\n+             .test()\n+             .0\n+             .x;\n+}\n+\n+fn test() {\n+    a?\n+}"}]}