{"sha": "36b495f3cf23a1f235482ce7f81f0f4be614bb85", "node_id": "C_kwDOAAsO6NoAKDM2YjQ5NWYzY2YyM2ExZjIzNTQ4MmNlN2Y4MWYwZjRiZTYxNGJiODU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-09T13:47:48Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-22T23:18:49Z"}, "message": "Introduce `ChunkedBitSet` and use it for some dataflow analyses.\n\nThis reduces peak memory usage significantly for some programs with very\nlarge functions, such as:\n- `keccak`, `unicode_normalization`, and `match-stress-enum`, from\n  the `rustc-perf` benchmark suite;\n- `http-0.2.6` from crates.io.\n\nThe new type is used in the analyses where the bitsets can get huge\n(e.g. 10s of thousands of bits): `MaybeInitializedPlaces`,\n`MaybeUninitializedPlaces`, and `EverInitializedPlaces`.\n\nSome refactoring was required in `rustc_mir_dataflow`. All existing\nanalysis domains are either `BitSet` or a trivial wrapper around\n`BitSet`, and access in a few places is done via `Borrow<BitSet>` or\n`BorrowMut<BitSet>`. Now that some of these domains are `ClusterBitSet`,\nthat no longer works. So this commit replaces the `Borrow`/`BorrowMut`\nusage with a new trait `BitSetExt` containing the needed bitset\noperations. The impls just forward these to the underlying bitset type.\nThis required fiddling with trait bounds in a few places.\n\nThe commit also:\n- Moves `static_assert_size` from `rustc_data_structures` to\n  `rustc_index` so it can be used in the latter; the former now\n  re-exports it so existing users are unaffected.\n- Factors out some common \"clear excess bits in the final word\"\n  functionality in `bit_set.rs`.\n- Uses `fill` in a few places instead of loops.", "tree": {"sha": "bb651118e987cbe7467f088e84811ae93a676954", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb651118e987cbe7467f088e84811ae93a676954"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36b495f3cf23a1f235482ce7f81f0f4be614bb85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36b495f3cf23a1f235482ce7f81f0f4be614bb85", "html_url": "https://github.com/rust-lang/rust/commit/36b495f3cf23a1f235482ce7f81f0f4be614bb85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36b495f3cf23a1f235482ce7f81f0f4be614bb85/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "523a1b1d388bfe82a5d0540b876d9428b6dccc9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/523a1b1d388bfe82a5d0540b876d9428b6dccc9c", "html_url": "https://github.com/rust-lang/rust/commit/523a1b1d388bfe82a5d0540b876d9428b6dccc9c"}], "stats": {"total": 877, "additions": 804, "deletions": 73}, "files": [{"sha": "753eed530680710c86f7f981d7d1e2cf7f6d3bdf", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -22,7 +22,7 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::Node;\n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{\n@@ -1667,7 +1667,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (PlaceRef<'tcx>, Span),\n-        maybe_uninits: &BitSet<MovePathIndex>,\n+        maybe_uninits: &ChunkedBitSet<MovePathIndex>,\n         from: u64,\n         to: u64,\n     ) {"}, {"sha": "3e93fe9a11f72613a3aa8d21a50ff0394108d049", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -37,6 +37,8 @@ extern crate cfg_if;\n #[macro_use]\n extern crate rustc_macros;\n \n+pub use rustc_index::static_assert_size;\n+\n #[inline(never)]\n #[cold]\n pub fn cold_path<F: FnOnce() -> R, R>(f: F) -> R {"}, {"sha": "e05491f6ff6e4b47ce6907337a2ee06fcc7397c0", "filename": "compiler/rustc_data_structures/src/macros.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,11 +1,3 @@\n-/// Type size assertion. The first argument is a type and the second argument is its expected size.\n-#[macro_export]\n-macro_rules! static_assert_size {\n-    ($ty:ty, $size:expr) => {\n-        const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n-    };\n-}\n-\n #[macro_export]\n macro_rules! enum_from_u32 {\n     ($(#[$attr:meta])* pub enum $name:ident {"}, {"sha": "12bde02949452ee607d7b2a8d60ffa8b1a9e41d8", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 471, "deletions": 27, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -5,16 +5,37 @@ use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::ops::{BitAnd, BitAndAssign, BitOrAssign, Bound, Not, Range, RangeBounds, Shl};\n+use std::rc::Rc;\n use std::slice;\n \n use rustc_macros::{Decodable, Encodable};\n \n+use Chunk::*;\n+\n #[cfg(test)]\n mod tests;\n \n-pub type Word = u64;\n-pub const WORD_BYTES: usize = mem::size_of::<Word>();\n-pub const WORD_BITS: usize = WORD_BYTES * 8;\n+type Word = u64;\n+const WORD_BYTES: usize = mem::size_of::<Word>();\n+const WORD_BITS: usize = WORD_BYTES * 8;\n+\n+// The choice of chunk size has some trade-offs.\n+//\n+// A big chunk size tends to favour cases where many large `ChunkedBitSet`s are\n+// present, because they require fewer `Chunk`s, reducing the number of\n+// allocations and reducing peak memory usage. Also, fewer chunk operations are\n+// required, though more of them might be `Mixed`.\n+//\n+// A small chunk size tends to favour cases where many small `ChunkedBitSet`s\n+// are present, because less space is wasted at the end of the final chunk (if\n+// it's not full).\n+const CHUNK_WORDS: usize = 32;\n+const CHUNK_BITS: usize = CHUNK_WORDS * WORD_BITS; // 2048 bits\n+\n+/// ChunkSize is small to keep `Chunk` small. The static assertion ensures it's\n+/// not too small.\n+type ChunkSize = u16;\n+const _: () = assert!(CHUNK_BITS <= ChunkSize::MAX as usize);\n \n pub trait BitRelations<Rhs> {\n     fn union(&mut self, other: &Rhs) -> bool;\n@@ -121,19 +142,12 @@ impl<T: Idx> BitSet<T> {\n     /// Clear all elements.\n     #[inline]\n     pub fn clear(&mut self) {\n-        for word in &mut self.words {\n-            *word = 0;\n-        }\n+        self.words.fill(0);\n     }\n \n     /// Clear excess bits in the final word.\n     fn clear_excess_bits(&mut self) {\n-        let num_bits_in_final_word = self.domain_size % WORD_BITS;\n-        if num_bits_in_final_word > 0 {\n-            let mask = (1 << num_bits_in_final_word) - 1;\n-            let final_word_idx = self.words.len() - 1;\n-            self.words[final_word_idx] &= mask;\n-        }\n+        clear_excess_bits_in_final_word(self.domain_size, &mut self.words);\n     }\n \n     /// Count the number of set bits in the set.\n@@ -203,9 +217,7 @@ impl<T: Idx> BitSet<T> {\n \n     /// Sets all bits to true.\n     pub fn insert_all(&mut self) {\n-        for word in &mut self.words {\n-            *word = !0;\n-        }\n+        self.words.fill(!0);\n         self.clear_excess_bits();\n     }\n \n@@ -328,6 +340,407 @@ impl<T: Idx> BitRelations<BitSet<T>> for BitSet<T> {\n     }\n }\n \n+/// A fixed-size bitset type with a partially dense, partially sparse\n+/// representation. The bitset is broken into chunks, and chunks that are all\n+/// zeros or all ones are represented and handled very efficiently.\n+///\n+/// This type is especially efficient for sets that typically have a large\n+/// `domain_size` with significant stretches of all zeros or all ones, and also\n+/// some stretches with lots of 0s and 1s mixed in a way that causes trouble\n+/// for `IntervalSet`.\n+///\n+/// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n+/// just be `usize`.\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size. All operations that involve two bitsets\n+/// will panic if the bitsets have differing domain sizes.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ChunkedBitSet<T> {\n+    domain_size: usize,\n+\n+    /// The chunks. Each one contains exactly CHUNK_BITS values, except the\n+    /// last one which contains 1..=CHUNK_BITS values.\n+    chunks: Box<[Chunk]>,\n+\n+    marker: PhantomData<T>,\n+}\n+\n+// Note: the chunk domain size is duplicated in each variant. This is a bit\n+// inconvenient, but it allows the type size to be smaller than if we had an\n+// outer struct containing a chunk domain size plus the `Chunk`, because the\n+// compiler can place the chunk domain size after the tag.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+enum Chunk {\n+    /// A chunk that is all zeros; we don't represent the zeros explicitly.\n+    Zeros(ChunkSize),\n+\n+    /// A chunk that is all ones; we don't represent the ones explicitly.\n+    Ones(ChunkSize),\n+\n+    /// A chunk that has a mix of zeros and ones, which are represented\n+    /// explicitly and densely. It never has all zeros or all ones.\n+    ///\n+    /// If this is the final chunk there may be excess, unused words. This\n+    /// turns out to be both simpler and have better performance than\n+    /// allocating the minimum number of words, largely because we avoid having\n+    /// to store the length, which would make this type larger. These excess\n+    /// words are always be zero, as are any excess bits in the final in-use\n+    /// word.\n+    ///\n+    /// The second field is the count of 1s set in the chunk, and must satisfy\n+    /// `0 < count < chunk_domain_size`.\n+    ///\n+    /// The words are within an `Rc` because it's surprisingly common to\n+    /// duplicate an entire chunk, e.g. in `ChunkedBitSet::clone_from()`, or\n+    /// when a `Mixed` chunk is union'd into a `Zeros` chunk. When we do need\n+    /// to modify a chunk we use `Rc::make_mut`.\n+    Mixed(ChunkSize, ChunkSize, Rc<[Word; CHUNK_WORDS]>),\n+}\n+\n+// This type is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+crate::static_assert_size!(Chunk, 16);\n+\n+impl<T> ChunkedBitSet<T> {\n+    pub fn domain_size(&self) -> usize {\n+        self.domain_size\n+    }\n+\n+    #[cfg(test)]\n+    fn assert_valid(&self) {\n+        if self.domain_size == 0 {\n+            assert!(self.chunks.is_empty());\n+            return;\n+        }\n+\n+        assert!((self.chunks.len() - 1) * CHUNK_BITS <= self.domain_size);\n+        assert!(self.chunks.len() * CHUNK_BITS >= self.domain_size);\n+        for chunk in self.chunks.iter() {\n+            chunk.assert_valid();\n+        }\n+    }\n+}\n+\n+impl<T: Idx> ChunkedBitSet<T> {\n+    /// Creates a new bitset with a given `domain_size` and chunk kind.\n+    fn new(domain_size: usize, is_empty: bool) -> Self {\n+        let chunks = if domain_size == 0 {\n+            Box::new([])\n+        } else {\n+            // All the chunks have a chunk_domain_size of `CHUNK_BITS` except\n+            // the final one.\n+            let final_chunk_domain_size = {\n+                let n = domain_size % CHUNK_BITS;\n+                if n == 0 { CHUNK_BITS } else { n }\n+            };\n+            let mut chunks =\n+                vec![Chunk::new(CHUNK_BITS, is_empty); num_chunks(domain_size)].into_boxed_slice();\n+            *chunks.last_mut().unwrap() = Chunk::new(final_chunk_domain_size, is_empty);\n+            chunks\n+        };\n+        ChunkedBitSet { domain_size, chunks, marker: PhantomData }\n+    }\n+\n+    /// Creates a new, empty bitset with a given `domain_size`.\n+    #[inline]\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        ChunkedBitSet::new(domain_size, /* is_empty */ true)\n+    }\n+\n+    /// Creates a new, filled bitset with a given `domain_size`.\n+    #[inline]\n+    pub fn new_filled(domain_size: usize) -> Self {\n+        ChunkedBitSet::new(domain_size, /* is_empty */ false)\n+    }\n+\n+    #[cfg(test)]\n+    fn chunks(&self) -> &[Chunk] {\n+        &self.chunks\n+    }\n+\n+    /// Count the number of bits in the set.\n+    pub fn count(&self) -> usize {\n+        self.chunks.iter().map(|chunk| chunk.count()).sum()\n+    }\n+\n+    /// Returns `true` if `self` contains `elem`.\n+    #[inline]\n+    pub fn contains(&self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n+        let chunk = &self.chunks[chunk_index(elem)];\n+        match &chunk {\n+            Zeros(_) => false,\n+            Ones(_) => true,\n+            Mixed(_, _, words) => {\n+                let (word_index, mask) = chunk_word_index_and_mask(elem);\n+                (words[word_index] & mask) != 0\n+            }\n+        }\n+    }\n+\n+    /// Insert `elem`. Returns whether the set has changed.\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n+        let chunk_index = chunk_index(elem);\n+        let chunk = &mut self.chunks[chunk_index];\n+        match *chunk {\n+            Zeros(chunk_domain_size) => {\n+                if chunk_domain_size > 1 {\n+                    // We take some effort to avoid copying the words.\n+                    let words = Rc::<[Word; CHUNK_WORDS]>::new_zeroed();\n+                    // SAFETY: `words` can safely be all zeroes.\n+                    let mut words = unsafe { words.assume_init() };\n+                    let words_ref = Rc::get_mut(&mut words).unwrap();\n+\n+                    let (word_index, mask) = chunk_word_index_and_mask(elem);\n+                    words_ref[word_index] |= mask;\n+                    *chunk = Mixed(chunk_domain_size, 1, words);\n+                } else {\n+                    *chunk = Ones(chunk_domain_size);\n+                }\n+                true\n+            }\n+            Ones(_) => false,\n+            Mixed(chunk_domain_size, ref mut count, ref mut words) => {\n+                // We skip all the work if the bit is already set.\n+                let (word_index, mask) = chunk_word_index_and_mask(elem);\n+                if (words[word_index] & mask) == 0 {\n+                    *count += 1;\n+                    if *count < chunk_domain_size {\n+                        let words = Rc::make_mut(words);\n+                        words[word_index] |= mask;\n+                    } else {\n+                        *chunk = Ones(chunk_domain_size);\n+                    }\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Sets all bits to true.\n+    pub fn insert_all(&mut self) {\n+        for chunk in self.chunks.iter_mut() {\n+            *chunk = match *chunk {\n+                Zeros(chunk_domain_size)\n+                | Ones(chunk_domain_size)\n+                | Mixed(chunk_domain_size, ..) => Ones(chunk_domain_size),\n+            }\n+        }\n+    }\n+\n+    /// Returns `true` if the set has changed.\n+    pub fn remove(&mut self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n+        let chunk_index = chunk_index(elem);\n+        let chunk = &mut self.chunks[chunk_index];\n+        match *chunk {\n+            Zeros(_) => false,\n+            Ones(chunk_domain_size) => {\n+                if chunk_domain_size > 1 {\n+                    // We take some effort to avoid copying the words.\n+                    let words = Rc::<[Word; CHUNK_WORDS]>::new_zeroed();\n+                    // SAFETY: `words` can safely be all zeroes.\n+                    let mut words = unsafe { words.assume_init() };\n+                    let words_ref = Rc::get_mut(&mut words).unwrap();\n+\n+                    // Set only the bits in use.\n+                    let num_words = num_words(chunk_domain_size as usize);\n+                    words_ref[..num_words].fill(!0);\n+                    clear_excess_bits_in_final_word(\n+                        chunk_domain_size as usize,\n+                        &mut words_ref[..num_words],\n+                    );\n+                    let (word_index, mask) = chunk_word_index_and_mask(elem);\n+                    words_ref[word_index] &= !mask;\n+                    *chunk = Mixed(chunk_domain_size, chunk_domain_size - 1, words);\n+                } else {\n+                    *chunk = Zeros(chunk_domain_size);\n+                }\n+                true\n+            }\n+            Mixed(chunk_domain_size, ref mut count, ref mut words) => {\n+                // We skip all the work if the bit is already clear.\n+                let (word_index, mask) = chunk_word_index_and_mask(elem);\n+                if (words[word_index] & mask) != 0 {\n+                    *count -= 1;\n+                    if *count > 0 {\n+                        let words = Rc::make_mut(words);\n+                        words[word_index] &= !mask;\n+                    } else {\n+                        *chunk = Zeros(chunk_domain_size);\n+                    }\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+    }\n+\n+    bit_relations_inherent_impls! {}\n+}\n+\n+impl<T: Idx> BitRelations<ChunkedBitSet<T>> for ChunkedBitSet<T> {\n+    fn union(&mut self, other: &ChunkedBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        debug_assert_eq!(self.chunks.len(), other.chunks.len());\n+\n+        let mut changed = false;\n+        for (mut self_chunk, other_chunk) in self.chunks.iter_mut().zip(other.chunks.iter()) {\n+            match (&mut self_chunk, &other_chunk) {\n+                (_, Zeros(_)) | (Ones(_), _) => {}\n+                (Zeros(self_chunk_domain_size), Ones(other_chunk_domain_size))\n+                | (Mixed(self_chunk_domain_size, ..), Ones(other_chunk_domain_size))\n+                | (Zeros(self_chunk_domain_size), Mixed(other_chunk_domain_size, ..)) => {\n+                    // `other_chunk` fully overwrites `self_chunk`\n+                    debug_assert_eq!(self_chunk_domain_size, other_chunk_domain_size);\n+                    *self_chunk = other_chunk.clone();\n+                    changed = true;\n+                }\n+                (\n+                    Mixed(\n+                        self_chunk_domain_size,\n+                        ref mut self_chunk_count,\n+                        ref mut self_chunk_words,\n+                    ),\n+                    Mixed(_other_chunk_domain_size, _other_chunk_count, other_chunk_words),\n+                ) => {\n+                    // First check if the operation would change\n+                    // `self_chunk.words`. If not, we can avoid allocating some\n+                    // words, and this happens often enough that it's a\n+                    // performance win. Also, we only need to operate on the\n+                    // in-use words, hence the slicing.\n+                    let op = |a, b| a | b;\n+                    let num_words = num_words(*self_chunk_domain_size as usize);\n+                    if bitwise_changes(\n+                        &self_chunk_words[0..num_words],\n+                        &other_chunk_words[0..num_words],\n+                        op,\n+                    ) {\n+                        let self_chunk_words = Rc::make_mut(self_chunk_words);\n+                        let has_changed = bitwise(\n+                            &mut self_chunk_words[0..num_words],\n+                            &other_chunk_words[0..num_words],\n+                            op,\n+                        );\n+                        debug_assert!(has_changed);\n+                        *self_chunk_count = self_chunk_words[0..num_words]\n+                            .iter()\n+                            .map(|w| w.count_ones() as ChunkSize)\n+                            .sum();\n+                        if *self_chunk_count == *self_chunk_domain_size {\n+                            *self_chunk = Ones(*self_chunk_domain_size);\n+                        }\n+                        changed = true;\n+                    }\n+                }\n+            }\n+        }\n+        changed\n+    }\n+\n+    fn subtract(&mut self, _other: &ChunkedBitSet<T>) -> bool {\n+        unimplemented!(\"implement if/when necessary\");\n+    }\n+\n+    fn intersect(&mut self, _other: &ChunkedBitSet<T>) -> bool {\n+        unimplemented!(\"implement if/when necessary\");\n+    }\n+}\n+\n+impl<T: Idx> BitRelations<HybridBitSet<T>> for ChunkedBitSet<T> {\n+    fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        // FIXME: this is slow if `other` is dense, and could easily be\n+        // improved, but it hasn't been a problem in practice so far.\n+        assert_eq!(self.domain_size, other.domain_size());\n+        sequential_update(|elem| self.insert(elem), other.iter())\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n+        // FIXME: this is slow if `other` is dense, and could easily be\n+        // improved, but it hasn't been a problem in practice so far.\n+        assert_eq!(self.domain_size, other.domain_size());\n+        sequential_update(|elem| self.remove(elem), other.iter())\n+    }\n+\n+    fn intersect(&mut self, _other: &HybridBitSet<T>) -> bool {\n+        unimplemented!(\"implement if/when necessary\");\n+    }\n+}\n+\n+impl<T> Clone for ChunkedBitSet<T> {\n+    fn clone(&self) -> Self {\n+        ChunkedBitSet {\n+            domain_size: self.domain_size,\n+            chunks: self.chunks.clone(),\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    /// WARNING: this implementation of clone_from will panic if the two\n+    /// bitsets have different domain sizes. This constraint is not inherent to\n+    /// `clone_from`, but it works with the existing call sites and allows a\n+    /// faster implementation, which is important because this function is hot.\n+    fn clone_from(&mut self, from: &Self) {\n+        assert_eq!(self.domain_size, from.domain_size);\n+        debug_assert_eq!(self.chunks.len(), from.chunks.len());\n+\n+        self.chunks.clone_from(&from.chunks)\n+    }\n+}\n+\n+impl Chunk {\n+    #[cfg(test)]\n+    fn assert_valid(&self) {\n+        match *self {\n+            Zeros(chunk_domain_size) | Ones(chunk_domain_size) => {\n+                assert!(chunk_domain_size as usize <= CHUNK_BITS);\n+            }\n+            Mixed(chunk_domain_size, count, ref words) => {\n+                assert!(chunk_domain_size as usize <= CHUNK_BITS);\n+                assert!(0 < count && count < chunk_domain_size);\n+\n+                // Check the number of set bits matches `count`.\n+                assert_eq!(\n+                    words.iter().map(|w| w.count_ones() as ChunkSize).sum::<ChunkSize>(),\n+                    count\n+                );\n+\n+                // Check the not-in-use words are all zeroed.\n+                let num_words = num_words(chunk_domain_size as usize);\n+                if num_words < CHUNK_WORDS {\n+                    assert_eq!(\n+                        words[num_words..]\n+                            .iter()\n+                            .map(|w| w.count_ones() as ChunkSize)\n+                            .sum::<ChunkSize>(),\n+                        0\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn new(chunk_domain_size: usize, is_empty: bool) -> Self {\n+        debug_assert!(chunk_domain_size <= CHUNK_BITS);\n+        let chunk_domain_size = chunk_domain_size as ChunkSize;\n+        if is_empty { Zeros(chunk_domain_size) } else { Ones(chunk_domain_size) }\n+    }\n+\n+    /// Count the number of 1s in the chunk.\n+    fn count(&self) -> usize {\n+        match *self {\n+            Zeros(_) => 0,\n+            Ones(chunk_domain_size) => chunk_domain_size as usize,\n+            Mixed(_, count, _) => count as usize,\n+        }\n+    }\n+}\n+\n // Applies a function to mutate a bitset, and returns true if any\n // of the applications return true\n fn sequential_update<T: Idx>(\n@@ -642,6 +1055,23 @@ where\n     changed != 0\n }\n \n+/// Does this bitwise operation change `out_vec`?\n+#[inline]\n+fn bitwise_changes<Op>(out_vec: &[Word], in_vec: &[Word], op: Op) -> bool\n+where\n+    Op: Fn(Word, Word) -> Word,\n+{\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    for (out_elem, in_elem) in iter::zip(out_vec, in_vec) {\n+        let old_val = *out_elem;\n+        let new_val = op(old_val, *in_elem);\n+        if old_val != new_val {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n const SPARSE_MAX: usize = 8;\n \n /// A fixed-size bitset type with a sparse representation and a maximum of\n@@ -1136,18 +1566,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         for index in start..end {\n             words[index] = !0;\n         }\n-        self.clear_excess_bits(row);\n-    }\n-\n-    /// Clear excess bits in the final word of the row.\n-    fn clear_excess_bits(&mut self, row: R) {\n-        let num_bits_in_final_word = self.num_columns % WORD_BITS;\n-        if num_bits_in_final_word > 0 {\n-            let mask = (1 << num_bits_in_final_word) - 1;\n-            let (_, end) = self.range(row);\n-            let final_word_idx = end - 1;\n-            self.words[final_word_idx] &= mask;\n-        }\n+        clear_excess_bits_in_final_word(self.num_columns, &mut self.words[..end]);\n     }\n \n     /// Gets a slice of the underlying words.\n@@ -1339,6 +1758,12 @@ fn num_words<T: Idx>(domain_size: T) -> usize {\n     (domain_size.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n+#[inline]\n+fn num_chunks<T: Idx>(domain_size: T) -> usize {\n+    assert!(domain_size.index() > 0);\n+    (domain_size.index() + CHUNK_BITS - 1) / CHUNK_BITS\n+}\n+\n #[inline]\n fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n     let elem = elem.index();\n@@ -1347,6 +1772,25 @@ fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n     (word_index, mask)\n }\n \n+#[inline]\n+fn chunk_index<T: Idx>(elem: T) -> usize {\n+    elem.index() / CHUNK_BITS\n+}\n+\n+#[inline]\n+fn chunk_word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n+    let chunk_elem = elem.index() % CHUNK_BITS;\n+    word_index_and_mask(chunk_elem)\n+}\n+\n+fn clear_excess_bits_in_final_word(domain_size: usize, words: &mut [Word]) {\n+    let num_bits_in_final_word = domain_size % WORD_BITS;\n+    if num_bits_in_final_word > 0 {\n+        let mask = (1 << num_bits_in_final_word) - 1;\n+        words[words.len() - 1] &= mask;\n+    }\n+}\n+\n #[inline]\n fn max_bit(word: Word) -> usize {\n     WORD_BITS - 1 - word.leading_zeros() as usize"}, {"sha": "eec7dab5189a664c955a88bffe827560e497ac71", "filename": "compiler/rustc_index/src/bit_set/tests.rs", "status": "modified", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -147,6 +147,201 @@ fn hybrid_bitset() {\n     assert!(dense0.is_empty());\n }\n \n+#[test]\n+fn chunked_bitset() {\n+    let mut b0 = ChunkedBitSet::<usize>::new_empty(0);\n+    let b0b = b0.clone();\n+    assert_eq!(b0, ChunkedBitSet { domain_size: 0, chunks: Box::new([]), marker: PhantomData });\n+\n+    // There are no valid insert/remove/contains operations on a 0-domain\n+    // bitset, but we can test `union`.\n+    b0.assert_valid();\n+    assert!(!b0.union(&b0b));\n+    assert_eq!(b0.chunks(), vec![]);\n+    assert_eq!(b0.count(), 0);\n+    b0.assert_valid();\n+\n+    //-----------------------------------------------------------------------\n+\n+    let mut b1 = ChunkedBitSet::<usize>::new_empty(1);\n+    assert_eq!(\n+        b1,\n+        ChunkedBitSet { domain_size: 1, chunks: Box::new([Zeros(1)]), marker: PhantomData }\n+    );\n+\n+    b1.assert_valid();\n+    assert!(!b1.contains(0));\n+    assert_eq!(b1.count(), 0);\n+    assert!(b1.insert(0));\n+    assert!(b1.contains(0));\n+    assert_eq!(b1.count(), 1);\n+    assert_eq!(b1.chunks(), [Ones(1)]);\n+    assert!(!b1.insert(0));\n+    assert!(b1.remove(0));\n+    assert!(!b1.contains(0));\n+    assert_eq!(b1.count(), 0);\n+    assert_eq!(b1.chunks(), [Zeros(1)]);\n+    b1.assert_valid();\n+\n+    //-----------------------------------------------------------------------\n+\n+    let mut b100 = ChunkedBitSet::<usize>::new_filled(100);\n+    assert_eq!(\n+        b100,\n+        ChunkedBitSet { domain_size: 100, chunks: Box::new([Ones(100)]), marker: PhantomData }\n+    );\n+\n+    b100.assert_valid();\n+    for i in 0..100 {\n+        assert!(b100.contains(i));\n+    }\n+    assert_eq!(b100.count(), 100);\n+    assert!(b100.remove(3));\n+    assert!(b100.insert(3));\n+    assert_eq!(b100.chunks(), vec![Ones(100)]);\n+    assert!(\n+        b100.remove(20) && b100.remove(30) && b100.remove(40) && b100.remove(99) && b100.insert(30)\n+    );\n+    assert_eq!(b100.count(), 97);\n+    assert!(!b100.contains(20) && b100.contains(30) && !b100.contains(99) && b100.contains(50));\n+    assert_eq!(\n+        b100.chunks(),\n+        vec![Mixed(\n+            100,\n+            97,\n+            #[rustfmt::skip]\n+            Rc::new([\n+                0b11111111_11111111_11111110_11111111_11111111_11101111_11111111_11111111,\n+                0b00000000_00000000_00000000_00000111_11111111_11111111_11111111_11111111,\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0,\n+            ])\n+        )],\n+    );\n+    b100.assert_valid();\n+    let mut num_removed = 0;\n+    for i in 0..100 {\n+        if b100.remove(i) {\n+            num_removed += 1;\n+        }\n+    }\n+    assert_eq!(num_removed, 97);\n+    assert_eq!(b100.chunks(), vec![Zeros(100)]);\n+    b100.assert_valid();\n+\n+    //-----------------------------------------------------------------------\n+\n+    let mut b2548 = ChunkedBitSet::<usize>::new_empty(2548);\n+    assert_eq!(\n+        b2548,\n+        ChunkedBitSet {\n+            domain_size: 2548,\n+            chunks: Box::new([Zeros(2048), Zeros(500)]),\n+            marker: PhantomData,\n+        }\n+    );\n+\n+    b2548.assert_valid();\n+    b2548.insert(14);\n+    b2548.remove(14);\n+    assert_eq!(b2548.chunks(), vec![Zeros(2048), Zeros(500)]);\n+    b2548.insert_all();\n+    for i in 0..2548 {\n+        assert!(b2548.contains(i));\n+    }\n+    assert_eq!(b2548.count(), 2548);\n+    assert_eq!(b2548.chunks(), vec![Ones(2048), Ones(500)]);\n+    b2548.assert_valid();\n+\n+    //-----------------------------------------------------------------------\n+\n+    let mut b4096 = ChunkedBitSet::<usize>::new_empty(4096);\n+    assert_eq!(\n+        b4096,\n+        ChunkedBitSet {\n+            domain_size: 4096,\n+            chunks: Box::new([Zeros(2048), Zeros(2048)]),\n+            marker: PhantomData,\n+        }\n+    );\n+\n+    b4096.assert_valid();\n+    for i in 0..4096 {\n+        assert!(!b4096.contains(i));\n+    }\n+    assert!(b4096.insert(0) && b4096.insert(4095) && !b4096.insert(4095));\n+    assert!(\n+        b4096.contains(0) && !b4096.contains(2047) && !b4096.contains(2048) && b4096.contains(4095)\n+    );\n+    assert_eq!(\n+        b4096.chunks(),\n+        #[rustfmt::skip]\n+        vec![\n+            Mixed(2048, 1, Rc::new([\n+                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+            ])),\n+            Mixed(2048, 1, Rc::new([\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8000_0000_0000_0000\n+            ])),\n+        ],\n+    );\n+    assert_eq!(b4096.count(), 2);\n+    b4096.assert_valid();\n+\n+    //-----------------------------------------------------------------------\n+\n+    let mut b10000 = ChunkedBitSet::<usize>::new_empty(10000);\n+    assert_eq!(\n+        b10000,\n+        ChunkedBitSet {\n+            domain_size: 10000,\n+            chunks: Box::new([Zeros(2048), Zeros(2048), Zeros(2048), Zeros(2048), Zeros(1808),]),\n+            marker: PhantomData,\n+        }\n+    );\n+\n+    b10000.assert_valid();\n+    assert!(b10000.insert(3000) && b10000.insert(5000));\n+    assert_eq!(\n+        b10000.chunks(),\n+        #[rustfmt::skip]\n+        vec![\n+            Zeros(2048),\n+            Mixed(2048, 1, Rc::new([\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0100_0000_0000_0000, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            ])),\n+            Mixed(2048, 1, Rc::new([\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0100, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            ])),\n+            Zeros(2048),\n+            Zeros(1808),\n+        ],\n+    );\n+    let mut b10000b = ChunkedBitSet::<usize>::new_empty(10000);\n+    b10000b.clone_from(&b10000);\n+    assert_eq!(b10000, b10000b);\n+    for i in 6000..7000 {\n+        b10000b.insert(i);\n+    }\n+    assert_eq!(b10000b.count(), 1002);\n+    b10000b.assert_valid();\n+    b10000b.clone_from(&b10000);\n+    assert_eq!(b10000b.count(), 2);\n+    for i in 2000..8000 {\n+        b10000b.insert(i);\n+    }\n+    b10000.union(&b10000b);\n+    assert_eq!(b10000.count(), 6000);\n+    b10000.union(&b10000b);\n+    assert_eq!(b10000.count(), 6000);\n+    b10000.assert_valid();\n+    b10000b.assert_valid();\n+}\n+\n #[test]\n fn grow() {\n     let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);"}, {"sha": "0cfb7bd110602103b6c3a5962c0dcd1ef1223817", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,11 +1,21 @@\n #![feature(allow_internal_unstable)]\n #![feature(bench_black_box)]\n #![feature(extend_one)]\n+#![feature(let_else)]\n #![feature(min_specialization)]\n+#![feature(new_uninit)]\n #![feature(step_trait)]\n+#![feature(stmt_expr_attributes)]\n #![feature(test)]\n-#![feature(let_else)]\n \n pub mod bit_set;\n pub mod interval;\n pub mod vec;\n+\n+/// Type size assertion. The first argument is a type and the second argument is its expected size.\n+#[macro_export]\n+macro_rules! static_assert_size {\n+    ($ty:ty, $size:expr) => {\n+        const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n+    };\n+}"}, {"sha": "2de5a9d6991fece2f9c8ce498610a29fc5352d20", "filename": "compiler/rustc_mir_dataflow/src/framework/cursor.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fcursor.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,10 +1,12 @@\n //! Random access inspection of the results of a dataflow analysis.\n \n+use crate::framework::BitSetExt;\n+\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n \n+#[cfg(debug_assertions)]\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n use super::{Analysis, Direction, Effect, EffectIndex, Results};\n@@ -209,13 +211,13 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, A, R, T> ResultsCursor<'mir, 'tcx, A, R>\n+impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n where\n-    A: Analysis<'tcx, Domain = BitSet<T>>,\n-    T: Idx,\n+    A: crate::GenKillAnalysis<'tcx>,\n+    A::Domain: BitSetExt<A::Idx>,\n     R: Borrow<Results<'tcx, A>>,\n {\n-    pub fn contains(&self, elem: T) -> bool {\n+    pub fn contains(&self, elem: A::Idx) -> bool {\n         self.get().contains(elem)\n     }\n }"}, {"sha": "88ed0128a1fd360d2ed4825b29927b60c853a15e", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,6 +1,7 @@\n //! A solver for dataflow problems.\n \n-use std::borrow::BorrowMut;\n+use crate::framework::BitSetExt;\n+\n use std::ffi::OsString;\n use std::path::PathBuf;\n \n@@ -91,7 +92,7 @@ where\n impl<'a, 'tcx, A, D, T> Engine<'a, 'tcx, A>\n where\n     A: GenKillAnalysis<'tcx, Idx = T, Domain = D>,\n-    D: Clone + JoinSemiLattice + GenKill<T> + BorrowMut<BitSet<T>>,\n+    D: Clone + JoinSemiLattice + GenKill<T> + BitSetExt<T>,\n     T: Idx,\n {\n     /// Creates a new `Engine` to solve a gen-kill dataflow problem.\n@@ -106,7 +107,7 @@ where\n \n         // Otherwise, compute and store the cumulative transfer function for each block.\n \n-        let identity = GenKillSet::identity(analysis.bottom_value(body).borrow().domain_size());\n+        let identity = GenKillSet::identity(analysis.bottom_value(body).domain_size());\n         let mut trans_for_block = IndexVec::from_elem(identity, body.basic_blocks());\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n@@ -115,7 +116,7 @@ where\n         }\n \n         let apply_trans = Box::new(move |bb: BasicBlock, state: &mut A::Domain| {\n-            trans_for_block[bb].apply(state.borrow_mut());\n+            trans_for_block[bb].apply(state);\n         });\n \n         Self::new(tcx, body, analysis, Some(apply_trans as Box<_>))"}, {"sha": "99735673f4d58fc6991a072ffe6a9e42bd61b687", "filename": "compiler/rustc_mir_dataflow/src/framework/fmt.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ffmt.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,7 +1,7 @@\n //! Custom formatting traits used when outputting Graphviz diagrams with the results of a dataflow\n //! analysis.\n \n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::bit_set::{BitSet, ChunkedBitSet, HybridBitSet};\n use rustc_index::vec::Idx;\n use std::fmt;\n \n@@ -133,6 +133,19 @@ where\n     }\n }\n \n+impl<T, C> DebugWithContext<C> for ChunkedBitSet<T>\n+where\n+    T: Idx + DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, _ctxt: &C, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        unimplemented!(\"implement when/if needed\");\n+    }\n+\n+    fn fmt_diff_with(&self, _old: &Self, _ctxt: &C, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        unimplemented!(\"implement when/if needed\");\n+    }\n+}\n+\n impl<T, C> DebugWithContext<C> for &'_ T\n where\n     T: DebugWithContext<C>,"}, {"sha": "9a462f6e1a41afed9c626889419f181bb384f086", "filename": "compiler/rustc_mir_dataflow/src/framework/lattice.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -38,7 +38,8 @@\n //! [Hasse diagram]: https://en.wikipedia.org/wiki/Hasse_diagram\n //! [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n \n-use rustc_index::bit_set::BitSet;\n+use crate::framework::BitSetExt;\n+use rustc_index::bit_set::{BitSet, ChunkedBitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use std::iter;\n \n@@ -145,6 +146,18 @@ impl<T: Idx> MeetSemiLattice for BitSet<T> {\n     }\n }\n \n+impl<T: Idx> JoinSemiLattice for ChunkedBitSet<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.union(other)\n+    }\n+}\n+\n+impl<T: Idx> MeetSemiLattice for ChunkedBitSet<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        self.intersect(other)\n+    }\n+}\n+\n /// The counterpart of a given semilattice `T` using the [inverse order].\n ///\n /// The dual of a join-semilattice is a meet-semilattice and vice versa. For example, the dual of a\n@@ -155,15 +168,21 @@ impl<T: Idx> MeetSemiLattice for BitSet<T> {\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub struct Dual<T>(pub T);\n \n-impl<T> std::borrow::Borrow<T> for Dual<T> {\n-    fn borrow(&self) -> &T {\n-        &self.0\n+impl<T: Idx> BitSetExt<T> for Dual<BitSet<T>> {\n+    fn domain_size(&self) -> usize {\n+        self.0.domain_size()\n+    }\n+\n+    fn contains(&self, elem: T) -> bool {\n+        self.0.contains(elem)\n+    }\n+\n+    fn union(&mut self, other: &HybridBitSet<T>) {\n+        self.0.union(other);\n     }\n-}\n \n-impl<T> std::borrow::BorrowMut<T> for Dual<T> {\n-    fn borrow_mut(&mut self) -> &mut T {\n-        &mut self.0\n+    fn subtract(&mut self, other: &HybridBitSet<T>) {\n+        self.0.subtract(other);\n     }\n }\n "}, {"sha": "c51dd06de251d42533caccb800dca6410b4a65b5", "filename": "compiler/rustc_mir_dataflow/src/framework/mod.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -30,10 +30,9 @@\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n \n-use std::borrow::BorrowMut;\n use std::cmp::Ordering;\n \n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::bit_set::{BitSet, ChunkedBitSet, HybridBitSet};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::TyCtxt;\n@@ -52,6 +51,51 @@ pub use self::engine::{Engine, Results};\n pub use self::lattice::{JoinSemiLattice, MeetSemiLattice};\n pub use self::visitor::{visit_results, ResultsVisitable, ResultsVisitor};\n \n+/// Analysis domains are all bitsets of various kinds. This trait holds\n+/// operations needed by all of them.\n+pub trait BitSetExt<T> {\n+    fn domain_size(&self) -> usize;\n+    fn contains(&self, elem: T) -> bool;\n+    fn union(&mut self, other: &HybridBitSet<T>);\n+    fn subtract(&mut self, other: &HybridBitSet<T>);\n+}\n+\n+impl<T: Idx> BitSetExt<T> for BitSet<T> {\n+    fn domain_size(&self) -> usize {\n+        self.domain_size()\n+    }\n+\n+    fn contains(&self, elem: T) -> bool {\n+        self.contains(elem)\n+    }\n+\n+    fn union(&mut self, other: &HybridBitSet<T>) {\n+        self.union(other);\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) {\n+        self.subtract(other);\n+    }\n+}\n+\n+impl<T: Idx> BitSetExt<T> for ChunkedBitSet<T> {\n+    fn domain_size(&self) -> usize {\n+        self.domain_size()\n+    }\n+\n+    fn contains(&self, elem: T) -> bool {\n+        self.contains(elem)\n+    }\n+\n+    fn union(&mut self, other: &HybridBitSet<T>) {\n+        self.union(other);\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) {\n+        self.subtract(other);\n+    }\n+}\n+\n /// Define the domain of a dataflow problem.\n ///\n /// This trait specifies the lattice on which this analysis operates (the domain) as well as its\n@@ -303,7 +347,7 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n impl<'tcx, A> Analysis<'tcx> for A\n where\n     A: GenKillAnalysis<'tcx>,\n-    A::Domain: GenKill<A::Idx> + BorrowMut<BitSet<A::Idx>>,\n+    A::Domain: GenKill<A::Idx> + BitSetExt<A::Idx>,\n {\n     fn apply_statement_effect(\n         &self,\n@@ -435,7 +479,7 @@ impl<T: Idx> GenKillSet<T> {\n         }\n     }\n \n-    pub fn apply(&self, state: &mut BitSet<T>) {\n+    pub fn apply(&self, state: &mut impl BitSetExt<T>) {\n         state.union(&self.gen);\n         state.subtract(&self.kill);\n     }\n@@ -463,6 +507,16 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n+impl<T: Idx> GenKill<T> for ChunkedBitSet<T> {\n+    fn gen(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.remove(elem);\n+    }\n+}\n+\n impl<T: Idx> GenKill<T> for lattice::Dual<BitSet<T>> {\n     fn gen(&mut self, elem: T) {\n         self.0.insert(elem);"}, {"sha": "9502c5d57d68860944170a19347ed55f404a1baf", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -2,7 +2,7 @@\n //! bitvectors attached to each basic block, represented via a\n //! zero-sized structure.\n \n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::{BitSet, ChunkedBitSet};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::visit::{MirVisitable, Visitor};\n use rustc_middle::mir::{self, Body, Location};\n@@ -286,12 +286,12 @@ impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n-    type Domain = BitSet<MovePathIndex>;\n+    type Domain = ChunkedBitSet<MovePathIndex>;\n     const NAME: &'static str = \"maybe_init\";\n \n     fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n         // bottom = uninitialized\n-        BitSet::new_empty(self.move_data().move_paths.len())\n+        ChunkedBitSet::new_empty(self.move_data().move_paths.len())\n     }\n \n     fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut Self::Domain) {\n@@ -417,13 +417,13 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n-    type Domain = BitSet<MovePathIndex>;\n+    type Domain = ChunkedBitSet<MovePathIndex>;\n \n     const NAME: &'static str = \"maybe_uninit\";\n \n     fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n         // bottom = initialized (start_block_effect counters this at outset)\n-        BitSet::new_empty(self.move_data().move_paths.len())\n+        ChunkedBitSet::new_empty(self.move_data().move_paths.len())\n     }\n \n     // sets on_entry bits for Arg places\n@@ -606,13 +606,13 @@ impl<'tcx> GenKillAnalysis<'tcx> for DefinitelyInitializedPlaces<'_, 'tcx> {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n-    type Domain = BitSet<InitIndex>;\n+    type Domain = ChunkedBitSet<InitIndex>;\n \n     const NAME: &'static str = \"ever_init\";\n \n     fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n         // bottom = no initialized variables by default\n-        BitSet::new_empty(self.move_data().inits.len())\n+        ChunkedBitSet::new_empty(self.move_data().inits.len())\n     }\n \n     fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {"}, {"sha": "51ab5b43bff0a3753c1ee20952a8e46a772e52dd", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,5 +1,3 @@\n-use std::borrow::Borrow;\n-\n use rustc_ast::ast;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -10,6 +8,7 @@ use rustc_middle::mir::MirPass;\n use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n+use crate::framework::BitSetExt;\n use crate::impls::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeUninitializedPlaces,\n };\n@@ -248,7 +247,7 @@ pub trait RustcPeekAt<'tcx>: Analysis<'tcx> {\n impl<'tcx, A, D> RustcPeekAt<'tcx> for A\n where\n     A: Analysis<'tcx, Domain = D> + HasMoveData<'tcx>,\n-    D: JoinSemiLattice + Clone + Borrow<BitSet<MovePathIndex>>,\n+    D: JoinSemiLattice + Clone + BitSetExt<MovePathIndex>,\n {\n     fn peek_at(\n         &self,\n@@ -259,7 +258,7 @@ where\n     ) {\n         match self.move_data().rev_lookup.find(place.as_ref()) {\n             LookupResult::Exact(peek_mpi) => {\n-                let bit_state = flow_state.borrow().contains(peek_mpi);\n+                let bit_state = flow_state.contains(peek_mpi);\n                 debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\", call.arg, place, bit_state);\n                 if !bit_state {\n                     tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");"}, {"sha": "dc1b76aba1613afdba078f7b83379036004611db", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b495f3cf23a1f235482ce7f81f0f4be614bb85/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=36b495f3cf23a1f235482ce7f81f0f4be614bb85", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::ChunkedBitSet;\n use rustc_middle::mir::{Body, Field, Rvalue, Statement, StatementKind, TerminatorKind};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, VariantDef};\n@@ -89,7 +89,7 @@ impl<'tcx> MirPass<'tcx> for RemoveUninitDrops {\n fn is_needs_drop_and_init<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    maybe_inits: &BitSet<MovePathIndex>,\n+    maybe_inits: &ChunkedBitSet<MovePathIndex>,\n     move_data: &MoveData<'tcx>,\n     ty: Ty<'tcx>,\n     mpi: MovePathIndex,"}]}