{"sha": "bcda58f49133921abd091d7f800732fe2c4e5a98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZGE1OGY0OTEzMzkyMWFiZDA5MWQ3ZjgwMDczMmZlMmM0ZTVhOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-10T04:16:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-10T04:16:20Z"}, "message": "Auto merge of #31710 - eddyb:reify, r=nikomatsakis\n\nDistinguish fn item types to allow reification from nothing to fn pointers.\n\nThe first commit is a rebase of #26284, except for files that have moved since.\n\nThis is a [breaking-change], due to:\n* each FFI function has a distinct type, like all other functions currently do\n* all generic parameters on functions are recorded in their item types, e.g.:\n`size_of::<u8>` & `size_of::<i8>`'s types differ despite their identical signature.\n* function items are zero-sized, which will stop transmutes from working on them\n\nThe first two cases are handled in most cases with the new coerce-unify logic,\nwhich will combine incompatible function item types into function pointers,\nat the outer-most level of if-else chains, match arms and array literals.\n\nThe last case is specially handled during type-checking such that transmutes\nfrom a function item type to a pointer or integer type will continue to work for\nanother release cycle, but are being linted against. To get rid of warnings and\nensure your code will continue to compile, cast to a pointer before transmuting.", "tree": {"sha": "bf0595da87152141630ebfbc469b1de313f36f2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf0595da87152141630ebfbc469b1de313f36f2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcda58f49133921abd091d7f800732fe2c4e5a98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcda58f49133921abd091d7f800732fe2c4e5a98", "html_url": "https://github.com/rust-lang/rust/commit/bcda58f49133921abd091d7f800732fe2c4e5a98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcda58f49133921abd091d7f800732fe2c4e5a98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b9995b24ccc7489e0082199793c300015753dd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9995b24ccc7489e0082199793c300015753dd1", "html_url": "https://github.com/rust-lang/rust/commit/0b9995b24ccc7489e0082199793c300015753dd1"}, {"sha": "3855fa99cad8412be5c2f322fa40a0d415d6cbd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3855fa99cad8412be5c2f322fa40a0d415d6cbd6", "html_url": "https://github.com/rust-lang/rust/commit/3855fa99cad8412be5c2f322fa40a0d415d6cbd6"}], "stats": {"total": 4298, "additions": 2056, "deletions": 2242}, "files": [{"sha": "97a550a4076fab8b3b743545ba3170eb6baf58f5", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -148,6 +148,12 @@ declare_lint! {\n     \"uses of #[derive] with raw pointers are rarely correct\"\n }\n \n+declare_lint! {\n+    pub TRANSMUTE_FROM_FN_ITEM_TYPES,\n+    Warn,\n+    \"transmute from function item type to pointer-sized type erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -177,7 +183,8 @@ impl LintPass for HardwiredLints {\n             INVALID_TYPE_PARAM_DEFAULT,\n             MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n             CONST_ERR,\n-            RAW_POINTER_DERIVE\n+            RAW_POINTER_DERIVE,\n+            TRANSMUTE_FROM_FN_ITEM_TYPES\n         )\n     }\n }"}, {"sha": "c11e9dc822eb39790cbd5bc2c57698ae372653c3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -1287,6 +1287,9 @@ pub fn check_crate(tcx: &TyCtxt, access_levels: &AccessLevels) {\n     }\n \n     *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n+\n+    // Put the lint store back in the session.\n+    mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), cx.lints);\n }\n \n pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {"}, {"sha": "e6821cf639eca2d8058d0a81b82e71f45a503eb9", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -44,7 +44,8 @@ enum RootUnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyBareFn(_, ref f) => f.unsafety == hir::Unsafety::Unsafe,\n+        ty::TyFnDef(_, _, ref f) |\n+        ty::TyFnPtr(ref f) => f.unsafety == hir::Unsafety::Unsafe,\n         _ => false,\n     }\n }"}, {"sha": "a87ce1206b408f2217782d52cf772476d2238954", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -556,7 +556,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                callee, callee_ty);\n         let call_scope = self.tcx().region_maps.node_extent(call.id);\n         match callee_ty.sty {\n-            ty::TyBareFn(..) => {\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n                 self.consume_expr(callee);\n             }\n             ty::TyError => { }"}, {"sha": "6c0dd9b608d5674e529f23d9082b015e15a3600a", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -161,7 +161,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::TySlice(..) |\n             ty::TyRawPtr(..) |\n             ty::TyRef(..) |\n-            ty::TyBareFn(..) |\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) |\n             ty::TyTrait(..) |\n             ty::TyStruct(..) |\n             ty::TyClosure(..) |"}, {"sha": "1e3546269dbc279508346d1babeb58b8d8ff4782", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -454,7 +454,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          -> UnitResult<'tcx>\n {\n     debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n-    cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n+    cx.eq_types(a_is_expected, origin, a, b)\n }\n \n pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -466,7 +466,7 @@ pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n {\n     debug!(\"mk_eq_trait_refs({:?} <: {:?})\",\n            a, b);\n-    cx.commit_if_ok(|_| cx.eq_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+    cx.eq_trait_refs(a_is_expected, origin, a, b)\n }\n \n pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -478,7 +478,7 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n {\n     debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\",\n            a, b);\n-    cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+    cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -1351,18 +1351,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_mismatched_types(&self,\n-                                   span: Span,\n+                                   origin: TypeOrigin,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: &TypeError<'tcx>) {\n+                                   err: TypeError<'tcx>) {\n         let trace = TypeTrace {\n-            origin: TypeOrigin::Misc(span),\n+            origin: origin,\n             values: Types(ExpectedFound {\n                 expected: expected,\n                 found: actual\n             })\n         };\n-        self.report_and_explain_type_error(trace, err);\n+        self.report_and_explain_type_error(trace, &err);\n     }\n \n     pub fn report_conflicting_default_types(&self,"}, {"sha": "fd857513e5b560c0f9e1f69fa4c16e4feae38880", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -12,7 +12,7 @@ use dep_graph::DepNode;\n use middle::def::Def;\n use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n-use middle::ty::{TransmuteRestriction, TyCtxt, TyBareFn};\n+use middle::ty::{TransmuteRestriction, TyCtxt};\n use middle::ty::{self, Ty, TypeFoldable};\n \n use std::fmt;\n@@ -53,7 +53,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.tcx.lookup_item_type(def_id).ty.sty {\n-            ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n+            ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n         intrinsic && self.tcx.item_name(def_id).as_str() == \"transmute\"\n@@ -238,7 +238,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n                     let typ = self.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n-                        TyBareFn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        ty::TyFnDef(_, _, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n                                 let from = bare_fn_ty.sig.0.inputs[0];\n                                 self.check_transmute(expr.span, from, to, expr.id);"}, {"sha": "02dfeb80b928f0c5b18e3adc119806c7026742cc", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -148,11 +148,11 @@ impl<'tcx> Substs<'tcx> {\n         Substs { types: types, regions: regions }\n     }\n \n-    pub fn with_method_from(self,\n+    pub fn with_method_from(&self,\n                             meth_substs: &Substs<'tcx>)\n                             -> Substs<'tcx>\n     {\n-        let Substs { types, regions } = self;\n+        let Substs { types, regions } = self.clone();\n         let types = types.with_slice(FnSpace, meth_substs.types.get_slice(FnSpace));\n         let regions = regions.map(|r| {\n             r.with_slice(FnSpace, meth_substs.regions().get_slice(FnSpace))"}, {"sha": "b79849e87ffacc3a50737646e003667fe324a280", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -301,7 +301,8 @@ fn ty_is_local_constructor<'tcx>(tcx: &TyCtxt<'tcx>,\n         ty::TyUint(..) |\n         ty::TyFloat(..) |\n         ty::TyStr |\n-        ty::TyBareFn(..) |\n+        ty::TyFnDef(..) |\n+        ty::TyFnPtr(_) |\n         ty::TyArray(..) |\n         ty::TySlice(..) |\n         ty::TyRawPtr(..) |"}, {"sha": "8a2f0c0c093041fe9c6011386bd94031794c03a7", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -278,7 +278,7 @@ pub enum Vtable<'tcx, N> {\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n-    pub substs: subst::Substs<'tcx>,\n+    pub substs: &'tcx subst::Substs<'tcx>,\n     pub nested: Vec<N>\n }\n "}, {"sha": "e36307feddbf79b3a7ec68bdfcd414bbd19cf97a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -948,7 +948,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     for impl_item in &selcx.tcx().impl_items.borrow()[&impl_vtable.impl_def_id] {\n         if let ty::TypeTraitItem(ref assoc_ty) = impl_or_trait_items_map[&impl_item.def_id()] {\n             if assoc_ty.name == obligation.predicate.item_name {\n-                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), &impl_vtable.substs),\n+                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), impl_vtable.substs),\n                         impl_vtable.nested);\n             }\n         }"}, {"sha": "2ecfa119007b8c88bb8e141ab208270d64d17ba3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -1286,7 +1286,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyBareFn(_, &ty::BareFnTy {\n+            ty::TyFnDef(_, _, &ty::BareFnTy {\n+                unsafety: hir::Unsafety::Normal,\n+                abi: Abi::Rust,\n+                sig: ty::Binder(ty::FnSig {\n+                    inputs: _,\n+                    output: ty::FnConverging(_),\n+                    variadic: false\n+                })\n+            }) |\n+            ty::TyFnPtr(&ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -1646,7 +1655,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInt(_) |\n             ty::TyBool |\n             ty::TyFloat(_) |\n-            ty::TyBareFn(..) |\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) |\n             ty::TyChar => {\n                 // safe for everything\n                 ok_if(Vec::new())\n@@ -1850,7 +1860,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInt(_) |\n             ty::TyBool |\n             ty::TyFloat(_) |\n-            ty::TyBareFn(..) |\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) |\n             ty::TyStr |\n             ty::TyError |\n             ty::TyInfer(ty::IntVar(_)) |\n@@ -2294,7 +2305,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData { impl_def_id: impl_def_id,\n-                         substs: substs.value,\n+                         substs: self.tcx().mk_substs(substs.value),\n                          nested: impl_obligations }\n     }\n "}, {"sha": "903b7c80bafabee8633dabb94537a4537d67def1", "filename": "src/librustc/middle/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -147,9 +147,10 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n     fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let substs = self.substs.fold_with(folder);\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n+            substs: folder.tcx().mk_substs(substs),\n             nested: self.nested.fold_with(folder),\n         }\n     }"}, {"sha": "e4c293a74e896ceb890b0092069676e4e1316897", "filename": "src/librustc/middle/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -155,8 +155,8 @@ impl<'tcx> ty::TyS<'tcx> {\n                 match *adjustment {\n                     AdjustReifyFnPointer => {\n                         match self.sty {\n-                            ty::TyBareFn(Some(_), b) => {\n-                                cx.mk_fn(None, b)\n+                            ty::TyFnDef(_, _, b) => {\n+                                cx.mk_ty(ty::TyFnPtr(b))\n                             }\n                             _ => {\n                                 cx.sess.bug(\n@@ -168,7 +168,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n                     AdjustUnsafeFnPointer => {\n                         match self.sty {\n-                            ty::TyBareFn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n+                            ty::TyFnPtr(b) => cx.safe_to_unsafe_fn_ty(b),\n                             ref b => {\n                                 cx.sess.bug(\n                                     &format!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: \\"}, {"sha": "b25d6e0476d9847c4151121baba40ee2b68d9d57", "filename": "src/librustc/middle/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -69,7 +69,7 @@ impl<'tcx> CastTy<'tcx> {\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n-            ty::TyBareFn(..) => Some(CastTy::FnPtr),\n+            ty::TyFnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }\n     }"}, {"sha": "47a15a14b41ee43fb74b2532e022ed7e4952b1b1", "filename": "src/librustc/middle/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -187,7 +187,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 // Scalar and unique types are sendable, and durable\n                 ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n                 ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-                ty::TyBareFn(..) | ty::TyChar => {\n+                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar => {\n                     TC::None\n                 }\n "}, {"sha": "61a7f49f45d4e7fd267db5be9e68a57633dfac3e", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -41,7 +41,6 @@ use std::borrow::Borrow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n-use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token::special_idents;\n@@ -734,8 +733,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn print_debug_stats(&self) {\n         sty_debug_print!(\n             self,\n-            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyBareFn, TyTrait,\n-            TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n+            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -792,12 +791,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(&self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n         assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n-        let unsafe_fn_ty_a = self.mk_bare_fn(ty::BareFnTy {\n+        self.mk_fn_ptr(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n             abi: bare_fn.abi,\n             sig: bare_fn.sig.clone()\n-        });\n-        self.mk_fn(None, unsafe_fn_ty_a)\n+        })\n     }\n \n     pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n@@ -946,26 +944,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(TyBool)\n     }\n \n-    pub fn mk_fn(&self,\n-                 opt_def_id: Option<DefId>,\n-                 fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyBareFn(opt_def_id, fty))\n-    }\n-\n-    pub fn mk_ctor_fn(&self,\n-                      def_id: DefId,\n-                      input_tys: &[Ty<'tcx>],\n-                      output: Ty<'tcx>) -> Ty<'tcx> {\n-        let input_args = input_tys.iter().cloned().collect();\n-        self.mk_fn(Some(def_id), self.mk_bare_fn(BareFnTy {\n-            unsafety: hir::Unsafety::Normal,\n-            abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: input_args,\n-                output: ty::FnConverging(output),\n-                variadic: false\n-            })\n-        }))\n+    pub fn mk_fn_def(&self, def_id: DefId,\n+                     substs: &'tcx Substs<'tcx>,\n+                     fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnDef(def_id, substs, self.mk_bare_fn(fty)))\n+    }\n+\n+    pub fn mk_fn_ptr(&self, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnPtr(self.mk_bare_fn(fty)))\n     }\n \n     pub fn mk_trait(&self,"}, {"sha": "1033af5f331a7c5ad932f44292c54d2131dec427", "filename": "src/librustc/middle/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -223,8 +223,8 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::TySlice(_) => \"slice\".to_string(),\n             ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n             ty::TyRef(_, _) => \"&-ptr\".to_string(),\n-            ty::TyBareFn(Some(_), _) => format!(\"fn item\"),\n-            ty::TyBareFn(None, _) => \"fn pointer\".to_string(),\n+            ty::TyFnDef(..) => format!(\"fn item\"),\n+            ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n             ty::TyTrait(ref inner) => {\n                 format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n             }"}, {"sha": "fc4db22a8a62f7a00a4aa02ada2273cebfd68666", "filename": "src/librustc/middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -83,7 +83,7 @@ pub fn simplify_type(tcx: &TyCtxt,\n         ty::TyTuple(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyBareFn(_, ref f) => {\n+        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {"}, {"sha": "c491bd6ca5e99d6dad0d4812ef34b0c042aa5708", "filename": "src/librustc/middle/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -134,7 +134,12 @@ impl FlagComputation {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyBareFn(_, ref f) => {\n+            &ty::TyFnDef(_, substs, ref f) => {\n+                self.add_substs(substs);\n+                self.add_fn_sig(&f.sig);\n+            }\n+\n+            &ty::TyFnPtr(ref f) => {\n                 self.add_fn_sig(&f.sig);\n             }\n         }"}, {"sha": "9439180a6cd211243727e1e7892140bc7294ca5e", "filename": "src/librustc/middle/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -182,7 +182,8 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         ty::TyRawPtr(..) |      // ...\n         ty::TyRef(..) |         // OutlivesReference\n         ty::TyTuple(..) |       // ...\n-        ty::TyBareFn(..) |      // OutlivesFunction (*)\n+        ty::TyFnDef(..) |       // OutlivesFunction (*)\n+        ty::TyFnPtr(_) |        // OutlivesFunction (*)\n         ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n         ty::TyError => {\n             // (*) Bare functions and traits are both binders. In the"}, {"sha": "6da65c85f91dbbc485bdf233c5ad95cad02197f0", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -139,11 +139,11 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n     relate_substs(relation, opt_variances, a_subst, b_subst)\n }\n \n-fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                               variances: Option<&ty::ItemVariances>,\n-                               a_subst: &Substs<'tcx>,\n-                               b_subst: &Substs<'tcx>)\n-                               -> RelateResult<'tcx, Substs<'tcx>>\n+pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n+                                   variances: Option<&ty::ItemVariances>,\n+                                   a_subst: &Substs<'tcx>,\n+                                   b_subst: &Substs<'tcx>)\n+                                   -> RelateResult<'tcx, Substs<'tcx>>\n     where R: TypeRelation<'a,'tcx>\n {\n     let mut substs = Substs::empty();\n@@ -568,11 +568,19 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::TyBareFn(a_opt_def_id, a_fty), &ty::TyBareFn(b_opt_def_id, b_fty))\n-            if a_opt_def_id == b_opt_def_id =>\n+        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n+         &ty::TyFnDef(b_def_id, b_substs, b_fty))\n+            if a_def_id == b_def_id =>\n         {\n+            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n             let fty = try!(relation.relate(a_fty, b_fty));\n-            Ok(tcx.mk_fn(a_opt_def_id, tcx.mk_bare_fn(fty)))\n+            Ok(tcx.mk_fn_def(a_def_id, tcx.mk_substs(substs), fty))\n+        }\n+\n+        (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>\n+        {\n+            let fty = try!(relation.relate(a_fty, b_fty));\n+            Ok(tcx.mk_fn_ptr(fty))\n         }\n \n         (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>"}, {"sha": "3fe9e02a90d42e3a3286860eb017db9d7b4a97de", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -282,9 +282,16 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             }\n             ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n             ty::TyTuple(ref ts) => ty::TyTuple(ts.fold_with(folder)),\n-            ty::TyBareFn(opt_def_id, ref f) => {\n+            ty::TyFnDef(def_id, substs, ref f) => {\n+                let substs = substs.fold_with(folder);\n+                let bfn = f.fold_with(folder);\n+                ty::TyFnDef(def_id,\n+                            folder.tcx().mk_substs(substs),\n+                            folder.tcx().mk_bare_fn(bfn))\n+            }\n+            ty::TyFnPtr(ref f) => {\n                 let bfn = f.fold_with(folder);\n-                ty::TyBareFn(opt_def_id, folder.tcx().mk_bare_fn(bfn))\n+                ty::TyFnPtr(folder.tcx().mk_bare_fn(bfn))\n             }\n             ty::TyRef(r, ref tm) => {\n                 let r = r.fold_with(folder);\n@@ -318,7 +325,10 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyEnum(_tid, ref substs) => substs.visit_with(visitor),\n             ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n             ty::TyTuple(ref ts) => ts.visit_with(visitor),\n-            ty::TyBareFn(_opt_def_id, ref f) => f.visit_with(visitor),\n+            ty::TyFnDef(_, substs, ref f) => {\n+                substs.visit_with(visitor) || f.visit_with(visitor)\n+            }\n+            ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n             ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),"}, {"sha": "2d7b7dc6e9b58b7662ac6b50fa6dc3e8f6b469f4", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -127,14 +127,14 @@ pub enum TypeVariants<'tcx> {\n     /// `&a mut T` or `&'a T`.\n     TyRef(&'tcx Region, TypeAndMut<'tcx>),\n \n-    /// If the def-id is Some(_), then this is the type of a specific\n-    /// fn item. Otherwise, if None(_), it is a fn pointer type.\n-    ///\n-    /// FIXME: Conflating function pointers and the type of a\n-    /// function is probably a terrible idea; a function pointer is a\n-    /// value with a specific type, but a function can be polymorphic\n-    /// or dynamically dispatched.\n-    TyBareFn(Option<DefId>, &'tcx BareFnTy<'tcx>),\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type.\n+    TyFnDef(DefId, &'tcx Substs<'tcx>, &'tcx BareFnTy<'tcx>),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    /// FIXME: This is currently also used to represent the callee of a method;\n+    /// see ty::MethodCallee etc.\n+    TyFnPtr(&'tcx BareFnTy<'tcx>),\n \n     /// A trait, defined with `trait`.\n     TyTrait(Box<TraitTy<'tcx>>),\n@@ -1029,7 +1029,7 @@ impl<'tcx> TyS<'tcx> {\n         match self.sty {\n             TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n             TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n-            TyBareFn(..) | TyRawPtr(_) => true,\n+            TyFnDef(..) | TyFnPtr(_) | TyRawPtr(_) => true,\n             _ => false\n         }\n     }\n@@ -1080,20 +1080,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_bare_fn(&self) -> bool {\n-        match self.sty {\n-            TyBareFn(..) => true,\n-            _ => false\n-        }\n-    }\n-\n-    pub fn is_bare_fn_item(&self) -> bool {\n-        match self.sty {\n-            TyBareFn(Some(_), _) => true,\n-            _ => false\n-        }\n-    }\n-\n     pub fn is_fp(&self) -> bool {\n         match self.sty {\n             TyInfer(FloatVar(_)) | TyFloat(_) => true,\n@@ -1154,15 +1140,15 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n         match self.sty {\n-            TyBareFn(_, ref f) => &f.sig,\n+            TyFnDef(_, _, ref f) | TyFnPtr(ref f) => &f.sig,\n             _ => panic!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n \n     /// Returns the ABI of the given function.\n     pub fn fn_abi(&self) -> abi::Abi {\n         match self.sty {\n-            TyBareFn(_, ref f) => f.abi,\n+            TyFnDef(_, _, ref f) | TyFnPtr(ref f) => f.abi,\n             _ => panic!(\"Ty::fn_abi() called on non-fn type\"),\n         }\n     }\n@@ -1178,7 +1164,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_fn(&self) -> bool {\n         match self.sty {\n-            TyBareFn(..) => true,\n+            TyFnDef(..) | TyFnPtr(_) => true,\n             _ => false\n         }\n     }\n@@ -1224,7 +1210,8 @@ impl<'tcx> TyS<'tcx> {\n             TyProjection(ref data) => {\n                 data.trait_ref.substs.regions().as_slice().to_vec()\n             }\n-            TyBareFn(..) |\n+            TyFnDef(..) |\n+            TyFnPtr(_) |\n             TyBool |\n             TyChar |\n             TyInt(_) |"}, {"sha": "2b83aaccdc46bba7fa554266b9b27864723765ac", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -514,9 +514,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                         region(state, *r);\n                         mt(state, m);\n                     }\n-                    TyBareFn(opt_def_id, ref b) => {\n+                    TyFnDef(def_id, _, _) => {\n                         byte!(14);\n-                        hash!(opt_def_id);\n+                        hash!(def_id);\n+                    }\n+                    TyFnPtr(ref b) => {\n+                        byte!(15);\n                         hash!(b.unsafety);\n                         hash!(b.abi);\n                         fn_sig(state, &b.sig);\n@@ -599,14 +602,14 @@ impl<'tcx> TyCtxt<'tcx> {\n #[derive(Debug)]\n pub struct ImplMethod<'tcx> {\n     pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub is_provided: bool\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n     pub fn get_impl_method(&self,\n                            impl_def_id: DefId,\n-                           substs: Substs<'tcx>,\n+                           substs: &'tcx Substs<'tcx>,\n                            name: Name)\n                            -> ImplMethod<'tcx>\n     {\n@@ -633,9 +636,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                 if meth.name == name {\n                     let impl_to_trait_substs = self\n                         .make_substs_for_receiver_types(&trait_ref, meth);\n+                    let substs = impl_to_trait_substs.subst(self, substs);\n                     return ImplMethod {\n                         method: meth.clone(),\n-                        substs: impl_to_trait_substs.subst(self, &substs),\n+                        substs: self.mk_substs(substs),\n                         is_provided: true\n                     }\n                 }\n@@ -677,7 +681,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         // Fast-path for primitive types\n         let result = match self.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyBareFn(..) | TyRef(_, TypeAndMut {\n+            TyRawPtr(..) | TyFnDef(..) | TyFnPtr(_) | TyRef(_, TypeAndMut {\n                 mutbl: hir::MutImmutable, ..\n             }) => Some(false),\n \n@@ -719,7 +723,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         // Fast-path for primitive types\n         let result = match self.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyBareFn(..) |\n+            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyTuple(..) | TyClosure(..) => Some(true),\n \n             TyStr | TyTrait(..) | TySlice(_) => Some(false),"}, {"sha": "b6d93ecf78b888fea8e8793cd02852c470030690", "filename": "src/librustc/middle/ty/walk.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fwalk.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -98,7 +98,11 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         ty::TyTuple(ref ts) => {\n             push_reversed(stack, ts);\n         }\n-        ty::TyBareFn(_, ref ft) => {\n+        ty::TyFnDef(_, substs, ref ft) => {\n+            push_reversed(stack, substs.types.as_slice());\n+            push_sig_subtypes(stack, &ft.sig);\n+        }\n+        ty::TyFnPtr(ref ft) => {\n             push_sig_subtypes(stack, &ft.sig);\n         }\n     }"}, {"sha": "5f81d27a1f688b23cbe06c24cecc1cf42d821c1b", "filename": "src/librustc/middle/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -354,8 +354,8 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                     // WFedness.)\n                 }\n \n-                ty::TyBareFn(..) => {\n-                    // let the loop iterator into the argument/return\n+                ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                    // let the loop iterate into the argument/return\n                     // types appearing in the fn signature\n                 }\n "}, {"sha": "4556611df594b3dbf533a484adc78ac3a1eea115", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -861,20 +861,10 @@ impl<'tcx> Debug for TypedConstVal<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum ItemKind {\n-    Constant,\n-    /// This is any sort of callable (usually those that have a type of `fn(\u2026) -> \u2026`). This\n-    /// includes functions, constructors, but not methods which have their own ItemKind.\n-    Function,\n-    Method,\n-}\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,\n-        kind: ItemKind,\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {"}, {"sha": "8fd784cbde7a7e0cc8f05fe46c435e4d3fae93e1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -13,7 +13,7 @@ use middle::def_id::DefId;\n use middle::subst::{self, Subst};\n use middle::ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n-use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n+use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use middle::ty::TyClosure;\n use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n@@ -812,7 +812,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n                 write!(f, \")\")\n             }\n-            TyBareFn(opt_def_id, ref bare_fn) => {\n+            TyFnDef(def_id, substs, ref bare_fn) => {\n                 if bare_fn.unsafety == hir::Unsafety::Unsafe {\n                     try!(write!(f, \"unsafe \"));\n                 }\n@@ -822,13 +822,30 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n \n                 try!(write!(f, \"{}\", bare_fn.sig.0));\n+                try!(ty::tls::with(|tcx| {\n+                    write!(f, \" {{{}\", tcx.item_path_str(def_id))\n+                }));\n+\n+                let tps = substs.types.get_slice(subst::FnSpace);\n+                if tps.len() >= 1 {\n+                    try!(write!(f, \"::<{}\", tps[0]));\n+                    for &ty in &tps[1..] {\n+                        try!(write!(f, \", {}\", ty));\n+                    }\n+                    try!(write!(f, \">\"));\n+                }\n+                write!(f, \"}}\")\n+            }\n+            TyFnPtr(ref bare_fn) => {\n+                if bare_fn.unsafety == hir::Unsafety::Unsafe {\n+                    try!(write!(f, \"unsafe \"));\n+                }\n \n-                if let Some(def_id) = opt_def_id {\n-                    try!(write!(f, \" {{{}}}\", ty::tls::with(|tcx| {\n-                        tcx.item_path_str(def_id)\n-                    })));\n+                if bare_fn.abi != Abi::Rust {\n+                    try!(write!(f, \"extern {} \", bare_fn.abi));\n                 }\n-                Ok(())\n+\n+                write!(f, \"{}\", bare_fn.sig.0)\n             }\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),"}, {"sha": "3cab9cfb88ca90758bf3d89437cb01a881fbe6cd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -261,16 +261,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n-        self.infcx.tcx.mk_fn(None,\n-                             self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n-                                 unsafety: hir::Unsafety::Normal,\n-                                 abi: Abi::Rust,\n-                                 sig: ty::Binder(ty::FnSig {\n-                                     inputs: input_args,\n-                                     output: ty::FnConverging(output_ty),\n-                                     variadic: false,\n-                                 }),\n-                             }))\n+        self.infcx.tcx.mk_fn_ptr(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Normal,\n+            abi: Abi::Rust,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: input_args,\n+                output: ty::FnConverging(output_ty),\n+                variadic: false,\n+            }),\n+        })\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {"}, {"sha": "0c906f8eb546c2fd68da66c513d8d9532a37b708", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -1065,7 +1065,7 @@ impl LateLintPass for MutableTransmutes {\n                 }\n                 let typ = cx.tcx.node_id_to_type(expr.id);\n                 match typ.sty {\n-                    ty::TyBareFn(_, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n+                    ty::TyFnDef(_, _, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         if let ty::FnConverging(to) = bare_fn.sig.0.output {\n                             let from = bare_fn.sig.0.inputs[0];\n                             return Some((&from.sty, &to.sty));\n@@ -1079,7 +1079,7 @@ impl LateLintPass for MutableTransmutes {\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n             match cx.tcx.lookup_item_type(def_id).ty.sty {\n-                ty::TyBareFn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n+                ty::TyFnDef(_, _, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n             }\n             cx.tcx.with_path(def_id, |path| match path.last() {"}, {"sha": "e47f67dad8fcf6d1efb88b3574e50467057cfec4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -171,6 +171,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"RFC 218 <https://github.com/rust-lang/rfcs/blob/\\\n                         master/text/0218-empty-struct-with-braces.md>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(TRANSMUTE_FROM_FN_ITEM_TYPES),\n+            reference: \"issue #19925 <https://github.com/rust-lang/rust/issues/19925>\",\n+        },\n         ]);\n \n     // We have one lint pass defined specially"}, {"sha": "10535549ceb7715f8d9818bcecd8bd5b0240d8a6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -391,7 +391,7 @@ fn is_repr_nullable_ptr<'tcx>(tcx: &TyCtxt<'tcx>,\n \n         if def.variants[data_idx].fields.len() == 1 {\n             match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::TyBareFn(None, _) => { return true; }\n+                ty::TyFnPtr(_) => { return true; }\n                 ty::TyRef(..) => { return true; }\n                 _ => { }\n             }\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 self.check_type_for_ffi(cache, ty)\n             }\n \n-            ty::TyBareFn(None, bare_fn) => {\n+            ty::TyFnPtr(bare_fn) => {\n                 match bare_fn.abi {\n                     Abi::Rust |\n                     Abi::RustIntrinsic |\n@@ -595,7 +595,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n             ty::TyClosure(..) | ty::TyProjection(..) |\n-            ty::TyBareFn(Some(_), _) => {\n+            ty::TyFnDef(..) => {\n                 panic!(\"Unexpected type in foreign function\")\n             }\n         }"}, {"sha": "06f81a17a061c774b3744ea95b28ad16c4721d87", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -472,7 +472,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                    variant.name,\n                    ctor_ty);\n             let field_tys = match ctor_ty.sty {\n-                ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+                ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n                     ref inputs, ..\n                 }), ..}) => {\n                     // tuple-struct constructors don't have escaping regions\n@@ -992,7 +992,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n             let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n-                ty::TyBareFn(_, fty) => fty.clone(),\n+                ty::TyFnDef(_, _, fty) => fty.clone(),\n                 _ => tcx.sess.bug(&format!(\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name))\n@@ -1586,7 +1586,8 @@ pub fn is_extern_item(cdata: Cmd, id: DefIndex, tcx: &TyCtxt) -> bool {\n             let ty::TypeScheme { generics, ty } = get_type(cdata, id, tcx);\n             let no_generics = generics.types.is_empty();\n             match ty.sty {\n-                ty::TyBareFn(_, fn_ty) if fn_ty.abi != Abi::Rust => return no_generics,\n+                ty::TyFnDef(_, _, fn_ty) | ty::TyFnPtr(fn_ty)\n+                    if fn_ty.abi != Abi::Rust => return no_generics,\n                 _ => no_generics,\n             }\n         },"}, {"sha": "e9b23eb0458560e0ca378a33b47558b7fd6a4f4a", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -380,10 +380,11 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'F' => {\n                 let def_id = self.parse_def();\n-                return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n+                let substs = self.tcx.mk_substs(self.parse_substs());\n+                return tcx.mk_fn_def(def_id, substs, self.parse_bare_fn_ty());\n             }\n             'G' => {\n-                return tcx.mk_fn(None, tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n+                return tcx.mk_fn_ptr(self.parse_bare_fn_ty());\n             }\n             '#' => {\n                 // This is a hacky little caching scheme. The idea is that if we encode"}, {"sha": "a6601e591ab67ecc720097fa4db103a7ade8989c", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -135,12 +135,13 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyStr => {\n             write!(w, \"v\");\n         }\n-        ty::TyBareFn(Some(def_id), f) => {\n+        ty::TyFnDef(def_id, substs, f) => {\n             write!(w, \"F\");\n             write!(w, \"{}|\", (cx.ds)(def_id));\n+            enc_substs(w, cx, substs);\n             enc_bare_fn_ty(w, cx, f);\n         }\n-        ty::TyBareFn(None, f) => {\n+        ty::TyFnPtr(f) => {\n             write!(w, \"G\");\n             enc_bare_fn_ty(w, cx, f);\n         }"}, {"sha": "a7f4a53b022e1f3b33c972397b7252899b70abfe", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -239,7 +239,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n             ExprKind::Call { ty, fun, args } => {\n                 let diverges = match ty.sty {\n-                    ty::TyBareFn(_, ref f) => f.sig.0.output.diverges(),\n+                    ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n+                        f.sig.0.output.diverges()\n+                    }\n                     _ => false\n                 };\n                 let fun = unpack!(block = this.as_operand(block, fun));"}, {"sha": "8c435b45daeff14953d8e049184d75049f68dad8", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -12,7 +12,6 @@\n //! kind of thing.\n \n use build::Builder;\n-use hair::*;\n use rustc::middle::ty::Ty;\n use rustc::mir::repr::*;\n use std::u32;\n@@ -59,16 +58,4 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             });\n         temp\n     }\n-\n-    pub fn item_ref_operand(&mut self,\n-                            span: Span,\n-                            item_ref: ItemRef<'tcx>)\n-                            -> Operand<'tcx> {\n-        let literal = Literal::Item {\n-            def_id: item_ref.def_id,\n-            kind: item_ref.kind,\n-            substs: item_ref.substs,\n-        };\n-        self.literal_operand(span, item_ref.ty, literal)\n-    }\n }"}, {"sha": "3d14ad2374bb43e1fdff70b97d652fc3ee12e972", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -503,7 +503,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ty: self.hir.tcx().lookup_item_type(funcdid).ty,\n             literal: Literal::Item {\n                 def_id: funcdid,\n-                kind: ItemKind::Function,\n                 substs: self.hir.tcx().mk_substs(Substs::empty())\n             }\n         }\n@@ -641,7 +640,6 @@ fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n             ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n             literal: Literal::Item {\n                 def_id: free_func,\n-                kind: ItemKind::Function,\n                 substs: substs\n             }\n         }),"}, {"sha": "cbd6bed81a68fcfd7f53e337d84d4fa245de2ed4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     let method = method_callee(cx, self, ty::MethodCall::expr(self.id));\n \n                     let sig = match method.ty.sty {\n-                        ty::TyBareFn(_, fn_ty) => &fn_ty.sig,\n+                        ty::TyFnDef(_, _, fn_ty) => &fn_ty.sig,\n                         _ => cx.tcx.sess.span_bug(self.span, \"type of method is not an fn\")\n                     };\n \n@@ -581,7 +581,6 @@ fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n         kind: ExprKind::Literal {\n             literal: Literal::Item {\n                 def_id: callee.def_id,\n-                kind: ItemKind::Method,\n                 substs: callee.substs,\n             },\n         },\n@@ -618,14 +617,13 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n-    let (def_id, kind) = match def {\n+    let def_id = match def {\n         // A regular function.\n-        Def::Fn(def_id) => (def_id, ItemKind::Function),\n-        Def::Method(def_id) => (def_id, ItemKind::Method),\n+        Def::Fn(def_id) | Def::Method(def_id) => def_id,\n         Def::Struct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A tuple-struct constructor. Should only be reached if not called in the same\n             // expression.\n-            ty::TyBareFn(..) => (def_id, ItemKind::Function),\n+            ty::TyFnDef(..) => def_id,\n             // A unit struct which is used as a value. We return a completely different ExprKind\n             // here to account for this special case.\n             ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n@@ -640,7 +638,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         Def::Variant(enum_id, variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A variant constructor. Should only be reached if not called in the same\n             // expression.\n-            ty::TyBareFn(..) => (variant_id, ItemKind::Function),\n+            ty::TyFnDef(..) => variant_id,\n             // A unit variant, similar special case to the struct case above.\n             ty::TyEnum(adt_def, substs) => {\n                 debug_assert!(adt_def.did == enum_id);\n@@ -660,7 +658,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n             if let Some(v) = cx.try_const_eval_literal(expr) {\n                 return ExprKind::Literal { literal: v };\n             } else {\n-                (def_id, ItemKind::Constant)\n+                def_id\n             }\n         }\n \n@@ -677,7 +675,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n                 &format!(\"def `{:?}` not yet implemented\", def)),\n     };\n     ExprKind::Literal {\n-        literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n+        literal: Literal::Item { def_id: def_id, substs: substs }\n     }\n }\n "}, {"sha": "6a22dce7af9d262f985ac78fe03e4681e0c9673d", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -14,7 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp, ItemKind,\n+use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp,\n     TypedConstVal};\n use rustc::middle::const_eval::ConstVal;\n use rustc::middle::def_id::DefId;\n@@ -28,14 +28,6 @@ use self::cx::Cx;\n \n pub mod cx;\n \n-#[derive(Clone, Debug)]\n-pub struct ItemRef<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub kind: ItemKind,\n-    pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub extent: CodeExtent,"}, {"sha": "e021300f1b3978b61f87d6ee679e17c4df0de08a", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let func_ty = mir.operand_ty(tcx, func);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let func_ty = match func_ty.sty {\n-                    ty::TyBareFn(_, func_ty) => func_ty,\n+                    ty::TyFnDef(_, _, func_ty) | ty::TyFnPtr(func_ty) => func_ty,\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;"}, {"sha": "3a39a3c6dd1947ecb18c1feb08144e98114f85c6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -582,7 +582,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(Def::Struct(..)) => {\n-                    if let ty::TyBareFn(..) = node_ty.sty {\n+                    if let ty::TyFnDef(..) = node_ty.sty {\n                         // Count the function pointer.\n                         v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }"}, {"sha": "79ccc8fb2b21f626414c91d7ffd957c40997c518", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -856,7 +856,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 if let Def::Struct(..) = self.tcx.resolve_expr(expr) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {\n-                        ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+                        ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n                             output: ty::FnConverging(ty), ..\n                         }), ..}) => ty,\n                         _ => expr_ty"}, {"sha": "c5508a8268fe2ea80f51647ca8d40540bbb849dd", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -451,8 +451,8 @@ fn find_discr_field_candidate<'tcx>(tcx: &TyCtxt<'tcx>,\n         // Regular thin pointer: &T/&mut T/Box<T>\n         ty::TyRef(..) | ty::TyBox(..) => Some(path),\n \n-        // Functions are just pointers\n-        ty::TyBareFn(..) => Some(path),\n+        // Function pointer: `fn() -> i32`\n+        ty::TyFnPtr(_) => Some(path),\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n         ty::TyStruct(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {"}, {"sha": "98e9a1c98ad84387ef62cbef0b1890082a842901", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -50,7 +50,6 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                           expr_ty(bcx, &out.expr),\n                                           out_datum,\n                                           cleanup::CustomScope(temp_scope),\n-                                          callee::DontAutorefArg,\n                                           &mut inputs);\n             if out.is_rw {\n                 ext_inputs.push(*inputs.last().unwrap());\n@@ -64,7 +63,6 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                               expr_ty(bcx, &out.expr),\n                                               out_datum,\n                                               cleanup::CustomScope(temp_scope),\n-                                              callee::DontAutorefArg,\n                                               &mut ext_inputs);\n                 ext_constraints.push(i.to_string());\n             }\n@@ -80,7 +78,6 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     expr_ty(bcx, &input),\n                                     in_datum,\n                                     cleanup::CustomScope(temp_scope),\n-                                    callee::DontAutorefArg,\n                                     &mut inputs);\n     }\n     inputs.extend_from_slice(&ext_inputs[..]);"}, {"sha": "009d43e813ebc26cc3e8cc7ff70d9b92b07f283b", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -131,7 +131,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n \n     let function_type;\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n-        ty::TyBareFn(_, ref f) => (&f.sig, f.abi, None),\n+        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => (&f.sig, f.abi, None),\n         ty::TyClosure(closure_did, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n             function_type = infcx.closure_type(closure_did, substs);\n@@ -162,7 +162,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n-        ty::TyBareFn(..) if abi == Abi::RustCall => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) if abi == Abi::RustCall => {\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n             match fn_sig.inputs[1].sty {"}, {"sha": "5088dabfbe78ea02b86b229dd8cb7905a7f9a235", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -195,16 +195,14 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_ty: Ty<'tcx>,\n                                 name: &str,\n-                                did: DefId)\n+                                attrs: &[ast::Attribute])\n                                 -> ValueRef {\n     if let Some(n) = ccx.externs().borrow().get(name) {\n         return *n;\n     }\n \n     let f = declare::declare_rust_fn(ccx, name, fn_ty);\n-\n-    let attrs = ccx.sess().cstore.item_attrs(did);\n-    attributes::from_fn_attrs(ccx, &attrs[..], f);\n+    attributes::from_fn_attrs(ccx, &attrs, f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -390,7 +388,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\"),\n             }\n         }\n-        ty::TyBareFn(..) | ty::TyBool | ty::TyUint(_) | ty::TyChar => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyBool | ty::TyUint(_) | ty::TyChar => {\n             ICmp(bcx,\n                  bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n                  lhs,\n@@ -621,8 +619,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n-                                old_info: Option<ValueRef>,\n-                                param_substs: &'tcx Substs<'tcx>)\n+                                old_info: Option<ValueRef>)\n                                 -> ValueRef {\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n@@ -641,7 +638,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                 def_id: principal.def_id(),\n                 substs: substs,\n             });\n-            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n+            consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n                             Type::vtable_ptr(ccx))\n         }\n         _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n@@ -668,7 +665,7 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             assert!(common::type_is_sized(bcx.tcx(), a));\n             let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n             (PointerCast(bcx, src, ptr_ty),\n-             unsized_info(bcx.ccx(), a, b, None, bcx.fcx.param_substs))\n+             unsized_info(bcx.ccx(), a, b, None))\n         }\n         _ => bcx.sess().bug(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -900,29 +897,31 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     did: DefId,\n-                                     t: Ty<'tcx>)\n-                                     -> ValueRef {\n-    let name = ccx.sess().cstore.item_symbol(did);\n-    match t.sty {\n-        ty::TyBareFn(_, ref fn_ty) => {\n-            match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n-                Abi::Rust | Abi::RustCall => {\n-                    get_extern_rust_fn(ccx, t, &name[..], did)\n-                }\n+pub fn get_extern_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               def_id: DefId)\n+                               -> datum::Datum<'tcx, datum::Rvalue> {\n+    let name = ccx.sess().cstore.item_symbol(def_id);\n+    let attrs = ccx.sess().cstore.item_attrs(def_id);\n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    match ty.sty {\n+        ty::TyFnDef(_, _, fty) => {\n+            let abi = fty.abi;\n+            let fty = infer::normalize_associated_type(ccx.tcx(), fty);\n+            let ty = ccx.tcx().mk_fn_ptr(fty);\n+            let llfn = match ccx.sess().target.target.adjust_abi(abi) {\n                 Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                    ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n+                    ccx.sess().bug(\"unexpected intrinsic in get_extern_fn\")\n+                }\n+                Abi::Rust | Abi::RustCall => {\n+                    get_extern_rust_fn(ccx, ty, &name, &attrs)\n                 }\n                 _ => {\n-                    let attrs = ccx.sess().cstore.item_attrs(did);\n-                    foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name, &attrs)\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, &name, &attrs)\n                 }\n-            }\n-        }\n-        _ => {\n-            get_extern_const(ccx, did, t)\n+            };\n+            datum::immediate_rvalue(llfn, ty)\n         }\n+        _ => unreachable!(\"get_extern_fn: expected fn item type, found {}\", ty)\n     }\n }\n \n@@ -2610,7 +2609,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_id: ast::NodeId,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n-    if let ty::TyBareFn(_, ref f) = node_type.sty {\n+    if let ty::TyFnDef(_, _, ref f) = node_type.sty {\n         if f.abi != Abi::Rust && f.abi != Abi::RustCall {\n             ccx.sess().span_bug(sp,\n                                 &format!(\"only the `{}` or `{}` calling conventions are valid \\\n@@ -2685,8 +2684,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                                                                .as_local_node_id(start_def_id) {\n                     get_item_val(ccx, start_node_id)\n                 } else {\n-                    let start_fn_type = ccx.tcx().lookup_item_type(start_def_id).ty;\n-                    trans_external_path(ccx, start_def_id, start_fn_type)\n+                    get_extern_fn(ccx, start_def_id).val\n                 };\n                 let args = {\n                     let opaque_rust_main =\n@@ -2915,7 +2913,7 @@ fn register_method(ccx: &CrateContext,\n \n     let sym = exported_name(ccx, id, mty, &attrs);\n \n-    if let ty::TyBareFn(_, ref f) = mty.sty {\n+    if let ty::TyFnDef(_, _, ref f) = mty.sty {\n         let llfn = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n             register_fn(ccx, span, sym, id, mty)\n         } else {"}, {"sha": "05e5ac808d0301301723210db7ededa8ce6cf9c9", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 286, "deletions": 406, "changes": 692, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -14,15 +14,13 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-pub use self::AutorefArg::*;\n pub use self::CalleeData::*;\n pub use self::CallArgs::*;\n \n use arena::TypedArena;\n use back::link;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n-use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n@@ -32,14 +30,13 @@ use trans::adt;\n use trans::base;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n                     ExprOrMethodCall, FunctionContext, MethodCallKey};\n use trans::consts;\n use trans::datum::*;\n-use trans::debuginfo::{DebugLoc, ToDebugLoc};\n+use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n use trans::glue;\n@@ -52,177 +49,148 @@ use trans::type_::Type;\n use trans::type_of;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use middle::ty::MethodCall;\n use rustc_front::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n use syntax::errors;\n use syntax::ptr::P;\n \n-#[derive(Copy, Clone)]\n-pub struct MethodData {\n-    pub llfn: ValueRef,\n-    pub llself: ValueRef,\n-}\n-\n pub enum CalleeData<'tcx> {\n-    // Constructor for enum variant/tuple-like-struct\n-    // i.e. Some, Ok\n+    /// Constructor for enum variant/tuple-like-struct.\n     NamedTupleConstructor(Disr),\n \n-    // Represents a (possibly monomorphized) top-level fn item or method\n-    // item. Note that this is just the fn-ptr and is not a Rust closure\n-    // value (which is a pair).\n-    Fn(/* llfn */ ValueRef),\n+    /// Function pointer.\n+    Fn(ValueRef),\n \n-    Intrinsic(ast::NodeId, subst::Substs<'tcx>),\n+    Intrinsic(ast::NodeId, &'tcx subst::Substs<'tcx>),\n \n-    TraitItem(MethodData)\n+    /// Trait object found in the vtable at that index.\n+    Virtual(usize)\n }\n \n-pub struct Callee<'blk, 'tcx: 'blk> {\n-    pub bcx: Block<'blk, 'tcx>,\n+pub struct Callee<'tcx> {\n     pub data: CalleeData<'tcx>,\n     pub ty: Ty<'tcx>\n }\n \n-fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n-                     -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr={:?})\", expr);\n-\n-    // pick out special kinds of expressions that can be called:\n-    match expr.node {\n-        hir::ExprPath(..) => {\n-            return trans_def(bcx, bcx.def(expr.id), expr);\n+impl<'tcx> Callee<'tcx> {\n+    /// Function pointer.\n+    pub fn ptr(datum: Datum<'tcx, Rvalue>) -> Callee<'tcx> {\n+        Callee {\n+            data: Fn(datum.val),\n+            ty: datum.ty\n         }\n-        _ => {}\n     }\n \n-    // any other expressions are closures:\n-    return datum_callee(bcx, expr);\n-\n-    fn datum_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n-                                -> Callee<'blk, 'tcx> {\n-        let DatumBlock { bcx, datum, .. } = expr::trans(bcx, expr);\n-        match datum.ty.sty {\n-            ty::TyBareFn(..) => {\n-                Callee {\n-                    bcx: bcx,\n-                    ty: datum.ty,\n-                    data: Fn(datum.to_llscalarish(bcx))\n-                }\n-            }\n-            _ => {\n-                bcx.tcx().sess.span_bug(\n-                    expr.span,\n-                    &format!(\"type of callee is neither bare-fn nor closure: {}\",\n-                             datum.ty));\n-            }\n-        }\n+    /// Trait or impl method call.\n+    pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n+                             method_call: ty::MethodCall)\n+                             -> Callee<'tcx> {\n+        let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+        Callee::method(bcx, method)\n     }\n \n-    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, datum: Datum<'tcx, Rvalue>)\n-                             -> Callee<'blk, 'tcx> {\n-        Callee {\n-            bcx: bcx,\n-            data: Fn(datum.val),\n-            ty: datum.ty\n-        }\n+    /// Trait or impl method.\n+    pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n+                        method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n+        let substs = bcx.tcx().mk_substs(bcx.fcx.monomorphize(&method.substs));\n+        let ty = bcx.fcx.monomorphize(&method.ty);\n+        Callee::def(bcx.ccx(), method.def_id, substs, ty)\n     }\n \n-    fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             def: Def,\n-                             ref_expr: &hir::Expr)\n-                             -> Callee<'blk, 'tcx> {\n-        debug!(\"trans_def(def={:?}, ref_expr={:?})\", def, ref_expr);\n-        let expr_ty = common::node_id_type(bcx, ref_expr.id);\n-        match def {\n-            Def::Fn(did) if {\n-                let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n-                let maybe_ast_node = maybe_def_id.and_then(|def_id| {\n-                    let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n-                    bcx.tcx().map.find(node_id)\n-                });\n-                match maybe_ast_node {\n-                    Some(hir_map::NodeStructCtor(_)) => true,\n-                    _ => false\n-                }\n-            } => {\n-                Callee {\n-                    bcx: bcx,\n+    /// Function or method definition.\n+    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                   def_id: DefId,\n+                   substs: &'tcx subst::Substs<'tcx>,\n+                   ty: Ty<'tcx>)\n+                   -> Callee<'tcx> {\n+        let tcx = ccx.tcx();\n+\n+        if substs.self_ty().is_some() {\n+            // Only trait methods can have a Self parameter.\n+            let method_item = tcx.impl_or_trait_item(def_id);\n+            let trait_id = method_item.container().id();\n+            let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n+            let vtbl = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            return meth::callee_for_trait_impl(ccx, def_id, substs,\n+                                               trait_id, ty, vtbl);\n+        }\n+\n+        let maybe_node_id = inline::get_local_instance(ccx, def_id)\n+            .and_then(|def_id| tcx.map.as_local_node_id(def_id));\n+        let maybe_ast_node = maybe_node_id.and_then(|node_id| {\n+            tcx.map.find(node_id)\n+        });\n+        match maybe_ast_node {\n+            Some(hir_map::NodeStructCtor(_)) => {\n+                return Callee {\n                     data: NamedTupleConstructor(Disr(0)),\n-                    ty: expr_ty\n-                }\n-            }\n-            Def::Fn(did) if match expr_ty.sty {\n-                ty::TyBareFn(_, ref f) => f.abi == Abi::RustIntrinsic ||\n-                                          f.abi == Abi::PlatformIntrinsic,\n-                _ => false\n-            } => {\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n-                let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n-                Callee { bcx: bcx, data: Intrinsic(node_id, substs), ty: expr_ty }\n-            }\n-            Def::Fn(did) => {\n-                fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs))\n-            }\n-            Def::Method(meth_did) => {\n-                let method_item = bcx.tcx().impl_or_trait_item(meth_did);\n-                let fn_datum = match method_item.container() {\n-                    ty::ImplContainer(_) => {\n-                        trans_fn_ref(bcx.ccx(), meth_did,\n-                                     ExprId(ref_expr.id),\n-                                     bcx.fcx.param_substs)\n-                    }\n-                    ty::TraitContainer(trait_did) => {\n-                        meth::trans_static_method_callee(bcx.ccx(),\n-                                                         meth_did,\n-                                                         trait_did,\n-                                                         ref_expr.id,\n-                                                         bcx.fcx.param_substs)\n-                    }\n+                    ty: ty\n                 };\n-                fn_callee(bcx, fn_datum)\n             }\n-            Def::Variant(tid, vid) => {\n-                let vinfo = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n+            Some(hir_map::NodeVariant(_)) => {\n+                let vinfo = common::inlined_variant_def(ccx, maybe_node_id.unwrap());\n                 assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n \n-                Callee {\n-                    bcx: bcx,\n+                return Callee {\n                     data: NamedTupleConstructor(Disr::from(vinfo.disr_val)),\n-                    ty: expr_ty\n-                }\n+                    ty: ty\n+                };\n             }\n-            Def::Struct(..) => {\n-                Callee {\n-                    bcx: bcx,\n-                    data: NamedTupleConstructor(Disr(0)),\n-                    ty: expr_ty\n+            Some(hir_map::NodeForeignItem(fi)) => {\n+                let abi = tcx.map.get_foreign_abi(fi.id);\n+                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                    return Callee {\n+                        data: Intrinsic(fi.id, substs),\n+                        ty: ty\n+                    };\n                 }\n             }\n-            Def::Static(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Upvar(..) => {\n-                datum_callee(bcx, ref_expr)\n-            }\n-            Def::Mod(..) | Def::ForeignMod(..) | Def::Trait(..) |\n-            Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(..) |\n-            Def::AssociatedTy(..) | Def::Label(..) | Def::TyParam(..) |\n-            Def::SelfTy(..) | Def::Err => {\n-                bcx.tcx().sess.span_bug(\n-                    ref_expr.span,\n-                    &format!(\"cannot translate def {:?} \\\n-                             to a callable thing!\", def));\n+            _ => {}\n+        }\n+        Callee::ptr(trans_fn_ref_with_substs(ccx, def_id, Some(ty), substs))\n+    }\n+\n+    /// This behemoth of a function translates function calls. Unfortunately, in\n+    /// order to generate more efficient LLVM output at -O0, it has quite a complex\n+    /// signature (refactoring this into two functions seems like a good idea).\n+    ///\n+    /// In particular, for lang items, it is invoked with a dest of None, and in\n+    /// that case the return value contains the result of the fn. The lang item must\n+    /// not return a structural type or else all heck breaks loose.\n+    ///\n+    /// For non-lang items, `dest` is always Some, and hence the result is written\n+    /// into memory somewhere. Nonetheless we return the actual return value of the\n+    /// function.\n+    pub fn call<'a, 'blk>(self, bcx: Block<'blk, 'tcx>,\n+                          debug_loc: DebugLoc,\n+                          args: CallArgs<'a, 'tcx>,\n+                          dest: Option<expr::Dest>)\n+                          -> Result<'blk, 'tcx> {\n+        trans_call_inner(bcx, debug_loc, self, args, dest)\n+    }\n+\n+    /// Turn the callee into a function pointer.\n+    pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>)\n+                     -> Datum<'tcx, Rvalue> {\n+        match self.data {\n+            Fn(llfn) => {\n+                let fn_ptr_ty = match self.ty.sty {\n+                    ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n+                    _ => self.ty\n+                };\n+                immediate_rvalue(llfn, fn_ptr_ty)\n             }\n+            Virtual(idx) => meth::trans_object_shim(ccx, self.ty, idx),\n+            NamedTupleConstructor(_) => match self.ty.sty {\n+                ty::TyFnDef(def_id, substs, _) => {\n+                    return trans_fn_ref_with_substs(ccx, def_id, Some(self.ty), substs);\n+                }\n+                _ => unreachable!(\"expected fn item type, found {}\", self.ty)\n+            },\n+            Intrinsic(..) => unreachable!(\"intrinsic {} getting reified\", self.ty)\n         }\n     }\n }\n@@ -241,7 +209,17 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            def_id,\n            node,\n            substs);\n-    trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n+    let ref_ty = match node {\n+        ExprId(0) => return trans_fn_ref_with_substs(ccx, def_id, None, substs),\n+        ExprId(id) => ccx.tcx().node_id_to_type(id),\n+        MethodCallKey(method_call) => {\n+            ccx.tcx().tables.borrow().method_map[&method_call].ty\n+        }\n+    };\n+    let ref_ty = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                  param_substs,\n+                                                  &ref_ty);\n+    trans_fn_ref_with_substs(ccx, def_id, Some(ref_ty), substs)\n }\n \n /// Translates an adapter that implements the `Fn` trait for a fn\n@@ -290,33 +268,33 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (opt_def_id, sig) =\n-        match bare_fn_ty.sty {\n-            ty::TyBareFn(opt_def_id,\n-                           &ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n-                                           abi: Abi::Rust,\n-                                           ref sig }) => {\n-                (opt_def_id, sig)\n-            }\n+    let sig = match bare_fn_ty.sty {\n+        ty::TyFnDef(_, _,\n+                    &ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n+                                    abi: Abi::Rust,\n+                                    ref sig }) |\n+        ty::TyFnPtr(&ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n+                                    abi: Abi::Rust,\n+                                    ref sig }) => sig,\n \n-            _ => {\n-                tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                      bare_fn_ty));\n-            }\n-        };\n+        _ => {\n+            tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                                    bare_fn_ty));\n+        }\n+    };\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n-    let tuple_fn_ty = tcx.mk_fn(opt_def_id,\n-        tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Normal,\n-            abi: Abi::RustCall,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: vec![bare_fn_ty_maybe_ref,\n-                             tuple_input_ty],\n-                output: sig.output,\n-                variadic: false\n-            })}));\n+    let tuple_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+        unsafety: hir::Unsafety::Normal,\n+        abi: Abi::RustCall,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: vec![bare_fn_ty_maybe_ref,\n+                         tuple_input_ty],\n+            output: sig.output,\n+            variadic: false\n+        })\n+    });\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n@@ -341,11 +319,18 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llargs = get_params(fcx.llfn);\n \n     let self_idx = fcx.arg_offset();\n-    // the first argument (`self`) will be ptr to the fn pointer\n-    let llfnpointer = if is_by_ref {\n-        Load(bcx, llargs[self_idx])\n-    } else {\n-        llargs[self_idx]\n+    let llfnpointer = match bare_fn_ty.sty {\n+        ty::TyFnDef(def_id, substs, _) => {\n+            // Function definitions have to be turned into a pointer.\n+            Callee::def(ccx, def_id, substs, bare_fn_ty).reify(ccx).val\n+        }\n+\n+        // the first argument (`self`) will be ptr to the fn pointer\n+        _ => if is_by_ref {\n+            Load(bcx, llargs[self_idx])\n+        } else {\n+            llargs[self_idx]\n+        }\n     };\n \n     assert!(!fcx.needs_ret_allocas);\n@@ -354,13 +339,11 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n-    bcx = trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n-        Callee {\n-            bcx: bcx,\n-            data: Fn(llfnpointer),\n-            ty: bare_fn_ty\n-        }\n-    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n+    let callee = Callee {\n+        data: Fn(llfnpointer),\n+        ty: bare_fn_ty\n+    };\n+    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n@@ -379,30 +362,25 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n /// - `node`: node id of the reference to the fn/method, if applicable.\n ///   This parameter may be zero; but, if so, the resulting value may not\n ///   have the right type, so it must be cast before being used.\n-/// - `param_substs`: if the `node` is in a polymorphic function, these\n-///   are the substitutions required to monomorphize its type\n+/// - `ref_ty`: monotype of the reference to the fn/method, if applicable.\n+///   This parameter may be None; but, if so, the resulting value may not\n+///   have the right type, so it must be cast before being used.\n /// - `substs`: values for each of the fn/method's parameters\n pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     def_id: DefId,\n-    node: ExprOrMethodCall,\n-    param_substs: &'tcx subst::Substs<'tcx>,\n-    substs: subst::Substs<'tcx>)\n+    ref_ty: Option<Ty<'tcx>>,\n+    substs: &'tcx subst::Substs<'tcx>)\n     -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={:?}, node={:?}, \\\n-            param_substs={:?}, substs={:?})\",\n-           def_id,\n-           node,\n-           param_substs,\n-           substs);\n+    debug!(\"trans_fn_ref_with_substs(def_id={:?}, ref_ty={:?}, substs={:?})\",\n+           def_id, ref_ty, substs);\n \n     assert!(!substs.types.needs_infer());\n     assert!(!substs.types.has_escaping_regions());\n-    let substs = substs.erase_regions();\n \n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n@@ -437,48 +415,45 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, LOCAL_CRATE);\n \n-        let opt_ref_id = match node {\n-            ExprId(id) => if id != 0 { Some(id) } else { None },\n-            MethodCallKey(_) => None,\n+        let substs = tcx.mk_substs(substs.clone().erase_regions());\n+        let (mut val, fn_ty, must_cast) =\n+            monomorphize::monomorphic_fn(ccx, def_id, substs);\n+        let fn_ty = ref_ty.unwrap_or(fn_ty);\n+        let fn_ptr_ty = match fn_ty.sty {\n+            ty::TyFnDef(_, _, fty) => {\n+                // Create a fn pointer with the substituted signature.\n+                tcx.mk_ty(ty::TyFnPtr(fty))\n+            }\n+            _ => unreachable!(\"expected fn item type, found {}\", fn_ty)\n         };\n-\n-        let substs = tcx.mk_substs(substs);\n-        let (val, fn_ty, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, substs, opt_ref_id);\n-        if must_cast && node != ExprId(0) {\n-            // Monotype of the REFERENCE to the function (type params\n-            // are subst'd)\n-            let ref_ty = match node {\n-                ExprId(id) => tcx.node_id_to_type(id),\n-                MethodCallKey(method_call) => {\n-                    tcx.tables.borrow().method_map[&method_call].ty\n-                }\n-            };\n-            let ref_ty = monomorphize::apply_param_substs(tcx,\n-                                                          param_substs,\n-                                                          &ref_ty);\n-            let llptrty = type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to();\n+        if must_cast && ref_ty.is_some() {\n+            let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n             if llptrty != common::val_ty(val) {\n-                let val = consts::ptrcast(val, llptrty);\n-                return Datum::new(val, ref_ty, Rvalue::new(ByValue));\n+                val = consts::ptrcast(val, llptrty);\n             }\n         }\n-        return Datum::new(val, fn_ty, Rvalue::new(ByValue));\n+        return immediate_rvalue(val, fn_ptr_ty);\n     }\n \n-    // Type scheme of the function item (may have type params)\n-    let fn_type_scheme = tcx.lookup_item_type(def_id);\n-    let fn_type = infer::normalize_associated_type(tcx, &fn_type_scheme.ty);\n-\n     // Find the actual function pointer.\n-    let mut val = {\n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n-            // Internal reference.\n-            get_item_val(ccx, node_id)\n-        } else {\n-            // External reference.\n-            trans_external_path(ccx, def_id, fn_type)\n-        }\n+    let local_node = ccx.tcx().map.as_local_node_id(def_id);\n+    let mut datum = if let Some(node_id) = local_node {\n+        // Type scheme of the function item (may have type params)\n+        let fn_type_scheme = tcx.lookup_item_type(def_id);\n+        let fn_type = match fn_type_scheme.ty.sty {\n+            ty::TyFnDef(_, _, fty) => {\n+                // Create a fn pointer with the normalized signature.\n+                tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n+            }\n+            _ => unreachable!(\"expected fn item type, found {}\",\n+                              fn_type_scheme.ty)\n+        };\n+\n+        // Internal reference.\n+        immediate_rvalue(get_item_val(ccx, node_id), fn_type)\n+    } else {\n+        // External reference.\n+        get_extern_fn(ccx, def_id)\n     };\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n@@ -504,93 +479,36 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, fn_type);\n-    let llptrty = llty.ptr_to();\n-    if common::val_ty(val) != llptrty {\n+    let llptrty = type_of::type_of(ccx, datum.ty);\n+    if common::val_ty(datum.val) != llptrty {\n         debug!(\"trans_fn_ref_with_substs(): casting pointer!\");\n-        val = consts::ptrcast(val, llptrty);\n+        datum.val = consts::ptrcast(datum.val, llptrty);\n     } else {\n         debug!(\"trans_fn_ref_with_substs(): not casting pointer!\");\n     }\n \n-    Datum::new(val, fn_type, Rvalue::new(ByValue))\n+    datum\n }\n \n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  call_expr: &hir::Expr,\n-                                  f: &hir::Expr,\n-                                  args: CallArgs<'a, 'tcx>,\n-                                  dest: expr::Dest)\n-                                  -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_call\");\n-    trans_call_inner(bcx,\n-                     call_expr.debug_loc(),\n-                     |bcx, _| trans(bcx, f),\n-                     args,\n-                     Some(dest)).bcx\n-}\n-\n-pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                         call_expr: &hir::Expr,\n-                                         rcvr: &hir::Expr,\n-                                         args: CallArgs<'a, 'tcx>,\n-                                         dest: expr::Dest)\n-                                         -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n-    let method_call = MethodCall::expr(call_expr.id);\n-    trans_call_inner(\n-        bcx,\n-        call_expr.debug_loc(),\n-        |cx, arg_cleanup_scope| {\n-            meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n-        },\n-        args,\n-        Some(dest)).bcx\n-}\n-\n pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    did: DefId,\n                                    args: &[ValueRef],\n                                    dest: Option<expr::Dest>,\n                                    debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n-    callee::trans_call_inner(bcx, debug_loc, |bcx, _| {\n-        let datum = trans_fn_ref_with_substs(bcx.ccx(),\n-                                             did,\n-                                             ExprId(0),\n-                                             bcx.fcx.param_substs,\n-                                             subst::Substs::trans_empty());\n-        Callee {\n-            bcx: bcx,\n-            data: Fn(datum.val),\n-            ty: datum.ty\n-        }\n-    }, ArgVals(args), dest)\n+    let datum = trans_fn_ref(bcx.ccx(), did, ExprId(0), bcx.fcx.param_substs);\n+    Callee::ptr(datum).call(bcx, debug_loc, ArgVals(args), dest)\n }\n \n-/// This behemoth of a function translates function calls. Unfortunately, in\n-/// order to generate more efficient LLVM output at -O0, it has quite a complex\n-/// signature (refactoring this into two functions seems like a good idea).\n-///\n-/// In particular, for lang items, it is invoked with a dest of None, and in\n-/// that case the return value contains the result of the fn. The lang item must\n-/// not return a structural type or else all heck breaks loose.\n-///\n-/// For non-lang items, `dest` is always Some, and hence the result is written\n-/// into memory somewhere. Nonetheless we return the actual return value of the\n-/// function.\n-pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           debug_loc: DebugLoc,\n-                                           get_callee: F,\n-                                           args: CallArgs<'a, 'tcx>,\n-                                           dest: Option<expr::Dest>)\n-                                           -> Result<'blk, 'tcx> where\n-    F: FnOnce(Block<'blk, 'tcx>, cleanup::ScopeId) -> Callee<'blk, 'tcx>,\n-{\n+fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                    debug_loc: DebugLoc,\n+                                    callee: Callee<'tcx>,\n+                                    args: CallArgs<'a, 'tcx>,\n+                                    dest: Option<expr::Dest>)\n+                                    -> Result<'blk, 'tcx> {\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n     // this cleanup is to ensure that, should a panic occur while\n@@ -600,27 +518,17 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     // scope will ever execute.\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n-    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n-\n-    let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n-    let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee.ty.sty {\n-        ty::TyBareFn(_, ref f) => {\n+        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n             let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n             let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n             (f.abi, sig.output)\n         }\n-        _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n+        _ => panic!(\"expected fn item or ptr in Callee::call\")\n     };\n \n-    let (llfn, llself) = match callee.data {\n-        Fn(llfn) => {\n-            (llfn, None)\n-        }\n-        TraitItem(d) => {\n-            (d.llfn, Some(d.llself))\n-        }\n+    match callee.data {\n         Intrinsic(node, substs) => {\n             assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n             assert!(dest.is_some());\n@@ -632,14 +540,15 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n+            let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n             return intrinsic::trans_intrinsic_call(bcx, node, callee.ty,\n                                                    arg_cleanup_scope, args,\n-                                                   dest.unwrap(), substs,\n+                                                   dest.unwrap(),\n+                                                   substs,\n                                                    call_info);\n         }\n         NamedTupleConstructor(disr) => {\n             assert!(dest.is_some());\n-            fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n             return base::trans_named_tuple_constructor(bcx,\n                                                        callee.ty,\n@@ -648,7 +557,8 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        dest.unwrap(),\n                                                        debug_loc);\n         }\n-    };\n+        _ => {}\n+    }\n \n     // Intrinsics should not become actual functions.\n     // We trans them in place in `trans_intrinsic_call`\n@@ -688,6 +598,8 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n     };\n \n+    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n+\n     // The code below invokes the function, using either the Rust\n     // conventions (if it is a rust fn) or the native conventions\n     // (otherwise).  The important part is that, when all is said\n@@ -711,27 +623,33 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        // Push a trait object's self.\n-        if let Some(llself) = llself {\n-            llargs.push(llself);\n-        }\n+        let arg_start = llargs.len();\n \n         // Push the arguments.\n         bcx = trans_args(bcx,\n                          args,\n                          callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n-                         llself.is_some(),\n                          abi);\n \n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n+        let datum = match callee.data {\n+            Fn(f) => immediate_rvalue(f, callee.ty),\n+            Virtual(idx) => {\n+                // The data and vtable pointers were split by trans_arg_datum.\n+                let vtable = llargs.remove(arg_start + 1);\n+                meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n+            }\n+            _ => unreachable!()\n+        };\n+\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n-                                      llfn,\n+                                      datum.val,\n                                       &llargs[..],\n-                                      callee.ty,\n+                                      datum.ty,\n                                       debug_loc);\n         bcx = b;\n         llresult = llret;\n@@ -754,16 +672,17 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         assert!(dest.is_some());\n \n         let mut llargs = Vec::new();\n-        let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect(),\n-            _ => panic!(\"expected arg exprs.\")\n+        let (llfn, arg_tys) = match (callee.data, &args) {\n+            (Fn(f), &ArgExprs(a)) => {\n+                (f, a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect())\n+            }\n+            _ => panic!(\"expected fn ptr and arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n                          args,\n                          callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n-                         false,\n                          abi);\n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n@@ -800,23 +719,22 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n pub enum CallArgs<'a, 'tcx> {\n-    // Supply value of arguments as a list of expressions that must be\n-    // translated. This is used in the common case of `foo(bar, qux)`.\n+    /// Supply value of arguments as a list of expressions that must be\n+    /// translated. This is used in the common case of `foo(bar, qux)`.\n     ArgExprs(&'a [P<hir::Expr>]),\n \n-    // Supply value of arguments as a list of LLVM value refs; frequently\n-    // used with lang items and so forth, when the argument is an internal\n-    // value.\n+    /// Supply value of arguments as a list of LLVM value refs; frequently\n+    /// used with lang items and so forth, when the argument is an internal\n+    /// value.\n     ArgVals(&'a [ValueRef]),\n \n-    // For overloaded operators: `(lhs, Option(rhs, rhs_id), autoref)`. `lhs`\n-    // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n-    // the right-hand-side argument (if any). `autoref` indicates whether the `rhs`\n-    // arguments should be auto-referenced\n-    ArgOverloadedOp(Datum<'tcx, Expr>, Option<(Datum<'tcx, Expr>, ast::NodeId)>, bool),\n+    /// For overloaded operators: `(lhs, Option(rhs))`.\n+    /// `lhs` is the left-hand-side and `rhs` is the datum\n+    /// of the right-hand-side argument (if any).\n+    ArgOverloadedOp(Datum<'tcx, Expr>, Option<Datum<'tcx, Expr>>),\n \n-    // Supply value of arguments as a list of expressions that must be\n-    // translated, for overloaded call operators.\n+    /// Supply value of arguments as a list of expressions that must be\n+    /// translated, for overloaded call operators.\n     ArgOverloadedCall(Vec<&'a hir::Expr>),\n }\n \n@@ -825,24 +743,20 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              arg_exprs: &[P<hir::Expr>],\n                              fn_ty: Ty<'tcx>,\n                              llargs: &mut Vec<ValueRef>,\n-                             arg_cleanup_scope: cleanup::ScopeId,\n-                             ignore_self: bool)\n+                             arg_cleanup_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx>\n {\n     let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n     let args = sig.inputs;\n \n     // Translate the `self` argument first.\n-    if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n-        bcx = trans_arg_datum(bcx,\n-                              args[0],\n-                              arg_datum,\n-                              arg_cleanup_scope,\n-                              DontAutorefArg,\n-                              llargs);\n-    }\n+    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n+    bcx = trans_arg_datum(bcx,\n+                          args[0],\n+                          arg_datum,\n+                          arg_cleanup_scope,\n+                          llargs);\n \n     // Now untuple the rest of the arguments.\n     let tuple_expr = &arg_exprs[1];\n@@ -870,7 +784,6 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                                       field_type,\n                                       arg_datum,\n                                       arg_cleanup_scope,\n-                                      DontAutorefArg,\n                                       llargs);\n             }\n         }\n@@ -888,23 +801,19 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               arg_exprs: Vec<&hir::Expr>,\n                               fn_ty: Ty<'tcx>,\n                               llargs: &mut Vec<ValueRef>,\n-                              arg_cleanup_scope: cleanup::ScopeId,\n-                              ignore_self: bool)\n+                              arg_cleanup_scope: cleanup::ScopeId)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n     let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n     let arg_tys = sig.inputs;\n \n-    if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n-        bcx = trans_arg_datum(bcx,\n-                              arg_tys[0],\n-                              arg_datum,\n-                              arg_cleanup_scope,\n-                              DontAutorefArg,\n-                              llargs);\n-    }\n+    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n+    bcx = trans_arg_datum(bcx,\n+                          arg_tys[0],\n+                          arg_datum,\n+                          arg_cleanup_scope,\n+                          llargs);\n \n     // Now untuple the rest of the arguments.\n     let tuple_type = arg_tys[1];\n@@ -917,7 +826,6 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                                       field_type,\n                                       arg_datum,\n                                       arg_cleanup_scope,\n-                                      DontAutorefArg,\n                                       llargs);\n             }\n         }\n@@ -935,7 +843,6 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                   fn_ty: Ty<'tcx>,\n                                   llargs: &mut Vec<ValueRef>,\n                                   arg_cleanup_scope: cleanup::ScopeId,\n-                                  ignore_self: bool,\n                                   abi: Abi)\n                                   -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n@@ -960,15 +867,11 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                                  arg_exprs,\n                                                  fn_ty,\n                                                  llargs,\n-                                                 arg_cleanup_scope,\n-                                                 ignore_self)\n+                                                 arg_cleanup_scope)\n             }\n \n             let num_formal_args = arg_tys.len();\n             for (i, arg_expr) in arg_exprs.iter().enumerate() {\n-                if i == 0 && ignore_self {\n-                    continue;\n-                }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n                     common::expr_ty_adjusted(cx, &arg_expr)\n@@ -979,7 +882,6 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n                 bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n                                       arg_cleanup_scope,\n-                                      DontAutorefArg,\n                                       llargs);\n             }\n         }\n@@ -988,22 +890,19 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                               arg_exprs,\n                                               fn_ty,\n                                               llargs,\n-                                              arg_cleanup_scope,\n-                                              ignore_self)\n+                                              arg_cleanup_scope)\n         }\n-        ArgOverloadedOp(lhs, rhs, autoref) => {\n+        ArgOverloadedOp(lhs, rhs) => {\n             assert!(!variadic);\n \n             bcx = trans_arg_datum(bcx, arg_tys[0], lhs,\n                                   arg_cleanup_scope,\n-                                  DontAutorefArg,\n                                   llargs);\n \n-            if let Some((rhs, rhs_id)) = rhs {\n+            if let Some(rhs) = rhs {\n                 assert_eq!(arg_tys.len(), 2);\n                 bcx = trans_arg_datum(bcx, arg_tys[1], rhs,\n                                       arg_cleanup_scope,\n-                                      if autoref { DoAutorefArg(rhs_id) } else { DontAutorefArg },\n                                       llargs);\n             } else {\n                 assert_eq!(arg_tys.len(), 1);\n@@ -1017,17 +916,10 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-#[derive(Copy, Clone)]\n-pub enum AutorefArg {\n-    DontAutorefArg,\n-    DoAutorefArg(ast::NodeId)\n-}\n-\n pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    formal_arg_ty: Ty<'tcx>,\n                                    arg_datum: Datum<'tcx, Expr>,\n                                    arg_cleanup_scope: cleanup::ScopeId,\n-                                   autoref_arg: AutorefArg,\n                                    llargs: &mut Vec<ValueRef>)\n                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n@@ -1041,37 +933,25 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debug!(\"   arg datum: {}\", arg_datum.to_string(bcx.ccx()));\n \n-    let mut val;\n-    // FIXME(#3548) use the adjustments table\n-    match autoref_arg {\n-        DoAutorefArg(arg_id) => {\n-            // We will pass argument by reference\n-            // We want an lvalue, so that we can pass by reference and\n-            let arg_datum = unpack_datum!(\n-                bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n-            val = arg_datum.val;\n-        }\n-        DontAutorefArg if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n-                !bcx.fcx.type_needs_drop(arg_datum_ty) => {\n-            val = arg_datum.val\n-        }\n-        DontAutorefArg => {\n-            // Make this an rvalue, since we are going to be\n-            // passing ownership.\n-            let arg_datum = unpack_datum!(\n-                bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n-\n-            // Now that arg_datum is owned, get it into the appropriate\n-            // mode (ref vs value).\n-            let arg_datum = unpack_datum!(\n-                bcx, arg_datum.to_appropriate_datum(bcx));\n-\n-            // Technically, ownership of val passes to the callee.\n-            // However, we must cleanup should we panic before the\n-            // callee is actually invoked.\n-            val = arg_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n-        }\n-    }\n+    let mut val = if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n+                     !bcx.fcx.type_needs_drop(arg_datum_ty) {\n+        arg_datum.val\n+    } else {\n+        // Make this an rvalue, since we are going to be\n+        // passing ownership.\n+        let arg_datum = unpack_datum!(\n+            bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n+\n+        // Now that arg_datum is owned, get it into the appropriate\n+        // mode (ref vs value).\n+        let arg_datum = unpack_datum!(\n+            bcx, arg_datum.to_appropriate_datum(bcx));\n+\n+        // Technically, ownership of val passes to the callee.\n+        // However, we must cleanup should we panic before the\n+        // callee is actually invoked.\n+        arg_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n+    };\n \n     if type_of::arg_is_indirect(ccx, formal_arg_ty) && formal_arg_ty != arg_datum_ty {\n         // this could happen due to e.g. subtyping"}, {"sha": "95ca250e8444525f812696a08731ee10780a6252", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -17,7 +17,7 @@ use trans::adt;\n use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n+use trans::callee::{self, ArgVals, Callee};\n use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue};\n@@ -271,24 +271,8 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n-    let closure_kind = ccx.tcx().closure_kind(closure_def_id);\n-    trans_closure_adapter_shim(ccx,\n-                               closure_def_id,\n-                               substs,\n-                               closure_kind,\n-                               trait_closure_kind,\n-                               llfn)\n-}\n+    let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n \n-fn trans_closure_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    llfn_closure_kind: ty::ClosureKind,\n-    trait_closure_kind: ty::ClosureKind,\n-    llfn: ValueRef)\n-    -> ValueRef\n-{\n     let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n     let tcx = ccx.tcx();\n \n@@ -355,42 +339,45 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Make a version with the type of by-ref closure.\n     let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, &substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n-    let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n-                                                               abi: abi,\n-                                                               sig: sig.clone() });\n-    let llref_fn_ty = tcx.mk_fn(None, llref_bare_fn_ty);\n+    let llref_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: sig.clone()\n+    });\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n+    let ret_ty = tcx.erase_late_bound_regions(&sig.output());\n+    let ret_ty = infer::normalize_associated_type(ccx.tcx(), &ret_ty);\n+\n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n     assert_eq!(abi, RustCall);\n     sig.0.inputs[0] = closure_ty;\n-    let llonce_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n-                                                                abi: abi,\n-                                                                sig: sig });\n-    let llonce_fn_ty = tcx.mk_fn(None, llonce_bare_fn_ty);\n+    let llonce_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: sig\n+    });\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n     let lloncefn = declare::define_internal_rust_fn(ccx, &function_name,\n                                                     llonce_fn_ty);\n-    let sig = tcx.erase_late_bound_regions(&llonce_bare_fn_ty.sig);\n-    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       lloncefn,\n                       ast::DUMMY_NODE_ID,\n                       false,\n-                      sig.output,\n+                      ret_ty,\n                       substs.func_substs,\n                       None,\n                       &block_arena);\n-    let mut bcx = init_function(&fcx, false, sig.output);\n+    let mut bcx = init_function(&fcx, false, ret_ty);\n \n-    let llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(fcx.llfn);\n \n     // the first argument (`self`) will be the (by value) closure env.\n     let self_scope = fcx.push_custom_cleanup_scope();\n@@ -405,25 +392,21 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n            bcx.val_to_string(env_datum.val));\n+    llargs[self_idx] = env_datum.val;\n \n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n-\n-    let callee_data = TraitItem(MethodData { llfn: llreffn,\n-                                             llself: env_datum.val });\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n \n-    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n-        Callee {\n-            bcx: bcx,\n-            data: callee_data,\n-            ty: llref_fn_ty\n-        }\n-    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n+    let callee = Callee {\n+        data: callee::Fn(llreffn),\n+        ty: llref_fn_ty\n+    };\n+    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n \n-    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+    finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n \n     lloncefn\n }"}, {"sha": "abfd127f38860d9ff4026fbf813423cbc01d17ce", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -542,14 +542,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting operand {:?}\", *operand);\n \n         let callee = match *operand {\n-            mir::Operand::Constant(mir::Constant {\n-                literal: mir::Literal::Item {\n-                    def_id,\n-                    kind,\n-                    substs\n-                },\n-                ..\n-            }) if is_function_or_method(kind) => Some((def_id, substs)),\n+            mir::Operand::Constant(mir::Constant { ty: &ty::TyS {\n+                sty: ty::TyFnDef(def_id, substs, _), ..\n+            }, .. }) => Some((def_id, substs)),\n             _ => None\n         };\n \n@@ -588,25 +583,18 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_operand(operand);\n \n-        fn is_function_or_method(item_kind: mir::ItemKind) -> bool {\n-            match item_kind {\n-                mir::ItemKind::Constant => false,\n-                mir::ItemKind::Function |\n-                mir::ItemKind::Method   => true\n-            }\n-        }\n-\n         fn can_result_in_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n             if !match ccx.tcx().lookup_item_type(def_id).ty.sty {\n-                ty::TyBareFn(Some(def_id), _) => {\n-                    // Some constructors also have type TyBareFn but they are\n+                ty::TyFnDef(def_id, _, _) => {\n+                    // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n-                    // translation item.\n+                    // translation item. Same for FFI functions.\n                     match ccx.tcx().map.get_if_local(def_id) {\n                         Some(hir_map::NodeVariant(_))    |\n-                        Some(hir_map::NodeStructCtor(_)) => false,\n+                        Some(hir_map::NodeStructCtor(_)) |\n+                        Some(hir_map::NodeForeignItem(_)) => false,\n                         Some(_) => true,\n                         None => {\n                             ccx.sess().cstore.variant_kind(def_id).is_none()\n@@ -689,25 +677,26 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         if can_have_local_instance(ccx, destructor_did) {\n             let trans_item = create_fn_trans_item(ccx,\n                                                   destructor_did,\n-                                                  ccx.tcx().mk_substs(substs),\n+                                                  substs,\n                                                   &Substs::trans_empty());\n             output.push(trans_item);\n         }\n     }\n \n     // Finally add the types of nested values\n     match ty.sty {\n-        ty::TyBool       |\n-        ty::TyChar       |\n-        ty::TyInt(_)     |\n-        ty::TyUint(_)    |\n-        ty::TyStr        |\n-        ty::TyFloat(_)   |\n-        ty::TyRawPtr(_)  |\n-        ty::TyRef(..)    |\n-        ty::TyBareFn(..) |\n-        ty::TySlice(_)   |\n-        ty::TyTrait(_)   => {\n+        ty::TyBool      |\n+        ty::TyChar      |\n+        ty::TyInt(_)    |\n+        ty::TyUint(_)   |\n+        ty::TyStr       |\n+        ty::TyFloat(_)  |\n+        ty::TyRawPtr(_) |\n+        ty::TyRef(..)   |\n+        ty::TyFnDef(..) |\n+        ty::TyFnPtr(_)  |\n+        ty::TySlice(_)  |\n+        ty::TyTrait(_)  => {\n             /* nothing to do */\n         }\n         ty::TyStruct(ref adt_def, substs) |\n@@ -831,9 +820,9 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         {\n             let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n             let impl_method = tcx.get_impl_method(impl_did,\n-                                                  callee_substs,\n+                                                  tcx.mk_substs(callee_substs),\n                                                   trait_method.name);\n-            Some((impl_method.method.def_id, tcx.mk_substs(impl_method.substs)))\n+            Some((impl_method.method.def_id, impl_method.substs))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n         // the concrete closure/function somewhere else (during closure or fn\n@@ -991,10 +980,9 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                         // create translation items\n                         .filter_map(|impl_method| {\n                             if can_have_local_instance(ccx, impl_method.method.def_id) {\n-                                let substs = ccx.tcx().mk_substs(impl_method.substs);\n                                 Some(create_fn_trans_item(ccx,\n                                                           impl_method.method.def_id,\n-                                                          substs,\n+                                                          impl_method.substs,\n                                                           &Substs::trans_empty()))\n                             } else {\n                                 None\n@@ -1173,12 +1161,12 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n                     let mth = tcx.get_impl_method(impl_def_id,\n-                                                  callee_substs.clone(),\n+                                                  callee_substs,\n                                                   default_impl.name);\n \n                     assert!(mth.is_provided);\n \n-                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n+                    let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n                     if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                         continue;\n                     }\n@@ -1289,7 +1277,8 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              &trait_data.bounds.projection_bounds,\n                              output);\n         },\n-        ty::TyBareFn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "34ef4f4acec5e4d763eaa6b19f530f6081256bed", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -1228,7 +1228,7 @@ pub enum ExprOrMethodCall {\n pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 node: ExprOrMethodCall,\n                                 param_substs: &subst::Substs<'tcx>)\n-                                -> subst::Substs<'tcx> {\n+                                -> &'tcx subst::Substs<'tcx> {\n     let tcx = ccx.tcx();\n \n     let substs = match node {\n@@ -1245,9 +1245,9 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               node, substs));\n     }\n \n-    monomorphize::apply_param_substs(tcx,\n-                                     param_substs,\n-                                     &substs.erase_regions())\n+    ccx.tcx().mk_substs(monomorphize::apply_param_substs(tcx,\n+                                                         param_substs,\n+                                                         &substs.erase_regions()))\n }\n \n pub fn langcall(bcx: Block,\n@@ -1277,7 +1277,7 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n            inlined_vid);\n     let adt_def = match ctor_ty.sty {\n-        ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+        ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n             output: ty::FnConverging(ty), ..\n         }), ..}) => ty,\n         _ => ctor_ty"}, {"sha": "6c47cab64effe7f2a2ec1111e7a4e620ff8086ae", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -28,6 +28,7 @@ use middle::def::Def;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n+use trans::callee::Callee;\n use trans::collector::{self, TransItem};\n use trans::common::{self, type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n@@ -211,7 +212,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let arg_ids = args.iter().map(|arg| arg.pat.id);\n     let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n \n-    let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n+    let substs = node_id_substs(ccx, node, param_substs);\n     match fn_like.body().expr {\n         Some(ref expr) => {\n             const_expr(ccx, &expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n@@ -355,8 +356,16 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n         Some(AdjustReifyFnPointer) => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to do something here\n+            match ety.sty {\n+                ty::TyFnDef(def_id, substs, _) => {\n+                    let datum = Callee::def(cx, def_id, substs, ety).reify(cx);\n+                    llconst = datum.val;\n+                    ety_adjusted = datum.ty;\n+                }\n+                _ => {\n+                    unreachable!(\"{} cannot be reified to a fn ptr\", ety)\n+                }\n+            }\n         }\n         Some(AdjustUnsafeFnPointer) | Some(AdjustMutToConstPointer) => {\n             // purely a type-level thing\n@@ -413,8 +422,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     .expect(\"consts: unsizing got non-pointer target type\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                 let base = ptrcast(base, ptr_ty);\n-                let info = base::unsized_info(cx, pointee_ty, unsized_ty,\n-                                              old_info, param_substs);\n+                let info = base::unsized_info(cx, pointee_ty, unsized_ty, old_info);\n \n                 if old_info.is_none() {\n                     let prev_const = cx.const_unsized().borrow_mut()\n@@ -894,9 +902,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         cx.sess().span_bug(e.span, \"const fn argument not found\")\n                     }\n                 }\n-                Def::Fn(..) | Def::Method(..) => {\n-                    expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                }\n+                Def::Fn(..) | Def::Method(..) => C_nil(cx),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     load_const(cx, try!(get_const_val(cx, def_id, e, param_substs)),\n                                ety)\n@@ -908,23 +914,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             let repr = adt::represent_type(cx, ety);\n                             adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])\n                         }\n-                        ty::VariantKind::Tuple => {\n-                            expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                        }\n+                        ty::VariantKind::Tuple => C_nil(cx),\n                         ty::VariantKind::Struct => {\n                             cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n                         }\n                     }\n                 }\n-                Def::Struct(..) => {\n-                    if let ty::TyBareFn(..) = ety.sty {\n-                        // Tuple struct.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                    } else {\n-                        // Unit struct.\n-                        C_null(type_of::type_of(cx, ety))\n-                    }\n-                }\n+                // Unit struct or ctor.\n+                Def::Struct(..) => C_null(type_of::type_of(cx, ety)),\n                 _ => {\n                     cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\\n                                                 or variant def\")"}, {"sha": "0cd1f4e7fbf3e184dda828212ac17ec4bf06d19a", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -253,7 +253,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                        principal.substs,\n                                        &mut unique_type_id);\n             },\n-            ty::TyBareFn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n                 if unsafety == hir::Unsafety::Unsafe {\n                     unique_type_id.push_str(\"unsafe \");\n                 }\n@@ -765,7 +766,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::TyBareFn(_, ref barefnty) => {\n+        ty::TyFnDef(_, _, ref barefnty) | ty::TyFnPtr(ref barefnty) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n                                                        &barefnty.sig,"}, {"sha": "15275a46e9b7773e2e122bbf70d2f9a047666df9", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -430,7 +430,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let fn_type = monomorphize::apply_param_substs(cx.tcx(), param_substs, &fn_type);\n \n         let (sig, abi) = match fn_type.sty {\n-            ty::TyBareFn(_, ref barefnty) => {\n+            ty::TyFnDef(_, _, ref barefnty) | ty::TyFnPtr(ref barefnty) => {\n                 let sig = cx.tcx().erase_late_bound_regions(&barefnty.sig);\n                 let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n                 (sig, barefnty.abi)"}, {"sha": "cc9067677b25b3cc3370d390b20c3c2be85e8c04", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -101,7 +101,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_item_name(cx, principal.def_id, false, output);\n             push_type_params(cx, principal.substs, output);\n         },\n-        ty::TyBareFn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "38e456c068829ee6b9add7189ec8cebbfbd3e8db", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -106,7 +106,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n \n     let function_type; // placeholder so that the memory ownership works out ok\n     let (sig, abi, env) = match fn_type.sty {\n-        ty::TyBareFn(_, ref f) => {\n+        ty::TyFnDef(_, _, f) |\n+        ty::TyFnPtr(f) => {\n             (&f.sig, f.abi, None)\n         }\n         ty::TyClosure(closure_did, ref substs) => {"}, {"sha": "ae03f58bce0cf81d01bd1edc69eb479203ce82a9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 107, "deletions": 203, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -56,17 +56,17 @@ use llvm::{self, ValueRef, TypeKind};\n use middle::const_qualif::ConstQualif;\n use middle::def::Def;\n use middle::subst::Substs;\n-use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n+use trans::{_match, adt, asm, base, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n+use trans::callee::{Callee, ArgExprs, ArgOverloadedCall, ArgOverloadedOp};\n use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::datum::*;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::declare;\n use trans::glue;\n use trans::machine;\n-use trans::meth;\n use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n@@ -85,7 +85,6 @@ use rustc_front::hir;\n \n use syntax::{ast, codemap};\n use syntax::parse::token::InternedString;\n-use syntax::ptr::P;\n use std::mem;\n \n // Destinations\n@@ -349,11 +348,7 @@ fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     match adjustment {\n-        AdjustReifyFnPointer => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to return true here\n-            false\n-        }\n+        AdjustReifyFnPointer => true,\n         AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n             false\n@@ -388,8 +383,15 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            adjustment);\n     match adjustment {\n         AdjustReifyFnPointer => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to do something here\n+            match datum.ty.sty {\n+                ty::TyFnDef(def_id, substs, _) => {\n+                    datum = Callee::def(bcx.ccx(), def_id, substs, datum.ty)\n+                        .reify(bcx.ccx()).to_expr_datum();\n+                }\n+                _ => {\n+                    unreachable!(\"{} cannot be reified to a fn ptr\", datum.ty)\n+                }\n+            }\n         }\n         AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n@@ -492,8 +494,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 (val, None)\n             };\n \n-            let info = unsized_info(bcx.ccx(), inner_source, inner_target,\n-                                    old_info, bcx.fcx.param_substs);\n+            let info = unsized_info(bcx.ccx(), inner_source, inner_target, old_info);\n \n             // Compute the base pointer. This doesn't change the pointer value,\n             // but merely its type.\n@@ -785,15 +786,10 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let index_expr_debug_loc = index_expr.debug_loc();\n \n     // Check for overloaded index.\n-    let method_ty = ccx.tcx()\n-                       .tables\n-                       .borrow()\n-                       .method_map\n-                       .get(&method_call)\n-                       .map(|method| method.ty);\n-    let elt_datum = match method_ty {\n-        Some(method_ty) => {\n-            let method_ty = monomorphize_type(bcx, method_ty);\n+    let method = ccx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n+    let elt_datum = match method {\n+        Some(method) => {\n+            let method_ty = monomorphize_type(bcx, method.ty);\n \n             let base_datum = unpack_datum!(bcx, trans(bcx, base));\n \n@@ -811,19 +807,16 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(elt_tm) => elt_tm.ty,\n             };\n \n-            // Overloaded. Evaluate `trans_overloaded_op`, which will\n-            // invoke the user's index() method, which basically yields\n-            // a `&T` pointer.  We can then proceed down the normal\n-            // path (below) to dereference that `&T`.\n+            // Overloaded. Invoke the index() method, which basically\n+            // yields a `&T` pointer.  We can then proceed down the\n+            // normal path (below) to dereference that `&T`.\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_index_elt\");\n-            unpack_result!(bcx,\n-                           trans_overloaded_op(bcx,\n-                                               index_expr,\n-                                               method_call,\n-                                               base_datum,\n-                                               Some((ix_datum, idx.id)),\n-                                               Some(SaveIn(scratch.val)),\n-                                               false));\n+\n+            bcx = Callee::method(bcx, method)\n+                .call(bcx, index_expr_debug_loc,\n+                      ArgOverloadedOp(base_datum, Some(ix_datum)),\n+                      Some(SaveIn(scratch.val))).bcx;\n+\n             let datum = scratch.to_expr_datum();\n             let lval = Lvalue::new(\"expr::trans_index overload\");\n             if type_is_sized(bcx.tcx(), elt_ty) {\n@@ -899,24 +892,18 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        Def::Fn(..) | Def::Method(..) |\n-        Def::Struct(..) | Def::Variant(..) => {\n-            let datum = trans_def_fn_unadjusted(bcx.ccx(), ref_expr, def,\n-                                                bcx.fcx.param_substs);\n-            DatumBlock::new(bcx, datum.to_expr_datum())\n-        }\n         Def::Static(did, _) => {\n             let const_ty = expr_ty(bcx, ref_expr);\n             let val = get_static_val(bcx.ccx(), did, const_ty);\n             let lval = Lvalue::new(\"expr::trans_def\");\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n         }\n-        Def::Const(_) | Def::AssociatedConst(_) => {\n-            bcx.sess().span_bug(ref_expr.span,\n-                \"constant expression should not reach expr::trans_def\")\n+        Def::Local(..) | Def::Upvar(..) => {\n+            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n         }\n         _ => {\n-            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n+            bcx.sess().span_bug(ref_expr.span,\n+                &format!(\"{:?} should not reach expr::trans_def\", def))\n         }\n     }\n }\n@@ -1024,17 +1011,18 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         hir::ExprAssignOp(op, ref dst, ref src) => {\n-            let has_method_map = bcx.tcx()\n-                                    .tables\n-                                    .borrow()\n-                                    .method_map\n-                                    .contains_key(&MethodCall::expr(expr.id));\n+            let method = bcx.tcx().tables\n+                                  .borrow()\n+                                  .method_map\n+                                  .get(&MethodCall::expr(expr.id)).cloned();\n \n-            if has_method_map {\n+            if let Some(method) = method {\n                 let dst = unpack_datum!(bcx, trans(bcx, &dst));\n                 let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n-                trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), dst,\n-                                    Some((src_datum, src.id)), None, false).bcx\n+\n+                Callee::method(bcx, method)\n+                    .call(bcx, expr.debug_loc(),\n+                          ArgOverloadedOp(dst, Some(src_datum)), None).bcx\n             } else {\n                 trans_assign_op(bcx, expr, op, &dst, &src)\n             }\n@@ -1061,6 +1049,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n+    // Entry into the method table if this is an overloaded call/op.\n+    let method_call = MethodCall::expr(expr.id);\n+\n     match expr.node {\n         hir::ExprType(ref e, _) => {\n             trans_into(bcx, &e, dest)\n@@ -1144,47 +1135,54 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         &expr.attrs).unwrap_or(bcx)\n         }\n         hir::ExprCall(ref f, ref args) => {\n-            if bcx.tcx().is_method_call(expr.id) {\n-                trans_overloaded_call(bcx,\n-                                      expr,\n-                                      &f,\n-                                      &args[..],\n-                                      Some(dest))\n+            let method = bcx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n+            let (callee, args) = if let Some(method) = method {\n+                let mut all_args = vec![&**f];\n+                all_args.extend(args.iter().map(|e| &**e));\n+\n+                (Callee::method(bcx, method), ArgOverloadedCall(all_args))\n             } else {\n-                callee::trans_call(bcx,\n-                                   expr,\n-                                   &f,\n-                                   callee::ArgExprs(&args[..]),\n-                                   dest)\n-            }\n+                let f = unpack_datum!(bcx, trans(bcx, f));\n+                (match f.ty.sty {\n+                    ty::TyFnDef(def_id, substs, _) => {\n+                        Callee::def(bcx.ccx(), def_id, substs, f.ty)\n+                    }\n+                    ty::TyFnPtr(_) => {\n+                        let f = unpack_datum!(bcx,\n+                            f.to_rvalue_datum(bcx, \"callee\"));\n+                        Callee::ptr(f)\n+                    }\n+                    _ => {\n+                        bcx.tcx().sess.span_bug(expr.span,\n+                            &format!(\"type of callee is not a fn: {}\", f.ty));\n+                    }\n+                }, ArgExprs(&args))\n+            };\n+            callee.call(bcx, expr.debug_loc(), args, Some(dest)).bcx\n         }\n         hir::ExprMethodCall(_, _, ref args) => {\n-            callee::trans_method_call(bcx,\n-                                      expr,\n-                                      &args[0],\n-                                      callee::ArgExprs(&args[..]),\n-                                      dest)\n+            Callee::method_call(bcx, method_call)\n+                .call(bcx, expr.debug_loc(), ArgExprs(&args), Some(dest)).bcx\n         }\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprBinary(op, ref lhs, ref rhs_expr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let lhs = unpack_datum!(bcx, trans(bcx, &lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, &rhs));\n-            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n-                                Some((rhs_datum, rhs.id)), Some(dest),\n-                                !rustc_front::util::is_by_value_binop(op.node)).bcx\n+            let mut rhs = unpack_datum!(bcx, trans(bcx, &rhs_expr));\n+            if !rustc_front::util::is_by_value_binop(op.node) {\n+                rhs = unpack_datum!(bcx, auto_ref(bcx, rhs, rhs_expr));\n+            }\n+\n+            Callee::method_call(bcx, method_call)\n+                .call(bcx, expr.debug_loc(),\n+                      ArgOverloadedOp(lhs, Some(rhs)), Some(dest)).bcx\n         }\n-        hir::ExprUnary(op, ref subexpr) => {\n+        hir::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let arg = unpack_datum!(bcx, trans(bcx, &subexpr));\n-            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n-                                arg, None, Some(dest), !rustc_front::util::is_by_value_unop(op)).bcx\n-        }\n-        hir::ExprIndex(ref base, ref idx) => {\n-            // if not overloaded, would be RvalueDatumExpr\n-            let base = unpack_datum!(bcx, trans(bcx, &base));\n-            let idx_datum = unpack_datum!(bcx, trans(bcx, &idx));\n-            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n-                                Some((idx_datum, idx.id)), Some(dest), true).bcx\n+\n+            Callee::method_call(bcx, method_call)\n+                .call(bcx, expr.debug_loc(),\n+                      ArgOverloadedOp(arg, None), Some(dest)).bcx\n         }\n         hir::ExprCast(..) => {\n             // Trait casts used to come this way, now they should be coercions.\n@@ -1218,26 +1216,22 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Ignore => { return bcx; }\n     };\n \n+    let ty = expr_ty(bcx, ref_expr);\n+    if let ty::TyFnDef(..) = ty.sty {\n+        // Zero-sized function or ctor.\n+        return bcx;\n+    }\n+\n     match def {\n         Def::Variant(tid, vid) => {\n             let variant = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n-            if let ty::VariantKind::Tuple = variant.kind() {\n-                // N-ary variant.\n-                let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n-                                                ExprId(ref_expr.id),\n-                                                bcx.fcx.param_substs).val;\n-                Store(bcx, llfn, lldest);\n-                return bcx;\n-            } else {\n-                // Nullary variant.\n-                let ty = expr_ty(bcx, ref_expr);\n-                let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n-                return bcx;\n-            }\n+            // Nullary variant.\n+            let ty = expr_ty(bcx, ref_expr);\n+            let repr = adt::represent_type(bcx.ccx(), ty);\n+            adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n+            bcx\n         }\n         Def::Struct(..) => {\n-            let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n                 ty::TyStruct(def, _) if def.has_dtor() => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n@@ -1255,41 +1249,6 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                         ref_expr: &hir::Expr,\n-                                         def: Def,\n-                                         param_substs: &'tcx Substs<'tcx>)\n-                                         -> Datum<'tcx, Rvalue> {\n-    let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n-\n-    match def {\n-        Def::Fn(did) |\n-        Def::Struct(did) | Def::Variant(_, did) => {\n-            callee::trans_fn_ref(ccx, did, ExprId(ref_expr.id), param_substs)\n-        }\n-        Def::Method(method_did) => {\n-            match ccx.tcx().impl_or_trait_item(method_did).container() {\n-                ty::ImplContainer(_) => {\n-                    callee::trans_fn_ref(ccx, method_did,\n-                                         ExprId(ref_expr.id),\n-                                         param_substs)\n-                }\n-                ty::TraitContainer(trait_did) => {\n-                    meth::trans_static_method_callee(ccx, method_did,\n-                                                     trait_did, ref_expr.id,\n-                                                     param_substs)\n-                }\n-            }\n-        }\n-        _ => {\n-            ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n-                    \"trans_def_fn_unadjusted invoked on: {:?} for {:?}\",\n-                    def,\n-                    ref_expr));\n-        }\n-    }\n-}\n-\n /// Translates a reference to a local variable or argument. This always results in an lvalue datum.\n pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    def: Def)\n@@ -1898,51 +1857,6 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   expr: &hir::Expr,\n-                                   method_call: MethodCall,\n-                                   lhs: Datum<'tcx, Expr>,\n-                                   rhs: Option<(Datum<'tcx, Expr>, ast::NodeId)>,\n-                                   dest: Option<Dest>,\n-                                   autoref: bool)\n-                                   -> Result<'blk, 'tcx> {\n-    callee::trans_call_inner(bcx,\n-                             expr.debug_loc(),\n-                             |bcx, arg_cleanup_scope| {\n-                                meth::trans_method_callee(bcx,\n-                                                          method_call,\n-                                                          None,\n-                                                          arg_cleanup_scope)\n-                             },\n-                             callee::ArgOverloadedOp(lhs, rhs, autoref),\n-                             dest)\n-}\n-\n-fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                         expr: &hir::Expr,\n-                                         callee: &'a hir::Expr,\n-                                         args: &'a [P<hir::Expr>],\n-                                         dest: Option<Dest>)\n-                                         -> Block<'blk, 'tcx> {\n-    debug!(\"trans_overloaded_call {}\", expr.id);\n-    let method_call = MethodCall::expr(expr.id);\n-    let mut all_args = vec!(callee);\n-    all_args.extend(args.iter().map(|e| &**e));\n-    unpack_result!(bcx,\n-                   callee::trans_call_inner(bcx,\n-                                            expr.debug_loc(),\n-                                            |bcx, arg_cleanup_scope| {\n-                                                meth::trans_method_callee(\n-                                                    bcx,\n-                                                    method_call,\n-                                                    None,\n-                                                    arg_cleanup_scope)\n-                                            },\n-                                            callee::ArgOverloadedCall(all_args),\n-                                            dest));\n-    bcx\n-}\n-\n pub fn cast_is_noop<'tcx>(tcx: &TyCtxt<'tcx>,\n                           expr: &hir::Expr,\n                           t_in: Ty<'tcx>,\n@@ -2179,18 +2093,12 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_ty = ccx.tcx()\n-                       .tables\n-                       .borrow()\n-                       .method_map\n-                       .get(&method_call).map(|method| method.ty);\n-\n-    let datum = match method_ty {\n-        Some(method_ty) => {\n-            let method_ty = monomorphize_type(bcx, method_ty);\n-\n-            // Overloaded. Evaluate `trans_overloaded_op`, which will\n-            // invoke the user's deref() method, which basically\n+    let method = ccx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n+    let datum = match method {\n+        Some(method) => {\n+            let method_ty = monomorphize_type(bcx, method.ty);\n+\n+            // Overloaded. Invoke the deref() method, which basically\n             // converts from the `Smaht<T>` pointer that we have into\n             // a `&T` pointer.  We can then proceed down the normal\n             // path (below) to dereference that `&T`.\n@@ -2205,9 +2113,10 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n-            unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n-                                                    datum, None, Some(SaveIn(scratch.val)),\n-                                                    false));\n+            bcx = Callee::method(bcx, method)\n+                .call(bcx, expr.debug_loc(),\n+                      ArgOverloadedOp(datum, None),\n+                      Some(SaveIn(scratch.val))).bcx;\n             scratch.to_expr_datum()\n         }\n         None => {\n@@ -2524,18 +2433,13 @@ fn expr_kind(tcx: &TyCtxt, expr: &hir::Expr) -> ExprKind {\n     match expr.node {\n         hir::ExprPath(..) => {\n             match tcx.resolve_expr(expr) {\n-                Def::Struct(..) | Def::Variant(..) => {\n-                    if let ty::TyBareFn(..) = tcx.node_id_to_type(expr.id).sty {\n-                        // ctor function\n-                        ExprKind::RvalueDatum\n-                    } else {\n-                        ExprKind::RvalueDps\n-                    }\n+                // Put functions and ctors with the ADTs, as they\n+                // are zero-sized, so DPS is the cheapest option.\n+                Def::Struct(..) | Def::Variant(..) |\n+                Def::Fn(..) | Def::Method(..) => {\n+                    ExprKind::RvalueDps\n                 }\n \n-                // Fn pointers are just scalar values.\n-                Def::Fn(..) | Def::Method(..) => ExprKind::RvalueDatum,\n-\n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues."}, {"sha": "cace98a230f61a00c406b13c3e4f94d989abd597", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -262,7 +262,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::TyBareFn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n+        ty::TyFnDef(_, _, ref fn_ty) |\n+        ty::TyFnPtr(ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n@@ -501,7 +502,8 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n-                        ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &decl, bft),\n+                        ty::TyFnDef(_, _, bft) |\n+                        ty::TyFnPtr(bft) => gate_simd_ffi(ccx.tcx(), &decl, bft),\n                         _ => ccx.tcx().sess.span_bug(foreign_item.span,\n                                                      \"foreign fn's sty isn't a bare_fn_ty?\")\n                     }\n@@ -552,7 +554,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tys = foreign_types_for_fn_ty(ccx, t);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let cconv = match t.sty {\n-        ty::TyBareFn(_, ref fn_ty) => {\n+        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n@@ -574,7 +576,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n     let t = ccx.tcx().node_id_to_type(node_id);\n     let cconv = match t.sty {\n-        ty::TyBareFn(_, ref fn_ty) => {\n+        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n@@ -634,7 +636,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n-            ty::TyBareFn(_, ref f) => {\n+            ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f)=> {\n                 assert!(f.abi != Abi::Rust);\n                 assert!(f.abi != Abi::RustIntrinsic);\n                 assert!(f.abi != Abi::PlatformIntrinsic);\n@@ -957,7 +959,7 @@ fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty.sty {\n-        ty::TyBareFn(_, ref fn_ty) => &fn_ty.sig,\n+        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => &fn_ty.sig,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);"}, {"sha": "d5f8cff495600397c853f0cf9e65c5933441350b", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -356,27 +356,18 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         &unsized_args\n     };\n \n-    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n-        let trait_ref = ty::Binder(ty::TraitRef {\n-            def_id: tcx.lang_items.drop_trait().unwrap(),\n-            substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n-        });\n-        let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n-            traits::VtableImpl(data) => data,\n-            _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n-        };\n-        let dtor_did = def.destructor().unwrap();\n-        let datum = callee::trans_fn_ref_with_substs(bcx.ccx(),\n-                                                     dtor_did,\n-                                                     ExprId(0),\n-                                                     bcx.fcx.param_substs,\n-                                                     vtbl.substs);\n-        callee::Callee {\n-            bcx: bcx,\n-            data: callee::Fn(datum.val),\n-            ty: datum.ty\n-        }\n-    }, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n+    let trait_ref = ty::Binder(ty::TraitRef {\n+        def_id: tcx.lang_items.drop_trait().unwrap(),\n+        substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n+    });\n+    let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n+        traits::VtableImpl(data) => data,\n+        _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n+    };\n+    let dtor_did = def.destructor().unwrap();\n+    bcx = callee::Callee::ptr(callee::trans_fn_ref_with_substs(\n+            bcx.ccx(), dtor_did, None, vtbl.substs))\n+        .call(bcx, DebugLoc::None, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }"}, {"sha": "96c1d6a4d691a4ba74a0dea7cb2e3fb15268498f", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -22,7 +22,7 @@ use trans::adt;\n use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee;\n+use trans::callee::{self, Callee};\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n@@ -45,6 +45,7 @@ use syntax::ast;\n use syntax::ptr::P;\n use syntax::parse::token;\n \n+use rustc::lint;\n use rustc::session::Session;\n use syntax::codemap::Span;\n \n@@ -125,29 +126,41 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                                                transmute_restriction.substituted_to);\n         let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n         let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n+\n+        if let ty::TyFnDef(..) = transmute_restriction.substituted_from.sty {\n+            if to_type_size == machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+                // FIXME #19925 Remove this warning after a release cycle.\n+                lint::raw_emit_lint(&ccx.tcx().sess,\n+                                    &ccx.tcx().sess.lint_store.borrow(),\n+                                    lint::builtin::TRANSMUTE_FROM_FN_ITEM_TYPES,\n+                                    (lint::Warn, lint::LintSource::Default),\n+                                    Some(transmute_restriction.span),\n+                                    &format!(\"`{}` is now zero-sized and has to be cast \\\n+                                              to a pointer before transmuting to `{}`\",\n+                                             transmute_restriction.substituted_from,\n+                                             transmute_restriction.substituted_to));\n+                continue;\n+            }\n+        }\n         if from_type_size != to_type_size {\n             last_failing_id = Some(transmute_restriction.id);\n \n             if transmute_restriction.original_from != transmute_restriction.substituted_from {\n                 span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n                     &format!(\"transmute called with differently sized types: \\\n-                              {} (could be {} bit{}) to {} (could be {} bit{})\",\n+                              {} (could be {} bits) to {} (could be {} bits)\",\n                              transmute_restriction.original_from,\n-                             from_type_size as usize,\n-                             if from_type_size == 1 {\"\"} else {\"s\"},\n+                             from_type_size,\n                              transmute_restriction.original_to,\n-                             to_type_size as usize,\n-                             if to_type_size == 1 {\"\"} else {\"s\"}));\n+                             to_type_size));\n             } else {\n                 span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n                     &format!(\"transmute called with differently sized types: \\\n-                              {} ({} bit{}) to {} ({} bit{})\",\n+                              {} ({} bits) to {} ({} bits)\",\n                              transmute_restriction.original_from,\n-                             from_type_size as usize,\n-                             if from_type_size == 1 {\"\"} else {\"s\"},\n+                             from_type_size,\n                              transmute_restriction.original_to,\n-                             to_type_size as usize,\n-                             if to_type_size == 1 {\"\"} else {\"s\"}));\n+                             to_type_size));\n             }\n         }\n     }\n@@ -163,7 +176,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             cleanup_scope: cleanup::CustomScopeIndex,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n-                                            substs: subst::Substs<'tcx>,\n+                                            substs: &'tcx subst::Substs<'tcx>,\n                                             call_info: NodeIdAndSpan)\n                                             -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n@@ -179,6 +192,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let foreign_item = tcx.map.expect_foreign_item(node);\n     let name = foreign_item.name.as_str();\n \n+    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+\n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n         let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n@@ -194,6 +209,27 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n                 let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n \n+                if let ty::TyFnDef(def_id, substs, _) = in_type.sty {\n+                    if out_type_size != 0 {\n+                        // FIXME #19925 Remove this hack after a release cycle.\n+                        let _ = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n+                        let llfn = Callee::def(ccx, def_id, substs, in_type).reify(ccx).val;\n+                        let llfnty = val_ty(llfn);\n+                        let llresult = match dest {\n+                            expr::SaveIn(d) => d,\n+                            expr::Ignore => alloc_ty(bcx, out_type, \"ret\")\n+                        };\n+                        Store(bcx, llfn, PointerCast(bcx, llresult, llfnty.ptr_to()));\n+                        if dest == expr::Ignore {\n+                            bcx = glue::drop_ty(bcx, llresult, out_type,\n+                                                call_debug_location);\n+                        }\n+                        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n+                        fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n+                        return Result::new(bcx, llresult);\n+                    }\n+                }\n+\n                 // This should be caught by the intrinsicck pass\n                 assert_eq!(in_type_size, out_type_size);\n \n@@ -311,8 +347,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n-\n     // For `try` we need some custom control flow\n     if &name[..] == \"try\" {\n         if let callee::ArgExprs(ref exprs) = args {\n@@ -364,7 +398,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              callee_ty,\n                              &mut llargs,\n                              cleanup::CustomScope(cleanup_scope),\n-                             false,\n                              Abi::RustIntrinsic);\n \n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n@@ -1264,7 +1297,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = ccx.tcx();\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+    let fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n@@ -1273,18 +1306,17 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n             variadic: false,\n         }),\n     });\n-    let fn_ty = tcx.mk_fn(None, fn_ty);\n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n-    let try_fn_ty  = tcx.mk_bare_fn(ty::BareFnTy {\n+    let try_fn_ty  = ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n             inputs: vec![fn_ty, i8p, i8p],\n             output: output,\n             variadic: false,\n         }),\n-    });\n-    let rust_try = gen_fn(fcx, \"__rust_try\", tcx.mk_fn(None, try_fn_ty), output,\n+    };\n+    let rust_try = gen_fn(fcx, \"__rust_try\", tcx.mk_fn_ptr(try_fn_ty), output,\n                           trans);\n     *ccx.rust_try_fn().borrow_mut() = Some(rust_try);\n     return rust_try\n@@ -1353,7 +1385,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // going on here, all I can say is that there's a few tests cases in\n         // LLVM's test suite which follow this pattern of instructions, so we\n         // just do the same.\n-        let filter_fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+        let filter_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n             abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n@@ -1362,7 +1394,6 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                 variadic: false,\n             }),\n         });\n-        let filter_fn_ty = tcx.mk_fn(None, filter_fn_ty);\n         gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n             let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], None, dloc);\n             let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n@@ -1373,7 +1404,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // Conveniently on x86_64 the EXCEPTION_POINTERS handle and base pointer\n         // are passed in as arguments to the filter function, so we just pass\n         // those along.\n-        let filter_fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+        let filter_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n             abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n@@ -1382,7 +1413,6 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                 variadic: false,\n             }),\n         });\n-        let filter_fn_ty = tcx.mk_fn(None, filter_fn_ty);\n         gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n             let exn = llvm::get_param(bcx.fcx.llfn, 0);\n             let rbp = llvm::get_param(bcx.fcx.llfn, 1);\n@@ -1400,7 +1430,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     (bcx: Block<'blk, 'tcx>,\n      name: &str,\n-     substs: subst::Substs<'tcx>,\n+     substs: &'tcx subst::Substs<'tcx>,\n      callee_ty: Ty<'tcx>,\n      args: Option<&[P<hir::Expr>]>,\n      llargs: &[ValueRef],\n@@ -1508,11 +1538,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n             None => bcx.sess().span_bug(call_info.span,\n                                         \"intrinsic call with unexpected argument shape\"),\n         };\n-        let vector = match consts::const_expr(\n-            bcx.ccx(),\n-            vector,\n-            tcx.mk_substs(substs),\n-            None,\n+        let vector = match consts::const_expr(bcx.ccx(), vector, substs, None,\n             consts::TrueConst::Yes, // this should probably help simd error reporting\n         ) {\n             Ok((vector, _)) => vector,"}, {"sha": "78b86dafa18ad83dd31172f1930d6036fb916f5e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 88, "deletions": 278, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -18,9 +18,8 @@ use middle::subst;\n use middle::traits;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee::*;\n-use trans::callee;\n-use trans::cleanup;\n+use trans::callee::{Callee, Virtual, ArgVals,\n+                    trans_fn_pointer_shim, trans_fn_ref_with_substs};\n use trans::closure;\n use trans::common::*;\n use trans::consts;\n@@ -30,11 +29,9 @@ use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::machine;\n-use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty, TyCtxt};\n-use middle::ty::MethodCall;\n \n use syntax::ast;\n use syntax::attr;\n@@ -92,264 +89,99 @@ pub fn trans_impl(ccx: &CrateContext,\n     }\n }\n \n-pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       method_call: MethodCall,\n-                                       self_expr: Option<&hir::Expr>,\n-                                       arg_cleanup_scope: cleanup::ScopeId)\n-                                       -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_method_callee\");\n-\n-    let method = bcx.tcx().tables.borrow().method_map[&method_call];\n-\n-    match bcx.tcx().impl_or_trait_item(method.def_id).container() {\n-        ty::ImplContainer(_) => {\n-            debug!(\"trans_method_callee: static, {:?}\", method.def_id);\n-            let datum = callee::trans_fn_ref(bcx.ccx(),\n-                                             method.def_id,\n-                                             MethodCallKey(method_call),\n-                                             bcx.fcx.param_substs);\n-            Callee {\n-                bcx: bcx,\n-                data: Fn(datum.val),\n-                ty: datum.ty\n-            }\n-        }\n-\n-        ty::TraitContainer(trait_def_id) => {\n-            let trait_ref = method.substs.to_trait_ref(bcx.tcx(), trait_def_id);\n-            let trait_ref = ty::Binder(bcx.monomorphize(&trait_ref));\n-            let span = bcx.tcx().map.span(method_call.expr_id);\n-            debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n-                   method_call,\n-                   trait_ref,\n-                   trait_ref.0.def_id,\n-                   trait_ref.0.substs);\n-            let origin = fulfill_obligation(bcx.ccx(), span, trait_ref);\n-            debug!(\"origin = {:?}\", origin);\n-            trans_monomorphized_callee(bcx,\n-                                       method_call,\n-                                       self_expr,\n-                                       trait_def_id,\n-                                       method.def_id,\n-                                       method.ty,\n-                                       origin,\n-                                       arg_cleanup_scope)\n-        }\n-    }\n-}\n-\n-pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                            method_id: DefId,\n-                                            trait_id: DefId,\n-                                            expr_id: ast::NodeId,\n-                                            param_substs: &'tcx subst::Substs<'tcx>)\n-                                            -> Datum<'tcx, Rvalue>\n-{\n-    let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n-    let tcx = ccx.tcx();\n-\n-    debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n-            expr_id={})\",\n-           method_id,\n-           tcx.item_path_str(trait_id),\n-           expr_id);\n-\n-    let mname = tcx.item_name(method_id);\n-\n-    debug!(\"trans_static_method_callee: method_id={:?}, expr_id={}, \\\n-            name={}\", method_id, expr_id, mname);\n-\n-    // Find the substitutions for the fn itself. This includes\n-    // type parameters that belong to the trait but also some that\n-    // belong to the method:\n-    let rcvr_substs = node_id_substs(ccx, ExprId(expr_id), param_substs);\n-    debug!(\"rcvr_substs={:?}\", rcvr_substs);\n-    let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(traits::VtableImplData {\n-            impl_def_id: impl_did,\n-            substs: impl_substs,\n-            nested: _ }) =>\n-        {\n-            let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n-            let mth = tcx.get_impl_method(impl_did, callee_substs, mname);\n-            trans_fn_ref_with_substs(ccx, mth.method.def_id, ExprId(expr_id),\n-                                     param_substs,\n-                                     mth.substs)\n-        }\n-        traits::VtableObject(ref data) => {\n-            let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n-            trans_object_shim(ccx,\n-                              data.upcast_trait_ref.clone(),\n-                              method_id,\n-                              idx)\n-        }\n-        _ => {\n-            // FIXME(#20847): handle at least VtableFnPointer\n-            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n-                                 vtbl));\n-        }\n-    }\n-}\n-\n-fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          method_call: MethodCall,\n-                                          self_expr: Option<&hir::Expr>,\n-                                          trait_id: DefId,\n-                                          method_id: DefId,\n-                                          method_ty: Ty<'tcx>,\n-                                          vtable: traits::Vtable<'tcx, ()>,\n-                                          arg_cleanup_scope: cleanup::ScopeId)\n-                                          -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n+/// Compute the appropriate callee, give na method's ID, trait ID,\n+/// substitutions and a Vtable for that trait.\n+pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       method_id: DefId,\n+                                       substs: &'tcx subst::Substs<'tcx>,\n+                                       trait_id: DefId,\n+                                       method_ty: Ty<'tcx>,\n+                                       vtable: traits::Vtable<'tcx, ()>)\n+                                       -> Callee<'tcx> {\n+    let _icx = push_ctxt(\"meth::callee_for_trait_impl\");\n     match vtable {\n         traits::VtableImpl(vtable_impl) => {\n-            let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n-            let mname = match ccx.tcx().impl_or_trait_item(method_id) {\n-                ty::MethodTraitItem(method) => method.name,\n-                _ => {\n-                    bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n-                                        item\")\n-                }\n-            };\n+            let mname = ccx.tcx().item_name(method_id);\n             // create a concatenated set of substitutions which includes\n             // those from the impl and those from the method:\n-            let meth_substs = node_id_substs(ccx,\n-                                             MethodCallKey(method_call),\n-                                             bcx.fcx.param_substs);\n-            let impl_substs = vtable_impl.substs.with_method_from(&meth_substs);\n-            let mth = bcx.tcx().get_impl_method(impl_did, impl_substs, mname);\n-            // translate the function\n-            let datum = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                 mth.method.def_id,\n-                                                 MethodCallKey(method_call),\n-                                                 bcx.fcx.param_substs,\n-                                                 mth.substs);\n-\n-            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n+            let impl_substs = vtable_impl.substs.with_method_from(&substs);\n+            let substs = ccx.tcx().mk_substs(impl_substs);\n+            let mth = ccx.tcx().get_impl_method(impl_did, substs, mname);\n+\n+            // Translate the function, bypassing Callee::def.\n+            // That is because default methods have the same ID as the\n+            // trait method used to look up the impl method that ended\n+            // up here, so calling Callee::def would infinitely recurse.\n+            Callee::ptr(trans_fn_ref_with_substs(ccx, mth.method.def_id,\n+                                                 Some(method_ty), mth.substs))\n         }\n         traits::VtableClosure(vtable_closure) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n-            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = closure::trans_closure_method(bcx.ccx(),\n+            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = closure::trans_closure_method(ccx,\n                                                      vtable_closure.closure_def_id,\n                                                      vtable_closure.substs,\n                                                      trait_closure_kind);\n-            Callee {\n-                bcx: bcx,\n-                data: Fn(llfn),\n-                ty: monomorphize_type(bcx, method_ty)\n-            }\n+            let fn_ptr_ty = match method_ty.sty {\n+                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n+                _ => unreachable!(\"expected fn item type, found {}\",\n+                                  method_ty)\n+            };\n+            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n         }\n         traits::VtableFnPointer(fn_ty) => {\n-            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n-            Callee {\n-                bcx: bcx,\n-                data: Fn(llfn),\n-                ty: monomorphize_type(bcx, method_ty)\n-            }\n+            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+            let fn_ptr_ty = match method_ty.sty {\n+                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n+                _ => unreachable!(\"expected fn item type, found {}\",\n+                                  method_ty)\n+            };\n+            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n         }\n         traits::VtableObject(ref data) => {\n-            let idx = traits::get_vtable_index_of_object_method(bcx.tcx(), data, method_id);\n-            if let Some(self_expr) = self_expr {\n-                if let ty::TyBareFn(_, ref fty) = monomorphize_type(bcx, method_ty).sty {\n-                    let ty = bcx.tcx().mk_fn(None, opaque_method_ty(bcx.tcx(), fty));\n-                    return trans_trait_callee(bcx, ty, idx, self_expr, arg_cleanup_scope);\n-                }\n+            Callee {\n+                data: Virtual(traits::get_vtable_index_of_object_method(\n+                    ccx.tcx(), data, method_id)),\n+                ty: method_ty\n             }\n-            let datum = trans_object_shim(bcx.ccx(),\n-                                          data.upcast_trait_ref.clone(),\n-                                          method_id,\n-                                          idx);\n-            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n         traits::VtableBuiltin(..) |\n         traits::VtableDefaultImpl(..) |\n         traits::VtableParam(..) => {\n-            bcx.sess().bug(\n+            ccx.sess().bug(\n                 &format!(\"resolved vtable bad vtable {:?} in trans\",\n                         vtable));\n         }\n     }\n }\n \n-/// Create a method callee where the method is coming from a trait object (e.g., Box<Trait> type).\n-/// In this case, we must pull the fn pointer out of the vtable that is packaged up with the\n-/// object. Objects are represented as a pair, so we first evaluate the self expression and then\n-/// extract the self data and vtable out of the pair.\n-fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  opaque_fn_ty: Ty<'tcx>,\n-                                  vtable_index: usize,\n-                                  self_expr: &hir::Expr,\n-                                  arg_cleanup_scope: cleanup::ScopeId)\n-                                  -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_trait_callee\");\n-    let mut bcx = bcx;\n-\n-    // Translate self_datum and take ownership of the value by\n-    // converting to an rvalue.\n-    let self_datum = unpack_datum!(\n-        bcx, expr::trans(bcx, self_expr));\n-\n-    let llval = if bcx.fcx.type_needs_drop(self_datum.ty) {\n-        let self_datum = unpack_datum!(\n-            bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n-\n-        // Convert to by-ref since `trans_trait_callee_from_llval` wants it\n-        // that way.\n-        let self_datum = unpack_datum!(\n-            bcx, self_datum.to_ref_datum(bcx));\n-\n-        // Arrange cleanup in case something should go wrong before the\n-        // actual call occurs.\n-        self_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n-    } else {\n-        // We don't have to do anything about cleanups for &Trait and &mut Trait.\n-        assert!(self_datum.kind.is_by_ref());\n-        self_datum.val\n-    };\n-\n-    let llself = Load(bcx, expr::get_dataptr(bcx, llval));\n-    let llvtable = Load(bcx, expr::get_meta(bcx, llval));\n-    trans_trait_callee_from_llval(bcx, opaque_fn_ty, vtable_index, llself, llvtable)\n-}\n-\n-/// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n-/// pair.\n-fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                             opaque_fn_ty: Ty<'tcx>,\n-                                             vtable_index: usize,\n-                                             llself: ValueRef,\n-                                             llvtable: ValueRef)\n-                                             -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_trait_callee\");\n+/// Extracts a method from a trait object's vtable, at the\n+/// specified index, and casts it to the given type.\n+pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      llvtable: ValueRef,\n+                                      vtable_index: usize,\n+                                      method_ty: Ty<'tcx>)\n+                                      -> Datum<'tcx, Rvalue> {\n+    let _icx = push_ctxt(\"meth::get_virtual_method\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llself={}, llvtable={})\",\n-           opaque_fn_ty,\n+    debug!(\"get_virtual_method(callee_ty={}, vtable_index={}, llvtable={})\",\n+           method_ty,\n            vtable_index,\n-           bcx.val_to_string(llself),\n            bcx.val_to_string(llvtable));\n \n-    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n-    let llcallee_ty = type_of_fn_from_ty(ccx, opaque_fn_ty);\n \n-    Callee {\n-        bcx: bcx,\n-        data: TraitItem(MethodData {\n-            llfn: PointerCast(bcx, mptr, llcallee_ty.ptr_to()),\n-            llself: PointerCast(bcx, llself, Type::i8p(ccx)),\n-        }),\n-        ty: opaque_fn_ty\n+    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n+    if let ty::TyFnDef(_, _, fty) = method_ty.sty {\n+        let opaque_ty = opaque_method_ty(ccx.tcx(), fty);\n+        immediate_rvalue(PointerCast(bcx, mptr, type_of(ccx, opaque_ty)), opaque_ty)\n+    } else {\n+        immediate_rvalue(mptr, method_ty)\n     }\n }\n \n@@ -374,58 +206,41 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n-pub fn trans_object_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_id: DefId,\n-    vtable_index: usize)\n-    -> Datum<'tcx, Rvalue>\n-{\n+pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                   method_ty: Ty<'tcx>,\n+                                   vtable_index: usize)\n+                                   -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(upcast_trait_ref={:?}, method_id={:?})\",\n-           upcast_trait_ref,\n-           method_id);\n+    debug!(\"trans_object_shim(vtable_index={}, method_ty={:?})\",\n+           vtable_index,\n+           method_ty);\n \n-    // Upcast to the trait in question and extract out the substitutions.\n-    let upcast_trait_ref = tcx.erase_late_bound_regions(&upcast_trait_ref);\n-    let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n-    debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n+    let ret_ty = tcx.erase_late_bound_regions(&method_ty.fn_ret());\n+    let ret_ty = infer::normalize_associated_type(tcx, &ret_ty);\n \n-    // Lookup the type of this method as declared in the trait and apply substitutions.\n-    let method_ty = match tcx.impl_or_trait_item(method_id) {\n-        ty::MethodTraitItem(method) => method,\n-        _ => {\n-            tcx.sess.bug(\"can't create a method shim for a non-method item\")\n-        }\n+    let shim_fn_ty = match method_ty.sty {\n+        ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+        _ => unreachable!(\"expected fn item type, found {}\", method_ty)\n     };\n-    let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n-    let fty = tcx.mk_bare_fn(fty);\n-    let method_ty = opaque_method_ty(tcx, fty);\n-    debug!(\"trans_object_shim: fty={:?} method_ty={:?}\", fty, method_ty);\n \n     //\n-    let shim_fn_ty = tcx.mk_fn(None, fty);\n-    let method_bare_fn_ty = tcx.mk_fn(None, method_ty);\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n     let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty);\n \n-    let sig = ccx.tcx().erase_late_bound_regions(&fty.sig);\n-    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       llfn,\n                       ast::DUMMY_NODE_ID,\n                       false,\n-                      sig.output,\n+                      ret_ty,\n                       empty_substs,\n                       None,\n                       &block_arena);\n-    let mut bcx = init_function(&fcx, false, sig.output);\n+    let mut bcx = init_function(&fcx, false, ret_ty);\n \n     let llargs = get_params(fcx.llfn);\n \n@@ -440,21 +255,18 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n \n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n            vtable_index);\n \n-    bcx = trans_call_inner(bcx,\n-                           DebugLoc::None,\n-                           |bcx, _| trans_trait_callee_from_llval(bcx,\n-                                                                  method_bare_fn_ty,\n-                                                                  vtable_index,\n-                                                                  llself, llvtable),\n-                           ArgVals(&llargs[(self_idx + 2)..]),\n-                           dest).bcx;\n+    let callee = Callee {\n+        data: Virtual(vtable_index),\n+        ty: method_ty\n+    };\n+    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+    finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n \n     immediate_rvalue(llfn, shim_fn_ty)\n }\n@@ -466,8 +278,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            trait_ref: ty::PolyTraitRef<'tcx>,\n-                            param_substs: &'tcx subst::Substs<'tcx>)\n+                            trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> ValueRef\n {\n     let tcx = ccx.tcx();\n@@ -503,8 +314,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             Some(mth) => {\n                                 trans_fn_ref_with_substs(ccx,\n                                                          mth.method.def_id,\n-                                                         ExprId(0),\n-                                                         param_substs,\n+                                                         None,\n                                                          mth.substs).val\n                             }\n                             None => nullptr\n@@ -567,7 +377,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     impl_id: DefId,\n-                                    substs: subst::Substs<'tcx>)\n+                                    substs: &'tcx subst::Substs<'tcx>)\n                                     -> Vec<Option<ty::util::ImplMethod<'tcx>>>\n {\n     let tcx = ccx.tcx();\n@@ -618,7 +428,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = tcx.get_impl_method(impl_id, substs.clone(), name);\n+            let mth = tcx.get_impl_method(impl_id, substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -628,7 +438,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n-                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n+                let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;\n@@ -642,11 +452,11 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n /// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n fn opaque_method_ty<'tcx>(tcx: &TyCtxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n-                          -> &'tcx ty::BareFnTy<'tcx> {\n+                          -> Ty<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n     inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::IntTy::I8));\n \n-    tcx.mk_bare_fn(ty::BareFnTy {\n+    tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: method_ty.unsafety,\n         abi: method_ty.abi,\n         sig: ty::Binder(ty::FnSig {"}, {"sha": "50283c0959c3f37a5f613d2456119b0822aef196", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 76, "deletions": 69, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -9,72 +9,27 @@\n // except according to those terms.\n \n use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n-use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty;\n use rustc::mir::repr as mir;\n use syntax::abi::Abi;\n use trans::adt;\n use trans::attributes;\n use trans::base;\n use trans::build;\n+use trans::callee::{Callee, Fn, Virtual};\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n use trans::foreign;\n+use trans::meth;\n use trans::type_of;\n use trans::glue;\n use trans::type_::Type;\n \n use super::{MirContext, drop};\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n-use super::operand::OperandRef;\n-\n-#[derive(PartialEq, Eq)]\n-enum AbiStyle {\n-    Foreign,\n-    RustCall,\n-    Rust\n-}\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    fn abi_style(&self, fn_ty: Ty<'tcx>) -> AbiStyle {\n-        if let ty::TyBareFn(_, ref f) = fn_ty.sty {\n-            // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-            assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n-\n-            match f.abi {\n-                Abi::Rust => AbiStyle::Rust,\n-                Abi::RustCall => AbiStyle::RustCall,\n-                _ => AbiStyle::Foreign\n-            }\n-        } else {\n-            unreachable!()\n-        }\n-    }\n-\n-    fn arg_operands(&mut self,\n-                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                    abi_style: AbiStyle,\n-                    args: &[mir::Operand<'tcx>])\n-                    -> Vec<OperandRef<'tcx>>\n-    {\n-        match abi_style {\n-            AbiStyle::Foreign | AbiStyle::Rust => {\n-                args.iter().map(|arg| self.trans_operand(bcx, arg)).collect()\n-            }\n-            AbiStyle::RustCall => match args.split_last() {\n-                None => vec![],\n-                Some((tup, self_ty)) => {\n-                    // we can reorder safely because of MIR\n-                    let untupled_args = self.trans_operand_untupled(bcx, tup);\n-                    self_ty\n-                        .iter().map(|arg| self.trans_operand(bcx, arg))\n-                        .chain(untupled_args.into_iter())\n-                        .collect()\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         debug!(\"trans_block({:?})\", bb);\n \n@@ -197,19 +152,32 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n-                // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n+                // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n-                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n                 let debugloc = DebugLoc::None;\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let mut llargs = Vec::with_capacity(args.len() + 1);\n                 // Types of the arguments. We do not preallocate, because this vector is only\n                 // filled when `is_foreign` is `true` and foreign calls are minority of the cases.\n                 let mut arg_tys = Vec::new();\n \n+                let (callee, fty) = match callee.ty.sty {\n+                    ty::TyFnDef(def_id, substs, f) => {\n+                        (Callee::def(bcx.ccx(), def_id, substs, callee.ty), f)\n+                    }\n+                    ty::TyFnPtr(f) => {\n+                        (Callee {\n+                            data: Fn(callee.immediate()),\n+                            ty: callee.ty\n+                        }, f)\n+                    }\n+                    _ => unreachable!(\"{} is not callable\", callee.ty)\n+                };\n+\n+                // We do not translate intrinsics here (they shouldn\u2019t be functions)\n+                assert!(fty.abi != Abi::RustIntrinsic && fty.abi != Abi::PlatformIntrinsic);\n                 // Foreign-ABI functions are translated differently\n-                let abi_style = self.abi_style(callee.ty);\n-                let is_foreign = abi_style == AbiStyle::Foreign;\n+                let is_foreign = fty.abi != Abi::Rust && fty.abi != Abi::RustCall;\n \n                 // Prepare the return value destination\n                 let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n@@ -225,19 +193,58 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (None, false)\n                 };\n \n-                // Process the rest of the args.\n-                for operand in self.arg_operands(&bcx, abi_style, args) {\n-                    match operand.val {\n-                        Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                        FatPtr(b, e) => {\n-                            llargs.push(b);\n-                            llargs.push(e);\n+                // Split the rust-call tupled arguments off.\n+                let (args, rest) = if fty.abi == Abi::RustCall && !args.is_empty() {\n+                    let (tup, args) = args.split_last().unwrap();\n+                    // we can reorder safely because of MIR\n+                    (args, self.trans_operand_untupled(&bcx, tup))\n+                } else {\n+                    (&args[..], vec![])\n+                };\n+\n+                let datum = {\n+                    let mut arg_ops = args.iter().map(|arg| {\n+                        self.trans_operand(&bcx, arg)\n+                    }).chain(rest.into_iter());\n+\n+                    // Get the actual pointer we can call.\n+                    // This can involve vtable accesses or reification.\n+                    let datum = if let Virtual(idx) = callee.data {\n+                        assert!(!is_foreign);\n+\n+                        // Grab the first argument which is a trait object.\n+                        let vtable = match arg_ops.next().unwrap().val {\n+                            FatPtr(data, vtable) => {\n+                                llargs.push(data);\n+                                vtable\n+                            }\n+                            _ => unreachable!(\"expected FatPtr for Virtual call\")\n+                        };\n+\n+                        bcx.with_block(|bcx| {\n+                            meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n+                        })\n+                    } else {\n+                        callee.reify(bcx.ccx())\n+                    };\n+\n+                    // Process the rest of the args.\n+                    for operand in arg_ops {\n+                        match operand.val {\n+                            Ref(llval) | Immediate(llval) => llargs.push(llval),\n+                            FatPtr(b, e) => {\n+                                llargs.push(b);\n+                                llargs.push(e);\n+                            }\n+                        }\n+                        if is_foreign {\n+                            arg_tys.push(operand.ty);\n                         }\n                     }\n-                    if is_foreign {\n-                        arg_tys.push(operand.ty);\n-                    }\n-                }\n+\n+                    datum\n+                };\n+                let attrs = attributes::from_fn_type(bcx.ccx(), datum.ty);\n \n                 // Many different ways to call a function handled here\n                 match (is_foreign, cleanup, destination) {\n@@ -246,7 +253,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n-                        bcx.invoke(callee.immediate(),\n+                        bcx.invoke(datum.val,\n                                    &llargs[..],\n                                    unreachable_blk.llbb,\n                                    landingpad.llbb(),\n@@ -259,7 +266,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (false, &Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n-                        let invokeret = bcx.invoke(callee.immediate(),\n+                        let invokeret = bcx.invoke(datum.val,\n                                                    &llargs[..],\n                                                    self.llblock(success),\n                                                    landingpad.llbb(),\n@@ -282,15 +289,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         });\n                     },\n                     (false, _, &None) => {\n-                        bcx.call(callee.immediate(),\n+                        bcx.call(datum.val,\n                                  &llargs[..],\n                                  cleanup_bundle.as_ref(),\n                                  Some(attrs));\n                         // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                     (false, _, &Some((_, target))) => {\n-                        let llret = bcx.call(callee.immediate(),\n+                        let llret = bcx.call(datum.val,\n                                              &llargs[..],\n                                              cleanup_bundle.as_ref(),\n                                              Some(attrs));\n@@ -312,8 +319,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             .expect(\"return destination is not set\");\n                         bcx = bcx.map_block(|bcx| {\n                             foreign::trans_native_call(bcx,\n-                                                       callee.ty,\n-                                                       callee.immediate(),\n+                                                       datum.ty,\n+                                                       datum.val,\n                                                        dest.llval,\n                                                        &llargs[..],\n                                                        arg_tys,"}, {"sha": "a0615a6cf5b18041c5e57e78e30cc3e10c3e9a95", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -10,14 +10,14 @@\n \n use back::abi;\n use llvm::ValueRef;\n-use middle::subst::Substs;\n use middle::ty::{Ty, TypeFoldable};\n-use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::const_eval::{self, ConstVal};\n use rustc::mir::repr as mir;\n use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n-                    C_str_slice};\n+                    C_str_slice, C_nil, C_undef};\n use trans::consts;\n use trans::expr;\n+use trans::inline;\n use trans::type_of;\n \n use super::operand::{OperandRef, OperandValue};\n@@ -32,7 +32,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           -> OperandRef<'tcx>\n     {\n         let ccx = bcx.ccx();\n-        let val = self.trans_constval_inner(bcx, cv, ty, bcx.fcx().param_substs);\n+        let val = self.trans_constval_inner(bcx, cv, ty);\n         let val = if common::type_is_immediate(ccx, ty) {\n             OperandValue::Immediate(val)\n         } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n@@ -55,8 +55,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     fn trans_constval_inner(&mut self,\n                             bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                             cv: &ConstVal,\n-                            ty: Ty<'tcx>,\n-                            param_substs: &'tcx Substs<'tcx>)\n+                            ty: Ty<'tcx>)\n                             -> ValueRef\n     {\n         let ccx = bcx.ccx();\n@@ -75,8 +74,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     expr::trans(bcx, expr).datum.val\n                 })\n             },\n-            ConstVal::Function(did) =>\n-                self.trans_fn_ref(bcx, ty, param_substs, did).immediate()\n+            ConstVal::Function(_) => C_nil(ccx)\n         }\n     }\n \n@@ -85,13 +83,31 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n+        let ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {\n-            mir::Literal::Item { def_id, kind, substs } => {\n+            mir::Literal::Item { def_id, substs } => {\n+                // Shortcut for zero-sized types, including function item\n+                // types, which would not work with lookup_const_by_id.\n+                if common::type_is_zero_size(bcx.ccx(), ty) {\n+                    let llty = type_of::type_of(bcx.ccx(), ty);\n+                    return OperandRef {\n+                        val: OperandValue::Immediate(C_undef(llty)),\n+                        ty: ty\n+                    };\n+                }\n+\n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n-                self.trans_item_ref(bcx, constant.ty, kind, substs, def_id)\n+                let def_id = inline::maybe_instantiate_inline(bcx.ccx(), def_id);\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, None, Some(substs))\n+                            .expect(\"def was const, but lookup_const_by_id failed\");\n+                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n+                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n+                let d = bcx.with_block(|bcx| {\n+                    expr::trans(bcx, expr)\n+                });\n+                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n             }\n             mir::Literal::Value { ref value } => {\n-                let ty = bcx.monomorphize(&constant.ty);\n                 self.trans_constval(bcx, value, ty)\n             }\n         }"}, {"sha": "3741b07d248e23900073d3470e1ee4fcc74a176d", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9995b24ccc7489e0082199793c300015753dd1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=0b9995b24ccc7489e0082199793c300015753dd1", "patch": "@@ -1,171 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Code for translating references to other items (DefIds).\n-\n-use syntax::codemap::DUMMY_SP;\n-use rustc::front::map;\n-use rustc::middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::middle::subst::Substs;\n-use rustc::middle::const_eval;\n-use rustc::middle::def_id::DefId;\n-use rustc::middle::traits;\n-use rustc::mir::repr::ItemKind;\n-use trans::common::{BlockAndBuilder, fulfill_obligation};\n-use trans::base;\n-use trans::closure;\n-use trans::expr;\n-use trans::monomorphize;\n-use trans::meth;\n-use trans::inline;\n-\n-use super::MirContext;\n-use super::operand::{OperandRef, OperandValue};\n-\n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    /// Translate reference to item.\n-    pub fn trans_item_ref(&mut self,\n-                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          kind: ItemKind,\n-                          substs: &'tcx Substs<'tcx>,\n-                          did: DefId)\n-                          -> OperandRef<'tcx> {\n-        debug!(\"trans_item_ref(ty={:?}, kind={:?}, substs={:?}, did={})\",\n-            ty, kind, substs, bcx.tcx().item_path_str(did));\n-\n-        match kind {\n-            ItemKind::Function => self.trans_fn_ref(bcx, ty, substs, did),\n-            ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n-                ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n-                ty::TraitContainer(tdid) => self.trans_trait_method(bcx, ty, did, tdid, substs)\n-            },\n-            ItemKind::Constant => {\n-                let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                let expr = const_eval::lookup_const_by_id(bcx.tcx(), did, None, Some(substs))\n-                            .expect(\"def was const, but lookup_const_by_id failed\");\n-                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n-                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n-                let d = bcx.with_block(|bcx| {\n-                    expr::trans(bcx, expr)\n-                });\n-                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n-            }\n-        }\n-    }\n-\n-    /// Translates references to a function-like items.\n-    ///\n-    /// That includes regular functions, non-static methods, struct and enum variant constructors,\n-    /// closures and possibly more.\n-    ///\n-    /// This is an adaptation of callee::trans_fn_ref_with_substs.\n-    pub fn trans_fn_ref(&mut self,\n-                        bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                        ty: Ty<'tcx>,\n-                        substs: &'tcx Substs<'tcx>,\n-                        did: DefId)\n-                        -> OperandRef<'tcx> {\n-        debug!(\"trans_fn_ref(ty={:?}, substs={:?}, did={})\",\n-            ty, substs, bcx.tcx().item_path_str(did));\n-\n-        let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-\n-        if !substs.types.is_empty() || is_named_tuple_constructor(bcx.tcx(), did) {\n-            let (val, fn_ty, _) = monomorphize::monomorphic_fn(bcx.ccx(), did, substs, None);\n-            // FIXME: cast fnptr to proper type if necessary\n-            OperandRef {\n-                ty: fn_ty,\n-                val: OperandValue::Immediate(val)\n-            }\n-        } else {\n-            let val = if let Some(node_id) = bcx.tcx().map.as_local_node_id(did) {\n-                base::get_item_val(bcx.ccx(), node_id)\n-            } else {\n-                base::trans_external_path(bcx.ccx(), did, ty)\n-            };\n-            // FIXME: cast fnptr to proper type if necessary\n-            OperandRef {\n-                ty: ty,\n-                val: OperandValue::Immediate(val)\n-            }\n-        }\n-    }\n-\n-    /// Translates references to trait methods.\n-    ///\n-    /// This is an adaptation of meth::trans_static_method_callee\n-    pub fn trans_trait_method(&mut self,\n-                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              ty: Ty<'tcx>,\n-                              method_id: DefId,\n-                              trait_id: DefId,\n-                              substs: &'tcx Substs<'tcx>)\n-                              -> OperandRef<'tcx> {\n-        debug!(\"trans_static_method(ty={:?}, method={}, trait={}, substs={:?})\",\n-                ty,\n-                bcx.tcx().item_path_str(method_id),\n-                bcx.tcx().item_path_str(trait_id),\n-                substs);\n-\n-        let ccx = bcx.ccx();\n-        let tcx = bcx.tcx();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-        let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n-        match vtbl {\n-            traits::VtableImpl(traits::VtableImplData {\n-                impl_def_id, substs: impl_substs, ..\n-            }) => {\n-                assert!(!impl_substs.types.needs_infer());\n-\n-                let mname = tcx.item_name(method_id);\n-\n-                let callee_substs = impl_substs.with_method_from(substs);\n-                let mth = tcx.get_impl_method(impl_def_id, callee_substs, mname);\n-                let mth_substs = tcx.mk_substs(mth.substs);\n-                self.trans_fn_ref(bcx, ty, mth_substs, mth.method.def_id)\n-            },\n-            traits::VtableClosure(data) => {\n-                let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-                let llfn = closure::trans_closure_method(bcx.ccx(),\n-                                                         data.closure_def_id,\n-                                                         data.substs,\n-                                                         trait_closure_kind);\n-                OperandRef {\n-                    ty: ty,\n-                    val: OperandValue::Immediate(llfn)\n-                }\n-            },\n-            traits::VtableObject(ref data) => {\n-                let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n-                OperandRef::from_rvalue_datum(\n-                    meth::trans_object_shim(ccx, data.upcast_trait_ref.clone(), method_id, idx)\n-                )\n-            }\n-            _ => {\n-                tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl));\n-            }\n-        }\n-   }\n-}\n-\n-fn is_named_tuple_constructor(tcx: &TyCtxt, def_id: DefId) -> bool {\n-    let node_id = match tcx.map.as_local_node_id(def_id) {\n-        Some(n) => n,\n-        None => { return false; }\n-    };\n-    match tcx.map.find(node_id).expect(\"local item should be in ast map\") {\n-        map::NodeVariant(v) => {\n-            v.node.data.is_tuple()\n-        }\n-        map::NodeStructCtor(_) => true,\n-        _ => false\n-    }\n-}"}, {"sha": "4ad2e035945f3baaac56dbfaf2487732ece9a781", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -196,7 +196,6 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n-mod did;\n mod drop;\n mod lvalue;\n mod operand;"}, {"sha": "ce10ed425f63afe92ff8b15425ee77910d5cc47e", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::repr as mir;\n \n use trans::asm;\n use trans::base;\n+use trans::callee::Callee;\n use trans::common::{self, BlockAndBuilder, Result};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n@@ -193,9 +194,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let cast_ty = bcx.monomorphize(&cast_ty);\n \n                 let val = match *kind {\n-                    mir::CastKind::ReifyFnPointer |\n+                    mir::CastKind::ReifyFnPointer => {\n+                        match operand.ty.sty {\n+                            ty::TyFnDef(def_id, substs, _) => {\n+                                OperandValue::Immediate(\n+                                    Callee::def(bcx.ccx(), def_id, substs, operand.ty)\n+                                        .reify(bcx.ccx()).val)\n+                            }\n+                            _ => {\n+                                unreachable!(\"{} cannot be reified to a fn ptr\", operand.ty)\n+                            }\n+                        }\n+                    }\n                     mir::CastKind::UnsafeFnPointer => {\n-                        // these are no-ops at the LLVM level\n+                        // this is a no-op at the LLVM level\n                         operand.val\n                     }\n                     mir::CastKind::Unsize => {"}, {"sha": "c6119416e47eda2fffee413336498b212bc2d42d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -37,16 +37,9 @@ use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n-                                psubsts: &'tcx subst::Substs<'tcx>,\n-                                ref_id: Option<ast::NodeId>)\n+                                psubsts: &'tcx subst::Substs<'tcx>)\n                                 -> (ValueRef, Ty<'tcx>, bool) {\n-    debug!(\"monomorphic_fn(\\\n-            fn_id={:?}, \\\n-            real_substs={:?}, \\\n-            ref_id={:?})\",\n-           fn_id,\n-           psubsts,\n-           ref_id);\n+    debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n \n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n "}, {"sha": "b78bf9bfc3fb27f15552eb161f1c98e348acb7aa", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -150,26 +150,6 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     Type::func(&atys[..], &lloutputtype)\n }\n \n-// Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>) -> Type {\n-    match fty.sty {\n-        ty::TyBareFn(_, ref f) => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to do something here\n-            if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-                let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n-                let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-                type_of_rust_fn(cx, None, &sig, f.abi)\n-            } else {\n-                foreign::lltype_for_foreign_fn(cx, fty)\n-            }\n-        }\n-        _ => {\n-            cx.sess().bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n-        }\n-    }\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -210,7 +190,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::TyBareFn(..) => Type::i8p(cx),\n+        ty::TyFnDef(..) => Type::nil(cx),\n+        ty::TyFnPtr(_) => Type::i8p(cx),\n \n         ty::TyArray(ty, size) => {\n             let llty = sizing_type_of(cx, ty);\n@@ -415,8 +396,15 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TySlice(ty) => in_memory_type_of(cx, ty),\n       ty::TyStr | ty::TyTrait(..) => Type::i8(cx),\n \n-      ty::TyBareFn(..) => {\n-          type_of_fn_from_ty(cx, t).ptr_to()\n+      ty::TyFnDef(..) => Type::nil(cx),\n+      ty::TyFnPtr(f) => {\n+        if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n+            let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n+            let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n+            type_of_rust_fn(cx, None, &sig, f.abi).ptr_to()\n+        } else {\n+            foreign::lltype_for_foreign_fn(cx, t).ptr_to()\n+        }\n       }\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {"}, {"sha": "1938fa7582918dc57836f5d4453d9ac4757c07da", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -1636,8 +1636,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         hir::TyBareFn(ref bf) => {\n             require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &bf.decl);\n-            tcx.mk_fn(None, tcx.mk_bare_fn(bare_fn))\n+            tcx.mk_fn_ptr(ty_of_bare_fn(this, bf.unsafety, bf.abi, &bf.decl))\n         }\n         hir::TyPolyTraitRef(ref bounds) => {\n             conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)"}, {"sha": "305970db9e72e0fa43d340ab4c01f34f472c9a18", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -15,9 +15,10 @@ use middle::pat_util::pat_is_resolved_const;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n-use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n+use check::{demand, FnCtxt, Expectation};\n use check::{check_expr_with_lvalue_pref};\n use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n+use check::coercion;\n use lint;\n use require_same_types;\n use util::nodemap::FnvHashMap;\n@@ -492,54 +493,67 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // of execution reach it, we will panic, so bottom is an appropriate\n     // type in that case)\n     let expected = expected.adjust_for_branches(fcx);\n-    let result_ty = arms.iter().fold(fcx.infcx().next_diverging_ty_var(), |result_ty, arm| {\n-        let bty = match expected {\n-            // We don't coerce to `()` so that if the match expression is a\n-            // statement it's branches can have any consistent type. That allows\n-            // us to give better error messages (pointing to a usually better\n-            // arm for inconsistent arms or to the whole match when a `()` type\n-            // is required).\n-            Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n-                check_expr_coercable_to_type(fcx, &arm.body, ety);\n-                ety\n-            }\n-            _ => {\n-                check_expr_with_expectation(fcx, &arm.body, expected);\n-                fcx.node_ty(arm.body.id)\n+    let mut result_ty = fcx.infcx().next_diverging_ty_var();\n+    let coerce_first = match expected {\n+        // We don't coerce to `()` so that if the match expression is a\n+        // statement it's branches can have any consistent type. That allows\n+        // us to give better error messages (pointing to a usually better\n+        // arm for inconsistent arms or to the whole match when a `()` type\n+        // is required).\n+        Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n+            ety\n+        }\n+        _ => result_ty\n+    };\n+    for (i, arm) in arms.iter().enumerate() {\n+        if let Some(ref e) = arm.guard {\n+            check_expr_has_type(fcx, e, tcx.types.bool);\n+        }\n+        check_expr_with_expectation(fcx, &arm.body, expected);\n+        let arm_ty = fcx.expr_ty(&arm.body);\n+\n+        if result_ty.references_error() || arm_ty.references_error() {\n+            result_ty = tcx.types.err;\n+            continue;\n+        }\n+\n+        // Handle the fallback arm of a desugared if-let like a missing else.\n+        let is_if_let_fallback = match match_src {\n+            hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n+                i == arms.len() - 1 && arm_ty.is_nil()\n             }\n+            _ => false\n         };\n \n-        if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, &e, tcx.types.bool);\n-        }\n+        let origin = if is_if_let_fallback {\n+            TypeOrigin::IfExpressionWithNoElse(expr.span)\n+        } else {\n+            TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src)\n+        };\n \n-        if result_ty.references_error() || bty.references_error() {\n-            tcx.types.err\n+        let result = if is_if_let_fallback {\n+            fcx.infcx().eq_types(true, origin, arm_ty, result_ty).map(|_| arm_ty)\n+        } else if i == 0 {\n+            // Special-case the first arm, as it has no \"previous expressions\".\n+            coercion::try(fcx, &arm.body, coerce_first)\n         } else {\n-            let (origin, expected, found) = match match_src {\n-                /* if-let construct without an else block */\n-                hir::MatchSource::IfLetDesugar { contains_else_clause }\n-                if !contains_else_clause => (\n-                    TypeOrigin::IfExpressionWithNoElse(expr.span),\n-                    bty,\n-                    result_ty,\n-                ),\n-                _ => (\n-                    TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src),\n-                    result_ty,\n-                    bty,\n-                ),\n-            };\n+            let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n+            coercion::try_find_lub(fcx, origin, prev_arms, result_ty, &arm.body)\n+        };\n \n-            infer::common_supertype(\n-                fcx.infcx(),\n-                origin,\n-                true,\n-                expected,\n-                found,\n-            )\n-        }\n-    });\n+        result_ty = match result {\n+            Ok(ty) => ty,\n+            Err(e) => {\n+                let (expected, found) = if is_if_let_fallback {\n+                    (arm_ty, result_ty)\n+                } else {\n+                    (result_ty, arm_ty)\n+                };\n+                fcx.infcx().report_mismatched_types(origin, expected, found, e);\n+                fcx.tcx().types.err\n+            }\n+        };\n+    }\n \n     fcx.write_ty(expr.id, result_ty);\n }"}, {"sha": "bf60f435a2213f3a2ec9332431ef65f134c23990", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -82,7 +82,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         autoderef(fcx,\n                   callee_expr.span,\n                   original_callee_ty,\n-                  Some(callee_expr),\n+                  || Some(callee_expr),\n                   UnresolvedTypeAction::Error,\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n@@ -130,7 +130,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n-        ty::TyBareFn(..) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             fcx.write_autoderef_adjustment(callee_expr.id, autoderefs);\n             return Some(CallStep::Builtin);\n         }\n@@ -225,7 +225,8 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let error_fn_sig;\n \n     let fn_sig = match callee_ty.sty {\n-        ty::TyBareFn(_, &ty::BareFnTy {ref sig, ..}) => {\n+        ty::TyFnDef(_, _, &ty::BareFnTy {ref sig, ..}) |\n+        ty::TyFnPtr(&ty::BareFnTy {ref sig, ..}) => {\n             sig\n         }\n         _ => {"}, {"sha": "b5cd5d7f8e5a38d391ab2f056ff70de16cc60d56", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -55,7 +55,7 @@ use syntax::ast;\n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n pub struct CastCheck<'tcx> {\n-    expr: hir::Expr,\n+    expr: &'tcx hir::Expr,\n     expr_ty: Ty<'tcx>,\n     cast_ty: Ty<'tcx>,\n     span: Span,\n@@ -109,7 +109,7 @@ enum CastError {\n }\n \n impl<'tcx> CastCheck<'tcx> {\n-    pub fn new(expr: hir::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n+    pub fn new(expr: &'tcx hir::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n                -> CastCheck<'tcx> {\n         CastCheck {\n             expr: expr,\n@@ -235,6 +235,20 @@ impl<'tcx> CastCheck<'tcx> {\n         let (t_from, t_cast) = match (CastTy::from_ty(self.expr_ty),\n                                       CastTy::from_ty(self.cast_ty)) {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n+            // Function item types may need to be reified before casts.\n+            (None, Some(t_cast)) => {\n+                if let ty::TyFnDef(_, _, f) = self.expr_ty.sty {\n+                    // Attempt a coercion to a fn pointer type.\n+                    let res = coercion::try(fcx, self.expr,\n+                                            fcx.tcx().mk_ty(ty::TyFnPtr(f)));\n+                    if !res.is_ok() {\n+                        return Err(CastError::NonScalar);\n+                    }\n+                    (FnPtr, t_cast)\n+                } else {\n+                    return Err(CastError::NonScalar);\n+                }\n+            }\n             _ => {\n                 return Err(CastError::NonScalar)\n             }\n@@ -376,14 +390,7 @@ impl<'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n-        if let Ok(()) = coercion::mk_assignty(fcx,\n-                                              &self.expr,\n-                                              self.expr_ty,\n-                                              self.cast_ty) {\n-            true\n-        } else {\n-            false\n-        }\n+        coercion::try(fcx, self.expr, self.cast_ty).is_ok()\n     }\n \n }"}, {"sha": "aa359c95e2d1409c37c42f4de5de2cdc5f663b86", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 264, "deletions": 116, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -62,7 +62,7 @@\n \n use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n \n-use middle::infer::{self, Coercion, TypeOrigin};\n+use middle::infer::{Coercion, TypeOrigin, TypeTrace};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n@@ -71,7 +71,7 @@ use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n use middle::ty::fold::TypeFoldable;\n use middle::ty::error::TypeError;\n-use middle::ty::relate::RelateResult;\n+use middle::ty::relate::{relate_substs, RelateResult, TypeRelation};\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -80,42 +80,75 @@ use rustc_front::hir;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    origin: infer::TypeOrigin,\n+    origin: TypeOrigin,\n+    use_lub: bool,\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, Option<AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, AutoAdjustment<'tcx>)>;\n+\n+fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n+                       to_mutbl: hir::Mutability)\n+                       -> RelateResult<'tcx, ()> {\n+    match (from_mutbl, to_mutbl) {\n+        (hir::MutMutable, hir::MutMutable) |\n+        (hir::MutImmutable, hir::MutImmutable) |\n+        (hir::MutMutable, hir::MutImmutable) => Ok(()),\n+        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability)\n+    }\n+}\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n+    fn new(fcx: &'f FnCtxt<'f, 'tcx>, origin: TypeOrigin) -> Self {\n+        Coerce {\n+            fcx: fcx,\n+            origin: origin,\n+            use_lub: false,\n+            unsizing_obligations: RefCell::new(vec![])\n+        }\n+    }\n+\n     fn tcx(&self) -> &TyCtxt<'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        try!(self.fcx.infcx().sub_types(false, self.origin.clone(), a, b));\n-        Ok(None) // No coercion required.\n+    /// Unify two types (using sub or lub) and produce a noop coercion.\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        let infcx = self.fcx.infcx();\n+        infcx.commit_if_ok(|_| {\n+            let trace = TypeTrace::types(self.origin, false, a, b);\n+            if self.use_lub {\n+                infcx.lub(false, trace).relate(&a, &b)\n+            } else {\n+                infcx.sub(false, trace).relate(&a, &b)\n+            }\n+        }).and_then(|ty| self.identity(ty))\n     }\n \n-    fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n-        F: FnOnce(Ty<'tcx>) -> T,\n-    {\n-        f(self.fcx.infcx().shallow_resolve(a))\n+    /// Synthesize an identity adjustment.\n+    fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        Ok((ty, AdjustDerefRef(AutoDerefRef {\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: None\n+        })))\n     }\n \n-    fn coerce(&self,\n-              expr_a: &hir::Expr,\n-              a: Ty<'tcx>,\n-              b: Ty<'tcx>)\n-              -> CoerceResult<'tcx> {\n-        debug!(\"Coerce.tys({:?} => {:?})\",\n-               a,\n-               b);\n+    fn coerce<'a, E, I>(&self,\n+                        exprs: &E,\n+                        a: Ty<'tcx>,\n+                        b: Ty<'tcx>)\n+                        -> CoerceResult<'tcx>\n+        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+        where E: Fn() -> I,\n+              I: IntoIterator<Item=&'a hir::Expr> {\n \n         let a = self.fcx.infcx().shallow_resolve(a);\n+        debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return Ok(None);\n+            return self.identity(b);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -134,43 +167,45 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n \n             ty::TyRef(_, mt_b) => {\n-                return self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl);\n+                return self.coerce_borrowed_pointer(exprs, a, b, mt_b.mutbl);\n             }\n \n             _ => {}\n         }\n \n         match a.sty {\n-            ty::TyBareFn(Some(_), a_f) => {\n+            ty::TyFnDef(_, _, a_f) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n                 self.coerce_from_fn_item(a, a_f, b)\n             }\n-            ty::TyBareFn(None, a_f) => {\n+            ty::TyFnPtr(a_f) => {\n                 // We permit coercion of fn pointers to drop the\n                 // unsafe qualifier.\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n             _ => {\n-                // Otherwise, just use subtyping rules.\n-                self.subtype(a, b)\n+                // Otherwise, just use unification rules.\n+                self.unify(a, b)\n             }\n         }\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_borrowed_pointer(&self,\n-                               expr_a: &hir::Expr,\n-                               a: Ty<'tcx>,\n-                               b: Ty<'tcx>,\n-                               mutbl_b: hir::Mutability)\n-                               -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\",\n-               a,\n-               b);\n+    fn coerce_borrowed_pointer<'a, E, I>(&self,\n+                                         exprs: &E,\n+                                         a: Ty<'tcx>,\n+                                         b: Ty<'tcx>,\n+                                         mutbl_b: hir::Mutability)\n+                                         -> CoerceResult<'tcx>\n+        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+        where E: Fn() -> I,\n+              I: IntoIterator<Item=&'a hir::Expr> {\n+\n+        debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -182,20 +217,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::TyRef(_, mt_a) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n             }\n-            _ => return self.subtype(a, b)\n+            _ => return self.unify(a, b)\n         }\n \n-        let coercion = Coercion(self.origin.span());\n+        let span = self.origin.span();\n+        let coercion = Coercion(span);\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let r_borrow = self.tcx().mk_region(r_borrow);\n         let autoref = Some(AutoPtr(r_borrow, mutbl_b));\n \n         let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n         let mut first_error = None;\n-        let (_, autoderefs, success) = autoderef(self.fcx,\n-                                                 expr_a.span,\n-                                                 a,\n-                                                 Some(expr_a),\n+        let (_, autoderefs, success) = autoderef(self.fcx, span, a, exprs,\n                                                  UnresolvedTypeAction::Ignore,\n                                                  lvalue_pref,\n                                                  |inner_ty, autoderef| {\n@@ -206,19 +239,20 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             let ty = self.tcx().mk_ref(r_borrow,\n                                         TypeAndMut {ty: inner_ty, mutbl: mutbl_b});\n-            if let Err(err) = self.subtype(ty, b) {\n-                if first_error.is_none() {\n-                    first_error = Some(err);\n+            match self.unify(ty, b) {\n+                Err(err) => {\n+                    if first_error.is_none() {\n+                        first_error = Some(err);\n+                    }\n+                    None\n                 }\n-                None\n-            } else {\n-                Some(())\n+                Ok((ty, _)) => Some(ty)\n             }\n         });\n \n         match success {\n-            Some(_) => {\n-                Ok(Some(AdjustDerefRef(AutoDerefRef {\n+            Some(ty) => {\n+                Ok((ty, AdjustDerefRef(AutoDerefRef {\n                     autoderefs: autoderefs,\n                     autoref: autoref,\n                     unsize: None\n@@ -329,17 +363,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         }\n \n-        let mut obligations = self.unsizing_obligations.borrow_mut();\n-        assert!(obligations.is_empty());\n-        *obligations = leftover_predicates;\n+        *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n \n         let adjustment = AutoDerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n             unsize: Some(target)\n         };\n         debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok(Some(AdjustDerefRef(adjustment)))\n+        Ok((target, AdjustDerefRef(adjustment)))\n     }\n \n     fn coerce_from_fn_pointer(&self,\n@@ -353,22 +385,21 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n          * into a closure or a `proc`.\n          */\n \n-        self.unpack_actual_value(b, |b| {\n-            debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\",\n-                   a, b);\n+        let b = self.fcx.infcx().shallow_resolve(b);\n+        debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n-            if let ty::TyBareFn(None, fn_ty_b) = b.sty {\n-                match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n-                    (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n-                        let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n-                        try!(self.subtype(unsafe_a, b));\n-                        return Ok(Some(AdjustUnsafeFnPointer));\n-                    }\n-                    _ => {}\n+        if let ty::TyFnPtr(fn_ty_b) = b.sty {\n+            match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n+                (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n+                    let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n+                    return self.unify(unsafe_a, b).map(|(ty, _)| {\n+                        (ty, AdjustUnsafeFnPointer)\n+                    });\n                 }\n+                _ => {}\n             }\n-            self.subtype(a, b)\n-        })\n+        }\n+        self.unify(a, b)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -381,19 +412,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n          * into a closure or a `proc`.\n          */\n \n-        self.unpack_actual_value(b, |b| {\n-            debug!(\"coerce_from_fn_item(a={:?}, b={:?})\",\n-                   a, b);\n+        let b = self.fcx.infcx().shallow_resolve(b);\n+        debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n-            match b.sty {\n-                ty::TyBareFn(None, _) => {\n-                    let a_fn_pointer = self.tcx().mk_fn(None, fn_ty_a);\n-                    try!(self.subtype(a_fn_pointer, b));\n-                    Ok(Some(AdjustReifyFnPointer))\n-                }\n-                _ => self.subtype(a, b)\n+        match b.sty {\n+            ty::TyFnPtr(_) => {\n+                let a_fn_pointer = self.tcx().mk_ty(ty::TyFnPtr(fn_ty_a));\n+                self.unify(a_fn_pointer, b).map(|(ty, _)| {\n+                    (ty, AdjustReifyFnPointer)\n+                })\n             }\n-        })\n+            _ => self.unify(a, b)\n+        }\n     }\n \n     fn coerce_unsafe_ptr(&self,\n@@ -409,74 +439,192 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.subtype(a, b);\n+                return self.unify(a, b);\n             }\n         };\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx().mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n-        try!(self.subtype(a_unsafe, b));\n+        let (ty, noop) = try!(self.unify(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        if is_ref {\n-            Ok(Some(AdjustDerefRef(AutoDerefRef {\n+        Ok((ty, if is_ref {\n+            AdjustDerefRef(AutoDerefRef {\n                 autoderefs: 1,\n                 autoref: Some(AutoUnsafe(mutbl_b)),\n                 unsize: None\n-            })))\n+            })\n         } else if mt_a.mutbl != mutbl_b {\n-            Ok(Some(AdjustMutToConstPointer))\n+            AdjustMutToConstPointer\n         } else {\n-            Ok(None)\n-        }\n+            noop\n+        }))\n     }\n }\n \n-pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                             expr: &hir::Expr,\n+fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n+                             exprs: &E,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n-                             -> RelateResult<'tcx, ()> {\n-    debug!(\"mk_assignty({:?} -> {:?})\", a, b);\n-    let mut unsizing_obligations = vec![];\n-    let adjustment = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|_| {\n-            let coerce = Coerce {\n-                fcx: fcx,\n-                origin: TypeOrigin::ExprAssignable(expr.span),\n-                unsizing_obligations: RefCell::new(vec![])\n-            };\n-            let adjustment = try!(coerce.coerce(expr, a, b));\n-            unsizing_obligations = coerce.unsizing_obligations.into_inner();\n-            Ok(adjustment)\n-        })\n-    }));\n+                             -> CoerceResult<'tcx>\n+    where E: Fn() -> I,\n+          I: IntoIterator<Item=&'b hir::Expr> {\n \n-    if let Some(AdjustDerefRef(auto)) = adjustment {\n+    let (ty, adjustment) = try!(indent(|| coerce.coerce(exprs, a, b)));\n+\n+    let fcx = coerce.fcx;\n+    if let AdjustDerefRef(auto) = adjustment {\n         if auto.unsize.is_some() {\n-            for obligation in unsizing_obligations {\n+            let mut obligations = coerce.unsizing_obligations.borrow_mut();\n+            for obligation in obligations.drain(..) {\n                 fcx.register_predicate(obligation);\n             }\n         }\n     }\n \n-    if let Some(adjustment) = adjustment {\n-        debug!(\"Success, coerced with {:?}\", adjustment);\n-        fcx.write_adjustment(expr.id, adjustment);\n-    }\n-    Ok(())\n+    Ok((ty, adjustment))\n }\n \n-fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n-                       to_mutbl: hir::Mutability)\n-                       -> CoerceResult<'tcx> {\n-    match (from_mutbl, to_mutbl) {\n-        (hir::MutMutable, hir::MutMutable) |\n-        (hir::MutImmutable, hir::MutImmutable) |\n-        (hir::MutMutable, hir::MutImmutable) => Ok(None),\n-        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability)\n+/// Attempt to coerce an expression to a type, and return the\n+/// adjusted type of the expression, if successful.\n+/// Adjustments are only recorded if the coercion succeeded.\n+/// The expressions *must not* have any pre-existing adjustments.\n+pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                     expr: &hir::Expr,\n+                     target: Ty<'tcx>)\n+                     -> RelateResult<'tcx, Ty<'tcx>> {\n+    let source = fcx.resolve_type_vars_if_possible(fcx.expr_ty(expr));\n+    debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n+\n+    let mut coerce = Coerce::new(fcx, TypeOrigin::ExprAssignable(expr.span));\n+    fcx.infcx().commit_if_ok(|_| {\n+        let (ty, adjustment) =\n+            try!(apply(&mut coerce, &|| Some(expr), source, target));\n+        if !adjustment.is_identity() {\n+            debug!(\"Success, coerced with {:?}\", adjustment);\n+            assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+            fcx.write_adjustment(expr.id, adjustment);\n+        }\n+        Ok(ty)\n+    })\n+}\n+\n+/// Given some expressions, their known unified type and another expression,\n+/// tries to unify the types, potentially inserting coercions on any of the\n+/// provided expressions and returns their LUB (aka \"common supertype\").\n+pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        origin: TypeOrigin,\n+                                        exprs: E,\n+                                        prev_ty: Ty<'tcx>,\n+                                        new: &'b hir::Expr)\n+                                        -> RelateResult<'tcx, Ty<'tcx>>\n+    // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+    where E: Fn() -> I,\n+          I: IntoIterator<Item=&'b hir::Expr> {\n+\n+    let prev_ty = fcx.resolve_type_vars_if_possible(prev_ty);\n+    let new_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(new));\n+    debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n+\n+    let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n+    let mut lub = fcx.infcx().lub(true, trace);\n+\n+    // Special-case that coercion alone cannot handle:\n+    // Two function item types of differing IDs or Substs.\n+    match (&prev_ty.sty, &new_ty.sty) {\n+        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n+         &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n+            // The signature must always match.\n+            let fty = try!(lub.relate(a_fty, b_fty));\n+\n+            if a_def_id == b_def_id {\n+                // Same function, maybe the parameters match.\n+                let substs = fcx.infcx().commit_if_ok(|_| {\n+                    relate_substs(&mut lub, None, a_substs, b_substs)\n+                }).map(|s| fcx.tcx().mk_substs(s));\n+\n+                if let Ok(substs) = substs {\n+                    // We have a LUB of prev_ty and new_ty, just return it.\n+                    return Ok(fcx.tcx().mk_fn_def(a_def_id, substs, fty));\n+                }\n+            }\n+\n+            // Reify both sides and return the reified fn pointer type.\n+            for expr in exprs().into_iter().chain(Some(new)) {\n+                // No adjustments can produce a fn item, so this should never trip.\n+                assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+                fcx.write_adjustment(expr.id, AdjustReifyFnPointer);\n+            }\n+            return Ok(fcx.tcx().mk_fn_ptr(fty));\n+        }\n+        _ => {}\n+    }\n+\n+    let mut coerce = Coerce::new(fcx, origin);\n+    coerce.use_lub = true;\n+\n+    // First try to coerce the new expression to the type of the previous ones,\n+    // but only if the new expression has no coercion already applied to it.\n+    let mut first_error = None;\n+    if !fcx.inh.tables.borrow().adjustments.contains_key(&new.id) {\n+        let result = fcx.infcx().commit_if_ok(|_| {\n+            apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n+        });\n+        match result {\n+            Ok((ty, adjustment)) => {\n+                if !adjustment.is_identity() {\n+                    fcx.write_adjustment(new.id, adjustment);\n+                }\n+                return Ok(ty);\n+            }\n+            Err(e) => first_error = Some(e)\n+        }\n+    }\n+\n+    // Then try to coerce the previous expressions to the type of the new one.\n+    // This requires ensuring there are no coercions applied to *any* of the\n+    // previous expressions, other than noop reborrows (ignoring lifetimes).\n+    for expr in exprs() {\n+        let noop = match fcx.inh.tables.borrow().adjustments.get(&expr.id) {\n+            Some(&AdjustDerefRef(AutoDerefRef {\n+                autoderefs: 1,\n+                autoref: Some(AutoPtr(_, mutbl_adj)),\n+                unsize: None\n+            })) => match fcx.expr_ty(expr).sty {\n+                ty::TyRef(_, mt_orig) => {\n+                    // Reborrow that we can safely ignore.\n+                    mutbl_adj == mt_orig.mutbl\n+                }\n+                _ => false\n+            },\n+            Some(_) => false,\n+            None => true\n+        };\n+\n+        if !noop {\n+            return fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty));\n+        }\n+    }\n+\n+    match fcx.infcx().commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+        Err(_) => {\n+            // Avoid giving strange errors on failed attempts.\n+            if let Some(e) = first_error {\n+                Err(e)\n+            } else {\n+                fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty))\n+            }\n+        }\n+        Ok((ty, adjustment)) => {\n+            if !adjustment.is_identity() {\n+                for expr in exprs() {\n+                    fcx.write_adjustment(expr.id, adjustment);\n+                }\n+            }\n+            Ok(ty)\n+        }\n     }\n }"}, {"sha": "ff7b809577f64a693f13d36fc1e7be3ac7efcea7", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -276,9 +276,9 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n     // type.\n \n     // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = tcx.mk_fn(None, tcx.mk_bare_fn(impl_m.fty.clone()));\n+    let impl_fty = tcx.mk_fn_ptr(impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-    let trait_fty = tcx.mk_fn(None, tcx.mk_bare_fn(trait_m.fty.clone()));\n+    let trait_fty = tcx.mk_fn_ptr(trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     let err = infcx.commit_if_ok(|snapshot| {\n@@ -296,11 +296,11 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n-        let impl_fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        let impl_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n             unsafety: impl_m.fty.unsafety,\n             abi: impl_m.fty.abi,\n             sig: ty::Binder(impl_sig)\n-        }));\n+        });\n         debug!(\"compare_impl_method: impl_fty={:?}\",\n                impl_fty);\n \n@@ -314,11 +314,11 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n-        let trait_fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        let trait_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n             unsafety: trait_m.fty.unsafety,\n             abi: trait_m.fty.abi,\n             sig: ty::Binder(trait_sig)\n-        }));\n+        });\n \n         debug!(\"compare_impl_method: trait_fty={:?}\",\n                trait_fty);"}, {"sha": "1f61198bef92134ffc9e39ef793dde2c2b647676", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -10,45 +10,27 @@\n \n \n use check::{coercion, FnCtxt};\n-use middle::ty::{self, Ty};\n-use middle::infer::{self, TypeOrigin};\n+use middle::ty::Ty;\n+use middle::infer::TypeOrigin;\n \n-use std::result::Result::{Err, Ok};\n use syntax::codemap::Span;\n use rustc_front::hir;\n \n // Requires that the two types unify, and prints an error message if\n // they don't.\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                         ty_expected: Ty<'tcx>, ty_actual: Ty<'tcx>) {\n-    suptype_with_fn(fcx, sp, false, ty_expected, ty_actual,\n-        |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n-}\n-\n-/// As `suptype`, but call `handle_err` if unification for subtyping fails.\n-pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                    sp: Span,\n-                                    b_is_expected: bool,\n-                                    ty_a: Ty<'tcx>,\n-                                    ty_b: Ty<'tcx>,\n-                                    handle_err: F) where\n-    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::error::TypeError<'tcx>),\n-{\n-    // n.b.: order of actual, expected is reversed\n-    match infer::mk_subty(fcx.infcx(), b_is_expected, TypeOrigin::Misc(sp),\n-                          ty_b, ty_a) {\n-      Ok(()) => { /* ok */ }\n-      Err(ref err) => {\n-          handle_err(sp, ty_a, ty_b, err);\n-      }\n+                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+    let origin = TypeOrigin::Misc(sp);\n+    if let Err(e) = fcx.infcx().sub_types(false, origin, actual, expected) {\n+        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n     }\n }\n \n pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    match infer::mk_eqty(fcx.infcx(), false, TypeOrigin::Misc(sp), actual, expected) {\n-        Ok(()) => { /* ok */ }\n-        Err(ref err) => { fcx.report_mismatched_types(sp, expected, actual, err); }\n+    let origin = TypeOrigin::Misc(sp);\n+    if let Err(e) = fcx.infcx().eq_types(false, origin, actual, expected) {\n+        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n     }\n }\n \n@@ -57,16 +39,10 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         sp: Span,\n                         expected: Ty<'tcx>,\n                         expr: &hir::Expr) {\n-    let expr_ty = fcx.expr_ty(expr);\n-    debug!(\"demand::coerce(expected = {:?}, expr_ty = {:?})\",\n-           expected,\n-           expr_ty);\n-    let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n-    match coercion::mk_assignty(fcx, expr, expr_ty, expected) {\n-      Ok(()) => { /* ok */ }\n-      Err(ref err) => {\n-        fcx.report_mismatched_types(sp, expected, expr_ty, err);\n-      }\n+    if let Err(e) = coercion::try(fcx, expr, expected) {\n+        let origin = TypeOrigin::Misc(sp);\n+        let expr_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(expr));\n+        fcx.infcx().report_mismatched_types(origin, expected, expr_ty, e);\n     }\n }"}, {"sha": "4ebe4c25dd1d3799f3c813f1045fa5ceeb93963c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -479,7 +479,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyBareFn(..) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             // FIXME(#26656): this type is always destruction-safe, but\n             // it implicitly witnesses Self: Fn, which can be false.\n             Ok(())"}, {"sha": "a05329bc4a4029b5636e69476453eb24dc5ac11c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -13,7 +13,7 @@\n \n use astconv::AstConv;\n use intrinsics;\n-use middle::subst;\n+use middle::subst::{self, Substs};\n use middle::ty::FnSig;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::fold::TypeFolder;\n@@ -33,16 +33,21 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: &TyCtxt<'tcx>, it: &hir::ForeignItem,\n                                    abi: Abi,\n                                    inputs: Vec<ty::Ty<'tcx>>,\n                                    output: ty::FnOutput<'tcx>) {\n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+    let def_id = tcx.map.local_def_id(it.id);\n+    let i_ty = tcx.lookup_item_type(def_id);\n+\n+    let mut substs = Substs::empty();\n+    substs.types = i_ty.generics.types.map(|def| tcx.mk_param_from_def(def));\n+\n+    let fty = tcx.mk_fn_def(def_id, tcx.mk_substs(substs), ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: abi,\n         sig: ty::Binder(FnSig {\n             inputs: inputs,\n             output: output,\n             variadic: false,\n         }),\n-    }));\n-    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n+    });\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,\n@@ -296,8 +301,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                         variadic: false,\n                     }),\n                 };\n-                let fn_ty = tcx.mk_bare_fn(fn_ty);\n-                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8, mut_u8], tcx.types.i32)\n+                (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n             ref other => {"}, {"sha": "f4268deee37c5a381517ba0a52feaf836ee1ed48", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 91, "deletions": 87, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -98,27 +98,29 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let InstantiatedMethodSig {\n             method_sig, all_substs, method_predicates\n         } = self.instantiate_method_sig(&pick, all_substs);\n+        let all_substs = self.tcx().mk_substs(all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Create the method type\n+        let def_id = pick.item.def_id();\n         let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = self.tcx().mk_fn(None, self.tcx().mk_bare_fn(ty::BareFnTy {\n+        let fty = self.tcx().mk_fn_def(def_id, all_substs, ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n-        }));\n+        });\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(fty, &all_substs, &method_predicates);\n+        self.add_obligations(fty, all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n         let callee = ty::MethodCallee {\n-            def_id: pick.item.def_id(),\n+            def_id: def_id,\n             ty: fty,\n-            substs: self.tcx().mk_substs(all_substs)\n+            substs: all_substs\n         };\n         // If this is an `&mut self` method, bias the receiver\n         // expression towards mutability (this will switch\n@@ -156,7 +158,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (autoderefd_ty, n, result) = check::autoderef(self.fcx,\n                                                           self.span,\n                                                           unadjusted_self_ty,\n-                                                          Some(self.self_expr),\n+                                                          || Some(self.self_expr),\n                                                           UnresolvedTypeAction::Error,\n                                                           NoPreference,\n                                                           |_, n| {\n@@ -285,7 +287,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (_, _, result) = check::autoderef(self.fcx,\n                                               self.span,\n                                               self_ty,\n-                                              None,\n+                                              || None,\n                                               UnresolvedTypeAction::Error,\n                                               NoPreference,\n                                               |ty, _| {\n@@ -457,7 +459,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn fixup_derefs_on_method_receiver_if_necessary(&self,\n                                                     method_callee: &ty::MethodCallee) {\n         let sig = match method_callee.ty.sty {\n-            ty::TyBareFn(_, ref f) => f.sig.clone(),\n+            ty::TyFnDef(_, _, ref f) => f.sig.clone(),\n             _ => return,\n         };\n \n@@ -507,7 +509,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n                                  self.fcx.expr_ty(expr),\n-                                 Some(expr),\n+                                 || Some(expr),\n                                  UnresolvedTypeAction::Error,\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n@@ -520,92 +522,94 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             }\n \n             // Don't retry the first one or we might infinite loop!\n-            if i != 0 {\n-                match expr.node {\n-                    hir::ExprIndex(ref base_expr, ref index_expr) => {\n-                        // If this is an overloaded index, the\n-                        // adjustment will include an extra layer of\n-                        // autoref because the method is an &self/&mut\n-                        // self method. We have to peel it off to get\n-                        // the raw adjustment that `try_index_step`\n-                        // expects. This is annoying and horrible. We\n-                        // ought to recode this routine so it doesn't\n-                        // (ab)use the normal type checking paths.\n-                        let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n-                                                                          .cloned();\n-                        let (autoderefs, unsize) = match adj {\n-                            Some(AdjustDerefRef(adr)) => match adr.autoref {\n-                                None => {\n-                                    assert!(adr.unsize.is_none());\n-                                    (adr.autoderefs, None)\n-                                }\n-                                Some(AutoPtr(_, _)) => {\n-                                    (adr.autoderefs, adr.unsize.map(|target| {\n-                                        target.builtin_deref(false, NoPreference)\n-                                              .expect(\"fixup: AutoPtr is not &T\").ty\n-                                    }))\n-                                }\n-                                Some(_) => {\n-                                    self.tcx().sess.span_bug(\n-                                        base_expr.span,\n-                                        &format!(\"unexpected adjustment autoref {:?}\",\n-                                                adr));\n-                                }\n-                            },\n-                            None => (0, None),\n+            if i == 0 {\n+                continue;\n+            }\n+            match expr.node {\n+                hir::ExprIndex(ref base_expr, ref index_expr) => {\n+                    // If this is an overloaded index, the\n+                    // adjustment will include an extra layer of\n+                    // autoref because the method is an &self/&mut\n+                    // self method. We have to peel it off to get\n+                    // the raw adjustment that `try_index_step`\n+                    // expects. This is annoying and horrible. We\n+                    // ought to recode this routine so it doesn't\n+                    // (ab)use the normal type checking paths.\n+                    let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n+                                                                        .cloned();\n+                    let (autoderefs, unsize) = match adj {\n+                        Some(AdjustDerefRef(adr)) => match adr.autoref {\n+                            None => {\n+                                assert!(adr.unsize.is_none());\n+                                (adr.autoderefs, None)\n+                            }\n+                            Some(AutoPtr(_, _)) => {\n+                                (adr.autoderefs, adr.unsize.map(|target| {\n+                                    target.builtin_deref(false, NoPreference)\n+                                            .expect(\"fixup: AutoPtr is not &T\").ty\n+                                }))\n+                            }\n                             Some(_) => {\n                                 self.tcx().sess.span_bug(\n                                     base_expr.span,\n-                                    \"unexpected adjustment type\");\n+                                    &format!(\"unexpected adjustment autoref {:?}\",\n+                                            adr));\n                             }\n-                        };\n-\n-                        let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n-                            (target, true)\n-                        } else {\n-                            (self.fcx.adjust_expr_ty(base_expr,\n-                                Some(&AdjustDerefRef(AutoDerefRef {\n-                                    autoderefs: autoderefs,\n-                                    autoref: None,\n-                                    unsize: None\n-                                }))), false)\n-                        };\n-                        let index_expr_ty = self.fcx.expr_ty(&index_expr);\n-\n-                        let result = check::try_index_step(\n-                            self.fcx,\n-                            ty::MethodCall::expr(expr.id),\n-                            expr,\n-                            &base_expr,\n-                            adjusted_base_ty,\n-                            autoderefs,\n-                            unsize,\n-                            PreferMutLvalue,\n-                            index_expr_ty);\n-\n-                        if let Some((input_ty, return_ty)) = result {\n-                            demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n-\n-                            let expr_ty = self.fcx.expr_ty(&expr);\n-                            demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n+                        },\n+                        None => (0, None),\n+                        Some(_) => {\n+                            self.tcx().sess.span_bug(\n+                                base_expr.span,\n+                                \"unexpected adjustment type\");\n                         }\n+                    };\n+\n+                    let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n+                        (target, true)\n+                    } else {\n+                        (self.fcx.adjust_expr_ty(base_expr,\n+                            Some(&AdjustDerefRef(AutoDerefRef {\n+                                autoderefs: autoderefs,\n+                                autoref: None,\n+                                unsize: None\n+                            }))), false)\n+                    };\n+                    let index_expr_ty = self.fcx.expr_ty(&index_expr);\n+\n+                    let result = check::try_index_step(\n+                        self.fcx,\n+                        ty::MethodCall::expr(expr.id),\n+                        expr,\n+                        &base_expr,\n+                        adjusted_base_ty,\n+                        autoderefs,\n+                        unsize,\n+                        PreferMutLvalue,\n+                        index_expr_ty);\n+\n+                    if let Some((input_ty, return_ty)) = result {\n+                        demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n+\n+                        let expr_ty = self.fcx.expr_ty(&expr);\n+                        demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                     }\n-                    hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n-                        // if this is an overloaded deref, then re-evaluate with\n-                        // a preference for mut\n-                        let method_call = ty::MethodCall::expr(expr.id);\n-                        if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n-                            check::try_overloaded_deref(\n-                                self.fcx,\n-                                expr.span,\n-                                Some(method_call),\n-                                Some(&base_expr),\n-                                self.fcx.expr_ty(&base_expr),\n-                                PreferMutLvalue);\n-                        }\n+                }\n+                hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n+                    // if this is an overloaded deref, then re-evaluate with\n+                    // a preference for mut\n+                    let method_call = ty::MethodCall::expr(expr.id);\n+                    if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n+                        let method = check::try_overloaded_deref(\n+                            self.fcx,\n+                            expr.span,\n+                            Some(&base_expr),\n+                            self.fcx.expr_ty(&base_expr),\n+                            PreferMutLvalue);\n+                        let method = method.expect(\"re-trying deref failed\");\n+                        self.fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n     }"}, {"sha": "e74623eda6d428afb46277a1f7a5a8801d586fa4", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -230,11 +230,12 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                                        &method_ty.fty.sig).0;\n     let fn_sig = fcx.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+    let def_id = method_item.def_id();\n+    let fty = tcx.mk_fn_def(def_id, trait_ref.substs, ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: method_ty.fty.unsafety,\n         abi: method_ty.fty.abi.clone(),\n-    }));\n+    });\n \n     debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n            fty,\n@@ -318,7 +319,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     let callee = ty::MethodCallee {\n-        def_id: method_item.def_id(),\n+        def_id: def_id,\n         ty: fty,\n         substs: trait_ref.substs\n     };"}, {"sha": "d11a07cb41ff77a3f28be6adb14899cc6a524525", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -200,7 +200,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let (final_ty, dereferences, _) = check::autoderef(fcx,\n                                                        span,\n                                                        self_ty,\n-                                                       None,\n+                                                       || None,\n                                                        UnresolvedTypeAction::Error,\n                                                        NoPreference,\n                                                        |t, d| {"}, {"sha": "7dc9d46c303f0c5271636286e57bd24b6b936004", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -101,7 +101,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     match field_ty.sty {\n                         // Not all of these (e.g. unsafe fns) implement FnOnce\n                         // so we look for these beforehand\n-                        ty::TyClosure(..) | ty::TyBareFn(..) => {\n+                        ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n                             span_stored_function!();\n                         }\n                         // If it's not a simple function, look for things which implement FnOnce\n@@ -351,7 +351,7 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         return is_local(fcx.resolve_type_vars_if_possible(rcvr_ty));\n     }\n \n-    check::autoderef(fcx, span, rcvr_ty, None,\n+    check::autoderef(fcx, span, rcvr_ty, || None,\n                      check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n                      |ty, _| {\n         if is_local(ty) {"}, {"sha": "0743c0b9e187b560da663928c4c773b9a7234e7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 173, "deletions": 184, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -89,7 +89,7 @@ use middle::cstore::LOCAL_CRATE;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::infer;\n-use middle::infer::{TypeOrigin, type_variable};\n+use middle::infer::{TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n@@ -101,6 +101,7 @@ use middle::ty::{MethodCall, MethodCallee};\n use middle::ty::adjustment;\n use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::relate::TypeRelation;\n use middle::ty::util::Representability;\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n@@ -434,7 +435,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n {\n     match raw_fty.sty {\n-        ty::TyBareFn(_, ref fn_ty) => {\n+        ty::TyFnDef(_, _, ref fn_ty) => {\n             let tables = RefCell::new(ty::Tables::empty());\n             let inh = Inherited::new(ccx.tcx, &tables, param_env);\n \n@@ -1622,14 +1623,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.infcx().type_error_struct(sp, mk_msg, actual_ty, err)\n     }\n \n-    pub fn report_mismatched_types(&self,\n-                                   sp: Span,\n-                                   e: Ty<'tcx>,\n-                                   a: Ty<'tcx>,\n-                                   err: &TypeError<'tcx>) {\n-        self.infcx().report_mismatched_types(sp, e, a, err)\n-    }\n-\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n@@ -1709,6 +1702,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // FIXME(arielb1): use this instead of field.ty everywhere\n+    // Only for fields! Returns <none> for methods>\n+    // Indifferent to privacy flags\n     pub fn field_ty(&self,\n                     span: Span,\n                     field: ty::FieldDef<'tcx>,\n@@ -1719,8 +1714,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                            &field.ty(self.tcx(), substs))\n     }\n \n-    // Only for fields! Returns <none> for methods>\n-    // Indifferent to privacy flags\n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n         for cast in deferred_cast_checks.drain(..) {\n@@ -2061,20 +2054,21 @@ pub enum UnresolvedTypeAction {\n ///\n /// Note: this method does not modify the adjustments table. The caller is responsible for\n /// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n-pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 sp: Span,\n-                                 base_ty: Ty<'tcx>,\n-                                 opt_expr: Option<&hir::Expr>,\n-                                 unresolved_type_action: UnresolvedTypeAction,\n-                                 mut lvalue_pref: LvaluePreference,\n-                                 mut should_stop: F)\n-                                 -> (Ty<'tcx>, usize, Option<T>)\n-    where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n+pub fn autoderef<'a, 'b, 'tcx, E, I, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                           sp: Span,\n+                                           base_ty: Ty<'tcx>,\n+                                           maybe_exprs: E,\n+                                           unresolved_type_action: UnresolvedTypeAction,\n+                                           mut lvalue_pref: LvaluePreference,\n+                                           mut should_stop: F)\n+                                           -> (Ty<'tcx>, usize, Option<T>)\n+    // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+    where E: Fn() -> I,\n+          I: IntoIterator<Item=&'b hir::Expr>,\n+          F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n-    debug!(\"autoderef(base_ty={:?}, opt_expr={:?}, lvalue_pref={:?})\",\n-           base_ty,\n-           opt_expr,\n-           lvalue_pref);\n+    debug!(\"autoderef(base_ty={:?}, lvalue_pref={:?})\",\n+           base_ty, lvalue_pref);\n \n     let mut t = base_ty;\n     for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n@@ -2087,7 +2081,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // (i.e. it is an inference variable) because `Ty::builtin_deref`\n                 // and `try_overloaded_deref` both simply return `None`\n                 // in such a case without producing spurious errors.\n-                fcx.resolve_type_vars_if_possible(t)\n+                fcx.infcx().resolve_type_vars_if_possible(&t)\n             }\n         };\n         if resolved_t.references_error() {\n@@ -2100,34 +2094,34 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let mt = match resolved_t.builtin_deref(false, lvalue_pref) {\n-            Some(mt) => Some(mt),\n-            None => {\n-                let method_call =\n-                    opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs as u32));\n-\n-                // Super subtle: it might seem as though we should\n-                // pass `opt_expr` to `try_overloaded_deref`, so that\n-                // the (implicit) autoref of using an overloaded deref\n-                // would get added to the adjustment table. However we\n-                // do not do that, because it's kind of a\n-                // \"meta-adjustment\" -- instead, we just leave it\n-                // unrecorded and know that there \"will be\" an\n-                // autoref. regionck and other bits of the code base,\n-                // when they encounter an overloaded autoderef, have\n-                // to do some reconstructive surgery. This is a pretty\n-                // complex mess that is begging for a proper MIR.\n-                try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n+\n+        // Super subtle: it might seem as though we should\n+        // pass `opt_expr` to `try_overloaded_deref`, so that\n+        // the (implicit) autoref of using an overloaded deref\n+        // would get added to the adjustment table. However we\n+        // do not do that, because it's kind of a\n+        // \"meta-adjustment\" -- instead, we just leave it\n+        // unrecorded and know that there \"will be\" an\n+        // autoref. regionck and other bits of the code base,\n+        // when they encounter an overloaded autoderef, have\n+        // to do some reconstructive surgery. This is a pretty\n+        // complex mess that is begging for a proper MIR.\n+        let mt = if let Some(mt) = resolved_t.builtin_deref(false, lvalue_pref) {\n+            mt\n+        } else if let Some(method) = try_overloaded_deref(fcx, sp, None,\n+                                                          resolved_t, lvalue_pref) {\n+            for expr in maybe_exprs() {\n+                let method_call = MethodCall::autoderef(expr.id, autoderefs as u32);\n+                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n+            make_overloaded_lvalue_return_type(fcx.tcx(), method)\n+        } else {\n+            return (resolved_t, autoderefs, None);\n         };\n-        match mt {\n-            Some(mt) => {\n-                t = mt.ty;\n-                if mt.mutbl == hir::MutImmutable {\n-                    lvalue_pref = NoPreference;\n-                }\n-            }\n-            None => return (resolved_t, autoderefs, None)\n+\n+        t = mt.ty;\n+        if mt.mutbl == hir::MutImmutable {\n+            lvalue_pref = NoPreference;\n         }\n     }\n \n@@ -2140,11 +2134,10 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   span: Span,\n-                                  method_call: Option<MethodCall>,\n                                   base_expr: Option<&hir::Expr>,\n                                   base_ty: Ty<'tcx>,\n                                   lvalue_pref: LvaluePreference)\n-                                  -> Option<ty::TypeAndMut<'tcx>>\n+                                  -> Option<MethodCallee<'tcx>>\n {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n@@ -2166,33 +2159,23 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (method, _) => method\n     };\n \n-    make_overloaded_lvalue_return_type(fcx, method_call, method)\n+    method\n }\n \n /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait returns a type of `&T`, but the\n /// actual type we assign to the *expression* is `T`. So this function just peels off the return\n-/// type by one layer to yield `T`. It also inserts the `method-callee` into the method map.\n-fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                method_call: Option<MethodCall>,\n-                                                method: Option<MethodCallee<'tcx>>)\n-                                                -> Option<ty::TypeAndMut<'tcx>>\n+/// type by one layer to yield `T`.\n+fn make_overloaded_lvalue_return_type<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                            method: MethodCallee<'tcx>)\n+                                            -> ty::TypeAndMut<'tcx>\n {\n-    match method {\n-        Some(method) => {\n-            // extract method return type, which will be &T;\n-            // all LB regions should have been instantiated during method lookup\n-            let ret_ty = method.ty.fn_ret();\n-            let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n-\n-            if let Some(method_call) = method_call {\n-                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n-            }\n+    // extract method return type, which will be &T;\n+    // all LB regions should have been instantiated during method lookup\n+    let ret_ty = method.ty.fn_ret();\n+    let ret_ty = tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n-            // method returns &T, but the type as visible to user is T, so deref\n-            ret_ty.builtin_deref(true, NoPreference)\n-        }\n-        None => None,\n-    }\n+    // method returns &T, but the type as visible to user is T, so deref\n+    ret_ty.builtin_deref(true, NoPreference).unwrap()\n }\n \n fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2210,7 +2193,7 @@ fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let (ty, autoderefs, final_mt) = autoderef(fcx,\n                                                base_expr.span,\n                                                base_ty,\n-                                               Some(base_expr),\n+                                               || Some(base_expr),\n                                                UnresolvedTypeAction::Error,\n                                                lvalue_pref,\n                                                |adj_ty, idx| {\n@@ -2307,10 +2290,10 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // If some lookup succeeds, write callee into table and extract index/element\n     // type from the method signature.\n     // If some lookup succeeded, install method in table\n-    method.and_then(|method| {\n+    method.map(|method| {\n         debug!(\"try_index_step: success, using overloaded indexing\");\n-        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method)).\n-            map(|ret| (input_ty, ret.ty))\n+        fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+        (input_ty, make_overloaded_lvalue_return_type(fcx.tcx(), method).ty)\n     })\n }\n \n@@ -2340,7 +2323,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::FnConverging(fcx.tcx().types.err)\n     } else {\n         match method_fn_ty.sty {\n-            ty::TyBareFn(_, ref fty) => {\n+            ty::TyFnDef(_, _, ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 let expected_arg_tys = expected_types_for_fn_args(fcx,\n                                                                   sp,\n@@ -2509,20 +2492,17 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     Expectation::rvalue_hint(fcx.tcx(), ty)\n                 });\n \n-                check_expr_with_unifier(fcx,\n-                                        &arg,\n-                                        expected.unwrap_or(ExpectHasType(formal_ty)),\n-                                        NoPreference, || {\n-                    // 2. Coerce to the most detailed type that could be coerced\n-                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                    //    `ExprHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                    let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n-                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &arg);\n-\n-                    // 3. Relate the expected type and the formal one,\n-                    //    if the expected type was used for the coercion.\n-                    coerce_ty.map(|ty| demand::suptype(fcx, arg.span, formal_ty, ty));\n-                });\n+                check_expr_with_expectation(fcx, &arg,\n+                    expected.unwrap_or(ExpectHasType(formal_ty)));\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n+                demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &arg);\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                coerce_ty.map(|ty| demand::suptype(fcx, arg.span, formal_ty, ty));\n             }\n \n             if let Some(&arg_ty) = fcx.inh.tables.borrow().node_types.get(&arg.id) {\n@@ -2619,7 +2599,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::TyInt(_) | ty::TyUint(_) => Some(ty),\n                     ty::TyChar => Some(tcx.types.u8),\n                     ty::TyRawPtr(..) => Some(tcx.types.usize),\n-                    ty::TyBareFn(..) => Some(tcx.types.usize),\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => Some(tcx.types.usize),\n                     _ => None\n                 }\n             });\n@@ -2644,57 +2624,42 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_expr_eq_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 expr: &'tcx hir::Expr,\n                                 expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || demand::eqtype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n+    check_expr_with_hint(fcx, expr, expected);\n+    demand::eqtype(fcx, expr.span, expected, fcx.expr_ty(expr));\n }\n \n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n+    check_expr_with_hint(fcx, expr, expected);\n+    demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n }\n \n fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           expr: &'tcx hir::Expr,\n                                           expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || demand::coerce(fcx, expr.span, expected, expr));\n+    check_expr_with_hint(fcx, expr, expected);\n+    demand::coerce(fcx, expr.span, expected, expr);\n }\n \n fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &'tcx hir::Expr,\n                                   expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || ())\n+    check_expr_with_expectation(fcx, expr, ExpectHasType(expected))\n }\n \n fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          expr: &'tcx hir::Expr,\n                                          expected: Expectation<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, expected, NoPreference,\n-        || ())\n-}\n-\n-fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                         expr: &'tcx hir::Expr,\n-                                                         expected: Expectation<'tcx>,\n-                                                         lvalue_pref: LvaluePreference)\n-{\n-    check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n+    check_expr_with_expectation_and_lvalue_pref(fcx, expr, expected, NoPreference)\n }\n \n fn check_expr<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx hir::Expr)  {\n-    check_expr_with_unifier(fcx, expr, NoExpectation, NoPreference, || ())\n+    check_expr_with_expectation(fcx, expr, NoExpectation)\n }\n \n fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx hir::Expr,\n                                         lvalue_pref: LvaluePreference)  {\n-    check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n+    check_expr_with_expectation_and_lvalue_pref(fcx, expr, NoExpectation, lvalue_pref)\n }\n \n // determine the `self` type, using fresh variables for all variables\n@@ -2796,13 +2761,10 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for `TyError`, so avoid\n /// that when err needs to be handled differently.\n-fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        expr: &'tcx hir::Expr,\n-                                        expected: Expectation<'tcx>,\n-                                        lvalue_pref: LvaluePreference,\n-                                        unifier: F) where\n-    F: FnOnce(),\n-{\n+fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                         expr: &'tcx hir::Expr,\n+                                                         expected: Expectation<'tcx>,\n+                                                         lvalue_pref: LvaluePreference) {\n     debug!(\">> typechecking: expr={:?} expected={:?}\",\n            expr, expected);\n \n@@ -2873,30 +2835,52 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_block_with_expected(fcx, then_blk, expected);\n         let then_ty = fcx.node_ty(then_blk.id);\n \n-        let branches_ty = match opt_else_expr {\n-            Some(ref else_expr) => {\n-                check_expr_with_expectation(fcx, &else_expr, expected);\n-                let else_ty = fcx.expr_ty(&else_expr);\n-                infer::common_supertype(fcx.infcx(),\n-                                        TypeOrigin::IfExpression(sp),\n-                                        true,\n-                                        then_ty,\n-                                        else_ty)\n-            }\n-            None => {\n-                infer::common_supertype(fcx.infcx(),\n-                                        TypeOrigin::IfExpressionWithNoElse(sp),\n-                                        false,\n-                                        then_ty,\n-                                        fcx.tcx().mk_nil())\n-            }\n-        };\n+        let unit = fcx.tcx().mk_nil();\n+        let (origin, expected, found, result) =\n+        if let Some(else_expr) = opt_else_expr {\n+            check_expr_with_expectation(fcx, else_expr, expected);\n+            let else_ty = fcx.expr_ty(else_expr);\n+            let origin = TypeOrigin::IfExpression(sp);\n+\n+            // Only try to coerce-unify if we have a then expression\n+            // to assign coercions to, otherwise it's () or diverging.\n+            let result = if let Some(ref then) = then_blk.expr {\n+                let res = coercion::try_find_lub(fcx, origin, || Some(&**then),\n+                                                 then_ty, else_expr);\n+\n+                // In case we did perform an adjustment, we have to update\n+                // the type of the block, because old trans still uses it.\n+                let adj = fcx.inh.tables.borrow().adjustments.get(&then.id).cloned();\n+                if res.is_ok() && adj.is_some() {\n+                    fcx.write_ty(then_blk.id, fcx.adjust_expr_ty(then, adj.as_ref()));\n+                }\n \n-        let cond_ty = fcx.expr_ty(cond_expr);\n-        let if_ty = if cond_ty.references_error() {\n-            fcx.tcx().types.err\n+                res\n+            } else {\n+                fcx.infcx().commit_if_ok(|_| {\n+                    let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n+                    fcx.infcx().lub(true, trace).relate(&then_ty, &else_ty)\n+                })\n+            };\n+            (origin, then_ty, else_ty, result)\n         } else {\n-            branches_ty\n+            let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n+            (origin, unit, then_ty,\n+             fcx.infcx().eq_types(true, origin, unit, then_ty).map(|_| unit))\n+        };\n+\n+        let if_ty = match result {\n+            Ok(ty) => {\n+                if fcx.expr_ty(cond_expr).references_error() {\n+                    fcx.tcx().types.err\n+                } else {\n+                    ty\n+                }\n+            }\n+            Err(e) => {\n+                fcx.infcx().report_mismatched_types(origin, expected, found, e);\n+                fcx.tcx().types.err\n+            }\n         };\n \n         fcx.write_ty(id, if_ty);\n@@ -2915,7 +2899,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n-                                                  Some(base),\n+                                                  || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n@@ -3013,7 +2997,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n-                                                  Some(base),\n+                                                  || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n@@ -3261,21 +3245,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             match unop {\n                 hir::UnDeref => {\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n-                    oprnd_t = match oprnd_t.builtin_deref(true, NoPreference) {\n-                        Some(mt) => mt.ty,\n-                        None => match try_overloaded_deref(fcx, expr.span,\n-                                                           Some(MethodCall::expr(expr.id)),\n-                                                           Some(&oprnd), oprnd_t, lvalue_pref) {\n-                            Some(mt) => mt.ty,\n-                            None => {\n-                                fcx.type_error_message(expr.span, |actual| {\n-                                    format!(\"type `{}` cannot be \\\n-                                            dereferenced\", actual)\n-                                }, oprnd_t, None);\n-                                tcx.types.err\n-                            }\n-                        }\n-                    };\n+\n+                    if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n+                        oprnd_t = mt.ty;\n+                    } else if let Some(method) = try_overloaded_deref(\n+                            fcx, expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n+                        oprnd_t = make_overloaded_lvalue_return_type(tcx, method).ty;\n+                        fcx.inh.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n+                                                                      method);\n+                    } else {\n+                        fcx.type_error_message(expr.span, |actual| {\n+                            format!(\"type `{}` cannot be \\\n+                                    dereferenced\", actual)\n+                        }, oprnd_t, None);\n+                        oprnd_t = tcx.types.err;\n+                    }\n                 }\n                 hir::UnNot => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n@@ -3519,7 +3503,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            let cast_check = cast::CastCheck::new((**e).clone(), t_expr, t_cast, expr.span);\n+            let cast_check = cast::CastCheck::new(e, t_expr, t_cast, expr.span);\n             deferred_cast_checks.push(cast_check);\n         }\n       }\n@@ -3536,23 +3520,30 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         });\n \n-        let typ = match uty {\n-            Some(uty) => {\n-                for e in args {\n-                    check_expr_coercable_to_type(fcx, &e, uty);\n-                }\n-                uty\n-            }\n-            None => {\n-                let t: Ty = fcx.infcx().next_ty_var();\n-                for e in args {\n-                    check_expr_has_type(fcx, &e, t);\n+        let mut unified = fcx.infcx().next_ty_var();\n+        let coerce_to = uty.unwrap_or(unified);\n+\n+        for (i, e) in args.iter().enumerate() {\n+            check_expr_with_hint(fcx, e, coerce_to);\n+            let e_ty = fcx.expr_ty(e);\n+            let origin = TypeOrigin::Misc(e.span);\n+\n+            // Special-case the first element, as it has no \"previous expressions\".\n+            let result = if i == 0 {\n+                coercion::try(fcx, e, coerce_to)\n+            } else {\n+                let prev_elems = || args[..i].iter().map(|e| &**e);\n+                coercion::try_find_lub(fcx, origin, prev_elems, unified, e)\n+            };\n+\n+            match result {\n+                Ok(ty) => unified = ty,\n+                Err(e) => {\n+                    fcx.infcx().report_mismatched_types(origin, unified, e_ty, e);\n                 }\n-                t\n             }\n-        };\n-        let typ = tcx.mk_array(typ, args.len());\n-        fcx.write_ty(id, typ);\n+        }\n+        fcx.write_ty(id, tcx.mk_array(unified, args.len()));\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &count_expr, tcx.types.usize);\n@@ -3680,8 +3671,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"... {:?}, expected is {:?}\",\n            fcx.expr_ty(expr),\n            expected);\n-\n-    unifier();\n }\n \n pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,"}, {"sha": "e428fc927f05cf925caded37c7dfa77a947a0c63", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -881,7 +881,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     _callee_expr: &hir::Expr) {\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     match callee_ty.sty {\n-        ty::TyBareFn(..) => { }\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n         _ => {\n             // this should not happen, but it does if the program is\n             // erroneous"}, {"sha": "a8ada8061317e2b229825df7ac27c67d5f9ddf9e", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -255,9 +255,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n-                ty::TyBareFn(_, ref bare_fn_ty) => bare_fn_ty,\n+                ty::TyFnDef(_, _, ref bare_fn_ty) => bare_fn_ty,\n                 _ => {\n-                    this.tcx().sess.span_bug(item.span, \"Fn item without bare fn type\");\n+                    this.tcx().sess.span_bug(item.span, \"Fn item without fn type\");\n                 }\n             };\n "}, {"sha": "cad321c0b237480f2a61478d3b65bda7a36b6a26", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -27,7 +27,7 @@ use middle::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n use middle::ty::{TyParam, TyRawPtr};\n use middle::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n use middle::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n-use middle::ty::{TyUint, TyClosure, TyBox, TyBareFn};\n+use middle::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use middle::ty::TyProjection;\n use middle::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n@@ -67,8 +67,8 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         }\n \n         TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-        TyStr | TyArray(..) | TySlice(..) | TyBareFn(..) | TyTuple(..) |\n-        TyParam(..) | TyError |\n+        TyStr | TyArray(..) | TySlice(..) | TyFnDef(..) | TyFnPtr(_) |\n+        TyTuple(..) | TyParam(..) | TyError |\n         TyRawPtr(_) | TyRef(_, _) | TyProjection(..) => {\n             None\n         }\n@@ -385,11 +385,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n \n+            let origin = TypeOrigin::Misc(span);\n             let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n                 if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                    infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n-                                                  target, &ty::error::TypeError::Mutability);\n+                    infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n+                                                  target, ty::error::TypeError::Mutability);\n                 }\n                 (mt_a.ty, mt_b.ty, unsize_trait, None)\n             };\n@@ -418,7 +419,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                         return;\n                     }\n \n-                    let origin = TypeOrigin::Misc(span);\n                     let fields = &def_a.struct_variant().fields;\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n                         let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));"}, {"sha": "3ce03e245785a55a7a50ffdcb7cc9852765f75b6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -543,6 +543,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               sig, untransformed_rcvr_ty);\n \n     let def_id = ccx.tcx.map.local_def_id(id);\n+    let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n+\n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n@@ -552,8 +554,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id,\n                                     container);\n \n-    let fty = ccx.tcx.mk_fn(Some(def_id),\n-                            ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n+    let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty.clone());\n     debug!(\"method {} (id {}) has type {:?}\",\n             name, id, fty);\n     ccx.tcx.register_item_type(def_id, TypeScheme {\n@@ -715,17 +716,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.register_item_type(def_id,\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n-            if let &Some(ref ast_trait_ref) = opt_trait_ref {\n-                tcx.impl_trait_refs.borrow_mut().insert(\n-                    def_id,\n-                    Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                             &ExplicitRscope,\n-                                                             ast_trait_ref,\n-                                                             Some(selfty)))\n-                        );\n-            } else {\n-                tcx.impl_trait_refs.borrow_mut().insert(def_id, None);\n-            }\n+            let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n+                astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                                                    &ExplicitRscope,\n+                                                    ast_trait_ref,\n+                                                    Some(selfty))\n+            });\n+            tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n             enforce_impl_params_are_constrained(tcx, generics, &mut ty_predicates, def_id);\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n@@ -902,7 +899,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(tcx, struct_def.id(), variant, scheme, predicates);\n+                convert_variant_ctor(ccx, struct_def.id(), variant, scheme, predicates);\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n@@ -920,11 +917,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     }\n }\n \n-fn convert_variant_ctor<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n                                   variant: ty::VariantDef<'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n+    let tcx = ccx.tcx;\n     let ctor_ty = match variant.kind() {\n         VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n@@ -933,9 +931,17 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n                 .iter()\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n-            tcx.mk_ctor_fn(tcx.map.local_def_id(ctor_id),\n-                           &inputs[..],\n-                           scheme.ty)\n+            let def_id = tcx.map.local_def_id(ctor_id);\n+            let substs = tcx.mk_substs(mk_item_substs(ccx, &scheme.generics));\n+            tcx.mk_fn_def(def_id, substs, ty::BareFnTy {\n+                unsafety: hir::Unsafety::Normal,\n+                abi: abi::Abi::Rust,\n+                sig: ty::Binder(ty::FnSig {\n+                    inputs: inputs,\n+                    output: ty::FnConverging(scheme.ty),\n+                    variadic: false\n+                })\n+            })\n         }\n     };\n     write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n@@ -961,7 +967,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n         convert_variant_ctor(\n-            ccx.tcx,\n+            ccx,\n             variant.node.data.id(),\n             ty_variant,\n             scheme.clone(),\n@@ -1436,7 +1442,9 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n-            let ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(it.id)), tcx.mk_bare_fn(tofd));\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            let substs = tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n+            let ty = tcx.mk_fn_def(def_id, substs, tofd);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemTy(ref t, ref generics) => {\n@@ -1556,7 +1564,9 @@ fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n {\n     match it.node {\n         hir::ForeignItemFn(ref fn_decl, ref generics) => {\n-            compute_type_scheme_of_foreign_fn_decl(ccx, fn_decl, generics, abi)\n+            compute_type_scheme_of_foreign_fn_decl(\n+                ccx, ccx.tcx.map.local_def_id(it.id),\n+                fn_decl, generics, abi)\n         }\n         hir::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n@@ -2107,6 +2117,7 @@ fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,\n \n fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n+    id: DefId,\n     decl: &hir::FnDecl,\n     ast_generics: &hir::Generics,\n     abi: abi::Abi)\n@@ -2140,14 +2151,14 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n             ty::FnDiverging\n     };\n \n-    let t_fn = ccx.tcx.mk_fn(None,\n-        ccx.tcx.mk_bare_fn(ty::BareFnTy {\n-            abi: abi,\n-            unsafety: hir::Unsafety::Unsafe,\n-            sig: ty::Binder(ty::FnSig {inputs: input_tys,\n-                                       output: output,\n-                                       variadic: decl.variadic}),\n-        }));\n+    let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n+    let t_fn = ccx.tcx.mk_fn_def(id, substs, ty::BareFnTy {\n+        abi: abi,\n+        unsafety: hir::Unsafety::Unsafe,\n+        sig: ty::Binder(ty::FnSig {inputs: input_tys,\n+                                    output: output,\n+                                    variadic: decl.variadic}),\n+    });\n \n     ty::TypeScheme {\n         generics: ty_generics,"}, {"sha": "907ee15c41ba0238ba1c6e3ad725f2c248ca29ab", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -72,7 +72,8 @@ fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n             parameters_for_regions_in_substs(&pi.trait_ref.substs),\n         ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n         ty::TyFloat(..) | ty::TyBox(..) | ty::TyStr |\n-        ty::TyArray(..) | ty::TySlice(..) | ty::TyBareFn(..) |\n+        ty::TyArray(..) | ty::TySlice(..) |\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) |\n         ty::TyTuple(..) | ty::TyRawPtr(..) |\n         ty::TyInfer(..) | ty::TyClosure(..) | ty::TyError =>\n             vec![]"}, {"sha": "035f8c60500228effcd27706afd5acbf75c19d02", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -103,7 +103,7 @@ use dep_graph::DepNode;\n use front::map as hir_map;\n use middle::def::Def;\n use middle::infer::{self, TypeOrigin};\n-use middle::subst;\n+use middle::subst::Substs;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use session::{config, CompileResult};\n use util::common::time;\n@@ -128,7 +128,7 @@ pub mod coherence;\n pub mod variance;\n \n pub struct TypeAndSubsts<'tcx> {\n-    pub substs: subst::Substs<'tcx>,\n+    pub substs: Substs<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n \n@@ -220,7 +220,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let main_t = tcx.node_id_to_type(main_id);\n     match main_t.sty {\n-        ty::TyBareFn(..) => {\n+        ty::TyFnDef(..) => {\n             match tcx.map.find(main_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n@@ -236,15 +236,16 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n             let main_def_id = tcx.map.local_def_id(main_id);\n-            let se_ty = tcx.mk_fn(Some(main_def_id), tcx.mk_bare_fn(ty::BareFnTy {\n+            let substs = tcx.mk_substs(Substs::empty());\n+            let se_ty = tcx.mk_fn_def(main_def_id, substs, ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(tcx.mk_nil()),\n                     variadic: false\n                 })\n-            }));\n+            });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n                 || {\n@@ -266,7 +267,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let start_t = tcx.node_id_to_type(start_id);\n     match start_t.sty {\n-        ty::TyBareFn(..) => {\n+        ty::TyFnDef(..) => {\n             match tcx.map.find(start_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n@@ -282,8 +283,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(start_id)),\n-                                  tcx.mk_bare_fn(ty::BareFnTy {\n+            let start_def_id = ccx.tcx.map.local_def_id(start_id);\n+            let substs = tcx.mk_substs(Substs::empty());\n+            let se_ty = tcx.mk_fn_def(start_def_id, substs, ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -294,7 +296,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                     output: ty::FnConverging(tcx.types.isize),\n                     variadic: false,\n                 }),\n-            }));\n+            });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n                 || {"}, {"sha": "aecc588c3e286c3bebdf3a2615341a942b08a590", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -429,7 +429,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyBareFn(_, &ty::BareFnTy { ref sig, .. }) => {\n+            ty::TyFnDef(_, _, &ty::BareFnTy { ref sig, .. }) |\n+            ty::TyFnPtr(&ty::BareFnTy { ref sig, .. }) => {\n                 self.add_constraints_from_sig(generics, sig, variance);\n             }\n "}, {"sha": "c14e4af810310ea58ab3066f2c35cac3fabb4f74", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -164,7 +164,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &TyCtxt,\n fn build_external_function(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::Function {\n     let t = tcx.lookup_item_type(did);\n     let (decl, style, abi) = match t.ty.sty {\n-        ty::TyBareFn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n+        ty::TyFnDef(_, _, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n "}, {"sha": "5921093bcac1e52be86b5dc3303e9bf491f6415e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -1663,7 +1663,8 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::TyBareFn(_, ref fty) => BareFunction(box BareFunctionDecl {\n+            ty::TyFnDef(_, _, ref fty) |\n+            ty::TyFnPtr(ref fty) => BareFunction(box BareFunctionDecl {\n                 unsafety: fty.unsafety,\n                 generics: Generics {\n                     lifetimes: Vec::new(),"}, {"sha": "4cb846b51868fc9d62ded630170e5a3e62d817af", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -14,26 +14,26 @@ pub mod testtypes {\n     use std::any::TypeId;\n \n     pub fn type_ids() -> Vec<TypeId> {\n-        let mut ids = vec!();\n-        ids.push(TypeId::of::<FooNil>());\n-        ids.push(TypeId::of::<FooBool>());\n-        ids.push(TypeId::of::<FooInt>());\n-        ids.push(TypeId::of::<FooUint>());\n-        ids.push(TypeId::of::<FooFloat>());\n-        ids.push(TypeId::of::<FooEnum>());\n-        ids.push(TypeId::of::<FooUniq>());\n-        ids.push(TypeId::of::<FooPtr>());\n-        ids.push(TypeId::of::<&'static FooTrait>());\n-        ids.push(TypeId::of::<FooStruct>());\n-        ids.push(TypeId::of::<FooTuple>());\n-        ids\n+        vec![\n+            TypeId::of::<FooBool>(),\n+            TypeId::of::<FooInt>(),\n+            TypeId::of::<FooUint>(),\n+            TypeId::of::<FooFloat>(),\n+            TypeId::of::<FooStr>(),\n+            TypeId::of::<FooArray>(),\n+            TypeId::of::<FooSlice>(),\n+            TypeId::of::<FooBox>(),\n+            TypeId::of::<FooPtr>(),\n+            TypeId::of::<FooRef>(),\n+            TypeId::of::<FooFnPtr>(),\n+            TypeId::of::<FooNil>(),\n+            TypeId::of::<FooTuple>(),\n+            TypeId::of::<FooTrait>(),\n+            TypeId::of::<FooStruct>(),\n+            TypeId::of::<FooEnum>()\n+        ]\n     }\n \n-    // Tests ty_nil\n-    pub type FooNil = ();\n-\n-    // Skipping ty_bot\n-\n     // Tests TyBool\n     pub type FooBool = bool;\n \n@@ -49,25 +49,26 @@ pub mod testtypes {\n     // Tests TyFloat (does not test all variants of FloatTy)\n     pub type FooFloat = f64;\n \n-    // For TyStr, what kind of string should I use? &'static str? String? Raw str?\n+    // Tests TyStr\n+    pub type FooStr = str;\n \n-    // Tests TyEnum\n-    pub enum FooEnum {\n-        VarA(usize),\n-        VarB(usize, usize)\n-    }\n+    // Tests TyArray\n+    pub type FooArray = [u8; 1];\n \n-    // Tests TyBox (of u8)\n-    pub type FooUniq = Box<u8>;\n+    // Tests TySlice\n+    pub type FooSlice = [u8];\n \n-    // As with TyStr, what type should be used for TyArray?\n+    // Tests TyBox (of u8)\n+    pub type FooBox = Box<u8>;\n \n     // Tests TyRawPtr\n     pub type FooPtr = *const u8;\n \n-    // Skipping TyRef\n+    // Tests TyRef\n+    pub type FooRef = &'static u8;\n \n-    // Skipping TyBareFn (how do you get a bare function type, rather than proc or closure?)\n+    // Tests TyFnPtr\n+    pub type FooFnPtr = fn(u8) -> bool;\n \n     // Tests TyTrait\n     pub trait FooTrait {\n@@ -80,14 +81,17 @@ pub mod testtypes {\n         foo_field: usize\n     }\n \n+    // Tests TyEnum\n+    pub enum FooEnum {\n+        VarA(usize),\n+        VarB(usize, usize)\n+    }\n+\n     // Tests TyTuple\n+    pub type FooNil = ();\n     pub type FooTuple = (u8, i8, bool);\n \n-    // Skipping ty_param\n-\n-    // Skipping ty_self\n-\n-    // Skipping ty_self\n+    // Skipping TyParam\n \n     // Skipping TyInfer\n "}, {"sha": "2fbd1ddb1e6b962f3ca6f79d3712d3a7e1ec557e", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -11,23 +11,37 @@\n // Test that the types of distinct fn items are not compatible by\n // default. See also `run-pass/fn-item-type-*.rs`.\n \n-fn foo(x: isize) -> isize { x * 2 }\n-fn bar(x: isize) -> isize { x * 4 }\n+fn foo<T>(x: isize) -> isize { x * 2 }\n+fn bar<T>(x: isize) -> isize { x * 4 }\n \n fn eq<T>(x: T, y: T) { }\n \n+trait Foo { fn foo() { /* this is a default fn */ } }\n+impl<T> Foo for T { /* `foo` is still default here */ }\n+\n fn main() {\n-    let f = if true { foo } else { bar };\n-    //~^ ERROR if and else have incompatible types\n-    //~| expected `fn(isize) -> isize {foo}`\n-    //~| found `fn(isize) -> isize {bar}`\n-    //~| expected fn item,\n-    //~| found a different fn item\n-\n-    eq(foo, bar);\n+    eq(foo::<u8>, bar::<u8>);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn(isize) -> isize {foo}`\n-    //~|  found `fn(isize) -> isize {bar}`\n+    //~|  expected `fn(isize) -> isize {foo::<u8>}`\n+    //~|  found `fn(isize) -> isize {bar::<u8>}`\n     //~|  expected fn item\n     //~|  found a different fn item\n+\n+    eq(foo::<u8>, foo::<i8>);\n+    //~^ ERROR mismatched types\n+    //~|  expected `fn(isize) -> isize {foo::<u8>}`\n+    //~|  found `fn(isize) -> isize {foo::<i8>}`\n+\n+    eq(bar::<String>, bar::<Vec<u8>>);\n+    //~^ ERROR mismatched types\n+    //~|  expected `fn(isize) -> isize {bar::<collections::string::String>}`\n+    //~|  found `fn(isize) -> isize {bar::<collections::vec::Vec<u8>>}`\n+    //~|  expected struct `collections::string::String`\n+    //~|  found struct `collections::vec::Vec`\n+\n+    // Make sure we distinguish between trait methods correctly.\n+    eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n+    //~^ ERROR mismatched types\n+    //~|  expected `fn() {Foo::foo}`\n+    //~|  found `fn() {Foo::foo}`\n }"}, {"sha": "2aa2546cb9fe124b0ca324be16ed9c3e430193df", "filename": "src/test/compile-fail/invalid-intrinsic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(intrinsics)]\n+extern \"rust-intrinsic\" {\n+    pub static breakpoint : unsafe extern \"rust-intrinsic\" fn();\n+    //~^ ERROR intrinsic has wrong type\n+}\n+fn main() { unsafe { breakpoint(); } }\n\\ No newline at end of file"}, {"sha": "e1fe2d06993d5ba4a21f4cddd18a3bf9713bccfa", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let y = match x {\n         [] => None,\n //~^ ERROR mismatched types\n-//~| expected `[_#0i; 2]`\n+//~| expected `[_#1i; 2]`\n //~| found `[_#7t; 0]`\n //~| expected an array with a fixed size of 2 elements\n //~| found one with 0 elements"}, {"sha": "787eb7a3b8878e362e49b12123d590a8fc03f608", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -107,7 +107,7 @@ impl Debug for Player {\n }\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n-    match to_parse {\n+    match to_parse { //~ ERROR match arms have incompatible types\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -116,7 +116,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"out\" => RoomDirection::Out,\n         \"up\" => RoomDirection::Up,\n         \"down\" => RoomDirection::Down,\n-        _ => None //~ ERROR mismatched types\n+        _ => None //~ NOTE match arm with an incompatible type\n     }\n }\n "}, {"sha": "9143a226a248355a8a932e859dea6b5e8809717b", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -21,5 +21,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR no method named `bind` found for type `[&str; 1]` in the current scope\n+    //~^ ERROR no method named `bind` found for type `[&'static str; 1]` in the current scope\n }"}, {"sha": "3eae76f9492a224e0b46e7bd03ee80e3f8277972", "filename": "src/test/compile-fail/transmute-from-fn-item-types-lint.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+unsafe fn foo() -> (isize, *const (), Option<fn()>) {\n+    let i = mem::transmute(bar);\n+    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ WARN was previously accepted\n+\n+    let p = mem::transmute(foo);\n+    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ WARN was previously accepted\n+\n+    let of = mem::transmute(main);\n+    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ WARN was previously accepted\n+\n+    (i, p, of)\n+}\n+\n+unsafe fn bar() {\n+    mem::transmute::<_, *mut ()>(foo);\n+    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ WARN was previously accepted\n+\n+    mem::transmute::<_, fn()>(bar);\n+    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ WARN was previously accepted\n+\n+    // No error if a coercion would otherwise occur.\n+    mem::transmute::<fn(), usize>(main);\n+\n+    // Error, still, if the resulting type is not pointer-sized.\n+    mem::transmute::<_, u8>(main);\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo();\n+        bar();\n+    }\n+}"}, {"sha": "1d5ebdbae3e2e959fa182046412a33f3bf7334a7", "filename": "src/test/compile-fail/variadic-ffi-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -22,7 +22,7 @@ fn main() {\n         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n         //~^ ERROR: mismatched types\n         //~| expected `unsafe extern \"C\" fn(isize, u8)`\n-        //~| found `unsafe extern \"C\" fn(isize, u8, ...)`\n+        //~| found `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n         //~| expected non-variadic fn\n         //~| found variadic function\n "}, {"sha": "0347631aeb336c99a765b3faea25fbf33c965799", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -86,8 +86,10 @@\n pub fn use_id() {\n     let _ =\n         ((id::<[i32; (3 as usize)]> as\n-             fn([i32; 3]) -> [i32; 3] {id})(([(1 as i32), (2 as i32),\n-                                              (3 as i32)] as [i32; 3])) as\n+             fn([i32; 3]) -> [i32; 3] {id::<[i32; 3]>})(([(1 as i32),\n+                                                          (2 as i32),\n+                                                          (3 as i32)] as\n+                                                            [i32; 3])) as\n             [i32; 3]);\n }\n fn main() { }"}, {"sha": "3d690146931d9cb8b461164ee3453222215e4b69", "filename": "src/test/run-pass/coerce-unify.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fcoerce-unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fcoerce-unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-unify.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that coercions can unify if-else, match arms and array elements.\n+\n+// Try to construct if-else chains, matches and arrays out of given expressions.\n+macro_rules! check {\n+    ($last:expr $(, $rest:expr)+) => {\n+        // Last expression comes first because of whacky ifs and matches.\n+        let _ = $(if false { $rest })else+ else { $last };\n+\n+        let _ = match 0 { $(_ if false => $rest,)+ _ => $last };\n+\n+        let _ = [$($rest,)+ $last];\n+    }\n+}\n+\n+// Check all non-uniform cases of 2 and 3 expressions of 2 types.\n+macro_rules! check2 {\n+    ($a:expr, $b:expr) => {\n+        check!($a, $b);\n+        check!($b, $a);\n+\n+        check!($a, $a, $b);\n+        check!($a, $b, $a);\n+        check!($a, $b, $b);\n+\n+        check!($b, $a, $a);\n+        check!($b, $a, $b);\n+        check!($b, $b, $a);\n+    }\n+}\n+\n+// Check all non-uniform cases of 2 and 3 expressions of 3 types.\n+macro_rules! check3 {\n+    ($a:expr, $b:expr, $c:expr) => {\n+        // Delegate to check2 for cases where a type repeats.\n+        check2!($a, $b);\n+        check2!($b, $c);\n+        check2!($a, $c);\n+\n+        // Check the remaining cases, i.e. permutations of ($a, $b, $c).\n+        check!($a, $b, $c);\n+        check!($a, $c, $b);\n+        check!($b, $a, $c);\n+        check!($b, $c, $a);\n+        check!($c, $a, $b);\n+        check!($c, $b, $a);\n+    }\n+}\n+\n+use std::mem::size_of;\n+\n+fn foo() {}\n+fn bar() {}\n+\n+pub fn main() {\n+    check3!(foo, bar, foo as fn());\n+    check3!(size_of::<u8>, size_of::<u16>, size_of::<usize> as fn() -> usize);\n+\n+    let s = String::from(\"bar\");\n+    check2!(\"foo\", &s);\n+\n+    let a = [1, 2, 3];\n+    let v = vec![1, 2, 3];\n+    check2!(&a[..], &v);\n+\n+    // Make sure in-array coercion still works.\n+    let _ = [(\"a\", Default::default()), (Default::default(), \"b\"), (&s, &s)];\n+}"}, {"sha": "fdaad9e1fabcea336bfe6290b9ca79a54c0c9376", "filename": "src/test/run-pass/enum-clike-ffi-as-int.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -25,16 +25,17 @@\n \n #[repr(u32)]\n enum Foo {\n-  A = 0,\n-  B = 23\n+    A = 0,\n+    B = 23\n }\n \n #[inline(never)]\n extern \"C\" fn foo(_x: usize) -> Foo { Foo::B }\n \n pub fn main() {\n-  unsafe {\n-    let f: extern \"C\" fn(usize) -> u32 = ::std::mem::transmute(foo);\n-    assert_eq!(f(0xDEADBEEF), Foo::B as u32);\n-  }\n+    unsafe {\n+        let f: extern \"C\" fn(usize) -> u32 =\n+            ::std::mem::transmute(foo as extern \"C\" fn(usize) -> Foo);\n+        assert_eq!(f(0xDEADBEEF), Foo::B as u32);\n+    }\n }"}, {"sha": "5fdaf083d078fa2d429be14b4a45261549629b37", "filename": "src/test/run-pass/fn-item-type-zero-sized.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Ffn-item-type-zero-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Ffn-item-type-zero-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-item-type-zero-sized.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that fn item types are zero-sized.\n+\n+use std::mem::{size_of, size_of_val};\n+\n+fn main() {\n+    assert_eq!(size_of_val(&main), 0);\n+\n+    let (a, b) = (size_of::<u8>, size_of::<u16>);\n+    assert_eq!(size_of_val(&a), 0);\n+    assert_eq!(size_of_val(&b), 0);\n+    assert_eq!((a(), b()), (1, 2));\n+}"}, {"sha": "084b7a166cdd36c4f9a24d18ec61996c5051216e", "filename": "src/test/run-pass/issue-13507-2.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fissue-13507-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fissue-13507-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13507-2.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -19,23 +19,29 @@ use issue13507::testtypes;\n use std::any::TypeId;\n \n pub fn type_ids() -> Vec<TypeId> {\n-    let mut ids = vec!();\n-    ids.push(TypeId::of::<testtypes::FooNil>());\n-    ids.push(TypeId::of::<testtypes::FooBool>());\n-    ids.push(TypeId::of::<testtypes::FooInt>());\n-    ids.push(TypeId::of::<testtypes::FooUint>());\n-    ids.push(TypeId::of::<testtypes::FooFloat>());\n-    ids.push(TypeId::of::<testtypes::FooEnum>());\n-    ids.push(TypeId::of::<testtypes::FooUniq>());\n-    ids.push(TypeId::of::<testtypes::FooPtr>());\n-    ids.push(TypeId::of::<&'static testtypes::FooTrait>());\n-    ids.push(TypeId::of::<testtypes::FooStruct>());\n-    ids.push(TypeId::of::<testtypes::FooTuple>());\n-    ids\n+    use issue13507::testtypes::*;\n+    vec![\n+        TypeId::of::<FooBool>(),\n+        TypeId::of::<FooInt>(),\n+        TypeId::of::<FooUint>(),\n+        TypeId::of::<FooFloat>(),\n+        TypeId::of::<FooStr>(),\n+        TypeId::of::<FooArray>(),\n+        TypeId::of::<FooSlice>(),\n+        TypeId::of::<FooBox>(),\n+        TypeId::of::<FooPtr>(),\n+        TypeId::of::<FooRef>(),\n+        TypeId::of::<FooFnPtr>(),\n+        TypeId::of::<FooNil>(),\n+        TypeId::of::<FooTuple>(),\n+        TypeId::of::<FooTrait>(),\n+        TypeId::of::<FooStruct>(),\n+        TypeId::of::<FooEnum>()\n+    ]\n }\n \n pub fn main() {\n-    let othercrate = testtypes::type_ids();\n+    let othercrate = issue13507::testtypes::type_ids();\n     let thiscrate = type_ids();\n     assert_eq!(thiscrate, othercrate);\n }"}, {"sha": "67baf2f9c49c190df6e4c089e6828bf4ba64a161", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -204,48 +204,41 @@ fn t24() -> fn(u8) -> S {\n     C4\n }\n \n-fn main(){\n-    unsafe {\n-        assert_eq!(t1()(), regular());\n-\n-        assert!(::std::mem::transmute::<_, *mut ()>(t2()) ==\n-                ::std::mem::transmute::<_, *mut ()>(E::U));\n-        assert!(::std::mem::transmute::<_, *mut ()>(t3()) ==\n-                ::std::mem::transmute::<_, *mut ()>(S));\n-\n-        assert_eq!(t4()(), S::hey());\n-        let s = S(42);\n-        assert_eq!(t5()(&s), <S as X>::hoy(&s));\n-\n-\n-        assert_eq!(t6()(), ext::regular_fn());\n-        assert!(::std::mem::transmute::<_, *mut ()>(t7()) ==\n-                ::std::mem::transmute::<_, *mut ()>(ext::E::U));\n-        assert!(::std::mem::transmute::<_, *mut ()>(t8()) ==\n-                ::std::mem::transmute::<_, *mut ()>(ext::S));\n-\n-        assert_eq!(t9()(), ext::S::hey());\n-        let sext = ext::S(6);\n-        assert_eq!(t10()(&sext), <ext::S as ext::X>::hoy(&sext));\n-\n-        let p = parametric::<u8>;\n-        assert!(::std::mem::transmute::<_, *mut ()>(t11()) ==\n-                ::std::mem::transmute::<_, *mut ()>(p));\n-\n-        assert_eq!(t12(), C);\n-        assert_eq!(t13(), C2);\n-        assert_eq!(t13_2(), C3);\n-\n-        assert_eq!(t14()(), <S as X>::hoy2());\n-        assert_eq!(t15()(&s), S::hey2(&s));\n-        assert_eq!(t16()(10u32, 20u32), F::f(10u32, 20u32));\n-        assert_eq!(t17()(30u32, 10u64), F::f(30u32, 10u64));\n-        assert_eq!(t18()(50u64, 5u64), F::f(50u64, 5u64));\n-        assert_eq!(t19()(322u64, 2u32), F::f(322u64, 2u32));\n-        assert_eq!(t20()(123u64, 38u32), <u32 as T<_, _>>::staticmeth(123, 38));\n-        assert_eq!(t21(), Unit);\n-        assert_eq!(t22(), None);\n-        assert_eq!(t23(), (CEnum::A, CEnum::B));\n-        assert_eq!(t24(), C4);\n-    }\n+fn main() {\n+    assert_eq!(t1()(), regular());\n+\n+    assert_eq!(t2() as *mut (), E::U as *mut ());\n+    assert_eq!(t3() as *mut (), S as *mut ());\n+\n+    assert_eq!(t4()(), S::hey());\n+    let s = S(42);\n+    assert_eq!(t5()(&s), <S as X>::hoy(&s));\n+\n+\n+    assert_eq!(t6()(), ext::regular_fn());\n+    assert_eq!(t7() as *mut (), ext::E::U as *mut ());\n+    assert_eq!(t8() as *mut (), ext::S as *mut ());\n+\n+    assert_eq!(t9()(), ext::S::hey());\n+    let sext = ext::S(6);\n+    assert_eq!(t10()(&sext), <ext::S as ext::X>::hoy(&sext));\n+\n+    let p = parametric::<u8>;\n+    assert_eq!(t11() as *mut (), p as *mut ());\n+\n+    assert_eq!(t12(), C);\n+    assert_eq!(t13(), C2);\n+    assert_eq!(t13_2(), C3);\n+\n+    assert_eq!(t14()(), <S as X>::hoy2());\n+    assert_eq!(t15()(&s), S::hey2(&s));\n+    assert_eq!(t16()(10u32, 20u32), F::f(10u32, 20u32));\n+    assert_eq!(t17()(30u32, 10u64), F::f(30u32, 10u64));\n+    assert_eq!(t18()(50u64, 5u64), F::f(50u64, 5u64));\n+    assert_eq!(t19()(322u64, 2u32), F::f(322u64, 2u32));\n+    assert_eq!(t20()(123u64, 38u32), <u32 as T<_, _>>::staticmeth(123, 38));\n+    assert_eq!(t21(), Unit);\n+    assert_eq!(t22(), None);\n+    assert_eq!(t23(), (CEnum::A, CEnum::B));\n+    assert_eq!(t24(), C4);\n }"}, {"sha": "2b7cf6c6682477bf890547c1bb854b9e96a8e425", "filename": "src/test/run-pass/nullable-pointer-ffi-compat.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -24,13 +24,14 @@\n use std::mem;\n \n #[inline(never)]\n-extern \"C\" fn foo<'a>(x: &'a isize) -> Option<&'a isize> { Some(x) }\n+extern \"C\" fn foo(x: &isize) -> Option<&isize> { Some(x) }\n \n static FOO: isize = 0xDEADBEE;\n \n pub fn main() {\n     unsafe {\n-        let f: for<'a> extern \"C\" fn(&'a isize) -> &'a isize = mem::transmute(foo);\n+        let f: extern \"C\" fn(&isize) -> &isize =\n+            mem::transmute(foo as extern \"C\" fn(&isize) -> Option<&isize>);\n         assert_eq!(*f(&FOO), FOO);\n     }\n }"}, {"sha": "dffdcfe0af562d5d4a59f4eba925f6e0f34e9ef2", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -12,8 +12,6 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::{option, mem};\n-\n // Iota-reduction is a rule in the Calculus of (Co-)Inductive Constructions,\n // which \"says that a destructor applied to an object built from a constructor\n // behaves as expected\".  -- http://coq.inria.fr/doc/Reference-Manual006.html\n@@ -43,9 +41,9 @@ macro_rules! check_option {\n         check_option!($e, $T, |ptr| assert_eq!(*ptr, $e));\n     }};\n     ($e:expr, $T:ty, |$v:ident| $chk:expr) => {{\n-        assert!(option::Option::None::<$T>.is_none());\n+        assert!(None::<$T>.is_none());\n         let e = $e;\n-        let s_ = option::Option::Some::<$T>(e);\n+        let s_ = Some::<$T>(e);\n         let $v = s_.as_ref().unwrap();\n         $chk\n     }}\n@@ -78,9 +76,8 @@ pub fn main() {\n     check_type!(&17, &isize);\n     check_type!(box 18, Box<isize>);\n     check_type!(\"foo\".to_string(), String);\n-    check_type!(vec!(20, 22), Vec<isize> );\n-    let mint: usize = unsafe { mem::transmute(main) };\n+    check_type!(vec!(20, 22), Vec<isize>);\n     check_type!(main, fn(), |pthing| {\n-        assert_eq!(mint, unsafe { mem::transmute(*pthing) })\n+        assert_eq!(main as fn(), *pthing as fn())\n     });\n }"}, {"sha": "574a90e2ad6972fd11de8f85c0d6d8c7c50ef0c4", "filename": "src/test/run-pass/transmute-from-fn-item-types.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Ftransmute-from-fn-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcda58f49133921abd091d7f800732fe2c4e5a98/src%2Ftest%2Frun-pass%2Ftransmute-from-fn-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftransmute-from-fn-item-types.rs?ref=bcda58f49133921abd091d7f800732fe2c4e5a98", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(transmute_from_fn_item_types)]\n+\n+use std::mem;\n+\n+fn main() {\n+    unsafe {\n+        let u = mem::transmute(main);\n+        let p = mem::transmute(main);\n+        let f = mem::transmute(main);\n+        let tuple: (usize, *mut (), fn()) = (u, p, f);\n+        assert_eq!(mem::transmute::<_, [usize; 3]>(tuple), [main as usize; 3]);\n+\n+        mem::transmute::<_, usize>(main);\n+        mem::transmute::<_, *mut ()>(main);\n+        mem::transmute::<_, fn()>(main);\n+    }\n+}"}]}