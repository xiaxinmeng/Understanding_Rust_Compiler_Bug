{"sha": "48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MTY3YzQ5OWFhOGFkOGQ3YjY0MWY3OWU2YWI5Y2MxNjNlYmM3ZGQ=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-02-14T05:28:34Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-04T18:01:22Z"}, "message": "Moved Context and its impls to a separate file", "tree": {"sha": "e3b9164be06d841c1149d7abe8e8f7f5b4b724ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b9164be06d841c1149d7abe8e8f7f5b4b724ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "html_url": "https://github.com/rust-lang/rust/commit/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec7f258d543e1ac7d0b94435972331e85da8c509", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7f258d543e1ac7d0b94435972331e85da8c509", "html_url": "https://github.com/rust-lang/rust/commit/ec7f258d543e1ac7d0b94435972331e85da8c509"}], "stats": {"total": 1211, "additions": 618, "deletions": 593}, "files": [{"sha": "1198df04abb62cf94a0e786fdab0fa34092a8f26", "filename": "src/librustdoc/html/render/context.rs", "status": "added", "additions": 611, "deletions": 0, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "patch": "@@ -0,0 +1,611 @@\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::io;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::mpsc::{channel, Receiver};\n+use std::sync::Arc;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n+use rustc_span::edition::Edition;\n+use rustc_span::source_map::FileName;\n+use rustc_span::symbol::sym;\n+\n+use super::cache::{build_index, ExternalLocation};\n+use super::{\n+    full_path, item_path, make_item_keywords, print_item, print_sidebar, settings, write_shared,\n+    AllTypes, NameDoc, SharedContext, StylePath, BASIC_KEYWORDS, CURRENT_DEPTH, INITIAL_IDS,\n+};\n+\n+use crate::clean::{self, AttributesExt};\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n+use crate::error::Error;\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::FormatRenderer;\n+use crate::html::escape::Escape;\n+use crate::html::format::Buffer;\n+use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n+use crate::html::{layout, sources};\n+\n+/// Major driving force in all rustdoc rendering. This contains information\n+/// about where in the tree-like hierarchy rendering is occurring and controls\n+/// how the current page is being rendered.\n+///\n+/// It is intended that this context is a lightweight object which can be fairly\n+/// easily cloned because it is cloned per work-job (about once per item in the\n+/// rustdoc tree).\n+#[derive(Clone)]\n+crate struct Context<'tcx> {\n+    /// Current hierarchy of components leading down to what's currently being\n+    /// rendered\n+    crate current: Vec<String>,\n+    /// The current destination folder of where HTML artifacts should be placed.\n+    /// This changes as the context descends into the module hierarchy.\n+    crate dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    crate render_redirect_pages: bool,\n+    /// `None` by default, depends on the `generate-redirect-map` option flag. If this field is set\n+    /// to `Some(...)`, it'll store redirections and then generate a JSON file at the top level of\n+    /// the crate.\n+    crate redirections: Option<Rc<RefCell<FxHashMap<String, String>>>>,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    pub(super) id_map: Rc<RefCell<IdMap>>,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    pub(super) deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n+    crate shared: Arc<SharedContext<'tcx>>,\n+    all: Rc<RefCell<AllTypes>>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    crate errors: Rc<Receiver<String>>,\n+    crate cache: Rc<Cache>,\n+}\n+\n+impl<'tcx> Context<'tcx> {\n+    pub(super) fn path(&self, filename: &str) -> PathBuf {\n+        // We use splitn vs Path::extension here because we might get a filename\n+        // like `style.min.css` and we want to process that into\n+        // `style-suffix.min.css`.  Path::extension would just return `css`\n+        // which would result in `style.min-suffix.css` which isn't what we\n+        // want.\n+        let (base, ext) = filename.split_once('.').unwrap();\n+        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n+        self.dst.join(&filename)\n+    }\n+\n+    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.shared.tcx\n+    }\n+\n+    fn sess(&self) -> &'tcx Session {\n+        &self.shared.tcx.sess\n+    }\n+\n+    pub(super) fn derive_id(&self, id: String) -> String {\n+        let mut map = self.id_map.borrow_mut();\n+        map.derive(id)\n+    }\n+\n+    /// String representation of how to get back to the root path of the 'doc/'\n+    /// folder in terms of a relative URL.\n+    pub(super) fn root_path(&self) -> String {\n+        \"../\".repeat(self.current.len())\n+    }\n+\n+    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n+        // A little unfortunate that this is done like this, but it sure\n+        // does make formatting *a lot* nicer.\n+        CURRENT_DEPTH.with(|slot| {\n+            slot.set(self.current.len());\n+        });\n+\n+        let mut title = if it.is_primitive() || it.is_keyword() {\n+            // No need to include the namespace for primitive types and keywords\n+            String::new()\n+        } else {\n+            self.current.join(\"::\")\n+        };\n+        if pushname {\n+            if !title.is_empty() {\n+                title.push_str(\"::\");\n+            }\n+            title.push_str(&it.name.unwrap().as_str());\n+        }\n+        title.push_str(\" - Rust\");\n+        let tyname = it.type_();\n+        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(&doc));\n+        let desc = if let Some(desc) = desc {\n+            desc\n+        } else if it.is_crate() {\n+            format!(\"API documentation for the Rust `{}` crate.\", self.shared.layout.krate)\n+        } else {\n+            format!(\n+                \"API documentation for the Rust `{}` {} in crate `{}`.\",\n+                it.name.as_ref().unwrap(),\n+                tyname,\n+                self.shared.layout.krate\n+            )\n+        };\n+        let keywords = make_item_keywords(it);\n+        let page = layout::Page {\n+            css_class: tyname.as_str(),\n+            root_path: &self.root_path(),\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            title: &title,\n+            description: &desc,\n+            keywords: &keywords,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+\n+        {\n+            self.id_map.borrow_mut().reset();\n+            self.id_map.borrow_mut().populate(&INITIAL_IDS);\n+        }\n+\n+        if !self.render_redirect_pages {\n+            layout::render(\n+                &self.shared.layout,\n+                &page,\n+                |buf: &mut _| print_sidebar(self, it, buf),\n+                |buf: &mut _| print_item(self, it, buf),\n+                &self.shared.style_files,\n+            )\n+        } else {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+                let mut path = String::new();\n+                for name in &names[..names.len() - 1] {\n+                    path.push_str(name);\n+                    path.push('/');\n+                }\n+                path.push_str(&item_path(ty, names.last().unwrap()));\n+                match self.redirections {\n+                    Some(ref redirections) => {\n+                        let mut current_path = String::new();\n+                        for name in &self.current {\n+                            current_path.push_str(name);\n+                            current_path.push('/');\n+                        }\n+                        current_path.push_str(&item_path(ty, names.last().unwrap()));\n+                        redirections.borrow_mut().insert(current_path, path);\n+                    }\n+                    None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),\n+                }\n+            }\n+            String::new()\n+        }\n+    }\n+\n+    /// Construct a map of items shown in the sidebar to a plain-text summary of their docs.\n+    fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n+        // BTreeMap instead of HashMap to get a sorted output\n+        let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n+        for item in &m.items {\n+            if item.is_stripped() {\n+                continue;\n+            }\n+\n+            let short = item.type_();\n+            let myname = match item.name {\n+                None => continue,\n+                Some(ref s) => s.to_string(),\n+            };\n+            let short = short.to_string();\n+            map.entry(short).or_default().push((\n+                myname,\n+                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n+            ));\n+        }\n+\n+        if self.shared.sort_modules_alphabetically {\n+            for items in map.values_mut() {\n+                items.sort();\n+            }\n+        }\n+        map\n+    }\n+\n+    /// Generates a url appropriate for an `href` attribute back to the source of\n+    /// this item.\n+    ///\n+    /// The url generated, when clicked, will redirect the browser back to the\n+    /// original source code.\n+    ///\n+    /// If `None` is returned, then a source link couldn't be generated. This\n+    /// may happen, for example, with externally inlined items where the source\n+    /// of their crate documentation isn't known.\n+    pub(super) fn src_href(&self, item: &clean::Item) -> Option<String> {\n+        if item.source.is_dummy() {\n+            return None;\n+        }\n+        let mut root = self.root_path();\n+        let mut path = String::new();\n+        let cnum = item.source.cnum(self.sess());\n+\n+        // We can safely ignore synthetic `SourceFile`s.\n+        let file = match item.source.filename(self.sess()) {\n+            FileName::Real(ref path) => path.local_path().to_path_buf(),\n+            _ => return None,\n+        };\n+        let file = &file;\n+\n+        let symbol;\n+        let (krate, path) = if cnum == LOCAL_CRATE {\n+            if let Some(path) = self.shared.local_sources.get(file) {\n+                (self.shared.layout.krate.as_str(), path)\n+            } else {\n+                return None;\n+            }\n+        } else {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n+                (name, ref src, ExternalLocation::Local) => (name, src),\n+                (name, ref src, ExternalLocation::Remote(ref s)) => {\n+                    root = s.to_string();\n+                    (name, src)\n+                }\n+                (_, _, ExternalLocation::Unknown) => return None,\n+            };\n+\n+            sources::clean_path(&src_root, file, false, |component| {\n+                path.push_str(&component.to_string_lossy());\n+                path.push('/');\n+            });\n+            let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n+            fname.push(\".html\");\n+            path.push_str(&fname.to_string_lossy());\n+            symbol = krate.as_str();\n+            (&*symbol, &path)\n+        };\n+\n+        let loline = item.source.lo(self.sess()).line;\n+        let hiline = item.source.hi(self.sess()).line;\n+        let lines =\n+            if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n+        Some(format!(\n+            \"{root}src/{krate}/{path}#{lines}\",\n+            root = Escape(&root),\n+            krate = krate,\n+            path = path,\n+            lines = lines\n+        ))\n+    }\n+}\n+\n+/// Generates the documentation for `crate` into the directory `dst`\n+impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n+    fn descr() -> &'static str {\n+        \"html\"\n+    }\n+\n+    fn init(\n+        mut krate: clean::Crate,\n+        options: RenderOptions,\n+        edition: Edition,\n+        mut cache: Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Result<(Self, clean::Crate), Error> {\n+        // need to save a copy of the options for rendering the index page\n+        let md_opts = options.clone();\n+        let RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            sort_modules_alphabetically,\n+            themes: style_files,\n+            default_settings,\n+            extension_css,\n+            resource_suffix,\n+            static_root_path,\n+            generate_search_filter,\n+            unstable_features,\n+            generate_redirect_map,\n+            ..\n+        } = options;\n+\n+        let src_root = match krate.src {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        };\n+        // If user passed in `--playground-url` arg, we fill in crate name here\n+        let mut playground = None;\n+        if let Some(url) = playground_url {\n+            playground =\n+                Some(markdown::Playground { crate_name: Some(krate.name.to_string()), url });\n+        }\n+        let mut layout = layout::Layout {\n+            logo: String::new(),\n+            favicon: String::new(),\n+            external_html,\n+            default_settings,\n+            krate: krate.name.to_string(),\n+            css_file_extension: extension_css,\n+            generate_search_filter,\n+        };\n+        let mut issue_tracker_base_url = None;\n+        let mut include_sources = true;\n+\n+        // Crawl the crate attributes looking for attributes which control how we're\n+        // going to emit HTML\n+        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+            for attr in attrs.lists(sym::doc) {\n+                match (attr.name_or_empty(), attr.value_str()) {\n+                    (sym::html_favicon_url, Some(s)) => {\n+                        layout.favicon = s.to_string();\n+                    }\n+                    (sym::html_logo_url, Some(s)) => {\n+                        layout.logo = s.to_string();\n+                    }\n+                    (sym::html_playground_url, Some(s)) => {\n+                        playground = Some(markdown::Playground {\n+                            crate_name: Some(krate.name.to_string()),\n+                            url: s.to_string(),\n+                        });\n+                    }\n+                    (sym::issue_tracker_base_url, Some(s)) => {\n+                        issue_tracker_base_url = Some(s.to_string());\n+                    }\n+                    (sym::html_no_source, None) if attr.is_word() => {\n+                        include_sources = false;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        let (sender, receiver) = channel();\n+        let mut scx = SharedContext {\n+            tcx,\n+            collapsed: krate.collapsed,\n+            src_root,\n+            include_sources,\n+            local_sources: Default::default(),\n+            issue_tracker_base_url,\n+            layout,\n+            created_dirs: Default::default(),\n+            sort_modules_alphabetically,\n+            style_files,\n+            resource_suffix,\n+            static_root_path,\n+            fs: DocFS::new(sender),\n+            edition,\n+            codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n+            playground,\n+        };\n+\n+        // Add the default themes to the `Vec` of stylepaths\n+        //\n+        // Note that these must be added before `sources::render` is called\n+        // so that the resulting source pages are styled\n+        //\n+        // `light.css` is not disabled because it is the stylesheet that stays loaded\n+        // by the browser as the theme stylesheet. The theme system (hackily) works by\n+        // changing the href to this stylesheet. All other themes are disabled to\n+        // prevent rule conflicts\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n+        let dst = output;\n+        scx.ensure_dir(&dst)?;\n+        krate = sources::render(&dst, &mut scx, krate)?;\n+\n+        // Build our search index\n+        let index = build_index(&krate, &mut cache, tcx);\n+\n+        let mut cx = Context {\n+            current: Vec::new(),\n+            dst,\n+            render_redirect_pages: false,\n+            id_map: Rc::new(RefCell::new(id_map)),\n+            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n+            shared: Arc::new(scx),\n+            all: Rc::new(RefCell::new(AllTypes::new())),\n+            errors: Rc::new(receiver),\n+            cache: Rc::new(cache),\n+            redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n+        };\n+\n+        CURRENT_DEPTH.with(|s| s.set(0));\n+\n+        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n+        write_shared(&cx, &krate, index, &md_opts)?;\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        Ok((cx, krate))\n+    }\n+\n+    fn after_krate(\n+        &mut self,\n+        krate: &clean::Crate,\n+        diag: &rustc_errors::Handler,\n+    ) -> Result<(), Error> {\n+        let final_file = self.dst.join(&*krate.name.as_str()).join(\"all.html\");\n+        let settings_file = self.dst.join(\"settings.html\");\n+        let crate_name = krate.name;\n+\n+        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n+        if !root_path.ends_with('/') {\n+            root_path.push('/');\n+        }\n+        let mut page = layout::Page {\n+            title: \"List of all items in this crate\",\n+            css_class: \"mod\",\n+            root_path: \"../\",\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            description: \"List of all items in this crate\",\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n+            format!(\n+                \"<p class=\\\"location\\\">Crate {}</p>\\\n+                     <div class=\\\"block version\\\">\\\n+                         <p>Version {}</p>\\\n+                     </div>\\\n+                     <a id=\\\"all-types\\\" href=\\\"index.html\\\"><p>Back to index</p></a>\",\n+                crate_name,\n+                Escape(version),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        let all = self.all.replace(AllTypes::new());\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            |buf: &mut Buffer| all.print(buf),\n+            &self.shared.style_files,\n+        );\n+        self.shared.fs.write(&final_file, v.as_bytes())?;\n+\n+        // Generating settings page.\n+        page.title = \"Rustdoc settings\";\n+        page.description = \"Settings of Rustdoc\";\n+        page.root_path = \"./\";\n+\n+        let mut style_files = self.shared.style_files.clone();\n+        let sidebar = \"<p class=\\\"location\\\">Settings</p><div class=\\\"sidebar-elems\\\"></div>\";\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            settings(\n+                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n+                &self.shared.resource_suffix,\n+                &self.shared.style_files,\n+            )?,\n+            &style_files,\n+        );\n+        self.shared.fs.write(&settings_file, v.as_bytes())?;\n+        if let Some(redirections) = self.redirections.take() {\n+            if !redirections.borrow().is_empty() {\n+                let redirect_map_path =\n+                    self.dst.join(&*krate.name.as_str()).join(\"redirect-map.json\");\n+                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n+                self.shared.ensure_dir(&self.dst.join(&*krate.name.as_str()))?;\n+                self.shared.fs.write(&redirect_map_path, paths.as_bytes())?;\n+            }\n+        }\n+\n+        // Flush pending errors.\n+        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n+        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n+        if nb_errors > 0 {\n+            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn mod_item_in(&mut self, item: &clean::Item, item_name: &str) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+        let scx = &self.shared;\n+        self.dst.push(item_name);\n+        self.current.push(item_name.to_owned());\n+\n+        info!(\"Recursing into {}\", self.dst.display());\n+\n+        let buf = self.render_item(item, false);\n+        // buf will be empty if the module is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(\"index.html\");\n+            scx.fs.write(&joint_dst, buf.as_bytes())?;\n+        }\n+\n+        // Render sidebar-items.js used throughout this module.\n+        if !self.render_redirect_pages {\n+            let module = match *item.kind {\n+                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n+                _ => unreachable!(),\n+            };\n+            let items = self.build_sidebar_items(module);\n+            let js_dst = self.dst.join(\"sidebar-items.js\");\n+            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            scx.fs.write(&js_dst, &v)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n+        info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+        // Go back to where we were at\n+        self.dst.pop();\n+        self.current.pop();\n+        Ok(())\n+    }\n+\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+\n+        let buf = self.render_item(&item, true);\n+        // buf will be empty if the item is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            let name = item.name.as_ref().unwrap();\n+            let item_type = item.type_();\n+            let file_name = &item_path(item_type, &name.as_str());\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(file_name);\n+            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n+\n+            if !self.render_redirect_pages {\n+                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+            }\n+            // If the item is a macro, redirect from the old macro URL (with !)\n+            // to the new one (without).\n+            if item_type == ItemType::Macro {\n+                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n+                if let Some(ref redirections) = self.redirections {\n+                    let crate_name = &self.shared.layout.krate;\n+                    redirections.borrow_mut().insert(\n+                        format!(\"{}/{}\", crate_name, redir_name),\n+                        format!(\"{}/{}\", crate_name, file_name),\n+                    );\n+                } else {\n+                    let v = layout::redirect(file_name);\n+                    let redir_dst = self.dst.join(redir_name);\n+                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n+}"}, {"sha": "17c32969e049ebad06ef9eb3e21bfaa9bbe18e59", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 7, "deletions": 593, "changes": 600, "blob_url": "https://github.com/rust-lang/rust/blob/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "patch": "@@ -30,21 +30,21 @@ crate mod cache;\n #[cfg(test)]\n mod tests;\n \n+mod context;\n+crate use context::*;\n+\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n-use std::collections::{BTreeMap, VecDeque};\n+use std::collections::VecDeque;\n use std::default::Default;\n use std::ffi::OsStr;\n use std::fmt::{self, Write};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Component, Path, PathBuf};\n-use std::rc::Rc;\n use std::str;\n use std::string::ToString;\n-use std::sync::mpsc::{channel, Receiver};\n-use std::sync::Arc;\n \n use itertools::Itertools;\n use rustc_ast_pretty::pprust;\n@@ -53,19 +53,17 @@ use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::FileName;\n use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, AttributesExt, GetDefId, RenderedLink, SelfTy, TypeKind};\n+use crate::clean::{self, GetDefId, RenderedLink, SelfTy, TypeKind};\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;\n@@ -76,12 +74,8 @@ use crate::html::escape::Escape;\n use crate::html::format::Function;\n use crate::html::format::{href, print_default_space, print_generic_bounds, WhereClause};\n use crate::html::format::{print_abi_with_space, Buffer, PrintWithSpace};\n-use crate::html::markdown::{\n-    self, plain_text_summary, ErrorCodes, IdMap, Markdown, MarkdownHtml, MarkdownSummaryLine,\n-};\n-use crate::html::sources;\n+use crate::html::markdown::{self, ErrorCodes, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use crate::html::{highlight, layout, static_files};\n-use cache::{build_index, ExternalLocation};\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -92,42 +86,6 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     })\n }\n \n-/// Major driving force in all rustdoc rendering. This contains information\n-/// about where in the tree-like hierarchy rendering is occurring and controls\n-/// how the current page is being rendered.\n-///\n-/// It is intended that this context is a lightweight object which can be fairly\n-/// easily cloned because it is cloned per work-job (about once per item in the\n-/// rustdoc tree).\n-#[derive(Clone)]\n-crate struct Context<'tcx> {\n-    /// Current hierarchy of components leading down to what's currently being\n-    /// rendered\n-    crate current: Vec<String>,\n-    /// The current destination folder of where HTML artifacts should be placed.\n-    /// This changes as the context descends into the module hierarchy.\n-    crate dst: PathBuf,\n-    /// A flag, which when `true`, will render pages which redirect to the\n-    /// real location of an item. This is used to allow external links to\n-    /// publicly reused items to redirect to the right location.\n-    crate render_redirect_pages: bool,\n-    /// `None` by default, depends on the `generate-redirect-map` option flag. If this field is set\n-    /// to `Some(...)`, it'll store redirections and then generate a JSON file at the top level of\n-    /// the crate.\n-    crate redirections: Option<Rc<RefCell<FxHashMap<String, String>>>>,\n-    /// The map used to ensure all generated 'id=' attributes are unique.\n-    id_map: Rc<RefCell<IdMap>>,\n-    /// Tracks section IDs for `Deref` targets so they match in both the main\n-    /// body and the sidebar.\n-    deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n-    crate shared: Arc<SharedContext<'tcx>>,\n-    all: Rc<RefCell<AllTypes>>,\n-    /// Storage for the errors produced while generating documentation so they\n-    /// can be printed together at the end.\n-    crate errors: Rc<Receiver<String>>,\n-    crate cache: Rc<Cache>,\n-}\n-\n crate struct SharedContext<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     /// The path to the crate root source minus the file name.\n@@ -169,27 +127,6 @@ crate struct SharedContext<'tcx> {\n     playground: Option<markdown::Playground>,\n }\n \n-impl<'tcx> Context<'tcx> {\n-    fn path(&self, filename: &str) -> PathBuf {\n-        // We use splitn vs Path::extension here because we might get a filename\n-        // like `style.min.css` and we want to process that into\n-        // `style-suffix.min.css`.  Path::extension would just return `css`\n-        // which would result in `style.min-suffix.css` which isn't what we\n-        // want.\n-        let (base, ext) = filename.split_once('.').unwrap();\n-        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n-        self.dst.join(&filename)\n-    }\n-\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.shared.tcx\n-    }\n-\n-    fn sess(&self) -> &'tcx Session {\n-        &self.shared.tcx.sess\n-    }\n-}\n-\n impl SharedContext<'_> {\n     crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n@@ -380,337 +317,6 @@ crate const INITIAL_IDS: [&'static str; 15] = [\n     \"implementations\",\n ];\n \n-/// Generates the documentation for `crate` into the directory `dst`\n-impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n-    fn descr() -> &'static str {\n-        \"html\"\n-    }\n-\n-    fn init(\n-        mut krate: clean::Crate,\n-        options: RenderOptions,\n-        edition: Edition,\n-        mut cache: Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Result<(Self, clean::Crate), Error> {\n-        // need to save a copy of the options for rendering the index page\n-        let md_opts = options.clone();\n-        let RenderOptions {\n-            output,\n-            external_html,\n-            id_map,\n-            playground_url,\n-            sort_modules_alphabetically,\n-            themes: style_files,\n-            default_settings,\n-            extension_css,\n-            resource_suffix,\n-            static_root_path,\n-            generate_search_filter,\n-            unstable_features,\n-            generate_redirect_map,\n-            ..\n-        } = options;\n-\n-        let src_root = match krate.src {\n-            FileName::Real(ref p) => match p.local_path().parent() {\n-                Some(p) => p.to_path_buf(),\n-                None => PathBuf::new(),\n-            },\n-            _ => PathBuf::new(),\n-        };\n-        // If user passed in `--playground-url` arg, we fill in crate name here\n-        let mut playground = None;\n-        if let Some(url) = playground_url {\n-            playground =\n-                Some(markdown::Playground { crate_name: Some(krate.name.to_string()), url });\n-        }\n-        let mut layout = layout::Layout {\n-            logo: String::new(),\n-            favicon: String::new(),\n-            external_html,\n-            default_settings,\n-            krate: krate.name.to_string(),\n-            css_file_extension: extension_css,\n-            generate_search_filter,\n-        };\n-        let mut issue_tracker_base_url = None;\n-        let mut include_sources = true;\n-\n-        // Crawl the crate attributes looking for attributes which control how we're\n-        // going to emit HTML\n-        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-            for attr in attrs.lists(sym::doc) {\n-                match (attr.name_or_empty(), attr.value_str()) {\n-                    (sym::html_favicon_url, Some(s)) => {\n-                        layout.favicon = s.to_string();\n-                    }\n-                    (sym::html_logo_url, Some(s)) => {\n-                        layout.logo = s.to_string();\n-                    }\n-                    (sym::html_playground_url, Some(s)) => {\n-                        playground = Some(markdown::Playground {\n-                            crate_name: Some(krate.name.to_string()),\n-                            url: s.to_string(),\n-                        });\n-                    }\n-                    (sym::issue_tracker_base_url, Some(s)) => {\n-                        issue_tracker_base_url = Some(s.to_string());\n-                    }\n-                    (sym::html_no_source, None) if attr.is_word() => {\n-                        include_sources = false;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        let (sender, receiver) = channel();\n-        let mut scx = SharedContext {\n-            tcx,\n-            collapsed: krate.collapsed,\n-            src_root,\n-            include_sources,\n-            local_sources: Default::default(),\n-            issue_tracker_base_url,\n-            layout,\n-            created_dirs: Default::default(),\n-            sort_modules_alphabetically,\n-            style_files,\n-            resource_suffix,\n-            static_root_path,\n-            fs: DocFS::new(sender),\n-            edition,\n-            codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n-            playground,\n-        };\n-\n-        // Add the default themes to the `Vec` of stylepaths\n-        //\n-        // Note that these must be added before `sources::render` is called\n-        // so that the resulting source pages are styled\n-        //\n-        // `light.css` is not disabled because it is the stylesheet that stays loaded\n-        // by the browser as the theme stylesheet. The theme system (hackily) works by\n-        // changing the href to this stylesheet. All other themes are disabled to\n-        // prevent rule conflicts\n-        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n-        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n-        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n-\n-        let dst = output;\n-        scx.ensure_dir(&dst)?;\n-        krate = sources::render(&dst, &mut scx, krate)?;\n-\n-        // Build our search index\n-        let index = build_index(&krate, &mut cache, tcx);\n-\n-        let mut cx = Context {\n-            current: Vec::new(),\n-            dst,\n-            render_redirect_pages: false,\n-            id_map: Rc::new(RefCell::new(id_map)),\n-            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n-            shared: Arc::new(scx),\n-            all: Rc::new(RefCell::new(AllTypes::new())),\n-            errors: Rc::new(receiver),\n-            cache: Rc::new(cache),\n-            redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n-        };\n-\n-        CURRENT_DEPTH.with(|s| s.set(0));\n-\n-        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n-        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-        write_shared(&cx, &krate, index, &md_opts)?;\n-        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n-        Ok((cx, krate))\n-    }\n-\n-    fn after_krate(\n-        &mut self,\n-        krate: &clean::Crate,\n-        diag: &rustc_errors::Handler,\n-    ) -> Result<(), Error> {\n-        let final_file = self.dst.join(&*krate.name.as_str()).join(\"all.html\");\n-        let settings_file = self.dst.join(\"settings.html\");\n-        let crate_name = krate.name;\n-\n-        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n-        if !root_path.ends_with('/') {\n-            root_path.push('/');\n-        }\n-        let mut page = layout::Page {\n-            title: \"List of all items in this crate\",\n-            css_class: \"mod\",\n-            root_path: \"../\",\n-            static_root_path: self.shared.static_root_path.as_deref(),\n-            description: \"List of all items in this crate\",\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.shared.resource_suffix,\n-            extra_scripts: &[],\n-            static_extra_scripts: &[],\n-        };\n-        let sidebar = if let Some(ref version) = self.cache.crate_version {\n-            format!(\n-                \"<p class=\\\"location\\\">Crate {}</p>\\\n-                     <div class=\\\"block version\\\">\\\n-                         <p>Version {}</p>\\\n-                     </div>\\\n-                     <a id=\\\"all-types\\\" href=\\\"index.html\\\"><p>Back to index</p></a>\",\n-                crate_name,\n-                Escape(version),\n-            )\n-        } else {\n-            String::new()\n-        };\n-        let all = self.all.replace(AllTypes::new());\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            |buf: &mut Buffer| all.print(buf),\n-            &self.shared.style_files,\n-        );\n-        self.shared.fs.write(&final_file, v.as_bytes())?;\n-\n-        // Generating settings page.\n-        page.title = \"Rustdoc settings\";\n-        page.description = \"Settings of Rustdoc\";\n-        page.root_path = \"./\";\n-\n-        let mut style_files = self.shared.style_files.clone();\n-        let sidebar = \"<p class=\\\"location\\\">Settings</p><div class=\\\"sidebar-elems\\\"></div>\";\n-        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            settings(\n-                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n-                &self.shared.resource_suffix,\n-                &self.shared.style_files,\n-            )?,\n-            &style_files,\n-        );\n-        self.shared.fs.write(&settings_file, v.as_bytes())?;\n-        if let Some(redirections) = self.redirections.take() {\n-            if !redirections.borrow().is_empty() {\n-                let redirect_map_path =\n-                    self.dst.join(&*krate.name.as_str()).join(\"redirect-map.json\");\n-                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n-                self.shared.ensure_dir(&self.dst.join(&*krate.name.as_str()))?;\n-                self.shared.fs.write(&redirect_map_path, paths.as_bytes())?;\n-            }\n-        }\n-\n-        // Flush pending errors.\n-        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n-        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n-        if nb_errors > 0 {\n-            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn mod_item_in(&mut self, item: &clean::Item, item_name: &str) -> Result<(), Error> {\n-        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n-        // if they contain impls for public types. These modules can also\n-        // contain items such as publicly re-exported structures.\n-        //\n-        // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally\n-        // (a flag on the context).\n-        if !self.render_redirect_pages {\n-            self.render_redirect_pages = item.is_stripped();\n-        }\n-        let scx = &self.shared;\n-        self.dst.push(item_name);\n-        self.current.push(item_name.to_owned());\n-\n-        info!(\"Recursing into {}\", self.dst.display());\n-\n-        let buf = self.render_item(item, false);\n-        // buf will be empty if the module is stripped and there is no redirect for it\n-        if !buf.is_empty() {\n-            self.shared.ensure_dir(&self.dst)?;\n-            let joint_dst = self.dst.join(\"index.html\");\n-            scx.fs.write(&joint_dst, buf.as_bytes())?;\n-        }\n-\n-        // Render sidebar-items.js used throughout this module.\n-        if !self.render_redirect_pages {\n-            let module = match *item.kind {\n-                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n-                _ => unreachable!(),\n-            };\n-            let items = self.build_sidebar_items(module);\n-            let js_dst = self.dst.join(\"sidebar-items.js\");\n-            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n-            scx.fs.write(&js_dst, &v)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n-        info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-        // Go back to where we were at\n-        self.dst.pop();\n-        self.current.pop();\n-        Ok(())\n-    }\n-\n-    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n-        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n-        // if they contain impls for public types. These modules can also\n-        // contain items such as publicly re-exported structures.\n-        //\n-        // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally\n-        // (a flag on the context).\n-        if !self.render_redirect_pages {\n-            self.render_redirect_pages = item.is_stripped();\n-        }\n-\n-        let buf = self.render_item(&item, true);\n-        // buf will be empty if the item is stripped and there is no redirect for it\n-        if !buf.is_empty() {\n-            let name = item.name.as_ref().unwrap();\n-            let item_type = item.type_();\n-            let file_name = &item_path(item_type, &name.as_str());\n-            self.shared.ensure_dir(&self.dst)?;\n-            let joint_dst = self.dst.join(file_name);\n-            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n-\n-            if !self.render_redirect_pages {\n-                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n-            }\n-            // If the item is a macro, redirect from the old macro URL (with !)\n-            // to the new one (without).\n-            if item_type == ItemType::Macro {\n-                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n-                if let Some(ref redirections) = self.redirections {\n-                    let crate_name = &self.shared.layout.krate;\n-                    redirections.borrow_mut().insert(\n-                        format!(\"{}/{}\", crate_name, redir_name),\n-                        format!(\"{}/{}\", crate_name, file_name),\n-                    );\n-                } else {\n-                    let v = layout::redirect(file_name);\n-                    let redir_dst = self.dst.join(redir_name);\n-                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn cache(&self) -> &Cache {\n-        &self.cache\n-    }\n-}\n-\n fn write_shared(\n     cx: &Context<'_>,\n     krate: &clean::Crate,\n@@ -1541,198 +1147,6 @@ fn settings(root_path: &str, suffix: &str, themes: &[StylePath]) -> Result<Strin\n     ))\n }\n \n-impl Context<'_> {\n-    fn derive_id(&self, id: String) -> String {\n-        let mut map = self.id_map.borrow_mut();\n-        map.derive(id)\n-    }\n-\n-    /// String representation of how to get back to the root path of the 'doc/'\n-    /// folder in terms of a relative URL.\n-    fn root_path(&self) -> String {\n-        \"../\".repeat(self.current.len())\n-    }\n-\n-    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n-        // A little unfortunate that this is done like this, but it sure\n-        // does make formatting *a lot* nicer.\n-        CURRENT_DEPTH.with(|slot| {\n-            slot.set(self.current.len());\n-        });\n-\n-        let mut title = if it.is_primitive() || it.is_keyword() {\n-            // No need to include the namespace for primitive types and keywords\n-            String::new()\n-        } else {\n-            self.current.join(\"::\")\n-        };\n-        if pushname {\n-            if !title.is_empty() {\n-                title.push_str(\"::\");\n-            }\n-            title.push_str(&it.name.unwrap().as_str());\n-        }\n-        title.push_str(\" - Rust\");\n-        let tyname = it.type_();\n-        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(&doc));\n-        let desc = if let Some(desc) = desc {\n-            desc\n-        } else if it.is_crate() {\n-            format!(\"API documentation for the Rust `{}` crate.\", self.shared.layout.krate)\n-        } else {\n-            format!(\n-                \"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                it.name.as_ref().unwrap(),\n-                tyname,\n-                self.shared.layout.krate\n-            )\n-        };\n-        let keywords = make_item_keywords(it);\n-        let page = layout::Page {\n-            css_class: tyname.as_str(),\n-            root_path: &self.root_path(),\n-            static_root_path: self.shared.static_root_path.as_deref(),\n-            title: &title,\n-            description: &desc,\n-            keywords: &keywords,\n-            resource_suffix: &self.shared.resource_suffix,\n-            extra_scripts: &[],\n-            static_extra_scripts: &[],\n-        };\n-\n-        {\n-            self.id_map.borrow_mut().reset();\n-            self.id_map.borrow_mut().populate(&INITIAL_IDS);\n-        }\n-\n-        if !self.render_redirect_pages {\n-            layout::render(\n-                &self.shared.layout,\n-                &page,\n-                |buf: &mut _| print_sidebar(self, it, buf),\n-                |buf: &mut _| print_item(self, it, buf),\n-                &self.shared.style_files,\n-            )\n-        } else {\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n-                let mut path = String::new();\n-                for name in &names[..names.len() - 1] {\n-                    path.push_str(name);\n-                    path.push('/');\n-                }\n-                path.push_str(&item_path(ty, names.last().unwrap()));\n-                match self.redirections {\n-                    Some(ref redirections) => {\n-                        let mut current_path = String::new();\n-                        for name in &self.current {\n-                            current_path.push_str(name);\n-                            current_path.push('/');\n-                        }\n-                        current_path.push_str(&item_path(ty, names.last().unwrap()));\n-                        redirections.borrow_mut().insert(current_path, path);\n-                    }\n-                    None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),\n-                }\n-            }\n-            String::new()\n-        }\n-    }\n-\n-    /// Construct a map of items shown in the sidebar to a plain-text summary of their docs.\n-    fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n-        // BTreeMap instead of HashMap to get a sorted output\n-        let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n-        for item in &m.items {\n-            if item.is_stripped() {\n-                continue;\n-            }\n-\n-            let short = item.type_();\n-            let myname = match item.name {\n-                None => continue,\n-                Some(ref s) => s.to_string(),\n-            };\n-            let short = short.to_string();\n-            map.entry(short).or_default().push((\n-                myname,\n-                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n-            ));\n-        }\n-\n-        if self.shared.sort_modules_alphabetically {\n-            for items in map.values_mut() {\n-                items.sort();\n-            }\n-        }\n-        map\n-    }\n-\n-    /// Generates a url appropriate for an `href` attribute back to the source of\n-    /// this item.\n-    ///\n-    /// The url generated, when clicked, will redirect the browser back to the\n-    /// original source code.\n-    ///\n-    /// If `None` is returned, then a source link couldn't be generated. This\n-    /// may happen, for example, with externally inlined items where the source\n-    /// of their crate documentation isn't known.\n-    fn src_href(&self, item: &clean::Item) -> Option<String> {\n-        if item.source.is_dummy() {\n-            return None;\n-        }\n-        let mut root = self.root_path();\n-        let mut path = String::new();\n-        let cnum = item.source.cnum(self.sess());\n-\n-        // We can safely ignore synthetic `SourceFile`s.\n-        let file = match item.source.filename(self.sess()) {\n-            FileName::Real(ref path) => path.local_path().to_path_buf(),\n-            _ => return None,\n-        };\n-        let file = &file;\n-\n-        let symbol;\n-        let (krate, path) = if cnum == LOCAL_CRATE {\n-            if let Some(path) = self.shared.local_sources.get(file) {\n-                (self.shared.layout.krate.as_str(), path)\n-            } else {\n-                return None;\n-            }\n-        } else {\n-            let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n-                (name, ref src, ExternalLocation::Local) => (name, src),\n-                (name, ref src, ExternalLocation::Remote(ref s)) => {\n-                    root = s.to_string();\n-                    (name, src)\n-                }\n-                (_, _, ExternalLocation::Unknown) => return None,\n-            };\n-\n-            sources::clean_path(&src_root, file, false, |component| {\n-                path.push_str(&component.to_string_lossy());\n-                path.push('/');\n-            });\n-            let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n-            fname.push(\".html\");\n-            path.push_str(&fname.to_string_lossy());\n-            symbol = krate.as_str();\n-            (&*symbol, &path)\n-        };\n-\n-        let loline = item.source.lo(self.sess()).line;\n-        let hiline = item.source.hi(self.sess()).line;\n-        let lines =\n-            if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n-        Some(format!(\n-            \"{root}src/{krate}/{path}#{lines}\",\n-            root = Escape(&root),\n-            krate = krate,\n-            path = path,\n-            lines = lines\n-        ))\n-    }\n-}\n-\n fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n where\n     F: FnOnce(&mut Buffer),"}]}