{"sha": "f32f810e6ecde94e60baf0f11a38dc12ebee7453", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMmY4MTBlNmVjZGU5NGU2MGJhZjBmMTFhMzhkYzEyZWJlZTc0NTM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-19T23:15:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-19T23:15:12Z"}, "message": "Rollup merge of #46518 - partim:asref-borrow-doc, r=dtolnay\n\nImprove documentation for Borrow\n\nThis is the first step in improving the documentation for all the reference conversion traits. It proposes new text for the trait documentation of `Borrow`. Since I feel it is a somewhat radical rewrite and includes a stricter contract for `Borrow` then the previous text\u2014namely that *all* shared traits need to behave the same, not just a select few\u2014, I wanted to get some feedback before continuing.\n\nApart from the \u2018normative\u2019 description, the new text also includes a fairly extensive explanation of how the trait is used in the examples section. I included it because every time I look at how `HashMap` uses the trait, I need to think for a while as the use is a bit twisted. So, I thought having this thinking written down as part of the trait itself might be useful. One could argue that this should go into The Book, and, while I really like having everything important in the docs, I can see the text moved there, too.\n\nSo, before I move on: is this new text any good? Do we feel it is correct, useful, comprehensive, and understandable?\n\n(This PR is in response to #44868 and #24140.)", "tree": {"sha": "20ce59a381ed4222c11ffcdb5bc611e10306a856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20ce59a381ed4222c11ffcdb5bc611e10306a856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f32f810e6ecde94e60baf0f11a38dc12ebee7453", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJasESACRBK7hj4Ov3rIwAAdHIIAJiT/PqfeR4avk6E6CUkMr5Z\nLEtTWjDi80VsaqAxLF7VvjLWAgN94H6NgJ8ofEUWEqY7reQ8hoQWkOSsZMvQomYs\nR6cZW71+7z+vwzFoEZICZhEcoqCN7UtKuE7miawNmoyFTwnurGQteuOqN50UBujX\ng3Rs7JjaTgDEMcozfX5MDJfNzkKjmfeAzMaD8RGEdVecAVE973oclVQC9qXbUYPN\nKIebsVvlshl2tgnl/kIxl9XAqqfjdPYIJANUSc+W7cr6IKbTHNfSYA91jmOhF9OJ\ntjSaZQzuffdYlEA8WMfekdVcJGEWJr5fSmjpJHfkgmF3tv+l5JV93J1U3NpXYVo=\n=TljS\n-----END PGP SIGNATURE-----\n", "payload": "tree 20ce59a381ed4222c11ffcdb5bc611e10306a856\nparent a04b88d1941644df01fa5e31dd43e0f57c13d938\nparent 13d94d666e037162808174f0bedbd5db9d65c7fe\nauthor kennytm <kennytm@gmail.com> 1521501312 +0800\ncommitter GitHub <noreply@github.com> 1521501312 +0800\n\nRollup merge of #46518 - partim:asref-borrow-doc, r=dtolnay\n\nImprove documentation for Borrow\n\nThis is the first step in improving the documentation for all the reference conversion traits. It proposes new text for the trait documentation of `Borrow`. Since I feel it is a somewhat radical rewrite and includes a stricter contract for `Borrow` then the previous text\u2014namely that *all* shared traits need to behave the same, not just a select few\u2014, I wanted to get some feedback before continuing.\n\nApart from the \u2018normative\u2019 description, the new text also includes a fairly extensive explanation of how the trait is used in the examples section. I included it because every time I look at how `HashMap` uses the trait, I need to think for a while as the use is a bit twisted. So, I thought having this thinking written down as part of the trait itself might be useful. One could argue that this should go into The Book, and, while I really like having everything important in the docs, I can see the text moved there, too.\n\nSo, before I move on: is this new text any good? Do we feel it is correct, useful, comprehensive, and understandable?\n\n(This PR is in response to #44868 and #24140.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f32f810e6ecde94e60baf0f11a38dc12ebee7453", "html_url": "https://github.com/rust-lang/rust/commit/f32f810e6ecde94e60baf0f11a38dc12ebee7453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f32f810e6ecde94e60baf0f11a38dc12ebee7453/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a04b88d1941644df01fa5e31dd43e0f57c13d938", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04b88d1941644df01fa5e31dd43e0f57c13d938", "html_url": "https://github.com/rust-lang/rust/commit/a04b88d1941644df01fa5e31dd43e0f57c13d938"}, {"sha": "13d94d666e037162808174f0bedbd5db9d65c7fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/13d94d666e037162808174f0bedbd5db9d65c7fe", "html_url": "https://github.com/rust-lang/rust/commit/13d94d666e037162808174f0bedbd5db9d65c7fe"}], "stats": {"total": 164, "additions": 149, "deletions": 15}, "files": [{"sha": "f45a32d4b94acd8a83f2da8643fb2823f9349c95", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 149, "deletions": 15, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f32f810e6ecde94e60baf0f11a38dc12ebee7453/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32f810e6ecde94e60baf0f11a38dc12ebee7453/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=f32f810e6ecde94e60baf0f11a38dc12ebee7453", "patch": "@@ -14,24 +14,154 @@\n \n /// A trait for borrowing data.\n ///\n-/// In general, there may be several ways to \"borrow\" a piece of data.  The\n-/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+/// In Rust, it is common to provide different representations of a type for\n+/// different use cases. For instance, storage location and management for a\n+/// value can be specifically chosen as appropriate for a particular use via\n+/// pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic\n+/// wrappers that can be used with any type, some types provide optional\n+/// facets providing potentially costly functionality. An example for such a\n+/// type is [`String`] which adds the ability to extend a string to the basic\n+/// [`str`]. This requires keeping additional information unnecessary for a\n+/// simple, immutable string.\n ///\n-/// When writing generic code, it is often desirable to abstract over all ways\n-/// of borrowing data from a given type. That is the role of the `Borrow`\n-/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n-/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n-/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+/// These types provide access to the underlying data through references\n+/// to the type of that data. They are said to be \u2018borrowed as\u2019 that type.\n+/// For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`]\n+/// can be borrowed as `str`.\n ///\n-/// If you are implementing `Borrow` and both `Self` and `Borrowed` implement\n-/// `Hash`, `Eq`, and/or `Ord`, they must produce the same result.\n+/// Types express that they can be borrowed as some type `T` by implementing\n+/// `Borrow<T>`, providing a reference to a `T` in the trait\u2019s\n+/// [`borrow`] method. A type is free to borrow as several different types.\n+/// If it wishes to mutably borrow as the type \u2013 allowing the underlying data\n+/// to be modified, it can additionally implement [`BorrowMut<T>`].\n ///\n-/// `Borrow` is very similar to, but different than, `AsRef`. See\n-/// [the book][book] for more.\n+/// Further, when providing implementations for additional traits, it needs\n+/// to be considered whether they should behave identical to those of the\n+/// underlying type as a consequence of acting as a representation of that\n+/// underlying type. Generic code typically uses `Borrow<T>` when it relies\n+/// on the identical behavior of these additional trait implementations.\n+/// These traits will likely appear as additional trait bounds.\n ///\n-/// [book]: ../../book/first-edition/borrow-and-asref.html\n+/// If generic code merely needs to work for all types that can\n+/// provide a reference to related type `T`, it is often better to use\n+/// [`AsRef<T>`] as more types can safely implement it.\n+///\n+/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n+/// [`BorrowMut<T>`]: trait.BorrowMut.html\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n+/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n+/// [`str`]: ../../std/primitive.str.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`borrow`]: #tymethod.borrow\n+///\n+/// # Examples\n+///\n+/// As a data collection, [`HashMap<K, V>`] owns both keys and values. If\n+/// the key\u2019s actual data is wrapped in a managing type of some kind, it\n+/// should, however, still be possible to search for a value using a\n+/// reference to the key\u2019s data. For instance, if the key is a string, then\n+/// it is likely stored with the hash map as a [`String`], while it should\n+/// be possible to search using a [`&str`][`str`]. Thus, `insert` needs to\n+/// operate on a `String` while `get` needs to be able to use a `&str`.\n+///\n+/// Slightly simplified, the relevant parts of `HashMap<K, V>` look like\n+/// this:\n+///\n+/// ```\n+/// use std::borrow::Borrow;\n+/// use std::hash::Hash;\n+///\n+/// pub struct HashMap<K, V> {\n+///     # marker: ::std::marker::PhantomData<(K, V)>,\n+///     // fields omitted\n+/// }\n+///\n+/// impl<K, V> HashMap<K, V> {\n+///     pub fn insert(&self, key: K, value: V) -> Option<V>\n+///     where K: Hash + Eq\n+///     {\n+///         # unimplemented!()\n+///         // ...\n+///     }\n+///\n+///     pub fn get<Q>(&self, k: &Q) -> Option<&V>\n+///     where\n+///         K: Borrow<Q>,\n+///         Q: Hash + Eq + ?Sized\n+///     {\n+///         # unimplemented!()\n+///         // ...\n+///     }\n+/// }\n+/// ```\n+///\n+/// The entire hash map is generic over a key type `K`. Because these keys\n+/// are stored with the hash map, this type has to own the key\u2019s data.\n+/// When inserting a key-value pair, the map is given such a `K` and needs\n+/// to find the correct hash bucket and check if the key is already present\n+/// based on that `K`. It therefore requires `K: Hash + Eq`.\n+///\n+/// When searching for a value in the map, however, having to provide a\n+/// reference to a `K` as the key to search for would require to always\n+/// create such an owned value. For string keys, this would mean a `String`\n+/// value needs to be created just for the search for cases where only a\n+/// `str` is available.\n+///\n+/// Instead, the `get` method is generic over the type of the underlying key\n+/// data, called `Q` in the method signature above. It states that `K`\n+/// borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally\n+/// requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q`\n+/// have implementations of the `Hash` and `Eq` traits that produce identical\n+/// results.\n+///\n+/// The implementation of `get` relies in particular on identical\n+/// implementations of `Hash` by determining the key\u2019s hash bucket by calling\n+/// `Hash::hash` on the `Q` value even though it inserted the key based on\n+/// the hash value calculated from the `K` value.\n+///\n+/// As a consequence, the hash map breaks if a `K` wrapping a `Q` value\n+/// produces a different hash than `Q`. For instance, imagine you have a\n+/// type that wraps a string but compares ASCII letters ignoring their case:\n+///\n+/// ```\n+/// pub struct CaseInsensitiveString(String);\n+///\n+/// impl PartialEq for CaseInsensitiveString {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.0.eq_ignore_ascii_case(&other.0)\n+///     }\n+/// }\n+///\n+/// impl Eq for CaseInsensitiveString { }\n+/// ```\n+///\n+/// Because two equal values need to produce the same hash value, the\n+/// implementation of `Hash` needs to ignore ASCII case, too:\n+///\n+/// ```\n+/// # use std::hash::{Hash, Hasher};\n+/// # pub struct CaseInsensitiveString(String);\n+/// impl Hash for CaseInsensitiveString {\n+///     fn hash<H: Hasher>(&self, state: &mut H) {\n+///         for c in self.0.as_bytes() {\n+///             c.to_ascii_lowercase().hash(state)\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can\n+/// provide a reference to a string slice via its contained owned string.\n+/// But because its `Hash` implementation differs, it behaves differently\n+/// from `str` and therefore must not, in fact, implement `Borrow<str>`.\n+/// If it wants to allow others access to the underlying `str`, it can do\n+/// that via `AsRef<str>` which doesn\u2019t carry any extra requirements.\n+///\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n@@ -59,7 +189,11 @@ pub trait Borrow<Borrowed: ?Sized> {\n \n /// A trait for mutably borrowing data.\n ///\n-/// Similar to `Borrow`, but for mutable borrows.\n+/// As a companion to [`Borrow<T>`] this trait allows a type to borrow as\n+/// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n+/// for more information on borrowing as another type.\n+///\n+/// [`Borrow<T>`]: trait.Borrow.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n     /// Mutably borrows from an owned value."}]}