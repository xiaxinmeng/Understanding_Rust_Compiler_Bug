{"sha": "8c7104fb6c2b378c124acc4a74e4524ccb031819", "node_id": "C_kwDOAAsO6NoAKDhjNzEwNGZiNmMyYjM3OGMxMjRhY2M0YTc0ZTQ1MjRjY2IwMzE4MTk", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:40:39Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:52:46Z"}, "message": "TB: Util: an efficient mapping for permissions", "tree": {"sha": "c364bee24a66506279ed66684df2f7c078a7c3d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c364bee24a66506279ed66684df2f7c078a7c3d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c7104fb6c2b378c124acc4a74e4524ccb031819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7104fb6c2b378c124acc4a74e4524ccb031819", "html_url": "https://github.com/rust-lang/rust/commit/8c7104fb6c2b378c124acc4a74e4524ccb031819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c7104fb6c2b378c124acc4a74e4524ccb031819/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fcfd9e11db56d40739fe7816540e3f98d6283b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fcfd9e11db56d40739fe7816540e3f98d6283b5", "html_url": "https://github.com/rust-lang/rust/commit/8fcfd9e11db56d40739fe7816540e3f98d6283b5"}], "stats": {"total": 304, "additions": 304, "deletions": 0}, "files": [{"sha": "c1d452ca89e9648ceffb19c58ab0078798862656", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/unimap.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/8c7104fb6c2b378c124acc4a74e4524ccb031819/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7104fb6c2b378c124acc4a74e4524ccb031819/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs?ref=8c7104fb6c2b378c124acc4a74e4524ccb031819", "patch": "@@ -0,0 +1,304 @@\n+//! This module implements the `UniMap`, which is a way to get efficient mappings\n+//! optimized for the setting of `tree_borrows/tree.rs`.\n+//!\n+//! A `UniKeyMap<K>` is a (slow) mapping from `K` to `UniIndex`,\n+//! and `UniValMap<V>` is a (fast) mapping from `UniIndex` to `V`.\n+//! Thus a pair `(UniKeyMap<K>, UniValMap<V>)` acts as a virtual `HashMap<K, V>`.\n+//!\n+//! Because of the asymmetry in access time, the use-case for `UniMap` is the following:\n+//! a tuple `(UniKeyMap<K>, Vec<UniValMap<V>>)` is much more efficient than\n+//! the equivalent `Vec<HashMap<K, V>>` it represents if all maps have similar\n+//! sets of keys.\n+\n+#![allow(dead_code)]\n+\n+use std::hash::Hash;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+/// Intermediate key between a UniKeyMap and a UniValMap.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct UniIndex {\n+    idx: u32,\n+}\n+\n+/// From K to UniIndex\n+#[derive(Debug, Clone, Default)]\n+pub struct UniKeyMap<K> {\n+    /// Underlying map that does all the hard work.\n+    /// Key invariant: the contents of `deassigned` are disjoint from the\n+    /// keys of `mapping`, and together they form the set of contiguous integers\n+    /// `0 .. (mapping.len() + deassigned.len())`.\n+    mapping: FxHashMap<K, u32>,\n+    /// Indexes that can be reused: memory gain when the map gets sparse\n+    /// due to many deletions.\n+    deassigned: Vec<u32>,\n+}\n+\n+/// From UniIndex to V\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct UniValMap<V> {\n+    /// The mapping data. Thanks to Vec we get both fast accesses, and\n+    /// a memory-optimal representation if there are few deletions.\n+    data: Vec<Option<V>>,\n+}\n+\n+impl<V> Default for UniValMap<V> {\n+    fn default() -> Self {\n+        Self { data: Vec::default() }\n+    }\n+}\n+\n+impl<K> UniKeyMap<K>\n+where\n+    K: Hash + Eq,\n+{\n+    /// How many keys/index pairs are currently active.\n+    pub fn len(&self) -> usize {\n+        self.mapping.len()\n+    }\n+\n+    /// Whether this key has an associated index or not.\n+    pub fn contains_key(&self, key: &K) -> bool {\n+        self.mapping.contains_key(key)\n+    }\n+\n+    /// Assign this key to a new index. Panics if the key is already assigned,\n+    /// use `get_or_insert` for a version that instead returns the existing\n+    /// assignment.\n+    #[track_caller]\n+    pub fn insert(&mut self, key: K) -> UniIndex {\n+        // We want an unused index. First we attempt to find one from `deassigned`,\n+        // and if `deassigned` is empty we generate a fresh index.\n+        let idx = self.deassigned.pop().unwrap_or_else(|| {\n+            // `deassigned` is empty, so all keys in use are already in `mapping`.\n+            // The next available key is `mapping.len()`.\n+            self.mapping.len().try_into().expect(\"UniMap ran out of useable keys\")\n+        });\n+        if self.mapping.insert(key, idx).is_some() {\n+            panic!(\n+                \"This key is already assigned to a different index; either use `get_or_insert` instead if you care about this data, or first call `remove` to undo the preexisting assignment.\"\n+            );\n+        };\n+        UniIndex { idx }\n+    }\n+\n+    /// If it exists, the index this key maps to.\n+    pub fn get(&self, key: &K) -> Option<UniIndex> {\n+        self.mapping.get(key).map(|&idx| UniIndex { idx })\n+    }\n+\n+    /// Either get a previously existing entry, or create a new one if it\n+    /// is not yet present.\n+    pub fn get_or_insert(&mut self, key: K) -> UniIndex {\n+        self.get(&key).unwrap_or_else(|| self.insert(key))\n+    }\n+\n+    /// Return whatever index this key was using to the deassigned pool.\n+    ///\n+    /// Note: calling this function can be dangerous. If the index still exists\n+    /// somewhere in a `UniValMap` and is reassigned by the `UniKeyMap` then\n+    /// it will inherit the old value of a completely unrelated key.\n+    /// If you `UniKeyMap::remove` a key you should make sure to also `UniValMap::remove`\n+    /// the associated `UniIndex` from ALL `UniValMap`s.\n+    ///\n+    /// Example of such behavior:\n+    /// ```\n+    /// let mut keymap = UniKeyMap::<char>::default();\n+    /// let mut valmap = UniValMap::<char>::default();\n+    /// // Insert 'a' -> _ -> 'A'\n+    /// let idx_a = keymap.insert('a');\n+    /// valmap.insert(idx_a, 'A');\n+    /// // Remove 'a' -> _, but forget to remove _ -> 'A'\n+    /// keymap.remove(&'a');\n+    /// // valmap.remove(idx_a); // If we uncomment this line the issue is fixed\n+    /// // Insert 'b' -> _\n+    /// let idx_b = keymap.insert('b');\n+    /// let val_b = valmap.get(idx_b);\n+    /// assert_eq!(val_b, Some('A')); // Oh no\n+    /// // assert_eq!(val_b, None); // This is what we would have expected\n+    /// ```\n+    pub fn remove(&mut self, key: &K) {\n+        if let Some(idx) = self.mapping.remove(key) {\n+            self.deassigned.push(idx);\n+        }\n+    }\n+}\n+\n+impl<V> UniValMap<V> {\n+    /// Whether this index has an associated value.\n+    pub fn contains_idx(&self, idx: UniIndex) -> bool {\n+        self.data.get(idx.idx as usize).and_then(Option::as_ref).is_some()\n+    }\n+\n+    /// Reserve enough space to insert the value at the right index.\n+    fn extend_to_length(&mut self, len: usize) {\n+        if len > self.data.len() {\n+            let nb = len - self.data.len();\n+            self.data.reserve(nb);\n+            for _ in 0..nb {\n+                self.data.push(None);\n+            }\n+        }\n+    }\n+\n+    /// Assign a value to the index. Permanently overwrites any previous value.\n+    pub fn insert(&mut self, idx: UniIndex, val: V) {\n+        self.extend_to_length(idx.idx as usize + 1);\n+        self.data[idx.idx as usize] = Some(val)\n+    }\n+\n+    /// Get the value at this index, if it exists.\n+    pub fn get(&self, idx: UniIndex) -> Option<&V> {\n+        self.data.get(idx.idx as usize).and_then(Option::as_ref)\n+    }\n+\n+    /// Get the value at this index mutably, if it exists.\n+    pub fn get_mut(&mut self, idx: UniIndex) -> Option<&mut V> {\n+        self.data.get_mut(idx.idx as usize).and_then(Option::as_mut)\n+    }\n+\n+    /// Delete any value associated with this index. Ok even if the index\n+    /// has no associated value.\n+    pub fn remove(&mut self, idx: UniIndex) {\n+        if idx.idx as usize >= self.data.len() {\n+            return;\n+        }\n+        self.data[idx.idx as usize] = None;\n+    }\n+}\n+\n+/// An access to a single value of the map.\n+pub struct UniEntry<'a, V> {\n+    inner: &'a mut Option<V>,\n+}\n+\n+impl<'a, V> UniValMap<V> {\n+    /// Get a wrapper around a mutable access to the value corresponding to `idx`.\n+    pub fn entry(&'a mut self, idx: UniIndex) -> UniEntry<'a, V> {\n+        self.extend_to_length(idx.idx as usize + 1);\n+        UniEntry { inner: &mut self.data[idx.idx as usize] }\n+    }\n+}\n+\n+impl<'a, V> UniEntry<'a, V> {\n+    /// Insert in the map and get the value.\n+    pub fn or_insert_with<F>(&mut self, default: F) -> &mut V\n+    where\n+        F: FnOnce() -> V,\n+    {\n+        if self.inner.is_none() {\n+            *self.inner = Some(default());\n+        }\n+        self.inner.as_mut().unwrap()\n+    }\n+}\n+\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn extend_to_length() {\n+        let mut km = UniValMap::<char>::default();\n+        km.extend_to_length(10);\n+        assert!(km.data.len() == 10);\n+        km.extend_to_length(0);\n+        assert!(km.data.len() == 10);\n+        km.extend_to_length(10);\n+        assert!(km.data.len() == 10);\n+        km.extend_to_length(11);\n+        assert!(km.data.len() == 11);\n+    }\n+\n+    #[derive(Default)]\n+    struct MapWitness<K, V> {\n+        key: UniKeyMap<K>,\n+        val: UniValMap<V>,\n+        map: FxHashMap<K, V>,\n+    }\n+\n+    impl<K, V> MapWitness<K, V>\n+    where\n+        K: Copy + Hash + Eq,\n+        V: Copy + Eq + std::fmt::Debug,\n+    {\n+        fn insert(&mut self, k: K, v: V) {\n+            // UniMap\n+            let i = self.key.get_or_insert(k);\n+            self.val.insert(i, v);\n+            // HashMap\n+            self.map.insert(k, v);\n+            // Consistency: nothing to check\n+        }\n+\n+        fn get(&self, k: &K) {\n+            // UniMap\n+            let v1 = self.key.get(k).and_then(|i| self.val.get(i));\n+            // HashMap\n+            let v2 = self.map.get(k);\n+            // Consistency\n+            assert_eq!(v1, v2);\n+        }\n+\n+        fn get_mut(&mut self, k: &K) {\n+            // UniMap\n+            let v1 = self.key.get(k).and_then(|i| self.val.get_mut(i));\n+            // HashMap\n+            let v2 = self.map.get_mut(k);\n+            // Consistency\n+            assert_eq!(v1, v2);\n+        }\n+        fn remove(&mut self, k: &K) {\n+            // UniMap\n+            if let Some(i) = self.key.get(k) {\n+                self.val.remove(i);\n+            }\n+            self.key.remove(k);\n+            // HashMap\n+            self.map.remove(k);\n+            // Consistency: nothing to check\n+        }\n+    }\n+\n+    #[test]\n+    fn consistency_small() {\n+        let mut m = MapWitness::<u64, char>::default();\n+        m.insert(1, 'a');\n+        m.insert(2, 'b');\n+        m.get(&1);\n+        m.get_mut(&2);\n+        m.remove(&2);\n+        m.insert(1, 'c');\n+        m.get(&1);\n+        m.insert(3, 'd');\n+        m.insert(4, 'e');\n+        m.insert(4, 'f');\n+        m.get(&2);\n+        m.get(&3);\n+        m.get(&4);\n+        m.get(&5);\n+        m.remove(&100);\n+        m.get_mut(&100);\n+        m.get(&100);\n+    }\n+\n+    #[test]\n+    fn consistency_large() {\n+        use std::collections::hash_map::DefaultHasher;\n+        use std::hash::{Hash, Hasher};\n+        let mut hasher = DefaultHasher::new();\n+        let mut map = MapWitness::<u64, u64>::default();\n+        for i in 0..1000 {\n+            i.hash(&mut hasher);\n+            let rng = hasher.finish();\n+            let op = rng % 3 == 0;\n+            let key = (rng / 2) % 50;\n+            let val = (rng / 100) % 1000;\n+            if op {\n+                map.insert(key, val);\n+            } else {\n+                map.get(&key);\n+            }\n+        }\n+    }\n+}"}]}