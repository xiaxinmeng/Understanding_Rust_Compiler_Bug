{"sha": "588a6a35be4446fbaaa792d08efee51e04e61fe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OGE2YTM1YmU0NDQ2ZmJhYWE3OTJkMDhlZmVlNTFlMDRlNjFmZTg=", "commit": {"author": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2017-11-10T12:00:55Z"}, "committer": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-26T17:46:04Z"}, "message": "Added JSON output to libtest.\n\nlibtest: Json format now outputs failed tests' stdouts.\n\nlibtest: Json format now outputs failed tests' stdouts.\n\nlibtest: Json formatter now spews individiual events, not as an array\n\nlibtest: JSON fixes\n\nlibtest: Better JSON escaping\n\nlibtest: Test start event is printed on time", "tree": {"sha": "2fc5aa944563ef37440c0ce688a2f2e3d6e38283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc5aa944563ef37440c0ce688a2f2e3d6e38283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/588a6a35be4446fbaaa792d08efee51e04e61fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/588a6a35be4446fbaaa792d08efee51e04e61fe8", "html_url": "https://github.com/rust-lang/rust/commit/588a6a35be4446fbaaa792d08efee51e04e61fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/588a6a35be4446fbaaa792d08efee51e04e61fe8/comments", "author": null, "committer": null, "parents": [{"sha": "d24f9af31c4e96e5158677408b513d3e33be7357", "url": "https://api.github.com/repos/rust-lang/rust/commits/d24f9af31c4e96e5158677408b513d3e33be7357", "html_url": "https://github.com/rust-lang/rust/commit/d24f9af31c4e96e5158677408b513d3e33be7357"}], "stats": {"total": 364, "additions": 313, "deletions": 51}, "files": [{"sha": "08d87b90978960d70617198dbc3fe0ffa246301c", "filename": "src/libtest/formatters.rs", "status": "modified", "additions": 219, "deletions": 19, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/588a6a35be4446fbaaa792d08efee51e04e61fe8/src%2Flibtest%2Fformatters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588a6a35be4446fbaaa792d08efee51e04e61fe8/src%2Flibtest%2Fformatters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters.rs?ref=588a6a35be4446fbaaa792d08efee51e04e61fe8", "patch": "@@ -12,12 +12,12 @@ use super::*;\n \n pub(crate) trait OutputFormatter {\n     fn write_run_start(&mut self, len: usize) -> io::Result<()>;\n-    fn write_test_start(&mut self,\n-        test: &TestDesc,\n-        align: NamePadding,\n-        max_name_len: usize) -> io::Result<()>;\n+    fn write_test_start(&mut self, test: &TestDesc) -> io::Result<()>;\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n-    fn write_result(&mut self, result: &TestResult) -> io::Result<()>;\n+    fn write_result(&mut self,\n+                    desc: &TestDesc,\n+                    result: &TestResult,\n+                    stdout: &[u8]) -> io::Result<()>;\n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n }\n \n@@ -26,15 +26,17 @@ pub(crate) struct HumanFormatter<T> {\n     terse: bool,\n     use_color: bool,\n     test_count: usize,\n+    max_name_len: usize, // number of columns to fill when aligning names\n }\n \n impl<T: Write> HumanFormatter<T> {\n-    pub fn new(out: OutputLocation<T>, use_color: bool, terse: bool) -> Self {\n+    pub fn new(out: OutputLocation<T>, use_color: bool, terse: bool, max_name_len: usize) -> Self {\n         HumanFormatter {\n             out,\n             terse,\n             use_color,\n             test_count: 0,\n+            max_name_len,\n         }\n     }\n \n@@ -73,7 +75,7 @@ impl<T: Write> HumanFormatter<T> {\n                 // `stamp` in the rust CI).\n                 self.write_plain(\"\\n\")?;\n             }\n-            \n+\n             self.test_count += 1;\n             Ok(())\n         } else {\n@@ -170,20 +172,18 @@ impl<T: Write> OutputFormatter for HumanFormatter<T> {\n         self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n     }\n \n-    fn write_test_start(&mut self,\n-                        test: &TestDesc,\n-                        align: NamePadding,\n-                        max_name_len: usize) -> io::Result<()> {\n-        if self.terse && align != PadOnRight {\n-            Ok(())\n-        }\n-        else {\n-            let name = test.padded_name(max_name_len, align);\n-            self.write_plain(&format!(\"test {} ... \", name))\n-        }\n+    fn write_test_start(&mut self, _desc: &TestDesc) -> io::Result<()> {\n+        // Do not print header, as priting it at this point will result in\n+        // an unreadable output when running tests concurrently.\n+        Ok(())\n     }\n \n-    fn write_result(&mut self, result: &TestResult) -> io::Result<()> {\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        if !(self.terse && desc.name.padding() != PadOnRight) {\n+            let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+            self.write_plain(&format!(\"test {} ... \", name))?;\n+        }\n+\n         match *result {\n             TrOk => self.write_ok(),\n             TrFailed | TrFailedMsg(_) => self.write_failed(),\n@@ -244,3 +244,203 @@ impl<T: Write> OutputFormatter for HumanFormatter<T> {\n         Ok(success)\n     }\n }\n+\n+pub(crate) struct JsonFormatter<T> {\n+    out: OutputLocation<T>\n+}\n+\n+impl<T: Write> JsonFormatter<T> {\n+    pub fn new(out: OutputLocation<T>) -> Self {\n+        Self {\n+            out,        }\n+    }\n+\n+    fn write_str<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        self.out.write_all(s.as_ref().as_ref())?;\n+        self.out.write_all(\"\\n\".as_ref())\n+    }\n+\n+    fn write_event(&mut self,\n+                    ty: &str,\n+                    name: &str,\n+                    evt: &str,\n+                    extra: Option<String>) -> io::Result<()> {\n+        if let Some(extras) = extra {\n+            self.write_str(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n+                                    ty,\n+                                    name,\n+                                    evt,\n+                                    extras))\n+        }\n+        else {\n+            self.write_str(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n+                                    ty,\n+                                    name,\n+                                    evt))\n+        }\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for JsonFormatter<T> {\n+    fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n+        self.write_str(\n+            &*format!(r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#, len))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_str(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n+                                desc.name))\n+    }\n+\n+    fn write_result(&mut self,\n+                        desc: &TestDesc,\n+                        result: &TestResult,\n+                        stdout: &[u8]) -> io::Result<()> {\n+        match *result {\n+            TrOk => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"ok\", None)\n+            },\n+\n+            TrFailed => {\n+                let extra_data = if stdout.len() > 0 {\n+                    Some(format!(r#\"\"stdout\": \"{}\"\"#,\n+                        EscapedString(String::from_utf8_lossy(stdout))))\n+                }\n+                else {\n+                    None\n+                };\n+\n+                self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n+            },\n+\n+            TrFailedMsg(ref m) => {\n+                self.write_event(\"test\",\n+                                    desc.name.as_slice(),\n+                                    \"failed\",\n+                                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))))\n+            },\n+\n+            TrIgnored => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None)\n+            },\n+\n+            TrAllowedFail => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n+            },\n+\n+            TrBench(ref bs) => {\n+                let median = bs.ns_iter_summ.median as usize;\n+                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n+\n+                let mbps = if bs.mb_s == 0 {\n+                    \"\".into()\n+                }\n+                else {\n+                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n+                };\n+\n+                let line = format!(\"{{ \\\"type\\\": \\\"bench\\\", \\\n+                                \\\"name\\\": \\\"{}\\\", \\\n+                                \\\"median\\\": {}, \\\n+                                \\\"deviation\\\": {}{} }}\",\n+                        desc.name,\n+                        median,\n+                        deviation,\n+                        mbps);\n+\n+                self.write_str(&*line)\n+            },\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_str(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n+                        desc.name))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+\n+        self.write_str(&*format!(\"{{ \\\"type\\\": \\\"suite\\\", \\\n+            \\\"event\\\": \\\"{}\\\", \\\n+            \\\"passed\\\": {}, \\\n+            \\\"failed\\\": {}, \\\n+            \\\"allowed_fail\\\": {}, \\\n+            \\\"ignored\\\": {}, \\\n+            \\\"measured\\\": {}, \\\n+            \\\"filtered_out\\\": \\\"{}\\\" }}\",\n+            if state.failed == 0 { \"ok\" } else { \"failed\" },\n+            state.passed,\n+            state.failed + state.allowed_fail,\n+            state.allowed_fail,\n+            state.ignored,\n+            state.measured,\n+            state.filtered_out))?;\n+\n+        Ok(state.failed == 0)\n+    }\n+}\n+\n+/// A formatting utility used to print strings with characters in need of escaping.\n+/// Base code taken form `libserialize::json::escape_str`\n+struct EscapedString<S: AsRef<str>>(S);\n+\n+impl<S: AsRef<str>> ::std::fmt::Display for EscapedString<S> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        let mut start = 0;\n+\n+        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n+            let escaped = match byte {\n+                b'\"' => \"\\\\\\\"\",\n+                b'\\\\' => \"\\\\\\\\\",\n+                b'\\x00' => \"\\\\u0000\",\n+                b'\\x01' => \"\\\\u0001\",\n+                b'\\x02' => \"\\\\u0002\",\n+                b'\\x03' => \"\\\\u0003\",\n+                b'\\x04' => \"\\\\u0004\",\n+                b'\\x05' => \"\\\\u0005\",\n+                b'\\x06' => \"\\\\u0006\",\n+                b'\\x07' => \"\\\\u0007\",\n+                b'\\x08' => \"\\\\b\",\n+                b'\\t' => \"\\\\t\",\n+                b'\\n' => \"\\\\n\",\n+                b'\\x0b' => \"\\\\u000b\",\n+                b'\\x0c' => \"\\\\f\",\n+                b'\\r' => \"\\\\r\",\n+                b'\\x0e' => \"\\\\u000e\",\n+                b'\\x0f' => \"\\\\u000f\",\n+                b'\\x10' => \"\\\\u0010\",\n+                b'\\x11' => \"\\\\u0011\",\n+                b'\\x12' => \"\\\\u0012\",\n+                b'\\x13' => \"\\\\u0013\",\n+                b'\\x14' => \"\\\\u0014\",\n+                b'\\x15' => \"\\\\u0015\",\n+                b'\\x16' => \"\\\\u0016\",\n+                b'\\x17' => \"\\\\u0017\",\n+                b'\\x18' => \"\\\\u0018\",\n+                b'\\x19' => \"\\\\u0019\",\n+                b'\\x1a' => \"\\\\u001a\",\n+                b'\\x1b' => \"\\\\u001b\",\n+                b'\\x1c' => \"\\\\u001c\",\n+                b'\\x1d' => \"\\\\u001d\",\n+                b'\\x1e' => \"\\\\u001e\",\n+                b'\\x1f' => \"\\\\u001f\",\n+                b'\\x7f' => \"\\\\u007f\",\n+                _ => { continue; }\n+            };\n+\n+            if start < i {\n+                f.write_str(&self.0.as_ref()[start..i])?;\n+            }\n+\n+            f.write_str(escaped)?;\n+\n+            start = i + 1;\n+        }\n+\n+        if start != self.0.as_ref().len() {\n+            f.write_str(&self.0.as_ref()[start..])?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "b11f783770f838219ea2cf77fa7695876e56923d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 93, "deletions": 31, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/588a6a35be4446fbaaa792d08efee51e04e61fe8/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588a6a35be4446fbaaa792d08efee51e04e61fe8/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=588a6a35be4446fbaaa792d08efee51e04e61fe8", "patch": "@@ -71,6 +71,7 @@ use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::time::{Instant, Duration};\n+use std::borrow::Cow;\n \n const TEST_WARN_TIMEOUT_S: u64 = 60;\n const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n@@ -97,22 +98,41 @@ use formatters::*;\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(String),\n+    AlignedTestName(Cow<'static, str>, NamePadding),\n }\n impl TestName {\n     fn as_slice(&self) -> &str {\n         match *self {\n             StaticTestName(s) => s,\n             DynTestName(ref s) => s,\n+            AlignedTestName(ref s, _) => &*s,\n         }\n     }\n+\n+    fn padding(&self) -> NamePadding {\n+        match self {\n+            &AlignedTestName(_, p) => p,\n+            _ => PadNone,\n+        }\n+    }\n+\n+    fn with_padding(&self, padding: NamePadding) -> TestName {\n+        let name = match self {\n+            &TestName::StaticTestName(name) => Cow::Borrowed(name),\n+            &TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n+            &TestName::AlignedTestName(ref name, _) => name.clone(),\n+        };\n+\n+        TestName::AlignedTestName(name, padding)\n+    }\n }\n impl fmt::Display for TestName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self.as_slice(), f)\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum NamePadding {\n     PadNone,\n     PadOnRight,\n@@ -306,6 +326,13 @@ pub enum ColorConfig {\n     NeverColor,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum OutputFormat {\n+    Pretty,\n+    Terse,\n+    Json\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n@@ -317,7 +344,7 @@ pub struct TestOpts {\n     pub logfile: Option<PathBuf>,\n     pub nocapture: bool,\n     pub color: ColorConfig,\n-    pub quiet: bool,\n+    pub format: OutputFormat,\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n     pub options: Options,\n@@ -336,7 +363,7 @@ impl TestOpts {\n             logfile: None,\n             nocapture: false,\n             color: AutoColor,\n-            quiet: false,\n+            format: OutputFormat::Pretty,\n             test_threads: None,\n             skip: vec![],\n             options: Options::new(),\n@@ -362,13 +389,17 @@ fn optgroups() -> getopts::Options {\n                                      in parallel\", \"n_threads\")\n         .optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n                                be used multiple times)\",\"FILTER\")\n-        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line.\\\n-                                Equivalent to --format=terse\")\n+        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line. \\\n+                                Alias to --format=terse\")\n         .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n         .optopt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n             always = always colorize output;\n-            never  = never colorize output;\", \"auto|always|never\");\n+            never  = never colorize output;\", \"auto|always|never\")\n+        .optopt(\"\", \"format\", \"Configure formatting of output:\n+            pretty = Print verbose output;\n+            terse  = Display one character per test;\n+            json   = Output a json document\", \"pretty|terse|json\");\n     return opts\n }\n \n@@ -469,6 +500,19 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         }\n     };\n \n+    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n+        None if quiet => OutputFormat::Terse,\n+        Some(\"pretty\") | None => OutputFormat::Pretty,\n+        Some(\"terse\") => OutputFormat::Terse,\n+        Some(\"json\") => OutputFormat::Json,\n+\n+        Some(v) => {\n+            return Some(Err(format!(\"argument for --format must be pretty, terse, or json (was \\\n+                                     {})\",\n+                                    v)))\n+        }\n+    };\n+\n     let test_opts = TestOpts {\n         list,\n         filter,\n@@ -479,7 +523,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         logfile,\n         nocapture,\n         color,\n-        quiet,\n+        format,\n         test_threads,\n         skip: matches.opt_strs(\"skip\"),\n         options: Options::new(),\n@@ -539,7 +583,6 @@ struct ConsoleTestState {\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8>)>,\n     not_failures: Vec<(TestDesc, Vec<u8>)>,\n-    max_name_len: usize, // number of columns to fill when aligning names\n     options: Options,\n }\n \n@@ -562,7 +605,6 @@ impl ConsoleTestState {\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n             not_failures: Vec::new(),\n-            max_name_len: 0,\n             options: opts.options,\n         })\n     }\n@@ -641,7 +683,9 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n         None => Raw(io::stdout()),\n         Some(t) => Pretty(t),\n     };\n-    let mut out = HumanFormatter::new(output, use_color(opts), opts.quiet);\n+\n+    let quiet = opts.format == OutputFormat::Terse;\n+    let mut out = HumanFormatter::new(output, use_color(opts), quiet, 0);\n     let mut st = ConsoleTestState::new(opts)?;\n \n     let mut ntest = 0;\n@@ -668,11 +712,11 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n         }\n     }\n \n-    if !opts.quiet {\n+    if !quiet {\n         if ntest != 0 || nbench != 0 {\n-            st.write_plain(\"\\n\")?;\n+            out.write_plain(\"\\n\")?;\n         }\n-        st.write_plain(format!(\"{}, {}\\n\",\n+        out.write_plain(format!(\"{}, {}\\n\",\n             plural(ntest, \"test\"),\n             plural(nbench, \"benchmark\")))?;\n     }\n@@ -682,6 +726,14 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n+    let tests = {\n+        let mut tests = tests;\n+        for test in tests.iter_mut() {\n+            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n+        }\n+\n+        tests\n+    };\n \n     fn callback(event: &TestEvent,\n                 st: &mut ConsoleTestState,\n@@ -693,11 +745,11 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                 out.write_run_start(filtered_tests.len())\n             },\n             TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n-            TeWait(ref test, padding) => out.write_test_start(test, padding, st.max_name_len),\n+            TeWait(ref test) => out.write_test_start(test),\n             TeTimeout(ref test) => out.write_timeout(test),\n             TeResult(test, result, stdout) => {\n                 st.write_log_result(&test, &result)?;\n-                out.write_result(&result)?;\n+                out.write_result(&test, &result, &*stdout)?;\n                 match result {\n                     TrOk => {\n                         st.passed += 1;\n@@ -734,20 +786,34 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         Some(t) => Pretty(t),\n     };\n \n-    let mut out = HumanFormatter::new(output, use_color(opts), opts.quiet);\n+    let max_name_len = if let Some(t) = tests.iter().max_by_key(|t| len_if_padded(*t)) {\n+        let n = t.desc.name.as_slice();\n+        n.len()\n+    }\n+    else {\n+        0\n+    };\n \n+    let mut out: Box<OutputFormatter> = match opts.format {\n+        OutputFormat::Pretty => Box::new(HumanFormatter::new(output,\n+                                                                use_color(opts),\n+                                                                false,\n+                                                                max_name_len)),\n+        OutputFormat::Terse => Box::new(HumanFormatter::new(output,\n+                                                                use_color(opts),\n+                                                                true,\n+                                                                max_name_len)),\n+        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+    };\n     let mut st = ConsoleTestState::new(opts)?;\n     fn len_if_padded(t: &TestDescAndFn) -> usize {\n         match t.testfn.padding() {\n             PadNone => 0,\n             PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n-    if let Some(t) = tests.iter().max_by_key(|t| len_if_padded(*t)) {\n-        let n = t.desc.name.as_slice();\n-        st.max_name_len = n.len();\n-    }\n-    run_tests(opts, tests, |x| callback(&x, &mut st, &mut out))?;\n+\n+    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n \n     assert!(st.current_test_count() == st.total);\n \n@@ -770,7 +836,7 @@ fn should_sort_failures_before_printing_them() {\n         allow_fail: false,\n     };\n \n-    let mut out = HumanFormatter::new(Raw(Vec::new()), false, false);\n+    let mut out = HumanFormatter::new(Raw(Vec::new()), false, false, 10);\n \n     let st = ConsoleTestState {\n         log_out: None,\n@@ -781,7 +847,6 @@ fn should_sort_failures_before_printing_them() {\n         allowed_fail: 0,\n         filtered_out: 0,\n         measured: 0,\n-        max_name_len: 10,\n         metrics: MetricMap::new(),\n         failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n         options: Options::new(),\n@@ -839,7 +904,7 @@ fn stdout_isatty() -> bool {\n #[derive(Clone)]\n pub enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n-    TeWait(TestDesc, NamePadding),\n+    TeWait(TestDesc),\n     TeResult(TestDesc, TestResult, Vec<u8>),\n     TeTimeout(TestDesc),\n     TeFilteredOut(usize),\n@@ -915,7 +980,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n     if concurrency == 1 {\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n-            callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n+            callback(TeWait(test.desc.clone()))?;\n             run_test(opts, !opts.run_tests, test, tx.clone());\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n@@ -926,6 +991,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n                 let test = remaining.pop().unwrap();\n                 let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n                 running_tests.insert(test.desc.clone(), timeout);\n+                callback(TeWait(test.desc.clone()))?; //here no pad\n                 run_test(opts, !opts.run_tests, test, tx.clone());\n                 pending += 1;\n             }\n@@ -949,7 +1015,6 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n             let (desc, result, stdout) = res.unwrap();\n             running_tests.remove(&desc);\n \n-            callback(TeWait(desc.clone(), PadNone))?;\n             callback(TeResult(desc, result, stdout))?;\n             pending -= 1;\n         }\n@@ -958,7 +1023,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n-            callback(TeWait(b.desc.clone(), b.testfn.padding()))?;\n+            callback(TeWait(b.desc.clone()))?;\n             run_test(opts, false, b, tx.clone());\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n@@ -1239,10 +1304,7 @@ pub fn run_test(opts: &TestOpts,\n             !cfg!(target_os = \"emscripten\") &&\n             !cfg!(target_arch = \"wasm32\");\n         if supports_threads {\n-            let cfg = thread::Builder::new().name(match name {\n-                DynTestName(ref name) => name.clone(),\n-                StaticTestName(name) => name.to_owned(),\n-            });\n+            let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             cfg.spawn(runtest).unwrap();\n         } else {\n             runtest();"}, {"sha": "1c52ebd7dc54e4fed51141cef0ae0539f62f1c42", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588a6a35be4446fbaaa792d08efee51e04e61fe8/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588a6a35be4446fbaaa792d08efee51e04e61fe8/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=588a6a35be4446fbaaa792d08efee51e04e61fe8", "patch": "@@ -485,7 +485,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         filter: config.filter.clone(),\n         filter_exact: config.filter_exact,\n         run_ignored: config.run_ignored,\n-        quiet: config.quiet,\n+        format: if config.quiet { test::OutputFormat::Terse } else { test::OutputFormat::Pretty },\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         bench_benchmarks: true,"}]}