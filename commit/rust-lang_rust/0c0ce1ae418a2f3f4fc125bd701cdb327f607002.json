{"sha": "0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMGNlMWFlNDE4YTJmM2Y0ZmMxMjViZDcwMWNkYjMyN2Y2MDcwMDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-05T14:16:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-05T15:55:54Z"}, "message": "Introduce ChildFromSource", "tree": {"sha": "596e533284a136297c8443094434c9738d24c435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/596e533284a136297c8443094434c9738d24c435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "html_url": "https://github.com/rust-lang/rust/commit/0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0bd068da39e74c66104206e27c270454e3562e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0bd068da39e74c66104206e27c270454e3562e", "html_url": "https://github.com/rust-lang/rust/commit/4c0bd068da39e74c66104206e27c270454e3562e"}], "stats": {"total": 418, "additions": 317, "deletions": 101}, "files": [{"sha": "58203c721b741d648320ca1187feb24344f0e283", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 40, "deletions": 101, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "patch": "@@ -1,17 +1,20 @@\n //! FIXME: write short doc here\n+use either::Either;\n \n-use hir_def::{nameres::ModuleSource, AstItemDef, LocationCtx, ModuleId};\n+use hir_def::{\n+    child_from_source::ChildFromSource, nameres::ModuleSource, AstItemDef, EnumVariantId,\n+    LocationCtx, ModuleId, VariantId,\n+};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    match_ast, AstPtr, SyntaxNode,\n+    match_ast, SyntaxNode,\n };\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n-    InFile, Local, MacroDef, Module, ModuleDef, Static, Struct, StructField, Trait, TypeAlias,\n-    Union, VariantDef,\n+    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, ImplBlock, InFile, Local,\n+    MacroDef, Module, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n pub trait FromSource: Sized {\n@@ -50,98 +53,45 @@ impl FromSource for Trait {\n impl FromSource for Function {\n     type Ast = ast::FnDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::Function(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::Function(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Trait(it) => it.id.child_from_source(db, src),\n+            Container::ImplBlock(it) => it.id.child_from_source(db, src),\n+            Container::Module(it) => it.id.child_from_source(db, src),\n+        }\n+        .map(Function::from)\n     }\n }\n \n impl FromSource for Const {\n     type Ast = ast::ConstDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::Const(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::Const(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Trait(it) => it.id.child_from_source(db, src),\n+            Container::ImplBlock(it) => it.id.child_from_source(db, src),\n+            Container::Module(it) => it.id.child_from_source(db, src),\n+        }\n+        .map(Const::from)\n     }\n }\n impl FromSource for Static {\n     type Ast = ast::StaticDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let module = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Module(it) => it,\n-            Container::Trait(_) | Container::ImplBlock(_) => return None,\n-        };\n-        module\n-            .declarations(db)\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                ModuleDef::Static(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Module(it) => it.id.child_from_source(db, src).map(Static::from),\n+            Container::Trait(_) | Container::ImplBlock(_) => None,\n+        }\n     }\n }\n \n impl FromSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::TypeAlias(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::TypeAlias(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Trait(it) => it.id.child_from_source(db, src),\n+            Container::ImplBlock(it) => it.id.child_from_source(db, src),\n+            Container::Module(it) => it.id.child_from_source(db, src),\n+        }\n+        .map(TypeAlias::from)\n     }\n }\n \n@@ -174,34 +124,33 @@ impl FromSource for EnumVariant {\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n         let parent_enum = src.value.parent_enum();\n         let src_enum = InFile { file_id: src.file_id, value: parent_enum };\n-        let variants = Enum::from_source(db, src_enum)?.variants(db);\n-        variants.into_iter().find(|v| same_source(&v.source(db), &src))\n+        let parent_enum = Enum::from_source(db, src_enum)?;\n+        parent_enum.id.child_from_source(db, src).map(EnumVariant::from)\n     }\n }\n \n impl FromSource for StructField {\n     type Ast = FieldSource;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let variant_def: VariantDef = match src.value {\n+        let variant_id: VariantId = match src.value {\n             FieldSource::Named(ref field) => {\n                 let value = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n                 let src = InFile { file_id: src.file_id, value };\n                 let def = Struct::from_source(db, src)?;\n-                VariantDef::from(def)\n+                def.id.into()\n             }\n             FieldSource::Pos(ref field) => {\n                 let value = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n                 let src = InFile { file_id: src.file_id, value };\n                 let def = EnumVariant::from_source(db, src)?;\n-                VariantDef::from(def)\n+                EnumVariantId::from(def).into()\n             }\n         };\n-        variant_def\n-            .variant_data(db)\n-            .fields()\n-            .iter()\n-            .map(|(id, _)| StructField { parent: variant_def, id })\n-            .find(|f| f.source(db) == src)\n+        let src = src.map(|field_source| match field_source {\n+            FieldSource::Pos(it) => Either::Left(it),\n+            FieldSource::Named(it) => Either::Right(it),\n+        });\n+        variant_id.child_from_source(db, src).map(StructField::from)\n     }\n }\n \n@@ -314,13 +263,3 @@ impl Container {\n         Some(Container::Module(c))\n     }\n }\n-\n-/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n-/// equal if they point to exactly the same object.\n-///\n-/// In general, we do not guarantee that we have exactly one instance of a\n-/// syntax tree for each file. We probably should add such guarantee, but, for\n-/// the time being, we will use identity-less AstPtr comparison.\n-fn same_source<N: AstNode>(s1: &InFile<N>, s2: &InFile<N>) -> bool {\n-    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n-}"}, {"sha": "37d4b787066bc75e9d49194e2be57dab5fb184af", "filename": "crates/ra_hir_def/src/child_from_source.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs?ref=0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "patch": "@@ -0,0 +1,276 @@\n+//! When *constructing* `hir`, we start at some parent syntax node and recursively\n+//! lower the children.\n+//!\n+//! This modules allows one to go in the opposite direction: start with a syntax\n+//! node for a *child*, and get its hir.\n+\n+use either::Either;\n+use hir_expand::InFile;\n+use ra_syntax::{ast, AstNode, AstPtr};\n+\n+use crate::{\n+    db::DefDatabase,\n+    src::{HasChildSource, HasSource},\n+    AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, ImplId, Lookup, ModuleDefId, ModuleId,\n+    StaticId, StructFieldId, TraitId, TypeAliasId, VariantId,\n+};\n+\n+pub trait ChildFromSource<CHILD, SOURCE> {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<SOURCE>,\n+    ) -> Option<CHILD>;\n+}\n+\n+impl ChildFromSource<FunctionId, ast::FnDef> for TraitId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::FnDef>,\n+    ) -> Option<FunctionId> {\n+        let data = db.trait_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|(_, item)| match item {\n+                AssocItemId::FunctionId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<FunctionId, ast::FnDef> for ImplId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::FnDef>,\n+    ) -> Option<FunctionId> {\n+        let data = db.impl_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|item| match item {\n+                AssocItemId::FunctionId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<FunctionId, ast::FnDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::FnDef>,\n+    ) -> Option<FunctionId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::FunctionId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<ConstId, ast::ConstDef> for TraitId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::ConstDef>,\n+    ) -> Option<ConstId> {\n+        let data = db.trait_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|(_, item)| match item {\n+                AssocItemId::ConstId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<ConstId, ast::ConstDef> for ImplId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::ConstDef>,\n+    ) -> Option<ConstId> {\n+        let data = db.impl_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|item| match item {\n+                AssocItemId::ConstId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<ConstId, ast::ConstDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::ConstDef>,\n+    ) -> Option<ConstId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::ConstId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for TraitId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        let data = db.trait_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|(_, item)| match item {\n+                AssocItemId::TypeAliasId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for ImplId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        let data = db.impl_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|item| match item {\n+                AssocItemId::TypeAliasId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::TypeAliasId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<StaticId, ast::StaticDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::StaticDef>,\n+    ) -> Option<StaticId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::StaticId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<StructFieldId, Either<ast::TupleFieldDef, ast::RecordFieldDef>> for VariantId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n+    ) -> Option<StructFieldId> {\n+        let arena_map = self.child_source(db);\n+        let (local_id, _) = arena_map.as_ref().value.iter().find(|(_local_id, source)| {\n+            child_source.file_id == arena_map.file_id\n+                && match (source, &child_source.value) {\n+                    (Either::Left(a), Either::Left(b)) => AstPtr::new(a) == AstPtr::new(b),\n+                    (Either::Right(a), Either::Right(b)) => AstPtr::new(a) == AstPtr::new(b),\n+                    _ => false,\n+                }\n+        })?;\n+        Some(StructFieldId { parent: *self, local_id })\n+    }\n+}\n+\n+impl ChildFromSource<EnumVariantId, ast::EnumVariant> for EnumId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::EnumVariant>,\n+    ) -> Option<EnumVariantId> {\n+        let arena_map = self.child_source(db);\n+        let (local_id, _) = arena_map.as_ref().value.iter().find(|(_local_id, source)| {\n+            child_source.file_id == arena_map.file_id\n+                && AstPtr::new(*source) == AstPtr::new(&child_source.value)\n+        })?;\n+        Some(EnumVariantId { parent: *self, local_id })\n+    }\n+}\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guarantee, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+fn same_source<N: AstNode>(s1: &InFile<N>, s2: &InFile<N>) -> bool {\n+    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n+}"}, {"sha": "e02622f62efc3c69923a5805e4c627794b658f0f", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0ce1ae418a2f3f4fc125bd701cdb327f607002/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=0c0ce1ae418a2f3f4fc125bd701cdb327f607002", "patch": "@@ -30,6 +30,7 @@ mod trace;\n pub mod nameres;\n \n pub mod src;\n+pub mod child_from_source;\n \n #[cfg(test)]\n mod test_db;"}]}