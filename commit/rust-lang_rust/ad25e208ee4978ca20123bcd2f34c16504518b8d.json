{"sha": "ad25e208ee4978ca20123bcd2f34c16504518b8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMjVlMjA4ZWU0OTc4Y2EyMDEyM2JjZDJmMzRjMTY1MDQ1MThiOGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-24T02:15:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-24T21:52:22Z"}, "message": "librustc: Allow `&mut` to be loaned; allow `self` to be loaned; make `&mut` loanable to `&`. r=nmatsakis", "tree": {"sha": "812ad433f7aaf53000f5bb257cb57c0100f518ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/812ad433f7aaf53000f5bb257cb57c0100f518ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad25e208ee4978ca20123bcd2f34c16504518b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad25e208ee4978ca20123bcd2f34c16504518b8d", "html_url": "https://github.com/rust-lang/rust/commit/ad25e208ee4978ca20123bcd2f34c16504518b8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad25e208ee4978ca20123bcd2f34c16504518b8d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbbb80559c8e321dc023c48579367e2ef1349b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbbb80559c8e321dc023c48579367e2ef1349b4b", "html_url": "https://github.com/rust-lang/rust/commit/bbbb80559c8e321dc023c48579367e2ef1349b4b"}], "stats": {"total": 504, "additions": 338, "deletions": 166}, "files": [{"sha": "7d7e16e930ca4d150c6b55ec9d675b10d42355d3", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -14,6 +14,7 @@\n #[forbid(deprecated_pattern)];\n #[warn(non_camel_case_types)];\n \n+use cast::transmute;\n use cast;\n use cmp::{Eq, Ord};\n use iter::BaseIter;\n@@ -477,14 +478,20 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // Memcopy the head element (the one we want) to the location we just\n         // popped. For the moment it unsafely exists at both the head and last\n         // positions\n-        let first_slice = view(*v, 0, 1);\n-        let last_slice = mut_view(*v, next_ln, ln);\n-        raw::copy_memory(last_slice, first_slice, 1);\n+        {\n+            let first_slice = view(*v, 0, 1);\n+            let last_slice = view(*v, next_ln, ln);\n+            raw::copy_memory(::cast::transmute(last_slice), first_slice, 1);\n+        }\n \n         // Memcopy everything to the left one element\n-        let init_slice = mut_view(*v, 0, next_ln);\n-        let tail_slice = view(*v, 1, ln);\n-        raw::copy_memory(init_slice, tail_slice, next_ln);\n+        {\n+            let init_slice = view(*v, 0, next_ln);\n+            let tail_slice = view(*v, 1, ln);\n+            raw::copy_memory(::cast::transmute(init_slice),\n+                             tail_slice,\n+                             next_ln);\n+        }\n \n         // Set the new length. Now the vector is back to normal\n         raw::set_len(&mut *v, next_ln);"}, {"sha": "ff5854322f456e0a84822f4692f2fd3ef7d9f4ff", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -22,9 +22,9 @@ use core::prelude::*;\n use middle::borrowck::{Loan, bckerr, borrowck_ctxt, cmt, inherent_mutability};\n use middle::borrowck::{req_maps, save_and_restore};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n-use middle::mem_categorization::{cat_local, cat_rvalue, cat_special, gc_ptr};\n-use middle::mem_categorization::{loan_path, lp_arg, lp_comp, lp_deref};\n-use middle::mem_categorization::{lp_local};\n+use middle::mem_categorization::{cat_local, cat_rvalue, cat_self};\n+use middle::mem_categorization::{cat_special, gc_ptr, loan_path, lp_arg};\n+use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -444,7 +444,7 @@ impl check_loan_ctxt {\n             self.check_for_loan_conflicting_with_assignment(\n                 at, ex, cmt, lp_base);\n           }\n-          lp_comp(*) | lp_local(*) | lp_arg(*) | lp_deref(*) => ()\n+          lp_comp(*) | lp_self | lp_local(*) | lp_arg(*) | lp_deref(*) => ()\n         }\n     }\n \n@@ -481,16 +481,13 @@ impl check_loan_ctxt {\n \n         match cmt.cat {\n           // Rvalues, locals, and arguments can be moved:\n-          cat_rvalue | cat_local(_) | cat_arg(_) => {}\n+          cat_rvalue | cat_local(_) | cat_arg(_) | cat_self(_) => {}\n \n           // We allow moving out of static items because the old code\n           // did.  This seems consistent with permitting moves out of\n           // rvalues, I guess.\n           cat_special(sk_static_item) => {}\n \n-          // We allow moving out of explicit self only.\n-          cat_special(sk_self) => {}\n-\n           cat_deref(_, _, unsafe_ptr) => {}\n \n           // Nothing else."}, {"sha": "967b1681b1bfb424a177c8377ab937bb94125e71", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -480,13 +480,44 @@ impl gather_loan_ctxt {\n             return;\n         }\n \n+        // Normally we wouldn't allow `re_free` here. However, in this case\n+        // it should be sound. Below is nmatsakis' reasoning:\n+        //\n+        // Perhaps [this permits] a function kind of like this one here, which\n+        // consumes one mut pointer and returns a narrower one:\n+        //\n+        //     struct Foo { f: int }\n+        //     fn foo(p: &v/mut Foo) -> &v/mut int { &mut p.f }\n+        //\n+        // I think this should work fine but there is more subtlety to it than\n+        // I at first imagined. Unfortunately it's a very important use case,\n+        // I think, so it really ought to work. The changes you [pcwalton]\n+        // made to permit re_free() do permit this case, I think, but I'm not\n+        // sure what else they permit. I have to think that over a bit.\n+        //\n+        // Ordinarily, a loan with scope re_free wouldn't make sense, because\n+        // you couldn't enforce it. But in this case, your function signature\n+        // informs the caller that you demand exclusive access to p and its\n+        // contents for the lifetime v. Since borrowed pointers are\n+        // non-copyable, they must have (a) made a borrow which will enforce\n+        // those conditions and then (b) given you the resulting pointer.\n+        // Therefore, they should be respecting the loan. So it actually seems\n+        // that it's ok in this case to have a loan with re_free, so long as\n+        // the scope of the loan is no greater than the region pointer on\n+        // which it is based. Neat but not something I had previously\n+        // considered all the way through. (Note that we already rely on\n+        // similar reasoning to permit you to return borrowed pointers into\n+        // immutable structures, this is just the converse I suppose)\n+\n         let scope_id = match scope_r {\n-            ty::re_scope(scope_id) => scope_id,\n+            ty::re_scope(scope_id) | ty::re_free(scope_id, _) => scope_id,\n             _ => {\n                 self.bccx.tcx.sess.span_bug(\n                     cmt.span,\n-                    fmt!(\"loans required but scope is scope_region is %s\",\n-                         region_to_str(self.tcx(), scope_r)));\n+                    fmt!(\"loans required but scope is scope_region is %s \\\n+                          (%?)\",\n+                         region_to_str(self.tcx(), scope_r),\n+                         scope_r));\n             }\n         };\n "}, {"sha": "1b274a5241c672a6286579e1ee83b1198e772725", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use middle::borrowck::{Loan, bckres, borrowck_ctxt, cmt, err_mutbl};\n use middle::borrowck::{err_out_of_scope};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n-use middle::mem_categorization::{cat_deref, cat_discr, cat_local};\n+use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n use middle::mem_categorization::{cat_special, cat_stack_upvar, comp_field};\n use middle::mem_categorization::{comp_index, comp_variant, gc_ptr};\n use middle::mem_categorization::{region_ptr};\n@@ -121,7 +121,7 @@ impl LoanContext {\n                 cmt.span,\n                 ~\"rvalue with a non-none lp\");\n           }\n-          cat_local(local_id) | cat_arg(local_id) => {\n+          cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n             let local_scope_id = self.tcx().region_map.get(local_id);\n             self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl)\n           }\n@@ -162,9 +162,18 @@ impl LoanContext {\n             // then the memory is freed.\n             self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n           }\n+          cat_deref(cmt_base, _, region_ptr(ast::m_mutbl, region)) => {\n+            // Mutable data can be loaned out as immutable or const. We must\n+            // loan out the base as well as the main memory. For example,\n+            // if someone borrows `*b`, we want to borrow `b` as immutable\n+            // as well.\n+            do self.loan(cmt_base, m_imm).chain |_| {\n+                self.issue_loan(cmt, region, m_const)\n+            }\n+          }\n           cat_deref(_, _, unsafe_ptr) |\n           cat_deref(_, _, gc_ptr(_)) |\n-          cat_deref(_, _, region_ptr(_)) => {\n+          cat_deref(_, _, region_ptr(_, _)) => {\n             // Aliased data is simply not lendable.\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,"}, {"sha": "4f7711c74a6980815742485e993bdb9b601442e3", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -20,7 +20,7 @@ use middle::borrowck::{cmt, err_mut_uniq, err_mut_variant};\n use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n use middle::borrowck::{err_root_not_permitted};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n-use middle::mem_categorization::{cat_discr, cat_local, cat_special};\n+use middle::mem_categorization::{cat_discr, cat_local, cat_self, cat_special};\n use middle::mem_categorization::{cat_stack_upvar, comp_field, comp_index};\n use middle::mem_categorization::{comp_variant, gc_ptr, region_ptr};\n use middle::ty;\n@@ -90,7 +90,6 @@ priv impl &preserve_ctxt {\n         let _i = indenter();\n \n         match cmt.cat {\n-          cat_special(sk_self) |\n           cat_special(sk_implicit_self) |\n           cat_special(sk_heap_upvar) => {\n             self.compare_scope(cmt, ty::re_scope(self.item_ub))\n@@ -148,6 +147,10 @@ priv impl &preserve_ctxt {\n             let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n+          cat_self(local_id) => {\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n+            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+          }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n           cat_comp(cmt_base, comp_tuple) |\n@@ -171,7 +174,7 @@ priv impl &preserve_ctxt {\n             // freed, so require imm.\n             self.require_imm(cmt, cmt_base, err_mut_uniq)\n           }\n-          cat_deref(_, _, region_ptr(region)) => {\n+          cat_deref(_, _, region_ptr(_, region)) => {\n             // References are always \"stable\" for lifetime `region` by\n             // induction (when the reference of type &MT was created,\n             // the memory must have been stable)."}, {"sha": "909d1f95fde4b9fb403d49610255143aad46d79a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -73,14 +73,15 @@ enum categorization {\n     cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n     cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n     cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n+    cat_self(ast::node_id),         // explicit `self`\n }\n \n // different kinds of pointers:\n #[deriving_eq]\n pub enum ptr_kind {\n     uniq_ptr,\n     gc_ptr(ast::mutability),\n-    region_ptr(ty::Region),\n+    region_ptr(ast::mutability, ty::Region),\n     unsafe_ptr\n }\n \n@@ -103,7 +104,6 @@ pub enum comp_kind {\n enum special_kind {\n     sk_method,\n     sk_static_item,\n-    sk_self,\n     sk_implicit_self,   // old by-reference `self`\n     sk_heap_upvar\n }\n@@ -135,45 +135,15 @@ impl cmt_ : cmp::Eq {\n // a loan path is like a category, but it exists only when the data is\n // interior to the stack frame.  loan paths are used as the key to a\n // map indicating what is borrowed at any point in time.\n+#[deriving_eq]\n pub enum loan_path {\n     lp_local(ast::node_id),\n     lp_arg(ast::node_id),\n+    lp_self,\n     lp_deref(@loan_path, ptr_kind),\n     lp_comp(@loan_path, comp_kind)\n }\n \n-impl loan_path : cmp::Eq {\n-    pure fn eq(&self, other: &loan_path) -> bool {\n-        match (*self) {\n-            lp_local(e0a) => {\n-                match (*other) {\n-                    lp_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_arg(e0a) => {\n-                match (*other) {\n-                    lp_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_deref(e0a, e1a) => {\n-                match (*other) {\n-                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            lp_comp(e0a, e1a) => {\n-                match (*other) {\n-                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &loan_path) -> bool { !(*self).eq(other) }\n-}\n-\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n@@ -193,14 +163,17 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         Some(deref_ptr(uniq_ptr))\n       }\n \n-      ty::ty_rptr(r, _) |\n-      ty::ty_evec(_, ty::vstore_slice(r)) |\n+      ty::ty_rptr(r, mt) |\n+      ty::ty_evec(mt, ty::vstore_slice(r)) => {\n+        Some(deref_ptr(region_ptr(mt.mutbl, r)))\n+      }\n+\n       ty::ty_estr(ty::vstore_slice(r)) => {\n-        Some(deref_ptr(region_ptr(r)))\n+        Some(deref_ptr(region_ptr(ast::m_imm, r)))\n       }\n \n       ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBorrowed => {\n-        Some(deref_ptr(region_ptr((*f).meta.region)))\n+        Some(deref_ptr(region_ptr(ast::m_imm, (*f).meta.region)))\n       }\n \n       ty::ty_box(mt) |\n@@ -481,15 +454,18 @@ impl &mem_categorization_ctxt {\n               mutbl:m, ty:expr_ty}\n           }\n \n-          ast::def_self(_, is_implicit) => {\n-            let special_kind = if is_implicit {\n-                sk_implicit_self\n+          ast::def_self(self_id, is_implicit) => {\n+            let cat, loan_path;\n+            if is_implicit {\n+                cat = cat_special(sk_implicit_self);\n+                loan_path = None;\n             } else {\n-                sk_self\n+                cat = cat_self(self_id);\n+                loan_path = Some(@lp_self);\n             };\n \n             @{id:id, span:span,\n-              cat:cat_special(special_kind), lp:None,\n+              cat:cat, lp:loan_path,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n@@ -626,13 +602,16 @@ impl &mem_categorization_ctxt {\n             deref_ptr(ptr) => {\n                 let lp = do base_cmt.lp.chain_ref |l| {\n                     // Given that the ptr itself is loanable, we can\n-                    // loan out deref'd uniq ptrs as the data they are\n-                    // the only way to reach the data they point at.\n-                    // Other ptr types admit aliases and are therefore\n-                    // not loanable.\n+                    // loan out deref'd uniq ptrs or mut ptrs as the data\n+                    // they are the only way to mutably reach the data they\n+                    // point at. Other ptr types admit mutable aliases and\n+                    // are therefore not loanable.\n                     match ptr {\n-                        uniq_ptr => {Some(@lp_deref(*l, ptr))}\n-                        gc_ptr(*) | region_ptr(_) | unsafe_ptr => {None}\n+                        uniq_ptr => Some(@lp_deref(*l, ptr)),\n+                        region_ptr(ast::m_mutbl, _) => {\n+                            Some(@lp_deref(*l, ptr))\n+                        }\n+                        gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => None\n                     }\n                 };\n \n@@ -642,7 +621,7 @@ impl &mem_categorization_ctxt {\n                     uniq_ptr => {\n                         self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                     }\n-                    gc_ptr(*) | region_ptr(_) | unsafe_ptr => {\n+                    gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => {\n                         mt.mutbl\n                     }\n                 };\n@@ -688,7 +667,7 @@ impl &mem_categorization_ctxt {\n               uniq_ptr => {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n-              gc_ptr(_) | region_ptr(_) | unsafe_ptr => {\n+              gc_ptr(_) | region_ptr(_, _) | unsafe_ptr => {\n                 mt.mutbl\n               }\n             };\n@@ -866,13 +845,13 @@ impl &mem_categorization_ctxt {\n           cat_special(sk_method) => ~\"method\",\n           cat_special(sk_static_item) => ~\"static_item\",\n           cat_special(sk_implicit_self) => ~\"implicit-self\",\n-          cat_special(sk_self) => ~\"self\",\n           cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n           cat_stack_upvar(_) => ~\"stack-upvar\",\n           cat_rvalue => ~\"rvalue\",\n           cat_local(node_id) => fmt!(\"local(%d)\", node_id),\n           cat_binding(node_id) => fmt!(\"binding(%d)\", node_id),\n           cat_arg(node_id) => fmt!(\"arg(%d)\", node_id),\n+          cat_self(node_id) => fmt!(\"self(%d)\", node_id),\n           cat_deref(cmt, derefs, ptr) => {\n             fmt!(\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n                  self.ptr_sigil(ptr), derefs)\n@@ -896,7 +875,7 @@ impl &mem_categorization_ctxt {\n         match ptr {\n           uniq_ptr => ~\"~\",\n           gc_ptr(_) => ~\"@\",\n-          region_ptr(_) => ~\"&\",\n+          region_ptr(_, _) => ~\"&\",\n           unsafe_ptr => ~\"*\"\n         }\n     }\n@@ -919,6 +898,7 @@ impl &mem_categorization_ctxt {\n           lp_arg(node_id) => {\n             fmt!(\"arg(%d)\", node_id)\n           }\n+          lp_self => ~\"self\",\n           lp_deref(lp, ptr) => {\n             fmt!(\"%s->(%s)\", self.lp_to_str(lp),\n                  self.ptr_sigil(ptr))\n@@ -945,13 +925,13 @@ impl &mem_categorization_ctxt {\n           cat_special(sk_method) => ~\"method\",\n           cat_special(sk_static_item) => ~\"static item\",\n           cat_special(sk_implicit_self) => ~\"self reference\",\n-          cat_special(sk_self) => ~\"self value\",\n           cat_special(sk_heap_upvar) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n           cat_rvalue => ~\"non-lvalue\",\n           cat_local(_) => mut_str + ~\" local variable\",\n           cat_binding(_) => ~\"pattern binding\",\n+          cat_self(_) => ~\"self value\",\n           cat_arg(_) => ~\"argument\",\n           cat_deref(_, _, pk) => fmt!(\"dereference of %s %s pointer\",\n                                       mut_str, self.ptr_sigil(pk)),\n@@ -1045,7 +1025,8 @@ impl categorization {\n             cat_special(*) |\n             cat_local(*) |\n             cat_binding(*) |\n-            cat_arg(*) => {\n+            cat_arg(*) |\n+            cat_self(*) => {\n                 false\n             }\n         }"}, {"sha": "dd355f6df702c707e3a1a6f26e669a22a008373c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -336,6 +336,14 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n         }\n     };\n \n+    // Record the ID of `self`.\n+    match fk {\n+        visit::fk_method(_, _, method) => {\n+            cx.region_map.insert(method.self_id, body.node.id);\n+        }\n+        _ => {}\n+    }\n+\n     debug!(\"visiting fn with body %d. cx.parent: %? \\\n             fn_cx.parent: %?\",\n            body.node.id, cx.parent, fn_cx.parent);"}, {"sha": "536f43d648c459ae19dd3661c221e408e3378a59", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -241,19 +241,24 @@ fn check_poison(is_mutex: bool, failed: bool) {\n \n #[doc(hidden)]\n struct PoisonOnFail {\n-    failed: &mut bool,\n+    failed: *mut bool,\n }\n \n impl PoisonOnFail : Drop {\n     fn finalize(&self) {\n-        /* assert !*self.failed; -- might be false in case of cond.wait() */\n-        if task::failing() { *self.failed = true; }\n+        unsafe {\n+            /* assert !*self.failed;\n+               -- might be false in case of cond.wait() */\n+            if task::failing() {\n+                *self.failed = true;\n+            }\n+        }\n     }\n }\n \n-fn PoisonOnFail(failed: &r/mut bool) -> PoisonOnFail/&r {\n+fn PoisonOnFail(failed: &r/mut bool) -> PoisonOnFail {\n     PoisonOnFail {\n-        failed: failed\n+        failed: ptr::to_mut_unsafe_ptr(failed)\n     }\n }\n \n@@ -415,7 +420,7 @@ pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n fn borrow_rwlock<T: Const Owned>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n-    unsafe { cast::transmute_immut(&mut state.lock) }\n+    unsafe { cast::transmute(&mut state.lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n@@ -442,12 +447,14 @@ impl<T: Const Owned> &RWWriteMode<T> {\n         match *self {\n             RWWriteMode((ref data, ref token, ref poison)) => {\n                 do token.write_cond |cond| {\n-                    let cvar = Condvar {\n-                        is_mutex: false,\n-                        failed: &mut *poison.failed,\n-                        cond: cond\n-                    };\n-                    blk(&mut **data, &cvar)\n+                    unsafe {\n+                        let cvar = Condvar {\n+                            is_mutex: false,\n+                            failed: &mut *poison.failed,\n+                            cond: cond\n+                        };\n+                        blk(&mut **data, &cvar)\n+                    }\n                 }\n             }\n         }"}, {"sha": "01b62797a8d7621a2cde37ed847b843d134cab1d", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -19,6 +19,7 @@ use core::vec;\n #[abi = \"rust-intrinsic\"]\n extern \"C\" mod rusti {\n     fn move_val_init<T>(dst: &mut T, -src: T);\n+    fn init<T>() -> T;\n }\n \n pub struct PriorityQueue <T: Ord>{\n@@ -136,8 +137,9 @@ impl <T: Ord> PriorityQueue<T> {\n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n-                    rusti::move_val_init(&mut self.data[pos],\n-                                         move *addr_of(&self.data[parent]));\n+                    let mut x = rusti::init();\n+                    x <-> self.data[parent];\n+                    rusti::move_val_init(&mut self.data[pos], move x);\n                     pos = parent;\n                     loop\n                 }\n@@ -159,8 +161,9 @@ impl <T: Ord> PriorityQueue<T> {\n                 if right < end && !(self.data[child] > self.data[right]) {\n                     child = right;\n                 }\n-                rusti::move_val_init(&mut self.data[pos],\n-                                     move *addr_of(&self.data[child]));\n+                let mut x = rusti::init();\n+                x <-> self.data[child];\n+                rusti::move_val_init(&mut self.data[pos], move x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }"}, {"sha": "36d919494f13d45abeacd130a56eadcb1ba4b023", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 110, "deletions": 58, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -55,8 +55,10 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n                 unsafe { // unsafe as a purity workaround\n                     // ICE: x.next() != y.next()\n \n-                    let (x1, x2) = x.next().unwrap();\n-                    let (y1, y2) = y.next().unwrap();\n+                    x = x.next();\n+                    y = y.next();\n+                    let (x1, x2) = x.get().unwrap();\n+                    let (y1, y2) = y.get().unwrap();\n \n                     if x1 != y1 || x2 != y2 {\n                         return false\n@@ -160,35 +162,46 @@ impl <K: Ord, V> TreeMap<K, V> {\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root}\n+        TreeMapIterator{stack: ~[], node: &self.root, current: None}\n     }\n }\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<K: Ord, V> {\n     priv stack: ~[&~TreeNode<K, V>],\n-    priv node: &Option<~TreeNode<K, V>>\n+    priv node: &Option<~TreeNode<K, V>>,\n+    priv current: Option<&~TreeNode<K, V>>\n }\n \n impl <K: Ord, V> TreeMapIterator<K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&self/K, &self/V)> {\n-        while !self.stack.is_empty() || self.node.is_some() {\n-            match *self.node {\n+    // Returns the current node, or None if this iterator is at the end.\n+    fn get(&const self) -> Option<(&self/K, &self/V)> {\n+        match self.current {\n+            Some(res) => Some((&res.key, &res.value)),\n+            None => None\n+        }\n+    }\n+\n+    /// Advance the iterator to the next node (in order). If this iterator\n+    /// is finished, does nothing.\n+    fn next(self) -> TreeMapIterator/&self<K, V> {\n+        let mut this = self;\n+        while !this.stack.is_empty() || this.node.is_some() {\n+            match *this.node {\n               Some(ref x) => {\n-                self.stack.push(x);\n-                self.node = &x.left;\n+                this.stack.push(x);\n+                this.node = &x.left;\n               }\n               None => {\n-                let res = self.stack.pop();\n-                self.node = &res.right;\n-                return Some((&res.key, &res.value));\n+                let res = this.stack.pop();\n+                this.node = &res.right;\n+                this.current = Some(res);\n+                return this;\n               }\n             }\n         }\n-        None\n+        this.current = None;\n+        return this;\n     }\n }\n \n@@ -256,15 +269,19 @@ impl <T: Ord> TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            let mut a = x.next();\n-            let mut b = y.next();\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    a = x.next();\n+                    x = x.next();\n+                    a = x.get();\n                 } else if b1 < a1 {\n-                    b = y.next();\n+                    y = y.next();\n+                    b = y.get();\n                 } else {\n                     return false;\n                 }\n@@ -283,8 +300,10 @@ impl <T: Ord> TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            let mut a = x.next();\n-            let mut b = y.next();\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n             while b.is_some() {\n                 if a.is_none() {\n                     return false\n@@ -298,9 +317,11 @@ impl <T: Ord> TreeSet<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    b = y.next();\n+                    y = y.next();\n+                    b = y.get();\n                 }\n-                a = x.next();\n+                x = x.next();\n+                a = x.get();\n             }\n         }\n         true\n@@ -312,13 +333,15 @@ impl <T: Ord> TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            let mut a = x.next();\n-            let mut b = y.next();\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next() } else { None }\n+                        if f(a1) { x = x.next(); x.get() } else { None }\n                     }\n                 }\n \n@@ -327,10 +350,12 @@ impl <T: Ord> TreeSet<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    a = x.next();\n+                    x = x.next();\n+                    a = x.get();\n                 } else {\n-                    if !(b1 < a1) { a = x.next() }\n-                    b = y.next();\n+                    if !(b1 < a1) { x = x.next(); a = x.get() }\n+                    y = y.next();\n+                    b = y.get();\n                 }\n             }\n         }\n@@ -343,13 +368,15 @@ impl <T: Ord> TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            let mut a = x.next();\n-            let mut b = y.next();\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next() } else { None }\n+                        if f(a1) { x.next(); x.get() } else { None }\n                     }\n                 }\n \n@@ -358,18 +385,21 @@ impl <T: Ord> TreeSet<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    a = x.next();\n+                    x = x.next();\n+                    a = x.get();\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        a = x.next();\n+                        x = x.next();\n+                        a = x.get();\n                     }\n-                    b = y.next();\n+                    y = y.next();\n+                    b = y.get();\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { y.next() } else { None }\n+                if f(b1) { y = y.next(); y.get() } else { None }\n             }\n         }\n     }\n@@ -380,19 +410,23 @@ impl <T: Ord> TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            let mut a = x.next();\n-            let mut b = y.next();\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    a = x.next();\n+                    x = x.next();\n+                    a = x.get();\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    b = y.next();\n+                    y = y.next();\n+                    b = y.get();\n                 }\n             }\n         }\n@@ -404,13 +438,15 @@ impl <T: Ord> TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            let mut a = x.next();\n-            let mut b = y.next();\n+            x = x.next();\n+            y = y.next();\n+            let mut a = x.get();\n+            let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next() } else { None }\n+                        if f(a1) { x = x.next(); x.get() } else { None }\n                     }\n                 }\n \n@@ -419,13 +455,16 @@ impl <T: Ord> TreeSet<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    b = y.next();\n+                    y = y.next();\n+                    b = y.get();\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        b = y.next()\n+                        y = y.next();\n+                        b = y.get()\n                     }\n-                    a = x.next();\n+                    x = x.next();\n+                    a = x.get();\n                 }\n             }\n         }\n@@ -438,11 +477,18 @@ pub struct TreeSetIterator<T: Ord> {\n }\n \n impl <T: Ord> TreeSetIterator<T> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the value. If there are no more nodes,\n-    /// return `None`.\n-    fn next(&mut self) -> Option<&self/T> {\n-        self.iter.next().map_consume(|(x, _)| x)\n+    /// Returns the current node, or None if this iterator is at the end.\n+    fn get(&const self) -> Option<&self/T> {\n+        match self.iter.get() {\n+            None => None,\n+            Some((k, _)) => Some(k)\n+        }\n+    }\n+\n+    /// Advance the iterator to the next node (in order). If this iterator is\n+    /// finished, does nothing.\n+    fn next(self) -> TreeSetIterator/&self<T> {\n+        TreeSetIterator { iter: self.iter.next() }\n     }\n }\n \n@@ -854,17 +900,23 @@ mod test_treemap {\n         //assert iter.next() == Some((&x1, &y1));\n         //assert iter.next().eq(&Some((&x1, &y1)));\n \n-        assert iter.next().unwrap() == (&x1, &y1);\n-        assert iter.next().unwrap() == (&x2, &y2);\n-        assert iter.next().unwrap() == (&x3, &y3);\n-        assert iter.next().unwrap() == (&x4, &y4);\n-        assert iter.next().unwrap() == (&x5, &y5);\n+        iter = iter.next();\n+        assert iter.get().unwrap() == (&x1, &y1);\n+        iter = iter.next();\n+        assert iter.get().unwrap() == (&x2, &y2);\n+        iter = iter.next();\n+        assert iter.get().unwrap() == (&x3, &y3);\n+        iter = iter.next();\n+        assert iter.get().unwrap() == (&x4, &y4);\n+        iter = iter.next();\n+        assert iter.get().unwrap() == (&x5, &y5);\n \n         // ICE:\n         //assert iter.next() == None;\n         //assert iter.next().eq(&None);\n \n-        assert iter.next().is_none();\n+        iter = iter.next();\n+        assert iter.get().is_none();\n     }\n }\n "}, {"sha": "0aec458aef43c4696ea8d61eb30951443dc79c6c", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     do (&mut x).with |opt| {  //~ ERROR illegal borrow\n         match opt {\n             &Right(ref f) => {\n-                x = X(Left((0,0)));\n+                x = X(Left((0,0))); //~ ERROR assigning to captured outer mutable variable\n                 (*f)()\n             },\n             _ => fail"}, {"sha": "4e0cc76bf7543e19dd9392cc512b0335858b865e", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -19,7 +19,7 @@ impl Foo {\n }\n \n fn a(x: &mut Foo) {\n-    x.f(); //~ ERROR illegal borrow unless pure\n+    x.f();\n     x.g();\n     x.h();\n }"}, {"sha": "5c3fe229602545b11ad96af01b01660e945453cf", "filename": "src/test/compile-fail/borrowck-imm-field-mut-base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -22,8 +22,9 @@ fn main() {\n     let q = &mut b.foo; //~ ERROR loan of mutable field as mutable conflicts with prior loan\n     //~^ ERROR loan of mutable local variable as mutable conflicts with prior loan\n     let r = &mut b; //~ ERROR loan of mutable local variable as mutable conflicts with prior loan\n+    //~^ ERROR loan of mutable local variable as mutable conflicts with prior loan\n     io::println(fmt!(\"*p = %u\", *p));\n     q.x += 1;\n     r.foo.x += 1;\n     io::println(fmt!(\"*p = %u\", *p));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "88db5f5434116a67d243239fbdb8afc91c6ab12c", "filename": "src/test/compile-fail/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     let mut _a = 3;\n-    let _b = &mut _a;\n+    let _b = &mut _a; //~ NOTE loan of mutable local variable granted here\n     {\n-        let _c = &*_b; //~ ERROR illegal borrow unless pure\n-        _a = 4; //~ NOTE impure due to assigning to mutable local variable\n+        let _c = &*_b;\n+        _a = 4; //~ ERROR assigning to mutable local variable prohibited\n     }\n }"}, {"sha": "48d39c39e5a47df00f59afd5261bedee927934dd", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -11,19 +11,19 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: &mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure\n+    borrow(*v); // OK: &mut -> &imm\n }\n \n fn box_rec_mut(v: &{mut f: ~int}) {\n     borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_mut_rec(v: &mut {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure\n+    borrow(v.f); // OK: &mut -> &imm\n }\n \n fn box_mut_recs(v: &mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n+    borrow(v.f.g.h); // OK: &mut -> &imm\n }\n \n fn box_imm(v: &~int) {"}, {"sha": "e47ad721b0d7b604ad93440cd75414439e96d400", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let mut b = ~3;\n+    let _x = &mut *b;   //~ NOTE prior loan as mutable granted here\n+    let _y = &mut *b;   //~ ERROR loan of dereference of mutable ~ pointer as mutable conflicts with prior loan\n+}\n+"}, {"sha": "015f368ecb0688794cecf879c35123ee8f31994e", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let mut a = ~3;\n+    let mut b = &mut a; //~ NOTE loan of mutable local variable granted here\n+    let _c = &mut *b;\n+    let mut d = /*move*/ a; //~ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+    *d += 1;\n+}\n+"}, {"sha": "36d32fddda1503bf2c827c94eb675af7cdf2c4d3", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut b = ~3;\n+    let _x = &mut *b;   //~ NOTE loan of mutable local variable granted here\n+    let mut y = /*move*/ b; //~ ERROR moving out of mutable local variable prohibited\n+    *y += 1;\n+}\n+"}, {"sha": "ba85616e63f283cf1e56fe8ef06b62248d36bcbb", "filename": "src/test/compile-fail/borrowck-wg-move-base-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,11 @@\n+fn foo(x: &mut int) {\n+    let mut a = 3;\n+    let mut _y = &mut *x;\n+    let _z = &mut *_y;\n+    _y = &mut a; //~ ERROR assigning to mutable local variable prohibited\n+}\n+\n+fn main() {\n+}\n+\n+"}, {"sha": "da5e3c2660ef78f558fc77ded3b3ec0627ef5016", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -15,7 +15,7 @@ fn broken() {\n     while x < 10 {\n         let mut z = x;\n         _y.push(&mut z); //~ ERROR illegal borrow\n-        x += 1;\n+        x += 1; //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n     }\n }\n "}, {"sha": "126135772ade08da981e21da8b3a5126fdc4d69e", "filename": "src/test/run-fail/borrowck-wg-fail-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "previous_filename": "src/test/run-fail/write-guard-fail-2.rs"}, {"sha": "ad4c794212121f07306806ace70b941421300043", "filename": "src/test/run-fail/borrowck-wg-fail-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "previous_filename": "src/test/run-fail/write-guard-fail-3.rs"}, {"sha": "d393832c6e862496bbaa97877f9cbb49c4830392", "filename": "src/test/run-fail/borrowck-wg-fail.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "previous_filename": "src/test/run-fail/write-guard-fail.rs"}, {"sha": "04e00b5972c59cf2f5ca52dccead713f3b4fd2cf", "filename": "src/test/run-pass/borrowck-binding-mutbl.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -16,8 +16,7 @@ fn main() {\n \n     match x {\n       {f: ref mut v} => {\n-        impure(*v); //~ ERROR illegal borrow unless pure\n-        //~^ NOTE impure due to access to impure function\n+        impure(*v);\n       }\n     }\n }", "previous_filename": "src/test/compile-fail/borrowck-binding-mutbl.rs"}, {"sha": "745f8f7f35744c705726f3b2bee1c9a6cae5e2d3", "filename": "src/test/run-pass/borrowck-lend-args.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-lend-args.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -15,8 +15,7 @@ fn borrow_from_arg_imm_ref(&&v: ~int) {\n }\n \n fn borrow_from_arg_mut_ref(v: &mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure\n-    //~^ NOTE impure due to access to impure function\n+    borrow(*v);\n }\n \n fn borrow_from_arg_move(-v: ~int) {", "previous_filename": "src/test/compile-fail/borrowck-lend-args.rs"}, {"sha": "12dc0c3a310ad32cfa8ae9d9486375fc80b9e833", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-2.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,13 @@\n+struct Cat;\n+\n+fn bar(_: &Cat) {\n+}\n+\n+fn foo(cat: &mut Cat) {\n+    bar(&*cat);\n+}\n+\n+fn main() {\n+    let mut mimi = ~Cat;\n+    foo(mimi);\n+}"}, {"sha": "66e29f3af3d37f00d2580beb8d94294006cead06", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,18 @@\n+struct Wizard {\n+    spells: ~[&static/str]\n+}\n+\n+impl Wizard {\n+    fn cast(&mut self) {\n+        for self.spells.each |&spell| {\n+            io::println(spell);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut harry = Wizard {\n+        spells: ~[ \"expelliarmus\", \"expecto patronum\", \"incendio\" ]\n+    };\n+    harry.cast();\n+}"}, {"sha": "36155a9d2660498a914612c886d325981af42a56", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "patch": "@@ -0,0 +1,12 @@\n+fn g(x: &Option<int>) {\n+    io::println(x.get().to_str());\n+}\n+\n+fn f(x: &mut Option<int>) {\n+    g(&*x);\n+}\n+\n+fn main() {\n+    let mut x = ~Some(3);\n+    f(x);\n+}"}, {"sha": "bc370b20d155be51aea08931259747595d09b855", "filename": "src/test/run-pass/borrowck-wg-simple.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad25e208ee4978ca20123bcd2f34c16504518b8d/src%2Ftest%2Frun-pass%2Fborrowck-wg-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-simple.rs?ref=ad25e208ee4978ca20123bcd2f34c16504518b8d", "previous_filename": "src/test/run-pass/write-guard.rs"}]}