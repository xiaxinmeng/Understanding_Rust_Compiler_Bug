{"sha": "8b3c851dd37f39f79e7e8807378f45fdde7f6411", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiM2M4NTFkZDM3ZjM5Zjc5ZTdlODgwNzM3OGY0NWZkZGU3ZjY0MTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-22T20:46:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-22T20:46:24Z"}, "message": "Merge #6098\n\n6098: Insert ref for completions r=adamrk a=adamrk\n\nFollow up to https://github.com/rust-analyzer/rust-analyzer/pull/5846. When we have a local in scope which needs a ref or mutable ref to match the name and type of the active in the completion context then a new completion item with `&` or `&mut ` is inserted. E.g.\r\n```rust\r\nfn foo(arg: &i32){};\r\nfn main() {\r\n    let arg = 1_i32;\r\n    foo(a<|>)\r\n}\r\n```\r\nnow offers `&arg` as a completion option with the highest score.\n\nCo-authored-by: adamrk <ark.email@gmail.com>", "tree": {"sha": "d6c20cd94e6291d6e4c3b8f58a17817d61463d79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c20cd94e6291d6e4c3b8f58a17817d61463d79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b3c851dd37f39f79e7e8807378f45fdde7f6411", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfke+gCRBK7hj4Ov3rIwAAdHIIAByRg26Vjto7uy4PARKWJB03\nx6dTMX1r0SHZKcesdWYgoET+zEi9Mj37PKi0CNJ1j6HExePe698N4ttQqoEIlmwj\nhOlXMVRaTHRtZkaTqKeY7Gld4+pOeqVHSULCLpHMXXF2pNY3uCqr8jzXf1qmaTl7\ntrLtB6XCrX5N+5I0wiPhWHiPFT2s4s/FBQxG+qfG+C0yhX0iI453mq/N+6FqUsNI\na0noBE1IX8NNW21c3saceQb8wMqIlbxY66LIW5NpTulH5y5c34k6z0nNIzLPEGmO\ne1BlEhbwXaJZuxCqwPW6hPuAhQmheJiUv1Xe5U9pqP0NIuCnkL2Mvf4aLEmENOA=\n=fMZj\n-----END PGP SIGNATURE-----\n", "payload": "tree d6c20cd94e6291d6e4c3b8f58a17817d61463d79\nparent edf46a13a6a28093985d2d934ef97570947b9494\nparent 3dbbcfca67ed09322227f2190b5364754a29a216\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1603399584 +0000\ncommitter GitHub <noreply@github.com> 1603399584 +0000\n\nMerge #6098\n\n6098: Insert ref for completions r=adamrk a=adamrk\n\nFollow up to https://github.com/rust-analyzer/rust-analyzer/pull/5846. When we have a local in scope which needs a ref or mutable ref to match the name and type of the active in the completion context then a new completion item with `&` or `&mut ` is inserted. E.g.\r\n```rust\r\nfn foo(arg: &i32){};\r\nfn main() {\r\n    let arg = 1_i32;\r\n    foo(a<|>)\r\n}\r\n```\r\nnow offers `&arg` as a completion option with the highest score.\n\nCo-authored-by: adamrk <ark.email@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3c851dd37f39f79e7e8807378f45fdde7f6411", "html_url": "https://github.com/rust-lang/rust/commit/8b3c851dd37f39f79e7e8807378f45fdde7f6411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b3c851dd37f39f79e7e8807378f45fdde7f6411/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf46a13a6a28093985d2d934ef97570947b9494", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf46a13a6a28093985d2d934ef97570947b9494", "html_url": "https://github.com/rust-lang/rust/commit/edf46a13a6a28093985d2d934ef97570947b9494"}, {"sha": "3dbbcfca67ed09322227f2190b5364754a29a216", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbbcfca67ed09322227f2190b5364754a29a216", "html_url": "https://github.com/rust-lang/rust/commit/3dbbcfca67ed09322227f2190b5364754a29a216"}], "stats": {"total": 158, "additions": 132, "deletions": 26}, "files": [{"sha": "e4f86d0e010acab6df446827569e475b43f31caf", "filename": "crates/completion/src/completion_context.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Fcompletion%2Fsrc%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Fcompletion%2Fsrc%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletion_context.rs?ref=8b3c851dd37f39f79e7e8807378f45fdde7f6411", "patch": "@@ -246,6 +246,19 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n+    pub(crate) fn active_name_and_type(&self) -> Option<(String, Type)> {\n+        if let Some(record_field) = &self.record_field_syntax {\n+            mark::hit!(record_field_type_match);\n+            let (struct_field, _local) = self.sema.resolve_record_field(record_field)?;\n+            Some((struct_field.name(self.db).to_string(), struct_field.signature_ty(self.db)))\n+        } else if let Some(active_parameter) = &self.active_parameter {\n+            mark::hit!(active_param_type_match);\n+            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);"}, {"sha": "2e1ca0e595bdacbf509d0193d7cefa4294e21952", "filename": "crates/completion/src/completion_item.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Fcompletion%2Fsrc%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Fcompletion%2Fsrc%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletion_item.rs?ref=8b3c851dd37f39f79e7e8807378f45fdde7f6411", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt;\n \n-use hir::Documentation;\n+use hir::{Documentation, Mutability};\n use syntax::TextRange;\n use text_edit::TextEdit;\n \n@@ -56,6 +56,10 @@ pub struct CompletionItem {\n \n     /// Score is useful to pre select or display in better order completion items\n     score: Option<CompletionScore>,\n+\n+    /// Indicates that a reference or mutable reference to this variable is a\n+    /// possible match.\n+    ref_match: Option<(Mutability, CompletionScore)>,\n }\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n@@ -194,6 +198,7 @@ impl CompletionItem {\n             deprecated: None,\n             trigger_call_info: None,\n             score: None,\n+            ref_match: None,\n         }\n     }\n     /// What user sees in pop-up in the UI.\n@@ -240,10 +245,15 @@ impl CompletionItem {\n     pub fn trigger_call_info(&self) -> bool {\n         self.trigger_call_info\n     }\n+\n+    pub fn ref_match(&self) -> Option<(Mutability, CompletionScore)> {\n+        self.ref_match\n+    }\n }\n \n /// A helper to make `CompletionItem`s.\n #[must_use]\n+#[derive(Clone)]\n pub(crate) struct Builder {\n     source_range: TextRange,\n     completion_kind: CompletionKind,\n@@ -258,6 +268,7 @@ pub(crate) struct Builder {\n     deprecated: Option<bool>,\n     trigger_call_info: Option<bool>,\n     score: Option<CompletionScore>,\n+    ref_match: Option<(Mutability, CompletionScore)>,\n }\n \n impl Builder {\n@@ -288,6 +299,7 @@ impl Builder {\n             deprecated: self.deprecated.unwrap_or(false),\n             trigger_call_info: self.trigger_call_info.unwrap_or(false),\n             score: self.score,\n+            ref_match: self.ref_match,\n         }\n     }\n     pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n@@ -350,6 +362,13 @@ impl Builder {\n         self.trigger_call_info = Some(true);\n         self\n     }\n+    pub(crate) fn set_ref_match(\n+        mut self,\n+        ref_match: Option<(Mutability, CompletionScore)>,\n+    ) -> Builder {\n+        self.ref_match = ref_match;\n+        self\n+    }\n }\n \n impl<'a> Into<CompletionItem> for Builder {"}, {"sha": "2a19281cfe48607be1acb0d47d899d12b36a4a3d", "filename": "crates/completion/src/presentation.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Fcompletion%2Fsrc%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Fcompletion%2Fsrc%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fpresentation.rs?ref=8b3c851dd37f39f79e7e8807378f45fdde7f6411", "patch": "@@ -1,7 +1,7 @@\n //! This modules takes care of rendering various definitions as completion items.\n //! It also handles scoring (sorting) completions.\n \n-use hir::{HasAttrs, HasSource, HirDisplay, ModPath, ScopeDef, StructKind, Type};\n+use hir::{HasAttrs, HasSource, HirDisplay, ModPath, Mutability, ScopeDef, StructKind, Type};\n use itertools::Itertools;\n use syntax::{ast::NameOwner, display::*};\n use test_utils::mark;\n@@ -107,9 +107,16 @@ impl Completions {\n             }\n         };\n \n+        let mut ref_match = None;\n         if let ScopeDef::Local(local) = resolution {\n-            if let Some(score) = compute_score(ctx, &local.ty(ctx.db), &local_name) {\n-                completion_item = completion_item.set_score(score);\n+            if let Some((active_name, active_type)) = ctx.active_name_and_type() {\n+                let ty = local.ty(ctx.db);\n+                if let Some(score) =\n+                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n+                {\n+                    completion_item = completion_item.set_score(score);\n+                }\n+                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n             }\n         }\n \n@@ -131,7 +138,7 @@ impl Completions {\n             }\n         }\n \n-        completion_item.kind(kind).set_documentation(docs).add_to(self)\n+        completion_item.kind(kind).set_documentation(docs).set_ref_match(ref_match).add_to(self)\n     }\n \n     pub(crate) fn add_macro(\n@@ -342,25 +349,15 @@ impl Completions {\n     }\n }\n \n-pub(crate) fn compute_score(\n-    ctx: &CompletionContext,\n+fn compute_score_from_active(\n+    active_type: &Type,\n+    active_name: &str,\n     ty: &Type,\n     name: &str,\n ) -> Option<CompletionScore> {\n-    let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n-        mark::hit!(record_field_type_match);\n-        let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n-        (struct_field.name(ctx.db).to_string(), struct_field.signature_ty(ctx.db))\n-    } else if let Some(active_parameter) = &ctx.active_parameter {\n-        mark::hit!(active_param_type_match);\n-        (active_parameter.name.clone(), active_parameter.ty.clone())\n-    } else {\n-        return None;\n-    };\n-\n     // Compute score\n     // For the same type\n-    if &active_type != ty {\n+    if active_type != ty {\n         return None;\n     }\n \n@@ -373,6 +370,24 @@ pub(crate) fn compute_score(\n \n     Some(res)\n }\n+fn refed_type_matches(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<(Mutability, CompletionScore)> {\n+    let derefed_active = active_type.remove_ref()?;\n+    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n+    Some((\n+        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n+        score,\n+    ))\n+}\n+\n+fn compute_score(ctx: &CompletionContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n+    let (active_name, active_type) = ctx.active_name_and_type()?;\n+    compute_score_from_active(&active_type, &active_name, ty, name)\n+}\n \n enum Params {\n     Named(Vec<String>),"}, {"sha": "2680e5f08bce63d30067695b13ccff6f5c53449d", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=8b3c851dd37f39f79e7e8807378f45fdde7f6411", "patch": "@@ -570,7 +570,7 @@ pub(crate) fn handle_completion(\n     let line_endings = snap.file_line_endings(position.file_id);\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n-        .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n+        .flat_map(|item| to_proto::completion_item(&line_index, line_endings, item))\n         .collect();\n \n     Ok(Some(items.into()))"}, {"sha": "24ad4920611d411cbcc8abb441ae575b77035b44", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c851dd37f39f79e7e8807378f45fdde7f6411/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=8b3c851dd37f39f79e7e8807378f45fdde7f6411", "patch": "@@ -160,7 +160,13 @@ pub(crate) fn completion_item(\n     line_index: &LineIndex,\n     line_endings: LineEndings,\n     completion_item: CompletionItem,\n-) -> lsp_types::CompletionItem {\n+) -> Vec<lsp_types::CompletionItem> {\n+    fn set_score(res: &mut lsp_types::CompletionItem, label: &str) {\n+        res.preselect = Some(true);\n+        // HACK: sort preselect items first\n+        res.sort_text = Some(format!(\" {}\", label));\n+    }\n+\n     let mut additional_text_edits = Vec::new();\n     let mut text_edit = None;\n     // LSP does not allow arbitrary edits in completion, so we have to do a\n@@ -200,9 +206,7 @@ pub(crate) fn completion_item(\n     };\n \n     if completion_item.score().is_some() {\n-        res.preselect = Some(true);\n-        // HACK: sort preselect items first\n-        res.sort_text = Some(format!(\" {}\", completion_item.label()));\n+        set_score(&mut res, completion_item.label());\n     }\n \n     if completion_item.deprecated() {\n@@ -217,9 +221,22 @@ pub(crate) fn completion_item(\n         });\n     }\n \n-    res.insert_text_format = Some(insert_text_format(completion_item.insert_text_format()));\n+    let mut all_results = match completion_item.ref_match() {\n+        Some(ref_match) => {\n+            let mut refed = res.clone();\n+            let (mutability, _score) = ref_match;\n+            let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), refed.label);\n+            set_score(&mut refed, &label);\n+            refed.label = label;\n+            vec![res, refed]\n+        }\n+        None => vec![res],\n+    };\n \n-    res\n+    for mut r in all_results.iter_mut() {\n+        r.insert_text_format = Some(insert_text_format(completion_item.insert_text_format()));\n+    }\n+    all_results\n }\n \n pub(crate) fn signature_help(\n@@ -775,6 +792,48 @@ mod tests {\n \n     use super::*;\n \n+    #[test]\n+    fn test_completion_with_ref() {\n+        let fixture = r#\"\n+        struct Foo;\n+        fn foo(arg: &Foo) {}\n+        fn main() {\n+            let arg = Foo;\n+            foo(<|>)\n+        }\"#;\n+\n+        let (offset, text) = test_utils::extract_offset(fixture);\n+        let line_index = LineIndex::new(&text);\n+        let (analysis, file_id) = Analysis::from_single_file(text);\n+        let completions: Vec<(String, Option<String>)> = analysis\n+            .completions(\n+                &ide::CompletionConfig::default(),\n+                base_db::FilePosition { file_id, offset },\n+            )\n+            .unwrap()\n+            .unwrap()\n+            .into_iter()\n+            .filter(|c| c.label().ends_with(\"arg\"))\n+            .map(|c| completion_item(&line_index, LineEndings::Unix, c))\n+            .flat_map(|comps| comps.into_iter().map(|c| (c.label, c.sort_text)))\n+            .collect();\n+        expect_test::expect![[r#\"\n+            [\n+                (\n+                    \"arg\",\n+                    None,\n+                ),\n+                (\n+                    \"&arg\",\n+                    Some(\n+                        \" &arg\",\n+                    ),\n+                ),\n+            ]\n+        \"#]]\n+        .assert_debug_eq(&completions);\n+    }\n+\n     #[test]\n     fn conv_fold_line_folding_only_fixup() {\n         let text = r#\"mod a;"}]}