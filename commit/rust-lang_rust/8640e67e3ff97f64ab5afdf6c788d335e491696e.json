{"sha": "8640e67e3ff97f64ab5afdf6c788d335e491696e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NDBlNjdlM2ZmOTdmNjRhYjVhZmRmNmM3ODhkMzM1ZTQ5MTY5NmU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-17T17:18:30Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-17T17:18:30Z"}, "message": "Add a precondition to GEP_tup_like", "tree": {"sha": "45e3fb31cf10b6306c969dca9d2830b69f9cbfd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45e3fb31cf10b6306c969dca9d2830b69f9cbfd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8640e67e3ff97f64ab5afdf6c788d335e491696e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8640e67e3ff97f64ab5afdf6c788d335e491696e", "html_url": "https://github.com/rust-lang/rust/commit/8640e67e3ff97f64ab5afdf6c788d335e491696e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8640e67e3ff97f64ab5afdf6c788d335e491696e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b98eccfeefb0e6f4f741096089edd072338c055", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b98eccfeefb0e6f4f741096089edd072338c055", "html_url": "https://github.com/rust-lang/rust/commit/2b98eccfeefb0e6f4f741096089edd072338c055"}], "stats": {"total": 77, "additions": 73, "deletions": 4}, "files": [{"sha": "887c8e6a230b51190f534496ce1552c8e893b5b5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8640e67e3ff97f64ab5afdf6c788d335e491696e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640e67e3ff97f64ab5afdf6c788d335e491696e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8640e67e3ff97f64ab5afdf6c788d335e491696e", "patch": "@@ -610,6 +610,8 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n }\n \n fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n+// FIXME: Typestate constraint that shows this alt is\n+// exhaustive\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n         let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n@@ -668,9 +670,8 @@ fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n-fn GEP_tup_like(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int]) ->\n-   result {\n-    assert (ty::type_is_tup_like(bcx_tcx(cx), t));\n+fn GEP_tup_like(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n+    : type_is_tup_like(cx, t) -> result {\n     // It might be a static-known type. Handle this.\n     if !ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n         ret rslt(cx, GEPi(cx, base, ixs));\n@@ -785,6 +786,8 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: ast::def_id,\n     } else { llunionptr = llblobptr; }\n \n     // Do the GEP_tup_like().\n+    // Silly check -- postcondition on mk_tup?\n+    check type_is_tup_like(cx, tup_ty);\n     let rs = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix as int]);\n     // Cast the result to the appropriate type, if necessary.\n \n@@ -1403,12 +1406,15 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n \n+    // Silly check\n+    check type_is_tup_like(cx, tup_ty);\n     let drop_flag = GEP_tup_like(cx, tup_ty, rs, [0, 0]);\n     cx = drop_flag.bcx;\n     let null_test = IsNull(cx, Load(cx, drop_flag.val));\n     CondBr(cx, null_test, next_cx.llbb, drop_cx.llbb);\n     cx = drop_cx;\n \n+    check type_is_tup_like(cx, tup_ty);\n     let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n@@ -1641,10 +1647,15 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         ret cx;\n     }\n \n+    /*\n+    Typestate constraint that shows the unimpl case doesn't happen?\n+    */\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_rec(fields) {\n         let i: int = 0;\n         for fld: ty::field in fields {\n+            // Silly check\n+            check type_is_tup_like(cx, t);\n             let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n             cx = f(bcx, llfld_a, fld.mt.ty);\n             i += 1;\n@@ -1653,6 +1664,8 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n       ty::ty_tup(args) {\n         let i = 0;\n         for arg in args {\n+            // Silly check\n+            check type_is_tup_like(cx, t);\n             let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n             cx = f(bcx, llfld_a, arg);\n             i += 1;\n@@ -1663,6 +1676,8 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n         let inner_t_s = ty::substitute_type_params(tcx, tps, inner);\n         let tup_t = ty::mk_tup(tcx, [ty::mk_int(tcx), inner_t_s]);\n+        // Silly check\n+        check type_is_tup_like(cx, tup_t);\n         let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, tup_t, av, [0, 1]);\n         ret f(bcx, llfld_a, inner1);\n       }\n@@ -2543,11 +2558,15 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n     // Copy expr values into boxed bindings.\n     let i = 0u;\n+    // Silly check\n+    check type_is_tup_like(bcx, closure_ty);\n     let bindings =\n         GEP_tup_like(bcx, closure_ty, closure,\n                      [0, abi::closure_elt_bindings]);\n     bcx = bindings.bcx;\n     for lv: lval_result in bound_vals {\n+        // Also a silly check\n+        check type_is_tup_like(bcx, bindings_ty);\n         let bound =\n             GEP_tup_like(bcx, bindings_ty, bindings.val, [0, i as int]);\n         bcx = bound.bcx;\n@@ -2559,6 +2578,8 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n+    // Silly check as well\n+    check type_is_tup_like(bcx, closure_ty);\n     let ty_params_slot =\n         GEP_tup_like(bcx, closure_ty, closure,\n                      [0, abi::closure_elt_ty_params]);\n@@ -2663,6 +2684,8 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n     // If this is an aliasing closure/for-each body, we need to load\n     // the iterbody.\n     if !copying && !option::is_none(enclosing_cx.fcx.lliterbody) {\n+        // Silly check\n+        check type_is_tup_like(bcx, ty);\n         let iterbodyptr = GEP_tup_like(bcx, ty, llclosure, path + [0]);\n         fcx.lliterbody = some(Load(bcx, iterbodyptr.val));\n         bcx = iterbodyptr.bcx;\n@@ -2671,6 +2694,8 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n \n     // Load the actual upvars.\n     for upvar_def in *upvars {\n+        // Silly check\n+        check type_is_tup_like(bcx, ty);\n         let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n         bcx = upvarptr.bcx;\n         let llupvarptr = upvarptr.val;\n@@ -2984,7 +3009,10 @@ fn trans_field_inner(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_rec(fields) {\n         let ix: uint = ty::field_idx(bcx_ccx(cx).sess, sp, field, fields);\n-        let v = GEP_tup_like(r.bcx, t, r.val, [0, ix as int]);\n+        let r_bcx = r.bcx;\n+        // Silly check\n+        check type_is_tup_like(r_bcx, t);\n+        let v = GEP_tup_like(r_bcx, t, r.val, [0, ix as int]);\n         ret lval_no_env(v.bcx, v.val, true);\n       }\n       ty::ty_obj(methods) {\n@@ -3329,6 +3357,8 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n         (fptr, C_null(T_opaque_closure_ptr(*bcx_ccx(bcx))), 0)\n       }\n       none. {\n+        // Silly check\n+        check type_is_tup_like(bcx, closure_ty);\n         let {bcx: cx, val: pair} =\n             GEP_tup_like(bcx, closure_ty, llclosure,\n                          [0, abi::box_rc_field_body,\n@@ -3368,6 +3398,8 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // Copy in the type parameters.\n     let i: uint = 0u;\n     while i < ty_param_count {\n+        // Silly check\n+        check type_is_tup_like(copy_args_bcx, closure_ty);\n         let lltyparam_ptr =\n             GEP_tup_like(copy_args_bcx, closure_ty, llclosure,\n                          [0, abi::box_rc_field_body,\n@@ -3391,6 +3423,8 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n+            // Silly check\n+            check type_is_tup_like(bcx, closure_ty);\n             let bound_arg =\n                 GEP_tup_like(bcx, closure_ty, llclosure,\n                              [0, abi::box_rc_field_body,\n@@ -3914,6 +3948,8 @@ fn trans_tup(cx: @block_ctxt, elts: [@ast::expr], id: ast::node_id) ->\n         let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n         let src = trans_lval(bcx, e);\n         bcx = src.bcx;\n+        // FIXME: constraint on argument?\n+        check type_is_tup_like(bcx, t);\n         let dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n         bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty);\n         i += 1;\n@@ -3943,6 +3979,8 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n     alt ty::struct(bcx_tcx(cx), t) { ty::ty_rec(flds) { ty_fields = flds; } }\n     for tf: ty::field in ty_fields {\n         let e_ty = tf.mt.ty;\n+        // FIXME: constraint on argument?\n+        check type_is_tup_like(bcx, t);\n         let dst_res = GEP_tup_like(bcx, t, rec_val, [0, i]);\n         bcx = dst_res.bcx;\n         let expr_provided = false;\n@@ -3956,6 +3994,8 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n             }\n         }\n         if !expr_provided {\n+            // FIXME: constraint on argument?\n+            check type_is_tup_like(bcx, t);\n             let src_res = GEP_tup_like(bcx, t, base_val, [0, i]);\n             src_res =\n                 rslt(src_res.bcx, load_if_immediate(bcx, src_res.val, e_ty));\n@@ -5100,6 +5140,8 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     }\n     i = 0;\n     for f: ast::obj_field in fcx.lcx.obj_fields {\n+        // FIXME: silly check\n+        check type_is_tup_like(bcx, fields_tup_ty);\n         let rslt = GEP_tup_like(bcx, fields_tup_ty, obj_fields, [0, i]);\n         bcx = llstaticallocas_block_ctxt(fcx);\n         let llfield = rslt.val;\n@@ -5248,9 +5290,12 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n         llretptr = BitCast(bcx, llretptr, llret_t);\n     }\n \n+    // FIXME: silly checks\n+    check type_is_tup_like(bcx, tup_t);\n     let dst = GEP_tup_like(bcx, tup_t, llretptr, [0, 1]);\n     bcx = dst.bcx;\n     bcx = copy_val(bcx, INIT, dst.val, arg, arg_t);\n+    check type_is_tup_like(bcx, tup_t);\n     let flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n     bcx = flag.bcx;\n     Store(bcx, C_int(1), flag.val);"}, {"sha": "eea4704c3d080aef1f25b046b0b9b5c7f33cb9e8", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8640e67e3ff97f64ab5afdf6c788d335e491696e/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640e67e3ff97f64ab5afdf6c788d335e491696e/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=8640e67e3ff97f64ab5afdf6c788d335e491696e", "patch": "@@ -342,6 +342,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         for field_name: ast::ident in rec_fields {\n             let ix: uint =\n                 ty::field_idx(ccx.sess, dummy_sp(), field_name, fields);\n+            // not sure how to get rid of this check\n+            check type_is_tup_like(bcx, rec_ty);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             rec_vals += [r.val];\n             bcx = r.bcx;\n@@ -359,6 +361,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             };\n         let tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n+            // how to get rid of this check?\n+            check type_is_tup_like(bcx, tup_ty);\n             let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             tup_vals += [r.val];\n             bcx = r.bcx;\n@@ -603,6 +607,8 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         for f: ast::field_pat in fields {\n             let ix: uint =\n                 ty::field_idx(ccx.sess, pat.span, f.ident, rec_fields);\n+            // how to get rid of this check?\n+            check type_is_tup_like(bcx, rec_ty);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, table, make_copy);\n         }\n@@ -611,6 +617,8 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let tup_ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n+            // how to get rid of this check?\n+            check type_is_tup_like(bcx, tup_ty);\n             let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(r.bcx, elem, r.val, table, make_copy);\n             i += 1u;"}, {"sha": "99eacedaf3b389e6ae6806002d087487a58559b1", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8640e67e3ff97f64ab5afdf6c788d335e491696e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640e67e3ff97f64ab5afdf6c788d335e491696e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=8640e67e3ff97f64ab5afdf6c788d335e491696e", "patch": "@@ -121,11 +121,14 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n         // the types of the object's fields, so that the fields can be freed\n         // later.\n \n+        // postcondition on create_object_body_type?\n+        check type_is_tup_like(bcx, body_ty);\n         let body_tydesc =\n             GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none;\n \n+        check type_is_tup_like(bcx, body_ty);\n         let r =\n             GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_typarams]);\n         bcx = r.bcx;\n@@ -151,6 +154,8 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n         let i: int = 0;\n         for tp: ast::ty_param in ty_params {\n             let typaram = bcx.fcx.lltydescs[i];\n+            // Silly check\n+            check type_is_tup_like(bcx, typarams_ty);\n             let capture =\n                 GEP_tup_like(bcx, typarams_ty, body_typarams, [0, i]);\n             bcx = capture.bcx;\n@@ -159,6 +164,8 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n         }\n \n         // Copy args into body fields.\n+        // how to get rid of this check?\n+        check type_is_tup_like(bcx, body_ty);\n         let body_fields =\n             GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n@@ -169,6 +176,8 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n                 let arg = load_if_immediate(bcx, arg1, arg_tys[i].ty);\n                 // TODO: can we just get fields_ty out of body_ty instead?\n                 let fields_ty: ty::t = ty::mk_tup(ccx.tcx, obj_fields);\n+                // Silly check\n+                check type_is_tup_like(bcx, fields_ty);\n                 let field =\n                     GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n                 bcx = field.bcx;\n@@ -314,6 +323,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n         // the user of the object.  So the tydesc is needed to keep track of\n         // the types of the object's fields, so that the fields can be freed\n         // later.\n+        // postcondition on create_object_body_type?\n+        check type_is_tup_like(bcx, body_ty);\n         let body_tydesc =\n             GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n@@ -328,6 +339,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n         // body.  (This is something like saving the lexical environment of a\n         // function in its closure: the fields were passed to the object\n         // constructor and are now available to the object's methods.\n+        check type_is_tup_like(bcx, body_ty);\n         let body_fields =\n             GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n@@ -338,6 +350,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n             load_if_immediate(bcx, additional_field_vals[i].val,\n                               additional_field_tys[i]);\n             let fields_ty: ty::t = ty::mk_tup(ccx.tcx, additional_field_tys);\n+            // Silly check\n+            check type_is_tup_like(bcx, fields_ty);\n             let field = GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n             bcx = field.bcx;\n             bcx =\n@@ -356,6 +370,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n             // value) wrapped in a result.\n             let inner_obj_val: result = trans_expr(bcx, e);\n \n+            check type_is_tup_like(bcx, body_ty);\n             let body_inner_obj =\n                 GEP_tup_like(bcx, body_ty, body,\n                              [0, abi::obj_body_elt_inner_obj]);\n@@ -776,6 +791,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n                     T_ptr(type_of(cx_ccx, sp, body_ty)));\n \n     // Now, reach into the body and grab the inner_obj.\n+    check type_is_tup_like(bcx, body_ty);\n     let llinner_obj =\n         GEP_tup_like(bcx, body_ty, llself_obj_body,\n                      [0, abi::obj_body_elt_inner_obj]);"}]}