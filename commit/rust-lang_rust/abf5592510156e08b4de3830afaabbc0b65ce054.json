{"sha": "abf5592510156e08b4de3830afaabbc0b65ce054", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZjU1OTI1MTAxNTZlMDhiNGRlMzgzMGFmYWFiYmMwYjY1Y2UwNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-29T07:06:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-29T07:06:13Z"}, "message": "Auto merge of #40338 - GuillaumeGomez:pulldown-switch, r=frewsxcv,steveklabnik\n\nReplace hoedown with pull in rustdoc\n\ncc @rust-lang/docs", "tree": {"sha": "9695a70dd5011efd447aa114cc04e533b8cd6f59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9695a70dd5011efd447aa114cc04e533b8cd6f59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf5592510156e08b4de3830afaabbc0b65ce054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf5592510156e08b4de3830afaabbc0b65ce054", "html_url": "https://github.com/rust-lang/rust/commit/abf5592510156e08b4de3830afaabbc0b65ce054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf5592510156e08b4de3830afaabbc0b65ce054/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4465f22ef6498db65059a41595d354a7af56cbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/4465f22ef6498db65059a41595d354a7af56cbea", "html_url": "https://github.com/rust-lang/rust/commit/4465f22ef6498db65059a41595d354a7af56cbea"}, {"sha": "a7c6d3e16a71fc0dcce4c9be09d031d746f84a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7c6d3e16a71fc0dcce4c9be09d031d746f84a69", "html_url": "https://github.com/rust-lang/rust/commit/a7c6d3e16a71fc0dcce4c9be09d031d746f84a69"}], "stats": {"total": 1077, "additions": 555, "deletions": 522}, "files": [{"sha": "53d17874924093c298f0f111f1c4c4d680c68f55", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -5,10 +5,6 @@\n [submodule \"src/compiler-rt\"]\n \tpath = src/compiler-rt\n \turl = https://github.com/rust-lang/compiler-rt.git\n-[submodule \"src/rt/hoedown\"]\n-\tpath = src/rt/hoedown\n-\turl = https://github.com/rust-lang/hoedown.git\n-\tbranch = rust-2015-09-21-do-not-delete\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git"}, {"sha": "a9021dc34e207438edb537e673f3511c461aa7b9", "filename": "src/Cargo.lock", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -8,7 +8,7 @@ dependencies = [\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.6.2\"\n+version = \"0.6.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -27,7 +27,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -65,7 +65,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"0.8.0\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -75,7 +75,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -104,12 +104,12 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.21.1\"\n+version = \"2.22.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"bitflags 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -122,7 +122,7 @@ name = \"cmake\"\n version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -140,7 +140,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -188,7 +188,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -197,7 +197,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.44\"\n+version = \"0.3.45\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -215,10 +215,10 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"handlebars\"\n-version = \"0.25.1\"\n+version = \"0.25.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -243,7 +243,7 @@ dependencies = [\n \n [[package]]\n name = \"lazy_static\"\n-version = \"0.2.4\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -272,9 +272,9 @@ name = \"mdbook\"\n version = \"0.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"handlebars 0.25.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -358,6 +358,14 @@ dependencies = [\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.0.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"qemu-test-client\"\n version = \"0.1.0\"\n@@ -383,7 +391,7 @@ name = \"regex\"\n version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -416,7 +424,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -593,7 +601,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -770,8 +778,9 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n@@ -818,7 +827,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -978,22 +987,22 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n-\"checksum aho-corasick 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0638fd549427caa90c499814196d1b9e3725eb4d15d7339d6de073a680ed0ca2\"\n+\"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n \"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n \"checksum bitflags 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23\"\n-\"checksum bitflags 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e1ab483fc81a8143faa7203c4a3c02888ebd1a782e37e41fa34753ba9a162\"\n-\"checksum clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74a80f603221c9cd9aa27a28f52af452850051598537bb6b359c38a7d61e5cda\"\n+\"checksum bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1370e9fc2a6ae53aea8b7a5110edbd08836ed87c88736dfabccade1c2b44bff4\"\n+\"checksum clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e17a4a72ffea176f77d6e2db609c6c919ef221f23862c9915e687fb54d833485\"\n \"checksum cmake 0.1.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d18d68987ed4c516dcc3e7913659bfa4076f5182eea4a7e0038bb060953e76ac\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3856f1697098606fc6cb97a93de88ca3f3bc35bb878c725920e6e82ecf05e83\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a32cd40070d7611ab76343dcb3204b2bb28c8a9450989a83a3d590248142f439\"\n+\"checksum gcc 0.3.45 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40899336fb50db0c78710f53e87afc54d8c7266fb76262fecc78ca1a7f09deae\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2249f6f0dc5a3bb2b3b1a8f797dfccbc4b053344d773d654ad565e51427d335\"\n+\"checksum handlebars 0.25.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"663e1728d8037fb0d4e13bcd1b1909fb5d913690a9929eb385922df157c2ff8f\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum lazy_static 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7291b1dd97d331f752620b02dfdbc231df7fc01bf282a00769e1cdb963c460dc\"\n+\"checksum lazy_static 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4732c563b9a21a406565c4747daa7b46742f082911ae4753f390dc9ec7ee1a97\"\n \"checksum libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88ee81885f9f04bff991e306fea7c1c60a5f0f9e409e99f6b40e3311a3363135\"\n \"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n \"checksum mdbook 0.0.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"06a68e8738e42b38a02755d3ce5fa12d559e17acb238e4326cbc3cc056e65280\"\n@@ -1002,6 +1011,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n+\"checksum pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab1e588ef8efd702c7ed9d2bd774db5e6f4d878bb5a1a9f371828fbdff6973\"\n \"checksum pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1058d7bb927ca067656537eec4e02c2b4b70eaaa129664c5b90c111e20326f41\"\n \"checksum quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0aad603e8d7fb67da22dbdf1f4b826ce8829e406124109e73cf1b2454b93a71c\"\n \"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\""}, {"sha": "c46b0c1324de6e1987df9afd69382ec53275ebda", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -838,10 +838,10 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// assert_eq!(1909, good_year);\n     /// assert_eq!(0, bad_year);\n+    /// ```\n     ///\n     /// [`parse`]: ../../std/primitive.str.html#method.parse\n     /// [`FromStr`]: ../../std/str/trait.FromStr.html\n-    /// ```\n     #[inline]\n     #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n     pub fn unwrap_or_default(self) -> T {"}, {"sha": "52f5d99838dc7c342047ed4bd0e19e74844e2b2f", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -2,7 +2,6 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustdoc\"\n version = \"0.0.0\"\n-build = \"build.rs\"\n \n [lib]\n name = \"rustdoc\"\n@@ -26,6 +25,7 @@ rustc_trans = { path = \"../librustc_trans\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+pulldown-cmark = { version = \"0.0.14\", default-features = false }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "9fa6406c1d8b69d14175484997cf569f76eec5f1", "filename": "src/librustdoc/build.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4465f22ef6498db65059a41595d354a7af56cbea/src%2Flibrustdoc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4465f22ef6498db65059a41595d354a7af56cbea/src%2Flibrustdoc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fbuild.rs?ref=4465f22ef6498db65059a41595d354a7af56cbea", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate build_helper;\n-extern crate gcc;\n-\n-fn main() {\n-    let src_dir = std::path::Path::new(\"../rt/hoedown/src\");\n-    build_helper::rerun_if_changed_anything_in_dir(src_dir);\n-    let mut cfg = gcc::Config::new();\n-    cfg.file(\"../rt/hoedown/src/autolink.c\")\n-       .file(\"../rt/hoedown/src/buffer.c\")\n-       .file(\"../rt/hoedown/src/document.c\")\n-       .file(\"../rt/hoedown/src/escape.c\")\n-       .file(\"../rt/hoedown/src/html.c\")\n-       .file(\"../rt/hoedown/src/html_blocks.c\")\n-       .file(\"../rt/hoedown/src/html_smartypants.c\")\n-       .file(\"../rt/hoedown/src/stack.c\")\n-       .file(\"../rt/hoedown/src/version.c\")\n-       .include(src_dir)\n-       .compile(\"libhoedown.a\");\n-}"}, {"sha": "117cfbabb52f7211379bdfa040aa9258967802a9", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 502, "deletions": 449, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -10,29 +10,25 @@\n \n //! Markdown formatting for rustdoc\n //!\n-//! This module implements markdown formatting through the hoedown C-library\n-//! (bundled into the rust runtime). This module self-contains the C bindings\n-//! and necessary legwork to render markdown, and exposes all of the\n+//! This module implements markdown formatting through the pulldown-cmark\n+//! rust-library. This module exposes all of the\n //! functionality through a unit-struct, `Markdown`, which has an implementation\n //! of `fmt::Display`. Example usage:\n //!\n //! ```rust,ignore\n-//! use rustdoc::html::markdown::Markdown;\n+//! use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle};\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s));\n+//! let html = format!(\"{}\", Markdown(s, MarkdownOutputStyle::Fancy));\n //! // ... something using html\n //! ```\n \n #![allow(non_camel_case_types)]\n \n-use libc;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::default::Default;\n-use std::ffi::CString;\n use std::fmt::{self, Write};\n-use std::slice;\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::codemap::Span;\n@@ -43,156 +39,41 @@ use html::highlight;\n use html::escape::Escape;\n use test;\n \n+use pulldown_cmark::{self, Event, Parser, Tag};\n+\n+#[derive(Copy, Clone)]\n+pub enum MarkdownOutputStyle {\n+    Compact,\n+    Fancy,\n+}\n+\n+impl MarkdownOutputStyle {\n+    pub fn is_compact(&self) -> bool {\n+        match *self {\n+            MarkdownOutputStyle::Compact => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_fancy(&self) -> bool {\n+        match *self {\n+            MarkdownOutputStyle::Fancy => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-pub struct Markdown<'a>(pub &'a str);\n+// The second parameter is whether we need a shorter version or not.\n+pub struct Markdown<'a>(pub &'a str, pub MarkdownOutputStyle);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str);\n \n-const DEF_OUNIT: libc::size_t = 64;\n-const HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 11;\n-const HOEDOWN_EXT_TABLES: libc::c_uint = 1 << 0;\n-const HOEDOWN_EXT_FENCED_CODE: libc::c_uint = 1 << 1;\n-const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n-const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n-const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n-const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n-const HOEDOWN_HTML_ESCAPE: libc::c_uint = 1 << 1;\n-\n-const HOEDOWN_EXTENSIONS: libc::c_uint =\n-    HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n-    HOEDOWN_EXT_FENCED_CODE | HOEDOWN_EXT_AUTOLINK |\n-    HOEDOWN_EXT_STRIKETHROUGH | HOEDOWN_EXT_SUPERSCRIPT |\n-    HOEDOWN_EXT_FOOTNOTES;\n-\n-enum hoedown_document {}\n-\n-type blockcodefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 *const hoedown_buffer, *const hoedown_renderer_data,\n-                                 libc::size_t);\n-\n-type blockquotefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                  *const hoedown_renderer_data, libc::size_t);\n-\n-type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                              libc::c_int, *const hoedown_renderer_data,\n-                              libc::size_t);\n-\n-type blockhtmlfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 *const hoedown_renderer_data, libc::size_t);\n-\n-type codespanfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n-\n-type linkfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n-                             *const hoedown_buffer, *const hoedown_buffer,\n-                             *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n-\n-type entityfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n-                               *const hoedown_renderer_data, libc::size_t);\n-\n-type normaltextfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                  *const hoedown_renderer_data, libc::size_t);\n-\n-#[repr(C)]\n-struct hoedown_renderer_data {\n-    opaque: *mut libc::c_void,\n-}\n-\n-#[repr(C)]\n-struct hoedown_renderer {\n-    opaque: *mut libc::c_void,\n-\n-    blockcode: Option<blockcodefn>,\n-    blockquote: Option<blockquotefn>,\n-    header: Option<headerfn>,\n-\n-    other_block_level_callbacks: [libc::size_t; 11],\n-\n-    blockhtml: Option<blockhtmlfn>,\n-\n-    /* span level callbacks - NULL or return 0 prints the span verbatim */\n-    autolink: libc::size_t, // unused\n-    codespan: Option<codespanfn>,\n-    other_span_level_callbacks_1: [libc::size_t; 7],\n-    link: Option<linkfn>,\n-    other_span_level_callbacks_2: [libc::size_t; 6],\n-\n-    /* low level callbacks - NULL copies input directly into the output */\n-    entity: Option<entityfn>,\n-    normal_text: Option<normaltextfn>,\n-\n-    /* header and footer */\n-    other_callbacks: [libc::size_t; 2],\n-}\n-\n-#[repr(C)]\n-struct hoedown_html_renderer_state {\n-    opaque: *mut libc::c_void,\n-    toc_data: html_toc_data,\n-    flags: libc::c_uint,\n-    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer,\n-                                          *const hoedown_buffer,\n-                                          *const hoedown_renderer_data)>,\n-}\n-\n-#[repr(C)]\n-struct html_toc_data {\n-    header_count: libc::c_int,\n-    current_level: libc::c_int,\n-    level_offset: libc::c_int,\n-    nesting_level: libc::c_int,\n-}\n-\n-struct MyOpaque {\n-    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                           *const hoedown_buffer, *const hoedown_renderer_data,\n-                           libc::size_t),\n-    toc_builder: Option<TocBuilder>,\n-}\n-\n-#[repr(C)]\n-struct hoedown_buffer {\n-    data: *const u8,\n-    size: libc::size_t,\n-    asize: libc::size_t,\n-    unit: libc::size_t,\n-}\n-\n-extern {\n-    fn hoedown_html_renderer_new(render_flags: libc::c_uint,\n-                                 nesting_level: libc::c_int)\n-        -> *mut hoedown_renderer;\n-    fn hoedown_html_renderer_free(renderer: *mut hoedown_renderer);\n-\n-    fn hoedown_document_new(rndr: *const hoedown_renderer,\n-                            extensions: libc::c_uint,\n-                            max_nesting: libc::size_t) -> *mut hoedown_document;\n-    fn hoedown_document_render(doc: *mut hoedown_document,\n-                               ob: *mut hoedown_buffer,\n-                               document: *const u8,\n-                               doc_size: libc::size_t);\n-    fn hoedown_document_free(md: *mut hoedown_document);\n-\n-    fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n-    fn hoedown_buffer_put(b: *mut hoedown_buffer, c: *const libc::c_char,\n-                          n: libc::size_t);\n-    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n-    fn hoedown_buffer_free(b: *mut hoedown_buffer);\n-\n-}\n-\n-// hoedown_buffer helpers\n-impl hoedown_buffer {\n-    fn as_bytes(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.data, self.size as usize) }\n-    }\n-}\n-\n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n /// `s` that should be used in tests. (None for lines that should be\n@@ -222,123 +103,126 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n+macro_rules! event_loop_break {\n+    ($parser:expr, $toc_builder:expr, $shorter:expr, $buf:expr, $escape:expr, $id:expr,\n+     $($end_event:pat)|*) => {{\n+        fn inner(id: &mut Option<&mut String>, s: &str) {\n+            if let Some(ref mut id) = *id {\n+                id.push_str(s);\n+            }\n+        }\n+        while let Some(event) = $parser.next() {\n+            match event {\n+                $($end_event)|* => break,\n+                Event::Text(ref s) => {\n+                    inner($id, s);\n+                    if $escape {\n+                        $buf.push_str(&format!(\"{}\", Escape(s)));\n+                    } else {\n+                        $buf.push_str(s);\n+                    }\n+                }\n+                Event::SoftBreak | Event::HardBreak if !$buf.is_empty() => {\n+                    $buf.push(' ');\n+                }\n+                x => {\n+                    looper($parser, &mut $buf, Some(x), $toc_builder, $shorter, $id);\n+                }\n+            }\n+        }\n+    }}\n+}\n \n pub fn render(w: &mut fmt::Formatter,\n               s: &str,\n               print_toc: bool,\n-              html_flags: libc::c_uint) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n-        unsafe {\n-            if orig_text.is_null() { return }\n-\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            let text = (*orig_text).as_bytes();\n-            let origtext = str::from_utf8(text).unwrap();\n-            let origtext = origtext.trim_left();\n-            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n-            let rendered = if lang.is_null() || origtext.is_empty() {\n-                false\n-            } else {\n-                let rlang = (*lang).as_bytes();\n-                let rlang = str::from_utf8(rlang).unwrap();\n-                if !LangString::parse(rlang).rust {\n-                    (my_opaque.dfltblk)(ob, orig_text, lang,\n-                                        opaque as *const hoedown_renderer_data,\n-                                        line);\n-                    true\n-                } else {\n-                    false\n+              shorter: MarkdownOutputStyle) -> fmt::Result {\n+    fn code_block(parser: &mut Parser, buffer: &mut String, lang: &str) {\n+        let mut origtext = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::CodeBlock(_)) => break,\n+                Event::Text(ref s) => {\n+                    origtext.push_str(s);\n                 }\n-            };\n+                _ => {}\n+            }\n+        }\n+        let origtext = origtext.trim_left();\n+        debug!(\"docblock: ==============\\n{:?}\\n=======\", origtext);\n \n-            let lines = origtext.lines().filter(|l| {\n-                stripped_filtered_line(*l).is_none()\n-            });\n-            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            if rendered { return }\n-            PLAYGROUND.with(|play| {\n-                // insert newline to clearly separate it from the\n-                // previous block so we can shorten the html output\n-                let mut s = String::from(\"\\n\");\n-                let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n-                    if url.is_empty() {\n-                        return None;\n-                    }\n-                    let test = origtext.lines().map(|l| {\n-                        stripped_filtered_line(l).unwrap_or(l)\n-                    }).collect::<Vec<&str>>().join(\"\\n\");\n-                    let krate = krate.as_ref().map(|s| &**s);\n-                    let test = test::maketest(&test, krate, false,\n-                                              &Default::default());\n-                    let channel = if test.contains(\"#![feature(\") {\n-                        \"&amp;version=nightly\"\n+        let lines = origtext.lines().filter(|l| {\n+            stripped_filtered_line(*l).is_none()\n+        });\n+        let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+        let block_info = if lang.is_empty() {\n+            LangString::all_false()\n+        } else {\n+            LangString::parse(lang)\n+        };\n+        if !block_info.rust {\n+            buffer.push_str(&format!(\"<pre><code class=\\\"language-{}\\\">{}</code></pre>\",\n+                            lang, text));\n+            return\n+        }\n+        PLAYGROUND.with(|play| {\n+            // insert newline to clearly separate it from the\n+            // previous block so we can shorten the html output\n+            buffer.push('\\n');\n+            let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n+                if url.is_empty() {\n+                    return None;\n+                }\n+                let test = origtext.lines().map(|l| {\n+                    stripped_filtered_line(l).unwrap_or(l)\n+                }).collect::<Vec<&str>>().join(\"\\n\");\n+                let krate = krate.as_ref().map(|s| &**s);\n+                let test = test::maketest(&test, krate, false,\n+                                          &Default::default());\n+                let channel = if test.contains(\"#![feature(\") {\n+                    \"&amp;version=nightly\"\n+                } else {\n+                    \"\"\n+                };\n+                // These characters don't need to be escaped in a URI.\n+                // FIXME: use a library function for percent encoding.\n+                fn dont_escape(c: u8) -> bool {\n+                    (b'a' <= c && c <= b'z') ||\n+                    (b'A' <= c && c <= b'Z') ||\n+                    (b'0' <= c && c <= b'9') ||\n+                    c == b'-' || c == b'_' || c == b'.' ||\n+                    c == b'~' || c == b'!' || c == b'\\'' ||\n+                    c == b'(' || c == b')' || c == b'*'\n+                }\n+                let mut test_escaped = String::new();\n+                for b in test.bytes() {\n+                    if dont_escape(b) {\n+                        test_escaped.push(char::from(b));\n                     } else {\n-                        \"\"\n-                    };\n-                    // These characters don't need to be escaped in a URI.\n-                    // FIXME: use a library function for percent encoding.\n-                    fn dont_escape(c: u8) -> bool {\n-                        (b'a' <= c && c <= b'z') ||\n-                        (b'A' <= c && c <= b'Z') ||\n-                        (b'0' <= c && c <= b'9') ||\n-                        c == b'-' || c == b'_' || c == b'.' ||\n-                        c == b'~' || c == b'!' || c == b'\\'' ||\n-                        c == b'(' || c == b')' || c == b'*'\n+                        write!(test_escaped, \"%{:02X}\", b).unwrap();\n                     }\n-                    let mut test_escaped = String::new();\n-                    for b in test.bytes() {\n-                        if dont_escape(b) {\n-                            test_escaped.push(char::from(b));\n-                        } else {\n-                            write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                        }\n-                    }\n-                    Some(format!(\n-                        r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n-                        url, test_escaped, channel\n-                    ))\n-                });\n-                s.push_str(&highlight::render_with_highlighting(\n-                               &text,\n-                               Some(\"rust-example-rendered\"),\n-                               None,\n-                               playground_button.as_ref().map(String::as_str)));\n-                let output = CString::new(s).unwrap();\n-                hoedown_buffer_puts(ob, output.as_ptr());\n-            })\n-        }\n+                }\n+                Some(format!(\n+                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n+                    url, test_escaped, channel\n+                ))\n+            });\n+            buffer.push_str(&highlight::render_with_highlighting(\n+                            &text,\n+                            Some(\"rust-example-rendered\"),\n+                            None,\n+                            playground_button.as_ref().map(String::as_str)));\n+        });\n     }\n \n-    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data,\n-                     _: libc::size_t) {\n-        // hoedown does this, we may as well too\n-        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n+    fn heading(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+               shorter: MarkdownOutputStyle, level: i32) {\n+        let mut ret = String::new();\n+        let mut id = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, ret, true, &mut Some(&mut id),\n+                          Event::End(Tag::Header(_)));\n+        ret = ret.trim_right().to_owned();\n \n-        // Extract the text provided\n-        let s = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let s = unsafe { (*text).as_bytes() };\n-            str::from_utf8(&s).unwrap().to_owned()\n-        };\n-\n-        // Discard '<em>', '<code>' tags and some escaped characters,\n-        // transform the contents of the header into a hyphenated string\n-        // without non-alphanumeric characters other than '-' and '_'.\n-        //\n-        // This is a terrible hack working around how hoedown gives us rendered\n-        // html for text rather than the raw text.\n-        let mut id = s.clone();\n-        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n-                            \"<strong>\", \"</strong>\",\n-                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n-        for sub in repl_sub {\n-            id = id.replace(sub, \"\");\n-        }\n         let id = id.chars().filter_map(|c| {\n             if c.is_alphanumeric() || c == '-' || c == '_' {\n                 if c.is_ascii() {\n@@ -353,145 +237,309 @@ pub fn render(w: &mut fmt::Formatter,\n             }\n         }).collect::<String>();\n \n-        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n-        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n-\n         let id = derive_id(id);\n \n-        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+        let sec = toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+            format!(\"{} \", builder.push(level as u32, ret.clone(), id.clone()))\n         });\n \n         // Render the HTML\n-        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n-                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n-                           s, lvl = level, id = id, sec = sec);\n-\n-        let text = CString::new(text).unwrap();\n-        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n-    }\n-\n-    extern fn codespan(\n-        ob: *mut hoedown_buffer,\n-        text: *const hoedown_buffer,\n-        _: *const hoedown_renderer_data,\n-        _: libc::size_t\n-    ) -> libc::c_int {\n-        let content = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let bytes = unsafe { (*text).as_bytes() };\n-            let s = str::from_utf8(bytes).unwrap();\n-            collapse_whitespace(s)\n-        };\n+        buffer.push_str(&format!(\"<h{lvl} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                                  <a href=\\\"#{id}\\\">{sec}{}</a></h{lvl}>\",\n+                                 ret, lvl = level, id = id, sec = sec));\n+    }\n \n-        let content = format!(\"<code>{}</code>\", Escape(&content));\n-        let element = CString::new(content).unwrap();\n-        unsafe { hoedown_buffer_puts(ob, element.as_ptr()); }\n-        // Return anything except 0, which would mean \"also print the code span verbatim\".\n-        1\n+    fn inline_code(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                   shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, false, id, Event::End(Tag::Code));\n+        buffer.push_str(&format!(\"<code>{}</code>\",\n+                                 Escape(&collapse_whitespace(content.trim_right()))));\n     }\n \n-    unsafe {\n-        let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let renderer = hoedown_html_renderer_new(html_flags, 0);\n-        let mut opaque = MyOpaque {\n-            dfltblk: (*renderer).blockcode.unwrap(),\n-            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n-        };\n-        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n-                = &mut opaque as *mut _ as *mut libc::c_void;\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n-        (*renderer).codespan = Some(codespan);\n+    fn link(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: MarkdownOutputStyle, url: &str, mut title: String,\n+            id: &mut Option<&mut String>) {\n+        event_loop_break!(parser, toc_builder, shorter, title, true, id,\n+                          Event::End(Tag::Link(_, _)));\n+        buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, title));\n+    }\n \n-        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n-        hoedown_document_render(document, ob, s.as_ptr(),\n-                                s.len() as libc::size_t);\n-        hoedown_document_free(document);\n+    fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                 shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n+                          Event::End(Tag::Paragraph));\n+        buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n+    }\n \n-        hoedown_html_renderer_free(renderer);\n+    fn table_cell(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                  shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n+                          Event::End(Tag::TableHead) |\n+                              Event::End(Tag::Table(_)) |\n+                              Event::End(Tag::TableRow) |\n+                              Event::End(Tag::TableCell));\n+        buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n+    }\n \n-        let mut ret = opaque.toc_builder.map_or(Ok(()), |builder| {\n-            write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n-        });\n+    fn table_row(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                 shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::TableHead) |\n+                    Event::End(Tag::Table(_)) |\n+                    Event::End(Tag::TableRow) => break,\n+                Event::Start(Tag::TableCell) => {\n+                    table_cell(parser, &mut content, toc_builder, shorter);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n+    }\n \n-        if ret.is_ok() {\n-            let buf = (*ob).as_bytes();\n-            ret = w.write_str(str::from_utf8(buf).unwrap());\n+    fn table_head(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                  shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n+                Event::Start(Tag::TableCell) => {\n+                    table_cell(parser, &mut content, toc_builder, shorter);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+                }\n+            }\n+        }\n+        if !content.is_empty() {\n+            buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n         }\n-        hoedown_buffer_free(ob);\n-        ret\n     }\n-}\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n-    extern fn block(_ob: *mut hoedown_buffer,\n-                    text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer,\n-                    data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n-        unsafe {\n-            if text.is_null() { return }\n-            let block_info = if lang.is_null() {\n-                LangString::all_false()\n-            } else {\n-                let lang = (*lang).as_bytes();\n-                let s = str::from_utf8(lang).unwrap();\n-                LangString::parse(s)\n-            };\n-            if !block_info.rust { return }\n-            let text = (*text).as_bytes();\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-            let text = str::from_utf8(text).unwrap();\n-            let lines = text.lines().map(|l| {\n-                stripped_filtered_line(l).unwrap_or(l)\n-            });\n-            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            let line = tests.get_line() + line;\n-            let filename = tests.get_filename();\n-            tests.add_test(text.to_owned(),\n-                           block_info.should_panic, block_info.no_run,\n-                           block_info.ignore, block_info.test_harness,\n-                           block_info.compile_fail, block_info.error_codes,\n-                           line, filename);\n+    fn table(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+             shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        let mut rows = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Table(_)) => break,\n+                Event::Start(Tag::TableHead) => {\n+                    table_head(parser, &mut content, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::TableRow) => {\n+                    table_row(parser, &mut rows, toc_builder, shorter);\n+                }\n+                _ => {}\n+            }\n         }\n+        buffer.push_str(&format!(\"<table>{}{}</table>\",\n+                                 content,\n+                                 if shorter.is_compact() || rows.is_empty() {\n+                                     String::new()\n+                                 } else {\n+                                     format!(\"<tbody>{}</tbody>\", rows)\n+                                 }));\n     }\n \n-    extern fn header(_ob: *mut hoedown_buffer,\n-                     text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data,\n-                     _: libc::size_t) {\n-        unsafe {\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-            if text.is_null() {\n-                tests.register_header(\"\", level as u32);\n-            } else {\n-                let text = (*text).as_bytes();\n-                let text = str::from_utf8(text).unwrap();\n-                tests.register_header(text, level as u32);\n+    fn blockquote(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                  shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n+                          Event::End(Tag::BlockQuote));\n+        buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n+    }\n+\n+    fn list_item(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                 shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Item) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(&format!(\"{}\", Escape(s)));\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<li>{}</li>\", content));\n+    }\n+\n+    fn list(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::List(_)) => break,\n+                Event::Start(Tag::Item) => {\n+                    list_item(parser, &mut content, toc_builder, shorter);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<ul>{}</ul>\", content));\n+    }\n+\n+    fn emphasis(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n+                          Event::End(Tag::Emphasis));\n+        buffer.push_str(&format!(\"<em>{}</em>\", content));\n+    }\n+\n+    fn strong(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+              shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n+                          Event::End(Tag::Strong));\n+        buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n+    }\n+\n+    fn looper<'a>(parser: &'a mut Parser, buffer: &mut String, next_event: Option<Event<'a>>,\n+                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n+                  id: &mut Option<&mut String>) -> bool {\n+        if let Some(event) = next_event {\n+            match event {\n+                Event::Start(Tag::CodeBlock(lang)) => {\n+                    code_block(parser, buffer, &*lang);\n+                }\n+                Event::Start(Tag::Header(level)) => {\n+                    heading(parser, buffer, toc_builder, shorter, level);\n+                }\n+                Event::Start(Tag::Code) => {\n+                    inline_code(parser, buffer, toc_builder, shorter, id);\n+                }\n+                Event::Start(Tag::Paragraph) => {\n+                    paragraph(parser, buffer, toc_builder, shorter, id);\n+                }\n+                Event::Start(Tag::Link(ref url, ref t)) => {\n+                    link(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned(), id);\n+                }\n+                Event::Start(Tag::Table(_)) => {\n+                    table(parser, buffer, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::BlockQuote) => {\n+                    blockquote(parser, buffer, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::List(_)) => {\n+                    list(parser, buffer, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::Emphasis) => {\n+                    emphasis(parser, buffer, toc_builder, shorter, id);\n+                }\n+                Event::Start(Tag::Strong) => {\n+                    strong(parser, buffer, toc_builder, shorter, id);\n+                }\n+                Event::Html(h) | Event::InlineHtml(h) => {\n+                    buffer.push_str(&*h);\n+                }\n+                _ => {}\n             }\n+            shorter.is_fancy()\n+        } else {\n+            false\n+        }\n+    }\n+\n+    let mut toc_builder = if print_toc {\n+        Some(TocBuilder::new())\n+    } else {\n+        None\n+    };\n+    let mut buffer = String::new();\n+    let mut parser = Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES);\n+    loop {\n+        let next_event = parser.next();\n+        if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder, shorter, &mut None) {\n+            break\n         }\n     }\n+    let mut ret = toc_builder.map_or(Ok(()), |builder| {\n+        write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n+    });\n+\n+    if ret.is_ok() {\n+        ret = w.write_str(&buffer);\n+    }\n+    ret\n+}\n \n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n     tests.set_position(position);\n-    unsafe {\n-        let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let renderer = hoedown_html_renderer_new(0, 0);\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n-        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n-                = tests as *mut _ as *mut libc::c_void;\n-\n-        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n-        hoedown_document_render(document, ob, doc.as_ptr(),\n-                                doc.len() as libc::size_t);\n-        hoedown_document_free(document);\n-\n-        hoedown_html_renderer_free(renderer);\n-        hoedown_buffer_free(ob);\n+\n+    let mut parser = Parser::new(doc);\n+    let mut prev_offset = 0;\n+    let mut nb_lines = 0;\n+    let mut register_header = None;\n+    'main: while let Some(event) = parser.next() {\n+        match event {\n+            Event::Start(Tag::CodeBlock(s)) => {\n+                let block_info = if s.is_empty() {\n+                    LangString::all_false()\n+                } else {\n+                    LangString::parse(&*s)\n+                };\n+                if !block_info.rust {\n+                    continue\n+                }\n+                let mut test_s = String::new();\n+                let mut offset = None;\n+                loop {\n+                    let event = parser.next();\n+                    if let Some(event) = event {\n+                        match event {\n+                            Event::End(Tag::CodeBlock(_)) => break,\n+                            Event::Text(ref s) => {\n+                                test_s.push_str(s);\n+                                if offset.is_none() {\n+                                    offset = Some(parser.get_offset());\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    } else {\n+                        break 'main;\n+                    }\n+                }\n+                let offset = offset.unwrap_or(0);\n+                let lines = test_s.lines().map(|l| {\n+                    stripped_filtered_line(l).unwrap_or(l)\n+                });\n+                let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+                nb_lines += doc[prev_offset..offset].lines().count();\n+                let line = tests.get_line() + (nb_lines - 1);\n+                let filename = tests.get_filename();\n+                tests.add_test(text.to_owned(),\n+                               block_info.should_panic, block_info.no_run,\n+                               block_info.ignore, block_info.test_harness,\n+                               block_info.compile_fail, block_info.error_codes,\n+                               line, filename);\n+                prev_offset = offset;\n+            }\n+            Event::Start(Tag::Header(level)) => {\n+                register_header = Some(level as u32);\n+            }\n+            Event::Text(ref s) if register_header.is_some() => {\n+                let level = register_header.unwrap();\n+                if s.is_empty() {\n+                    tests.register_header(\"\", level);\n+                } else {\n+                    tests.register_header(s, level);\n+                }\n+                register_header = None;\n+            }\n+            _ => {}\n+        }\n     }\n }\n \n@@ -570,17 +618,17 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md) = *self;\n+        let Markdown(md, shorter) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, 0)\n+        render(fmt, md, false, shorter)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true, 0)\n+        render(fmt, md, true, MarkdownOutputStyle::Fancy)\n     }\n }\n \n@@ -589,62 +637,67 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, HOEDOWN_HTML_ESCAPE)\n+        render(fmt, md, false, MarkdownOutputStyle::Fancy)\n     }\n }\n \n pub fn plain_summary_line(md: &str) -> String {\n-    extern fn link(_ob: *mut hoedown_buffer,\n-                       _link: *const hoedown_buffer,\n-                       _title: *const hoedown_buffer,\n-                       content: *const hoedown_buffer,\n-                       data: *const hoedown_renderer_data,\n-                       _: libc::size_t) -> libc::c_int\n-    {\n-        unsafe {\n-            if !content.is_null() && (*content).size > 0 {\n-                let ob = (*data).opaque as *mut hoedown_buffer;\n-                hoedown_buffer_put(ob, (*content).data as *const libc::c_char,\n-                                   (*content).size);\n-            }\n-        }\n-        1\n-    }\n-\n-    extern fn normal_text(_ob: *mut hoedown_buffer,\n-                          text: *const hoedown_buffer,\n-                          data: *const hoedown_renderer_data,\n-                          _: libc::size_t)\n-    {\n-        unsafe {\n-            let ob = (*data).opaque as *mut hoedown_buffer;\n-            hoedown_buffer_put(ob, (*text).data as *const libc::c_char,\n-                               (*text).size);\n-        }\n+    struct ParserWrapper<'a> {\n+        inner: Parser<'a>,\n+        is_in: isize,\n+        is_first: bool,\n     }\n \n-    unsafe {\n-        let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let mut plain_renderer: hoedown_renderer = ::std::mem::zeroed();\n-        let renderer: *mut hoedown_renderer = &mut plain_renderer;\n-        (*renderer).opaque = ob as *mut libc::c_void;\n-        (*renderer).link = Some(link);\n-        (*renderer).normal_text = Some(normal_text);\n+    impl<'a> Iterator for ParserWrapper<'a> {\n+        type Item = String;\n \n-        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n-        hoedown_document_render(document, ob, md.as_ptr(),\n-                                md.len() as libc::size_t);\n-        hoedown_document_free(document);\n-        let plain_slice = (*ob).as_bytes();\n-        let plain = str::from_utf8(plain_slice).unwrap_or(\"\").to_owned();\n-        hoedown_buffer_free(ob);\n-        plain\n+        fn next(&mut self) -> Option<String> {\n+            let next_event = self.inner.next();\n+            if next_event.is_none() {\n+                return None\n+            }\n+            let next_event = next_event.unwrap();\n+            let (ret, is_in) = match next_event {\n+                Event::Start(Tag::Paragraph) => (None, 1),\n+                Event::Start(Tag::Link(_, ref t)) if !self.is_first => {\n+                    (Some(t.as_ref().to_owned()), 1)\n+                }\n+                Event::Start(Tag::Code) => (Some(\"`\".to_owned()), 1),\n+                Event::End(Tag::Code) => (Some(\"`\".to_owned()), -1),\n+                Event::Start(Tag::Header(_)) => (None, 1),\n+                Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n+                Event::End(Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n+                Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n+                _ => (None, 0),\n+            };\n+            if is_in > 0 || (is_in < 0 && self.is_in > 0) {\n+                self.is_in += is_in;\n+            }\n+            if ret.is_some() {\n+                self.is_first = false;\n+                ret\n+            } else {\n+                Some(String::new())\n+            }\n+        }\n+    }\n+    let mut s = String::with_capacity(md.len() * 3 / 2);\n+    let mut p = ParserWrapper {\n+        inner: Parser::new(md),\n+        is_in: 0,\n+        is_first: true,\n+    };\n+    while let Some(t) = p.next() {\n+        if !t.is_empty() {\n+            s.push_str(&t);\n+        }\n     }\n+    s\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml};\n+    use super::{LangString, Markdown, MarkdownHtml, MarkdownOutputStyle};\n     use super::plain_summary_line;\n     use html::render::reset_ids;\n \n@@ -684,52 +737,52 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown));\n+        format!(\"{}\", Markdown(markdown, MarkdownOutputStyle::Fancy));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input));\n-            assert_eq!(output, expect);\n+            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            assert_eq!(output, expect, \"original: {}\", input);\n             reset_ids(true);\n         }\n \n-        t(\"# Foo bar\", \"\\n<h1 id='foo-bar' class='section-header'>\\\n-          <a href='#foo-bar'>Foo bar</a></h1>\");\n-        t(\"## Foo-bar_baz qux\", \"\\n<h2 id='foo-bar_baz-qux' class=\\'section-\\\n-          header'><a href='#foo-bar_baz-qux'>Foo-bar_baz qux</a></h2>\");\n+        t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n+          <a href=\\\"#foo-bar\\\">Foo bar</a></h1>\");\n+        t(\"## Foo-bar_baz qux\", \"<h2 id=\\\"foo-bar_baz-qux\\\" class=\\\"section-\\\n+          header\\\"><a href=\\\"#foo-bar_baz-qux\\\">Foo-bar_baz qux</a></h2>\");\n         t(\"### **Foo** *bar* baz!?!& -_qux_-%\",\n-          \"\\n<h3 id='foo-bar-baz--_qux_-' class='section-header'>\\\n-          <a href='#foo-bar-baz--_qux_-'><strong>Foo</strong> \\\n-          <em>bar</em> baz!?!&amp; -_qux_-%</a></h3>\");\n-        t(\"####**Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n-          \"\\n<h4 id='foo--bar--baz--qux' class='section-header'>\\\n-          <a href='#foo--bar--baz--qux'><strong>Foo?</strong> &amp; *bar?!*  \\\n+          \"<h3 id=\\\"foo-bar-baz--qux-\\\" class=\\\"section-header\\\">\\\n+          <a href=\\\"#foo-bar-baz--qux-\\\"><strong>Foo</strong> \\\n+          <em>bar</em> baz!?!&amp; -<em>qux</em>-%</a></h3>\");\n+        t(\"#### **Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n+          \"<h4 id=\\\"foo--bar--baz--qux\\\" class=\\\"section-header\\\">\\\n+          <a href=\\\"#foo--bar--baz--qux\\\"><strong>Foo?</strong> &amp; *bar?!*  \\\n           <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n     }\n \n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input));\n-            assert_eq!(output, expect);\n+            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n         let test = || {\n-            t(\"# Example\", \"\\n<h1 id='example' class='section-header'>\\\n-              <a href='#example'>Example</a></h1>\");\n-            t(\"# Panics\", \"\\n<h1 id='panics' class='section-header'>\\\n-              <a href='#panics'>Panics</a></h1>\");\n-            t(\"# Example\", \"\\n<h1 id='example-1' class='section-header'>\\\n-              <a href='#example-1'>Example</a></h1>\");\n-            t(\"# Main\", \"\\n<h1 id='main-1' class='section-header'>\\\n-              <a href='#main-1'>Main</a></h1>\");\n-            t(\"# Example\", \"\\n<h1 id='example-2' class='section-header'>\\\n-              <a href='#example-2'>Example</a></h1>\");\n-            t(\"# Panics\", \"\\n<h1 id='panics-1' class='section-header'>\\\n-              <a href='#panics-1'>Panics</a></h1>\");\n+            t(\"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n+              <a href=\\\"#example\\\">Example</a></h1>\");\n+            t(\"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n+              <a href=\\\"#panics\\\">Panics</a></h1>\");\n+            t(\"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n+              <a href=\\\"#example-1\\\">Example</a></h1>\");\n+            t(\"# Main\", \"<h1 id=\\\"main-1\\\" class=\\\"section-header\\\">\\\n+              <a href=\\\"#main-1\\\">Main</a></h1>\");\n+            t(\"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n+              <a href=\\\"#example-2\\\">Example</a></h1>\");\n+            t(\"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n+              <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n         };\n         test();\n         reset_ids(true);\n@@ -740,7 +793,7 @@ mod tests {\n     fn test_plain_summary_line() {\n         fn t(input: &str, expect: &str) {\n             let output = plain_summary_line(input);\n-            assert_eq!(output, expect);\n+            assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n         t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n@@ -754,10 +807,10 @@ mod tests {\n     fn test_markdown_html_escape() {\n         fn t(input: &str, expect: &str) {\n             let output = format!(\"{}\", MarkdownHtml(input));\n-            assert_eq!(output, expect);\n+            assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;&#39;a, T&gt;</code></p>\\n\");\n-        t(\"Struct<'a, T>\", \"<p>Struct&lt;&#39;a, T&gt;</p>\\n\");\n+        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;&#39;a, T&gt;</code></p>\");\n+        t(\"Struct<'a, T>\", \"<p>Struct&lt;&#39;a, T&gt;</p>\");\n     }\n }"}, {"sha": "f0b624105e3475de90a56d967e2a23b1013d8093", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownOutputStyle};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -1650,7 +1650,8 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n         } else {\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n-        write!(w, \"<div class='docblock'>{}</div>\", Markdown(&markdown))?;\n+        write!(w, \"<div class='docblock'>{}</div>\",\n+               Markdown(&markdown, MarkdownOutputStyle::Fancy))?;\n     }\n     Ok(())\n }\n@@ -1683,7 +1684,8 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s),\n+                                 MarkdownOutputStyle::Fancy))?;\n     }\n     Ok(())\n }\n@@ -1871,7 +1873,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = shorter(Some(&Markdown(doc_value).to_string())),\n+                       docs = shorter(Some(&Markdown(doc_value,\n+                                                     MarkdownOutputStyle::Compact).to_string())),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -2901,7 +2904,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, MarkdownOutputStyle::Fancy))?;\n         }\n     }\n "}, {"sha": "447d60018d91291f4e5fe469c7f26f253e8dfa44", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustdoc\"]\n-#![unstable(feature = \"rustdoc\", issue = \"27812\")]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -48,6 +48,7 @@ extern crate test as testing;\n extern crate std_unicode;\n #[macro_use] extern crate log;\n extern crate rustc_errors as errors;\n+extern crate pulldown_cmark;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "5cc0f03e1f629f4ff3021684d766a13640ebe15a", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -25,7 +25,7 @@ use externalfiles::{ExternalHtml, LoadStringError, load_string};\n use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n+use html::markdown::{Markdown, MarkdownWithToc, MarkdownOutputStyle, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -96,7 +96,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))\n     } else {\n-        format!(\"{}\", Markdown(text))\n+        format!(\"{}\", Markdown(text, MarkdownOutputStyle::Fancy))\n     };\n \n     let err = write!("}, {"sha": "da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92", "filename": "src/rt/hoedown", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fhoedown?ref=4465f22ef6498db65059a41595d354a7af56cbea", "patch": "@@ -1 +0,0 @@\n-Subproject commit da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92"}, {"sha": "a4f43c42623d33be11e547c4b6f9f1694f841e6b", "filename": "src/rustc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Frustc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Frustc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustdoc.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustdoc)]\n+#![feature(rustc_private)]\n \n extern crate rustdoc;\n "}, {"sha": "1d4f2c60d544f6ea05366167e93ba0aed74bc959", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf5592510156e08b4de3830afaabbc0b65ce054/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=abf5592510156e08b4de3830afaabbc0b65ce054", "patch": "@@ -24,7 +24,7 @@ use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc, MarkdownOutputStyle::Fancy))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}