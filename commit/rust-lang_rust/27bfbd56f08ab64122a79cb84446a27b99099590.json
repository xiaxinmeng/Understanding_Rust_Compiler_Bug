{"sha": "27bfbd56f08ab64122a79cb84446a27b99099590", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YmZiZDU2ZjA4YWI2NDEyMmE3OWNiODQ0NDZhMjdiOTkwOTk1OTA=", "commit": {"author": {"name": "QuietMisdreavus", "email": "bryan@icesoldier.me", "date": "2016-11-21T21:52:51Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2017-04-17T15:41:13Z"}, "message": "rustdoc: add a list of headings to the sidebar", "tree": {"sha": "b945715dc9590c0518853de9b4b2f0dc6076242d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b945715dc9590c0518853de9b4b2f0dc6076242d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27bfbd56f08ab64122a79cb84446a27b99099590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27bfbd56f08ab64122a79cb84446a27b99099590", "html_url": "https://github.com/rust-lang/rust/commit/27bfbd56f08ab64122a79cb84446a27b99099590", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27bfbd56f08ab64122a79cb84446a27b99099590/comments", "author": null, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c48ae6f7ffae392d85c86240c67f49df01f44fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c48ae6f7ffae392d85c86240c67f49df01f44fd", "html_url": "https://github.com/rust-lang/rust/commit/2c48ae6f7ffae392d85c86240c67f49df01f44fd"}], "stats": {"total": 229, "additions": 225, "deletions": 4}, "files": [{"sha": "1b7615fa05b0afcb37a63eead21e6a515dae5588", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27bfbd56f08ab64122a79cb84446a27b99099590/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27bfbd56f08ab64122a79cb84446a27b99099590/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=27bfbd56f08ab64122a79cb84446a27b99099590", "patch": "@@ -292,7 +292,7 @@ impl Item {\n         self.type_() == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        self.type_() == ItemType::Module\n+        self.type_() == ItemType::Enum\n     }\n     pub fn is_fn(&self) -> bool {\n         self.type_() == ItemType::Function\n@@ -312,6 +312,9 @@ impl Item {\n     pub fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n+    pub fn is_union(&self) -> bool {\n+        self.type_() == ItemType::Union\n+    }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n     }"}, {"sha": "22e113e501b8cc6e7bc944f413b1ccae9a54fe93", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 221, "deletions": 3, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/27bfbd56f08ab64122a79cb84446a27b99099590/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27bfbd56f08ab64122a79cb84446a27b99099590/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=27bfbd56f08ab64122a79cb84446a27b99099590", "patch": "@@ -2411,7 +2411,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }).peekable();\n     if let doctree::Plain = s.struct_type {\n         if fields.peek().is_some() {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+            write!(w, \"<h2 id='fields' class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n                 let id = derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n@@ -2459,7 +2459,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n     }).peekable();\n     if fields.peek().is_some() {\n-        write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+        write!(w, \"<h2 id='fields' class='fields'>Fields</h2>\")?;\n         for (field, ty) in fields {\n             write!(w, \"<span id='{shortty}.{name}' class=\\\"{shortty}\\\"><code>{name}: {ty}</code>\n                        </span>\",\n@@ -2535,7 +2535,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n+        write!(w, \"<h2 id='variants' class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n             let id = derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n@@ -3077,6 +3077,37 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n \n+        if it.is_struct() || it.is_trait() || it.is_primitive() || it.is_union()\n+            || it.is_enum() || it.is_mod()\n+        {\n+            write!(fmt, \"<p class='location'>\")?;\n+            match it.inner {\n+                clean::StructItem(..) => write!(fmt, \"Struct \")?,\n+                clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n+                clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n+                clean::UnionItem(..) => write!(fmt, \"Union \")?,\n+                clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n+                clean::ModuleItem(..) => if it.is_crate() {\n+                    write!(fmt, \"Crate \")?;\n+                } else {\n+                    write!(fmt, \"Module \")?;\n+                },\n+                _ => (),\n+            }\n+            write!(fmt, \"{}\", it.name.as_ref().unwrap())?;\n+            write!(fmt, \"</p>\")?;\n+\n+            match it.inner {\n+                clean::StructItem(ref s) => sidebar_struct(fmt, it, s)?,\n+                clean::TraitItem(ref t) => sidebar_trait(fmt, it, t)?,\n+                clean::PrimitiveItem(ref p) => sidebar_primitive(fmt, it, p)?,\n+                clean::UnionItem(ref u) => sidebar_union(fmt, it, u)?,\n+                clean::EnumItem(ref e) => sidebar_enum(fmt, it, e)?,\n+                clean::ModuleItem(ref m) => sidebar_module(fmt, it, &m.items)?,\n+                _ => (),\n+            }\n+        }\n+\n         // The sidebar is designed to display sibling functions, modules and\n         // other miscellaneous information. since there are lots of sibling\n         // items (and that causes quadratic growth in large modules),\n@@ -3119,6 +3150,193 @@ impl<'a> fmt::Display for Sidebar<'a> {\n     }\n }\n \n+fn sidebar_assoc_items(it: &clean::Item) -> String {\n+    let mut out = String::new();\n+    let c = cache();\n+    if let Some(v) = c.impls.get(&it.def_id) {\n+        if v.iter().any(|i| i.inner_impl().trait_.is_none()) {\n+            out.push_str(\"<li><a href=\\\"#methods\\\">Methods</a></li>\");\n+        }\n+\n+        if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n+            if let Some(impl_) = v.iter()\n+                                  .filter(|i| i.inner_impl().trait_.is_some())\n+                                  .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did) {\n+                if let Some(target) = impl_.inner_impl().items.iter().filter_map(|item| {\n+                    match item.inner {\n+                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        _ => None,\n+                    }\n+                }).next() {\n+                    let inner_impl = target.def_id().or(target.primitive_type().and_then(|prim| {\n+                        c.primitive_locations.get(&prim).cloned()\n+                    })).and_then(|did| c.impls.get(&did));\n+                    if inner_impl.is_some() {\n+                        out.push_str(\"<li><a href=\\\"#deref-methods\\\">\");\n+                        out.push_str(&format!(\"Methods from {:#}&lt;Target={:#}&gt;\",\n+                                                  impl_.inner_impl().trait_.as_ref().unwrap(),\n+                                                  target));\n+                        out.push_str(\"</a></li>\");\n+                    }\n+                }\n+            }\n+            out.push_str(\"<li><a href=\\\"#implementations\\\">Trait Implementations</a></li>\");\n+        }\n+    }\n+\n+    out\n+}\n+\n+fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                  s: &clean::Struct) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if s.fields.iter()\n+               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+        if let doctree::Plain = s.struct_type {\n+            sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+        }\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                 t: &clean::Trait) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    let has_types = t.items.iter().any(|m| m.is_associated_type());\n+    let has_consts = t.items.iter().any(|m| m.is_associated_const());\n+    let has_required = t.items.iter().any(|m| m.is_ty_method());\n+    let has_provided = t.items.iter().any(|m| m.is_method());\n+\n+    if has_types {\n+        sidebar.push_str(\"<li><a href=\\\"#associated-types\\\">Associated Types</a></li>\");\n+    }\n+    if has_consts {\n+        sidebar.push_str(\"<li><a href=\\\"#associated-const\\\">Associated Constants</a></li>\");\n+    }\n+    if has_required {\n+        sidebar.push_str(\"<li><a href=\\\"#required-methods\\\">Required Methods</a></li>\");\n+    }\n+    if has_provided {\n+        sidebar.push_str(\"<li><a href=\\\"#provided-methods\\\">Provided Methods</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    sidebar.push_str(\"<li><a href=\\\"#implementors\\\">Implementors</a></li>\");\n+\n+    write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)\n+}\n+\n+fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                     _p: &clean::PrimitiveType) -> fmt::Result {\n+    let sidebar = sidebar_assoc_items(it);\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                 u: &clean::Union) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if u.fields.iter()\n+               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+        sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                e: &clean::Enum) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if !e.variants.is_empty() {\n+        sidebar.push_str(\"<li><a href=\\\"#variants\\\">Variants</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n+                  items: &[clean::Item]) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if items.iter().any(|it| it.type_() == ItemType::ExternCrate ||\n+                             it.type_() == ItemType::Import) {\n+        sidebar.push_str(&format!(\"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n+                                  id = \"reexports\",\n+                                  name = \"Reexports\"));\n+    }\n+\n+    // ordering taken from item_module, reorder, where it prioritized elements in a certain order\n+    // to print its headings\n+    for &myty in &[ItemType::Primitive, ItemType::Module, ItemType::Macro, ItemType::Struct,\n+                   ItemType::Enum, ItemType::Constant, ItemType::Static, ItemType::Trait,\n+                   ItemType::Function, ItemType::Typedef, ItemType::Union, ItemType::Impl,\n+                   ItemType::TyMethod, ItemType::Method, ItemType::StructField, ItemType::Variant,\n+                   ItemType::AssociatedType, ItemType::AssociatedConst] {\n+        if items.iter().any(|it| {\n+            if let clean::DefaultImplItem(..) = it.inner {\n+                false\n+            } else {\n+                !maybe_ignore_item(it) && !it.is_stripped() && it.type_() == myty\n+            }\n+        }) {\n+            let (short, name) = match myty {\n+                ItemType::ExternCrate |\n+                ItemType::Import          => (\"reexports\", \"Reexports\"),\n+                ItemType::Module          => (\"modules\", \"Modules\"),\n+                ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Union           => (\"unions\", \"Unions\"),\n+                ItemType::Enum            => (\"enums\", \"Enums\"),\n+                ItemType::Function        => (\"functions\", \"Functions\"),\n+                ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n+                ItemType::Static          => (\"statics\", \"Statics\"),\n+                ItemType::Constant        => (\"constants\", \"Constants\"),\n+                ItemType::Trait           => (\"traits\", \"Traits\"),\n+                ItemType::Impl            => (\"impls\", \"Implementations\"),\n+                ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n+                ItemType::Method          => (\"methods\", \"Methods\"),\n+                ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n+                ItemType::Variant         => (\"variants\", \"Variants\"),\n+                ItemType::Macro           => (\"macros\", \"Macros\"),\n+                ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n+                ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n+                ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n+            };\n+            sidebar.push_str(&format!(\"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n+                                      id = short,\n+                                      name = name));\n+        }\n+    }\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n impl<'a> fmt::Display for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;"}]}