{"sha": "61ad6a96ad1019930294e754e72f627978e85787", "node_id": "C_kwDOAAsO6NoAKDYxYWQ2YTk2YWQxMDE5OTMwMjk0ZTc1NGU3MmY2Mjc5NzhlODU3ODc", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-02-18T20:32:55Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-06T17:39:08Z"}, "message": "Add BindingId", "tree": {"sha": "61a5f9f389f6ceb6b12062ea0e94791c0e98b568", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61a5f9f389f6ceb6b12062ea0e94791c0e98b568"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61ad6a96ad1019930294e754e72f627978e85787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61ad6a96ad1019930294e754e72f627978e85787", "html_url": "https://github.com/rust-lang/rust/commit/61ad6a96ad1019930294e754e72f627978e85787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61ad6a96ad1019930294e754e72f627978e85787/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a360fab9a36a20046fed4c6e9b863c52c7578de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a360fab9a36a20046fed4c6e9b863c52c7578de0", "html_url": "https://github.com/rust-lang/rust/commit/a360fab9a36a20046fed4c6e9b863c52c7578de0"}], "stats": {"total": 811, "additions": 514, "deletions": 297}, "files": [{"sha": "545d2bebf5f0d6349bf92d0ced03b36350ccd625", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -24,7 +24,7 @@ use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{dummy_expr_id, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    expr::{dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n     nameres::DefMap,\n@@ -270,6 +270,7 @@ pub struct Mark {\n pub struct Body {\n     pub exprs: Arena<Expr>,\n     pub pats: Arena<Pat>,\n+    pub bindings: Arena<Binding>,\n     pub or_pats: FxHashMap<PatId, Arc<[PatId]>>,\n     pub labels: Arena<Label>,\n     /// The patterns for the function's parameters. While the parameter types are\n@@ -435,13 +436,24 @@ impl Body {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let Self { _c: _, body_expr: _, block_scopes, or_pats, exprs, labels, params, pats } = self;\n+        let Self {\n+            _c: _,\n+            body_expr: _,\n+            block_scopes,\n+            or_pats,\n+            exprs,\n+            labels,\n+            params,\n+            pats,\n+            bindings,\n+        } = self;\n         block_scopes.shrink_to_fit();\n         or_pats.shrink_to_fit();\n         exprs.shrink_to_fit();\n         labels.shrink_to_fit();\n         params.shrink_to_fit();\n         pats.shrink_to_fit();\n+        bindings.shrink_to_fit();\n     }\n }\n \n@@ -451,6 +463,7 @@ impl Default for Body {\n             body_expr: dummy_expr_id(),\n             exprs: Default::default(),\n             pats: Default::default(),\n+            bindings: Default::default(),\n             or_pats: Default::default(),\n             labels: Default::default(),\n             params: Default::default(),\n@@ -484,6 +497,14 @@ impl Index<LabelId> for Body {\n     }\n }\n \n+impl Index<BindingId> for Body {\n+    type Output = Binding;\n+\n+    fn index(&self, b: BindingId) -> &Binding {\n+        &self.bindings[b]\n+    }\n+}\n+\n // FIXME: Change `node_` prefix to something more reasonable.\n // Perhaps `expr_syntax` and `expr_id`?\n impl BodySourceMap {"}, {"sha": "b7458bfb8a7b439d7b9a5602420ca1f62db99c54", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 80, "deletions": 37, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -15,6 +15,7 @@ use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -30,9 +31,9 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BindingAnnotation, ClosureKind, Expr, ExprId, FloatTypeWrapper,\n-        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n-        Statement,\n+        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n+        FloatTypeWrapper, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId,\n+        RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n@@ -87,6 +88,7 @@ pub(super) fn lower(\n         body: Body {\n             exprs: Arena::default(),\n             pats: Arena::default(),\n+            bindings: Arena::default(),\n             labels: Arena::default(),\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n@@ -116,6 +118,22 @@ struct ExprCollector<'a> {\n     is_lowering_generator: bool,\n }\n \n+#[derive(Debug, Default)]\n+struct BindingList {\n+    map: FxHashMap<Name, BindingId>,\n+}\n+\n+impl BindingList {\n+    fn find(\n+        &mut self,\n+        ec: &mut ExprCollector<'_>,\n+        name: Name,\n+        mode: BindingAnnotation,\n+    ) -> BindingId {\n+        *self.map.entry(name).or_insert_with_key(|n| ec.alloc_binding(n.clone(), mode))\n+    }\n+}\n+\n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n@@ -127,17 +145,16 @@ impl ExprCollector<'_> {\n                 param_list.self_param().filter(|_| attr_enabled.next().unwrap_or(false))\n             {\n                 let ptr = AstPtr::new(&self_param);\n-                let param_pat = self.alloc_pat(\n-                    Pat::Bind {\n-                        name: name![self],\n-                        mode: BindingAnnotation::new(\n-                            self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n-                            false,\n-                        ),\n-                        subpat: None,\n-                    },\n-                    Either::Right(ptr),\n+                let binding_id = self.alloc_binding(\n+                    name![self],\n+                    BindingAnnotation::new(\n+                        self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n+                        false,\n+                    ),\n                 );\n+                let param_pat =\n+                    self.alloc_pat(Pat::Bind { id: binding_id, subpat: None }, Either::Right(ptr));\n+                self.add_definition_to_binding(binding_id, param_pat);\n                 self.body.params.push(param_pat);\n             }\n \n@@ -179,6 +196,9 @@ impl ExprCollector<'_> {\n         id\n     }\n \n+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n+        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n+    }\n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_pat(pat, src.clone());\n@@ -804,7 +824,7 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pat_id = self.collect_pat_(pat);\n+        let pat_id = self.collect_pat_(pat, &mut BindingList::default());\n         for (_, pats) in self.name_to_pat_grouping.drain() {\n             let pats = Arc::<[_]>::from(pats);\n             self.body.or_pats.extend(pats.iter().map(|&pat| (pat, pats.clone())));\n@@ -820,16 +840,18 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_pat_(&mut self, pat: ast::Pat) -> PatId {\n+    fn collect_pat_(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n                 let key = self.is_lowering_inside_or_pat.then(|| name.clone());\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat));\n-                let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n+                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat, binding_list));\n+                let (binding, pattern) = if annotation == BindingAnnotation::Unannotated\n+                    && subpat.is_none()\n+                {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n                     let (resolved, _) = self.expander.def_map.resolve_path(\n@@ -839,30 +861,37 @@ impl ExprCollector<'_> {\n                         BuiltinShadowMode::Other,\n                     );\n                     match resolved.take_values() {\n-                        Some(ModuleDefId::ConstId(_)) => Pat::Path(name.into()),\n+                        Some(ModuleDefId::ConstId(_)) => (None, Pat::Path(name.into())),\n                         Some(ModuleDefId::EnumVariantId(_)) => {\n                             // this is only really valid for unit variants, but\n                             // shadowing other enum variants with a pattern is\n                             // an error anyway\n-                            Pat::Path(name.into())\n+                            (None, Pat::Path(name.into()))\n                         }\n                         Some(ModuleDefId::AdtId(AdtId::StructId(s)))\n                             if self.db.struct_data(s).variant_data.kind() != StructKind::Record =>\n                         {\n                             // Funnily enough, record structs *can* be shadowed\n                             // by pattern bindings (but unit or tuple structs\n                             // can't).\n-                            Pat::Path(name.into())\n+                            (None, Pat::Path(name.into()))\n                         }\n                         // shadowing statics is an error as well, so we just ignore that case here\n-                        _ => Pat::Bind { name, mode: annotation, subpat },\n+                        _ => {\n+                            let id = binding_list.find(self, name, annotation);\n+                            (Some(id), Pat::Bind { id, subpat })\n+                        }\n                     }\n                 } else {\n-                    Pat::Bind { name, mode: annotation, subpat }\n+                    let id = binding_list.find(self, name, annotation);\n+                    (Some(id), Pat::Bind { id, subpat })\n                 };\n \n                 let ptr = AstPtr::new(&pat);\n                 let pat = self.alloc_pat(pattern, Either::Left(ptr));\n+                if let Some(binding_id) = binding {\n+                    self.add_definition_to_binding(binding_id, pat);\n+                }\n                 if let Some(key) = key {\n                     self.name_to_pat_grouping.entry(key).or_default().push(pat);\n                 }\n@@ -871,11 +900,11 @@ impl ExprCollector<'_> {\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt(p.pat());\n+                let pat = self.collect_pat_opt_(p.pat(), binding_list);\n                 let mutability = Mutability::from_mutable(p.mut_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n@@ -886,12 +915,12 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::OrPat(p) => {\n                 self.is_lowering_inside_or_pat = true;\n-                let pats = p.pats().map(|p| self.collect_pat_(p)).collect();\n+                let pats = p.pats().map(|p| self.collect_pat_(p, binding_list)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat()),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -904,7 +933,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(ast_pat);\n+                        let pat = self.collect_pat_(ast_pat, binding_list);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -923,9 +952,15 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n-                    slice: slice.map(|p| self.collect_pat_(p)),\n-                    suffix: suffix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                    prefix: prefix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(p, binding_list))\n+                        .collect(),\n+                    slice: slice.map(|p| self.collect_pat_(p, binding_list)),\n+                    suffix: suffix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(p, binding_list))\n+                        .collect(),\n                 }\n             }\n             ast::Pat::LiteralPat(lit) => {\n@@ -948,7 +983,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(boxpat.pat());\n+                let inner = self.collect_pat_opt_(boxpat.pat(), binding_list);\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -965,7 +1000,7 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                            this.collect_pat_opt_(expanded_pat)\n+                            this.collect_pat_opt_(expanded_pat, binding_list)\n                         });\n                     self.source_map.pat_map.insert(src, pat);\n                     return pat;\n@@ -979,21 +1014,25 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(pat),\n+            Some(pat) => self.collect_pat_(pat, binding_list),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n+    fn collect_tuple_pat(\n+        &mut self,\n+        args: AstChildren<ast::Pat>,\n+        binding_list: &mut BindingList,\n+    ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(p))\n+            .map(|p| self.collect_pat_(p, binding_list))\n             .collect();\n \n         (args, ellipsis)\n@@ -1022,6 +1061,10 @@ impl ExprCollector<'_> {\n             None => Some(()),\n         }\n     }\n+\n+    fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {\n+        self.body.bindings[binding_id].definitions.push(pat_id);\n+    }\n }\n \n impl From<ast::LiteralKind> for Literal {"}, {"sha": "f8b159797e44afef0110905b6205bc88962c050a", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -5,7 +5,7 @@ use std::fmt::{self, Write};\n use syntax::ast::HasName;\n \n use crate::{\n-    expr::{Array, BindingAnnotation, ClosureKind, Literal, Movability, Statement},\n+    expr::{Array, BindingAnnotation, BindingId, ClosureKind, Literal, Movability, Statement},\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -524,14 +524,8 @@ impl<'a> Printer<'a> {\n             }\n             Pat::Path(path) => self.print_path(path),\n             Pat::Lit(expr) => self.print_expr(*expr),\n-            Pat::Bind { mode, name, subpat } => {\n-                let mode = match mode {\n-                    BindingAnnotation::Unannotated => \"\",\n-                    BindingAnnotation::Mutable => \"mut \",\n-                    BindingAnnotation::Ref => \"ref \",\n-                    BindingAnnotation::RefMut => \"ref mut \",\n-                };\n-                w!(self, \"{}{}\", mode, name);\n+            Pat::Bind { id, subpat } => {\n+                self.print_binding(*id);\n                 if let Some(pat) = subpat {\n                     self.whitespace();\n                     self.print_pat(*pat);\n@@ -635,4 +629,15 @@ impl<'a> Printer<'a> {\n     fn print_path(&mut self, path: &Path) {\n         print_path(path, self).unwrap();\n     }\n+\n+    fn print_binding(&mut self, id: BindingId) {\n+        let Binding { name, mode, .. } = &self.body.bindings[id];\n+        let mode = match mode {\n+            BindingAnnotation::Unannotated => \"\",\n+            BindingAnnotation::Mutable => \"mut \",\n+            BindingAnnotation::Ref => \"ref \",\n+            BindingAnnotation::RefMut => \"ref mut \",\n+        };\n+        w!(self, \"{}{}\", mode, name);\n+    }\n }"}, {"sha": "12fc1f116d7dac0cbfe98fcaa94d4c63b03ab7ed", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     body::Body,\n     db::DefDatabase,\n-    expr::{Expr, ExprId, LabelId, Pat, PatId, Statement},\n+    expr::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n     BlockId, DefWithBodyId,\n };\n \n@@ -23,16 +23,16 @@ pub struct ExprScopes {\n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeEntry {\n     name: Name,\n-    pat: PatId,\n+    binding: BindingId,\n }\n \n impl ScopeEntry {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n \n-    pub fn pat(&self) -> PatId {\n-        self.pat\n+    pub fn binding(&self) -> BindingId {\n+        self.binding\n     }\n }\n \n@@ -126,18 +126,23 @@ impl ExprScopes {\n         })\n     }\n \n-    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, binding: BindingId) {\n+        let Binding { name, .. } = &body.bindings[binding];\n+        let entry = ScopeEntry { name: name.clone(), binding };\n+        self.scopes[scope].entries.push(entry);\n+    }\n+\n+    fn add_pat_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n         let pattern = &body[pat];\n-        if let Pat::Bind { name, .. } = pattern {\n-            let entry = ScopeEntry { name: name.clone(), pat };\n-            self.scopes[scope].entries.push(entry);\n+        if let Pat::Bind { id, .. } = pattern {\n+            self.add_bindings(body, scope, *id);\n         }\n \n-        pattern.walk_child_pats(|pat| self.add_bindings(body, scope, pat));\n+        pattern.walk_child_pats(|pat| self.add_pat_bindings(body, scope, pat));\n     }\n \n     fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n-        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n+        params.iter().for_each(|pat| self.add_pat_bindings(body, scope, *pat));\n     }\n \n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n@@ -170,7 +175,7 @@ fn compute_block_scopes(\n                 }\n \n                 *scope = scopes.new_scope(*scope);\n-                scopes.add_bindings(body, *scope, *pat);\n+                scopes.add_pat_bindings(body, *scope, *pat);\n             }\n             Statement::Expr { expr, .. } => {\n                 compute_expr_scopes(*expr, body, scopes, scope);\n@@ -208,7 +213,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         Expr::For { iterable, pat, body: body_expr, label } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n-            scopes.add_bindings(body, scope, *pat);\n+            scopes.add_pat_bindings(body, scope, *pat);\n             compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::While { condition, body: body_expr, label } => {\n@@ -229,7 +234,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             compute_expr_scopes(*expr, body, scopes, scope);\n             for arm in arms.iter() {\n                 let mut scope = scopes.new_scope(*scope);\n-                scopes.add_bindings(body, scope, arm.pat);\n+                scopes.add_pat_bindings(body, scope, arm.pat);\n                 if let Some(guard) = arm.guard {\n                     scope = scopes.new_scope(scope);\n                     compute_expr_scopes(guard, body, scopes, &mut scope);\n@@ -248,7 +253,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         &Expr::Let { pat, expr } => {\n             compute_expr_scopes(expr, body, scopes, scope);\n             *scope = scopes.new_scope(*scope);\n-            scopes.add_bindings(body, *scope, pat);\n+            scopes.add_pat_bindings(body, *scope, pat);\n         }\n         e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n@@ -450,7 +455,7 @@ fn foo() {\n         let function = find_function(&db, file_id);\n \n         let scopes = db.expr_scopes(function.into());\n-        let (_body, source_map) = db.body_with_source_map(function.into());\n+        let (body, source_map) = db.body_with_source_map(function.into());\n \n         let expr_scope = {\n             let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n@@ -460,7 +465,9 @@ fn foo() {\n         };\n \n         let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n-        let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n+        let pat_src = source_map\n+            .pat_syntax(*body.bindings[resolved.binding()].definitions.first().unwrap())\n+            .unwrap();\n \n         let local_name = pat_src.value.either(\n             |it| it.syntax_node_ptr().to_node(file.syntax()),"}, {"sha": "bbea608c55eb5b40894f88ed1b7379b755133835", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -17,6 +17,7 @@ use std::fmt;\n use hir_expand::name::Name;\n use intern::Interned;\n use la_arena::{Idx, RawIdx};\n+use smallvec::SmallVec;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n@@ -29,6 +30,8 @@ pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, Unar\n \n pub type ExprId = Idx<Expr>;\n \n+pub type BindingId = Idx<Binding>;\n+\n /// FIXME: this is a hacky function which should be removed\n pub(crate) fn dummy_expr_id() -> ExprId {\n     ExprId::from_raw(RawIdx::from(u32::MAX))\n@@ -433,6 +436,13 @@ impl BindingAnnotation {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Binding {\n+    pub name: Name,\n+    pub mode: BindingAnnotation,\n+    pub definitions: SmallVec<[PatId; 1]>,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct RecordFieldPat {\n     pub name: Name,\n@@ -451,7 +461,7 @@ pub enum Pat {\n     Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),\n-    Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n+    Bind { id: BindingId, subpat: Option<PatId> },\n     TupleStruct { path: Option<Box<Path>>, args: Box<[PatId]>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n     Box { inner: PatId },"}, {"sha": "61e64fc10363114c96c3877a8a8cef2a7a2a3d63", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n-    expr::{ExprId, LabelId, PatId},\n+    expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::DefMap,\n@@ -105,7 +105,7 @@ pub enum ResolveValueResult {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n     ImplSelf(ImplId),\n-    LocalBinding(PatId),\n+    LocalBinding(BindingId),\n     FunctionId(FunctionId),\n     ConstId(ConstId),\n     StaticId(StaticId),\n@@ -267,7 +267,7 @@ impl Resolver {\n \n                         if let Some(e) = entry {\n                             return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(\n-                                e.pat(),\n+                                e.binding(),\n                             )));\n                         }\n                     }\n@@ -617,7 +617,7 @@ pub enum ScopeDef {\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n     GenericParam(GenericParamId),\n-    Local(PatId),\n+    Local(BindingId),\n     Label(LabelId),\n }\n \n@@ -669,7 +669,7 @@ impl Scope {\n                     acc.add(&name, ScopeDef::Label(label))\n                 }\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {\n-                    acc.add_local(e.name(), e.pat());\n+                    acc.add_local(e.name(), e.binding());\n                 });\n             }\n         }\n@@ -859,7 +859,7 @@ impl ScopeNames {\n             self.add(name, ScopeDef::Unknown)\n         }\n     }\n-    fn add_local(&mut self, name: &Name, pat: PatId) {\n+    fn add_local(&mut self, name: &Name, binding: BindingId) {\n         let set = self.map.entry(name.clone()).or_default();\n         // XXX: hack, account for local (and only local) shadowing.\n         //\n@@ -870,7 +870,7 @@ impl ScopeNames {\n             cov_mark::hit!(shadowing_shows_single_completion);\n             return;\n         }\n-        set.push(ScopeDef::Local(pat))\n+        set.push(ScopeDef::Local(binding))\n     }\n }\n "}, {"sha": "b7a466c389c7768bf23d6d529ae7b4779feee184", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -545,6 +545,49 @@ fn let_else() {\n     );\n }\n \n+#[test]\n+fn function_param_patterns() {\n+    check_number(\n+        r#\"\n+    const fn f((a, b): &(u8, u8)) -> u8 {\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(c @ (a, b): &(u8, u8)) -> u8 {\n+        *a + *b + (*c).1\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        8,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(ref a: u8) -> u8 {\n+        *a\n+    }\n+    const GOAL: u8 = f(2);\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    struct Foo(u8);\n+    impl Foo {\n+        const fn f(&self, (a, b): &(u8, u8)) -> u8 {\n+            self.0 + *a + *b\n+        }\n+    }\n+    const GOAL: u8 = Foo(4).f(&(2, 3));\n+        \"#,\n+        9,\n+    );\n+}\n+\n #[test]\n fn options() {\n     check_number("}, {"sha": "d36b93e3bdde19d71978235ad65005ef2d84a65b", "filename": "crates/hir-ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -235,8 +235,8 @@ impl<'a> DeclValidator<'a> {\n         let pats_replacements = body\n             .pats\n             .iter()\n-            .filter_map(|(id, pat)| match pat {\n-                Pat::Bind { name, .. } => Some((id, name)),\n+            .filter_map(|(pat_id, pat)| match pat {\n+                Pat::Bind { id, .. } => Some((pat_id, &body.bindings[*id].name)),\n                 _ => None,\n             })\n             .filter_map(|(id, bind_name)| {"}, {"sha": "859a37804ae7fa8b33b00864f616810f266dc10a", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -146,8 +146,9 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Leaf { subpatterns }\n             }\n \n-            hir_def::expr::Pat::Bind { ref name, subpat, .. } => {\n+            hir_def::expr::Pat::Bind { id, subpat, .. } => {\n                 let bm = self.infer.pat_binding_modes[&pat];\n+                let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {\n                     (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,\n                     (BindingMode::Ref(_), _) => {"}, {"sha": "bac733d9885c1f63c9b3fc5e020634ebedf45eb8", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -22,7 +22,7 @@ use hir_def::{\n     body::Body,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n-    expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n+    expr::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n     lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n     path::Path,\n@@ -352,6 +352,7 @@ pub struct InferenceResult {\n     /// **Note**: When a pattern type is resolved it may still contain\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_binding: ArenaMap<BindingId, Ty>,\n     pub type_of_rpit: ArenaMap<RpitId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n@@ -414,6 +415,14 @@ impl Index<PatId> for InferenceResult {\n     }\n }\n \n+impl Index<BindingId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, b: BindingId) -> &Ty {\n+        self.type_of_binding.get(b).unwrap_or(&self.standard_types.unknown)\n+    }\n+}\n+\n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n pub(crate) struct InferenceContext<'a> {\n@@ -534,7 +543,10 @@ impl<'a> InferenceContext<'a> {\n         for ty in result.type_of_pat.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_rpit.iter_mut().map(|x| x.1) {\n+        for ty in result.type_of_binding.values_mut() {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n+        for ty in result.type_of_rpit.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n         for mismatch in result.type_mismatches.values_mut() {\n@@ -704,6 +716,10 @@ impl<'a> InferenceContext<'a> {\n         self.result.type_of_pat.insert(pat, ty);\n     }\n \n+    fn write_binding_ty(&mut self, id: BindingId, ty: Ty) {\n+        self.result.type_of_binding.insert(id, ty);\n+    }\n+\n     fn push_diagnostic(&mut self, diagnostic: InferenceDiagnostic) {\n         self.result.diagnostics.push(diagnostic);\n     }"}, {"sha": "566ed298c58f380cb20f9b01d2ded26f0d25b2e9", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -5,7 +5,7 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{BindingAnnotation, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId, RecordFieldPat},\n+    expr::{Binding, BindingAnnotation, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId, RecordFieldPat, BindingId},\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -248,8 +248,8 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME update resolver for the surrounding expression\n                 self.infer_path(path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Pat::Bind { mode, name: _, subpat } => {\n-                return self.infer_bind_pat(pat, *mode, default_bm, *subpat, &expected);\n+            Pat::Bind { id, subpat } => {\n+                return self.infer_bind_pat(pat, *id, default_bm, *subpat, &expected);\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n                 self.infer_slice_pat(&expected, prefix, slice, suffix, default_bm)\n@@ -320,11 +320,12 @@ impl<'a> InferenceContext<'a> {\n     fn infer_bind_pat(\n         &mut self,\n         pat: PatId,\n-        mode: BindingAnnotation,\n+        binding: BindingId,\n         default_bm: BindingMode,\n         subpat: Option<PatId>,\n         expected: &Ty,\n     ) -> Ty {\n+        let Binding { mode, .. } = self.body.bindings[binding];\n         let mode = if mode == BindingAnnotation::Unannotated {\n             default_bm\n         } else {\n@@ -344,7 +345,8 @@ impl<'a> InferenceContext<'a> {\n             }\n             BindingMode::Move => inner_ty.clone(),\n         };\n-        self.write_pat_ty(pat, bound_ty);\n+        self.write_pat_ty(pat, bound_ty.clone());\n+        self.write_binding_ty(binding, bound_ty);\n         return inner_ty;\n     }\n \n@@ -420,19 +422,22 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         Pat::Lit(expr) => {\n             !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n         }\n-        Pat::Bind {\n-            mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n-            subpat: Some(subpat),\n-            ..\n-        } => is_non_ref_pat(body, *subpat),\n+        Pat::Bind { id, subpat: Some(subpat), .. }\n+            if matches!(\n+                body.bindings[*id].mode,\n+                BindingAnnotation::Mutable | BindingAnnotation::Unannotated\n+            ) =>\n+        {\n+            is_non_ref_pat(body, *subpat)\n+        }\n         Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Box { .. } | Pat::Missing => false,\n     }\n }\n \n pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n     let mut res = false;\n     walk_pats(body, pat_id, &mut |pat| {\n-        res |= matches!(pat, Pat::Bind { mode: BindingAnnotation::Ref, .. })\n+        res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n     });\n     res\n }"}, {"sha": "2267fedaa8e9261bc1af94492cac41bfe631a685", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -50,7 +50,7 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         let typable: ValueTyDefId = match value {\n-            ValueNs::LocalBinding(pat) => match self.result.type_of_pat.get(pat) {\n+            ValueNs::LocalBinding(pat) => match self.result.type_of_binding.get(pat) {\n                 Some(ty) => return Some(ty.clone()),\n                 None => {\n                     never!(\"uninferred pattern?\");"}, {"sha": "a8971fde3c21edbc0c8e21de6d2d9be570a763aa", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -65,17 +65,9 @@ fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n         })\n         .unwrap();\n     let hir_body = db.body(adt_id.into());\n-    let pat = hir_body\n-        .pats\n-        .iter()\n-        .find(|x| match x.1 {\n-            hir_def::expr::Pat::Bind { name, .. } => name.to_smol_str() == \"goal\",\n-            _ => false,\n-        })\n-        .unwrap()\n-        .0;\n+    let b = hir_body.bindings.iter().find(|x| x.1.name.to_smol_str() == \"goal\").unwrap().0;\n     let infer = db.infer(adt_id.into());\n-    let goal_ty = infer.type_of_pat[pat].clone();\n+    let goal_ty = infer.type_of_binding[b].clone();\n     layout_of_ty(&db, &goal_ty, module_id.krate())\n }\n "}, {"sha": "8f28d62db039062201030e3bd7066d31209abc92", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 72, "deletions": 24, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -6,7 +6,8 @@ use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n     body::Body,\n     expr::{\n-        Array, BindingAnnotation, ExprId, LabelId, Literal, MatchArm, Pat, PatId, RecordLitField,\n+        Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n+        RecordLitField,\n     },\n     layout::LayoutError,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n@@ -30,7 +31,7 @@ struct LoopBlocks {\n struct MirLowerCtx<'a> {\n     result: MirBody,\n     owner: DefWithBodyId,\n-    binding_locals: ArenaMap<PatId, LocalId>,\n+    binding_locals: ArenaMap<BindingId, LocalId>,\n     current_loop_blocks: Option<LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n@@ -43,7 +44,9 @@ pub enum MirLowerError {\n     ConstEvalError(Box<ConstEvalError>),\n     LayoutError(LayoutError),\n     IncompleteExpr,\n-    UnresolvedName,\n+    UnresolvedName(String),\n+    UnresolvedMethod,\n+    UnresolvedField,\n     MissingFunctionDefinition,\n     TypeError(&'static str),\n     NotSupported(String),\n@@ -222,22 +225,23 @@ impl MirLowerCtx<'_> {\n         match &self.body.exprs[expr_id] {\n             Expr::Missing => Err(MirLowerError::IncompleteExpr),\n             Expr::Path(p) => {\n+                let unresolved_name = || MirLowerError::UnresolvedName(\"\".to_string());\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n                 let pr = resolver\n                     .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n-                    .ok_or(MirLowerError::UnresolvedName)?;\n+                    .ok_or_else(unresolved_name)?;\n                 let pr = match pr {\n                     ResolveValueResult::ValueNs(v) => v,\n                     ResolveValueResult::Partial(..) => {\n                         return match self\n                             .infer\n                             .assoc_resolutions_for_expr(expr_id)\n-                            .ok_or(MirLowerError::UnresolvedName)?\n+                            .ok_or_else(unresolved_name)?\n                             .0\n                             //.ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n                         {\n                             hir_def::AssocItemId::ConstId(c) => self.lower_const(c, current, place),\n-                            _ => return Err(MirLowerError::UnresolvedName),\n+                            _ => return Err(unresolved_name()),\n                         };\n                     }\n                 };\n@@ -394,7 +398,7 @@ impl MirLowerCtx<'_> {\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n                 let (func_id, generic_args) =\n-                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedName)?;\n+                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedMethod)?;\n                 let ty = chalk_ir::TyKind::FnDef(\n                     CallableDefId::FunctionId(func_id).to_chalk(self.db),\n                     generic_args,\n@@ -476,7 +480,7 @@ impl MirLowerCtx<'_> {\n                 let variant_id = self\n                     .infer\n                     .variant_resolution_for_expr(expr_id)\n-                    .ok_or(MirLowerError::UnresolvedName)?;\n+                    .ok_or_else(|| MirLowerError::UnresolvedName(\"\".to_string()))?;\n                 let subst = match self.expr_ty(expr_id).kind(Interner) {\n                     TyKind::Adt(_, s) => s.clone(),\n                     _ => not_supported!(\"Non ADT record literal\"),\n@@ -487,7 +491,7 @@ impl MirLowerCtx<'_> {\n                         let mut operands = vec![None; variant_data.fields().len()];\n                         for RecordLitField { name, expr } in fields.iter() {\n                             let field_id =\n-                                variant_data.field(name).ok_or(MirLowerError::UnresolvedName)?;\n+                                variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n                             let op;\n                             (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n                             operands[u32::from(field_id.into_raw()) as usize] = Some(op);\n@@ -509,7 +513,7 @@ impl MirLowerCtx<'_> {\n                             not_supported!(\"Union record literal with more than one field\");\n                         };\n                         let local_id =\n-                            variant_data.field(name).ok_or(MirLowerError::UnresolvedName)?;\n+                            variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n                         let mut place = place;\n                         place\n                             .projection\n@@ -529,7 +533,7 @@ impl MirLowerCtx<'_> {\n                     let field = self\n                         .infer\n                         .field_resolution(expr_id)\n-                        .ok_or(MirLowerError::UnresolvedName)?;\n+                        .ok_or(MirLowerError::UnresolvedField)?;\n                     current_place.projection.push(ProjectionElem::Field(field));\n                 }\n                 self.push_assignment(current, place, Operand::Copy(current_place).into());\n@@ -962,8 +966,9 @@ impl MirLowerCtx<'_> {\n                 }\n                 (then_target, Some(else_target))\n             }\n-            Pat::Bind { mode, name: _, subpat } => {\n-                let target_place = self.binding_locals[pattern];\n+            Pat::Bind { id, subpat } => {\n+                let target_place = self.binding_locals[*id];\n+                let mode = self.body.bindings[*id].mode;\n                 if let Some(subpat) = subpat {\n                     (current, current_else) = self.pattern_match(\n                         current,\n@@ -975,7 +980,7 @@ impl MirLowerCtx<'_> {\n                     )?\n                 }\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-                    binding_mode = *mode;\n+                    binding_mode = mode;\n                 }\n                 self.push_assignment(\n                     current,\n@@ -1189,17 +1194,40 @@ pub fn lower_to_mir(\n     let mut locals = Arena::new();\n     // 0 is return local\n     locals.alloc(Local { mutability: Mutability::Mut, ty: infer[root_expr].clone() });\n-    let mut create_local_of_path = |p: PatId| {\n-        // FIXME: mutablity is broken\n-        locals.alloc(Local { mutability: Mutability::Not, ty: infer[p].clone() })\n+    let mut binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n+    let param_locals: ArenaMap<PatId, LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n+        let substs = TyBuilder::placeholder_subst(db, fid);\n+        let callable_sig = db.callable_item_signature(fid.into()).substitute(Interner, &substs);\n+        // 1 to param_len is for params\n+        body.params\n+            .iter()\n+            .zip(callable_sig.params().iter())\n+            .map(|(&x, ty)| {\n+                let local_id = locals.alloc(Local { mutability: Mutability::Not, ty: ty.clone() });\n+                if let Pat::Bind { id, subpat: None } = body[x] {\n+                    if matches!(\n+                        body.bindings[id].mode,\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n+                    ) {\n+                        binding_locals.insert(id, local_id);\n+                    }\n+                }\n+                (x, local_id)\n+            })\n+            .collect()\n+    } else {\n+        if !body.params.is_empty() {\n+            return Err(MirLowerError::TypeError(\"Unexpected parameter for non function body\"));\n+        }\n+        ArenaMap::new()\n     };\n-    // 1 to param_len is for params\n-    let mut binding_locals: ArenaMap<PatId, LocalId> =\n-        body.params.iter().map(|&x| (x, create_local_of_path(x))).collect();\n     // and then rest of bindings\n-    for (pat_id, _) in body.pats.iter() {\n-        if !binding_locals.contains_idx(pat_id) {\n-            binding_locals.insert(pat_id, create_local_of_path(pat_id));\n+    for (id, _) in body.bindings.iter() {\n+        if !binding_locals.contains_idx(id) {\n+            binding_locals.insert(\n+                id,\n+                locals.alloc(Local { mutability: Mutability::Not, ty: infer[id].clone() }),\n+            );\n         }\n     }\n     let mir = MirBody { basic_blocks, locals, start_block, owner, arg_count: body.params.len() };\n@@ -1213,7 +1241,27 @@ pub fn lower_to_mir(\n         current_loop_blocks: None,\n         discr_temp: None,\n     };\n-    let b = ctx.lower_expr_to_place(root_expr, return_slot().into(), start_block)?;\n+    let mut current = start_block;\n+    for &param in &body.params {\n+        if let Pat::Bind { id, .. } = body[param] {\n+            if param_locals[param] == ctx.binding_locals[id] {\n+                continue;\n+            }\n+        }\n+        let r = ctx.pattern_match(\n+            current,\n+            None,\n+            param_locals[param].into(),\n+            ctx.result.locals[param_locals[param]].ty.clone(),\n+            param,\n+            BindingAnnotation::Unannotated,\n+        )?;\n+        if let Some(b) = r.1 {\n+            ctx.set_terminator(b, Terminator::Unreachable);\n+        }\n+        current = r.0;\n+    }\n+    let b = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)?;\n     ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n     Ok(ctx.result)\n }"}, {"sha": "aaaa7abf3863c35057113075133e3b5d399493ee", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -4,7 +4,7 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    expr::{LabelId, PatId},\n+    expr::{BindingId, LabelId},\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, GenericDefId, GenericParamId,\n     ModuleDefId, VariantId,\n };\n@@ -251,9 +251,9 @@ impl From<AssocItem> for GenericDefId {\n     }\n }\n \n-impl From<(DefWithBodyId, PatId)> for Local {\n-    fn from((parent, pat_id): (DefWithBodyId, PatId)) -> Self {\n-        Local { parent, pat_id }\n+impl From<(DefWithBodyId, BindingId)> for Local {\n+    fn from((parent, binding_id): (DefWithBodyId, BindingId)) -> Self {\n+        Local { parent, binding_id }\n     }\n }\n "}, {"sha": "b83d83b5ed5c16bdd1bc888bbb90a7c3db138689", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -41,7 +41,7 @@ use either::Either;\n use hir_def::{\n     adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n-    expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n+    expr::{BindingAnnotation, BindingId, ExprOrPatId, LabelId, Pat},\n     generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::{LangItem, LangItemTarget},\n@@ -77,7 +77,7 @@ use rustc_hash::FxHashSet;\n use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n-    AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n+    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, T,\n };\n \n use crate::db::{DefDatabase, HirDatabase};\n@@ -1782,8 +1782,8 @@ impl Param {\n         let parent = DefWithBodyId::FunctionId(self.func.into());\n         let body = db.body(parent);\n         let pat_id = body.params[self.idx];\n-        if let Pat::Bind { .. } = &body[pat_id] {\n-            Some(Local { parent, pat_id: body.params[self.idx] })\n+        if let Pat::Bind { id, .. } = &body[pat_id] {\n+            Some(Local { parent, binding_id: *id })\n         } else {\n             None\n         }\n@@ -2460,13 +2460,42 @@ impl GenericDef {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBodyId,\n-    pub(crate) pat_id: PatId,\n+    pub(crate) binding_id: BindingId,\n+}\n+\n+pub struct LocalSource {\n+    pub local: Local,\n+    pub source: InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+}\n+\n+impl LocalSource {\n+    pub fn as_ident_pat(&self) -> Option<&ast::IdentPat> {\n+        match &self.source.value {\n+            Either::Left(x) => Some(x),\n+            Either::Right(_) => None,\n+        }\n+    }\n+\n+    pub fn into_ident_pat(self) -> Option<ast::IdentPat> {\n+        match self.source.value {\n+            Either::Left(x) => Some(x),\n+            Either::Right(_) => None,\n+        }\n+    }\n+\n+    pub fn original_file(&self, db: &dyn HirDatabase) -> FileId {\n+        self.source.file_id.original_file(db.upcast())\n+    }\n+\n+    pub fn syntax(&self) -> &SyntaxNode {\n+        self.source.value.syntax()\n+    }\n }\n \n impl Local {\n     pub fn is_param(self, db: &dyn HirDatabase) -> bool {\n-        let src = self.source(db);\n-        match src.value {\n+        let src = self.primary_source(db);\n+        match src.source.value {\n             Either::Left(pat) => pat\n                 .syntax()\n                 .ancestors()\n@@ -2486,13 +2515,7 @@ impl Local {\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let body = db.body(self.parent);\n-        match &body[self.pat_id] {\n-            Pat::Bind { name, .. } => name.clone(),\n-            _ => {\n-                stdx::never!(\"hir::Local is missing a name!\");\n-                Name::missing()\n-            }\n-        }\n+        body[self.binding_id].name.clone()\n     }\n \n     pub fn is_self(self, db: &dyn HirDatabase) -> bool {\n@@ -2501,15 +2524,12 @@ impl Local {\n \n     pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent);\n-        matches!(&body[self.pat_id], Pat::Bind { mode: BindingAnnotation::Mutable, .. })\n+        body[self.binding_id].mode == BindingAnnotation::Mutable\n     }\n \n     pub fn is_ref(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent);\n-        matches!(\n-            &body[self.pat_id],\n-            Pat::Bind { mode: BindingAnnotation::Ref | BindingAnnotation::RefMut, .. }\n-        )\n+        matches!(body[self.binding_id].mode, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n     }\n \n     pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n@@ -2523,34 +2543,33 @@ impl Local {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let def = self.parent;\n         let infer = db.infer(def);\n-        let ty = infer[self.pat_id].clone();\n+        let ty = infer[self.binding_id].clone();\n         Type::new(db, def, ty)\n     }\n \n-    pub fn associated_locals(self, db: &dyn HirDatabase) -> Box<[Local]> {\n-        let body = db.body(self.parent);\n-        body.ident_patterns_for(&self.pat_id)\n+    /// All definitions for this local. Example: `let (a$0, _) | (_, a$0) = x;`\n+    pub fn sources(self, db: &dyn HirDatabase) -> Vec<LocalSource> {\n+        let (body, source_map) = db.body_with_source_map(self.parent);\n+        body[self.binding_id]\n+            .definitions\n             .iter()\n-            .map(|&pat_id| Local { parent: self.parent, pat_id })\n+            .map(|&definition| {\n+                let src = source_map.pat_syntax(definition).unwrap(); // Hmm...\n+                let root = src.file_syntax(db.upcast());\n+                src.map(|ast| match ast {\n+                    // Suspicious unwrap\n+                    Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n+                    Either::Right(it) => Either::Right(it.to_node(&root)),\n+                })\n+            })\n+            .map(|source| LocalSource { local: self, source })\n             .collect()\n     }\n \n-    /// If this local is part of a multi-local, retrieve the representative local.\n-    /// That is the local that references are being resolved to.\n-    pub fn representative(self, db: &dyn HirDatabase) -> Local {\n-        let body = db.body(self.parent);\n-        Local { pat_id: body.pattern_representative(self.pat_id), ..self }\n-    }\n-\n-    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n-        let (_body, source_map) = db.body_with_source_map(self.parent);\n-        let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n-        let root = src.file_syntax(db.upcast());\n-        src.map(|ast| match ast {\n-            // Suspicious unwrap\n-            Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n-            Either::Right(it) => Either::Right(it.to_node(&root)),\n-        })\n+    /// The leftmost definition for this local. Example: `let (a$0, _) | (_, a) = x;`\n+    pub fn primary_source(self, db: &dyn HirDatabase) -> LocalSource {\n+        let all_sources = self.sources(db);\n+        all_sources.into_iter().next().unwrap()\n     }\n }\n "}, {"sha": "cbd350cea448e5828f0286d3c567cae7268dab18", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -1654,8 +1654,8 @@ impl<'a> SemanticsScope<'a> {\n                     resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                     resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n                     resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(id.into()),\n-                    resolver::ScopeDef::Local(pat_id) => match self.resolver.body_owner() {\n-                        Some(parent) => ScopeDef::Local(Local { parent, pat_id }),\n+                    resolver::ScopeDef::Local(binding_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Local(Local { parent, binding_id }),\n                         None => continue,\n                     },\n                     resolver::ScopeDef::Label(label_id) => match self.resolver.body_owner() {"}, {"sha": "f6f8c9a250f06cbf16ac88c5c8b3b5b022b46347", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -89,7 +89,7 @@ use base_db::FileId;\n use hir_def::{\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n-    expr::{LabelId, PatId},\n+    expr::{BindingId, LabelId},\n     keys::{self, Key},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n     GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n@@ -98,7 +98,7 @@ use hir_def::{\n use hir_expand::{attrs::AttrId, name::AsName, HirFileId, MacroCallId};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n-use stdx::impl_from;\n+use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasName},\n     AstNode, SyntaxNode,\n@@ -216,26 +216,31 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn bind_pat_to_def(\n         &mut self,\n         src: InFile<ast::IdentPat>,\n-    ) -> Option<(DefWithBodyId, PatId)> {\n+    ) -> Option<(DefWithBodyId, BindingId)> {\n         let container = self.find_pat_or_label_container(src.syntax())?;\n         let (body, source_map) = self.db.body_with_source_map(container);\n         let src = src.map(ast::Pat::from);\n         let pat_id = source_map.node_pat(src.as_ref())?;\n         // the pattern could resolve to a constant, verify that that is not the case\n-        if let crate::Pat::Bind { .. } = body[pat_id] {\n-            Some((container, pat_id))\n+        if let crate::Pat::Bind { id, .. } = body[pat_id] {\n+            Some((container, id))\n         } else {\n             None\n         }\n     }\n     pub(super) fn self_param_to_def(\n         &mut self,\n         src: InFile<ast::SelfParam>,\n-    ) -> Option<(DefWithBodyId, PatId)> {\n+    ) -> Option<(DefWithBodyId, BindingId)> {\n         let container = self.find_pat_or_label_container(src.syntax())?;\n-        let (_body, source_map) = self.db.body_with_source_map(container);\n+        let (body, source_map) = self.db.body_with_source_map(container);\n         let pat_id = source_map.node_self_param(src.as_ref())?;\n-        Some((container, pat_id))\n+        if let crate::Pat::Bind { id, .. } = body[pat_id] {\n+            Some((container, id))\n+        } else {\n+            never!();\n+            None\n+        }\n     }\n     pub(super) fn label_to_def(\n         &mut self,"}, {"sha": "133fa810d66133d332b7ffcf30d4b67bb02c8a76", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -422,8 +422,8 @@ impl SourceAnalyzer {\n             // Shorthand syntax, resolve to the local\n             let path = ModPath::from_segments(PathKind::Plain, once(local_name.clone()));\n             match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n-                Some(ValueNs::LocalBinding(pat_id)) => {\n-                    Some(Local { pat_id, parent: self.resolver.body_owner()? })\n+                Some(ValueNs::LocalBinding(binding_id)) => {\n+                    Some(Local { binding_id, parent: self.resolver.body_owner()? })\n                 }\n                 _ => None,\n             }\n@@ -1018,8 +1018,8 @@ fn resolve_hir_path_(\n     let values = || {\n         resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n             let res = match val {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let var = Local { parent: body_owner?, pat_id };\n+                ValueNs::LocalBinding(binding_id) => {\n+                    let var = Local { parent: body_owner?, binding_id };\n                     PathResolution::Local(var)\n                 }\n                 ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),"}, {"sha": "745a870ab6b4b4e31797d287abe7734dddb43758", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -101,7 +101,7 @@ fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Opti\n             let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;\n             match NameRefClass::classify(&ctx.sema, &name_ref)? {\n                 NameRefClass::Definition(Definition::Local(local)) => {\n-                    let source = local.source(ctx.db()).value.left()?;\n+                    let source = local.primary_source(ctx.db()).into_ident_pat()?;\n                     Some(source.name()?)\n                 }\n                 _ => None,"}, {"sha": "0b90c9ba34f5fb9ce7353197bb3018640e8394b3", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -3,7 +3,8 @@ use std::iter;\n use ast::make;\n use either::Either;\n use hir::{\n-    HasSource, HirDisplay, InFile, Local, ModuleDef, PathResolution, Semantics, TypeInfo, TypeParam,\n+    HasSource, HirDisplay, InFile, Local, LocalSource, ModuleDef, PathResolution, Semantics,\n+    TypeInfo, TypeParam,\n };\n use ide_db::{\n     defs::{Definition, NameRefClass},\n@@ -710,7 +711,7 @@ impl FunctionBody {\n                     ) => local_ref,\n                     _ => return,\n                 };\n-            let InFile { file_id, value } = local_ref.source(sema.db);\n+            let InFile { file_id, value } = local_ref.primary_source(sema.db).source;\n             // locals defined inside macros are not relevant to us\n             if !file_id.is_macro() {\n                 match value {\n@@ -972,11 +973,11 @@ impl FunctionBody {\n         locals: impl Iterator<Item = Local>,\n     ) -> Vec<Param> {\n         locals\n-            .map(|local| (local, local.source(ctx.db())))\n+            .map(|local| (local, local.primary_source(ctx.db())))\n             .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))\n-            .filter_map(|(local, src)| match src.value {\n-                Either::Left(src) => Some((local, src)),\n-                Either::Right(_) => {\n+            .filter_map(|(local, src)| match src.into_ident_pat() {\n+                Some(src) => Some((local, src)),\n+                None => {\n                     stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n                     None\n                 }\n@@ -1238,17 +1239,9 @@ fn local_outlives_body(\n fn is_defined_outside_of_body(\n     ctx: &AssistContext<'_>,\n     body: &FunctionBody,\n-    src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+    src: &LocalSource,\n ) -> bool {\n-    src.file_id.original_file(ctx.db()) == ctx.file_id()\n-        && !body.contains_node(either_syntax(&src.value))\n-}\n-\n-fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n-    match value {\n-        Either::Left(pat) => pat.syntax(),\n-        Either::Right(it) => it.syntax(),\n-    }\n+    src.original_file(ctx.db()) == ctx.file_id() && !body.contains_node(src.syntax())\n }\n \n /// find where to put extracted function definition"}, {"sha": "e69d1a29677a9fec828968777af14c23e7132b95", "filename": "crates/ide-assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -1,4 +1,3 @@\n-use either::Either;\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n@@ -205,12 +204,14 @@ fn inline_usage(\n         return None;\n     }\n \n-    // FIXME: Handle multiple local definitions\n-    let bind_pat = match local.source(sema.db).value {\n-        Either::Left(ident) => ident,\n-        _ => return None,\n+    let sources = local.sources(sema.db);\n+    let [source] = sources.as_slice() else {\n+        // Not applicable with locals with multiple definitions (i.e. or patterns)\n+        return None;\n     };\n \n+    let bind_pat = source.as_ident_pat()?;\n+\n     let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n \n     let UsageSearchResult { mut references } = Definition::Local(local).usages(sema).all();"}, {"sha": "298c7141390bda740c4eeb4795ec0c9402a53d0b", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 49, "deletions": 56, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -121,14 +121,8 @@ impl Definition {\n             Definition::Trait(it) => name_range(it, sema),\n             Definition::TraitAlias(it) => name_range(it, sema),\n             Definition::TypeAlias(it) => name_range(it, sema),\n-            Definition::Local(local) => {\n-                let src = local.source(sema.db);\n-                let name = match &src.value {\n-                    Either::Left(bind_pat) => bind_pat.name()?,\n-                    Either::Right(_) => return None,\n-                };\n-                src.with_value(name.syntax()).original_file_range_opt(sema.db)\n-            }\n+            // A local might be `self` or have multiple definitons like `let (a | a) = 2`, so it should be handled as a special case\n+            Definition::Local(_) => return None,\n             Definition::GenericParam(generic_param) => match generic_param {\n                 hir::GenericParam::LifetimeParam(lifetime_param) => {\n                     let src = lifetime_param.source(sema.db)?;\n@@ -302,13 +296,7 @@ fn rename_reference(\n         source_change.insert_source_edit(file_id, edit);\n         Ok(())\n     };\n-    match def {\n-        Definition::Local(l) => l\n-            .associated_locals(sema.db)\n-            .iter()\n-            .try_for_each(|&local| insert_def_edit(Definition::Local(local))),\n-        def => insert_def_edit(def),\n-    }?;\n+    insert_def_edit(def)?;\n     Ok(source_change)\n }\n \n@@ -471,59 +459,64 @@ fn source_edit_from_def(\n     def: Definition,\n     new_name: &str,\n ) -> Result<(FileId, TextEdit)> {\n-    let FileRange { file_id, range } = def\n-        .range_for_rename(sema)\n-        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-\n     let mut edit = TextEdit::builder();\n     if let Definition::Local(local) = def {\n-        if let Either::Left(pat) = local.source(sema.db).value {\n-            // special cases required for renaming fields/locals in Record patterns\n-            if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+        let mut file_id = None;\n+        for source in local.sources(sema.db) {\n+            let source = source.source;\n+            file_id = source.file_id.file_id();\n+            if let Either::Left(pat) = source.value {\n                 let name_range = pat.name().unwrap().syntax().text_range();\n-                if let Some(name_ref) = pat_field.name_ref() {\n-                    if new_name == name_ref.text() && pat.at_token().is_none() {\n-                        // Foo { field: ref mut local } -> Foo { ref mut field }\n-                        //       ^^^^^^ delete this\n-                        //                      ^^^^^ replace this with `field`\n-                        cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n-                        edit.delete(\n-                            name_ref\n-                                .syntax()\n-                                .text_range()\n-                                .cover_offset(pat.syntax().text_range().start()),\n-                        );\n-                        edit.replace(name_range, name_ref.text().to_string());\n+                // special cases required for renaming fields/locals in Record patterns\n+                if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+                    if let Some(name_ref) = pat_field.name_ref() {\n+                        if new_name == name_ref.text() && pat.at_token().is_none() {\n+                            // Foo { field: ref mut local } -> Foo { ref mut field }\n+                            //       ^^^^^^ delete this\n+                            //                      ^^^^^ replace this with `field`\n+                            cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n+                            edit.delete(\n+                                name_ref\n+                                    .syntax()\n+                                    .text_range()\n+                                    .cover_offset(pat.syntax().text_range().start()),\n+                            );\n+                            edit.replace(name_range, name_ref.text().to_string());\n+                        } else {\n+                            // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n+                            // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n+                            //                      ^^^^^ replace this with `new_name`\n+                            edit.replace(name_range, new_name.to_string());\n+                        }\n                     } else {\n-                        // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n-                        // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n-                        //                      ^^^^^ replace this with `new_name`\n+                        // Foo { ref mut field } -> Foo { field: ref mut new_name }\n+                        //      ^ insert `field: `\n+                        //               ^^^^^ replace this with `new_name`\n+                        edit.insert(\n+                            pat.syntax().text_range().start(),\n+                            format!(\"{}: \", pat_field.field_name().unwrap()),\n+                        );\n                         edit.replace(name_range, new_name.to_string());\n                     }\n                 } else {\n-                    // Foo { ref mut field } -> Foo { field: ref mut new_name }\n-                    //      ^ insert `field: `\n-                    //               ^^^^^ replace this with `new_name`\n-                    edit.insert(\n-                        pat.syntax().text_range().start(),\n-                        format!(\"{}: \", pat_field.field_name().unwrap()),\n-                    );\n                     edit.replace(name_range, new_name.to_string());\n                 }\n             }\n         }\n+        let Some(file_id) = file_id else { bail!(\"No file available to rename\") };\n+        return Ok((file_id, edit.finish()));\n     }\n-    if edit.is_empty() {\n-        let (range, new_name) = match def {\n-            Definition::GenericParam(hir::GenericParam::LifetimeParam(_))\n-            | Definition::Label(_) => (\n-                TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n-                new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n-            ),\n-            _ => (range, new_name.to_owned()),\n-        };\n-        edit.replace(range, new_name);\n-    }\n+    let FileRange { file_id, range } = def\n+        .range_for_rename(sema)\n+        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+    let (range, new_name) = match def {\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_) => (\n+            TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n+            new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n+        ),\n+        _ => (range, new_name.to_owned()),\n+    };\n+    edit.replace(range, new_name);\n     Ok((file_id, edit.finish()))\n }\n "}, {"sha": "6298ea1927d1fda6966fbd2263d1c130025716d9", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -320,7 +320,7 @@ impl Definition {\n             scope: None,\n             include_self_kw_refs: None,\n             local_repr: match self {\n-                Definition::Local(local) => Some(local.representative(sema.db)),\n+                Definition::Local(local) => Some(local),\n                 _ => None,\n             },\n             search_self_mod: false,\n@@ -646,7 +646,7 @@ impl<'a> FindUsages<'a> {\n         match NameRefClass::classify(self.sema, name_ref) {\n             Some(NameRefClass::Definition(def @ Definition::Local(local)))\n                 if matches!(\n-                    self.local_repr, Some(repr) if repr == local.representative(self.sema.db)\n+                    self.local_repr, Some(repr) if repr == local\n                 ) =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n@@ -707,7 +707,7 @@ impl<'a> FindUsages<'a> {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local.representative(self.sema.db)) => {\n+                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local) => {\n                         ReferenceCategory::new(&Definition::Local(local), name_ref)\n                     }\n                     _ => return false,\n@@ -755,7 +755,7 @@ impl<'a> FindUsages<'a> {\n             Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n                 if matches!(\n                     self.local_repr,\n-                    Some(repr) if local.representative(self.sema.db) == repr\n+                    Some(repr) if local == repr\n                 ) {\n                     let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n                     let reference = FileReference {"}, {"sha": "d88ffd25c40fe008bf3cee63c2e15e15afba7583", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n     SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n-use crate::{references, NavigationTarget, TryToNav};\n+use crate::{navigation_target::ToNav, references, NavigationTarget, TryToNav};\n \n #[derive(PartialEq, Eq, Hash)]\n pub struct HighlightedRange {\n@@ -98,32 +98,39 @@ fn highlight_references(\n             category: access,\n         });\n     let mut res = FxHashSet::default();\n-\n-    let mut def_to_hl_range = |def| {\n-        let hl_range = match def {\n-            Definition::Module(module) => {\n-                Some(NavigationTarget::from_module_to_decl(sema.db, module))\n-            }\n-            def => def.try_to_nav(sema.db),\n-        }\n-        .filter(|decl| decl.file_id == file_id)\n-        .and_then(|decl| decl.focus_range)\n-        .map(|range| {\n-            let category =\n-                references::decl_mutability(&def, node, range).then_some(ReferenceCategory::Write);\n-            HighlightedRange { range, category }\n-        });\n-        if let Some(hl_range) = hl_range {\n-            res.insert(hl_range);\n-        }\n-    };\n     for &def in &defs {\n         match def {\n-            Definition::Local(local) => local\n-                .associated_locals(sema.db)\n-                .iter()\n-                .for_each(|&local| def_to_hl_range(Definition::Local(local))),\n-            def => def_to_hl_range(def),\n+            Definition::Local(local) => {\n+                let category = local.is_mut(sema.db).then_some(ReferenceCategory::Write);\n+                local\n+                    .sources(sema.db)\n+                    .into_iter()\n+                    .map(|x| x.to_nav(sema.db))\n+                    .filter(|decl| decl.file_id == file_id)\n+                    .filter_map(|decl| decl.focus_range)\n+                    .map(|range| HighlightedRange { range, category })\n+                    .for_each(|x| {\n+                        res.insert(x);\n+                    });\n+            }\n+            def => {\n+                let hl_range = match def {\n+                    Definition::Module(module) => {\n+                        Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+                    }\n+                    def => def.try_to_nav(sema.db),\n+                }\n+                .filter(|decl| decl.file_id == file_id)\n+                .and_then(|decl| decl.focus_range)\n+                .map(|range| {\n+                    let category = references::decl_mutability(&def, node, range)\n+                        .then_some(ReferenceCategory::Write);\n+                    HighlightedRange { range, category }\n+                });\n+                if let Some(hl_range) = hl_range {\n+                    res.insert(hl_range);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "da725ce502b8da62348946ab08242c6405de24f2", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -635,8 +635,8 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n     let ty = it.ty(db);\n     let ty = ty.display_truncated(db, None);\n     let is_mut = if it.is_mut(db) { \"mut \" } else { \"\" };\n-    let desc = match it.source(db).value {\n-        Either::Left(ident) => {\n+    let desc = match it.primary_source(db).into_ident_pat() {\n+        Some(ident) => {\n             let name = it.name(db);\n             let let_kw = if ident\n                 .syntax()\n@@ -649,7 +649,7 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n             };\n             format!(\"{let_kw}{is_mut}{name}: {ty}\")\n         }\n-        Either::Right(_) => format!(\"{is_mut}self: {ty}\"),\n+        None => format!(\"{is_mut}self: {ty}\"),\n     };\n     markup(None, desc, None)\n }"}, {"sha": "6aae82f98160025169032477e7ad1a648697960e", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ad6a96ad1019930294e754e72f627978e85787/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=61ad6a96ad1019930294e754e72f627978e85787", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use either::Either;\n use hir::{\n     symbols::FileSymbol, AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay,\n-    InFile, ModuleSource, Semantics,\n+    InFile, LocalSource, ModuleSource, Semantics,\n };\n use ide_db::{\n     base_db::{FileId, FileRange},\n@@ -387,9 +387,11 @@ impl TryToNav for hir::GenericParam {\n     }\n }\n \n-impl ToNav for hir::Local {\n+impl ToNav for LocalSource {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let InFile { file_id, value } = self.source(db);\n+        let InFile { file_id, value } = &self.source;\n+        let file_id = *file_id;\n+        let local = self.local;\n         let (node, name) = match &value {\n             Either::Left(bind_pat) => (bind_pat.syntax(), bind_pat.name()),\n             Either::Right(it) => (it.syntax(), it.name()),\n@@ -398,10 +400,10 @@ impl ToNav for hir::Local {\n         let FileRange { file_id, range: full_range } =\n             InFile::new(file_id, node).original_file_range(db);\n \n-        let name = self.name(db).to_smol_str();\n-        let kind = if self.is_self(db) {\n+        let name = local.name(db).to_smol_str();\n+        let kind = if local.is_self(db) {\n             SymbolKind::SelfParam\n-        } else if self.is_param(db) {\n+        } else if local.is_param(db) {\n             SymbolKind::ValueParam\n         } else {\n             SymbolKind::Local\n@@ -419,6 +421,12 @@ impl ToNav for hir::Local {\n     }\n }\n \n+impl ToNav for hir::Local {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        self.primary_source(db).to_nav(db)\n+    }\n+}\n+\n impl ToNav for hir::Label {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let InFile { file_id, value } = self.source(db);"}]}