{"sha": "cac7524c1aa63961973e3607d72a49dfccb09448", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYzc1MjRjMWFhNjM5NjE5NzNlMzYwN2Q3MmE0OWRmY2NiMDk0NDg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T18:59:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T18:59:10Z"}, "message": "rustc: Remove all manual type construction outside ty.rs", "tree": {"sha": "1412cd27f95bafd462485fd11e37eba11778f59a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1412cd27f95bafd462485fd11e37eba11778f59a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cac7524c1aa63961973e3607d72a49dfccb09448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cac7524c1aa63961973e3607d72a49dfccb09448", "html_url": "https://github.com/rust-lang/rust/commit/cac7524c1aa63961973e3607d72a49dfccb09448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cac7524c1aa63961973e3607d72a49dfccb09448/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e842244c33ced2bc248a0b0911b507336829c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e842244c33ced2bc248a0b0911b507336829c9", "html_url": "https://github.com/rust-lang/rust/commit/38e842244c33ced2bc248a0b0911b507336829c9"}], "stats": {"total": 208, "additions": 107, "deletions": 101}, "files": [{"sha": "2490613ae9cf86d7aee8bbd589cd90e8bce02d1a", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=cac7524c1aa63961973e3607d72a49dfccb09448", "patch": "@@ -75,52 +75,28 @@ fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n }\n \n fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n-    ret @rec(struct=parse_sty(st, sd),\n-             cname=option.none[str]);\n-}\n-\n-fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n-    auto mut;\n-    alt (peek(st) as char) {\n-        case ('m') {next(st); mut = ast.mut;}\n-        case ('?') {next(st); mut = ast.maybe_mut;}\n-        case (_)   {mut=ast.imm;}\n-    }\n-    ret rec(ty=parse_ty(st, sd), mut=mut);\n-}\n-\n-fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n-    auto def = \"\";\n-    while (peek(st) as char != '|') {\n-        def += _str.unsafe_from_byte(next(st));\n-    }\n-    st.pos = st.pos + 1u;\n-    ret sd(def);\n-}\n-\n-fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n     alt (next(st) as char) {\n-        case ('n') {ret ty.ty_nil;}\n-        case ('b') {ret ty.ty_bool;}\n-        case ('i') {ret ty.ty_int;}\n-        case ('u') {ret ty.ty_uint;}\n-        case ('l') {ret ty.ty_float;}\n+        case ('n') { ret ty.mk_nil(); }\n+        case ('b') { ret ty.mk_bool(); }\n+        case ('i') { ret ty.mk_int(); }\n+        case ('u') { ret ty.mk_uint(); }\n+        case ('l') { ret ty.mk_float(); }\n         case ('M') {\n             alt (next(st) as char) {\n-                case ('b') {ret ty.ty_machine(common.ty_u8);}\n-                case ('w') {ret ty.ty_machine(common.ty_u16);}\n-                case ('l') {ret ty.ty_machine(common.ty_u32);}\n-                case ('d') {ret ty.ty_machine(common.ty_u64);}\n-                case ('B') {ret ty.ty_machine(common.ty_i8);}\n-                case ('W') {ret ty.ty_machine(common.ty_i16);}\n-                case ('L') {ret ty.ty_machine(common.ty_i32);}\n-                case ('D') {ret ty.ty_machine(common.ty_i64);}\n-                case ('f') {ret ty.ty_machine(common.ty_f32);}\n-                case ('F') {ret ty.ty_machine(common.ty_f64);}\n+                case ('b') { ret ty.mk_mach(common.ty_u8); }\n+                case ('w') { ret ty.mk_mach(common.ty_u16); }\n+                case ('l') { ret ty.mk_mach(common.ty_u32); }\n+                case ('d') { ret ty.mk_mach(common.ty_u64); }\n+                case ('B') { ret ty.mk_mach(common.ty_i8); }\n+                case ('W') { ret ty.mk_mach(common.ty_i16); }\n+                case ('L') { ret ty.mk_mach(common.ty_i32); }\n+                case ('D') { ret ty.mk_mach(common.ty_i64); }\n+                case ('f') { ret ty.mk_mach(common.ty_f32); }\n+                case ('F') { ret ty.mk_mach(common.ty_f64); }\n             }\n         }\n-        case ('c') {ret ty.ty_char;}\n-        case ('s') {ret ty.ty_str;}\n+        case ('c') { ret ty.mk_char(); }\n+        case ('s') { ret ty.mk_str(); }\n         case ('t') {\n             check(next(st) as char == '[');\n             auto def = parse_def(st, sd);\n@@ -129,21 +105,21 @@ fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n                 params += vec(parse_ty(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.ty_tag(def, params);\n+            ret ty.mk_tag(def, params);\n         }\n-        case ('p') {ret ty.ty_param(parse_int(st) as uint);}\n-        case ('@') {ret ty.ty_box(parse_mt(st, sd));}\n-        case ('V') {ret ty.ty_vec(parse_mt(st, sd));}\n-        case ('P') {ret ty.ty_port(parse_ty(st, sd));}\n-        case ('C') {ret ty.ty_chan(parse_ty(st, sd));}\n+        case ('p') { ret ty.mk_param(parse_int(st) as uint); }\n+        case ('@') { ret ty.mk_box(parse_mt(st, sd)); }\n+        case ('V') { ret ty.mk_vec(parse_mt(st, sd)); }\n+        case ('P') { ret ty.mk_port(parse_ty(st, sd)); }\n+        case ('C') { ret ty.mk_chan(parse_ty(st, sd)); }\n         case ('T') {\n             check(next(st) as char == '[');\n             let vec[ty.mt] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_mt(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.ty_tup(params);\n+            ret ty.mk_tup(params);\n         }\n         case ('R') {\n             check(next(st) as char == '[');\n@@ -157,15 +133,15 @@ fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n                 fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.ty_rec(fields);\n+            ret ty.mk_rec(fields);\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.ty_fn(ast.proto_fn, func._0, func._1);\n+            ret ty.mk_fn(ast.proto_fn, func._0, func._1);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.ty_fn(ast.proto_iter, func._0, func._1);\n+            ret ty.mk_fn(ast.proto_iter, func._0, func._1);\n         }\n         case ('N') {\n             auto abi;\n@@ -175,7 +151,7 @@ fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n                 case ('l') {abi = ast.native_abi_llvm;}\n             }\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.ty_native_fn(abi,func._0,func._1);\n+            ret ty.mk_native_fn(abi,func._0,func._1);\n         }\n         case ('O') {\n             check(next(st) as char == '[');\n@@ -197,12 +173,31 @@ fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n                                    output=func._1));\n             }\n             st.pos += 1u;\n-            ret ty.ty_obj(methods);\n+            ret ty.mk_obj(methods);\n         }\n-        case ('X') {ret ty.ty_var(parse_int(st));}\n-        case ('E') {ret ty.ty_native;}\n-        case ('Y') {ret ty.ty_type;}\n+        case ('X') { ret ty.mk_var(parse_int(st)); }\n+        case ('E') { ret ty.mk_native(); }\n+        case ('Y') { ret ty.mk_type(); }\n+    }\n+}\n+\n+fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n+    auto mut;\n+    alt (peek(st) as char) {\n+        case ('m') {next(st); mut = ast.mut;}\n+        case ('?') {next(st); mut = ast.maybe_mut;}\n+        case (_)   {mut=ast.imm;}\n     }\n+    ret rec(ty=parse_ty(st, sd), mut=mut);\n+}\n+\n+fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n+    auto def = \"\";\n+    while (peek(st) as char != '|') {\n+        def += _str.unsafe_from_byte(next(st));\n+    }\n+    st.pos = st.pos + 1u;\n+    ret sd(def);\n }\n \n fn parse_int(@pstate st) -> int {"}, {"sha": "439e563ebac5d62954da12c949d02957fba6fbd4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cac7524c1aa63961973e3607d72a49dfccb09448", "patch": "@@ -2843,12 +2843,12 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     alt (t.struct) {\n         case (ty.ty_int) {\n-            auto tm = ty.ty_machine(cx.sess.get_targ_cfg().int_type);\n-            ret @rec(struct=tm with *t);\n+            auto struct_ty = ty.mk_mach(cx.sess.get_targ_cfg().int_type);\n+            ret ty.copy_cname(struct_ty, t);\n         }\n         case (ty.ty_uint) {\n-            auto tm = ty.ty_machine(cx.sess.get_targ_cfg().uint_type);\n-            ret @rec(struct=tm with *t);\n+            auto struct_ty = ty.mk_mach(cx.sess.get_targ_cfg().uint_type);\n+            ret ty.copy_cname(struct_ty, t);\n         }\n         case (_) { /* fall through */ }\n     }"}, {"sha": "df85ed27331e1f2d62a83edcc852969bdb6c6b63", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=cac7524c1aa63961973e3607d72a49dfccb09448", "patch": "@@ -386,10 +386,6 @@ fn walk_ty(ty_walk walker, @t ty) {\n type ty_fold = fn(@t) -> @t;\n \n fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n-    fn rewrap(@t orig, &sty new) -> @t {\n-        ret @rec(struct=new, cname=orig.cname);\n-    }\n-\n     auto ty = ty_0;\n     alt (ty.struct) {\n         case (ty_nil)           { /* no-op */ }\n@@ -403,31 +399,33 @@ fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n         case (ty_type)          { /* no-op */ }\n         case (ty_native)        { /* no-op */ }\n         case (ty_box(?tm)) {\n-            ty = rewrap(ty, ty_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n+            ty = copy_cname(mk_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)),\n+                            ty);\n         }\n         case (ty_vec(?tm)) {\n-            ty = rewrap(ty, ty_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n+            ty = copy_cname(mk_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)),\n+                            ty);\n         }\n         case (ty_port(?subty)) {\n-            ty = rewrap(ty, ty_port(fold_ty(fld, subty)));\n+            ty = copy_cname(mk_port(fold_ty(fld, subty)), ty);\n         }\n         case (ty_chan(?subty)) {\n-            ty = rewrap(ty, ty_chan(fold_ty(fld, subty)));\n+            ty = copy_cname(mk_chan(fold_ty(fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n             let vec[@t] new_subtys = vec();\n             for (@t subty in subtys) {\n                 new_subtys += vec(fold_ty(fld, subty));\n             }\n-            ty = rewrap(ty, ty_tag(tid, new_subtys));\n+            ty = copy_cname(mk_tag(tid, new_subtys), ty);\n         }\n         case (ty_tup(?mts)) {\n             let vec[mt] new_mts = vec();\n             for (mt tm in mts) {\n                 auto new_subty = fold_ty(fld, tm.ty);\n                 new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ty = rewrap(ty, ty_tup(new_mts));\n+            ty = copy_cname(mk_tup(new_mts), ty);\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n@@ -436,24 +434,24 @@ fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n                 new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n-            ty = rewrap(ty, ty_rec(new_fields));\n+            ty = copy_cname(mk_rec(new_fields), ty);\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = rewrap(ty, ty_fn(proto, new_args, fold_ty(fld, ret_ty)));\n+            ty = copy_cname(mk_fn(proto, new_args, fold_ty(fld, ret_ty)), ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = rewrap(ty, ty_native_fn(abi, new_args,\n-                                         fold_ty(fld, ret_ty)));\n+            ty = copy_cname(mk_native_fn(abi, new_args, fold_ty(fld, ret_ty)),\n+                            ty);\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n@@ -466,7 +464,7 @@ fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n                                        inputs=new_args,\n                                        output=fold_ty(fld, m.output)));\n             }\n-            ty = rewrap(ty, ty_obj(new_methods));\n+            ty = copy_cname(mk_obj(new_methods), ty);\n         }\n         case (ty_var(_))         { /* no-op */ }\n         case (ty_local(_))       { /* no-op */ }\n@@ -479,6 +477,16 @@ fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n \n // Type utilities\n \n+fn rename(@t typ, str new_cname) -> @t {\n+    ret @rec(struct=typ.struct, cname=some[str](new_cname));\n+}\n+\n+// Returns a type with the structural part taken from `struct_ty` and the\n+// canonical name from `cname_ty`.\n+fn copy_cname(@t struct_ty, @t cname_ty) -> @t {\n+    ret @rec(struct=struct_ty.struct, cname=cname_ty.cname);\n+}\n+\n // FIXME: remove me when == works on these tags.\n fn mode_is_alias(ast.mode m) -> bool {\n     alt (m) {"}, {"sha": "a7213b68cc5f0e819362abd0179cee107f653615", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7524c1aa63961973e3607d72a49dfccb09448/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cac7524c1aa63961973e3607d72a49dfccb09448", "patch": "@@ -226,63 +226,63 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n     }\n \n     auto mut = ast.imm;\n-    auto sty;\n+    auto typ;\n     auto cname = none[str];\n     alt (ast_ty.node) {\n-        case (ast.ty_nil)          { sty = ty.ty_nil; }\n-        case (ast.ty_bool)         { sty = ty.ty_bool; }\n-        case (ast.ty_int)          { sty = ty.ty_int; }\n-        case (ast.ty_uint)         { sty = ty.ty_uint; }\n-        case (ast.ty_float)        { sty = ty.ty_float; }\n-        case (ast.ty_machine(?tm)) { sty = ty.ty_machine(tm); }\n-        case (ast.ty_char)         { sty = ty.ty_char; }\n-        case (ast.ty_str)          { sty = ty.ty_str; }\n-        case (ast.ty_box(?mt)) { sty = ty.ty_box(ast_mt_to_mt(getter, mt)); }\n-        case (ast.ty_vec(?mt)) { sty = ty.ty_vec(ast_mt_to_mt(getter, mt)); }\n+        case (ast.ty_nil)          { typ = ty.mk_nil(); }\n+        case (ast.ty_bool)         { typ = ty.mk_bool(); }\n+        case (ast.ty_int)          { typ = ty.mk_int(); }\n+        case (ast.ty_uint)         { typ = ty.mk_uint(); }\n+        case (ast.ty_float)        { typ = ty.mk_float(); }\n+        case (ast.ty_machine(?tm)) { typ = ty.mk_mach(tm); }\n+        case (ast.ty_char)         { typ = ty.mk_char(); }\n+        case (ast.ty_str)          { typ = ty.mk_str(); }\n+        case (ast.ty_box(?mt)) { typ = ty.mk_box(ast_mt_to_mt(getter, mt)); }\n+        case (ast.ty_vec(?mt)) { typ = ty.mk_vec(ast_mt_to_mt(getter, mt)); }\n \n         case (ast.ty_port(?t)) {\n-            sty = ty.ty_port(ast_ty_to_ty(getter, t));\n+            typ = ty.mk_port(ast_ty_to_ty(getter, t));\n         }\n \n         case (ast.ty_chan(?t)) {\n-            sty = ty.ty_chan(ast_ty_to_ty(getter, t));\n+            typ = ty.mk_chan(ast_ty_to_ty(getter, t));\n         }\n \n         case (ast.ty_tup(?fields)) {\n             let vec[ty.mt] flds = vec();\n             for (ast.mt field in fields) {\n                 _vec.push[ty.mt](flds, ast_mt_to_mt(getter, field));\n             }\n-            sty = ty.ty_tup(flds);\n+            typ = ty.mk_tup(flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n                 _vec.push[field](flds, rec(ident=f.ident,\n                                         mt=ast_mt_to_mt(getter, f.mt)));\n             }\n-            sty = ty.ty_rec(flds);\n+            typ = ty.mk_rec(flds);\n         }\n \n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(getter, _);\n             auto i = _vec.map[ast.ty_arg, arg](f, inputs);\n-            sty = ty.ty_fn(proto, i, ast_ty_to_ty(getter, output));\n+            typ = ty.mk_fn(proto, i, ast_ty_to_ty(getter, output));\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n             check (def != none[ast.def]);\n             alt (option.get[ast.def](def)) {\n                 case (ast.def_ty(?id)) {\n-                    sty = instantiate(getter, id, path.node.types).struct;\n+                    typ = instantiate(getter, id, path.node.types);\n                 }\n                 case (ast.def_native_ty(?id)) {\n-                    sty = getter(id)._1.struct;\n+                    typ = getter(id)._1;\n                 }\n                 case (ast.def_obj(?id))     {\n-                    sty = instantiate(getter, id, path.node.types).struct;\n+                    typ = instantiate(getter, id, path.node.types);\n                 }\n-                case (ast.def_ty_arg(?id))  { sty = ty.ty_param(id); }\n+                case (ast.def_ty_arg(?id))  { typ = ty.mk_param(id); }\n                 case (_)                    { fail; }\n             }\n \n@@ -302,11 +302,14 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n                                       output=out));\n             }\n \n-            sty = ty.ty_obj(ty.sort_methods(tmeths));\n+            typ = ty.mk_obj(ty.sort_methods(tmeths));\n         }\n     }\n \n-    auto typ = @rec(struct=sty, cname=cname);\n+    alt (cname) {\n+        case (none[str]) { /* no-op */ }\n+        case (some[str](?cname_str)) { typ = ty.rename(typ, cname_str); }\n+    }\n     ret typ;\n }\n \n@@ -427,8 +430,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto methods =\n             _vec.map[@ast.method,method](f, obj_info.methods);\n \n-        auto t_obj = @rec(struct=ty.ty_obj(ty.sort_methods(methods)),\n-                          cname=some[str](id));\n+        auto t_obj = ty.mk_obj(ty.sort_methods(methods));\n+        t_obj = ty.rename(t_obj, id);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n     }\n@@ -547,7 +550,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     ret type_cache.get(def_id);\n                 }\n \n-                auto t = @rec(struct=ty.ty_native, cname=none[str]);\n+                auto t = ty.mk_native();\n                 auto tpt = tup(0u, t);\n                 type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -769,7 +772,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         alt (ob.dtor) {\n             case (some[@ast.method](?d)) {\n                 let vec[arg] inputs = vec();\n-                let @ty.t output = @rec(struct=ty.ty_nil, cname=none[str]);\n+                let @ty.t output = ty.mk_nil();\n                 auto dtor_tfn = ty.mk_fn(ast.proto_fn, inputs, output);\n                 auto d_ = rec(ann=triv_ann(dtor_tfn) with d.node);\n                 dtor = some[@ast.method](@rec(node=d_ with *d));"}]}