{"sha": "34e5a4992c920ce9e68c333621f3d4c967c012c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZTVhNDk5MmM5MjBjZTllNjhjMzMzNjIxZjNkNGM5NjdjMDEyYzQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-07-24T18:10:22Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:31Z"}, "message": "Normalize projection bounds when considering candidates\n\nThis unfortunately requires some winnowing hacks to avoid\nnow ambiguous candidates.", "tree": {"sha": "b8affedfce34f245b6205a54a044a8b86f2fb8af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8affedfce34f245b6205a54a044a8b86f2fb8af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34e5a4992c920ce9e68c333621f3d4c967c012c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34e5a4992c920ce9e68c333621f3d4c967c012c4", "html_url": "https://github.com/rust-lang/rust/commit/34e5a4992c920ce9e68c333621f3d4c967c012c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34e5a4992c920ce9e68c333621f3d4c967c012c4/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfee49593d756bb97018d1d2ac194e0821d2dfca", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfee49593d756bb97018d1d2ac194e0821d2dfca", "html_url": "https://github.com/rust-lang/rust/commit/cfee49593d756bb97018d1d2ac194e0821d2dfca"}], "stats": {"total": 646, "additions": 390, "deletions": 256}, "files": [{"sha": "d52e54191006a7bd32c01d331fa258641b6972d2", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -884,6 +884,7 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n         candidate_set,\n         ProjectionTyCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n+        false,\n     );\n }\n \n@@ -927,6 +928,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         candidate_set,\n         ProjectionTyCandidate::TraitDef,\n         bounds.iter(),\n+        true,\n     )\n }\n \n@@ -937,6 +939,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n+    potentially_unnormalized_candidates: bool,\n ) {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\", obligation);\n     let infcx = selcx.infcx();\n@@ -948,16 +951,12 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n \n             let is_match = same_def_id\n                 && infcx.probe(|_| {\n-                    let data_poly_trait_ref = data.to_poly_trait_ref(infcx.tcx);\n-                    let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-                    infcx\n-                        .at(&obligation.cause, obligation.param_env)\n-                        .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                        .map(|InferOk { obligations: _, value: () }| {\n-                            // FIXME(#32730) -- do we need to take obligations\n-                            // into account in any way? At the moment, no.\n-                        })\n-                        .is_ok()\n+                    selcx.match_projection_projections(\n+                        obligation,\n+                        obligation_trait_ref,\n+                        &data,\n+                        potentially_unnormalized_candidates,\n+                    )\n                 });\n \n             debug!(\n@@ -1157,9 +1156,12 @@ fn confirm_candidate<'cx, 'tcx>(\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\", candidate, obligation);\n \n     let mut progress = match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection)\n-        | ProjectionTyCandidate::TraitDef(poly_projection) => {\n-            confirm_param_env_candidate(selcx, obligation, poly_projection)\n+        ProjectionTyCandidate::ParamEnv(poly_projection) => {\n+            confirm_param_env_candidate(selcx, obligation, poly_projection, false)\n+        }\n+\n+        ProjectionTyCandidate::TraitDef(poly_projection) => {\n+            confirm_param_env_candidate(selcx, obligation, poly_projection, true)\n         }\n \n         ProjectionTyCandidate::Select(impl_source) => {\n@@ -1272,7 +1274,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n         }\n     };\n \n-    confirm_param_env_candidate(selcx, obligation, env_predicate)\n+    confirm_param_env_candidate(selcx, obligation, env_predicate, false)\n }\n \n fn confirm_generator_candidate<'cx, 'tcx>(\n@@ -1323,7 +1325,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         }\n     });\n \n-    confirm_param_env_candidate(selcx, obligation, predicate)\n+    confirm_param_env_candidate(selcx, obligation, predicate, false)\n         .with_addl_obligations(impl_source.nested)\n         .with_addl_obligations(obligations)\n }\n@@ -1345,7 +1347,7 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n         ty: self_ty.discriminant_ty(tcx),\n     };\n \n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate))\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate), false)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n@@ -1420,13 +1422,14 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n         ty: ret_type,\n     });\n \n-    confirm_param_env_candidate(selcx, obligation, predicate)\n+    confirm_param_env_candidate(selcx, obligation, predicate, false)\n }\n \n fn confirm_param_env_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n+    potentially_unnormalized_candidate: bool,\n ) -> Progress<'tcx> {\n     let infcx = selcx.infcx();\n     let cause = &obligation.cause;\n@@ -1440,8 +1443,27 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n \n     let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n     let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    let mut nested_obligations = Vec::new();\n+    let cache_trait_ref = if potentially_unnormalized_candidate {\n+        ensure_sufficient_stack(|| {\n+            normalize_with_depth_to(\n+                selcx,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &cache_trait_ref,\n+                &mut nested_obligations,\n+            )\n+        })\n+    } else {\n+        cache_trait_ref\n+    };\n+\n     match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n-        Ok(InferOk { value: _, obligations }) => Progress { ty: cache_entry.ty, obligations },\n+        Ok(InferOk { value: _, obligations }) => {\n+            nested_obligations.extend(obligations);\n+            Progress { ty: cache_entry.ty, obligations: nested_obligations }\n+        }\n         Err(e) => {\n             let msg = format!(\n                 \"Failed to unify obligation `{:?}` with poly_projection `{:?}`: {:?}\","}, {"sha": "e6fce78f269ca7a297a27f41667d50d5ff5c1fa1", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -137,18 +137,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let candidate = candidate_predicate\n                 .to_opt_poly_trait_ref()\n                 .expect(\"projection candidate is not a trait predicate\");\n-            let mut obligations = self\n-                .infcx\n-                .at(&obligation.cause, obligation.param_env)\n-                .sup(obligation.predicate.to_poly_trait_ref(), candidate)\n-                .map(|InferOk { obligations, .. }| obligations)\n-                .unwrap_or_else(|_| {\n-                    bug!(\n-                        \"Projection bound `{:?}` was applicable to `{:?}` but now is not\",\n-                        candidate,\n-                        obligation\n-                    );\n-                });\n+            let Normalized { value: candidate, mut obligations } = normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &candidate,\n+            );\n+\n+            obligations.extend(\n+                self.infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .sup(obligation.predicate.to_poly_trait_ref(), candidate)\n+                    .map(|InferOk { obligations, .. }| obligations)\n+                    .unwrap_or_else(|_| {\n+                        bug!(\n+                            \"Projection bound `{:?}` was applicable to `{:?}` but now is not\",\n+                            candidate,\n+                            obligation\n+                        );\n+                    }),\n+            );\n             // Require that the projection is well-formed.\n             let self_ty = self.infcx.replace_bound_vars_with_placeholders(&bound_self_ty);\n             let self_ty = normalize_with_depth_to("}, {"sha": "147b0c74d16e8d77d6de3282db79a75d26079a5b", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 209, "deletions": 127, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -9,6 +9,7 @@ use super::coherence::{self, Conflict};\n use super::const_evaluatable;\n use super::project;\n use super::project::normalize_with_depth_to;\n+use super::project::ProjectionTyObligation;\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n@@ -36,9 +37,8 @@ use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{\n-    self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n+use rustc_middle::ty::{self, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -946,10 +946,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// to have a *lower* recursion_depth than the obligation used to create it.\n     /// Projection sub-obligations may be returned from the projection cache,\n     /// which results in obligations with an 'old' `recursion_depth`.\n-    /// Additionally, methods like `wf::obligations` and\n-    /// `InferCtxt.subtype_predicate` produce subobligations without\n-    /// taking in a 'parent' depth, causing the generated subobligations\n-    /// to have a `recursion_depth` of `0`.\n+    /// Additionally, methods like `InferCtxt.subtype_predicate` produce\n+    /// subobligations without taking in a 'parent' depth, causing the\n+    /// generated subobligations to have a `recursion_depth` of `0`.\n     ///\n     /// To ensure that obligation_depth never decreasees, we force all subobligations\n     /// to have at least the depth of the original obligation.\n@@ -1229,10 +1228,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         placeholder_trait_ref: ty::TraitRef<'tcx>,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         debug_assert!(!placeholder_trait_ref.has_escaping_bound_vars());\n+        if placeholder_trait_ref.def_id != trait_bound.def_id() {\n+            // Avoid unnecessary normalization\n+            return Err(());\n+        }\n+\n+        let Normalized { value: trait_bound, obligations: mut nested_obligations } =\n+            ensure_sufficient_stack(|| {\n+                project::normalize_with_depth(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &trait_bound,\n+                )\n+            });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n-            .map(|InferOk { obligations, .. }| obligations)\n+            .map(|InferOk { obligations, .. }| {\n+                nested_obligations.extend(obligations);\n+                nested_obligations\n+            })\n             .map_err(|_| ())\n     }\n \n@@ -1249,6 +1266,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n+    pub(super) fn match_projection_projections(\n+        &mut self,\n+        obligation: &ProjectionTyObligation<'tcx>,\n+        obligation_trait_ref: &ty::TraitRef<'tcx>,\n+        data: &PolyProjectionPredicate<'tcx>,\n+        potentially_unnormalized_candidates: bool,\n+    ) -> bool {\n+        let mut nested_obligations = Vec::new();\n+        let projection_ty = if potentially_unnormalized_candidates {\n+            ensure_sufficient_stack(|| {\n+                project::normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &data.map_bound_ref(|data| data.projection_ty),\n+                    &mut nested_obligations,\n+                )\n+            })\n+        } else {\n+            data.map_bound_ref(|data| data.projection_ty)\n+        };\n+\n+        // FIXME(generic_associated_types): Compare the whole projections\n+        let data_poly_trait_ref = projection_ty.map_bound(|proj| proj.trait_ref(self.tcx()));\n+        let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+        self.infcx\n+            .at(&obligation.cause, obligation.param_env)\n+            .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+            .map_or(false, |InferOk { obligations, value: () }| {\n+                self.evaluate_predicates_recursively(\n+                    TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n+                    nested_obligations.into_iter().chain(obligations),\n+                )\n+                .map_or(false, |res| res.may_apply())\n+            })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1283,147 +1338,174 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //\n         // This is a fix for #53123 and prevents winnowing from accidentally extending the\n         // lifetime of a variable.\n-        match other.candidate {\n+        match (&other.candidate, &victim.candidate) {\n+            (_, AutoImplCandidate(..)) | (AutoImplCandidate(..), _) => {\n+                bug!(\n+                    \"default implementations shouldn't be recorded \\\n+                    when there are other valid candidates\"\n+                );\n+            }\n+\n             // (*)\n-            BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => true,\n-            ParamCandidate(ref cand) => match victim.candidate {\n-                AutoImplCandidate(..) => {\n-                    bug!(\n-                        \"default implementations shouldn't be recorded \\\n-                         when there are other valid candidates\"\n-                    );\n-                }\n-                // (*)\n-                BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => false,\n+            (BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate, _) => true,\n+            (_, BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate) => false,\n+\n+            (ParamCandidate(..), ParamCandidate(..)) => false,\n+\n+            // Global bounds from the where clause should be ignored\n+            // here (see issue #50825). Otherwise, we have a where\n+            // clause so don't go around looking for impls.\n+            // Arbitrarily give param candidates priority\n+            // over projection and object candidates.\n+            (\n+                ParamCandidate(ref cand),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n-                | TraitAliasCandidate(..) => {\n-                    // Global bounds from the where clause should be ignored\n-                    // here (see issue #50825). Otherwise, we have a where\n-                    // clause so don't go around looking for impls.\n-                    !is_global(cand)\n-                }\n-                ObjectCandidate | ProjectionCandidate(_) => {\n-                    // Arbitrarily give param candidates priority\n-                    // over projection and object candidates.\n-                    !is_global(cand)\n-                }\n-                ParamCandidate(..) => false,\n-            },\n-            ObjectCandidate | ProjectionCandidate(_) => match victim.candidate {\n-                AutoImplCandidate(..) => {\n-                    bug!(\n-                        \"default implementations shouldn't be recorded \\\n-                         when there are other valid candidates\"\n-                    );\n-                }\n-                // (*)\n-                BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => false,\n+                | TraitAliasCandidate(..)\n+                | ObjectCandidate\n+                | ProjectionCandidate(_),\n+            ) => !is_global(cand),\n+            (ObjectCandidate | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n+                // Prefer these to a global where-clause bound\n+                // (see issue #50825).\n+                is_global(cand)\n+            }\n+            (\n+                ImplCandidate(_)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { has_nested: true }\n+                | TraitAliasCandidate(..),\n+                ParamCandidate(ref cand),\n+            ) => {\n+                // Prefer these to a global where-clause bound\n+                // (see issue #50825).\n+                is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+            }\n+\n+            (ProjectionCandidate(i), ProjectionCandidate(j)) => {\n+                // Arbitrarily pick the first candidate for backwards\n+                // compatibility reasons. Don't let this affect inference.\n+                i > j && !needs_infer\n+            }\n+            (ObjectCandidate, ObjectCandidate) => bug!(\"Duplicate object candidate\"),\n+            (ObjectCandidate, ProjectionCandidate(_))\n+            | (ProjectionCandidate(_), ObjectCandidate) => {\n+                bug!(\"Have both object and projection candidate\")\n+            }\n+\n+            // Arbitrarily give projection and object candidates priority.\n+            (\n+                ObjectCandidate | ProjectionCandidate(_),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n-                | TraitAliasCandidate(..) => true,\n-                ObjectCandidate | ProjectionCandidate(_) => {\n-                    // Shouldn't have both an object and projection candidate,\n-                    // nor multiple object candidates. Multiple projection\n-                    // candidates are ambiguous.\n-                    false\n-                }\n-                ParamCandidate(ref cand) => is_global(cand),\n-            },\n-            ImplCandidate(other_def) => {\n+                | TraitAliasCandidate(..),\n+            ) => true,\n+\n+            (\n+                ImplCandidate(..)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { .. }\n+                | TraitAliasCandidate(..),\n+                ObjectCandidate | ProjectionCandidate(_),\n+            ) => false,\n+\n+            (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n                 // i.e., `EvaluatedToOk`.\n                 if other.evaluation.must_apply_modulo_regions() {\n-                    match victim.candidate {\n-                        ImplCandidate(victim_def) => {\n-                            let tcx = self.tcx();\n-                            if tcx.specializes((other_def, victim_def)) {\n-                                return true;\n-                            }\n-                            return match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n-                                Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n-                                    // Subtle: If the predicate we are evaluating has inference\n-                                    // variables, do *not* allow discarding candidates due to\n-                                    // marker trait impls.\n-                                    //\n-                                    // Without this restriction, we could end up accidentally\n-                                    // constrainting inference variables based on an arbitrarily\n-                                    // chosen trait impl.\n-                                    //\n-                                    // Imagine we have the following code:\n-                                    //\n-                                    // ```rust\n-                                    // #[marker] trait MyTrait {}\n-                                    // impl MyTrait for u8 {}\n-                                    // impl MyTrait for bool {}\n-                                    // ```\n-                                    //\n-                                    // And we are evaluating the predicate `<_#0t as MyTrait>`.\n-                                    //\n-                                    // During selection, we will end up with one candidate for each\n-                                    // impl of `MyTrait`. If we were to discard one impl in favor\n-                                    // of the other, we would be left with one candidate, causing\n-                                    // us to \"successfully\" select the predicate, unifying\n-                                    // _#0t with (for example) `u8`.\n-                                    //\n-                                    // However, we have no reason to believe that this unification\n-                                    // is correct - we've essentially just picked an arbitrary\n-                                    // *possibility* for _#0t, and required that this be the *only*\n-                                    // possibility.\n-                                    //\n-                                    // Eventually, we will either:\n-                                    // 1) Unify all inference variables in the predicate through\n-                                    // some other means (e.g. type-checking of a function). We will\n-                                    // then be in a position to drop marker trait candidates\n-                                    // without constraining inference variables (since there are\n-                                    // none left to constrin)\n-                                    // 2) Be left with some unconstrained inference variables. We\n-                                    // will then correctly report an inference error, since the\n-                                    // existence of multiple marker trait impls tells us nothing\n-                                    // about which one should actually apply.\n-                                    !needs_infer\n-                                }\n-                                Some(_) => true,\n-                                None => false,\n-                            };\n-                        }\n-                        ParamCandidate(ref cand) => {\n-                            // Prefer the impl to a global where clause candidate.\n-                            return is_global(cand);\n-                        }\n-                        _ => (),\n-                    }\n-                }\n-\n-                false\n-            }\n-            ClosureCandidate\n-            | GeneratorCandidate\n-            | FnPointerCandidate\n-            | BuiltinObjectCandidate\n-            | BuiltinUnsizeCandidate\n-            | BuiltinCandidate { has_nested: true } => {\n-                match victim.candidate {\n-                    ParamCandidate(ref cand) => {\n-                        // Prefer these to a global where-clause bound\n-                        // (see issue #50825).\n-                        is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+                    let tcx = self.tcx();\n+                    if tcx.specializes((other_def, victim_def)) {\n+                        return true;\n                     }\n-                    _ => false,\n+                    return match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n+                        Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n+                            // Subtle: If the predicate we are evaluating has inference\n+                            // variables, do *not* allow discarding candidates due to\n+                            // marker trait impls.\n+                            //\n+                            // Without this restriction, we could end up accidentally\n+                            // constrainting inference variables based on an arbitrarily\n+                            // chosen trait impl.\n+                            //\n+                            // Imagine we have the following code:\n+                            //\n+                            // ```rust\n+                            // #[marker] trait MyTrait {}\n+                            // impl MyTrait for u8 {}\n+                            // impl MyTrait for bool {}\n+                            // ```\n+                            //\n+                            // And we are evaluating the predicate `<_#0t as MyTrait>`.\n+                            //\n+                            // During selection, we will end up with one candidate for each\n+                            // impl of `MyTrait`. If we were to discard one impl in favor\n+                            // of the other, we would be left with one candidate, causing\n+                            // us to \"successfully\" select the predicate, unifying\n+                            // _#0t with (for example) `u8`.\n+                            //\n+                            // However, we have no reason to believe that this unification\n+                            // is correct - we've essentially just picked an arbitrary\n+                            // *possibility* for _#0t, and required that this be the *only*\n+                            // possibility.\n+                            //\n+                            // Eventually, we will either:\n+                            // 1) Unify all inference variables in the predicate through\n+                            // some other means (e.g. type-checking of a function). We will\n+                            // then be in a position to drop marker trait candidates\n+                            // without constraining inference variables (since there are\n+                            // none left to constrin)\n+                            // 2) Be left with some unconstrained inference variables. We\n+                            // will then correctly report an inference error, since the\n+                            // existence of multiple marker trait impls tells us nothing\n+                            // about which one should actually apply.\n+                            !needs_infer\n+                        }\n+                        Some(_) => true,\n+                        None => false,\n+                    };\n+                } else {\n+                    false\n                 }\n             }\n-            _ => false,\n+\n+            // Everything else is ambiguous\n+            (\n+                ImplCandidate(_)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { has_nested: true }\n+                | TraitAliasCandidate(..),\n+                ImplCandidate(_)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { has_nested: true }\n+                | TraitAliasCandidate(..),\n+            ) => false,\n         }\n     }\n "}, {"sha": "8093c4b9d9ec0e40e0edf58df3c04803b0bae17f", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -6,26 +6,25 @@\n use std::fmt::Debug;\n use std::iter::Once;\n \n-trait Lam<Binder> { type App; }\n+trait Lam<Binder> {\n+    type App;\n+}\n \n #[derive(Clone)]\n struct L1;\n-impl<'a> Lam<&'a u8> for L1 { type App = u8; }\n+impl<'a> Lam<&'a u8> for L1 {\n+    type App = u8;\n+}\n \n #[derive(Clone)]\n struct L2;\n-impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n+impl<'a, 'b> Lam<&'a &'b u8> for L2 {\n+    type App = u8;\n+}\n \n trait Case1 {\n-    type C: Clone + Iterator<Item:\n-        Send + Iterator<Item:\n-            for<'a> Lam<&'a u8, App:\n-                Debug\n-            >\n-        > + Sync>;\n-        //~^^^^^^ ERROR `<<Self as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n-        //~^^^^^^ ERROR `<<Self as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n-        //~^^^ ERROR `<<Self as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n+    type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n+    //~^ ERROR overflow evaluating the requirement `<<Self as Case1>::C as std::iter::Iterator>::Item`\n }\n \n pub struct S1;\n@@ -34,10 +33,20 @@ impl Case1 for S1 {\n }\n \n fn assume_case1<T: Case1>() {\n-    fn assert_a<_0, A>() where A: Iterator<Item = _0>, _0: Debug {}\n+    fn assert_a<_0, A>()\n+    where\n+        A: Iterator<Item = _0>,\n+        _0: Debug,\n+    {\n+    }\n     assert_a::<_, T::A>();\n \n-    fn assert_b<_0, B>() where B: Iterator<Item = _0>, _0: 'static {}\n+    fn assert_b<_0, B>()\n+    where\n+        B: Iterator<Item = _0>,\n+        _0: 'static,\n+    {\n+    }\n     assert_b::<_, T::B>();\n \n     fn assert_c<_0, _1, _2, C>()\n@@ -46,7 +55,8 @@ fn assume_case1<T: Case1>() {\n         _2: Send + Iterator<Item = _1>,\n         _1: for<'a> Lam<&'a u8, App = _0>,\n         _0: Debug,\n-    {}\n+    {\n+    }\n     assert_c::<_, _, _, T::C>();\n }\n "}, {"sha": "abaae7e5343dda082c353ef90f1651ffb04620d4", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -1,5 +1,5 @@\n-error[E0277]: `<<Self as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:5\n+error[E0275]: overflow evaluating the requirement `<<Self as Case1>::C as std::iter::Iterator>::Item`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:28:5\n    |\n LL | /     type C: Clone + Iterator<Item:\n LL | |         Send + Iterator<Item:\n@@ -49,6 +49,6 @@ help: consider further restricting the associated type\n LL | trait Case1 where <<Self as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "db092970f79b88603e426dd821ebb6350b2c81e6", "filename": "src/test/ui/associated-types/associate-type-bound-normalization.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fassociated-types%2Fassociate-type-bound-normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fassociated-types%2Fassociate-type-bound-normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociate-type-bound-normalization.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -0,0 +1,25 @@\n+// Make sure that we normalize bounds on associated types before checking them\n+// as candidates.\n+\n+// check-pass\n+\n+trait Mul<T> {\n+    type Output;\n+}\n+\n+trait Matrix: Mul<<Self as Matrix>::Row, Output = ()> {\n+    type Row;\n+\n+    type Transpose: Matrix<Row = Self::Row>;\n+}\n+\n+fn is_mul<S, T: Mul<S, Output = ()>>() {}\n+\n+fn f<T: Matrix>() {\n+    // The unnormalized bound on `T::Transpose` is\n+    // `Mul<<T::Transpose as Matrix>::Row` which has to be normalized to be\n+    // equal to `T::Row`.\n+    is_mul::<T::Row, T::Transpose>();\n+}\n+\n+fn main() {}"}, {"sha": "909c33f642d31f581e7fafb31ac18b0d04a3293b", "filename": "src/test/ui/closures/issue-41366.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -9,4 +9,5 @@ impl<'g> T<'g> for u32 {\n fn main() {\n     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n     //~^ ERROR: type mismatch in closure arguments\n+    //~| ERROR: size for values of type `<u32 as T<'_>>::V` cannot be known at compilation time\n }"}, {"sha": "97c33c0708e49047ad6497eb1b9f321945a50570", "filename": "src/test/ui/closures/issue-41366.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -9,6 +9,24 @@ LL |     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n    |\n    = note: required for the cast to the object type `dyn for<'x> Fn(<u32 as T<'x>>::V)`\n \n-error: aborting due to previous error\n+error[E0277]: the size for values of type `<u32 as T<'_>>::V` cannot be known at compilation time\n+  --> $DIR/issue-41366.rs:10:8\n+   |\n+LL |     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |        ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `<u32 as T<'_>>::V`\n+   = help: unsized locals are gated as an unstable feature\n+help: consider further restricting the associated type\n+   |\n+LL | fn main() where <u32 as T<'_>>::V: std::marker::Sized {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL |     (&|&_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |        ^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0631`.\n+Some errors have detailed explanations: E0277, E0631.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "5a7b3459589eb77ea6a14457c02ad46b6c3f62b4", "filename": "src/test/ui/issues/issue-24204.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-24204.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-24204.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![allow(dead_code)]\n \n trait MultiDispatch<T> {\n@@ -8,10 +10,16 @@ trait Trait: Sized {\n     type A: MultiDispatch<Self::B, O = Self>;\n     type B;\n \n-    fn new<U>(u: U) -> <Self::A as MultiDispatch<U>>::O where Self::A : MultiDispatch<U>;\n+    fn new<U>(u: U) -> <Self::A as MultiDispatch<U>>::O\n+    where\n+        Self::A: MultiDispatch<U>;\n }\n \n-fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-//~^ ERROR mismatched types\n+fn test<T: Trait<B = i32>>(b: i32) -> T\n+where\n+    T::A: MultiDispatch<i32>,\n+{\n+    T::new(b)\n+}\n \n fn main() {}"}, {"sha": "9d66c9ff0a843aea9b9d2aadb2ac7998b4c5bd2e", "filename": "src/test/ui/issues/issue-24204.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -1,15 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-24204.rs:14:72\n-   |\n-LL | fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-   |         -                           -                                  ^^^^^^^^^ expected type parameter `T`, found associated type\n-   |         |                           |\n-   |         this type parameter         expected `T` because of return type\n-   |\n-   = note: expected type parameter `T`\n-             found associated type `<<T as Trait>::A as MultiDispatch<i32>>::O`\n-   = note: you might be missing a type parameter or trait bound\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "0cb04dcb22a548c76459a20f3701b7d10a3e29f0", "filename": "src/test/ui/issues/issue-58344.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n use std::ops::Add;\n \n trait Trait<T> {\n@@ -18,30 +20,28 @@ enum Either<L, R> {\n }\n \n impl<L, R> Either<L, R> {\n-    fn converge<T>(self) -> T where L: Trait<T>, R: Trait<T> {\n+    fn converge<T>(self) -> T\n+    where\n+        L: Trait<T>,\n+        R: Trait<T>,\n+    {\n         match self {\n             Either::Left(val) => val.get(),\n             Either::Right(val) => val.get(),\n         }\n     }\n }\n \n-fn add_generic<A: Add<B>, B>(lhs: A, rhs: B) -> Either<\n-    impl Trait<<A as Add<B>>::Output>,\n-    impl Trait<<A as Add<B>>::Output>\n-> {\n-    if true {\n-        Either::Left(Holder(lhs + rhs))\n-    } else {\n-        Either::Right(Holder(lhs + rhs))\n-    }\n+fn add_generic<A: Add<B>, B>(\n+    lhs: A,\n+    rhs: B,\n+) -> Either<impl Trait<<A as Add<B>>::Output>, impl Trait<<A as Add<B>>::Output>> {\n+    if true { Either::Left(Holder(lhs + rhs)) } else { Either::Right(Holder(lhs + rhs)) }\n }\n \n fn add_one(\n     value: u32,\n ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n-    //~^ ERROR: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>`\n-    //~| ERROR: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>`\n     add_generic(value, 1u32)\n }\n "}, {"sha": "ade85d8b0168c6227c72004ecd8e52da3b1fd758", "filename": "src/test/ui/issues/issue-58344.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -1,25 +0,0 @@\n-error[E0277]: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>` is not satisfied\n-  --> $DIR/issue-58344.rs:42:13\n-   |\n-LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as Add>::Output>`\n-...\n-LL |     add_generic(value, 1u32)\n-   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as Add>::Output>, impl Trait<<u32 as Add>::Output>>`\n-   |\n-   = note: the return type of a function must have a statically known size\n-\n-error[E0277]: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>` is not satisfied\n-  --> $DIR/issue-58344.rs:42:52\n-   |\n-LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n-   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as Add>::Output>`\n-...\n-LL |     add_generic(value, 1u32)\n-   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as Add>::Output>, impl Trait<<u32 as Add>::Output>>`\n-   |\n-   = note: the return type of a function must have a statically known size\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "9f4813071a1e797079c89b1e3f98ffd4d8c96888", "filename": "src/test/ui/issues/issue-60283.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -16,4 +16,5 @@ where\n fn main() {\n     foo((), drop)\n     //~^ ERROR type mismatch in function arguments\n+    //~| ERROR the size for values of type `<() as Trait<'_>>::Item` cannot be known at compilation time\n }"}, {"sha": "2922eb87e825f0b0481e3d27ebeecac10f9b6201", "filename": "src/test/ui/issues/issue-60283.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -13,6 +13,24 @@ LL |     foo((), drop)\n    |             expected signature of `fn(<() as Trait<'a>>::Item) -> _`\n    |             found signature of `fn(()) -> _`\n \n-error: aborting due to previous error\n+error[E0277]: the size for values of type `<() as Trait<'_>>::Item` cannot be known at compilation time\n+  --> $DIR/issue-60283.rs:17:13\n+   |\n+LL |     foo((), drop)\n+   |             ^^^^ doesn't have a size known at compile-time\n+   | \n+  ::: $SRC_DIR/libcore/mem/mod.rs:LL:COL\n+   |\n+LL | pub fn drop<T>(_x: T) {}\n+   |             - required by this bound in `std::mem::drop`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `<() as Trait<'_>>::Item`\n+help: consider further restricting the associated type\n+   |\n+LL | fn main() where <() as Trait<'_>>::Item: std::marker::Sized {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0631`.\n+Some errors have detailed explanations: E0277, E0631.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "4954a8a6965be828ed807a35323845ec784e9797", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e5a4992c920ce9e68c333621f3d4c967c012c4/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs?ref=34e5a4992c920ce9e68c333621f3d4c967c012c4", "patch": "@@ -1,5 +1,4 @@\n-// Running rustfix would cause the same suggestion to be applied multiple times, which results in\n-// invalid code.\n+// check-pass\n \n trait Parent {\n     type Ty;\n@@ -17,7 +16,6 @@ struct ParentWrapper<T>(T);\n impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n     type Ty = A;\n     type Assoc = ChildWrapper<T::Assoc>;\n-    //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n }\n \n fn main() {}"}, {"sha": "676e2fb1a51dc7778695fd0f49eb0dc0169893eb", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfee49593d756bb97018d1d2ac194e0821d2dfca/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr?ref=cfee49593d756bb97018d1d2ac194e0821d2dfca", "patch": "@@ -1,18 +0,0 @@\n-error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-  --> $DIR/missing-assoc-type-bound-restriction.rs:19:5\n-   |\n-LL |     type Assoc: Child<Self::Ty>;\n-   |                 --------------- required by this bound in `Parent::Assoc`\n-...\n-LL |     type Assoc = ChildWrapper<T::Assoc>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n-   |\n-   = note: required because of the requirements on the impl of `Child<A>` for `ChildWrapper<<T as Parent>::Assoc>`\n-help: consider further restricting the associated type\n-   |\n-LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> where <T as Parent>::Assoc: Child<A> {\n-   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}]}