{"sha": "cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "node_id": "C_kwDOAAsO6NoAKGNiN2NkOTc2NDFiN2EyZDE2NDY1MjBiN2JmNzg1OTM0ZjljNmFhZWI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-03T21:10:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-05T14:09:42Z"}, "message": "promise that ptr::copy and ptr::swap are doing untyped copies", "tree": {"sha": "6a2cd15f8d6c4c3343a08abd8785c2e14aacbccb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a2cd15f8d6c4c3343a08abd8785c2e14aacbccb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "html_url": "https://github.com/rust-lang/rust/commit/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b96d1e45f188010f2cc6fff956902a455eb2178a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96d1e45f188010f2cc6fff956902a455eb2178a", "html_url": "https://github.com/rust-lang/rust/commit/b96d1e45f188010f2cc6fff956902a455eb2178a"}], "stats": {"total": 16, "additions": 14, "deletions": 2}, "files": [{"sha": "9bed758c10a1dbfe3314f6c24517b44bd23303d6", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "patch": "@@ -2043,6 +2043,9 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n /// with the argument order swapped.\n ///\n+/// The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n+/// requirements of `T`. The initialization state is preserved exactly.\n+///\n /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n ///\n /// # Safety\n@@ -2148,6 +2151,9 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n /// order swapped. Copying takes place as if the bytes were copied from `src`\n /// to a temporary array and then copied from the array to `dst`.\n ///\n+/// The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n+/// requirements of `T`. The initialization state is preserved exactly.\n+///\n /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n ///\n /// # Safety"}, {"sha": "1035fdbf12dd50696c71321f548e2be0ab769e71", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "patch": "@@ -774,7 +774,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// But for the following two exceptions, this function is semantically\n+/// But for the following exceptions, this function is semantically\n /// equivalent to [`mem::swap`]:\n ///\n /// * It operates on raw pointers instead of references. When references are\n@@ -784,6 +784,9 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///   overlapping region of memory from `x` will be used. This is demonstrated\n ///   in the second example below.\n ///\n+/// * The operation is \"untyped\" in the sense that data may be uninitialized or otherwise violate\n+///   the requirements of `T`. The initialization state is preserved exactly.\n+///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -860,6 +863,9 @@ pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n /// beginning at `x` and `y`. The two regions must *not* overlap.\n ///\n+/// The operation is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n+/// requirements of `T`. The initialization state is preserved exactly.\n+///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -965,7 +971,7 @@ const unsafe fn swap_nonoverlapping_simple_untyped<T>(x: *mut T, y: *mut T, coun\n         // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n         // and it's distinct from `x` since the ranges are non-overlapping\n         let y = unsafe { &mut *y.add(i) };\n-        mem::swap_simple(x, y);\n+        mem::swap_simple::<MaybeUninit<T>>(x, y);\n \n         i += 1;\n     }"}]}