{"sha": "88717319142e162ae2f48124d94f33d2c21bc2ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzE3MzE5MTQyZTE2MmFlMmY0ODEyNGQ5NGYzM2QyYzIxYmMyY2U=", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2019-11-12T23:24:37Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2019-11-12T23:24:37Z"}, "message": "Merge remote-tracking branch 'rust-lang/master' into hermit", "tree": {"sha": "e50a968f836c55007e9bc8f305d4f0f80aca042c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e50a968f836c55007e9bc8f305d4f0f80aca042c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88717319142e162ae2f48124d94f33d2c21bc2ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88717319142e162ae2f48124d94f33d2c21bc2ce", "html_url": "https://github.com/rust-lang/rust/commit/88717319142e162ae2f48124d94f33d2c21bc2ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88717319142e162ae2f48124d94f33d2c21bc2ce/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "969b74144641bf1c8ae5aba0581f4b52a4c15bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/969b74144641bf1c8ae5aba0581f4b52a4c15bac", "html_url": "https://github.com/rust-lang/rust/commit/969b74144641bf1c8ae5aba0581f4b52a4c15bac"}, {"sha": "4f03f4a989d1c8346c19dfb417a77c09b34408b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f4a989d1c8346c19dfb417a77c09b34408b8", "html_url": "https://github.com/rust-lang/rust/commit/4f03f4a989d1c8346c19dfb417a77c09b34408b8"}], "stats": {"total": 20925, "additions": 11336, "deletions": 9589}, "files": [{"sha": "bd1d49fb24dc3a8ee0d80ee915d7b66164efe527", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -105,7 +105,7 @@ contributions to the compiler and the standard library. It also lists some\n really useful commands to the build system (`./x.py`), which could save you a\n lot of time.\n \n-[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html\n+[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/building/how-to-build-and-run.html\n \n ## Pull Requests\n [pull-requests]: #pull-requests"}, {"sha": "16f2ffc28150f6c8507c4779df227c32315e0afd", "filename": "Cargo.lock", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -68,7 +68,7 @@ name = \"arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -208,6 +208,7 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n+ \"serde_json\",\n  \"toml\",\n ]\n \n@@ -486,7 +487,7 @@ dependencies = [\n  \"regex-syntax\",\n  \"semver\",\n  \"serde\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -654,7 +655,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0f0ed1a4de2235cabda8558ff5840bffb97fcb64c97827f354a451307df5f72b\"\n dependencies = [\n  \"crossbeam-utils 0.6.5\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n ]\n \n [[package]]\n@@ -2251,9 +2252,9 @@ dependencies = [\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.16\"\n+version = \"0.10.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec7bd7ca4cce6dbdc77e7c1230682740d307d1218a87fb0349a571272be749f9\"\n+checksum = \"2f372b2b53ce10fb823a337aaa674e3a7d072b957c6264d0f4ff0bd86e657449\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n@@ -2280,15 +2281,15 @@ dependencies = [\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.43\"\n+version = \"0.9.52\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"33c86834957dd5b915623e94f2f4ab2c70dd8f6b70679824155d5ae21dbd495d\"\n+checksum = \"c977d08e1312e2f7e4b86f9ebaa0ed3b19d1daff75fae88bbb88108afbd801fc\"\n dependencies = [\n+ \"autocfg\",\n  \"cc\",\n  \"libc\",\n  \"openssl-src\",\n  \"pkg-config\",\n- \"rustc_version\",\n  \"vcpkg\",\n ]\n \n@@ -2391,7 +2392,7 @@ dependencies = [\n  \"libc\",\n  \"rand 0.6.1\",\n  \"rustc_version\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n  \"winapi 0.3.6\",\n ]\n \n@@ -2406,7 +2407,7 @@ dependencies = [\n  \"libc\",\n  \"redox_syscall\",\n  \"rustc_version\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n  \"winapi 0.3.6\",\n ]\n \n@@ -3134,7 +3135,7 @@ dependencies = [\n  \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n@@ -3146,7 +3147,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a623fd4805842e9bd0bb6e6dace63efede0ee22de4522a0b03b7c3d15a22f009\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n ]\n \n [[package]]\n@@ -3175,7 +3176,7 @@ dependencies = [\n  \"rustc-hash\",\n  \"rustc-rayon 0.2.0\",\n  \"rustc-rayon-core 0.2.0\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n  \"stable_deref_trait\",\n ]\n \n@@ -3203,7 +3204,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"457a5c204ae2fdaa5bdb5b196e58ca59896870d80445fe423063c9453496e3ea\"\n dependencies = [\n  \"rustc-ap-serialize\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n ]\n \n [[package]]\n@@ -3249,7 +3250,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"92679240e86f4583cc05f8dcf6439bdab87bac9e6555718469176de9bd52ba20\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n ]\n \n [[package]]\n@@ -3269,7 +3270,7 @@ dependencies = [\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n  \"scoped-tls\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n ]\n \n [[package]]\n@@ -3392,7 +3393,7 @@ dependencies = [\n  \"crossbeam-utils 0.6.5\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec\",\n+ \"smallvec 0.6.10\",\n  \"syn 0.15.35\",\n  \"url 2.1.0\",\n  \"winapi 0.3.6\",\n@@ -3403,7 +3404,7 @@ name = \"rustc_apfloat\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -3483,7 +3484,7 @@ dependencies = [\n  \"rustc-rayon-core 0.3.0\",\n  \"rustc_index\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n ]\n \n@@ -3503,8 +3504,10 @@ dependencies = [\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_parse\",\n  \"rustc_plugin\",\n  \"rustc_plugin_impl\",\n+ \"rustc_resolve\",\n  \"rustc_save_analysis\",\n  \"rustc_target\",\n  \"serialize\",\n@@ -3551,7 +3554,7 @@ name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -3570,6 +3573,7 @@ dependencies = [\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_parse\",\n  \"rustc_passes\",\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n@@ -3578,7 +3582,7 @@ dependencies = [\n  \"rustc_traits\",\n  \"rustc_typeck\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_expand\",\n  \"syntax_ext\",\n@@ -3647,9 +3651,10 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n+ \"rustc_parse\",\n  \"rustc_target\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n  \"syntax\",\n  \"syntax_expand\",\n@@ -3674,7 +3679,7 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_target\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n@@ -3690,6 +3695,21 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"rustc_parse\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"log\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_lexer\",\n+ \"rustc_target\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n+ \"syntax_pos\",\n+]\n+\n [[package]]\n name = \"rustc_passes\"\n version = \"0.0.0\"\n@@ -3699,6 +3719,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n+ \"rustc_parse\",\n  \"rustc_target\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3745,7 +3766,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_metadata\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_expand\",\n  \"syntax_pos\",\n@@ -3761,7 +3782,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n- \"rustc_target\",\n+ \"rustc_parse\",\n  \"serde_json\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3798,7 +3819,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_target\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n@@ -3825,7 +3846,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_target\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n@@ -4069,7 +4090,7 @@ name = \"serialize\"\n version = \"0.0.0\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -4133,6 +4154,12 @@ version = \"0.6.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ab606a9c5e214920bb66c458cd7be8ef094f813f20fe77a54cc7dbfff220d4b7\"\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ecf3b85f68e8abaa7555aa5abdb1153079387e60b718283d732f03897fcfc86\"\n+\n [[package]]\n name = \"socket2\"\n version = \"0.3.8\"\n@@ -4355,28 +4382,23 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n- \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax_pos\",\n ]\n \n [[package]]\n name = \"syntax_expand\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags\",\n- \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_index\",\n  \"rustc_lexer\",\n- \"rustc_target\",\n- \"scoped-tls\",\n+ \"rustc_parse\",\n  \"serialize\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n@@ -4389,8 +4411,9 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_parse\",\n  \"rustc_target\",\n- \"smallvec\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_expand\",\n  \"syntax_pos\","}, {"sha": "61d3c9e1157203f0c4ed5165608d92294eaca808", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -21,7 +21,7 @@ The Rust build system has a Python script called `x.py` to bootstrap building\n the compiler. More information about it may be found by running `./x.py --help`\n or reading the [rustc guide][rustcguidebuild].\n \n-[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html\n+[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/building/how-to-build-and-run.html\n \n ### Building on *nix\n 1. Make sure you have installed the dependencies:"}, {"sha": "7b49cc0a9298cc059b56e2c2670e214bf78c02a5", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -448,12 +448,12 @@ Arguments:\n \n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n-            stage: matches.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_strs(\"keep-stage\")\n-                .into_iter().map(|j| j.parse().unwrap())\n+                .into_iter().map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n                 .collect(),\n             host: split(&matches.opt_strs(\"host\"))\n                 .into_iter()\n@@ -464,7 +464,7 @@ Arguments:\n                 .map(|x| INTERNER.intern_string(x))\n                 .collect::<Vec<_>>(),\n             config: cfg_file,\n-            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(&matches.opt_strs(\"exclude\"))"}, {"sha": "a858ed42badfdc7868a064655a732dfaf1c82d2a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -570,7 +570,12 @@ impl Step for Clippy {\n             let host_libs = builder\n                 .stage_out(compiler, Mode::ToolRustc)\n                 .join(builder.cargo_dir());\n+            let target_libs = builder\n+                .stage_out(compiler, Mode::ToolRustc)\n+                .join(&self.host)\n+                .join(builder.cargo_dir());\n             cargo.env(\"HOST_LIBS\", host_libs);\n+            cargo.env(\"TARGET_LIBS\", target_libs);\n             // clippy tests need to find the driver\n             cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n "}, {"sha": "836f81a7816569cb613f07ae56bcf867db738575", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -318,7 +318,7 @@ jobs:\n       # 32/64 bit MSVC and GNU deployment\n       dist-x86_64-msvc:\n         MSYS_BITS: 64\n-        RUST_CONFIGURE_ARGS: >\n+        RUST_CONFIGURE_ARGS: >-\n           --build=x86_64-pc-windows-msvc\n           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n           --enable-full-tools\n@@ -328,7 +328,7 @@ jobs:\n         DEPLOY: 1\n       dist-i686-msvc:\n         MSYS_BITS: 32\n-        RUST_CONFIGURE_ARGS: >\n+        RUST_CONFIGURE_ARGS: >-\n           --build=i686-pc-windows-msvc\n           --target=i586-pc-windows-msvc\n           --enable-full-tools"}, {"sha": "ad675830b7799ce8b27fe8115fe28f0dbeca5dd4", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -69,7 +69,7 @@ RUN ./build-python.sh\n \n # Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n # clang/clang++ compilers.\n-COPY dist-x86_64-linux/build-clang.sh /tmp/\n+COPY dist-x86_64-linux/build-clang.sh dist-x86_64-linux/llvm-project-centos.patch /tmp/\n RUN ./build-clang.sh\n ENV CC=clang CXX=clang++\n "}, {"sha": "c63ea6facca648e3f7a71027145e9a6414bb3058", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,17 +4,17 @@\n \n set -ex\n \n-# Originally from https://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+# Originally from https://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n+curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/clang%2Bllvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n   tar xJf -\n-export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n+export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n \n-git clone https://github.com/CraneStation/wasi-sysroot\n+git clone https://github.com/CraneStation/wasi-libc\n \n-cd wasi-sysroot\n-git reset --hard e5f14be38362f1ab83302895a6e74b2ffd0e2302\n+cd wasi-libc\n+git reset --hard a94d2d04e7722b323573da2bd04e909a5763d35b\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd ..\n-rm -rf reference-sysroot-wasi\n+rm -rf wasi-libc\n rm -rf clang+llvm*"}, {"sha": "2f2a10a0e90ae58c8c562041c290622c19699695", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -69,7 +69,7 @@ RUN ./build-python.sh\n \n # Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n # clang/clang++ compilers.\n-COPY dist-x86_64-linux/build-clang.sh /tmp/\n+COPY dist-x86_64-linux/build-clang.sh dist-x86_64-linux/llvm-project-centos.patch /tmp/\n RUN ./build-clang.sh\n ENV CC=clang CXX=clang++\n "}, {"sha": "518f6ef9b701dc249c0924788856f2d78905192e", "filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,14 +4,17 @@ set -ex\n \n source shared.sh\n \n-LLVM=llvmorg-8.0.0-rc2\n+LLVM=llvmorg-9.0.0\n \n mkdir llvm-project\n cd llvm-project\n \n curl -L https://github.com/llvm/llvm-project/archive/$LLVM.tar.gz | \\\n   tar xzf - --strip-components=1\n \n+yum install -y patch\n+patch -Np1 < ../llvm-project-centos.patch\n+\n mkdir clang-build\n cd clang-build\n "}, {"sha": "52650062cc4026cae473dabfdcb91c89bf90c819", "filename": "src/ci/docker/dist-x86_64-linux/llvm-project-centos.patch", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fllvm-project-centos.patch", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fllvm-project-centos.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fllvm-project-centos.patch?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,18 @@\n+diff --git a/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp b/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp\n+index 176d6d6abf3..a6d63bf24b8 100644\n+--- a/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp\n++++ b/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp\n+@@ -33,6 +33,13 @@ namespace {\n+ using namespace llvm;\n+ using namespace clang;\n+ \n++#define EPOLL_CLOEXEC -1\n++#define IN_CLOEXEC -1\n++#define O_CLOEXEC -1\n++static int epoll_create1(int flags) { return -1; }\n++static int inotify_init1(int flags) { return -1; }\n++static int pipe2(int *fds, int flags) { return -1; }\n++\n+ /// Pipe for inter-thread synchronization - for epoll-ing on multiple\n+ /// conditions. It is meant for uni-directional 1:1 signalling - specifically:\n+ /// no multiple consumers, no data passing. Thread waiting for signal should"}, {"sha": "b1e9bf92ca5d2444b284c741b40aa908e595b3e9", "filename": "src/ci/scripts/install-clang.sh", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fscripts%2Finstall-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fci%2Fscripts%2Finstall-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-clang.sh?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -9,10 +9,10 @@ IFS=$'\\n\\t'\n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isMacOS; then\n-    curl -f \"${MIRRORS_BASE}/clang%2Bllvm-7.0.0-x86_64-apple-darwin.tar.xz\" | tar xJf -\n+    curl -f \"${MIRRORS_BASE}/clang%2Bllvm-9.0.0-x86_64-darwin-apple.tar.xz\" | tar xJf -\n \n-    ciCommandSetEnv CC \"$(pwd)/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang\"\n-    ciCommandSetEnv CXX \"$(pwd)/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++\"\n+    ciCommandSetEnv CC \"$(pwd)/clang+llvm-9.0.0-x86_64-darwin-apple/bin/clang\"\n+    ciCommandSetEnv CXX \"$(pwd)/clang+llvm-9.0.0-x86_64-darwin-apple/bin/clang++\"\n \n     # Configure `AR` specifically so rustbuild doesn't try to infer it as\n     # `clang-ar` by accident.\n@@ -27,17 +27,18 @@ elif isWindows && [[ -z ${MINGW_URL+x} ]]; then\n     # Note that the LLVM installer is an NSIS installer\n     #\n     # Original downloaded here came from\n-    # http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n-    # That installer was run through `wine` on Linux and then the resulting\n-    # installation directory (found in `$HOME/.wine/drive_c/Program Files/LLVM`) was\n-    # packaged up into a tarball. We've had issues otherwise that the installer will\n-    # randomly hang, provide not a lot of useful information, pollute global state,\n-    # etc. In general the tarball is just more confined and easier to deal with when\n-    # working with various CI environments.\n+    # http://releases.llvm.org/9.0.0/LLVM-9.0.0-win64.exe\n+    # That installer was run through `wine ./installer.exe /S /NCRC` on Linux\n+    # and then the resulting installation directory (found in\n+    # `$HOME/.wine/drive_c/Program Files/LLVM`) was packaged up into a tarball.\n+    # We've had issues otherwise that the installer will randomly hang, provide\n+    # not a lot of useful information, pollute global state, etc. In general the\n+    # tarball is just more confined and easier to deal with when working with\n+    # various CI environments.\n \n     mkdir -p citools\n     cd citools\n-    curl -f \"${MIRRORS_BASE}/LLVM-7.0.0-win64.tar.gz\" | tar xzf -\n+    curl -f \"${MIRRORS_BASE}/LLVM-9.0.0-win64.tar.gz\" | tar xzf -\n     ciCommandSetEnv RUST_CONFIGURE_ARGS \\\n         \"${RUST_CONFIGURE_ARGS} --set llvm.clang-cl=$(pwd)/clang-rust/bin/clang-cl.exe\"\n fi"}, {"sha": "75a5f9236c689a547fe207a10854f0775bce7937", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1 +1 @@\n-Subproject commit 941968db2fd9c85788a4f971c8e425d46b4cb734\n+Subproject commit 75a5f9236c689a547fe207a10854f0775bce7937"}, {"sha": "0dc81378e05b2508ac2675577a7417ef03b539f9", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -197,7 +197,11 @@ in software.\n ## prefer-dynamic\n \n By default, `rustc` prefers to statically link dependencies. This option will\n-make it use dynamic linking instead.\n+indicate that dynamic linking should be used if possible if both a static and\n+dynamic versions of a library are available. There is an internal algorithm\n+for determining whether or not it is possible to statically or dynamically\n+link with a dependency. For example, `cdylib` crate types may only use static\n+linkage.\n \n ## no-integrated-as\n "}, {"sha": "577d03d1038f8a874fec87dd366fd96b27005e98", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -21,8 +21,7 @@ to `#[cfg(verbose)]` and `#[cfg(feature = \"serde\")]` respectively.\n <a id=\"option-l-search-path\"></a>\n ## `-L`: add a directory to the library search path\n \n-When looking for external crates or libraries, a directory passed to this flag\n-will be searched.\n+The `-L` flag adds a path to search for external crates and libraries.\n \n The kind of search path can optionally be specified with the form `-L\n KIND=PATH` where `KIND` may be one of:\n@@ -262,9 +261,30 @@ This flag, when combined with other flags, makes them produce extra output.\n <a id=\"option-extern\"></a>\n ## `--extern`: specify where an external library is located\n \n-This flag allows you to pass the name and location of an external crate that\n-will be linked into the crate you are building. This flag may be specified\n-multiple times. The format of the value should be `CRATENAME=PATH`.\n+This flag allows you to pass the name and location for an external crate of a\n+direct dependency. Indirect dependencies (dependencies of dependencies) are\n+located using the [`-L` flag](#option-l-search-path). The given crate name is\n+added to the [extern prelude], which is the same as specifying `extern crate`\n+within the root module. The given crate name does not need to match the name\n+the library was built with.\n+\n+This flag may be specified multiple times. This flag takes an argument with\n+either of the following formats:\n+\n+* `CRATENAME=PATH` \u2014\u00a0Indicates the given crate is found at the given path.\n+* `CRATENAME` \u2014\u00a0Indicates the given crate may be found in the search path,\n+  such as within the sysroot or via the `-L` flag.\n+\n+The same crate name may be specified multiple times for different crate types.\n+If both an `rlib` and `dylib` are found, an internal algorithm is used to\n+decide which to use for linking. The [`-C prefer-dynamic`\n+flag][prefer-dynamic] may be used to influence which is used.\n+\n+If the same crate name is specified with and without a path, the one with the\n+path is used and the pathless flag has no effect.\n+\n+[extern prelude]: ../reference/items/extern-crates.html#extern-prelude\n+[prefer-dynamic]: codegen-options/index.md#prefer-dynamic\n \n <a id=\"option-sysroot\"></a>\n ## `--sysroot`: Override the system root"}, {"sha": "dc5a9e44acfa2670b3a5869e7accbe9d82b8ce50", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 27, "deletions": 64, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -45,53 +45,6 @@ error: defaults for type parameters are only allowed in `struct`, `enum`, `type`\n   = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n ```\n \n-## legacy-constructor-visibility\n-\n-[RFC 1506](https://github.com/rust-lang/rfcs/blob/master/text/1506-adt-kinds.md) modified some\n-visibility rules, and changed the visibility of struct constructors. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-mod m {\n-    pub struct S(u8);\n-    \n-    fn f() {\n-        // this is trying to use S from the 'use' line, but because the `u8` is\n-        // not pub, it is private\n-        ::S;\n-    }\n-}\n-\n-use m::S;\n-```\n-\n-This will produce:\n-\n-```text\n-error: private struct constructors are not usable through re-exports in outer modules\n- --> src/main.rs:5:9\n-  |\n-5 |         ::S;\n-  |         ^^^\n-  |\n-  = note: `#[deny(legacy_constructor_visibility)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #39207 <https://github.com/rust-lang/rust/issues/39207>\n-```\n-\n-\n-## legacy-directory-ownership\n-\n-The legacy_directory_ownership warning is issued when\n-\n-* There is a non-inline module with a `#[path]` attribute (e.g. `#[path = \"foo.rs\"] mod bar;`),\n-* The module's file (\"foo.rs\" in the above example) is not named \"mod.rs\", and\n-* The module's file contains a non-inline child module without a `#[path]` attribute.\n-\n-The warning can be fixed by renaming the parent module to \"mod.rs\" and moving\n-it into its own directory if appropriate.\n-\n-\n ## missing-fragment-specifier\n \n The missing_fragment_specifier warning is issued when an unused pattern in a\n@@ -169,39 +122,49 @@ error: literal out of range for u8\n   |\n ```\n \n-## parenthesized-params-in-types-and-modules\n+## patterns-in-fns-without-body\n \n-This lint detects incorrect parentheses. Some example code that triggers this\n-lint:\n+This lint detects patterns in functions without body were that were\n+previously erroneously allowed. Some example code that triggers this lint:\n \n-```rust,ignore\n-let x = 5 as usize();\n+```rust,compile_fail\n+trait Trait {\n+    fn foo(mut arg: u8);\n+}\n ```\n \n This will produce:\n \n ```text\n-error: parenthesized parameters may only be used with a trait\n- --> src/main.rs:2:21\n+warning: patterns aren't allowed in methods without bodies\n+ --> src/main.rs:2:12\n   |\n-2 |   let x = 5 as usize();\n-  |                     ^^\n+2 |     fn foo(mut arg: u8);\n+  |            ^^^^^^^\n   |\n-  = note: `#[deny(parenthesized_params_in_types_and_modules)]` on by default\n+  = note: `#[warn(patterns_in_fns_without_body)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n+  = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n ```\n \n-To fix it, remove the `()`s.\n+To fix this, remove the pattern; it can be used in the implementation without\n+being used in the definition. That is:\n \n-## pub-use-of-private-extern-crate\n+```rust\n+trait Trait {\n+    fn foo(arg: u8);\n+}\n \n-This lint detects a specific situation of re-exporting a private `extern crate`;\n+impl Trait for i32 {\n+    fn foo(mut arg: u8) {\n+\n+    }\n+}\n+```\n \n-## safe-extern-statics\n+## pub-use-of-private-extern-crate\n \n-In older versions of Rust, there was a soundness issue where `extern static`s were allowed\n-to be accessed in safe code. This lint now catches and denies this kind of code.\n+This lint detects a specific situation of re-exporting a private `extern crate`;\n \n ## unknown-crate-types\n "}, {"sha": "77642a850fae847c6c517ed2221055591ee91afe", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -307,46 +307,6 @@ warning: path statement with no effect\n   |\n ```\n \n-## patterns-in-fns-without-body\n-\n-This lint detects patterns in functions without body were that were\n-previously erroneously allowed. Some example code that triggers this lint:\n-\n-```rust\n-trait Trait {\n-    fn foo(mut arg: u8);\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: patterns aren't allowed in methods without bodies\n- --> src/main.rs:2:12\n-  |\n-2 |     fn foo(mut arg: u8);\n-  |            ^^^^^^^\n-  |\n-  = note: `#[warn(patterns_in_fns_without_body)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n-```\n-\n-To fix this, remove the pattern; it can be used in the implementation without\n-being used in the definition. That is:\n-\n-```rust\n-trait Trait {\n-    fn foo(arg: u8);\n-}\n-\n-impl Trait for i32 {\n-    fn foo(mut arg: u8) {\n-\n-    }\n-}\n-```\n-\n ## plugin-as-library\n \n This lint detects when compiler plugins are used as ordinary library in"}, {"sha": "d4202f5b367ab4686a8b13b009efaf4475b21c26", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,8 +1,10 @@\n # The Rustdoc Book\n \n - [What is rustdoc?](what-is-rustdoc.md)\n+- [How to write documentation](how-to-write-documentation.md)\n - [Command-line arguments](command-line-arguments.md)\n - [The `#[doc]` attribute](the-doc-attribute.md)\n - [Documentation tests](documentation-tests.md)\n+- [Lints](lints.md)\n - [Passes](passes.md)\n - [Unstable features](unstable-features.md)"}, {"sha": "dd3aa5d4b6988ebf5ae47bd4b681f5bf19cc7c72", "filename": "src/doc/rustdoc/src/how-to-write-documentation.md", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,82 @@\n+# How to write documentation\n+\n+This chapter covers not only how to write documentation but specifically\n+how to write **good** documentation.  Something to keep in mind when\n+writing documentation is that your audience is not just yourself but others\n+who simply don't have the context you do.  It is important to be as clear\n+as you can, and as complete as possible.  As a rule of thumb: the more\n+documentation you write for your crate the better.  If an item is public\n+then it should be documented.\n+\n+## Basic structure\n+\n+It is recommended that each item's documentation follows this basic structure:\n+\n+```text\n+[short sentence explaining what it is]\n+\n+[more detailed explanation]\n+\n+[at least one code example that users can copy/paste to try it]\n+\n+[even more advanced explanations if necessary]\n+```\n+\n+This basic structure should be straightforward to follow when writing your\n+documentation and, while you might think that a code example is trivial,\n+the examples are really important because they can help your users to\n+understand what an item is, how it is used, and for what purpose it exists.\n+\n+Let's see an example coming from the [standard library] by taking a look at the\n+[`std::env::args()`][env::args] function:\n+\n+``````text\n+Returns the arguments which this program was started with (normally passed\n+via the command line).\n+\n+The first element is traditionally the path of the executable, but it can be\n+set to arbitrary text, and may not even exist. This means this property should\n+not be relied upon for security purposes.\n+\n+On Unix systems shell usually expands unquoted arguments with glob patterns\n+(such as `*` and `?`). On Windows this is not done, and such arguments are\n+passed as-is.\n+\n+# Panics\n+\n+The returned iterator will panic during iteration if any argument to the\n+process is not valid unicode. If this is not desired,\n+use the [`args_os`] function instead.\n+\n+# Examples\n+\n+```\n+use std::env;\n+\n+// Prints each argument on a separate line\n+for argument in env::args() {\n+    println!(\"{}\", argument);\n+}\n+```\n+\n+[`args_os`]: ./fn.args_os.html\n+``````\n+\n+As you can see, it follows the structure detailed above: it starts with a short\n+sentence explaining what the functions does, then it provides more information\n+and finally provides a code example.\n+\n+## Markdown\n+\n+`rustdoc` is using the [commonmark markdown specification]. You might be\n+interested into taking a look at their website to see what's possible to do.\n+\n+## Lints\n+\n+To be sure that you didn't miss any item without documentation or code examples,\n+you can take a look at the rustdoc lints [here][rustdoc-lints].\n+\n+[standard library]: https://doc.rust-lang.org/stable/std/index.html\n+[env::args]: https://doc.rust-lang.org/stable/std/env/fn.args.html\n+[commonmark markdown specification]: https://commonmark.org/\n+[rustdoc-lints]: lints.md"}, {"sha": "beb2556872df78278e0cc2b1e385fc707d9294e9", "filename": "src/doc/rustdoc/src/lints.md", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,119 @@\n+# Lints\n+\n+`rustdoc` provides lints to help you writing and testing your documentation. You\n+can use them like any other lints by doing this:\n+\n+```rust,ignore\n+#![allow(missing_docs)] // allowing the lint, no message\n+#![warn(missing_docs)] // warn if there is missing docs\n+#![deny(missing_docs)] // rustdoc will fail if there is missing docs\n+```\n+\n+Here is the list of the lints provided by `rustdoc`:\n+\n+## intra_doc_link_resolution_failure\n+\n+This lint **warns by default** and is **nightly-only**. This lint detects when\n+an intra-doc link fails to get resolved. For example:\n+\n+```rust\n+/// I want to link to [`Inexistent`] but it doesn't exist!\n+pub fn foo() {}\n+```\n+\n+You'll get a warning saying:\n+\n+```text\n+error: `[`Inexistent`]` cannot be resolved, ignoring it...\n+```\n+\n+## missing_docs\n+\n+This lint is **allowed by default**. It detects items missing documentation.\n+For example:\n+\n+```rust\n+#![warn(missing_docs)]\n+\n+pub fn undocumented() {}\n+# fn main() {}\n+```\n+\n+The `undocumented` function will then have the following warning:\n+\n+```text\n+warning: missing documentation for a function\n+  --> your-crate/lib.rs:3:1\n+   |\n+ 3 | pub fn undocumented() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+```\n+\n+## missing_doc_code_examples\n+\n+This lint is **allowed by default**. It detects when a documentation block\n+is missing a code example. For example:\n+\n+```rust\n+#![warn(missing_doc_code_examples)]\n+\n+/// There is no code example!\n+pub fn no_code_example() {}\n+# fn main() {}\n+```\n+\n+The `no_code_example` function will then have the following warning:\n+\n+```text\n+warning: Missing code example in this documentation\n+  --> your-crate/lib.rs:3:1\n+   |\n+LL | /// There is no code example!\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+```\n+\n+To fix the lint, you need to add a code example into the documentation block:\n+\n+```rust\n+/// There is no code example!\n+///\n+/// ```\n+/// println!(\"calling no_code_example...\");\n+/// no_code_example();\n+/// println!(\"we called no_code_example!\");\n+/// ```\n+pub fn no_code_example() {}\n+```\n+\n+## private_doc_tests\n+\n+This lint is **allowed by default**. It detects documentation tests when they\n+are on a private item. For example:\n+\n+```rust\n+#![warn(private_doc_tests)]\n+\n+mod foo {\n+    /// private doc test\n+    ///\n+    /// ```\n+    /// assert!(false);\n+    /// ```\n+    fn bar() {}\n+}\n+# fn main() {}\n+```\n+\n+Which will give:\n+\n+```text\n+warning: Documentation test in private item\n+  --> your-crate/lib.rs:4:1\n+   |\n+ 4 | /     /// private doc test\n+ 5 | |     ///\n+ 6 | |     /// ```\n+ 7 | |     /// assert!(false);\n+ 8 | |     /// ```\n+   | |___________^\n+```"}, {"sha": "8db241e4b4ebf7f0e67713dc0240b112745a83c0", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/969b74144641bf1c8ae5aba0581f4b52a4c15bac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/969b74144641bf1c8ae5aba0581f4b52a4c15bac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=969b74144641bf1c8ae5aba0581f4b52a4c15bac", "patch": "@@ -1,154 +0,0 @@\n-# `on_unimplemented`\n-\n-The tracking issue for this feature is: [#29628]\n-\n-[#29628]: https://github.com/rust-lang/rust/issues/29628\n-\n-------------------------\n-\n-The `on_unimplemented` feature provides the `#[rustc_on_unimplemented]`\n-attribute, which allows trait definitions to add specialized notes to error\n-messages when an implementation was expected but not found. You can refer\n-to the trait's generic arguments by name and to the resolved type using\n-`Self`.\n-\n-For example:\n-\n-```rust,compile_fail\n-#![feature(on_unimplemented)]\n-\n-#[rustc_on_unimplemented=\"an iterator over elements of type `{A}` \\\n-    cannot be built from a collection of type `{Self}`\"]\n-trait MyIterator<A> {\n-    fn next(&mut self) -> A;\n-}\n-\n-fn iterate_chars<I: MyIterator<char>>(i: I) {\n-    // ...\n-}\n-\n-fn main() {\n-    iterate_chars(&[1, 2, 3][..]);\n-}\n-```\n-\n-When the user compiles this, they will see the following;\n-\n-```txt\n-error[E0277]: the trait bound `&[{integer}]: MyIterator<char>` is not satisfied\n-  --> <anon>:14:5\n-   |\n-14 |     iterate_chars(&[1, 2, 3][..]);\n-   |     ^^^^^^^^^^^^^ an iterator over elements of type `char` cannot be built from a collection of type `&[{integer}]`\n-   |\n-   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n-   = note: required by `iterate_chars`\n-```\n-\n-`on_unimplemented` also supports advanced filtering for better targeting\n-of messages, as well as modifying specific parts of the error message. You\n-target the text of:\n-\n- - the main error message (`message`)\n- - the label (`label`)\n- - an extra note (`note`)\n-\n-For example, the following attribute\n-\n-```rust,compile_fail\n-#[rustc_on_unimplemented(\n-    message=\"message\",\n-    label=\"label\",\n-    note=\"note\"\n-)]\n-trait MyIterator<A> {\n-    fn next(&mut self) -> A;\n-}\n-```\n-\n-Would generate the following output:\n-\n-```text\n-error[E0277]: message\n-  --> <anon>:14:5\n-   |\n-14 |     iterate_chars(&[1, 2, 3][..]);\n-   |     ^^^^^^^^^^^^^ label\n-   |\n-   = note: note\n-   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n-   = note: required by `iterate_chars`\n-```\n-\n-To allow more targeted error messages, it is possible to filter the\n-application of these fields based on a variety of attributes when using\n-`on`:\n-\n- - `crate_local`: whether the code causing the trait bound to not be\n-   fulfilled is part of the user's crate. This is used to avoid suggesting\n-   code changes that would require modifying a dependency.\n- - Any of the generic arguments that can be substituted in the text can be\n-   referred by name as well for filtering, like `Rhs=\"i32\"`, except for\n-   `Self`.\n- - `_Self`: to filter only on a particular calculated trait resolution, like\n-   `Self=\"std::iter::Iterator<char>\"`. This is needed because `Self` is a\n-   keyword which cannot appear in attributes.\n- - `direct`: user-specified rather than derived obligation.\n- - `from_method`: usable both as boolean (whether the flag is present, like\n-   `crate_local`) or matching against a particular method. Currently used\n-   for `try`.\n- - `from_desugaring`: usable both as boolean (whether the flag is present)\n-   or matching against a particular desugaring. The desugaring is identified\n-   with its variant name in the `DesugaringKind` enum.\n-\n-For example, the `Iterator` trait can be annotated in the following way:\n-\n-```rust,compile_fail\n-#[rustc_on_unimplemented(\n-    on(\n-        _Self=\"&str\",\n-        note=\"call `.chars()` or `.as_bytes()` on `{Self}\"\n-    ),\n-    message=\"`{Self}` is not an iterator\",\n-    label=\"`{Self}` is not an iterator\",\n-    note=\"maybe try calling `.iter()` or a similar method\"\n-)]\n-pub trait Iterator {}\n-```\n-\n-Which would produce the following outputs:\n-\n-```text\n-error[E0277]: `Foo` is not an iterator\n- --> src/main.rs:4:16\n-  |\n-4 |     for foo in Foo {}\n-  |                ^^^ `Foo` is not an iterator\n-  |\n-  = note: maybe try calling `.iter()` or a similar method\n-  = help: the trait `std::iter::Iterator` is not implemented for `Foo`\n-  = note: required by `std::iter::IntoIterator::into_iter`\n-\n-error[E0277]: `&str` is not an iterator\n- --> src/main.rs:5:16\n-  |\n-5 |     for foo in \"\" {}\n-  |                ^^ `&str` is not an iterator\n-  |\n-  = note: call `.chars()` or `.bytes() on `&str`\n-  = help: the trait `std::iter::Iterator` is not implemented for `&str`\n-  = note: required by `std::iter::IntoIterator::into_iter`\n-```\n-\n-If you need to filter on multiple attributes, you can use `all`, `any` or\n-`not` in the following way:\n-\n-```rust,compile_fail\n-#[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"&str\", T=\"std::string::String\"),\n-        note=\"you can coerce a `{T}` into a `{Self}` by writing `&*variable`\"\n-    )\n-)]\n-pub trait From<T>: Sized { /* ... */ }\n-```"}, {"sha": "1e74652a890f6e48b73aa4016d341921e430fcde", "filename": "src/doc/unstable-book/src/language-features/re-rebalance-coherence.md", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/969b74144641bf1c8ae5aba0581f4b52a4c15bac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fre-rebalance-coherence.md", "raw_url": "https://github.com/rust-lang/rust/raw/969b74144641bf1c8ae5aba0581f4b52a4c15bac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fre-rebalance-coherence.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fre-rebalance-coherence.md?ref=969b74144641bf1c8ae5aba0581f4b52a4c15bac", "patch": "@@ -1,23 +0,0 @@\n-# `re_rebalance_coherence`\n-\n-The tracking issue for this feature is: [#55437]\n-\n-[#55437]: https://github.com/rust-lang/rust/issues/55437\n-\n-------------------------\n-\n-The `re_rebalance_coherence` feature tweaks the rules regarding which trait\n-impls are allowed in crates.\n-The following rule is used:\n-\n-Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an impl is valid only if at\n-least one of the following is true:\n-- `Trait` is a local trait\n-- All of\n-  - At least one of the types `T0..=Tn` must be a local type. Let `Ti` be the\n-    first such type.\n-  - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti` (excluding\n-    `Ti`)\n-\n-\n-See the [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2451-re-rebalancing-coherence.md) for details."}, {"sha": "39c24fb10e590d7dc00b3663d33c5ea270909d8d", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -14,8 +14,7 @@\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n TEMPLATE = \"\"\"\\\n-// ignore-x86\n-// ^ due to stderr output differences\n+// ignore-x86 FIXME: missing sysroot spans (#53081)\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}"}, {"sha": "a0c9263673d74e4a743cbfc89f47ca6ac9bc0d14", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -90,7 +90,7 @@ impl<T> Clone for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     // We do *not* exclusively own the entire list here, references to node's `element`\n-    // have been handed out by the iterator!  So be careful when using this; the methods\n+    // have been handed out by the iterator! So be careful when using this; the methods\n     // called must be aware that there can be aliasing pointers to `element`.\n     list: &'a mut LinkedList<T>,\n     head: Option<NonNull<Node<T>>>,"}, {"sha": "7795083e0580cc2d8f2fbff8081a60cd4b85c897", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -835,7 +835,8 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Shortens the `VecDeque`, dropping excess elements from the back.\n+    /// Shortens the `VecDeque`, keeping the first `len` elements and dropping\n+    /// the rest.\n     ///\n     /// If `len` is greater than the `VecDeque`'s current length, this has no\n     /// effect.\n@@ -855,8 +856,31 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n-        for _ in len..self.len() {\n-            self.pop_back();\n+        // Safe because:\n+        //\n+        // * Any slice passed to `drop_in_place` is valid; the second case has\n+        //   `len <= front.len()` and returning on `len > self.len()` ensures\n+        //   `begin <= back.len()` in the first case\n+        // * The head of the VecDeque is moved before calling `drop_in_place`,\n+        //   so no value is dropped twice if `drop_in_place` panics\n+        unsafe {\n+            if len > self.len() {\n+                return;\n+            }\n+            let num_dropped = self.len() - len;\n+            let (front, back) = self.as_mut_slices();\n+            if len > front.len() {\n+                let begin = len - front.len();\n+                let drop_back = back.get_unchecked_mut(begin..) as *mut _;\n+                self.head = self.wrap_sub(self.head, num_dropped);\n+                ptr::drop_in_place(drop_back);\n+            } else {\n+                let drop_back = back as *mut _;\n+                let drop_front = front.get_unchecked_mut(len..) as *mut _;\n+                self.head = self.wrap_sub(self.head, num_dropped);\n+                ptr::drop_in_place(drop_front);\n+                ptr::drop_in_place(drop_back);\n+            }\n         }\n     }\n \n@@ -1117,7 +1141,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n-        self.drain(..);\n+        self.truncate(0);\n     }\n \n     /// Returns `true` if the `VecDeque` contains an element equal to the"}, {"sha": "09009ff516ac8b5ba59678a9da1439ba5ccb7771", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -384,6 +384,41 @@ fn test_clone_from() {\n     }\n }\n \n+#[test]\n+fn test_vec_deque_truncate_drop() {\n+    static mut DROPS: u32 = 0;\n+    #[derive(Clone)]\n+    struct Elem(i32);\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let v = vec![Elem(1), Elem(2), Elem(3), Elem(4), Elem(5)];\n+    for push_front in 0..=v.len() {\n+        let v = v.clone();\n+        let mut tester = VecDeque::with_capacity(5);\n+        for (index, elem) in v.into_iter().enumerate() {\n+            if index < push_front {\n+                tester.push_front(elem);\n+            } else {\n+                tester.push_back(elem);\n+            }\n+        }\n+        assert_eq!(unsafe { DROPS }, 0);\n+        tester.truncate(3);\n+        assert_eq!(unsafe { DROPS }, 2);\n+        tester.truncate(0);\n+        assert_eq!(unsafe { DROPS }, 5);\n+        unsafe {\n+            DROPS = 0;\n+        }\n+    }\n+}\n+\n #[test]\n fn issue_53529() {\n     use crate::boxed::Box;"}, {"sha": "ddfa6797a5754639a94fae573fe72739732781d9", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -116,7 +116,7 @@\n #![feature(unsize)]\n #![feature(unsized_locals)]\n #![feature(allocator_internals)]\n-#![feature(on_unimplemented)]\n+#![cfg_attr(bootstrap, feature(on_unimplemented))]\n #![feature(rustc_const_unstable)]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]"}, {"sha": "a11f9e8c145799c707f009cbbf0552230fd2bd5f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -280,7 +280,7 @@ struct RcBox<T: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: NonNull<RcBox<T>>,\n-    phantom: PhantomData<T>,\n+    phantom: PhantomData<RcBox<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f7dff4c21f7c4343bdb79759ecf7a4755d38b720", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -687,7 +687,7 @@ impl String {\n     /// checked:\n     ///\n     /// * The memory at `ptr` needs to have been previously allocated by the\n-    ///   same allocator the standard library uses.\n+    ///   same allocator the standard library uses, with a required alignment of exactly 1.\n     /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the correct value.\n     ///"}, {"sha": "4b10f089c2950f3ad4213e686e60ac1ba456628d", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -195,7 +195,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: NonNull<ArcInner<T>>,\n-    phantom: PhantomData<T>,\n+    phantom: PhantomData<ArcInner<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5158aab8b7dc5c21cca20080e6ffd0f3e374ba17", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -10,4 +10,4 @@ path = \"lib.rs\"\n \n [dependencies]\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "1b06baeb711c2293b863c390e62d3298afc0ee8d", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,7 @@\n //! Memory allocation APIs\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use crate::cmp;"}, {"sha": "39a5dd7263ccfcbdcb8ad9fdda0446a649ea5d03", "filename": "src/libcore/any.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -182,6 +182,7 @@ impl dyn Any {\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n+            // SAFETY: just checked whether we are pointing to the correct type\n             unsafe {\n                 Some(&*(self as *const dyn Any as *const T))\n             }\n@@ -217,6 +218,7 @@ impl dyn Any {\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n+            // SAFETY: just checked whether we are pointing to the correct type\n             unsafe {\n                 Some(&mut *(self as *mut dyn Any as *mut T))\n             }\n@@ -424,7 +426,11 @@ impl TypeId {\n     #[rustc_const_unstable(feature=\"const_type_id\")]\n     pub const fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n+            #[cfg(bootstrap)]\n+            // SAFETY: going away soon\n             t: unsafe { intrinsics::type_id::<T>() },\n+            #[cfg(not(bootstrap))]\n+            t: intrinsics::type_id::<T>(),\n         }\n     }\n }"}, {"sha": "307e9b90ee2c0cfe1f62e6f875867796453534ea", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -51,7 +51,7 @@ where\n     /// iterator (either via `IntoIterator` for arrays or via another way).\n     #[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n     pub fn new(array: [T; N]) -> Self {\n-        // The transmute here is actually safe. The docs of `MaybeUninit`\n+        // SAFETY: The transmute here is actually safe. The docs of `MaybeUninit`\n         // promise:\n         //\n         // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n@@ -84,10 +84,10 @@ where\n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n     fn as_slice(&self) -> &[T] {\n-        // This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        let slice = &self.data[self.alive.clone()];\n+        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n         // the size and alignment of `T`. Furthermore, we know that all\n         // elements within `alive` are properly initialized.\n-        let slice = &self.data[self.alive.clone()];\n         unsafe {\n             mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n         }\n@@ -117,7 +117,8 @@ where\n         let idx = self.alive.start;\n         self.alive.start += 1;\n \n-        // Read the element from the array. This is safe: `idx` is an index\n+        // Read the element from the array.\n+        // SAFETY: This is safe: `idx` is an index\n         // into the \"alive\" region of the array. Reading this element means\n         // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n         // `idx` was the start of the alive-zone, the alive zone is now\n@@ -163,7 +164,8 @@ where\n         // + 1]`.\n         self.alive.end -= 1;\n \n-        // Read the element from the array. This is safe: `alive.end` is an\n+        // Read the element from the array.\n+        // SAFETY: This is safe: `alive.end` is an\n         // index into the \"alive\" region of the array. Compare the previous\n         // comment that states that the alive region is\n         // `data[alive.start..alive.end + 1]`. Reading this element means that\n@@ -226,6 +228,7 @@ where\n     [T; N]: LengthAtMost32,\n {\n     fn clone(&self) -> Self {\n+        // SAFETY: each point of unsafety is documented inside the unsafe block\n         unsafe {\n             // This creates a new uninitialized array. Note that the `assume_init`\n             // refers to the array, not the individual elements. And it is Ok if"}, {"sha": "74a7d062d3f4afe37dede82858bdd864c05671da", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -156,6 +156,7 @@ where\n     fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_ptr() as *const [T; N];\n+            // SAFETY: ok because we just checked that the length fits\n             unsafe { Ok(&*ptr) }\n         } else {\n             Err(TryFromSliceError(()))\n@@ -173,6 +174,7 @@ where\n     fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_mut_ptr() as *mut [T; N];\n+            // SAFETY: ok because we just checked that the length fits\n             unsafe { Ok(&mut *ptr) }\n         } else {\n             Err(TryFromSliceError(()))"}, {"sha": "9b588525bd6982775644f7035e3641141388ebe6", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -135,6 +135,7 @@ impl FusedIterator for EscapeDefault {}\n #[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\n impl fmt::Display for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // SAFETY: ok because `escape_default` created only valid utf-8 data\n         f.write_str(unsafe { from_utf8_unchecked(&self.data[self.range.clone()]) })\n     }\n }"}, {"sha": "e921dd1ba0636bec010bacdd41ed3cece7f457ec", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -118,6 +118,7 @@ benches! {\n     }\n \n     fn case07_fake_simd_u32(bytes: &mut [u8]) {\n+        // SAFETY: transmuting a sequence of `u8` to `u32` is always fine\n         let (before, aligned, after) = unsafe {\n             bytes.align_to_mut::<u32>()\n         };\n@@ -142,6 +143,7 @@ benches! {\n     }\n \n     fn case08_fake_simd_u64(bytes: &mut [u8]) {\n+        // SAFETY: transmuting a sequence of `u8` to `u64` is always fine\n         let (before, aligned, after) = unsafe {\n             bytes.align_to_mut::<u64>()\n         };"}, {"sha": "87d8e7aff058dc284c4a4da4ae22e2d858262047", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -137,9 +137,11 @@\n //! use std::cell::Cell;\n //! use std::ptr::NonNull;\n //! use std::intrinsics::abort;\n+//! use std::marker::PhantomData;\n //!\n //! struct Rc<T: ?Sized> {\n-//!     ptr: NonNull<RcBox<T>>\n+//!     ptr: NonNull<RcBox<T>>,\n+//!     phantom: PhantomData<RcBox<T>>,\n //! }\n //!\n //! struct RcBox<T: ?Sized> {\n@@ -151,7 +153,10 @@\n //! impl<T: ?Sized> Clone for Rc<T> {\n //!     fn clone(&self) -> Rc<T> {\n //!         self.inc_strong();\n-//!         Rc { ptr: self.ptr }\n+//!         Rc {\n+//!             ptr: self.ptr,\n+//!             phantom: PhantomData,\n+//!         }\n //!     }\n //! }\n //!\n@@ -182,6 +187,8 @@\n //! ```\n //!\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering;"}, {"sha": "28f520744956135539159da9449d148c0833d0b6", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -224,6 +224,7 @@ impl TryFrom<u32> for char {\n         if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n             Err(CharTryFromError(()))\n         } else {\n+            // SAFETY: checked that it's a legal unicode value\n             Ok(unsafe { from_u32_unchecked(i) })\n         }\n     }"}, {"sha": "ae09251c776de4e9d2b352054b6aec9b255b5773", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -87,7 +87,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n         };\n \n         if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n+            // SAFETY: not a surrogate\n             Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n         } else if u >= 0xDC00 {\n             // a trailing surrogate\n@@ -107,6 +107,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n \n             // all ok, so lets decode it.\n             let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            // SAFETY: we checked that it's a legal unicode value\n             Some(Ok(unsafe { from_u32_unchecked(c) }))\n         }\n     }"}, {"sha": "c048bab287dd2aa0408f639689ce19fb4622f105", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -438,6 +438,7 @@ impl char {\n     #[inline]\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n+        // SAFETY: each arm checks the size of the slice and only uses `get_unchecked` unsafe ops\n         unsafe {\n             let len = if code < MAX_ONE_B && !dst.is_empty() {\n                 *dst.get_unchecked_mut(0) = code as u8;\n@@ -507,6 +508,7 @@ impl char {\n     #[inline]\n     pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n         let mut code = self as u32;\n+        // SAFETY: each arm checks whether there are enough bits to write into\n         unsafe {\n             if (code & 0xFFFF) == code && !dst.is_empty() {\n                 // The BMP falls through (assuming non-surrogate, as it should)"}, {"sha": "5058e58d0eb9cb6fb1f4c5384342a457d58e748c", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -205,11 +205,12 @@ pub trait AsMut<T: ?Sized> {\n /// A value-to-value conversion that consumes the input value. The\n /// opposite of [`From`].\n ///\n-/// One should only implement [`Into`] if a conversion to a type outside the current crate is\n-/// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n-/// implementing [`From`] automatically provides one with a implementation of [`Into`] thanks to\n-/// the blanket implementation in the standard library. [`From`] cannot do these type of\n-/// conversions because of Rust's orphaning rules.\n+/// One should avoid implementing [`Into`] and implement [`From`] instead.\n+/// Implementing [`From`] automatically provides one with an implementation of [`Into`]\n+/// thanks to the blanket implementation in the standard library.\n+///\n+/// Prefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\n+/// to ensure that types that only implement [`Into`] can be used as well.\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n ///\n@@ -218,23 +219,22 @@ pub trait AsMut<T: ?Sized> {\n /// - [`From`]`<T> for U` implies `Into<U> for T`\n /// - [`Into`] is reflexive, which means that `Into<T> for T` is implemented\n ///\n-/// # Implementing [`Into`] for conversions to external types\n+/// # Implementing [`Into`] for conversions to external types in old versions of Rust\n ///\n-/// If the destination type is not part of the current crate\n-/// then you can't implement [`From`] directly.\n+/// Prior to Rust 1.40, if the destination type was not part of the current crate\n+/// then you couldn't implement [`From`] directly.\n /// For example, take this code:\n ///\n-/// ```compile_fail\n+/// ```\n /// struct Wrapper<T>(Vec<T>);\n /// impl<T> From<Wrapper<T>> for Vec<T> {\n ///     fn from(w: Wrapper<T>) -> Vec<T> {\n ///         w.0\n ///     }\n /// }\n /// ```\n-/// This will fail to compile because we cannot implement a trait for a type\n-/// if both the trait and the type are not defined by the current crate.\n-/// This is due to Rust's orphaning rules. To bypass this, you can implement [`Into`] directly:\n+/// This will fail to compile in older versions of the language because Rust's orphaning rules\n+/// used to be a little bit more strict. To bypass this, you could implement [`Into`] directly:\n ///\n /// ```\n /// struct Wrapper<T>(Vec<T>);\n@@ -249,9 +249,6 @@ pub trait AsMut<T: ?Sized> {\n /// (as [`From`] does with [`Into`]). Therefore, you should always try to implement [`From`]\n /// and then fall back to [`Into`] if [`From`] can't be implemented.\n ///\n-/// Prefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\n-/// to ensure that types that only implement [`Into`] can be used as well.\n-///\n /// # Examples\n ///\n /// [`String`] implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>`:"}, {"sha": "499dd0facd38c6ba47948122a1ddc3313b29585c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -315,6 +315,7 @@ impl<'f> Clone for VaListImpl<'f> {\n     #[inline]\n     fn clone(&self) -> Self {\n         let mut dest = crate::mem::MaybeUninit::uninit();\n+        // SAFETY: we write to the `MaybeUninit`, thus it is initialized and `assume_init` is legal\n         unsafe {\n             va_copy(dest.as_mut_ptr(), self);\n             dest.assume_init()"}, {"sha": "b52b56b1bdbc28f7cb0d5d5dfcbbe67e0108d668", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2,6 +2,8 @@ use crate::fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n+// ignore-tidy-undocumented-unsafe\n+\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]"}, {"sha": "5a039144f667fe7ec20cabacfa4cd1f8cf1afca3", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,7 @@\n //! Utilities for formatting and printing strings.\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};"}, {"sha": "3c7aefc090f8ede41a3478f17f17b675912ffa3a", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,7 @@\n //! Integer and floating-point number formatting\n \n+// ignore-tidy-undocumented-unsafe\n+\n \n use crate::fmt;\n use crate::ops::{Div, Rem, Sub};"}, {"sha": "0082363692df67572c8c9e86d806e1d2e7a71a0d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -79,6 +79,8 @@\n //! }\n //! ```\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;"}, {"sha": "194d9e6e2f8ad498da7873b60a7a0ec90cab0e0f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,7 @@\n //! An implementation of SipHash.\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![allow(deprecated)] // the types in this module are deprecated\n \n use crate::marker::PhantomData;"}, {"sha": "f68a3e5a76fd74b0e5324444bb76165387847dbc", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2,6 +2,8 @@\n \n //! Hints to compiler that affects how code should be emitted or optimized.\n \n+// ignore-tidy-undocumented-unsafe\n+\n use crate::intrinsics;\n \n /// Informs the compiler that this point in the code is not reachable, enabling"}, {"sha": "39d571006e66a154fc7a6dad0a69bd6f27e5b2a3", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -517,8 +517,18 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n         // overflow handling\n         loop {\n             let mul = n.checked_mul(step);\n-            if unsafe { intrinsics::likely(mul.is_some()) } {\n-                return self.iter.nth(mul.unwrap() - 1);\n+            #[cfg(bootstrap)]\n+            {\n+                // SAFETY: going away soon\n+                if unsafe { intrinsics::likely(mul.is_some()) } {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n+            }\n+            #[cfg(not(bootstrap))]\n+            {\n+                if intrinsics::likely(mul.is_some()) {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n             }\n             let div_n = usize::MAX / n;\n             let div_step = usize::MAX / step;"}, {"sha": "14d9d5499b88033010c7d8944ee83ff22911d672", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n \n use super::super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};"}, {"sha": "bbdb169cac0fc89b0052d44266172851f9abd462", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -205,6 +205,7 @@ pub trait FromIterator<A>: Sized {\n ///         .collect()\n /// }\n /// ```\n+#[rustc_diagnostic_item = \"IntoIterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n     /// The type of the elements being iterated over."}, {"sha": "ca431627147a8a8ff519fdcf4aec0bab2ae66bd7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -89,7 +89,7 @@\n #![feature(nll)]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n-#![feature(on_unimplemented)]\n+#![cfg_attr(bootstrap, feature(on_unimplemented))]\n #![feature(optin_builtin_traits)]\n #![feature(prelude_import)]\n #![feature(repr_simd, platform_intrinsics)]"}, {"sha": "726d187d2e98130bbed1df5ab3fc5019e24a8844", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,31 +26,29 @@ macro_rules! panic {\n /// For details, see `std::macros`.\n #[cfg(not(bootstrap))]\n #[macro_export]\n-#[allow_internal_unstable(core_panic, panic_internals)]\n+#[allow_internal_unstable(core_panic,\n+    // FIXME(anp, eddyb) `core_intrinsics` is used here to allow calling\n+    // the `caller_location` intrinsic, but once  `#[track_caller]` is implemented,\n+    // `panicking::{panic, panic_fmt}` can use that instead of a `Location` argument.\n+    core_intrinsics,\n+)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n-    ($msg:expr) => ({\n-        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n-            $crate::file!(),\n-            $crate::line!(),\n-            $crate::column!(),\n-        );\n-        $crate::panicking::panic($msg, LOC)\n-    });\n+    ($msg:expr) => (\n+        $crate::panicking::panic($msg, $crate::intrinsics::caller_location())\n+    );\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n-    ($fmt:expr, $($arg:tt)+) => ({\n-        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n-            $crate::file!(),\n-            $crate::line!(),\n-            $crate::column!(),\n-        );\n-        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+), LOC)\n-    });\n+    ($fmt:expr, $($arg:tt)+) => (\n+        $crate::panicking::panic_fmt(\n+            $crate::format_args!($fmt, $($arg)+),\n+            $crate::intrinsics::caller_location(),\n+        )\n+    );\n }\n \n /// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n@@ -1276,6 +1274,10 @@ pub(crate) mod builtin {\n     }\n \n     /// Inline assembly.\n+    ///\n+    /// Read the [unstable book] for the usage.\n+    ///\n+    /// [unstable book]: ../unstable-book/library-features/asm.html\n     #[unstable(feature = \"asm\", issue = \"29722\",\n                reason = \"inline assembly is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]"}, {"sha": "e05b40052ee769cf81e05b2be117807fc24ac7e0", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 227, "deletions": 8, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,6 +1,8 @@\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// A wrapper type to construct uninitialized instances of `T`.\n ///\n /// # Initialization invariant\n@@ -254,10 +256,48 @@ impl<T> MaybeUninit<T> {\n     /// [type]: union.MaybeUninit.html\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n+    #[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"maybe_uninit_uninit\")]\n     pub const fn uninit() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n+    /// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n+    ///\n+    /// Note: in a future Rust version this method may become unnecessary\n+    /// when array literal syntax allows\n+    /// [repeating const expressions](https://github.com/rust-lang/rust/issues/49147).\n+    /// The example below could then use `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice_assume_init)]\n+    ///\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// extern \"C\" {\n+    ///     fn read_into_buffer(ptr: *mut u8, max_len: usize) -> usize;\n+    /// }\n+    ///\n+    /// /// Returns a (possibly smaller) slice of data that was actually read\n+    /// fn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n+    ///     unsafe {\n+    ///         let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n+    ///         MaybeUninit::slice_get_ref(&buf[..len])\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n+    /// let data = read(&mut buf);\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"0\")]\n+    #[inline(always)]\n+    pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n+        unsafe {\n+            MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init()\n+        }\n+    }\n+\n     /// A promotable constant, equivalent to `uninit()`.\n     #[unstable(feature = \"internal_uninit_const\", issue = \"0\",\n         reason = \"hack to work around promotability\")]\n@@ -300,6 +340,7 @@ impl<T> MaybeUninit<T> {\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline]\n+    #[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"maybe_uninit_zeroed\")]\n     pub fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n         unsafe {\n@@ -440,6 +481,7 @@ impl<T> MaybeUninit<T> {\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n+    #[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"assume_init\")]\n     pub unsafe fn assume_init(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n@@ -509,35 +551,212 @@ impl<T> MaybeUninit<T> {\n         self.as_ptr().read()\n     }\n \n-    /// Gets a reference to the contained value.\n+    /// Gets a shared reference to the contained value.\n+    ///\n+    /// This can be useful when we want to access a `MaybeUninit` that has been\n+    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n+    /// of `.assume_init()`).\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n+    /// is in an initialized state.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ### Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// // Initialize `x`:\n+    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n+    /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n+    /// // create a shared reference to it:\n+    /// let x: &Vec<u32> = unsafe {\n+    ///     // Safety: `x` has been initialized.\n+    ///     x.get_ref()\n+    /// };\n+    /// assert_eq!(x, &vec![1, 2, 3]);\n+    /// ```\n+    ///\n+    /// ### *Incorrect* usages of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{cell::Cell, mem::MaybeUninit};\n+    ///\n+    /// let b = MaybeUninit::<Cell<bool>>::uninit();\n+    /// // Initialize the `MaybeUninit` using `Cell::set`:\n+    /// unsafe {\n+    ///     b.get_ref().set(true);\n+    ///  // ^^^^^^^^^^^\n+    ///  // Reference to an uninitialized `Cell<bool>`: UB!\n+    /// }\n+    /// ```\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n+        intrinsics::panic_if_uninhabited::<T>();\n         &*self.value\n     }\n \n-    /// Gets a mutable reference to the contained value.\n+    /// Gets a mutable (unique) reference to the contained value.\n+    ///\n+    /// This can be useful when we want to access a `MaybeUninit` that has been\n+    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n+    /// of `.assume_init()`).\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n+    /// is in an initialized state. For instance, `.get_mut()` cannot be used to\n+    /// initialize a `MaybeUninit`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ### Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// # unsafe extern \"C\" fn initialize_buffer(buf: *mut [u8; 2048]) { *buf = [0; 2048] }\n+    /// # #[cfg(FALSE)]\n+    /// extern \"C\" {\n+    ///     /// Initializes *all* the bytes of the input buffer.\n+    ///     fn initialize_buffer(buf: *mut [u8; 2048]);\n+    /// }\n+    ///\n+    /// let mut buf = MaybeUninit::<[u8; 2048]>::uninit();\n+    ///\n+    /// // Initialize `buf`:\n+    /// unsafe { initialize_buffer(buf.as_mut_ptr()); }\n+    /// // Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n+    /// // However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.\n+    /// // To assert our buffer has been initialized without copying it, we upgrade\n+    /// // the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:\n+    /// let buf: &mut [u8; 2048] = unsafe {\n+    ///     // Safety: `buf` has been initialized.\n+    ///     buf.get_mut()\n+    /// };\n+    ///\n+    /// // Now we can use `buf` as a normal slice:\n+    /// buf.sort_unstable();\n+    /// assert!(\n+    ///     buf.chunks(2).all(|chunk| chunk[0] <= chunk[1]),\n+    ///     \"buffer is sorted\",\n+    /// );\n+    /// ```\n+    ///\n+    /// ### *Incorrect* usages of this method:\n+    ///\n+    /// You cannot use `.get_mut()` to initialize a value:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut b = MaybeUninit::<bool>::uninit();\n+    /// unsafe {\n+    ///     *b.get_mut() = true;\n+    ///     // We have created a (mutable) reference to an uninitialized `bool`!\n+    ///     // This is undefined behavior.\n+    /// }\n+    /// ```\n+    ///\n+    /// For instance, you cannot [`Read`] into an uninitialized buffer:\n+    ///\n+    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{io, mem::MaybeUninit};\n+    ///\n+    /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n+    /// {\n+    ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n+    ///     reader.read_exact(unsafe { buffer.get_mut() })?;\n+    ///                             // ^^^^^^^^^^^^^^^^\n+    ///                             // (mutable) reference to uninitialized memory!\n+    ///                             // This is undefined behavior.\n+    ///     Ok(unsafe { buffer.assume_init() })\n+    /// }\n+    /// ```\n+    ///\n+    /// Nor can you use direct field access to do field-by-field gradual initialization:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{mem::MaybeUninit, ptr};\n+    ///\n+    /// struct Foo {\n+    ///     a: u32,\n+    ///     b: u8,\n+    /// }\n+    ///\n+    /// let foo: Foo = unsafe {\n+    ///     let mut foo = MaybeUninit::<Foo>::uninit();\n+    ///     ptr::write(&mut foo.get_mut().a as *mut u32, 1337);\n+    ///                  // ^^^^^^^^^^^^^\n+    ///                  // (mutable) reference to uninitialized memory!\n+    ///                  // This is undefined behavior.\n+    ///     ptr::write(&mut foo.get_mut().b as *mut u8, 42);\n+    ///                  // ^^^^^^^^^^^^^\n+    ///                  // (mutable) reference to uninitialized memory!\n+    ///                  // This is undefined behavior.\n+    ///     foo.assume_init()\n+    /// };\n+    /// ```\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n+        intrinsics::panic_if_uninhabited::<T>();\n         &mut *self.value\n     }\n \n+    /// Assuming all the elements are initialized, get a slice to them.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n+    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"0\")]\n+    #[inline(always)]\n+    pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n+        &*(slice as *const [Self] as *const [T])\n+    }\n+\n+    /// Assuming all the elements are initialized, get a mutable slice to them.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n+    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"0\")]\n+    #[inline(always)]\n+    pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n+        &mut *(slice as *mut [Self] as *mut [T])\n+    }\n+\n     /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]"}, {"sha": "dc7c36ff03c4e07062bf06e34103ce38be849160", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -93,6 +93,8 @@ pub fn forget<T>(t: T) {\n #[inline]\n #[unstable(feature = \"forget_unsized\", issue = \"0\")]\n pub fn forget_unsized<T: ?Sized>(t: T) {\n+    // SAFETY: the forget intrinsic could be safe, but there's no point in making it safe since\n+    // we'll be implementing this function soon via `ManuallyDrop`\n     unsafe { intrinsics::forget(t) }\n }\n \n@@ -266,7 +268,11 @@ pub const fn size_of<T>() -> usize {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    #[cfg(bootstrap)]\n+    // SAFETY: going away soon\n     unsafe { intrinsics::size_of_val(val) }\n+    #[cfg(not(bootstrap))]\n+    intrinsics::size_of_val(val)\n }\n \n /// Returns the [ABI]-required minimum alignment of a type.\n@@ -310,7 +316,11 @@ pub fn min_align_of<T>() -> usize {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    #[cfg(bootstrap)]\n+    // SAFETY: going away soon\n     unsafe { intrinsics::min_align_of_val(val) }\n+    #[cfg(not(bootstrap))]\n+    intrinsics::min_align_of_val(val)\n }\n \n /// Returns the [ABI]-required minimum alignment of a type.\n@@ -350,8 +360,9 @@ pub const fn align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n+    min_align_of_val(val)\n }\n \n /// Returns `true` if dropping values of type `T` matters.\n@@ -457,6 +468,7 @@ pub const fn needs_drop<T>() -> bool {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated_in_future)]\n #[allow(deprecated)]\n+#[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"mem_zeroed\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::init()\n@@ -485,6 +497,7 @@ pub unsafe fn zeroed<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated_in_future)]\n #[allow(deprecated)]\n+#[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"mem_uninitialized\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::uninit()\n@@ -508,6 +521,8 @@ pub unsafe fn uninitialized<T>() -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n+    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the\n+    // constraints on `ptr::swap_nonoverlapping_one`\n     unsafe {\n         ptr::swap_nonoverlapping_one(x, y);\n     }\n@@ -822,7 +837,11 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// ```\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    #[cfg(bootstrap)]\n+    // SAFETY: going away soon\n     unsafe {\n         Discriminant(intrinsics::discriminant_value(v), PhantomData)\n     }\n+    #[cfg(not(bootstrap))]\n+    Discriminant(intrinsics::discriminant_value(v), PhantomData)\n }"}, {"sha": "641463026261d9525264f2c3324473b74ad53d30", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -58,6 +58,8 @@ mod fpu_precision {\n     pub struct FPUControlWord(u16);\n \n     fn set_cw(cw: u16) {\n+        // SAFETY: the `fldcw` instruction has been audited to be able to work correctly with\n+        // any `u16`\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n     }\n \n@@ -74,6 +76,8 @@ mod fpu_precision {\n \n         // Get the original value of the control word to restore it later, when the\n         // `FPUControlWord` structure is dropped\n+        // SAFETY: the `fnstcw` instruction has been audited to be able to work correctly with\n+        // any `u16`\n         unsafe { asm!(\"fnstcw $0\" : \"=*m\" (&cw) ::: \"volatile\") }\n \n         // Set the control word to the desired precision. This is achieved by masking away the old"}, {"sha": "7662bba6b5e139deaf01f225fce4a2eb5d8b6181", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -414,6 +414,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u32 {\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute to it\n         unsafe { mem::transmute(self) }\n     }\n \n@@ -456,6 +457,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u32) -> Self {\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { mem::transmute(v) }\n     }"}, {"sha": "4a2a35dfb099928ef79a262b8e3b1f779eea845e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -427,6 +427,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u64 {\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute to it\n         unsafe { mem::transmute(self) }\n     }\n \n@@ -469,6 +470,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u64) -> Self {\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { mem::transmute(v) }\n     }"}, {"sha": "b5d61a3fd4e786ca6b9beea4791407aa56bef29f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -71,6 +71,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n+                        // SAFETY: we just checked that there's no `0`\n                         Some(unsafe { $Ty(n) })\n                     } else {\n                         None\n@@ -234,7 +235,6 @@ depending on the target pointer size.\n \"}\n }\n \n-// `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n     ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n      $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n@@ -703,6 +703,7 @@ $EndFeature, \"\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n+                    // SAFETY: div by zero and by INT_MIN have been checked above\n                     Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n                 }\n             }\n@@ -759,6 +760,7 @@ $EndFeature, \"\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n+                    // SAFETY: div by zero and by INT_MIN have been checked above\n                     Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n                 }\n             }\n@@ -1329,6 +1331,8 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -1358,6 +1362,8 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -2113,6 +2119,8 @@ assert_eq!(\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n                 unsafe { mem::transmute(self) }\n             }\n         }\n@@ -2221,6 +2229,7 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                // SAFETY: integers are plain old datatypes so we can always transmute to them\n                 unsafe { mem::transmute(bytes) }\n             }\n         }\n@@ -2293,7 +2302,6 @@ impl isize {\n          usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n-// `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n         $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n@@ -2748,6 +2756,8 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n             pub fn checked_div(self, rhs: Self) -> Option<Self> {\n                 match rhs {\n                     0 => None,\n+                    // SAFETY: div by zero has been checked above and unsigned types have no other\n+                    // failure modes for division\n                     rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n                 }\n             }\n@@ -2799,6 +2809,8 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n                 if rhs == 0 {\n                     None\n                 } else {\n+                    // SAFETY: div by zero has been checked above and unsigned types have no other\n+                    // failure modes for division\n                     Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n                 }\n             }\n@@ -3248,6 +3260,8 @@ assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -3279,6 +3293,8 @@ assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -3775,11 +3791,11 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n         fn one_less_than_next_power_of_two(self) -> Self {\n             if self <= 1 { return 0; }\n \n-            // Because `p > 0`, it cannot consist entirely of leading zeros.\n+            let p = self - 1;\n+            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n             // That means the shift is always in-bounds, and some processors\n             // (such as intel pre-haswell) have more efficient ctlz\n             // intrinsics when the argument is non-zero.\n-            let p = self - 1;\n             let z = unsafe { intrinsics::ctlz_nonzero(p) };\n             <$SelfT>::max_value() >> z\n         }\n@@ -3925,6 +3941,8 @@ assert_eq!(\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n                 unsafe { mem::transmute(self) }\n             }\n         }\n@@ -4033,6 +4051,7 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                // SAFETY: integers are plain old datatypes so we can always transmute to them\n                 unsafe { mem::transmute(bytes) }\n             }\n         }"}, {"sha": "958f31c0fd22a824c39252b106906945c6288056", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -133,6 +133,8 @@\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n //! [`i32`]: ../../std/primitive.i32.html\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{FromIterator, FusedIterator, TrustedLen};"}, {"sha": "b88dc336097f33ce5739aac3d5811b90b3264ba3", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -20,6 +20,8 @@\n //! one function. Currently, the actual symbol is declared in the standard\n //! library, but the location of this may change over time.\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![allow(dead_code, missing_docs)]\n #![unstable(feature = \"core_panic\",\n             reason = \"internal details of the implementation of the `panic!` \\"}, {"sha": "1219fd09a9dfafda837a6fd27a1481cbc2070b74", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -552,6 +552,7 @@ impl<P: Deref> Pin<P> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(&self) -> Pin<&P::Target> {\n+        // SAFETY: see documentation on this function\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n \n@@ -610,6 +611,7 @@ impl<P: DerefMut> Pin<P> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n+        // SAFETY: see documentation on this function\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n "}, {"sha": "5a75730cf2bd4e14e43834e13835ba8ffda8f647", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -18,6 +18,10 @@\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n //! * All pointers (except for the null pointer) are valid for all operations of\n //!   [size zero][zst].\n+//! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n+//!   be *dereferencable*: the memory range of the given size starting at the pointer must all be\n+//!   within the bounds of a single allocated object. Note that in Rust,\n+//!   every (stack-allocated) variable is considered a separate allocated object.\n //! * All accesses performed by functions in this module are *non-atomic* in the sense\n //!   of [atomic operations] used to synchronize between threads. This means it is\n //!   undefined behavior to perform two concurrent accesses to the same location from different\n@@ -61,6 +65,8 @@\n //! [`write_volatile`]: ./fn.write_volatile.html\n //! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::intrinsics;\n@@ -221,10 +227,15 @@ pub(crate) struct FatPtr<T> {\n     pub(crate) len: usize,\n }\n \n-/// Forms a slice from a pointer and a length.\n+/// Forms a raw slice from a pointer and a length.\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n+/// This function is safe, but actually using the return value is unsafe.\n+/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n+///\n+/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+///\n /// # Examples\n ///\n /// ```rust\n@@ -243,12 +254,16 @@ pub fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n     unsafe { Repr { raw: FatPtr { data, len } }.rust }\n }\n \n-/// Performs the same functionality as [`from_raw_parts`], except that a\n-/// mutable slice is returned.\n+/// Performs the same functionality as [`slice_from_raw_parts`], except that a\n+/// raw mutable slice is returned, as opposed to a raw immutable slice.\n ///\n-/// See the documentation of [`from_raw_parts`] for more details.\n+/// See the documentation of [`slice_from_raw_parts`] for more details.\n ///\n-/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+/// This function is safe, but actually using the return value is unsafe.\n+/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n+///\n+/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n+/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n #[inline]\n #[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n pub fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {"}, {"sha": "7599991f0f15a78a49dd66c5bfc521cebdfc0d22", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -7,6 +7,8 @@ use crate::mem;\n use crate::ptr::Unique;\n use crate::cmp::Ordering;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using"}, {"sha": "11a3aed1ab41b945f51be27de8498be21d2c055d", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -5,6 +5,8 @@ use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n use crate::ptr::NonNull;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n /// of this wrapper owns the referent. Useful for building abstractions like\n /// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`."}, {"sha": "2a2169dd348c211ec14edac3e33e5f5c886ac54e", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,6 +1,8 @@\n // Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n use crate::mem;\n "}, {"sha": "c8fe9f98613150f2bf31d03e25b5d97d3d575e5d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,4 +1,5 @@\n // ignore-tidy-filelength\n+// ignore-tidy-undocumented-unsafe\n \n //! Slice management and manipulation.\n //!\n@@ -5272,18 +5273,24 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n ///\n /// # Safety\n ///\n-/// This function is unsafe as there is no guarantee that the given pointer is\n-/// valid for `len` elements, nor whether the lifetime inferred is a suitable\n-/// lifetime for the returned slice.\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// `data` must be non-null and aligned, even for zero-length slices. One\n-/// reason for this is that enum layout optimizations may rely on references\n-/// (including slices of any length) being aligned and non-null to distinguish\n-/// them from other data. You can obtain a pointer that is usable as `data`\n-/// for zero-length slices using [`NonNull::dangling()`].\n+/// * `data` must be [valid] for reads for `len * mem::size_of::<T>()` many bytes,\n+///   and it must be properly aligned. This means in particular:\n ///\n-/// The total size of the slice must be no larger than `isize::MAX` **bytes**\n-/// in memory. See the safety documentation of [`pointer::offset`].\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///     * `data` must be non-null and aligned even for zero-length slices. One\n+///       reason for this is that enum layout optimizations may rely on references\n+///       (including slices of any length) being aligned and non-null to distinguish\n+///       them from other data. You can obtain a pointer that is usable as `data`\n+///       for zero-length slices using [`NonNull::dangling()`].\n+///\n+/// * The memory referenced by the returned slice must not be mutated for the duration\n+///   of lifetime `'a`, except inside an `UnsafeCell`.\n+///\n+/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n ///\n /// # Caveat\n ///\n@@ -5305,35 +5312,53 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n /// assert_eq!(slice[0], 42);\n /// ```\n ///\n+/// [valid]: ../../std/ptr/index.html#safety\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-                  \"attempt to create slice covering half the address space\");\n+                  \"attempt to create slice covering at least half the address space\");\n     &*ptr::slice_from_raw_parts(data, len)\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n /// mutable slice is returned.\n ///\n-/// This function is unsafe for the same reasons as [`from_raw_parts`], as well\n-/// as not being able to provide a non-aliasing guarantee of the returned\n-/// mutable slice. `data` must be non-null and aligned even for zero-length\n-/// slices as with [`from_raw_parts`]. The total size of the slice must be no\n-/// larger than `isize::MAX` **bytes** in memory.\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `data` must be [valid] for writes for `len * mem::size_of::<T>()` many bytes,\n+///   and it must be properly aligned. This means in particular:\n ///\n-/// See the documentation of [`from_raw_parts`] for more details.\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///     * `data` must be non-null and aligned even for zero-length slices. One\n+///       reason for this is that enum layout optimizations may rely on references\n+///       (including slices of any length) being aligned and non-null to distinguish\n+///       them from other data. You can obtain a pointer that is usable as `data`\n+///       for zero-length slices using [`NonNull::dangling()`].\n ///\n+/// * The memory referenced by the returned slice must not be accessed through any other pointer\n+///   (not derived from the return value) for the duration of lifetime `'a`.\n+///   Both read and write accesses are forbidden.\n+///\n+/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n+///\n+/// [valid]: ../../std/ptr/index.html#safety\n+/// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n+/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n /// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-                  \"attempt to create slice covering half the address space\");\n+                  \"attempt to create slice covering at least half the address space\");\n     &mut *ptr::slice_from_raw_parts_mut(data, len)\n }\n "}, {"sha": "a719a51b61605b2c194c3894d6309c8056ba151b", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -6,6 +6,8 @@\n //! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n //! stable sorting implementation.\n \n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;"}, {"sha": "762de0489a9756e36e129cac371e370e0a786b21", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,6 +3,8 @@ use crate::str as core_str;\n use crate::fmt::{self, Write};\n use crate::mem;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"0\")]\n pub struct Utf8Lossy {"}, {"sha": "25b7eec5b33432ab5cb5689e0cf48d202d4e8999", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,4 +1,5 @@\n // ignore-tidy-filelength\n+// ignore-tidy-undocumented-unsafe\n \n //! String manipulation.\n //!"}, {"sha": "a494274118a74171dfbf50da47664bcb2ff3628e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,6 +3,8 @@\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![unstable(feature = \"pattern\",\n             reason = \"API not fully fleshed out and ready to be stabilized\",\n             issue = \"27721\")]"}, {"sha": "d311cb16b64d37250f66d9bbd56b2a83a3dd87db", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -112,6 +112,8 @@\n //! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]"}, {"sha": "a35897e9bc1ac4899bc9263fb432229549d52df1", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -85,6 +85,8 @@ fn ldexp_f64(a: f64, b: i32) -> f64 {\n     extern {\n         fn ldexp(x: f64, n: i32) -> f64;\n     }\n+    // SAFETY: assuming a correct `ldexp` has been supplied, the given arguments cannot possibly\n+    // cause undefined behavior\n     unsafe { ldexp(a, b) }\n }\n "}, {"sha": "57fc1a7b76075f35f283f761fc96c5eb6d9ba010", "filename": "src/libcore/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -920,7 +920,7 @@ impl fmt::Debug for Duration {\n             if end == 0 {\n                 write!(f, \"{}\", integer_part)\n             } else {\n-                // We are only writing ASCII digits into the buffer and it was\n+                // SAFETY: We are only writing ASCII digits into the buffer and it was\n                 // initialized with '0's, so it contains valid UTF8.\n                 let s = unsafe {\n                     crate::str::from_utf8_unchecked(&buf[..end])"}, {"sha": "24b19028ac1179e65cff77613606a4eb8666fd03", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -35,7 +35,7 @@ impl InnerOffset {\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Piece<'a> {\n     /// A literal string which should directly be emitted\n     String(&'a str),\n@@ -45,7 +45,7 @@ pub enum Piece<'a> {\n }\n \n /// Representation of an argument specification.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n     pub position: Position,\n@@ -54,7 +54,7 @@ pub struct Argument<'a> {\n }\n \n /// Specification for the formatting of an argument in the format string.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct FormatSpec<'a> {\n     /// Optionally specified character to fill alignment with.\n     pub fill: Option<char>,\n@@ -74,10 +74,12 @@ pub struct FormatSpec<'a> {\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n     pub ty: &'a str,\n+    /// The span of the descriptor string (for diagnostics).\n+    pub ty_span: Option<InnerSpan>,\n }\n \n /// Enum describing where an argument for a format can be located.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Position {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n@@ -97,7 +99,7 @@ impl Position {\n }\n \n /// Enum of alignments which are supported.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Alignment {\n     /// The value will be aligned to the left.\n     AlignLeft,\n@@ -111,7 +113,7 @@ pub enum Alignment {\n \n /// Various flags which can be applied to format strings. The meaning of these\n /// flags is defined by the formatters themselves.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Flag {\n     /// A `+` will be used to denote positive numbers.\n     FlagSignPlus,\n@@ -131,7 +133,7 @@ pub enum Flag {\n \n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Count {\n     /// The count is specified explicitly.\n     CountIs(usize),\n@@ -475,6 +477,7 @@ impl<'a> Parser<'a> {\n             width: CountImplied,\n             width_span: None,\n             ty: &self.input[..0],\n+            ty_span: None,\n         };\n         if !self.consume(':') {\n             return spec;\n@@ -548,6 +551,7 @@ impl<'a> Parser<'a> {\n                 spec.precision_span = sp;\n             }\n         }\n+        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n         // Optional radix followed by the actual format specifier\n         if self.consume('x') {\n             if self.consume('?') {\n@@ -567,6 +571,12 @@ impl<'a> Parser<'a> {\n             spec.ty = \"?\";\n         } else {\n             spec.ty = self.word();\n+            let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n+            if !spec.ty.is_empty() {\n+                spec.ty_span = ty_span_start\n+                    .and_then(|s| ty_span_end.map(|e| (s, e)))\n+                    .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+            }\n         }\n         spec\n     }"}, {"sha": "81359033eda29f7aa64ab5dee11e28d125468cb4", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n fn same(fmt: &'static str, p: &[Piece<'static>]) {\n     let parser = Parser::new(fmt, None, vec![], false);\n-    assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n+    assert_eq!(parser.collect::<Vec<Piece<'static>>>(), p);\n }\n \n fn fmtdflt() -> FormatSpec<'static> {\n@@ -15,6 +15,7 @@ fn fmtdflt() -> FormatSpec<'static> {\n         precision_span: None,\n         width_span: None,\n         ty: \"\",\n+        ty_span: None,\n     };\n }\n \n@@ -82,7 +83,7 @@ fn format_position_nothing_else() {\n #[test]\n fn format_type() {\n     same(\n-        \"{3:a}\",\n+        \"{3:x}\",\n         &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n@@ -93,7 +94,8 @@ fn format_type() {\n                 width: CountImplied,\n                 precision_span: None,\n                 width_span: None,\n-                ty: \"a\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n }\n@@ -112,6 +114,7 @@ fn format_align_fill() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n@@ -127,6 +130,7 @@ fn format_align_fill() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n@@ -142,6 +146,7 @@ fn format_align_fill() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"abcd\",\n+                ty_span: Some(InnerSpan::new(6, 10)),\n             },\n         })]);\n }\n@@ -150,7 +155,7 @@ fn format_counts() {\n     use syntax_pos::{GLOBALS, Globals, edition};\n     GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n     same(\n-        \"{:10s}\",\n+        \"{:10x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -161,11 +166,12 @@ fn format_counts() {\n                 width: CountIs(10),\n                 precision_span: None,\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:10$.10s}\",\n+        \"{:10$.10x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -176,11 +182,12 @@ fn format_counts() {\n                 width: CountIsParam(10),\n                 precision_span: None,\n                 width_span: Some(InnerSpan::new(3, 6)),\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:.*s}\",\n+        \"{:.*x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(1),\n             format: FormatSpec {\n@@ -191,11 +198,12 @@ fn format_counts() {\n                 width: CountImplied,\n                 precision_span: Some(InnerSpan::new(3, 5)),\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:.10$s}\",\n+        \"{:.10$x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -206,11 +214,12 @@ fn format_counts() {\n                 width: CountImplied,\n                 precision_span: Some(InnerSpan::new(3, 7)),\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"x\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n-        \"{:a$.b$s}\",\n+        \"{:a$.b$?}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n             format: FormatSpec {\n@@ -221,7 +230,8 @@ fn format_counts() {\n                 width: CountIsName(Symbol::intern(\"a\")),\n                 precision_span: None,\n                 width_span: None,\n-                ty: \"s\",\n+                ty: \"?\",\n+                ty_span: None,\n             },\n         })]);\n     });\n@@ -241,6 +251,7 @@ fn format_flags() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n     same(\n@@ -256,13 +267,14 @@ fn format_flags() {\n                 precision_span: None,\n                 width_span: None,\n                 ty: \"\",\n+                ty_span: None,\n             },\n         })]);\n }\n #[test]\n fn format_mixture() {\n     same(\n-        \"abcd {3:a} efg\",\n+        \"abcd {3:x} efg\",\n         &[\n             String(\"abcd \"),\n             NextArgument(Argument {\n@@ -275,7 +287,8 @@ fn format_mixture() {\n                     width: CountImplied,\n                     precision_span: None,\n                     width_span: None,\n-                    ty: \"a\",\n+                    ty: \"x\",\n+                    ty_span: None,\n                 },\n             }),\n             String(\" efg\"),"}, {"sha": "bc9dd2edaf21174b4588b66cf05e5951ef5c8278", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -21,6 +21,7 @@\n // Rust's \"try\" function, but if we're aborting on panics we just call the\n // function as there's nothing else we need to do here.\n #[rustc_std_internal_symbol]\n+#[allow(improper_ctypes)]\n pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                               data: *mut u8,\n                                               _data_ptr: *mut usize,"}, {"sha": "7de347446ada1c34b6088ee85357a93479f09851", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -69,6 +69,7 @@ mod dwarf;\n // hairy and tightly coupled, for more information see the compiler's\n // implementation of this.\n #[no_mangle]\n+#[allow(improper_ctypes)]\n pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                                   data: *mut u8,\n                                                   data_ptr: *mut usize,"}, {"sha": "92b94af75d75019502843ba9fbeeac0d591fb979", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -39,5 +39,5 @@ parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.4\""}, {"sha": "9b13a910c617453f08437b2284b47dbe4ad3ecc9", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -304,7 +304,7 @@ impl DropArena {\n         // Move the content to the arena by copying it and then forgetting\n         // the content of the SmallVec\n         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-        mem::forget(vec.drain());\n+        mem::forget(vec.drain(..));\n \n         // Record the destructors after doing the allocation as that may panic\n         // and would cause `object`'s destuctor to run twice if it was recorded before"}, {"sha": "cea790375fc3d89671c1cd91ced8ff0a1cc5e112", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -525,7 +525,7 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        tcx.crate_name(*self).as_str().to_string()\n+        tcx.crate_name(*self).to_string()\n     }\n }\n "}, {"sha": "f40b892a06bf24230a9132ede389d318023a8610", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -335,7 +335,7 @@ This works because `Box` is a pointer, so its size is well-known.\n \"##,\n \n E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate an\n+This error indicates that the compiler was unable to sensibly evaluate a\n constant expression that had to be evaluated. Attempting to divide by 0\n or causing integer overflow are two ways to induce this error. For example:\n \n@@ -607,7 +607,7 @@ position that needs that trait. For example, when the following code is\n compiled:\n \n ```compile_fail\n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n fn foo<T: Index<u8>>(x: T){}\n \n@@ -639,7 +639,7 @@ position that needs that trait. For example, when the following code is\n compiled:\n \n ```compile_fail\n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n fn foo<T: Index<u8>>(x: T){}\n \n@@ -669,7 +669,7 @@ position that needs that trait. For example, when the following code is\n compiled:\n \n ```compile_fail\n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n fn foo<T: Index<u8>>(x: T){}\n \n@@ -2336,6 +2336,7 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n+    E0703, // invalid ABI\n //  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported"}, {"sha": "025494e3fd7be01be3cc9734a1f1322654097b40", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -40,10 +40,10 @@ pub enum NonMacroAttrKind {\n     Tool,\n     /// Single-segment custom attribute registered by a derive macro (`#[serde(default)]`).\n     DeriveHelper,\n+    /// Single-segment custom attribute registered with `#[register_attr]`.\n+    Registered,\n     /// Single-segment custom attribute registered by a legacy plugin (`register_attribute`).\n     LegacyPluginHelper,\n-    /// Single-segment custom attribute not registered in any way (`#[my_attr]`).\n-    Custom,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n@@ -329,8 +329,24 @@ impl NonMacroAttrKind {\n             NonMacroAttrKind::Builtin => \"built-in attribute\",\n             NonMacroAttrKind::Tool => \"tool attribute\",\n             NonMacroAttrKind::DeriveHelper => \"derive helper attribute\",\n+            NonMacroAttrKind::Registered => \"explicitly registered attribute\",\n             NonMacroAttrKind::LegacyPluginHelper => \"legacy plugin helper attribute\",\n-            NonMacroAttrKind::Custom => \"custom attribute\",\n+        }\n+    }\n+\n+    pub fn article(self) -> &'static str {\n+        match self {\n+            NonMacroAttrKind::Registered => \"an\",\n+            _ => \"a\",\n+        }\n+    }\n+\n+    /// Users of some attributes cannot mark them as used, so they are considered always used.\n+    pub fn is_used(self) -> bool {\n+        match self {\n+            NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper => true,\n+            NonMacroAttrKind::Builtin | NonMacroAttrKind::Registered |\n+            NonMacroAttrKind::LegacyPluginHelper => false,\n         }\n     }\n }\n@@ -389,6 +405,7 @@ impl<Id> Res<Id> {\n     pub fn article(&self) -> &'static str {\n         match *self {\n             Res::Def(kind, _) => kind.article(),\n+            Res::NonMacroAttr(kind) => kind.article(),\n             Res::Err => \"an\",\n             _ => \"a\",\n         }"}, {"sha": "29e3f7132766ee27c10f97e21704f43762a31476", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -45,7 +45,7 @@ pub enum FnKind<'a> {\n     ItemFn(Ident, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n \n     /// `fn foo(&self)`\n-    Method(Ident, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n+    Method(Ident, &'a FnSig, Option<&'a Visibility>, &'a [Attribute]),\n \n     /// `|x, y| {}`\n     Closure(&'a [Attribute]),\n@@ -481,13 +481,13 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n-        ItemKind::Fn(ref declaration, header, ref generics, body_id) => {\n+        ItemKind::Fn(ref sig, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident,\n                                             generics,\n-                                            header,\n+                                            sig.header,\n                                             &item.vis,\n                                             &item.attrs),\n-                             declaration,\n+                             &sig.decl,\n                              body_id,\n                              item.span,\n                              item.hir_id)"}, {"sha": "2c8e14f2addff3b63b02d995bb49c7eb725ac5d8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 38, "deletions": 59, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -44,8 +44,7 @@ use crate::hir::def::{Namespace, Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::hir::ptr::P;\n use crate::lint;\n-use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-                    ELIDED_LIFETIMES_IN_PATHS};\n+use crate::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n use crate::middle::cstore::CrateStore;\n use crate::session::Session;\n use crate::session::config::nightly_options;\n@@ -65,9 +64,8 @@ use syntax::ast;\n use syntax::ptr::P as AstP;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::expand::SpecialDerives;\n use syntax::print::pprust;\n-use syntax::parse::token::{self, Nonterminal, Token};\n+use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::sess::ParseSess;\n use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n@@ -184,9 +182,9 @@ pub trait Resolver {\n         ns: Namespace,\n     ) -> (ast::Path, Res<NodeId>);\n \n-    fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n-\n     fn lint_buffer(&mut self) -> &mut lint::LintBuffer;\n+\n+    fn next_node_id(&mut self) -> NodeId;\n }\n \n type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n@@ -301,7 +299,6 @@ enum ParamMode {\n \n enum ParenthesizedGenericArgs {\n     Ok,\n-    Warn,\n     Err,\n }\n \n@@ -677,7 +674,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n-        self.lower_node_id(self.sess.next_node_id())\n+        let node_id = self.resolver.next_node_id();\n+        self.lower_node_id(node_id)\n     }\n \n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n@@ -786,7 +784,7 @@ impl<'a> LoweringContext<'a> {\n         hir_name: ParamName,\n         parent_index: DefIndex,\n     ) -> hir::GenericParam {\n-        let node_id = self.sess.next_node_id();\n+        let node_id = self.resolver.next_node_id();\n \n         // Get the name we'll use to make the def-path. Note\n         // that collisions are ok here and this shouldn't\n@@ -1000,14 +998,20 @@ impl<'a> LoweringContext<'a> {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n+        let kind = match attr.kind {\n+            AttrKind::Normal(ref item) => {\n+                AttrKind::Normal(AttrItem {\n+                    path: item.path.clone(),\n+                    tokens: self.lower_token_stream(item.tokens.clone()),\n+                })\n+            }\n+            AttrKind::DocComment(comment) => AttrKind::DocComment(comment)\n+        };\n+\n         Attribute {\n-            item: AttrItem {\n-                path: attr.path.clone(),\n-                tokens: self.lower_token_stream(attr.tokens.clone()),\n-            },\n+            kind,\n             id: attr.id,\n             style: attr.style,\n-            is_sugared_doc: attr.is_sugared_doc,\n             span: attr.span,\n         }\n     }\n@@ -1105,7 +1109,7 @@ impl<'a> LoweringContext<'a> {\n                     // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n-                    let impl_trait_node_id = self.sess.next_node_id();\n+                    let impl_trait_node_id = self.resolver.next_node_id();\n                     let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n                     self.resolver.definitions().create_def_with_parent(\n                         parent_def_index,\n@@ -1116,9 +1120,10 @@ impl<'a> LoweringContext<'a> {\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n+                        let node_id = this.resolver.next_node_id();\n                         let ty = this.lower_ty(\n                             &Ty {\n-                                id: this.sess.next_node_id(),\n+                                id: node_id,\n                                 kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n                                 span: constraint.span,\n                             },\n@@ -1212,8 +1217,8 @@ impl<'a> LoweringContext<'a> {\n                                     &NodeMap::default(),\n                                     ImplTraitContext::disallowed(),\n                                 ),\n-                                unsafety: this.lower_unsafety(f.unsafety),\n-                                abi: f.abi,\n+                                unsafety: f.unsafety,\n+                                abi: this.lower_abi(f.abi),\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n                                 param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))\n@@ -1585,7 +1590,7 @@ impl<'a> LoweringContext<'a> {\n                         name,\n                     }));\n \n-                    let def_node_id = self.context.sess.next_node_id();\n+                    let def_node_id = self.context.resolver.next_node_id();\n                     let hir_id =\n                         self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n                     self.context.resolver.definitions().create_def_with_parent(\n@@ -1698,29 +1703,19 @@ impl<'a> LoweringContext<'a> {\n                     };\n                     let parenthesized_generic_args = match partial_res.base_res() {\n                         // `a::b::Trait(Args)`\n-                        Res::Def(DefKind::Trait, _)\n-                            if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n+                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n                         // `a::b::Trait(Args)::TraitItem`\n-                        Res::Def(DefKind::Method, _)\n-                        | Res::Def(DefKind::AssocConst, _)\n-                        | Res::Def(DefKind::AssocTy, _)\n-                            if i + 2 == proj_start =>\n-                        {\n+                        Res::Def(DefKind::Method, _) |\n+                        Res::Def(DefKind::AssocConst, _) |\n+                        Res::Def(DefKind::AssocTy, _) if i + 2 == proj_start => {\n                             ParenthesizedGenericArgs::Ok\n                         }\n                         // Avoid duplicated errors.\n                         Res::Err => ParenthesizedGenericArgs::Ok,\n                         // An error\n-                        Res::Def(DefKind::Struct, _)\n-                        | Res::Def(DefKind::Enum, _)\n-                        | Res::Def(DefKind::Union, _)\n-                        | Res::Def(DefKind::TyAlias, _)\n-                        | Res::Def(DefKind::Variant, _) if i + 1 == proj_start =>\n-                        {\n-                            ParenthesizedGenericArgs::Err\n-                        }\n-                        // A warning for now, for compatibility reasons.\n-                        _ => ParenthesizedGenericArgs::Warn,\n+                        _ => ParenthesizedGenericArgs::Err,\n                     };\n \n                     let num_lifetimes = type_def_id.map_or(0, |def_id| {\n@@ -1783,7 +1778,7 @@ impl<'a> LoweringContext<'a> {\n                 segment,\n                 param_mode,\n                 0,\n-                ParenthesizedGenericArgs::Warn,\n+                ParenthesizedGenericArgs::Err,\n                 itctx.reborrow(),\n                 None,\n             ));\n@@ -1859,15 +1854,6 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n-                    ParenthesizedGenericArgs::Warn => {\n-                        self.resolver.lint_buffer().buffer_lint(\n-                            PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-                            CRATE_NODE_ID,\n-                            data.span,\n-                            msg.into(),\n-                        );\n-                        (hir::GenericArgs::none(), true)\n-                    }\n                     ParenthesizedGenericArgs::Err => {\n                         let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n                         err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n@@ -2095,13 +2081,6 @@ impl<'a> LoweringContext<'a> {\n         }, ids)\n     }\n \n-    fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n-        match m {\n-            Mutability::Mutable => hir::MutMutable,\n-            Mutability::Immutable => hir::MutImmutable,\n-        }\n-    }\n-\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n@@ -2671,7 +2650,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy {\n         hir::MutTy {\n             ty: self.lower_ty(&mt.ty, itctx),\n-            mutbl: self.lower_mutability(mt.mutbl),\n+            mutbl: mt.mutbl,\n         }\n     }\n \n@@ -2772,7 +2751,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => {\n-                hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n+                hir::PatKind::Ref(self.lower_pat(inner), mutbl)\n             }\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n                 P(self.lower_expr(e1)),\n@@ -3252,7 +3231,7 @@ impl<'a> LoweringContext<'a> {\n             Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),\n \n             None => (\n-                self.sess.next_node_id(),\n+                self.resolver.next_node_id(),\n                 \"`&` without an explicit lifetime name cannot be used here\",\n                 \"explicit lifetime name needed here\",\n             ),\n@@ -3289,7 +3268,7 @@ impl<'a> LoweringContext<'a> {\n                     span,\n                     \"expected 'implicit elided lifetime not allowed' error\",\n                 );\n-                let id = self.sess.next_node_id();\n+                let id = self.resolver.next_node_id();\n                 self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n             }\n             // `PassThrough` is the normal case.\n@@ -3385,7 +3364,7 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n     // either in std or core, i.e. has either a `::std::ops::Range` or\n     // `::core::ops::Range` prefix.\n     fn is_range_path(path: &Path) -> bool {\n-        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.as_str().to_string()).collect();\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n         let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n \n         // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n@@ -3426,7 +3405,7 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n         ExprKind::Call(ref func, _) => {\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n                 if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n-                    let new_call = segment.ident.as_str() == \"new\";\n+                    let new_call = segment.ident.name == sym::new;\n                     return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n                 }\n             }"}, {"sha": "62f3eaef244a155712ef907ea59bc98b5beed634", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -64,7 +64,6 @@ impl LoweringContext<'_> {\n                 hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n-                let m = self.lower_mutability(m);\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n@@ -474,7 +473,6 @@ impl LoweringContext<'_> {\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n-        let capture_clause = self.lower_capture_clause(capture_clause);\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(ty),\n             None => FunctionRetTy::Default(span),\n@@ -495,7 +493,7 @@ impl LoweringContext<'_> {\n             decl,\n             body_id,\n             span,\n-            Some(hir::GeneratorMovability::Static)\n+            Some(hir::Movability::Static)\n         );\n         let generator = hir::Expr {\n             hir_id: self.lower_node_id(closure_node_id),\n@@ -595,7 +593,7 @@ impl LoweringContext<'_> {\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n-        let loop_node_id = self.sess.next_node_id();\n+        let loop_node_id = self.resolver.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);\n@@ -701,7 +699,6 @@ impl LoweringContext<'_> {\n                 generator_kind,\n                 movability,\n             );\n-            let capture_clause = this.lower_capture_clause(capture_clause);\n             this.current_item = prev;\n             hir::ExprKind::Closure(\n                 capture_clause,\n@@ -713,20 +710,13 @@ impl LoweringContext<'_> {\n         })\n     }\n \n-    fn lower_capture_clause(&mut self, c: CaptureBy) -> hir::CaptureClause {\n-        match c {\n-            CaptureBy::Value => hir::CaptureByValue,\n-            CaptureBy::Ref => hir::CaptureByRef,\n-        }\n-    }\n-\n     fn generator_movability_for_fn(\n         &mut self,\n         decl: &FnDecl,\n         fn_decl_span: Span,\n         generator_kind: Option<hir::GeneratorKind>,\n         movability: Movability,\n-    ) -> Option<hir::GeneratorMovability> {\n+    ) -> Option<hir::Movability> {\n         match generator_kind {\n             Some(hir::GeneratorKind::Gen) =>  {\n                 if !decl.inputs.is_empty() {\n@@ -737,10 +727,7 @@ impl LoweringContext<'_> {\n                         \"generators cannot have explicit parameters\"\n                     );\n                 }\n-                Some(match movability {\n-                    Movability::Movable => hir::GeneratorMovability::Movable,\n-                    Movability::Static => hir::GeneratorMovability::Static,\n-                })\n+                Some(movability)\n             },\n             Some(hir::GeneratorKind::Async(_)) => {\n                 bug!(\"non-`async` closure body turned `async` during lowering\");\n@@ -811,7 +798,7 @@ impl LoweringContext<'_> {\n                 this.expr(fn_decl_span, async_body, ThinVec::new())\n             });\n             hir::ExprKind::Closure(\n-                this.lower_capture_clause(capture_clause),\n+                capture_clause,\n                 fn_decl,\n                 body_id,\n                 fn_decl_span,\n@@ -1350,7 +1337,7 @@ impl LoweringContext<'_> {\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::AddrOf(hir::MutMutable, e), ThinVec::new())\n+        self.expr(span, hir::ExprKind::AddrOf(hir::Mutability::Mutable, e), ThinVec::new())\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> hir::Expr {"}, {"sha": "aafdd78e3e8bcb258768a32814c9c0618be3e6f9", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 38, "deletions": 57, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -12,14 +12,14 @@ use crate::hir::def::{Res, DefKind};\n use crate::util::nodemap::NodeMap;\n \n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_target::spec::abi;\n \n use std::collections::BTreeSet;\n use smallvec::SmallVec;\n use syntax::attr;\n use syntax::ast::*;\n use syntax::visit::{self, Visitor};\n-use syntax::expand::SpecialDerives;\n-use syntax::source_map::{respan, DesugaringKind, Spanned};\n+use syntax::source_map::{respan, DesugaringKind};\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n@@ -227,13 +227,7 @@ impl LoweringContext<'_> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let mut attrs = self.lower_attrs_extendable(&i.attrs);\n-        if self.resolver.has_derives(i.id, SpecialDerives::PARTIAL_EQ | SpecialDerives::EQ) {\n-            // Add `#[structural_match]` if the item derived both `PartialEq` and `Eq`.\n-            let ident = Ident::new(sym::structural_match, i.span);\n-            attrs.push(attr::mk_attr_outer(attr::mk_word_item(ident)));\n-        }\n-        let attrs = attrs.into();\n+        let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n@@ -295,7 +289,7 @@ impl LoweringContext<'_> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n-                    self.lower_mutability(m),\n+                    m,\n                     self.lower_const_body(e),\n                 )\n             }\n@@ -312,7 +306,7 @@ impl LoweringContext<'_> {\n                     self.lower_const_body(e)\n                 )\n             }\n-            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n+            ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n@@ -323,7 +317,7 @@ impl LoweringContext<'_> {\n                     // declaration (decl), not the return types.\n                     let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n \n-                    let (generics, fn_decl) = this.add_in_band_defs(\n+                    let (generics, decl) = this.add_in_band_defs(\n                         generics,\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n@@ -334,13 +328,8 @@ impl LoweringContext<'_> {\n                             header.asyncness.node.opt_return_id()\n                         ),\n                     );\n-\n-                    hir::ItemKind::Fn(\n-                        fn_decl,\n-                        this.lower_fn_header(header),\n-                        generics,\n-                        body_id,\n-                    )\n+                    let sig = hir::FnSig { decl, header: this.lower_fn_header(header) };\n+                    hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n             ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n@@ -444,8 +433,8 @@ impl LoweringContext<'_> {\n                 );\n \n                 hir::ItemKind::Impl(\n-                    self.lower_unsafety(unsafety),\n-                    self.lower_impl_polarity(polarity),\n+                    unsafety,\n+                    polarity,\n                     self.lower_defaultness(defaultness, true /* [1] */),\n                     generics,\n                     trait_ref,\n@@ -460,8 +449,8 @@ impl LoweringContext<'_> {\n                     .map(|item| self.lower_trait_item_ref(item))\n                     .collect();\n                 hir::ItemKind::Trait(\n-                    self.lower_is_auto(is_auto),\n-                    self.lower_unsafety(unsafety),\n+                    is_auto,\n+                    unsafety,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                     bounds,\n                     items,\n@@ -533,7 +522,7 @@ impl LoweringContext<'_> {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n-                        seg.id = self.sess.next_node_id();\n+                        seg.id = self.resolver.next_node_id();\n                     }\n                     let span = path.span;\n \n@@ -610,7 +599,7 @@ impl LoweringContext<'_> {\n \n                     // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n-                        seg.id = self.sess.next_node_id();\n+                        seg.id = self.resolver.next_node_id();\n                     }\n \n                     // Each `use` import is an item and thus are owners of the\n@@ -730,7 +719,7 @@ impl LoweringContext<'_> {\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n                     hir::ForeignItemKind::Static(\n-                        self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n+                        self.lower_ty(t, ImplTraitContext::disallowed()), m)\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n@@ -742,7 +731,7 @@ impl LoweringContext<'_> {\n \n     fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n         hir::ForeignMod {\n-            abi: fm.abi,\n+            abi: self.lower_abi(fm.abi),\n             items: fm.items\n                 .iter()\n                 .map(|x| self.lower_foreign_item(x))\n@@ -1022,13 +1011,6 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_impl_polarity(&mut self, i: ImplPolarity) -> hir::ImplPolarity {\n-        match i {\n-            ImplPolarity::Positive => hir::ImplPolarity::Positive,\n-            ImplPolarity::Negative => hir::ImplPolarity::Negative,\n-        }\n-    }\n-\n     fn record_body(&mut self, params: HirVec<hir::Param>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n             generator_kind: self.generator_kind,\n@@ -1266,11 +1248,11 @@ impl LoweringContext<'_> {\n     fn lower_method_sig(\n         &mut self,\n         generics: &Generics,\n-        sig: &MethodSig,\n+        sig: &FnSig,\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n-    ) -> (hir::Generics, hir::MethodSig) {\n+    ) -> (hir::Generics, hir::FnSig) {\n         let header = self.lower_fn_header(sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n@@ -1283,37 +1265,36 @@ impl LoweringContext<'_> {\n                 is_async,\n             ),\n         );\n-        (generics, hir::MethodSig { header, decl })\n-    }\n-\n-    fn lower_is_auto(&mut self, a: IsAuto) -> hir::IsAuto {\n-        match a {\n-            IsAuto::Yes => hir::IsAuto::Yes,\n-            IsAuto::No => hir::IsAuto::No,\n-        }\n+        (generics, hir::FnSig { header, decl })\n     }\n \n     fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n-            unsafety: self.lower_unsafety(h.unsafety),\n+            unsafety: h.unsafety,\n             asyncness: self.lower_asyncness(h.asyncness.node),\n-            constness: self.lower_constness(h.constness),\n-            abi: h.abi,\n+            constness: h.constness.node,\n+            abi: self.lower_abi(h.abi),\n         }\n     }\n \n-    pub(super) fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n-        match u {\n-            Unsafety::Unsafe => hir::Unsafety::Unsafe,\n-            Unsafety::Normal => hir::Unsafety::Normal,\n-        }\n+    pub(super) fn lower_abi(&mut self, abi: Abi) -> abi::Abi {\n+        abi::lookup(&abi.symbol.as_str()).unwrap_or_else(|| {\n+            self.error_on_invalid_abi(abi);\n+            abi::Abi::Rust\n+        })\n     }\n \n-    fn lower_constness(&mut self, c: Spanned<Constness>) -> hir::Constness {\n-        match c.node {\n-            Constness::Const => hir::Constness::Const,\n-            Constness::NotConst => hir::Constness::NotConst,\n-        }\n+    fn error_on_invalid_abi(&self, abi: Abi) {\n+        struct_span_err!(\n+            self.sess,\n+            abi.span,\n+            E0703,\n+            \"invalid ABI: found `{}`\",\n+            abi.symbol\n+        )\n+        .span_label(abi.span, \"invalid ABI\")\n+        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+        .emit();\n     }\n \n     fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {"}, {"sha": "f25f3b5741a0ef2984e1c9287e96722f413da9b5", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -158,25 +158,25 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn body(self) -> ast::BodyId {\n         self.handle(|i: ItemFnParts<'a>| i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _| body,\n+                    |_, _, _: &'a ast::FnSig, _, body: ast::BodyId, _, _| body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n         self.handle(|i: ItemFnParts<'a>| &*i.decl,\n-                    |_, _, sig: &'a ast::MethodSig, _, _, _, _| &sig.decl,\n+                    |_, _, sig: &'a ast::FnSig, _, _, _, _| &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts<'_>| i.span,\n-                    |_, _, _: &'a ast::MethodSig, _, _, span, _| span,\n+                    |_, _, _: &'a ast::FnSig, _, _, span, _| span,\n                     |c: ClosureParts<'_>| c.span)\n     }\n \n     pub fn id(self) -> ast::HirId {\n         self.handle(|i: ItemFnParts<'_>| i.id,\n-                    |id, _, _: &'a ast::MethodSig, _, _, _, _| id,\n+                    |id, _, _: &'a ast::FnSig, _, _, _, _| id,\n                     |c: ClosureParts<'_>| c.id)\n     }\n \n@@ -199,7 +199,7 @@ impl<'a> FnLikeNode<'a> {\n         let closure = |c: ClosureParts<'a>| {\n             FnKind::Closure(c.attrs)\n         };\n-        let method = |_, ident: Ident, sig: &'a ast::MethodSig, vis, _, _, attrs| {\n+        let method = |_, ident: Ident, sig: &'a ast::FnSig, vis, _, _, attrs| {\n             FnKind::Method(ident, sig, vis, attrs)\n         };\n         self.handle(item, method, closure)\n@@ -209,7 +209,7 @@ impl<'a> FnLikeNode<'a> {\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(ast::HirId,\n                   Ident,\n-                  &'a ast::MethodSig,\n+                  &'a ast::FnSig,\n                   Option<&'a ast::Visibility>,\n                   ast::BodyId,\n                   Span,\n@@ -219,16 +219,16 @@ impl<'a> FnLikeNode<'a> {\n     {\n         match self.node {\n             map::Node::Item(i) => match i.kind {\n-                ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n+                ast::ItemKind::Fn(ref sig, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.hir_id,\n                         ident: i.ident,\n-                        decl: &decl,\n+                        decl: &sig.decl,\n                         body: block,\n                         vis: &i.vis,\n                         span: i.span,\n                         attrs: &i.attrs,\n-                        header,\n+                        header: sig.header,\n                         generics,\n                     }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),"}, {"sha": "d858e00a2e9cdd7c204789326fbb3644d535b61a", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,7 +4,7 @@ use crate::hir::def_id::DefIndex;\n use syntax::ast::*;\n use syntax::visit;\n use syntax::symbol::{kw, sym};\n-use syntax::parse::token::{self, Token};\n+use syntax::token::{self, Token};\n use syntax_pos::hygiene::ExpnId;\n use syntax_pos::Span;\n \n@@ -100,7 +100,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into, the better\n-        let def_data = match i.kind {\n+        let def_data = match &i.kind {\n             ItemKind::Impl(..) => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n                 return visit::walk_item(self, i);\n@@ -109,19 +109,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n             ItemKind::OpaqueTy(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n             ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n-            ItemKind::Fn(\n-                ref decl,\n-                ref header,\n-                ref generics,\n-                ref body,\n-            ) if header.asyncness.node.is_async() => {\n+            ItemKind::Fn(sig, generics, body) if sig.header.asyncness.node.is_async() => {\n                 return self.visit_async_fn(\n                     i.id,\n                     i.ident.name,\n                     i.span,\n-                    header,\n+                    &sig.header,\n                     generics,\n-                    decl,\n+                    &sig.decl,\n                     body,\n                 )\n             }\n@@ -228,7 +223,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.kind {\n-            ImplItemKind::Method(MethodSig {\n+            ImplItemKind::Method(FnSig {\n                 ref header,\n                 ref decl,\n             }, ref body) if header.asyncness.node.is_async() => {"}, {"sha": "1e444e8a5b84e2ee7a9fd55ebb3ab3e964653998", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 87, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -19,7 +19,7 @@ use std::hash::Hash;\n use syntax::ast;\n use syntax_pos::symbol::{Symbol, sym};\n use syntax_pos::hygiene::ExpnId;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n /// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n@@ -310,10 +310,6 @@ pub enum DefPathData {\n     AnonConst,\n     /// An `impl Trait` type node.\n     ImplTrait,\n-    /// Identifies a piece of crate metadata that is global to a whole crate\n-    /// (as opposed to just one item). `GlobalMetaData` components are only\n-    /// supposed to show up right below the crate root.\n-    GlobalMetaData(Symbol),\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -444,9 +440,6 @@ impl Definitions {\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n         self.set_invocation_parent(ExpnId::root(), root_index);\n \n-        // Allocate some other `DefIndex`es that always must exist.\n-        GlobalMetaDataKind::allocate_def_indices(self);\n-\n         root_index\n     }\n \n@@ -553,8 +546,7 @@ impl DefPathData {\n             TypeNs(name) |\n             ValueNs(name) |\n             MacroNs(name) |\n-            LifetimeNs(name) |\n-            GlobalMetaData(name) => Some(name),\n+            LifetimeNs(name) => Some(name),\n \n             Impl |\n             CrateRoot |\n@@ -572,8 +564,7 @@ impl DefPathData {\n             TypeNs(name) |\n             ValueNs(name) |\n             MacroNs(name) |\n-            LifetimeNs(name) |\n-            GlobalMetaData(name) => {\n+            LifetimeNs(name) => {\n                 name\n             }\n             // Note that this does not show up in user print-outs.\n@@ -591,78 +582,3 @@ impl DefPathData {\n         self.as_symbol().to_string()\n     }\n }\n-\n-// We define the `GlobalMetaDataKind` enum with this macro because we want to\n-// make sure that we exhaustively iterate over all variants when registering\n-// the corresponding `DefIndex`es in the `DefTable`.\n-macro_rules! define_global_metadata_kind {\n-    (pub enum GlobalMetaDataKind {\n-        $($variant:ident),*\n-    }) => (\n-        pub enum GlobalMetaDataKind {\n-            $($variant),*\n-        }\n-\n-        impl GlobalMetaDataKind {\n-            fn allocate_def_indices(definitions: &mut Definitions) {\n-                $({\n-                    let instance = GlobalMetaDataKind::$variant;\n-                    definitions.create_def_with_parent(\n-                        CRATE_DEF_INDEX,\n-                        ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name()),\n-                        ExpnId::root(),\n-                        DUMMY_SP\n-                    );\n-\n-                    // Make sure calling `def_index` does not crash.\n-                    instance.def_index(&definitions.table);\n-                })*\n-            }\n-\n-            pub fn def_index(&self, def_path_table: &DefPathTable) -> DefIndex {\n-                let def_key = DefKey {\n-                    parent: Some(CRATE_DEF_INDEX),\n-                    disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name()),\n-                        disambiguator: 0,\n-                    }\n-                };\n-\n-                // These `DefKey`s are all right after the root,\n-                // so a linear search is fine.\n-                let index = def_path_table.index_to_key\n-                                          .iter()\n-                                          .position(|k| *k == def_key)\n-                                          .unwrap();\n-\n-                DefIndex::from(index)\n-            }\n-\n-            fn name(&self) -> Symbol {\n-\n-                let string = match *self {\n-                    $(\n-                        GlobalMetaDataKind::$variant => {\n-                            concat!(\"{{GlobalMetaData::\", stringify!($variant), \"}}\")\n-                        }\n-                    )*\n-                };\n-\n-                Symbol::intern(string)\n-            }\n-        }\n-    )\n-}\n-\n-define_global_metadata_kind!(pub enum GlobalMetaDataKind {\n-    Krate,\n-    CrateDeps,\n-    DylibDependencyFormats,\n-    LangItems,\n-    LangItemsMissing,\n-    NativeLibraries,\n-    SourceMap,\n-    Impls,\n-    ExportedSymbols\n-});"}, {"sha": "d7b1676c1d4d397ac3ad1e72b7de81031292eba8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -49,21 +49,21 @@ impl<'hir> Entry<'hir> {\n         match self.node {\n             Node::Item(ref item) => {\n                 match item.kind {\n-                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(fn_decl),\n+                    ItemKind::Fn(ref sig, _, _) => Some(&sig.decl),\n                     _ => None,\n                 }\n             }\n \n             Node::TraitItem(ref item) => {\n                 match item.kind {\n-                    TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n+                    TraitItemKind::Method(ref sig, _) => Some(&sig.decl),\n                     _ => None\n                 }\n             }\n \n             Node::ImplItem(ref item) => {\n                 match item.kind {\n-                    ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n+                    ImplItemKind::Method(ref sig, _) => Some(&sig.decl),\n                     _ => None,\n                 }\n             }\n@@ -85,7 +85,7 @@ impl<'hir> Entry<'hir> {\n                 match item.kind {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n-                    ItemKind::Fn(_, _, _, body) => Some(body),\n+                    ItemKind::Fn(.., body) => Some(body),\n                     _ => None,\n                 }\n             }\n@@ -605,7 +605,7 @@ impl<'hir> Map<'hir> {\n                 Node::TraitItem(ref trait_item) => Some(&trait_item.generics),\n                 Node::Item(ref item) => {\n                     match item.kind {\n-                        ItemKind::Fn(_, _, ref generics, _) |\n+                        ItemKind::Fn(_, ref generics, _) |\n                         ItemKind::TyAlias(_, ref generics) |\n                         ItemKind::Enum(_, ref generics) |\n                         ItemKind::Struct(_, ref generics) |\n@@ -702,9 +702,9 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => true,\n             Node::Item(&Item {\n-                kind: ItemKind::Fn(_, header, ..),\n+                kind: ItemKind::Fn(ref sig, ..),\n                 ..\n-            }) => header.constness == Constness::Const,\n+            }) => sig.header.constness == Constness::Const,\n             _ => false,\n         }\n     }"}, {"sha": "bbd3b40e1be90ab2d356758b48adcf2fd1755d50", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 20, "deletions": 99, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,9 +3,7 @@\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n pub use self::BlockCheckMode::*;\n-pub use self::CaptureClause::*;\n pub use self::FunctionRetTy::*;\n-pub use self::Mutability::*;\n pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n@@ -23,6 +21,7 @@ use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n+pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy, IsAuto, ImplPolarity};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n@@ -1053,30 +1052,6 @@ pub enum PatKind {\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Mutability {\n-    MutMutable,\n-    MutImmutable,\n-}\n-\n-impl Mutability {\n-    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n-    pub fn and(self, other: Self) -> Self {\n-        match self {\n-            MutMutable => other,\n-            MutImmutable => MutImmutable,\n-        }\n-    }\n-\n-    pub fn invert(self) -> Self {\n-        match self {\n-            MutMutable => MutImmutable,\n-            MutImmutable => MutMutable,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n@@ -1616,6 +1591,11 @@ pub enum ExprKind {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n+    ///\n+    /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n+    /// the `hir_id` of the `MethodCall` node itself.\n+    ///\n+    /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n     MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(HirVec<Expr>),\n@@ -1647,8 +1627,8 @@ pub enum ExprKind {\n     /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n-    /// `Option<GeneratorMovability>`.\n-    Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n+    /// `Option<Movability>`.\n+    Closure(CaptureBy, P<FnDecl>, BodyId, Span, Option<Movability>),\n     /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n \n@@ -1698,6 +1678,10 @@ pub enum ExprKind {\n }\n \n /// Represents an optionally `Self`-qualified value/type path or associated extension.\n+///\n+/// To resolve the path to a `DefId`, call [`qpath_res`].\n+///\n+/// [`qpath_res`]: ../ty/struct.TypeckTables.html#method.qpath_res\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n@@ -1817,17 +1801,6 @@ pub struct Destination {\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n-/// Whether a generator contains self-references, causing it to be `!Unpin`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum GeneratorMovability {\n-    /// May contain self-references, `!Unpin`.\n-    Static,\n-\n-    /// Must not contain self-references, `Unpin`.\n-    Movable,\n-}\n-\n /// The yield kind that caused an `ExprKind::Yield`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum YieldSource {\n@@ -1846,12 +1819,6 @@ impl fmt::Display for YieldSource {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum CaptureClause {\n-    CaptureByValue,\n-    CaptureByRef,\n-}\n-\n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -1860,9 +1827,10 @@ pub struct MutTy {\n     pub mutbl: Mutability,\n }\n \n-/// Represents a method's signature in a trait declaration or implementation.\n+/// Represents a function's signature in a trait declaration,\n+/// trait implementation, or a free function.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct MethodSig {\n+pub struct FnSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n }\n@@ -1905,7 +1873,7 @@ pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(P<Ty>, Option<BodyId>),\n     /// A method with an optional body.\n-    Method(MethodSig, TraitMethod),\n+    Method(FnSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type.\n     Type(GenericBounds, Option<P<Ty>>),\n@@ -1939,7 +1907,7 @@ pub enum ImplItemKind {\n     /// of the expression.\n     Const(P<Ty>, BodyId),\n     /// A method implementation with the given signature and body.\n-    Method(MethodSig, BodyId),\n+    Method(FnSig, BodyId),\n     /// An associated type.\n     TyAlias(P<Ty>),\n     /// An associated `type = impl Trait`.\n@@ -2154,33 +2122,13 @@ impl ImplicitSelfKind {\n     }\n }\n \n-/// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum IsAuto {\n-    Yes,\n-    No\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, HashStable,\n          Ord, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async,\n     NotAsync,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Unsafety {\n-    Unsafe,\n-    Normal,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum Constness {\n-    Const,\n-    NotConst,\n-}\n-\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Defaultness {\n     Default { has_value: bool },\n@@ -2207,33 +2155,6 @@ impl Defaultness {\n     }\n }\n \n-impl fmt::Display for Unsafety {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match self {\n-            Unsafety::Normal => \"normal\",\n-            Unsafety::Unsafe => \"unsafe\",\n-        })\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum ImplPolarity {\n-    /// `impl Trait for Type`\n-    Positive,\n-    /// `impl !Trait for Type`\n-    Negative,\n-}\n-\n-impl fmt::Debug for ImplPolarity {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match self {\n-            ImplPolarity::Positive => \"positive\",\n-            ImplPolarity::Negative => \"negative\",\n-        })\n-    }\n-}\n-\n-\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n@@ -2509,7 +2430,7 @@ pub enum ItemKind {\n     /// A `const` item.\n     Const(P<Ty>, BodyId),\n     /// A function declaration.\n-    Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n+    Fn(FnSig, Generics, BodyId),\n     /// A module.\n     Mod(Mod),\n     /// An external module, e.g. `extern { .. }`.\n@@ -2574,7 +2495,7 @@ impl ItemKind {\n \n     pub fn generics(&self) -> Option<&Generics> {\n         Some(match *self {\n-            ItemKind::Fn(_, _, ref generics, _) |\n+            ItemKind::Fn(_, ref generics, _) |\n             ItemKind::TyAlias(_, ref generics) |\n             ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. }) |\n             ItemKind::Enum(_, ref generics) |\n@@ -2667,7 +2588,7 @@ pub struct Upvar {\n     pub span: Span\n }\n \n-pub type CaptureModeMap = NodeMap<CaptureClause>;\n+pub type CaptureModeMap = NodeMap<CaptureBy>;\n \n  // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n  // has length > 0 if the trait is found through an chain of imports, starting with the"}, {"sha": "97228c8f2403882df34d8ccd17279960f046693e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -169,10 +169,11 @@ impl hir::Pat {\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n                 hir::BindingAnnotation::Ref => match result {\n-                    None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                    None | Some(hir::Mutability::Immutable) =>\n+                        result = Some(hir::Mutability::Immutable),\n                     _ => {}\n                 }\n-                hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n+                hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mutable),\n                 _ => {}\n             }\n         });"}, {"sha": "ba618a1da8cefbdd02e78f4800fc2959052ff718", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -295,8 +295,8 @@ impl<'a> State<'a> {\n             hir::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\");\n                 match mt.mutbl {\n-                    hir::MutMutable => self.word_nbsp(\"mut\"),\n-                    hir::MutImmutable => self.word_nbsp(\"const\"),\n+                    hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n+                    hir::Mutability::Immutable => self.word_nbsp(\"const\"),\n                 }\n                 self.print_type(&mt.ty);\n             }\n@@ -390,7 +390,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::MutMutable {\n+                if m == hir::Mutability::Mutable {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -506,7 +506,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::MutMutable {\n+                if m == hir::Mutability::Mutable {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -533,10 +533,10 @@ impl<'a> State<'a> {\n                 self.s.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n-            hir::ItemKind::Fn(ref decl, header, ref param_names, body) => {\n+            hir::ItemKind::Fn(ref sig, ref param_names, body) => {\n                 self.head(\"\");\n-                self.print_fn(decl,\n-                              header,\n+                self.print_fn(&sig.decl,\n+                              sig.header,\n                               Some(item.ident.name),\n                               param_names,\n                               &item.vis,\n@@ -564,7 +564,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::GlobalAsm(ref ga) => {\n                 self.head(visibility_qualified(&item.vis, \"global asm\"));\n-                self.s.word(ga.asm.as_str().to_string());\n+                self.s.word(ga.asm.to_string());\n                 self.end()\n             }\n             hir::ItemKind::TyAlias(ref ty, ref generics) => {\n@@ -835,7 +835,7 @@ impl<'a> State<'a> {\n     }\n     pub fn print_method_sig(&mut self,\n                             ident: ast::Ident,\n-                            m: &hir::MethodSig,\n+                            m: &hir::FnSig,\n                             generics: &hir::Generics,\n                             vis: &hir::Visibility,\n                             arg_names: &[ast::Ident],\n@@ -1628,11 +1628,11 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::MutImmutable);\n+                        self.print_mutability(hir::Mutability::Immutable);\n                     }\n                     hir::BindingAnnotation::RefMut => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::MutMutable);\n+                        self.print_mutability(hir::Mutability::Mutable);\n                     }\n                     hir::BindingAnnotation::Unannotated => {}\n                     hir::BindingAnnotation::Mutable => {\n@@ -1734,9 +1734,7 @@ impl<'a> State<'a> {\n                     _ => false,\n                 };\n                 self.s.word(\"&\");\n-                if mutbl == hir::MutMutable {\n-                    self.s.word(\"mut \");\n-                }\n+                self.s.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }\n@@ -1855,7 +1853,7 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n-                s.s.word(arg_name.as_str().to_string());\n+                s.s.word(arg_name.to_string());\n                 s.s.word(\":\");\n                 s.s.space();\n             } else if let Some(body_id) = body_id {\n@@ -1911,10 +1909,10 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_capture_clause(&mut self, capture_clause: hir::CaptureClause) {\n+    pub fn print_capture_clause(&mut self, capture_clause: hir::CaptureBy) {\n         match capture_clause {\n-            hir::CaptureByValue => self.word_space(\"move\"),\n-            hir::CaptureByRef => {},\n+            hir::CaptureBy::Value => self.word_space(\"move\"),\n+            hir::CaptureBy::Ref => {},\n         }\n     }\n \n@@ -2063,8 +2061,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mutability(&mut self, mutbl: hir::Mutability) {\n         match mutbl {\n-            hir::MutMutable => self.word_nbsp(\"mut\"),\n-            hir::MutImmutable => {},\n+            hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n+            hir::Mutability::Immutable => {},\n         }\n     }\n "}, {"sha": "a5b131520c243a7d5250b7eff65cdc95cbc742d2", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -309,11 +309,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n         let span = self.data();\n-\n-        if span.hi < span.lo {\n-            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-        }\n-\n         let (file_lo, line_lo, col_lo) = match hcx.source_map()\n                                                   .byte_pos_to_line_and_col(span.lo) {\n             Some(pos) => pos,"}, {"sha": "b3d82e5522cf2400d9c15b87fd3afa023efe1426", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -8,31 +8,31 @@ use std::mem;\n \n use syntax::ast;\n use syntax::feature_gate;\n-use syntax::parse::token;\n-use syntax::symbol::LocalInternedString;\n+use syntax::token;\n use syntax::tokenstream;\n+use syntax_pos::symbol::SymbolStr;\n use syntax_pos::SourceFile;\n \n use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n \n-impl<'a> HashStable<StableHashingContext<'a>> for LocalInternedString {\n+impl<'a> HashStable<StableHashingContext<'a>> for SymbolStr {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let str = self as &str;\n         str.hash_stable(hcx, hasher)\n     }\n }\n \n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalInternedString {\n-    type KeyType = LocalInternedString;\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for SymbolStr {\n+    type KeyType = SymbolStr;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n-                          -> LocalInternedString {\n+                          -> SymbolStr {\n         self.clone()\n     }\n }\n@@ -45,12 +45,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n }\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n-    type KeyType = LocalInternedString;\n+    type KeyType = SymbolStr;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n-                          -> LocalInternedString {\n+                          -> SymbolStr {\n         self.as_str()\n     }\n }\n@@ -124,7 +124,6 @@ for ::syntax::attr::StabilityLevel {\n \n impl_stable_hash_for!(struct ::syntax::attr::RustcDeprecation { since, reason, suggestion });\n \n-\n impl_stable_hash_for!(enum ::syntax::attr::IntType {\n     SignedInt(int_ty),\n     UnsignedInt(uint_ty)\n@@ -136,6 +135,11 @@ impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n     Unsuffixed\n });\n \n+impl_stable_hash_for!(enum ::syntax::ast::LitFloatType {\n+    Suffixed(float_ty),\n+    Unsuffixed\n+});\n+\n impl_stable_hash_for!(struct ::syntax::ast::Lit {\n     kind,\n     token,\n@@ -148,8 +152,7 @@ impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Byte(value),\n     Char(value),\n     Int(value, lit_int_type),\n-    Float(value, float_ty),\n-    FloatUnsuffixed(value),\n+    Float(value, lit_float_type),\n     Bool(value),\n     Err(value)\n });\n@@ -165,6 +168,10 @@ impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n+impl_stable_hash_for!(enum ::syntax::ast::Movability { Static, Movable });\n+impl_stable_hash_for!(enum ::syntax::ast::CaptureBy { Value, Ref });\n+impl_stable_hash_for!(enum ::syntax::ast::IsAuto { Yes, No });\n+impl_stable_hash_for!(enum ::syntax::ast::ImplPolarity { Positive, Negative });\n \n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n@@ -177,7 +184,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         let filtered: SmallVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n-                !attr.is_sugared_doc &&\n+                !attr.is_doc_comment() &&\n                 !attr.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name))\n             })\n             .collect();\n@@ -207,19 +214,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n         debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n-        debug_assert!(!self.is_sugared_doc);\n-\n-        let ast::Attribute {\n-            ref item,\n-            id: _,\n-            style,\n-            is_sugared_doc: _,\n-            span,\n-        } = *self;\n-\n-        item.hash_stable(hcx, hasher);\n-        style.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n+        debug_assert!(!self.is_doc_comment());\n+\n+        let ast::Attribute { kind, id: _, style, span } = self;\n+        if let ast::AttrKind::Normal(item) = kind {\n+            item.hash_stable(hcx, hasher);\n+            style.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        } else {\n+            unreachable!();\n+        }\n     }\n }\n "}, {"sha": "38edef50c966275d2e8c2965e308c5783bdc184f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -897,11 +897,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             } else {\n                 r.push(' ');\n             }\n-            s.push_highlighted(format!(\n-                \"&{}{}\",\n-                r,\n-                if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n-            ));\n+            s.push_highlighted(format!(\"&{}{}\", r, mutbl.prefix_str()));\n             s.push_normal(ty.to_string());\n         }\n \n@@ -1234,8 +1230,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        // In some (most?) cases cause.body_id points to actual body, but in some cases\n+        // it's a actual definition. According to the comments (e.g. in\n+        // librustc_typeck/check/compare_method.rs:compare_predicate_entailment) the latter\n+        // is relied upon by some other code. This might (or might not) need cleanup.\n+        let body_owner_def_id = self.tcx.hir().opt_local_def_id(cause.body_id)\n+            .unwrap_or_else(|| {\n+                self.tcx.hir().body_owner_def_id(hir::BodyId { hir_id: cause.body_id })\n+            });\n         self.check_and_note_conflicting_crates(diag, terr, span);\n-        self.tcx.note_and_explain_type_err(diag, terr, span);\n+        self.tcx.note_and_explain_type_err(diag, terr, span, body_owner_def_id);\n \n         // It reads better to have the error origin as the final\n         // thing."}, {"sha": "db5557204e4da2945d6b9ddfa9590aa750a0aa61", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -31,10 +31,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n                 let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Fn(ref fndecl, ..),\n+                        kind: hir::ItemKind::Fn(ref m, ..),\n                         ..\n-                    }) => &fndecl,\n-                    Node::TraitItem(&hir::TraitItem {\n+                    })\n+                    | Node::TraitItem(&hir::TraitItem {\n                         kind: hir::TraitItemKind::Method(ref m, ..),\n                         ..\n                     })"}, {"sha": "d789fb0de109304748ef35e75039489fa54cdac1", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,3 +1,3 @@\n For info on how the current borrowck works, see the [rustc guide].\n \n-[rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+[rustc guide]: https://rust-lang.github.io/rustc-guide/borrow_check.html"}, {"sha": "f8a592d22c19c1a3f6ce285fa294ffa9a44a6688", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 83, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -7,7 +7,7 @@\n use crate::lint::{LintPass, LateLintPass, LintArray, FutureIncompatibleInfo};\n use crate::middle::stability;\n use crate::session::Session;\n-use errors::{Applicability, DiagnosticBuilder, pluralise};\n+use errors::{Applicability, DiagnosticBuilder, pluralize};\n use syntax::ast;\n use syntax::edition::Edition;\n use syntax::source_map::Span;\n@@ -177,16 +177,6 @@ declare_lint! {\n     \"lints that have been renamed or removed\"\n }\n \n-declare_lint! {\n-    pub SAFE_EXTERN_STATICS,\n-    Deny,\n-    \"safe access to extern statics was erroneously allowed\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/36247>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     pub SAFE_PACKED_BORROWS,\n     Warn,\n@@ -199,35 +189,14 @@ declare_lint! {\n \n declare_lint! {\n     pub PATTERNS_IN_FNS_WITHOUT_BODY,\n-    Warn,\n+    Deny,\n     \"patterns in functions without body were erroneously allowed\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n         edition: None,\n     };\n }\n \n-declare_lint! {\n-    pub LEGACY_DIRECTORY_OWNERSHIP,\n-    Deny,\n-    \"non-inline, non-`#[path]` modules (e.g., `mod foo;`) were erroneously allowed in some files \\\n-     not named `mod.rs`\",\n-     @future_incompatible = FutureIncompatibleInfo {\n-         reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n-         edition: None,\n-     };\n-}\n-\n-declare_lint! {\n-    pub LEGACY_CONSTRUCTOR_VISIBILITY,\n-    Deny,\n-    \"detects use of struct constructors that would be invisible with new visibility rules\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     pub MISSING_FRAGMENT_SPECIFIER,\n     Deny,\n@@ -238,16 +207,6 @@ declare_lint! {\n     };\n }\n \n-declare_lint! {\n-    pub PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-    Deny,\n-    \"detects parenthesized generic parameters in type and module names\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     pub LATE_BOUND_LIFETIME_ARGUMENTS,\n     Warn,\n@@ -372,16 +331,6 @@ declare_lint! {\n     \"detects labels that are never used\"\n }\n \n-declare_lint! {\n-    pub DUPLICATE_MACRO_EXPORTS,\n-    Deny,\n-    \"detects duplicate macro exports\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #35896 <https://github.com/rust-lang/rust/issues/35896>\",\n-        edition: Some(Edition::Edition2018),\n-    };\n-}\n-\n declare_lint! {\n     pub INTRA_DOC_LINK_RESOLUTION_FAILURE,\n     Warn,\n@@ -459,7 +408,7 @@ declare_lint! {\n pub mod parser {\n     declare_lint! {\n         pub ILL_FORMED_ATTRIBUTE_INPUT,\n-        Warn,\n+        Deny,\n         \"ill-formed attribute inputs that were previously accepted and used in practice\",\n         @future_incompatible = super::FutureIncompatibleInfo {\n             reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n@@ -497,16 +446,6 @@ declare_lint! {\n     };\n }\n \n-declare_lint! {\n-    pub NESTED_IMPL_TRAIT,\n-    Warn,\n-    \"nested occurrence of `impl Trait` type\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #59014 <https://github.com/rust-lang/rust/issues/59014>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     pub MUTABLE_BORROW_RESERVATION_CONFLICT,\n     Warn,\n@@ -556,13 +495,9 @@ declare_lint_pass! {\n         INVALID_TYPE_PARAM_DEFAULT,\n         CONST_ERR,\n         RENAMED_AND_REMOVED_LINTS,\n-        SAFE_EXTERN_STATICS,\n         SAFE_PACKED_BORROWS,\n         PATTERNS_IN_FNS_WITHOUT_BODY,\n-        LEGACY_DIRECTORY_OWNERSHIP,\n-        LEGACY_CONSTRUCTOR_VISIBILITY,\n         MISSING_FRAGMENT_SPECIFIER,\n-        PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n         ORDER_DEPENDENT_TRAIT_OBJECTS,\n         DEPRECATED,\n@@ -578,7 +513,6 @@ declare_lint_pass! {\n         ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n-        DUPLICATE_MACRO_EXPORTS,\n         INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS,\n@@ -590,7 +524,6 @@ declare_lint_pass! {\n         parser::META_VARIABLE_MISUSE,\n         DEPRECATED_IN_FUTURE,\n         AMBIGUOUS_ASSOCIATED_ITEMS,\n-        NESTED_IMPL_TRAIT,\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n@@ -604,13 +537,11 @@ pub enum BuiltinLintDiagnostics {\n     Normal,\n     BareTraitObject(Span, /* is_global */ bool),\n     AbsPathWithModule(Span),\n-    DuplicatedMacroExports(ast::Ident, Span, Span),\n     ProcMacroDeriveResolutionFallback(Span),\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n     ElidedLifetimesInPaths(usize, Span, bool, Span, String),\n     UnknownCrateTypes(Span, String, String),\n     UnusedImports(String, Vec<(Span, String)>),\n-    NestedImplTrait { outer_impl_trait_span: Span, inner_impl_trait_span: Span },\n     RedundantImport(Vec<(Span, bool)>, ast::Ident),\n     DeprecatedMacro(Option<Symbol>, Span),\n }\n@@ -651,7 +582,7 @@ pub(crate) fn add_elided_lifetime_in_path_suggestion(\n     };\n     db.span_suggestion(\n         replace_span,\n-        &format!(\"indicate the anonymous lifetime{}\", pluralise!(n)),\n+        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n         suggestion,\n         Applicability::MachineApplicable\n     );\n@@ -687,10 +618,6 @@ impl BuiltinLintDiagnostics {\n                 };\n                 db.span_suggestion(span, \"use `crate`\", sugg, app);\n             }\n-            BuiltinLintDiagnostics::DuplicatedMacroExports(ident, earlier_span, later_span) => {\n-                db.span_label(later_span, format!(\"`{}` already exported\", ident));\n-                db.span_note(earlier_span, \"previous macro export is now shadowed\");\n-            }\n             BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n                 db.span_label(span, \"names from parent modules are not \\\n                                      accessible without an explicit import\");\n@@ -723,12 +650,6 @@ impl BuiltinLintDiagnostics {\n                     );\n                 }\n             }\n-            BuiltinLintDiagnostics::NestedImplTrait {\n-                outer_impl_trait_span, inner_impl_trait_span\n-            } => {\n-                db.span_label(outer_impl_trait_span, \"outer `impl Trait`\");\n-                db.span_label(inner_impl_trait_span, \"nested `impl Trait` here\");\n-            }\n             BuiltinLintDiagnostics::RedundantImport(spans, ident) => {\n                 for (span, is_imported) in spans {\n                     let introduced = if is_imported { \"imported\" } else { \"defined\" };"}, {"sha": "721baad25639fabce505077c9ccd57fb6b9bc0ce", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -699,6 +699,9 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n \n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n+    /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;\n+    /// inherent `impl` blocks are matched with the name of the type.\n+    ///\n     /// # Examples\n     ///\n     /// ```rust,ignore (no context or def id available)"}, {"sha": "1c5f86f480147cd1b78d2e73637fd5278aeb6072", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n             }\n-            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::MutImmutable }) => {\n+            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Immutable }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;"}, {"sha": "3510fe4d12359d967f55942e918644cf375201c1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -67,7 +67,7 @@ use crate::ty::adjustment;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n \n-use crate::hir::{MutImmutable, MutMutable, PatKind};\n+use crate::hir::{Mutability, PatKind};\n use crate::hir::pat_util::EnumerateAndAdjustIterator;\n use crate::hir;\n use syntax::ast::{self, Name};\n@@ -226,8 +226,8 @@ pub type McResult<T> = Result<T, ()>;\n impl MutabilityCategory {\n     pub fn from_mutbl(m: hir::Mutability) -> MutabilityCategory {\n         let ret = match m {\n-            MutImmutable => McImmutable,\n-            MutMutable => McDeclared\n+            Mutability::Immutable => McImmutable,\n+            Mutability::Mutable => McDeclared\n         };\n         debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n                \"from_mutbl\", m, ret);\n@@ -274,7 +274,7 @@ impl MutabilityCategory {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)\n                                     .expect(\"missing binding mode\");\n-                    if bm == ty::BindByValue(hir::MutMutable) {\n+                    if bm == ty::BindByValue(Mutability::Mutable) {\n                         McDeclared\n                     } else {\n                         McImmutable\n@@ -663,8 +663,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     span,\n                     cat,\n                     mutbl: match self.tcx.static_mutability(def_id).unwrap() {\n-                        hir::MutImmutable => McImmutable,\n-                        hir::MutMutable => McDeclared,\n+                        Mutability::Immutable => McImmutable,\n+                        Mutability::Mutable => McDeclared,\n                     },\n                     ty:expr_ty,\n                     note: NoteNone"}, {"sha": "f77f5a72e60ce88cd0010206598fa34e0d8ed4a3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -33,7 +33,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n     }\n \n     match item.kind {\n-        hir::ItemKind::Fn(_, header, ..) if header.is_const() => {\n+        hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => {\n             return true;\n         }\n         hir::ItemKind::Impl(..) |\n@@ -225,8 +225,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let Node::Item(item) = *node {\n-                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.kind {\n-                    header.abi != Abi::Rust\n+                let reachable = if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n+                    sig.header.abi != Abi::Rust\n                 } else {\n                     false\n                 };"}, {"sha": "f37d9b2827be03c26cc4b2b1cca2c857d1f7624b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -17,7 +17,7 @@ use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use crate::rustc::lint;\n use crate::session::Session;\n use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n-use errors::{Applicability, DiagnosticBuilder, pluralise};\n+use errors::{Applicability, DiagnosticBuilder, pluralize};\n use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -460,8 +460,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.kind {\n-            hir::ItemKind::Fn(ref decl, _, ref generics, _) => {\n-                self.visit_early_late(None, decl, generics, |this| {\n+            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n+                self.visit_early_late(None, &sig.decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -1524,8 +1524,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             {\n                 match parent {\n                     Node::Item(item) => {\n-                        if let hir::ItemKind::Fn(decl, _, _, _) = &item.kind {\n-                            find_arg_use_span(&decl.inputs);\n+                        if let hir::ItemKind::Fn(sig, _, _) = &item.kind {\n+                            find_arg_use_span(&sig.decl.inputs);\n                         }\n                     },\n                     Node::ImplItem(impl_item) => {\n@@ -3044,7 +3044,7 @@ pub fn report_missing_lifetime_specifiers(\n         span,\n         E0106,\n         \"missing lifetime specifier{}\",\n-        pluralise!(count)\n+        pluralize!(count)\n     )\n }\n "}, {"sha": "fabb0a59da81dadf3f8731a1ce57d0995a7adc04", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -22,8 +22,9 @@ use syntax::attr::{self, Stability, Deprecation, RustcDeprecation};\n use crate::ty::{self, TyCtxt};\n use crate::util::nodemap::{FxHashSet, FxHashMap};\n \n-use std::mem::replace;\n use std::cmp::Ordering;\n+use std::mem::replace;\n+use std::num::NonZeroU32;\n \n #[derive(PartialEq, Clone, Copy, Debug)]\n pub enum StabilityLevel {\n@@ -441,7 +442,7 @@ impl<'tcx> Index<'tcx> {\n                 let stability = tcx.intern_stability(Stability {\n                     level: attr::StabilityLevel::Unstable {\n                         reason: Some(Symbol::intern(reason)),\n-                        issue: 27812,\n+                        issue: NonZeroU32::new(27812),\n                         is_soft: false,\n                     },\n                     feature: sym::rustc_private,\n@@ -488,7 +489,7 @@ pub fn report_unstable(\n     sess: &Session,\n     feature: Symbol,\n     reason: Option<Symbol>,\n-    issue: u32,\n+    issue: Option<NonZeroU32>,\n     is_soft: bool,\n     span: Span,\n     soft_handler: impl FnOnce(&'static lint::Lint, Span, &str),\n@@ -520,7 +521,7 @@ pub fn report_unstable(\n             soft_handler(lint::builtin::SOFT_UNSTABLE, span, &msg)\n         } else {\n             emit_feature_err(\n-                &sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg\n+                &sess.parse_sess, feature, span, GateIssue::Library(issue), &msg\n             );\n         }\n     }\n@@ -637,7 +638,7 @@ pub enum EvalResult {\n     Deny {\n         feature: Symbol,\n         reason: Option<Symbol>,\n-        issue: u32,\n+        issue: Option<NonZeroU32>,\n         is_soft: bool,\n     },\n     /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n@@ -758,7 +759,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n-                if feature == sym::rustc_private && issue == 27812 {\n+                if feature == sym::rustc_private && issue == NonZeroU32::new(27812) {\n                     if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n                         return EvalResult::Allow;\n                     }"}, {"sha": "7b29fb26e74f51e0321b49ec61e85ed54bcde0b6", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -439,7 +439,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Ok(b as u64)\n     }\n \n-    pub fn to_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n+    pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         Ok(b as u64)\n     }\n@@ -465,7 +465,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Ok(b as i64)\n     }\n \n-    pub fn to_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n+    pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n         let sz = cx.data_layout().pointer_size;\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n@@ -592,8 +592,8 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n-        self.not_undef()?.to_usize(cx)\n+    pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n+        self.not_undef()?.to_machine_usize(cx)\n     }\n \n     #[inline(always)]\n@@ -612,8 +612,8 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n-        self.not_undef()?.to_isize(cx)\n+    pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n+        self.not_undef()?.to_machine_isize(cx)\n     }\n }\n "}, {"sha": "fd2063e2da984c329d62a71ba59a86af7e17f50a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -491,8 +491,8 @@ pub enum Mutability {\n impl From<Mutability> for hir::Mutability {\n     fn from(m: Mutability) -> Self {\n         match m {\n-            Mutability::Mut => hir::MutMutable,\n-            Mutability::Not => hir::MutImmutable,\n+            Mutability::Mut => hir::Mutability::Mutable,\n+            Mutability::Not => hir::Mutability::Immutable,\n         }\n     }\n }\n@@ -1665,6 +1665,15 @@ pub enum FakeReadCause {\n     /// Therefore, we insert a \"fake read\" here to ensure that we get\n     /// appropriate errors.\n     ForLet,\n+\n+    /// If we have an index expression like\n+    ///\n+    /// (*x)[1][{ x = y; 4}]\n+    ///\n+    /// then the first bounds check is invalidated when we evaluate the second\n+    /// index expression. Thus we create a fake borrow of `x` across the second\n+    /// indexer, which will cause a borrow check error.\n+    ForIndex,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -1764,9 +1773,8 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     def_id\n });\n \n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n@@ -2161,7 +2169,7 @@ pub enum AggregateKind<'tcx> {\n     Adt(&'tcx AdtDef, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n     Closure(DefId, SubstsRef<'tcx>),\n-    Generator(DefId, SubstsRef<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2701,7 +2709,6 @@ pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n-    ExternStatic(hir::HirId),\n     BorrowPacked(hir::HirId),\n }\n "}, {"sha": "a54635c3d51a3189a63e0706cbc1d7f541093ceb", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -486,7 +486,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n         if self.tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n             cgu_name\n         } else {\n-            let cgu_name = &cgu_name.as_str()[..];\n+            let cgu_name = &cgu_name.as_str();\n             Symbol::intern(&CodegenUnit::mangle_name(cgu_name))\n         }\n     }"}, {"sha": "c65f2b0478670a29a1bfb81eaa0ecd8ffaf54925", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -276,17 +276,17 @@ impl<'tcx> BinOp {\n impl BorrowKind {\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            BorrowKind::Mut { .. } => hir::MutMutable,\n-            BorrowKind::Shared => hir::MutImmutable,\n+            BorrowKind::Mut { .. } => hir::Mutability::Mutable,\n+            BorrowKind::Shared => hir::Mutability::Immutable,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            BorrowKind::Unique => hir::MutMutable,\n+            BorrowKind::Unique => hir::Mutability::Mutable,\n \n             // We have no type corresponding to a shallow borrow, so use\n             // `&` as an approximation.\n-            BorrowKind::Shallow => hir::MutImmutable,\n+            BorrowKind::Shallow => hir::Mutability::Immutable,\n         }\n     }\n }"}, {"sha": "bd7b77b0abb17dd7ef69cbc9b3a8a7df59eee307", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -93,7 +93,7 @@ rustc_queries! {\n         /// Maps DefId's that have an associated `mir::Body` to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n-        query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n+        query mir_const_qualif(key: DefId) -> u8 {\n             desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n@@ -228,12 +228,6 @@ rustc_queries! {\n             cycle_delay_bug\n         }\n \n-        query trivial_dropck_outlives(ty: Ty<'tcx>) -> bool {\n-            anon\n-            no_force\n-            desc { \"checking if `{:?}` has trivial dropck\", ty }\n-        }\n-\n         query adt_dtorck_constraint(\n             _: DefId\n         ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}"}, {"sha": "5baf0c5948f28a5481a25ee1111f52494d9c7349", "filename": "src/librustc/session/code_stats.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,6 +1,7 @@\n use rustc_target::abi::{Align, Size};\n use rustc_data_structures::fx::{FxHashSet};\n use std::cmp::{self, Ordering};\n+use rustc_data_structures::sync::Lock;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct VariantInfo {\n@@ -44,13 +45,13 @@ pub struct TypeSizeInfo {\n     pub variants: Vec<VariantInfo>,\n }\n \n-#[derive(PartialEq, Eq, Debug, Default)]\n+#[derive(Default)]\n pub struct CodeStats {\n-    type_sizes: FxHashSet<TypeSizeInfo>,\n+    type_sizes: Lock<FxHashSet<TypeSizeInfo>>,\n }\n \n impl CodeStats {\n-    pub fn record_type_size<S: ToString>(&mut self,\n+    pub fn record_type_size<S: ToString>(&self,\n                                          kind: DataTypeKind,\n                                          type_desc: S,\n                                          align: Align,\n@@ -73,11 +74,12 @@ impl CodeStats {\n             opt_discr_size: opt_discr_size.map(|s| s.bytes()),\n             variants,\n         };\n-        self.type_sizes.insert(info);\n+        self.type_sizes.borrow_mut().insert(info);\n     }\n \n     pub fn print_type_sizes(&self) {\n-        let mut sorted: Vec<_> = self.type_sizes.iter().collect();\n+        let type_sizes = self.type_sizes.borrow();\n+        let mut sorted: Vec<_> = type_sizes.iter().collect();\n \n         // Primary sort: large-to-small.\n         // Secondary sort: description (dictionary order)"}, {"sha": "4a14960aa69bd8f340083adeb07ee77e5b7a8af0", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 223, "deletions": 14, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,10 +1,13 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n+// ignore-tidy-filelength\n+\n use crate::lint;\n use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n+use crate::hir::map as hir_map;\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -440,6 +443,8 @@ top_level_options!(\n         // `true` if we're emitting JSON blobs about each artifact produced\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n+\n+        pretty: Option<(PpMode, Option<UserIdentifiedItem>)> [UNTRACKED],\n     }\n );\n \n@@ -621,6 +626,7 @@ impl Default for Options {\n             remap_path_prefix: Vec::new(),\n             edition: DEFAULT_EDITION,\n             json_artifact_notifications: false,\n+            pretty: None,\n         }\n     }\n }\n@@ -1800,7 +1806,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n             \"\",\n             \"extern\",\n             \"Specify where an external rust library is located\",\n-            \"NAME=PATH\",\n+            \"NAME[=PATH]\",\n         ),\n         opt::multi_s(\n             \"\",\n@@ -2164,7 +2170,6 @@ fn collect_print_requests(\n     cg: &mut CodegenOptions,\n     dopts: &mut DebuggingOptions,\n     matches: &getopts::Matches,\n-    is_unstable_enabled: bool,\n     error_format: ErrorOutputType,\n ) -> Vec<PrintRequest> {\n     let mut prints = Vec::<PrintRequest>::new();\n@@ -2206,7 +2211,7 @@ fn collect_print_requests(\n         \"tls-models\" => PrintRequest::TlsModels,\n         \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n         \"target-spec-json\" => {\n-            if is_unstable_enabled {\n+            if dopts.unstable_options {\n                 PrintRequest::TargetSpec\n             } else {\n                 early_error(\n@@ -2370,7 +2375,6 @@ fn parse_externs(\n     matches: &getopts::Matches,\n     debugging_opts: &DebuggingOptions,\n     error_format: ErrorOutputType,\n-    is_unstable_enabled: bool,\n ) -> Externs {\n     if matches.opt_present(\"extern-private\") && !debugging_opts.unstable_options {\n         early_error(\n@@ -2392,13 +2396,6 @@ fn parse_externs(\n         let name = parts.next().unwrap_or_else(||\n             early_error(error_format, \"--extern value must not be empty\"));\n         let location = parts.next().map(|s| s.to_string());\n-        if location.is_none() && !is_unstable_enabled {\n-            early_error(\n-                error_format,\n-                \"the `-Z unstable-options` flag must also be passed to \\\n-                 enable `--extern crate_name` without `=path`\",\n-            );\n-        };\n \n         let entry = externs\n             .entry(name.to_owned())\n@@ -2483,12 +2480,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         );\n     }\n \n-    let is_unstable_enabled = nightly_options::is_unstable_enabled(matches);\n     let prints = collect_print_requests(\n         &mut cg,\n         &mut debugging_opts,\n         matches,\n-        is_unstable_enabled,\n         error_format,\n     );\n \n@@ -2521,12 +2516,14 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         );\n     }\n \n-    let externs = parse_externs(matches, &debugging_opts, error_format, is_unstable_enabled);\n+    let externs = parse_externs(matches, &debugging_opts, error_format);\n \n     let crate_name = matches.opt_str(\"crate-name\");\n \n     let remap_path_prefix = parse_remap_path_prefix(matches, error_format);\n \n+    let pretty = parse_pretty(matches, &debugging_opts, error_format);\n+\n     Options {\n         crate_types,\n         optimize: opt_level,\n@@ -2557,6 +2554,73 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         remap_path_prefix,\n         edition,\n         json_artifact_notifications,\n+        pretty,\n+    }\n+}\n+\n+fn parse_pretty(\n+    matches: &getopts::Matches,\n+    debugging_opts: &DebuggingOptions,\n+    efmt: ErrorOutputType,\n+) -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+    let pretty = if debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            parse_pretty_inner(efmt, &a, false)\n+        })\n+    } else {\n+        None\n+    };\n+\n+    return if pretty.is_none() {\n+        debugging_opts.unpretty.as_ref().map(|a| {\n+            // extended with unstable pretty-print variants\n+            parse_pretty_inner(efmt, &a, true)\n+        })\n+    } else {\n+        pretty\n+    };\n+\n+    fn parse_pretty_inner(\n+        efmt: ErrorOutputType,\n+        name: &str,\n+        extended: bool,\n+    ) -> (PpMode, Option<UserIdentifiedItem>) {\n+        use PpMode::*;\n+        use PpSourceMode::*;\n+        let mut split = name.splitn(2, '=');\n+        let first = split.next().unwrap();\n+        let opt_second = split.next();\n+        let first = match (first, extended) {\n+            (\"normal\", _) => PpmSource(PpmNormal),\n+            (\"identified\", _) => PpmSource(PpmIdentified),\n+            (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n+            (\"expanded\", _) => PpmSource(PpmExpanded),\n+            (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n+            (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n+            (\"hir\", true) => PpmHir(PpmNormal),\n+            (\"hir,identified\", true) => PpmHir(PpmIdentified),\n+            (\"hir,typed\", true) => PpmHir(PpmTyped),\n+            (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n+            (\"mir\", true) => PpmMir,\n+            (\"mir-cfg\", true) => PpmMirCFG,\n+            _ => {\n+                if extended {\n+                    early_error(efmt, &format!(\"argument to `unpretty` must be one of `normal`, \\\n+                                        `expanded`, `identified`, `expanded,identified`, \\\n+                                        `expanded,hygiene`, `everybody_loops`, \\\n+                                        `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n+                                        `mir` or `mir-cfg`; got {}\",\n+                                        name));\n+                } else {\n+                    early_error(efmt, &format!(\"argument to `pretty` must be one of `normal`, \\\n+                                        `expanded`, `identified`, or `expanded,identified`; got {}\",\n+                                        name));\n+                }\n+            }\n+        };\n+        let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n+        (first, opt_second)\n     }\n }\n \n@@ -2667,6 +2731,151 @@ impl fmt::Display for CrateType {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpSourceMode {\n+    PpmNormal,\n+    PpmEveryBodyLoops,\n+    PpmExpanded,\n+    PpmIdentified,\n+    PpmExpandedIdentified,\n+    PpmExpandedHygiene,\n+    PpmTyped,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpMode {\n+    PpmSource(PpSourceMode),\n+    PpmHir(PpSourceMode),\n+    PpmHirTree(PpSourceMode),\n+    PpmMir,\n+    PpmMirCFG,\n+}\n+\n+impl PpMode {\n+    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+        use PpMode::*;\n+        use PpSourceMode::*;\n+        match *self {\n+            PpmSource(PpmNormal) |\n+            PpmSource(PpmEveryBodyLoops) |\n+            PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+            PpmSource(PpmExpanded) |\n+            PpmSource(PpmExpandedIdentified) |\n+            PpmSource(PpmExpandedHygiene) |\n+            PpmHir(_) |\n+            PpmHirTree(_) |\n+            PpmMir |\n+            PpmMirCFG => true,\n+            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n+        }\n+    }\n+\n+    pub fn needs_analysis(&self) -> bool {\n+        use PpMode::*;\n+        match *self {\n+            PpmMir | PpmMirCFG => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum UserIdentifiedItem {\n+    ItemViaNode(ast::NodeId),\n+    ItemViaPath(Vec<String>),\n+}\n+\n+impl FromStr for UserIdentifiedItem {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n+        use UserIdentifiedItem::*;\n+        Ok(s.parse()\n+            .map(ast::NodeId::from_u32)\n+            .map(ItemViaNode)\n+            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n+    }\n+}\n+\n+pub enum NodesMatchingUII<'a> {\n+    NodesMatchingDirect(std::option::IntoIter<ast::NodeId>),\n+    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n+}\n+\n+impl<'a> Iterator for NodesMatchingUII<'a> {\n+    type Item = ast::NodeId;\n+\n+    fn next(&mut self) -> Option<ast::NodeId> {\n+        use NodesMatchingUII::*;\n+        match self {\n+            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use NodesMatchingUII::*;\n+        match self {\n+            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n+            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n+        }\n+    }\n+}\n+\n+impl UserIdentifiedItem {\n+    pub fn reconstructed_input(&self) -> String {\n+        use UserIdentifiedItem::*;\n+        match *self {\n+            ItemViaNode(node_id) => node_id.to_string(),\n+            ItemViaPath(ref parts) => parts.join(\"::\"),\n+        }\n+    }\n+\n+    pub fn all_matching_node_ids<'a, 'hir>(&'a self,\n+                                       map: &'a hir_map::Map<'hir>)\n+                                       -> NodesMatchingUII<'a> {\n+        use UserIdentifiedItem::*;\n+        use NodesMatchingUII::*;\n+        match *self {\n+            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n+            ItemViaPath(ref parts) => {\n+                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n+            }\n+        }\n+    }\n+\n+    pub fn to_one_node_id(self,\n+                      user_option: &str,\n+                      sess: &Session,\n+                      map: &hir_map::Map<'_>)\n+                      -> ast::NodeId {\n+        let fail_because = |is_wrong_because| -> ast::NodeId {\n+            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n+                                   {}, which {}\",\n+                                  user_option,\n+                                  self.reconstructed_input(),\n+                                  is_wrong_because);\n+            sess.fatal(&message)\n+        };\n+\n+        let mut saw_node = ast::DUMMY_NODE_ID;\n+        let mut seen = 0;\n+        for node in self.all_matching_node_ids(map) {\n+            saw_node = node;\n+            seen += 1;\n+            if seen > 1 {\n+                fail_because(\"does not resolve uniquely\");\n+            }\n+        }\n+        if seen == 0 {\n+            fail_because(\"does not resolve to any item\");\n+        }\n+\n+        assert!(seen == 1);\n+        return saw_node;\n+    }\n+}\n+\n /// Command-line arguments passed to the compiler have to be incorporated with\n /// the dependency tracking system for incremental compilation. This module\n /// provides some utilities to make this more convenient."}, {"sha": "9792223ea15063b2893b553bb84c293635a118f4", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -21,13 +21,12 @@ use errors::{DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n use errors::emitter::HumanReadableErrorType;\n use errors::annotate_snippet_emitter_writer::{AnnotateSnippetEmitterWriter};\n-use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n use syntax::expand::allocator::AllocatorKind;\n use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n-use syntax::sess::ParseSess;\n+use syntax::sess::{ParseSess, ProcessCfgMod};\n use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n use crate::util::profiling::{SelfProfiler, SelfProfilerRef};\n@@ -38,10 +37,11 @@ use rustc_data_structures::jobserver;\n use ::jobserver::Client;\n \n use std;\n-use std::cell::{self, Cell, RefCell};\n+use std::cell::{self, RefCell};\n use std::env;\n use std::fmt;\n use std::io::Write;\n+use std::num::NonZeroU32;\n use std::path::PathBuf;\n use std::time::Duration;\n use std::sync::Arc;\n@@ -125,9 +125,7 @@ pub struct Session {\n     pub perf_stats: PerfStats,\n \n     /// Data about code being compiled, gathered during compilation.\n-    pub code_stats: Lock<CodeStats>,\n-\n-    next_node_id: OneThread<Cell<ast::NodeId>>,\n+    pub code_stats: CodeStats,\n \n     /// If `-zfuel=crate=n` is specified, `Some(crate)`.\n     optimization_fuel_crate: Option<String>,\n@@ -148,9 +146,6 @@ pub struct Session {\n     /// Metadata about the allocators for the current crate being compiled.\n     pub has_global_allocator: Once<bool>,\n \n-    /// Metadata about the panic handlers for the current crate being compiled.\n-    pub has_panic_handler: Once<bool>,\n-\n     /// Cap lint level specified by a driver specifically.\n     pub driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n \n@@ -189,7 +184,7 @@ enum DiagnosticBuilderMethod {\n pub enum DiagnosticMessageId {\n     ErrorId(u16), // EXXXX error code as integer\n     LintId(lint::LintId),\n-    StabilityId(u32), // issue number\n+    StabilityId(Option<NonZeroU32>), // issue number\n }\n \n impl From<&'static lint::Lint> for DiagnosticMessageId {\n@@ -358,21 +353,6 @@ impl Session {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n \n-    pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n-        let id = self.next_node_id.get();\n-\n-        match id.as_usize().checked_add(count) {\n-            Some(next) => {\n-                self.next_node_id.set(ast::NodeId::from_usize(next));\n-            }\n-            None => bug!(\"input too large; ran out of node-IDs!\"),\n-        }\n-\n-        id\n-    }\n-    pub fn next_node_id(&self) -> NodeId {\n-        self.reserve_node_ids(1)\n-    }\n     pub fn diagnostic(&self) -> &errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n@@ -955,6 +935,7 @@ pub fn build_session(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: errors::registry::Registry,\n+    process_cfg_mod: ProcessCfgMod,\n ) -> Session {\n     let file_path_mapping = sopts.file_path_mapping();\n \n@@ -965,6 +946,7 @@ pub fn build_session(\n         Lrc::new(source_map::SourceMap::new(file_path_mapping)),\n         DiagnosticOutput::Default,\n         Default::default(),\n+        process_cfg_mod,\n     )\n }\n \n@@ -1043,6 +1025,7 @@ pub fn build_session_with_source_map(\n     source_map: Lrc<source_map::SourceMap>,\n     diagnostics_output: DiagnosticOutput,\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+    process_cfg_mod: ProcessCfgMod,\n ) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -1083,7 +1066,14 @@ pub fn build_session_with_source_map(\n         },\n     );\n \n-    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map, lint_caps)\n+    build_session_(\n+        sopts,\n+        local_crate_source_file,\n+        diagnostic_handler,\n+        source_map,\n+        lint_caps,\n+        process_cfg_mod,\n+    )\n }\n \n fn build_session_(\n@@ -1092,6 +1082,7 @@ fn build_session_(\n     span_diagnostic: errors::Handler,\n     source_map: Lrc<source_map::SourceMap>,\n     driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+    process_cfg_mod: ProcessCfgMod,\n ) -> Session {\n     let self_profiler =\n         if let SwitchWithOptPath::Enabled(ref d) = sopts.debugging_opts.self_profile {\n@@ -1130,6 +1121,7 @@ fn build_session_(\n     let parse_sess = ParseSess::with_span_handler(\n         span_diagnostic,\n         source_map,\n+        process_cfg_mod,\n     );\n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n@@ -1190,7 +1182,6 @@ fn build_session_(\n         recursion_limit: Once::new(),\n         type_length_limit: Once::new(),\n         const_eval_stack_frame_limit: 100,\n-        next_node_id: OneThread::new(Cell::new(NodeId::from_u32(1))),\n         allocator_kind: Once::new(),\n         injected_panic_runtime: Once::new(),\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n@@ -1211,7 +1202,6 @@ fn build_session_(\n         print_fuel,\n         jobserver: jobserver::client(),\n         has_global_allocator: Once::new(),\n-        has_panic_handler: Once::new(),\n         driver_lint_caps,\n         trait_methods_not_found: Lock::new(Default::default()),\n         confused_type_with_std_module: Lock::new(Default::default()),"}, {"sha": "1645f94535ff2cf395df1e65ab02a6b6558a7698", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 40, "deletions": 106, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -367,118 +367,52 @@ fn orphan_check_trait_ref<'tcx>(\n              trait_ref);\n     }\n \n-    if tcx.features().re_rebalance_coherence {\n-        // Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only\n-        // if at least one of the following is true:\n-        //\n-        // - Trait is a local trait\n-        // (already checked in orphan_check prior to calling this function)\n-        // - All of\n-        //     - At least one of the types T0..=Tn must be a local type.\n-        //      Let Ti be the first such type.\n-        //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n-        //\n-        fn uncover_fundamental_ty<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            ty: Ty<'tcx>,\n-            in_crate: InCrate,\n-        ) -> Vec<Ty<'tcx>> {\n-            if fundamental_ty(ty) && ty_is_non_local(tcx, ty, in_crate).is_some() {\n-                ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n-            } else {\n-                vec![ty]\n-            }\n+    // Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only\n+    // if at least one of the following is true:\n+    //\n+    // - Trait is a local trait\n+    // (already checked in orphan_check prior to calling this function)\n+    // - All of\n+    //     - At least one of the types T0..=Tn must be a local type.\n+    //      Let Ti be the first such type.\n+    //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n+    //\n+    fn uncover_fundamental_ty<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        in_crate: InCrate,\n+    ) -> Vec<Ty<'tcx>> {\n+        if fundamental_ty(ty) && ty_is_non_local(tcx, ty, in_crate).is_some() {\n+            ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n+        } else {\n+            vec![ty]\n         }\n+    }\n \n-        let mut non_local_spans = vec![];\n-        for (i, input_ty) in trait_ref\n-            .input_types()\n-            .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-            .enumerate()\n-        {\n-            debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-            let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n-            if non_local_tys.is_none() {\n-                debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n-                return Ok(());\n-            } else if let ty::Param(_) = input_ty.kind {\n-                debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n-                return Err(OrphanCheckErr::UncoveredTy(input_ty))\n-            }\n-            if let Some(non_local_tys) = non_local_tys {\n-                for input_ty in non_local_tys {\n-                    non_local_spans.push((input_ty, i == 0));\n-                }\n-            }\n+    let mut non_local_spans = vec![];\n+    for (i, input_ty) in trait_ref\n+        .input_types()\n+        .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+        .enumerate()\n+    {\n+        debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n+        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n+        if non_local_tys.is_none() {\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n+            return Ok(());\n+        } else if let ty::Param(_) = input_ty.kind {\n+            debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n+            return Err(OrphanCheckErr::UncoveredTy(input_ty))\n         }\n-        // If we exit above loop, never found a local type.\n-        debug!(\"orphan_check_trait_ref: no local type\");\n-        Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n-    } else {\n-        let mut non_local_spans = vec![];\n-        // First, create an ordered iterator over all the type\n-        // parameters to the trait, with the self type appearing\n-        // first.  Find the first input type that either references a\n-        // type parameter OR some local type.\n-        for (i, input_ty) in trait_ref.input_types().enumerate() {\n-            let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n-            if non_local_tys.is_none() {\n-                debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n-\n-                // First local input type. Check that there are no\n-                // uncovered type parameters.\n-                let uncovered_tys = uncovered_tys(tcx, input_ty, in_crate);\n-                for uncovered_ty in uncovered_tys {\n-                    if let Some(param) = uncovered_ty.walk()\n-                        .find(|t| is_possibly_remote_type(t, in_crate))\n-                    {\n-                        debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n-                        return Err(OrphanCheckErr::UncoveredTy(param));\n-                    }\n-                }\n-\n-                // OK, found local type, all prior types upheld invariant.\n-                return Ok(());\n-            }\n-\n-            // Otherwise, enforce invariant that there are no type\n-            // parameters reachable.\n-            if let Some(param) = input_ty.walk()\n-                .find(|t| is_possibly_remote_type(t, in_crate))\n-            {\n-                debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n-                return Err(OrphanCheckErr::UncoveredTy(param));\n-            }\n-\n-            if let Some(non_local_tys) = non_local_tys {\n-                for input_ty in non_local_tys {\n-                    non_local_spans.push((input_ty, i == 0));\n-                }\n+        if let Some(non_local_tys) = non_local_tys {\n+            for input_ty in non_local_tys {\n+                non_local_spans.push((input_ty, i == 0));\n             }\n         }\n-        // If we exit above loop, never found a local type.\n-        debug!(\"orphan_check_trait_ref: no local type\");\n-        Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n-    }\n-}\n-\n-fn uncovered_tys<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n-    if ty_is_non_local_constructor(tcx, ty, in_crate).is_none() {\n-        vec![]\n-    } else if fundamental_ty(ty) {\n-        ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, in_crate))\n-          .collect()\n-    } else {\n-        vec![ty]\n-    }\n-}\n-\n-fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n-    match ty.kind {\n-        ty::Projection(..) | ty::Param(..) => true,\n-        _ => false,\n     }\n+    // If we exit above loop, never found a local type.\n+    debug!(\"orphan_check_trait_ref: no local type\");\n+    Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n fn ty_is_non_local<'t>(tcx: TyCtxt<'t>, ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {"}, {"sha": "f77db9621351ef6341399361d944bcd70b85f1fd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -33,7 +33,7 @@ use crate::ty::subst::Subst;\n use crate::ty::SubtypePredicate;\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n-use errors::{Applicability, DiagnosticBuilder, pluralise};\n+use errors::{Applicability, DiagnosticBuilder, pluralize};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::{sym, kw};\n@@ -383,9 +383,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let hir = &self.tcx.hir();\n         let node = hir.find(hir_id)?;\n         if let hir::Node::Item(\n-            hir::Item{kind: hir::ItemKind::Fn(_ ,fn_header ,_ , body_id), .. }) = &node {\n+            hir::Item{kind: hir::ItemKind::Fn(sig, _, body_id), .. }) = &node {\n             self.describe_generator(*body_id).or_else(||\n-                Some(if let hir::FnHeader{ asyncness: hir::IsAsync::Async, .. } = fn_header {\n+                Some(if let hir::FnHeader{ asyncness: hir::IsAsync::Async, .. } = sig.header {\n                     \"an async function\"\n                 } else {\n                     \"a function\"\n@@ -1081,7 +1081,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n \n                 hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_, _, generics, _), ..\n+                    kind: hir::ItemKind::Fn(_, generics, _), ..\n                 }) |\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n@@ -1112,7 +1112,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::ItemKind::Impl(_, _, _, generics, ..), span, ..\n                 }) |\n                 hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_, _, generics, _), span, ..\n+                    kind: hir::ItemKind::Fn(_, generics, _), span, ..\n                 }) |\n                 hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::TyAlias(_, generics), span, ..\n@@ -1130,7 +1130,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let restrict_msg = \"consider further restricting this bound\";\n                     let param_name = self_ty.to_string();\n                     for param in generics.params.iter().filter(|p| {\n-                        &param_name == std::convert::AsRef::<str>::as_ref(&p.name.ident().as_str())\n+                        p.name.ident().as_str() == param_name\n                     }) {\n                         if param_name.starts_with(\"impl \") {\n                             // `impl Trait` in argument:\n@@ -1231,7 +1231,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n@@ -1385,8 +1385,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n                 let trait_type = match mutability {\n-                    hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n-                    hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+                    hir::Mutability::Mutable => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Immutable => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n                 let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n@@ -1403,7 +1403,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let sp = self.tcx.sess.source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n                     if points_at_arg &&\n-                        mutability == hir::Mutability::MutImmutable &&\n+                        mutability == hir::Mutability::Immutable &&\n                         refs_number > 0\n                     {\n                         err.span_suggestion(\n@@ -1436,12 +1436,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(decl, _, _, body_id),\n+            kind: hir::ItemKind::Fn(sig, _, body_id),\n             ..\n         })) = node {\n             let body = hir.body(*body_id);\n             if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n-                if decl.output.span().overlaps(span) && blk.expr.is_none() &&\n+                if sig.decl.output.span().overlaps(span) && blk.expr.is_none() &&\n                     \"()\" == &trait_ref.self_ty().to_string()\n                 {\n                     // FIXME(estebank): When encountering a method with a trait\n@@ -1493,20 +1493,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Node::Item(&hir::Item {\n                 span,\n-                kind: hir::ItemKind::Fn(ref decl, ..),\n+                kind: hir::ItemKind::Fn(ref sig, ..),\n                 ..\n             }) |\n             Node::ImplItem(&hir::ImplItem {\n                 span,\n-                kind: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n+                kind: hir::ImplItemKind::Method(ref sig, _),\n                 ..\n             }) |\n             Node::TraitItem(&hir::TraitItem {\n                 span,\n-                kind: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n+                kind: hir::TraitItemKind::Method(ref sig, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), decl.inputs.iter()\n+                (self.tcx.sess.source_map().def_span(span), sig.decl.inputs.iter()\n                         .map(|arg| match arg.clone().kind {\n                     hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n@@ -1553,7 +1553,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 _ => format!(\"{} {}argument{}\",\n                              arg_length,\n                              if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n-                             pluralise!(arg_length))\n+                             pluralize!(arg_length))\n             }\n         };\n \n@@ -2040,11 +2040,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .and_then(|parent_did| self.tcx.hir().get_if_local(parent_did));\n         debug!(\"note_obligation_cause_for_async_await: parent_node={:?}\", parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(_, header, _, _),\n+            kind: hir::ItemKind::Fn(sig, _, _),\n             ..\n         })) = parent_node {\n-            debug!(\"note_obligation_cause_for_async_await: header={:?}\", header);\n-            if header.asyncness != hir::IsAsync::Async {\n+            debug!(\"note_obligation_cause_for_async_await: header={:?}\", sig.header);\n+            if sig.header.asyncness != hir::IsAsync::Async {\n                 return false;\n             }\n         }\n@@ -2287,11 +2287,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            ObligationCauseCode::AssocTypeBound(impl_span, orig) => {\n-                err.span_label(orig, \"associated type defined here\");\n-                if let Some(sp) = impl_span {\n+            ObligationCauseCode::AssocTypeBound(ref data) => {\n+                err.span_label(data.original, \"associated type defined here\");\n+                if let Some(sp) = data.impl_span {\n                     err.span_label(sp, \"in this `impl` item\");\n                 }\n+                for sp in &data.bounds {\n+                    err.span_label(*sp, \"restricted in this bound\");\n+                }\n             }\n         }\n     }"}, {"sha": "a29d8c66d811d73842dda9872b740da5ba082c6c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -276,7 +276,14 @@ pub enum ObligationCauseCode<'tcx> {\n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,\n \n-    AssocTypeBound(/*impl*/ Option<Span>, /*original*/ Span),\n+    AssocTypeBound(Box<AssocTypeBoundData>),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AssocTypeBoundData {\n+    pub impl_span: Option<Span>,\n+    pub original: Span,\n+    pub bounds: Vec<Span>,\n }\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger."}, {"sha": "b64e44b6a5afba877ebf6c671db1b93a5b0311cb", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -180,7 +180,7 @@ impl<'tcx> OnUnimplementedDirective {\n                     c.ident().map_or(false, |ident| {\n                         options.contains(&(\n                             ident.name,\n-                            c.value_str().map(|s| s.as_str().to_string())\n+                            c.value_str().map(|s| s.to_string())\n                         ))\n                     })\n                 }) {"}, {"sha": "eaf5971e4592f32044765236d47701f36a4e49a6", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -5,7 +5,6 @@ use std::iter::FromIterator;\n use syntax::source_map::Span;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::query::Providers;\n \n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -34,7 +33,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n         // Quick check: there are a number of cases that we know do not require\n         // any destructor.\n         let tcx = self.infcx.tcx;\n-        if tcx.trivial_dropck_outlives(ty) {\n+        if trivial_dropck_outlives(tcx, ty) {\n             return InferOk {\n                 value: vec![],\n                 obligations: vec![],\n@@ -208,15 +207,15 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Error => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::Array(ty, _) | ty::Slice(ty) => tcx.trivial_dropck_outlives(ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().all(|t| tcx.trivial_dropck_outlives(t.expect_ty())),\n+        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n         ty::Closure(def_id, ref substs) => substs\n             .as_closure()\n             .upvar_tys(def_id, tcx)\n-            .all(|t| tcx.trivial_dropck_outlives(t)),\n+            .all(|t| trivial_dropck_outlives(tcx, t)),\n \n         ty::Adt(def, _) => {\n             if Some(def.did) == tcx.lang_items().manually_drop() {\n@@ -244,10 +243,3 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n     }\n }\n-\n-crate fn provide(p: &mut Providers<'_>) {\n-    *p = Providers {\n-        trivial_dropck_outlives,\n-        ..*p\n-    };\n-}"}, {"sha": "81c3857cbf8d83d407e0a790d8dd0ad705072d39", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n-use crate::traits::query::dropck_outlives::DropckOutlivesResult;\n+use crate::traits::query::dropck_outlives::{DropckOutlivesResult, trivial_dropck_outlives};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -21,7 +21,7 @@ impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n-        if tcx.trivial_dropck_outlives(key.value.dropped_ty) {\n+        if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n             Some(DropckOutlivesResult::default())\n         } else {\n             None"}, {"sha": "04b2597af22415265cbd68f3caec6e036d720e49", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2195,11 +2195,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     if self.tcx().lang_items().unpin_trait() == Some(def_id) =>\n                 {\n                     match movability {\n-                        hir::GeneratorMovability::Static => {\n+                        hir::Movability::Static => {\n                             // Immovable generators are never `Unpin`, so\n                             // suppress the normal auto-impl candidate for it.\n                         }\n-                        hir::GeneratorMovability::Movable => {\n+                        hir::Movability::Movable => {\n                             // Movable generators are always `Unpin`, so add an\n                             // unconditional builtin candidate.\n                             candidates.vec.push(BuiltinCandidate {\n@@ -2652,7 +2652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Char\n             | ty::RawPtr(..)\n             | ty::Never\n-            | ty::Ref(_, _, hir::MutImmutable) => {\n+            | ty::Ref(_, _, hir::Mutability::Immutable) => {\n                 // Implementations provided in libcore\n                 None\n             }\n@@ -2663,7 +2663,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n             | ty::Foreign(..)\n-            | ty::Ref(_, _, hir::MutMutable) => None,\n+            | ty::Ref(_, _, hir::Mutability::Mutable) => None,\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here"}, {"sha": "59f2bb3754803e4690d68ddb3726cf008cac75eb", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::MethodReceiver => Some(super::MethodReceiver),\n             super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n             super::TrivialBound => Some(super::TrivialBound),\n-            super::AssocTypeBound(impl_sp, sp) => Some(super::AssocTypeBound(impl_sp, sp)),\n+            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n         }\n     }\n }"}, {"sha": "f5ab1eb38c3c6e32a6dc23b0be6b4710c7e22b88", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -20,6 +20,9 @@ pub enum PointerCast {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n+    /// Go from `*const [T; N]` to `*const T`\n+    ArrayToPointer,\n+\n     /// Unsize a pointer/reference value, e.g., `&[T; n]` to\n     /// `&[T]`. Note that the source could be a thin or fat pointer.\n     /// This will do things like convert thin pointers to fat\n@@ -106,8 +109,8 @@ pub struct OverloadedDeref<'tcx> {\n impl<'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::MutImmutable => tcx.lang_items().deref_trait(),\n-            hir::MutMutable => tcx.lang_items().deref_mut_trait()\n+            hir::Mutability::Immutable => tcx.lang_items().deref_trait(),\n+            hir::Mutability::Mutable => tcx.lang_items().deref_mut_trait()\n         };\n         let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n             .find(|m| m.kind == ty::AssocKind::Method).unwrap().def_id;\n@@ -142,8 +145,8 @@ pub enum AutoBorrowMutability {\n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {\n-            AutoBorrowMutability::Mutable { .. } => hir::MutMutable,\n-            AutoBorrowMutability::Immutable => hir::MutImmutable,\n+            AutoBorrowMutability::Mutable { .. } => hir::Mutability::Mutable,\n+            AutoBorrowMutability::Immutable => hir::Mutability::Immutable,\n         }\n     }\n }"}, {"sha": "905d7abb7828c7eb8b4a15bea2f50fe458b6d8d4", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -13,10 +13,10 @@ CloneTypeFoldableAndLiftImpls! { BindingMode, }\n impl BindingMode {\n     pub fn convert(ba: BindingAnnotation) -> BindingMode {\n         match ba {\n-            Unannotated => BindingMode::BindByValue(Mutability::MutImmutable),\n-            Mutable => BindingMode::BindByValue(Mutability::MutMutable),\n-            Ref => BindingMode::BindByReference(Mutability::MutImmutable),\n-            RefMut => BindingMode::BindByReference(Mutability::MutMutable),\n+            Unannotated => BindingMode::BindByValue(Mutability::Immutable),\n+            Mutable => BindingMode::BindByValue(Mutability::Mutable),\n+            Ref => BindingMode::BindByReference(Mutability::Immutable),\n+            RefMut => BindingMode::BindByReference(Mutability::Mutable),\n         }\n     }\n }"}, {"sha": "b3ef3217ec6a091a19a67b82ffe0e773a0111c78", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -76,7 +76,10 @@ pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n \n     // The shorthand encoding uses the same usize as the\n     // discriminant, with an offset so they can't conflict.\n+    #[cfg(bootstrap)]\n     let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n+    #[cfg(not(bootstrap))]\n+    let discriminant = intrinsics::discriminant_value(variant);\n     assert!(discriminant < SHORTHAND_OFFSET as u64);\n     let shorthand = start + SHORTHAND_OFFSET;\n "}, {"sha": "04e0f6f4b56d71856434c6e71f905b07f306d4fd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2410,22 +2410,22 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n     }\n \n     #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n     }\n \n     #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n     }\n \n     #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n     }\n \n     #[inline]\n@@ -2516,7 +2516,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn mk_generator(self,\n                         id: DefId,\n                         generator_substs: SubstsRef<'tcx>,\n-                        movability: hir::GeneratorMovability)\n+                        movability: hir::Movability)\n                         -> Ty<'tcx> {\n         self.mk_ty(Generator(id, generator_substs, movability))\n     }\n@@ -3045,4 +3045,9 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n     };\n+    providers.has_panic_handler = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        // We want to check if the panic handler was defined in this crate\n+        tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n+    };\n }"}, {"sha": "c61d559af53f5867db3b641a4c2b515aa4ed9255", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,7 +4,7 @@ use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n-use syntax::errors::pluralise;\n+use syntax::errors::pluralize;\n use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n \n@@ -100,17 +100,17 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 write!(f, \"expected a tuple with {} element{}, \\\n                            found one with {} element{}\",\n                        values.expected,\n-                       pluralise!(values.expected),\n+                       pluralize!(values.expected),\n                        values.found,\n-                       pluralise!(values.found))\n+                       pluralize!(values.found))\n             }\n             FixedArraySize(values) => {\n                 write!(f, \"expected an array with a fixed size of {} element{}, \\\n                            found one with {} element{}\",\n                        values.expected,\n-                       pluralise!(values.expected),\n+                       pluralize!(values.expected),\n                        values.found,\n-                       pluralise!(values.found))\n+                       pluralize!(values.found))\n             }\n             ArgCount => {\n                 write!(f, \"incorrect number of function parameters\")\n@@ -165,7 +165,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ProjectionBoundsLength(ref values) => {\n                 write!(f, \"expected {} associated type binding{}, found {}\",\n                        values.expected,\n-                       pluralise!(values.expected),\n+                       pluralize!(values.expected),\n                        values.found)\n             },\n             ExistentialMismatch(ref values) => {\n@@ -196,7 +196,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 let n = tcx.lift(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     Some(n) => {\n-                        format!(\"array of {} element{}\", n, pluralise!(n)).into()\n+                        format!(\"array of {} element{}\", n, pluralize!(n)).into()\n                     }\n                     None => \"array\".into(),\n                 }\n@@ -211,7 +211,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                    region.to_string() != \"'_\"     //... or a complex type\n                 {\n                     format!(\"{}reference\", match mutbl {\n-                        hir::Mutability::MutMutable => \"mutable \",\n+                        hir::Mutability::Mutable => \"mutable \",\n                         _ => \"\"\n                     }).into()\n                 } else {\n@@ -241,7 +241,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n-            ty::Param(_) => \"type parameter\".into(),\n+            ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n         }\n@@ -254,6 +254,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         db: &mut DiagnosticBuilder<'_>,\n         err: &TypeError<'tcx>,\n         sp: Span,\n+        body_owner_def_id: DefId,\n     ) {\n         use self::TypeError::*;\n \n@@ -288,7 +289,16 @@ impl<'tcx> TyCtxt<'tcx> {\n                             );\n                         }\n                     },\n-                    (ty::Param(_), ty::Param(_)) => {\n+                    (ty::Param(expected), ty::Param(found)) => {\n+                        let generics = self.generics_of(body_owner_def_id);\n+                        let e_span = self.def_span(generics.type_param(expected, self).def_id);\n+                        if !sp.contains(e_span) {\n+                            db.span_label(e_span, \"expected type parameter\");\n+                        }\n+                        let f_span = self.def_span(generics.type_param(found, self).def_id);\n+                        if !sp.contains(f_span) {\n+                            db.span_label(f_span, \"found type parameter\");\n+                        }\n                         db.note(\"a type parameter was expected, but a different one was found; \\\n                                  you might be missing a type parameter or trait bound\");\n                         db.note(\"for more information, visit \\\n@@ -301,7 +311,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     (ty::Param(_), ty::Projection(_)) | (ty::Projection(_), ty::Param(_)) => {\n                         db.note(\"you might be missing a type parameter or trait bound\");\n                     }\n-                    (ty::Param(_), _) | (_, ty::Param(_)) => {\n+                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n+                        let generics = self.generics_of(body_owner_def_id);\n+                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n+                        if !sp.contains(p_span) {\n+                            db.span_label(p_span, \"this type parameter\");\n+                        }\n                         db.help(\"type parameters must be constrained to match other types\");\n                         if self.sess.teach(&db.get_code().unwrap()) {\n                             db.help(\"given a type parameter `T` and a method `foo`:"}, {"sha": "227fbf967c0d7e85545afe132f08c55dfac32464", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -76,19 +76,19 @@ impl<'tcx> DefIdForest {\n                 break;\n             }\n \n-            for id in ret.root_ids.drain() {\n+            for id in ret.root_ids.drain(..) {\n                 if next_forest.contains(tcx, id) {\n                     next_ret.push(id);\n                 } else {\n                     old_ret.push(id);\n                 }\n             }\n-            ret.root_ids.extend(old_ret.drain());\n+            ret.root_ids.extend(old_ret.drain(..));\n \n             next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n \n             mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain();\n+            next_ret.drain(..);\n         }\n         ret\n     }\n@@ -101,7 +101,7 @@ impl<'tcx> DefIdForest {\n         let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();\n         for next_forest in iter {\n-            next_ret.extend(ret.root_ids.drain().filter(|&id| !next_forest.contains(tcx, id)));\n+            next_ret.extend(ret.root_ids.drain(..).filter(|&id| !next_forest.contains(tcx, id)));\n \n             for id in next_forest.root_ids {\n                 if !next_ret.contains(&id) {\n@@ -110,7 +110,7 @@ impl<'tcx> DefIdForest {\n             }\n \n             mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain();\n+            next_ret.drain(..);\n         }\n         ret\n     }"}, {"sha": "972452601ddd5c6ef192bf19a277177f8d76ce34", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -132,8 +132,8 @@ impl PrimitiveExt for Primitive {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n-            Float(FloatTy::F32) => tcx.types.f32,\n-            Float(FloatTy::F64) => tcx.types.f64,\n+            F32 => tcx.types.f32,\n+            F64 => tcx.types.f64,\n             Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n@@ -144,7 +144,7 @@ impl PrimitiveExt for Primitive {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             Pointer => tcx.types.usize,\n-            Float(..) => bug!(\"floats do not have an int type\"),\n+            F32 | F64 => bug!(\"floats do not have an int type\"),\n         }\n     }\n }\n@@ -538,7 +538,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Uint(ity) => {\n                 scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n-            ty::Float(fty) => scalar(Float(fty)),\n+            ty::Float(fty) => scalar(match fty {\n+                ast::FloatTy::F32 => F32,\n+                ast::FloatTy::F64 => F64,\n+            }),\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range = 1..=*ptr.valid_range.end();\n@@ -1611,13 +1614,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // (delay format until we actually need it)\n         let record = |kind, packed, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", layout.ty);\n-            self.tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n-                                                                   type_desc,\n-                                                                   layout.align.abi,\n-                                                                   layout.size,\n-                                                                   packed,\n-                                                                   opt_discr_size,\n-                                                                   variants);\n+            self.tcx.sess.code_stats.record_type_size(kind,\n+                                                      type_desc,\n+                                                      layout.align.abi,\n+                                                      layout.size,\n+                                                      packed,\n+                                                      opt_discr_size,\n+                                                      variants);\n         };\n \n         let adt_def = match layout.ty.kind {\n@@ -2218,12 +2221,12 @@ where\n                 let tcx = cx.tcx();\n                 let is_freeze = ty.is_freeze(tcx, cx.param_env(), DUMMY_SP);\n                 let kind = match mt {\n-                    hir::MutImmutable => if is_freeze {\n+                    hir::Mutability::Immutable => if is_freeze {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n-                    hir::MutMutable => {\n+                    hir::Mutability::Mutable => {\n                         // Previously we would only emit noalias annotations for LLVM >= 6 or in\n                         // panic=abort mode. That was deemed right, as prior versions had many bugs\n                         // in conjunction with unwinding, but later versions didn\u2019t seem to have\n@@ -2454,7 +2457,8 @@ impl_stable_hash_for!(enum crate::ty::layout::Integer {\n \n impl_stable_hash_for!(enum crate::ty::layout::Primitive {\n     Int(integer, signed),\n-    Float(fty),\n+    F32,\n+    F64,\n     Pointer\n });\n "}, {"sha": "e4ed1cd198e528700d1d13bdf22cead8e320db29", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2693,8 +2693,8 @@ impl<'tcx> TyS<'tcx> {\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n-            hir::MutMutable => MutBorrow,\n-            hir::MutImmutable => ImmBorrow,\n+            hir::Mutability::Mutable => MutBorrow,\n+            hir::Mutability::Immutable => ImmBorrow,\n         }\n     }\n \n@@ -2704,13 +2704,13 @@ impl BorrowKind {\n     /// question.\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            MutBorrow => hir::MutMutable,\n-            ImmBorrow => hir::MutImmutable,\n+            MutBorrow => hir::Mutability::Mutable,\n+            ImmBorrow => hir::Mutability::Immutable,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => hir::MutMutable,\n+            UniqueImmBorrow => hir::Mutability::Mutable,\n         }\n     }\n \n@@ -3407,7 +3407,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     layout::provide(providers);\n     util::provide(providers);\n     constness::provide(providers);\n-    crate::traits::query::dropck_outlives::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,\n         associated_item,"}, {"sha": "0389218b61d24d165eb3792ab87fe0b962ba6de5", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -12,7 +12,6 @@ use rustc::ty::{self, Const, Instance, Ty, TyCtxt};\n use rustc::{bug, hir};\n use std::fmt::Write;\n use std::iter;\n-use syntax::ast;\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n@@ -39,20 +38,9 @@ impl DefPathBasedNames<'tcx> {\n             ty::Char => output.push_str(\"char\"),\n             ty::Str => output.push_str(\"str\"),\n             ty::Never => output.push_str(\"!\"),\n-            ty::Int(ast::IntTy::Isize) => output.push_str(\"isize\"),\n-            ty::Int(ast::IntTy::I8) => output.push_str(\"i8\"),\n-            ty::Int(ast::IntTy::I16) => output.push_str(\"i16\"),\n-            ty::Int(ast::IntTy::I32) => output.push_str(\"i32\"),\n-            ty::Int(ast::IntTy::I64) => output.push_str(\"i64\"),\n-            ty::Int(ast::IntTy::I128) => output.push_str(\"i128\"),\n-            ty::Uint(ast::UintTy::Usize) => output.push_str(\"usize\"),\n-            ty::Uint(ast::UintTy::U8) => output.push_str(\"u8\"),\n-            ty::Uint(ast::UintTy::U16) => output.push_str(\"u16\"),\n-            ty::Uint(ast::UintTy::U32) => output.push_str(\"u32\"),\n-            ty::Uint(ast::UintTy::U64) => output.push_str(\"u64\"),\n-            ty::Uint(ast::UintTy::U128) => output.push_str(\"u128\"),\n-            ty::Float(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-            ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::Int(ty) => output.push_str(ty.name_str()),\n+            ty::Uint(ty) => output.push_str(ty.name_str()),\n+            ty::Float(ty) => output.push_str(ty.name_str()),\n             ty::Adt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n                 self.push_generic_params(substs, iter::empty(), output, debug);\n@@ -72,17 +60,15 @@ impl DefPathBasedNames<'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n                 output.push('*');\n                 match mutbl {\n-                    hir::MutImmutable => output.push_str(\"const \"),\n-                    hir::MutMutable => output.push_str(\"mut \"),\n+                    hir::Mutability::Immutable => output.push_str(\"const \"),\n+                    hir::Mutability::Mutable => output.push_str(\"mut \"),\n                 }\n \n                 self.push_type_name(inner_type, output, debug);\n             }\n             ty::Ref(_, inner_type, mutbl) => {\n                 output.push('&');\n-                if mutbl == hir::MutMutable {\n-                    output.push_str(\"mut \");\n-                }\n+                output.push_str(mutbl.prefix_str());\n \n                 self.push_type_name(inner_type, output, debug);\n             }\n@@ -114,9 +100,7 @@ impl DefPathBasedNames<'tcx> {\n             ty::Foreign(did) => self.push_def_path(did, output),\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let sig = t.fn_sig(self.tcx);\n-                if sig.unsafety() == hir::Unsafety::Unsafe {\n-                    output.push_str(\"unsafe \");\n-                }\n+                output.push_str(sig.unsafety().prefix_str());\n \n                 let abi = sig.abi();\n                 if abi != ::rustc_target::spec::abi::Abi::Rust {"}, {"sha": "fdd3a1faaa975c6884fafd2f4bf1f12e914ed15b", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -466,13 +466,13 @@ pub trait PrettyPrinter<'tcx>:\n         match ty.kind {\n             ty::Bool => p!(write(\"bool\")),\n             ty::Char => p!(write(\"char\")),\n-            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Int(t) => p!(write(\"{}\", t.name_str())),\n+            ty::Uint(t) => p!(write(\"{}\", t.name_str())),\n+            ty::Float(t) => p!(write(\"{}\", t.name_str())),\n             ty::RawPtr(ref tm) => {\n                 p!(write(\"*{} \", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n+                    hir::Mutability::Mutable => \"mut\",\n+                    hir::Mutability::Immutable => \"const\",\n                 }));\n                 p!(print(tm.ty))\n             }\n@@ -607,10 +607,9 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Generator(did, substs, movability) => {\n                 let upvar_tys = substs.as_generator().upvar_tys(did, self.tcx());\n                 let witness = substs.as_generator().witness(did, self.tcx());\n-                if movability == hir::GeneratorMovability::Movable {\n-                    p!(write(\"[generator\"));\n-                } else {\n-                    p!(write(\"[static generator\"));\n+                match movability {\n+                    hir::Movability::Movable => p!(write(\"[generator\")),\n+                    hir::Movability::Static  => p!(write(\"[static generator\")),\n                 }\n \n                 // FIXME(eddyb) should use `def_span`.\n@@ -895,10 +894,11 @@ pub trait PrettyPrinter<'tcx>:\n                 let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n                 let max = truncate(u128::max_value(), bit_size);\n \n+                let ui_str = ui.name_str();\n                 if data == max {\n-                    p!(write(\"std::{}::MAX\", ui))\n+                    p!(write(\"std::{}::MAX\", ui_str))\n                 } else {\n-                    p!(write(\"{}{}\", data, ui))\n+                    p!(write(\"{}{}\", data, ui_str))\n                 };\n             },\n             (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n@@ -911,10 +911,11 @@ pub trait PrettyPrinter<'tcx>:\n                 let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                     .unwrap()\n                     .size;\n+                let i_str = i.name_str();\n                 match data {\n-                    d if d == min => p!(write(\"std::{}::MIN\", i)),\n-                    d if d == max => p!(write(\"std::{}::MAX\", i)),\n-                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n+                    d if d == min => p!(write(\"std::{}::MIN\", i_str)),\n+                    d if d == max => p!(write(\"std::{}::MAX\", i_str)),\n+                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i_str))\n                 }\n             },\n             (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) =>\n@@ -1666,8 +1667,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TypeAndMut<'tcx> {\n-        p!(write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n-            print(self.ty))\n+        p!(write(\"{}\", self.mutbl.prefix_str()), print(self.ty))\n     }\n \n     ty::ExistentialTraitRef<'tcx> {\n@@ -1693,9 +1693,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::FnSig<'tcx> {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            p!(write(\"unsafe \"));\n-        }\n+        p!(write(\"{}\", self.unsafety.prefix_str()));\n \n         if self.abi != Abi::Rust {\n             p!(write(\"extern {} \", self.abi));"}, {"sha": "0615004125b3ca94df1720fb94ca0241b1f96eb9", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -42,7 +42,6 @@ use crate::util::common::ErrorReported;\n use crate::util::profiling::ProfileCategory::*;\n \n use rustc_data_structures::svh::Svh;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::fx::{FxIndexMap, FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;"}, {"sha": "4031eb6219432d523c424c3baadb2f9e3bcebb17", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -264,7 +264,7 @@ impl<'sess> OnDiskCache<'sess> {\n             let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n             let prev_cnums: Vec<_> = sorted_cnums.iter()\n                 .map(|&cnum| {\n-                    let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+                    let crate_name = tcx.original_crate_name(cnum).to_string();\n                     let crate_disambiguator = tcx.crate_disambiguator(cnum);\n                     (cnum.as_u32(), crate_name, crate_disambiguator)\n                 })\n@@ -796,11 +796,6 @@ where\n         }\n \n         let span_data = span.data();\n-\n-        if span_data.hi < span_data.lo {\n-            return TAG_INVALID_SPAN.encode(self);\n-        }\n-\n         let (file_lo, line_lo, col_lo) = match self.source_map\n                                                    .byte_pos_to_line_and_col(span_data.lo) {\n             Some(pos) => pos,"}, {"sha": "9b5cdc489a8b5330fb5031f31afb6c5b7095238b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -121,8 +121,8 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n         } else {\n             let mutbl = a.mutbl;\n             let variance = match mutbl {\n-                ast::Mutability::MutImmutable => ty::Covariant,\n-                ast::Mutability::MutMutable => ty::Invariant,\n+                ast::Mutability::Immutable => ty::Covariant,\n+                ast::Mutability::Mutable => ty::Invariant,\n             };\n             let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })"}, {"sha": "51cf7550c30f7c404d88edbf33b2731946514d55", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -162,7 +162,7 @@ pub enum TyKind<'tcx> {\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n-    Generator(DefId, SubstsRef<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n \n     /// A type representin the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n@@ -1839,8 +1839,8 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n         match self.kind {\n-            RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n-            Ref(_, _, hir::Mutability::MutMutable) => true,\n+            RawPtr(TypeAndMut { mutbl: hir::Mutability::Mutable, .. }) |\n+            Ref(_, _, hir::Mutability::Mutable) => true,\n             _ => false\n         }\n     }\n@@ -2030,7 +2030,7 @@ impl<'tcx> TyS<'tcx> {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n-                    mutbl: hir::MutImmutable,\n+                    mutbl: hir::Mutability::Immutable,\n                 })\n             },\n             Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),"}, {"sha": "d46320abff2ad795c6a2ff048393b98c736f1c80", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // Now libcore provides that impl.\n                 ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n                 ty::Char | ty::RawPtr(..) | ty::Never |\n-                ty::Ref(_, _, hir::MutImmutable) => return Ok(()),\n+                ty::Ref(_, _, hir::Mutability::Immutable) => return Ok(()),\n \n                 ty::Adt(adt, substs) => (adt, substs),\n \n@@ -680,7 +680,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns `true` if the node pointed to by `def_id` is a mutable `static` item.\n     pub fn is_mutable_static(&self, def_id: DefId) -> bool {\n-        self.static_mutability(def_id) == Some(hir::MutMutable)\n+        self.static_mutability(def_id) == Some(hir::Mutability::Mutable)\n     }\n \n     /// Expands the given impl trait type, stopping if the type is recursive."}, {"sha": "f9e7a8030a6fc6a50418c53c007fa58cb73df6dc", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 89, "deletions": 12, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2,9 +2,10 @@ use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::ty::subst::SubstsRef;\n-use crate::traits;\n+use crate::traits::{self, AssocTypeBoundData};\n use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n+use syntax::symbol::{kw, Ident};\n use syntax_pos::Span;\n use crate::middle::lang_items;\n use crate::mir::interpret::ConstValue;\n@@ -176,6 +177,23 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             pred: &ty::Predicate<'_>,\n             trait_assoc_items: ty::AssocItemsIterator<'_>,\n         | {\n+            let trait_item = tcx.hir().as_local_hir_id(trait_ref.def_id).and_then(|trait_id| {\n+                tcx.hir().find(trait_id)\n+            });\n+            let (trait_name, trait_generics) = match trait_item {\n+                Some(hir::Node::Item(hir::Item {\n+                    ident,\n+                    kind: hir::ItemKind::Trait(.., generics, _, _),\n+                    ..\n+                })) |\n+                Some(hir::Node::Item(hir::Item {\n+                    ident,\n+                    kind: hir::ItemKind::TraitAlias(generics, _),\n+                    ..\n+                })) => (Some(ident), Some(generics)),\n+                _ => (None, None),\n+            };\n+\n             let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n             match pred {\n                 ty::Predicate::Projection(proj) => {\n@@ -226,10 +244,11 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             item.ident == trait_assoc_item.ident\n                         }).next() {\n                             cause.span = impl_item.span;\n-                            cause.code = traits::AssocTypeBound(\n-                                item_span,\n-                                trait_assoc_item.ident.span,\n-                            );\n+                            cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                                impl_span: item_span,\n+                                original: trait_assoc_item.ident.span,\n+                                bounds: vec![],\n+                            }));\n                         }\n                     }\n                 }\n@@ -251,14 +270,13 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     //   LL |     type Assoc = bool;\n                     //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n                     //\n-                    // FIXME: if the obligation comes from the where clause in the `trait`, we\n-                    // should point at it:\n+                    // If the obligation comes from the where clause in the `trait`, we point at it:\n                     //\n                     //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n                     //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n                     //      |\n                     //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n-                    //      |                 -------------------------- obligation set here\n+                    //      |                 -------------------------- restricted in this bound\n                     //   LL |     type Assoc;\n                     //      |          ----- associated type defined here\n                     //   ...\n@@ -278,11 +296,17 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 .next()\n                                 .map(|impl_item| (impl_item, trait_assoc_item)))\n                         {\n+                            let bounds = trait_generics.map(|generics| get_generic_bound_spans(\n+                                &generics,\n+                                trait_name,\n+                                trait_assoc_item.ident,\n+                            )).unwrap_or_else(Vec::new);\n                             cause.span = impl_item.span;\n-                            cause.code = traits::AssocTypeBound(\n-                                item_span,\n-                                trait_assoc_item.ident.span,\n-                            );\n+                            cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                                impl_span: item_span,\n+                                original: trait_assoc_item.ident.span,\n+                                bounds,\n+                            }));\n                         }\n                     }\n                 }\n@@ -666,3 +690,56 @@ pub fn object_region_bounds<'tcx>(\n \n     tcx.required_region_bounds(open_ty, predicates)\n }\n+\n+/// Find the span of a generic bound affecting an associated type.\n+fn get_generic_bound_spans(\n+    generics: &hir::Generics,\n+    trait_name: Option<&Ident>,\n+    assoc_item_name: Ident,\n+) -> Vec<Span> {\n+    let mut bounds = vec![];\n+    for clause in generics.where_clause.predicates.iter() {\n+        if let hir::WherePredicate::BoundPredicate(pred) = clause {\n+            match &pred.bounded_ty.kind {\n+                hir::TyKind::Path(hir::QPath::Resolved(Some(ty), path)) => {\n+                    let mut s = path.segments.iter();\n+                    if let (a, Some(b), None) = (s.next(), s.next(), s.next()) {\n+                        if a.map(|s| &s.ident) == trait_name\n+                            && b.ident == assoc_item_name\n+                            && is_self_path(&ty.kind)\n+                        {\n+                            // `<Self as Foo>::Bar`\n+                            bounds.push(pred.span);\n+                        }\n+                    }\n+                }\n+                hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n+                    if segment.ident == assoc_item_name {\n+                        if is_self_path(&ty.kind) {\n+                            // `Self::Bar`\n+                            bounds.push(pred.span);\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+    bounds\n+}\n+\n+fn is_self_path(kind: &hir::TyKind) -> bool {\n+    match kind {\n+        hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n+            let mut s = path.segments.iter();\n+            if let (Some(segment), None) = (s.next(), s.next()) {\n+                if segment.ident.name == kw::SelfUpper {\n+                    // `type(Self)`\n+                    return true;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+    false\n+}"}, {"sha": "726965e1e7180411fe153998e248c9926e62475e", "filename": "src/librustc_apfloat/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -10,4 +10,4 @@ path = \"lib.rs\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "6f4e7d0f0caf5a00572dc174d9843fa47964781c", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -314,7 +314,7 @@ pub fn from_fn_attrs(\n             codegen_fn_attrs.target_features\n                 .iter()\n                 .map(|f| {\n-                    let feature = &*f.as_str();\n+                    let feature = &f.as_str();\n                     format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n                 })\n         )"}, {"sha": "e5a5d05ba5ec7920d52f5af4925f2b9ec236cb81", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -161,6 +161,7 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n     let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n+    let abi = SmallCStr::new(&sess.target.target.options.llvm_abiname);\n     let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n@@ -170,7 +171,7 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     Arc::new(move || {\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n-                triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n+                triple.as_ptr(), cpu.as_ptr(), features.as_ptr(), abi.as_ptr(),\n                 code_model,\n                 reloc_model,\n                 opt_level,\n@@ -239,9 +240,7 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n     }\n }\n \n-unsafe extern \"C\" fn report_inline_asm(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                                       msg: &str,\n-                                       cookie: c_uint) {\n+fn report_inline_asm(cgcx: &CodegenContext<LlvmCodegenBackend>, msg: &str, cookie: c_uint) {\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n }\n "}, {"sha": "4a40349cb73e819fc20c155675e19ee87ba0b7c2", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -203,6 +203,10 @@ pub unsafe fn create_module(\n     let llvm_target = SmallCStr::new(&sess.target.target.llvm_target);\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n \n+    if get_reloc_model(sess) == llvm::RelocMode::PIC {\n+        llvm::LLVMRustSetModulePICLevel(llmod);\n+    }\n+\n     if is_pie_binary(sess) {\n         llvm::LLVMRustSetModulePIELevel(llmod);\n     }"}, {"sha": "f1bf45111315213892301bddb3665cd0ccfcb2d5", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -843,13 +843,13 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n         ty::Char => (\"char\", DW_ATE_unsigned_char),\n         ty::Int(int_ty) => {\n-            (int_ty.ty_to_string(), DW_ATE_signed)\n+            (int_ty.name_str(), DW_ATE_signed)\n         },\n         ty::Uint(uint_ty) => {\n-            (uint_ty.ty_to_string(), DW_ATE_unsigned)\n+            (uint_ty.name_str(), DW_ATE_unsigned)\n         },\n         ty::Float(float_ty) => {\n-            (float_ty.ty_to_string(), DW_ATE_float)\n+            (float_ty.name_str(), DW_ATE_float)\n         },\n         _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n@@ -1904,8 +1904,8 @@ fn prepare_enum_metadata(\n \n             let discr_type = match discr.value {\n                 layout::Int(t, _) => t,\n-                layout::Float(layout::FloatTy::F32) => Integer::I32,\n-                layout::Float(layout::FloatTy::F64) => Integer::I64,\n+                layout::F32 => Integer::I32,\n+                layout::F64 => Integer::I64,\n                 layout::Pointer => cx.data_layout().ptr_sized_integer(),\n             }.to_ty(cx.tcx, false);\n "}, {"sha": "482bcf2aa5835ca1d47ee7c535c81a5e1847ae6a", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -34,11 +34,11 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate).as_str(),\n-        data => data.as_symbol().as_str()\n+        DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate),\n+        data => data.as_symbol()\n     };\n \n-    let namespace_name = SmallCStr::new(&namespace_name);\n+    let namespace_name = SmallCStr::new(&namespace_name.as_str());\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace("}, {"sha": "e1ce7f622e2ef15a02278fecaafe4141c01796e0", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -18,8 +18,8 @@ use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n-use syntax::ast::{self, FloatTy};\n use rustc_target::abi::HasDataLayout;\n+use syntax::ast;\n \n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::traits::*;\n@@ -163,12 +163,12 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                                     emit_va_arg(self, args[0], ret_ty)\n                                 }\n                             }\n-                            Primitive::Float(FloatTy::F64) |\n+                            Primitive::F64 |\n                             Primitive::Pointer => {\n                                 emit_va_arg(self, args[0], ret_ty)\n                             }\n                             // `va_arg` should never be used with the return type f32.\n-                            Primitive::Float(FloatTy::F32) => {\n+                            Primitive::F32 => {\n                                 bug!(\"the va_arg intrinsic does not work with `f32`\")\n                             }\n                         }\n@@ -1335,7 +1335,7 @@ fn generic_simd_intrinsic(\n             },\n             ty::Float(f) => {\n                 return_error!(\"unsupported element type `{}` of floating-point vector `{}`\",\n-                              f, in_ty);\n+                              f.name_str(), in_ty);\n             },\n             _ => {\n                 return_error!(\"`{}` is not a floating-point type\", in_ty);\n@@ -1573,7 +1573,7 @@ fn generic_simd_intrinsic(\n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mutable\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {"}, {"sha": "548e8c732a737cd256be0c04ab88e316f51656fb", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1684,6 +1684,7 @@ extern \"C\" {\n     pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n                                        CPU: *const c_char,\n                                        Features: *const c_char,\n+                                       Abi: *const c_char,\n                                        Model: CodeModel,\n                                        Reloc: RelocMode,\n                                        Level: CodeGenOptLevel,\n@@ -1806,6 +1807,7 @@ extern \"C\" {\n \n     pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char);\n     pub fn LLVMRustUnsetComdat(V: &Value);\n+    pub fn LLVMRustSetModulePICLevel(M: &Module);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);\n     pub fn LLVMRustModuleBufferCreate(M: &Module) -> &'static mut ModuleBuffer;\n     pub fn LLVMRustModuleBufferPtr(p: &ModuleBuffer) -> *const u8;"}, {"sha": "e49462674b3c280249255c6f0f5e950226867078", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -87,6 +87,7 @@ pub struct RustString {\n }\n \n /// Appending to a Rust string -- used by RawRustStringOstream.\n+#[allow(improper_ctypes)]\n #[no_mangle]\n pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: &RustString,\n                                                  ptr: *const c_char,"}, {"sha": "c21e62e7562e3ae50c4fa18d22823a273b59575c", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,7 +3,7 @@ use crate::common::*;\n use crate::type_::Type;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, Align, LayoutOf, FnAbiExt, PointeeInfo, Size, TyLayout};\n-use rustc_target::abi::{FloatTy, TyLayoutMethods};\n+use rustc_target::abi::TyLayoutMethods;\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;\n \n@@ -300,8 +300,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                                scalar: &layout::Scalar, offset: Size) -> &'a Type {\n         match scalar.value {\n             layout::Int(i, _) => cx.type_from_integer( i),\n-            layout::Float(FloatTy::F32) => cx.type_f32(),\n-            layout::Float(FloatTy::F64) => cx.type_f64(),\n+            layout::F32 => cx.type_f32(),\n+            layout::F64 => cx.type_f64(),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {"}, {"sha": "b8501f0e12a70ed4abf854297612c29a37903716", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -53,7 +53,7 @@ impl Command {\n     }\n \n     pub fn sym_arg(&mut self, arg: Symbol) -> &mut Command {\n-        self.arg(&arg.as_str());\n+        self.arg(&*arg.as_str());\n         self\n     }\n "}, {"sha": "35b62603b076afb3e88059184115250200086d67", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -129,9 +129,9 @@ fn reachable_non_generics_provider(\n                 //\n                 // In general though we won't link right if these\n                 // symbols are stripped, and LTO currently strips them.\n-                if &*name == \"rust_eh_personality\" ||\n-                   &*name == \"rust_eh_register_frames\" ||\n-                   &*name == \"rust_eh_unregister_frames\" {\n+                if name == \"rust_eh_personality\" ||\n+                   name == \"rust_eh_register_frames\" ||\n+                   name == \"rust_eh_unregister_frames\" {\n                     SymbolExportLevel::C\n                 } else {\n                     SymbolExportLevel::Rust"}, {"sha": "c3f2a5161ae1c4c93470268d21fbebf72871fb42", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -552,8 +552,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n                                                        &[\"crate\"],\n-                                                       Some(\"allocator\")).as_str()\n-                                                                         .to_string();\n+                                                       Some(\"allocator\")).to_string();\n         let mut modules = backend.new_metadata(tcx, &llmod_id);\n         time(tcx.sess, \"write allocator module\", || {\n             backend.codegen_allocator(tcx, &mut modules, kind)\n@@ -576,8 +575,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         // Codegen the encoded metadata.\n         let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n                                                                 &[\"crate\"],\n-                                                                Some(\"metadata\")).as_str()\n-                                                                                 .to_string();\n+                                                                Some(\"metadata\")).to_string();\n         let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n         time(tcx.sess, \"write compressed metadata\", || {\n             backend.write_compressed_metadata(tcx, &ongoing_codegen.metadata,"}, {"sha": "8ff08e832dc17ded74ec18b341dfc89937f3d17a", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -37,9 +37,9 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),\n         ty::Never => output.push_str(\"!\"),\n-        ty::Int(int_ty) => output.push_str(int_ty.ty_to_string()),\n-        ty::Uint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n-        ty::Float(float_ty) => output.push_str(float_ty.ty_to_string()),\n+        ty::Int(int_ty) => output.push_str(int_ty.name_str()),\n+        ty::Uint(uint_ty) => output.push_str(uint_ty.name_str()),\n+        ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n             push_item_name(tcx, def.did, qualified, output);\n@@ -62,8 +62,8 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 output.push('*');\n             }\n             match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n+                hir::Mutability::Immutable => output.push_str(\"const \"),\n+                hir::Mutability::Mutable => output.push_str(\"mut \"),\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n@@ -76,9 +76,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             if !cpp_like_names {\n                 output.push('&');\n             }\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n+            output.push_str(mutbl.prefix_str());\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n@@ -140,9 +138,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n \n \n             let sig = t.fn_sig(tcx);\n-            if sig.unsafety() == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n+            output.push_str(sig.unsafety().prefix_str());\n \n             let abi = sig.abi();\n             if abi != rustc_target::spec::abi::Abi::Rust {"}, {"sha": "81e7ef64e975a88363ec49e416858a3d0bd5083f", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -59,7 +59,8 @@ pub struct ModuleCodegen<M> {\n     pub kind: ModuleKind,\n }\n \n-pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n+// FIXME(eddyb) maybe include the crate name in this?\n+pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n pub const RLIB_BYTECODE_EXTENSION: &str = \"bc.z\";\n \n "}, {"sha": "13cd202158b771ab389469805ca45d694b35229b", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -995,7 +995,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         span: Span,\n     ) -> OperandRef<'tcx, Bx::Value> {\n-        let caller = bx.tcx().sess.source_map().lookup_char_pos(span.lo());\n+        let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+        let caller = bx.tcx().sess.source_map().lookup_char_pos(topmost.lo());\n         let const_loc = bx.tcx().const_caller_location((\n             Symbol::intern(&caller.file.name.to_string()),\n             caller.line as u32,"}, {"sha": "981fdf2298419822e543cf51e3fb48deb61a30aa", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -269,6 +269,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n+                    | mir::CastKind::Pointer(PointerCast::ArrayToPointer)\n                     | mir::CastKind::Misc => {\n                         assert!(bx.cx().is_backend_immediate(cast));\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);"}, {"sha": "66e1b6d949ef7254a7f87615a350b926b0df9ca8", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -121,9 +121,10 @@ fn get_symbol_hash<'tcx>(\n         substs.hash_stable(&mut hcx, &mut hasher);\n \n         if let Some(instantiating_crate) = instantiating_crate {\n-            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n+            tcx.original_crate_name(instantiating_crate).as_str()\n+                .hash_stable(&mut hcx, &mut hasher);\n+            tcx.crate_disambiguator(instantiating_crate)\n                 .hash_stable(&mut hcx, &mut hasher);\n-            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n         }\n \n         // We want to avoid accidental collision between different types of instances."}, {"sha": "1dfcc21f3903ddd674ad2c1e9361d55e35d6055a", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -373,8 +373,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::Ref(r, ty, mutbl) => {\n                 self.push(match mutbl {\n-                    hir::MutImmutable => \"R\",\n-                    hir::MutMutable => \"Q\",\n+                    hir::Mutability::Immutable => \"R\",\n+                    hir::Mutability::Mutable => \"Q\",\n                 });\n                 if *r != ty::ReErased {\n                     self = r.print(self)?;\n@@ -384,8 +384,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::RawPtr(mt) => {\n                 self.push(match mt.mutbl {\n-                    hir::MutImmutable => \"P\",\n-                    hir::MutMutable => \"O\",\n+                    hir::Mutability::Immutable => \"P\",\n+                    hir::Mutability::Mutable => \"O\",\n                 });\n                 self = mt.ty.print(self)?;\n             }\n@@ -601,8 +601,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             | DefPathData::Misc\n             | DefPathData::Impl\n             | DefPathData::MacroNs(_)\n-            | DefPathData::LifetimeNs(_)\n-            | DefPathData::GlobalMetaData(_) => {\n+            | DefPathData::LifetimeNs(_) => {\n                 bug!(\"symbol_names: unexpected DefPathData: {:?}\", disambiguated_data.data)\n             }\n         };"}, {"sha": "e79b3a81b9654331cf589b780c69dc8a8dd9c301", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -23,7 +23,7 @@ stable_deref_trait = \"1.0.0\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n rayon-core = { version = \"0.3.0\", package = \"rustc-rayon-core\" }\n rustc-hash = \"1.0.1\"\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }\n \n [dependencies.parking_lot]"}, {"sha": "f1565a2bd0a5f16d514e74bd8e4648d23af58bb2", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -21,11 +21,13 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_parse = { path = \"../librustc_parse\" }\n rustc_plugin = { path = \"../librustc_plugin/deprecated\" } # To get this in the sysroot\n rustc_plugin_impl = { path = \"../librustc_plugin\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_interface = { path = \"../librustc_interface\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_resolve = { path = \"../librustc_resolve\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "339a10f9140446f9b5ab7db9aa91c236c2a68831", "filename": "src/librustc_driver/args.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,22 +3,12 @@ use std::fmt;\n use std::fs;\n use std::io;\n use std::str;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-\n-static USED_ARGSFILE_FEATURE: AtomicBool = AtomicBool::new(false);\n-\n-pub fn used_unstable_argsfile() -> bool {\n-    USED_ARGSFILE_FEATURE.load(Ordering::Relaxed)\n-}\n \n pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     if arg.starts_with(\"@\") {\n         let path = &arg[1..];\n         let file = match fs::read_to_string(path) {\n-            Ok(file) => {\n-                USED_ARGSFILE_FEATURE.store(true, Ordering::Relaxed);\n-                file\n-            }\n+            Ok(file) => file,\n             Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {\n                 return Err(Error::Utf8Error(Some(path.to_string())));\n             }"}, {"sha": "10bc6599e7592ac64f8d22447bdc643c2ad45cd8", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -25,8 +25,6 @@ extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n-use pretty::{PpMode, UserIdentifiedItem};\n-\n //use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n@@ -42,6 +40,7 @@ use rustc::ty::TyCtxt;\n use rustc::util::common::{set_time_depth, time, print_time_passes_entry, ErrorReported};\n use rustc_metadata::locator;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use errors::PResult;\n use rustc_interface::interface;\n use rustc_interface::util::get_codegen_sysroot;\n use rustc_data_structures::sync::SeqCst;\n@@ -64,7 +63,6 @@ use std::time::Instant;\n use syntax::ast;\n use syntax::source_map::FileLoader;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n-use syntax::parse::{self, PResult};\n use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, FileName};\n \n@@ -284,33 +282,29 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        let pretty_info = parse_pretty(sess, &matches);\n-\n         compiler.parse()?;\n \n-        if let Some((ppm, opt_uii)) = pretty_info {\n+        if let Some((ppm, opt_uii)) = &sess.opts.pretty {\n             if ppm.needs_ast_map(&opt_uii) {\n-                pretty::visit_crate(sess, &mut compiler.parse()?.peek_mut(), ppm);\n                 compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let expanded_crate = compiler.expansion()?.take().0;\n                     pretty::print_after_hir_lowering(\n                         tcx,\n                         compiler.input(),\n                         &expanded_crate,\n-                        ppm,\n+                        *ppm,\n                         opt_uii.clone(),\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n                     Ok(())\n                 })?;\n             } else {\n-                let mut krate = compiler.parse()?.take();\n-                pretty::visit_crate(sess, &mut krate, ppm);\n+                let krate = compiler.parse()?.take();\n                 pretty::print_after_parsing(\n                     sess,\n                     &compiler.input(),\n                     &krate,\n-                    ppm,\n+                    *ppm,\n                     compiler.output_file().as_ref().map(|p| &**p),\n                 );\n             }\n@@ -399,7 +393,7 @@ pub fn run_compiler(\n         mem::drop(compiler.global_ctxt()?.take());\n \n         if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.borrow().print_type_sizes();\n+            sess.code_stats.print_type_sizes();\n         }\n \n         compiler.link()?;\n@@ -469,28 +463,6 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n     }\n }\n \n-fn parse_pretty(sess: &Session,\n-                matches: &getopts::Matches)\n-                -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-    let pretty = if sess.opts.debugging_opts.unstable_options {\n-        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-            // stable pretty-print variants only\n-            pretty::parse_pretty(sess, &a, false)\n-        })\n-    } else {\n-        None\n-    };\n-\n-    if pretty.is_none() {\n-        sess.opts.debugging_opts.unpretty.as_ref().map(|a| {\n-            // extended with unstable pretty-print variants\n-            pretty::parse_pretty(sess, &a, true)\n-        })\n-    } else {\n-        pretty\n-    }\n-}\n-\n // Whether to stop or continue compilation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Compilation {\n@@ -1043,12 +1015,6 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     //   (unstable option being used on stable)\n     nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n \n-    // Late check to see if @file was used without unstable options enabled\n-    if crate::args::used_unstable_argsfile() && !nightly_options::is_unstable_enabled(&matches) {\n-        early_error(ErrorOutputType::default(),\n-            \"@path is unstable - use -Z unstable-options to enable its use\");\n-    }\n-\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         // Only show unstable options in --help if we accept unstable options.\n         usage(matches.opt_present(\"verbose\"), nightly_options::is_unstable_enabled(&matches));\n@@ -1095,14 +1061,16 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n }\n \n fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<ast::Attribute>> {\n-    match *input {\n-        Input::File(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess)\n+    match input {\n+        Input::File(ifile) => {\n+            rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess)\n         }\n-        Input::Str { ref name, ref input } => {\n-            parse::parse_crate_attrs_from_source_str(name.clone(),\n-                                                     input.clone(),\n-                                                     &sess.parse_sess)\n+        Input::Str { name, input } => {\n+            rustc_parse::parse_crate_attrs_from_source_str(\n+                name.clone(),\n+                input.clone(),\n+                &sess.parse_sess,\n+            )\n         }\n     }\n }"}, {"sha": "23253dc4dadec9733fa37f5fe2768ea9cfd40f43", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 70, "deletions": 258, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -5,117 +5,27 @@ use rustc::hir::map as hir_map;\n use rustc::hir::print as pprust_hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n-use rustc::session::config::Input;\n+use rustc::session::config::{PpMode, PpSourceMode, UserIdentifiedItem, Input};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n-use rustc_interface::util::ReplaceBodyWithLoop;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;\n-use syntax::mut_visit::MutVisitor;\n use syntax::print::{pprust};\n use syntax_pos::FileName;\n \n use std::cell::Cell;\n use std::fs::File;\n use std::io::Write;\n-use std::option;\n use std::path::Path;\n-use std::str::FromStr;\n \n pub use self::UserIdentifiedItem::*;\n pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n-use self::NodesMatchingUII::*;\n use crate::abort_on_err;\n \n use crate::source_name;\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpSourceMode {\n-    PpmNormal,\n-    PpmEveryBodyLoops,\n-    PpmExpanded,\n-    PpmIdentified,\n-    PpmExpandedIdentified,\n-    PpmExpandedHygiene,\n-    PpmTyped,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpMode {\n-    PpmSource(PpSourceMode),\n-    PpmHir(PpSourceMode),\n-    PpmHirTree(PpSourceMode),\n-    PpmMir,\n-    PpmMirCFG,\n-}\n-\n-impl PpMode {\n-    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n-        match *self {\n-            PpmSource(PpmNormal) |\n-            PpmSource(PpmEveryBodyLoops) |\n-            PpmSource(PpmIdentified) => opt_uii.is_some(),\n-\n-            PpmSource(PpmExpanded) |\n-            PpmSource(PpmExpandedIdentified) |\n-            PpmSource(PpmExpandedHygiene) |\n-            PpmHir(_) |\n-            PpmHirTree(_) |\n-            PpmMir |\n-            PpmMirCFG => true,\n-            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-        }\n-    }\n-\n-    pub fn needs_analysis(&self) -> bool {\n-        match *self {\n-            PpmMir | PpmMirCFG => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-pub fn parse_pretty(sess: &Session,\n-                    name: &str,\n-                    extended: bool)\n-                    -> (PpMode, Option<UserIdentifiedItem>) {\n-    let mut split = name.splitn(2, '=');\n-    let first = split.next().unwrap();\n-    let opt_second = split.next();\n-    let first = match (first, extended) {\n-        (\"normal\", _) => PpmSource(PpmNormal),\n-        (\"identified\", _) => PpmSource(PpmIdentified),\n-        (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n-        (\"expanded\", _) => PpmSource(PpmExpanded),\n-        (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n-        (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n-        (\"hir\", true) => PpmHir(PpmNormal),\n-        (\"hir,identified\", true) => PpmHir(PpmIdentified),\n-        (\"hir,typed\", true) => PpmHir(PpmTyped),\n-        (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n-        (\"mir\", true) => PpmMir,\n-        (\"mir-cfg\", true) => PpmMirCFG,\n-        _ => {\n-            if extended {\n-                sess.fatal(&format!(\"argument to `unpretty` must be one of `normal`, \\\n-                                     `expanded`, `identified`, `expanded,identified`, \\\n-                                     `expanded,hygiene`, `everybody_loops`, \\\n-                                     `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n-                                     `mir` or `mir-cfg`; got {}\",\n-                                    name));\n-            } else {\n-                sess.fatal(&format!(\"argument to `pretty` must be one of `normal`, `expanded`, \\\n-                                     `identified`, or `expanded,identified`; got {}\",\n-                                    name));\n-            }\n-        }\n-    };\n-    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n-    (first, opt_second)\n-}\n-\n \n \n // This slightly awkward construction is to allow for each PpMode to\n@@ -131,76 +41,74 @@ pub fn parse_pretty(sess: &Session,\n // (The `use_once_payload` is working around the current lack of once\n // functions in the compiler.)\n \n-impl PpSourceMode {\n-    /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, F>(\n-        &self,\n-        sess: &'tcx Session,\n-        tcx: Option<TyCtxt<'tcx>>,\n-        f: F,\n-    ) -> A\n-    where\n-        F: FnOnce(&dyn PrinterSupport) -> A,\n-    {\n-        match *self {\n-            PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n-                let annotation = NoAnn {\n-                    sess,\n-                    tcx,\n-                };\n-                f(&annotation)\n-            }\n+/// Constructs a `PrinterSupport` object and passes it to `f`.\n+fn call_with_pp_support<'tcx, A, F>(\n+    ppmode: &PpSourceMode,\n+    sess: &'tcx Session,\n+    tcx: Option<TyCtxt<'tcx>>,\n+    f: F,\n+) -> A\n+where\n+    F: FnOnce(&dyn PrinterSupport) -> A,\n+{\n+    match *ppmode {\n+        PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n+            let annotation = NoAnn {\n+                sess,\n+                tcx,\n+            };\n+            f(&annotation)\n+        }\n \n-            PpmIdentified | PpmExpandedIdentified => {\n-                let annotation = IdentifiedAnnotation {\n-                    sess,\n-                    tcx,\n-                };\n-                f(&annotation)\n-            }\n-            PpmExpandedHygiene => {\n-                let annotation = HygieneAnnotation {\n-                    sess,\n-                };\n-                f(&annotation)\n-            }\n-            _ => panic!(\"Should use call_with_pp_support_hir\"),\n+        PpmIdentified | PpmExpandedIdentified => {\n+            let annotation = IdentifiedAnnotation {\n+                sess,\n+                tcx,\n+            };\n+            f(&annotation)\n+        }\n+        PpmExpandedHygiene => {\n+            let annotation = HygieneAnnotation {\n+                sess,\n+            };\n+            f(&annotation)\n+        }\n+        _ => panic!(\"Should use call_with_pp_support_hir\"),\n+    }\n+}\n+fn call_with_pp_support_hir<A, F>(ppmode: &PpSourceMode, tcx: TyCtxt<'_>, f: F) -> A\n+where\n+    F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n+{\n+    match *ppmode {\n+        PpmNormal => {\n+            let annotation = NoAnn {\n+                sess: tcx.sess,\n+                tcx: Some(tcx),\n+            };\n+            f(&annotation, tcx.hir().forest.krate())\n         }\n-    }\n-    fn call_with_pp_support_hir<A, F>(&self, tcx: TyCtxt<'_>, f: F) -> A\n-    where\n-        F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n-    {\n-        match *self {\n-            PpmNormal => {\n-                let annotation = NoAnn {\n-                    sess: tcx.sess,\n-                    tcx: Some(tcx),\n-                };\n-                f(&annotation, tcx.hir().forest.krate())\n-            }\n \n-            PpmIdentified => {\n-                let annotation = IdentifiedAnnotation {\n-                    sess: tcx.sess,\n-                    tcx: Some(tcx),\n-                };\n+        PpmIdentified => {\n+            let annotation = IdentifiedAnnotation {\n+                sess: tcx.sess,\n+                tcx: Some(tcx),\n+            };\n+            f(&annotation, tcx.hir().forest.krate())\n+        }\n+        PpmTyped => {\n+            abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n+\n+            let empty_tables = ty::TypeckTables::empty(None);\n+            let annotation = TypedAnnotation {\n+                tcx,\n+                tables: Cell::new(&empty_tables)\n+            };\n+            tcx.dep_graph.with_ignore(|| {\n                 f(&annotation, tcx.hir().forest.krate())\n-            }\n-            PpmTyped => {\n-                abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n-\n-                let empty_tables = ty::TypeckTables::empty(None);\n-                let annotation = TypedAnnotation {\n-                    tcx,\n-                    tables: Cell::new(&empty_tables)\n-                };\n-                tcx.dep_graph.with_ignore(|| {\n-                    f(&annotation, tcx.hir().forest.krate())\n-                })\n-            }\n-            _ => panic!(\"Should use call_with_pp_support\"),\n+            })\n         }\n+        _ => panic!(\"Should use call_with_pp_support\"),\n     }\n }\n \n@@ -482,102 +390,6 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum UserIdentifiedItem {\n-    ItemViaNode(ast::NodeId),\n-    ItemViaPath(Vec<String>),\n-}\n-\n-impl FromStr for UserIdentifiedItem {\n-    type Err = ();\n-    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n-        Ok(s.parse()\n-            .map(ast::NodeId::from_u32)\n-            .map(ItemViaNode)\n-            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n-    }\n-}\n-\n-enum NodesMatchingUII<'a> {\n-    NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n-}\n-\n-impl<'a> Iterator for NodesMatchingUII<'a> {\n-    type Item = ast::NodeId;\n-\n-    fn next(&mut self) -> Option<ast::NodeId> {\n-        match self {\n-            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self {\n-            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n-            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n-        }\n-    }\n-}\n-\n-impl UserIdentifiedItem {\n-    fn reconstructed_input(&self) -> String {\n-        match *self {\n-            ItemViaNode(node_id) => node_id.to_string(),\n-            ItemViaPath(ref parts) => parts.join(\"::\"),\n-        }\n-    }\n-\n-    fn all_matching_node_ids<'a, 'hir>(&'a self,\n-                                       map: &'a hir_map::Map<'hir>)\n-                                       -> NodesMatchingUII<'a> {\n-        match *self {\n-            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => {\n-                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n-            }\n-        }\n-    }\n-\n-    fn to_one_node_id(self,\n-                      user_option: &str,\n-                      sess: &Session,\n-                      map: &hir_map::Map<'_>)\n-                      -> ast::NodeId {\n-        let fail_because = |is_wrong_because| -> ast::NodeId {\n-            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n-                                   {}, which {}\",\n-                                  user_option,\n-                                  self.reconstructed_input(),\n-                                  is_wrong_because);\n-            sess.fatal(&message)\n-        };\n-\n-        let mut saw_node = ast::DUMMY_NODE_ID;\n-        let mut seen = 0;\n-        for node in self.all_matching_node_ids(map) {\n-            saw_node = node;\n-            seen += 1;\n-            if seen > 1 {\n-                fail_because(\"does not resolve uniquely\");\n-            }\n-        }\n-        if seen == 0 {\n-            fail_because(\"does not resolve to any item\");\n-        }\n-\n-        assert!(seen == 1);\n-        return saw_node;\n-    }\n-}\n-\n-pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n-    if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n-    }\n-}\n-\n fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     let src_name = source_name(input);\n     let src = String::clone(&sess.source_map()\n@@ -613,7 +425,7 @@ pub fn print_after_parsing(sess: &Session,\n     if let PpmSource(s) = ppm {\n         // Silently ignores an identified node.\n         let out = &mut out;\n-        s.call_with_pp_support(sess, None, move |annotation| {\n+        call_with_pp_support(&s, sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n             *out = pprust::print_crate(sess.source_map(),\n@@ -658,7 +470,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                 // Silently ignores an identified node.\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n+                call_with_pp_support(&s, tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     *out = pprust::print_crate(sess.source_map(),\n@@ -674,7 +486,7 @@ pub fn print_after_hir_lowering<'tcx>(\n             (PpmHir(s), None) => {\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n+                call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     *out = pprust_hir::print_crate(sess.source_map(),\n@@ -688,7 +500,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHirTree(s), None) => {\n                 let out = &mut out;\n-                s.call_with_pp_support_hir(tcx, move |_annotation, krate| {\n+                call_with_pp_support_hir(&s, tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     *out = format!(\"{:#?}\", krate);\n                 });\n@@ -697,7 +509,7 @@ pub fn print_after_hir_lowering<'tcx>(\n             (PpmHir(s), Some(uii)) => {\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support_hir(tcx, move |annotation, _| {\n+                call_with_pp_support_hir(&s, tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n@@ -722,7 +534,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHirTree(s), Some(uii)) => {\n                 let out = &mut out;\n-                s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n+                call_with_pp_support_hir(&s, tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     for node_id in uii.all_matching_node_ids(tcx.hir()) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);"}, {"sha": "291920f17f66d7fa1d94ab3c5c9a5fec0e934e15", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -12,7 +12,7 @@ use Destination::*;\n use syntax_pos::{SourceFile, Span, MultiSpan};\n \n use crate::{\n-    Level, CodeSuggestion, Diagnostic, SubDiagnostic, pluralise,\n+    Level, CodeSuggestion, Diagnostic, SubDiagnostic, pluralize,\n     SuggestionStyle, SourceMapper, SourceMapperDyn, DiagnosticId,\n };\n use crate::Level::Error;\n@@ -424,6 +424,14 @@ impl Emitter for EmitterWriter {\n     }\n }\n \n+/// An emitter that does nothing when emitting a diagnostic.\n+pub struct SilentEmitter;\n+\n+impl Emitter for SilentEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> { None }\n+    fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n+}\n+\n /// maximum number of lines we will print for each error; arbitrary.\n pub const MAX_HIGHLIGHT_LINES: usize = 6;\n /// maximum number of suggestions to be shown\n@@ -1573,7 +1581,7 @@ impl EmitterWriter {\n         }\n         if suggestions.len() > MAX_SUGGESTIONS {\n             let others = suggestions.len() - MAX_SUGGESTIONS;\n-            let msg = format!(\"and {} other candidate{}\", others, pluralise!(others));\n+            let msg = format!(\"and {} other candidate{}\", others, pluralize!(others));\n             buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n         } else if notice_capitalization {\n             let msg = \"notice the capitalization difference\";"}, {"sha": "8ee28875c625931bd277ad2cb8814aa854cc686d", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -15,7 +15,6 @@ use Level::*;\n \n use emitter::{Emitter, EmitterWriter, is_case_difference};\n use registry::Registry;\n-\n use rustc_data_structures::sync::{self, Lrc, Lock};\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -48,6 +47,13 @@ use syntax_pos::{\n     SpanSnippetError,\n };\n \n+pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n+\n+// `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n+// (See also the comment on `DiagnosticBuilderInner`.)\n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n+\n /// Indicates the confidence in the correctness of a suggestion.\n ///\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n@@ -1027,7 +1033,7 @@ impl Level {\n }\n \n #[macro_export]\n-macro_rules! pluralise {\n+macro_rules! pluralize {\n     ($x:expr) => {\n         if $x != 1 { \"s\" } else { \"\" }\n     };"}, {"sha": "483b515f2ba4ddfa1bdb2f250795e2ba3b69c44b", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -31,10 +31,6 @@ use syntax::symbol::{Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n-const MODULE: Symbol = sym::module;\n-const CFG: Symbol = sym::cfg;\n-const KIND: Symbol = sym::kind;\n-\n pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n@@ -71,7 +67,7 @@ impl AssertModuleSource<'tcx> {\n         } else if attr.check_name(ATTR_PARTITION_CODEGENED) {\n             (CguReuse::No, ComparisonKind::Exact)\n         } else if attr.check_name(ATTR_EXPECTED_CGU_REUSE) {\n-            match &self.field(attr, KIND).as_str()[..] {\n+            match &*self.field(attr, sym::kind).as_str() {\n                 \"no\" => (CguReuse::No, ComparisonKind::Exact),\n                 \"pre-lto\" => (CguReuse::PreLto, ComparisonKind::Exact),\n                 \"post-lto\" => (CguReuse::PostLto, ComparisonKind::Exact),\n@@ -98,8 +94,8 @@ impl AssertModuleSource<'tcx> {\n             return;\n         }\n \n-        let user_path = self.field(attr, MODULE).as_str().to_string();\n-        let crate_name = self.tcx.crate_name(LOCAL_CRATE).as_str().to_string();\n+        let user_path = self.field(attr, sym::module).to_string();\n+        let crate_name = self.tcx.crate_name(LOCAL_CRATE).to_string();\n \n         if !user_path.starts_with(&crate_name) {\n             let msg = format!(\"Found malformed codegen unit name `{}`. \\\n@@ -125,7 +121,7 @@ impl AssertModuleSource<'tcx> {\n                                                        cgu_path_components,\n                                                        cgu_special_suffix);\n \n-        debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, MODULE), cgu_name);\n+        debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, sym::module), cgu_name);\n \n         if !self.available_cgus.contains(&cgu_name) {\n             self.tcx.sess.span_err(attr.span,\n@@ -135,7 +131,7 @@ impl AssertModuleSource<'tcx> {\n                     cgu_name,\n                     self.available_cgus\n                         .iter()\n-                        .map(|cgu| cgu.as_str().to_string())\n+                        .map(|cgu| cgu.to_string())\n                         .collect::<Vec<_>>()\n                         .join(\", \")));\n         }\n@@ -169,7 +165,7 @@ impl AssertModuleSource<'tcx> {\n     /// cfg flag called `foo`.\n     fn check_config(&self, attr: &ast::Attribute) -> bool {\n         let config = &self.tcx.sess.parse_sess.config;\n-        let value = self.field(attr, CFG);\n+        let value = self.field(attr, sym::cfg);\n         debug!(\"check_config(config={:?}, value={:?})\", config, value);\n         if config.iter().any(|&(name, _)| name == value) {\n             debug!(\"check_config: matched\");"}, {"sha": "ea156a94ea17be34cf88a0249688d2d1057f0220", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -303,7 +303,7 @@ impl DirtyCleanVisitor<'tcx> {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n-                return Some(self.resolve_labels(&item, value.as_str().as_ref()));\n+                return Some(self.resolve_labels(&item, &value.as_str()));\n             }\n         }\n         None\n@@ -314,7 +314,7 @@ impl DirtyCleanVisitor<'tcx> {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n-                return self.resolve_labels(&item, value.as_str().as_ref());\n+                return self.resolve_labels(&item, &value.as_str());\n             }\n         }\n         // if no `label` or `except` is given, only the node's group are asserted"}, {"sha": "1435297f27adaccd103848b414f6866f035113bb", "filename": "src/librustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -11,4 +11,4 @@ doctest = false\n \n [dependencies]\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "de59882bbdf957f851818b73de4ea98d2c97962c", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -12,10 +12,11 @@ doctest = false\n [dependencies]\n log = \"0.4\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_expand = { path = \"../libsyntax_expand\" }\n+rustc_parse = { path = \"../librustc_parse\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc = { path = \"../librustc\" }\n@@ -27,7 +28,6 @@ rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_passes = { path = \"../librustc_passes\" }\n-rustc_target = { path = \"../librustc_target\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }\n@@ -36,3 +36,6 @@ rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\"\n once_cell = \"1\"\n+\n+[dev-dependencies]\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "02068b2ce388d6a70f21c606cdfc02465c5c6123", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -11,16 +11,16 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::OnDrop;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_parse::new_parser_from_source_str;\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n-use syntax::{self, parse};\n use syntax::ast::{self, MetaItemKind};\n-use syntax::parse::token;\n-use syntax::source_map::{FileName, FilePathMapping, FileLoader, SourceMap};\n+use syntax::token;\n+use syntax::source_map::{FileName, FileLoader, SourceMap};\n use syntax::sess::ParseSess;\n+use syntax_expand::config::process_configure_mod;\n use syntax_pos::edition;\n-use rustc_errors::{Diagnostic, emitter::Emitter, Handler, SourceMapperDyn};\n \n pub type Result<T> = result::Result<T, ErrorReported>;\n \n@@ -63,20 +63,11 @@ impl Compiler {\n \n /// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n-    struct NullEmitter;\n-    impl Emitter for NullEmitter {\n-        fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n-        fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> { None }\n-    }\n-\n     syntax::with_default_globals(move || {\n         let cfg = cfgspecs.into_iter().map(|s| {\n-\n-            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let handler = Handler::with_emitter(false, None, Box::new(NullEmitter));\n-            let sess = ParseSess::with_span_handler(handler, cm);\n+            let sess = ParseSess::with_silent_emitter(process_configure_mod);\n             let filename = FileName::cfg_spec_source_code(&s);\n-            let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n+            let mut parser = new_parser_from_source_str(&sess, filename, s.to_string());\n \n             macro_rules! error {($reason: expr) => {\n                 early_error(ErrorOutputType::default(),"}, {"sha": "453007c564246b8aee68be8d92c845c04f021bd6", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -16,15 +16,18 @@ use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{PpMode, PpSourceMode};\n use rustc::session::search_paths::PathKind;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n+use rustc_errors::PResult;\n use rustc_incremental;\n use rustc_metadata::cstore;\n use rustc_mir as mir;\n+use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, ast_validation, hir_stats, layout_test};\n use rustc_plugin as plugin;\n use rustc_plugin::registry::Registry;\n@@ -36,7 +39,6 @@ use syntax::{self, ast, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n use syntax_expand::base::{NamedSyntaxExtension, ExtCtxt};\n use syntax::mut_visit::MutVisitor;\n-use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n use syntax::symbol::Symbol;\n use syntax_pos::FileName;\n@@ -59,12 +61,11 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     let krate = time(sess, \"parsing\", || {\n         let _prof_timer = sess.prof.generic_activity(\"parse_crate\");\n \n-        match *input {\n-            Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n-            Input::Str {\n-                ref input,\n-                ref name,\n-            } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n+        match input {\n+            Input::File(file) => parse_crate_from_file(file, &sess.parse_sess),\n+            Input::Str { input, name } => {\n+                parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n+            }\n         }\n     })?;\n \n@@ -180,7 +181,7 @@ pub fn register_plugins<'a>(\n         )\n     });\n \n-    let (krate, features) = syntax::config::features(\n+    let (krate, features) = syntax_expand::config::features(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n@@ -393,8 +394,12 @@ fn configure_and_expand_inner<'a>(\n \n     // If we're actually rustdoc then there's no need to actually compile\n     // anything, so switch everything to just looping\n-    if sess.opts.actually_rustdoc {\n-        util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n+    let mut should_loop = sess.opts.actually_rustdoc;\n+    if let Some((PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops), _)) = sess.opts.pretty {\n+        should_loop |= true;\n+    }\n+    if should_loop {\n+        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n \n     let has_proc_macro_decls = time(sess, \"AST validation\", || {\n@@ -483,7 +488,7 @@ pub fn lower_to_hir(\n ) -> Result<hir::map::Forest> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n-        let nt_to_tokenstream = syntax::parse::nt_to_tokenstream;\n+        let nt_to_tokenstream = rustc_parse::nt_to_tokenstream;\n         let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream);\n \n         if sess.opts.debugging_opts.hir_stats {"}, {"sha": "8c1dac21576f7b9f2ffaf856161499af8fdaeb3e", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -8,7 +8,7 @@ use rustc::session::config::{build_configuration, build_session_options, to_crat\n use rustc::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n use rustc::session::config::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n use rustc::session::config::{rustc_optgroups, Options, ErrorOutputType, Passes};\n-use rustc::session::build_session;\n+use rustc::session::{build_session, Session};\n use rustc::session::search_paths::SearchPath;\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n@@ -17,16 +17,23 @@ use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n use syntax::symbol::sym;\n use syntax::edition::{Edition, DEFAULT_EDITION};\n use syntax;\n+use syntax_expand::config::process_configure_mod;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{ColorConfig, emitter::HumanReadableErrorType, registry};\n \n-pub fn build_session_options_and_crate_config(\n-    matches: &getopts::Matches,\n-) -> (Options, FxHashSet<(String, Option<String>)>) {\n-    (\n-        build_session_options(matches),\n-        parse_cfgspecs(matches.opt_strs(\"cfg\")),\n-    )\n+type CfgSpecs = FxHashSet<(String, Option<String>)>;\n+\n+fn build_session_options_and_crate_config(matches: getopts::Matches) -> (Options, CfgSpecs) {\n+    let sessopts = build_session_options(&matches);\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n+    (sessopts, cfg)\n+}\n+\n+fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n+    let registry = registry::Registry::new(&[]);\n+    let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n+    let sess = build_session(sessopts, None, registry, process_configure_mod);\n+    (sess, cfg)\n }\n \n fn new_public_extern_entry<S, I>(locations: I) -> ExternEntry\n@@ -59,31 +66,19 @@ fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n #[test]\n fn test_switch_implies_cfg_test() {\n     syntax::with_default_globals(|| {\n-        let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n-            Ok(m) => m,\n-            Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n-        };\n-        let registry = registry::Registry::new(&[]);\n-        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let matches = optgroups().parse(&[\"--test\".to_string()]).unwrap();\n+        let (sess, cfg) = mk_session(matches);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n         assert!(cfg.contains(&(sym::test, None)));\n     });\n }\n \n-// When the user supplies --test and --cfg test, don't implicitly add\n-// another --cfg test\n+// When the user supplies --test and --cfg test, don't implicitly add another --cfg test\n #[test]\n fn test_switch_implies_cfg_test_unless_cfg_test() {\n     syntax::with_default_globals(|| {\n-        let matches = &match optgroups().parse(&[\"--test\".to_string(),\n-                                                 \"--cfg=test\".to_string()]) {\n-            Ok(m) => m,\n-            Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n-        };\n-        let registry = registry::Registry::new(&[]);\n-        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let matches = optgroups().parse(&[\"--test\".to_string(), \"--cfg=test\".to_string()]).unwrap();\n+        let (sess, cfg) = mk_session(matches);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n         let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n         assert!(test_items.next().is_some());\n@@ -95,27 +90,21 @@ fn test_switch_implies_cfg_test_unless_cfg_test() {\n fn test_can_print_warnings() {\n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n-        let registry = registry::Registry::new(&[]);\n-        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let (sess, _) = mk_session(matches);\n         assert!(!sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n         let matches = optgroups()\n             .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n             .unwrap();\n-        let registry = registry::Registry::new(&[]);\n-        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let (sess, _) = mk_session(matches);\n         assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n-        let registry = registry::Registry::new(&[]);\n-        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let (sess, _) = mk_session(matches);\n         assert!(sess.diagnostic().can_emit_warnings());\n     });\n }\n@@ -704,6 +693,6 @@ fn test_edition_parsing() {\n     let matches = optgroups()\n         .parse(&[\"--edition=2018\".to_string()])\n         .unwrap();\n-    let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+    let (sessopts, _) = build_session_options_and_crate_config(matches);\n     assert!(sessopts.edition == Edition::Edition2018)\n }"}, {"sha": "115345955aea330824320de10f86a357ec8ffb71", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -18,7 +18,7 @@ use rustc_mir;\n use rustc_passes;\n use rustc_plugin;\n use rustc_privacy;\n-use rustc_resolve;\n+use rustc_resolve::{self, Resolver};\n use rustc_typeck;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n@@ -36,6 +36,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n use syntax::symbol::{Symbol, sym};\n use syntax::{self, ast, attr};\n+use syntax_expand::config::process_configure_mod;\n use syntax_pos::edition::Edition;\n #[cfg(not(parallel_compiler))]\n use std::{thread, panic};\n@@ -49,6 +50,7 @@ pub fn diagnostics_registry() -> Registry {\n     // FIXME: need to figure out a way to get these back in here\n     // all_errors.extend_from_slice(get_codegen_backend(sess).diagnostics());\n     all_errors.extend_from_slice(&rustc_metadata::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_parse::error_codes::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_passes::error_codes::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_plugin::error_codes::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_mir::error_codes::DIAGNOSTICS);\n@@ -103,6 +105,7 @@ pub fn create_session(\n         source_map.clone(),\n         diagnostic_output,\n         lint_caps,\n+        process_configure_mod,\n     );\n \n     let codegen_backend = get_codegen_backend(&sess);\n@@ -715,18 +718,18 @@ pub fn build_output_filenames(\n //    ambitious form of the closed RFC #1637. See also [#34511].\n //\n // [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n-pub struct ReplaceBodyWithLoop<'a> {\n+pub struct ReplaceBodyWithLoop<'a, 'b> {\n     within_static_or_const: bool,\n     nested_blocks: Option<Vec<ast::Block>>,\n-    sess: &'a Session,\n+    resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a> ReplaceBodyWithLoop<'a> {\n-    pub fn new(sess: &'a Session) -> ReplaceBodyWithLoop<'a> {\n+impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n+    pub fn new(resolver: &'a mut Resolver<'b>) -> ReplaceBodyWithLoop<'a, 'b> {\n         ReplaceBodyWithLoop {\n             within_static_or_const: false,\n             nested_blocks: None,\n-            sess\n+            resolver,\n         }\n     }\n \n@@ -786,14 +789,18 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n             false\n         }\n     }\n+\n+    fn is_sig_const(sig: &ast::FnSig) -> bool {\n+        sig.header.constness.node == ast::Constness::Const ||\n+            ReplaceBodyWithLoop::should_ignore_fn(&sig.decl)\n+    }\n }\n \n-impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n+impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n     fn visit_item_kind(&mut self, i: &mut ast::ItemKind) {\n         let is_const = match i {\n             ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n-            ast::ItemKind::Fn(ref decl, ref header, _, _) =>\n-                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            ast::ItemKind::Fn(ref sig, _, _) => Self::is_sig_const(sig),\n             _ => false,\n         };\n         self.run(is_const, |s| noop_visit_item_kind(i, s))\n@@ -802,8 +809,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n     fn flat_map_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n         let is_const = match i.kind {\n             ast::TraitItemKind::Const(..) => true,\n-            ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n-                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            ast::TraitItemKind::Method(ref sig, _) => Self::is_sig_const(sig),\n             _ => false,\n         };\n         self.run(is_const, |s| noop_flat_map_trait_item(i, s))\n@@ -812,8 +818,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n     fn flat_map_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n         let is_const = match i.kind {\n             ast::ImplItemKind::Const(..) => true,\n-            ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n-                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            ast::ImplItemKind::Method(ref sig, _) => Self::is_sig_const(sig),\n             _ => false,\n         };\n         self.run(is_const, |s| noop_flat_map_impl_item(i, s))\n@@ -826,40 +831,40 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n     fn visit_block(&mut self, b: &mut P<ast::Block>) {\n         fn stmt_to_block(rules: ast::BlockCheckMode,\n                          s: Option<ast::Stmt>,\n-                         sess: &Session) -> ast::Block {\n+                         resolver: &mut Resolver<'_>) -> ast::Block {\n             ast::Block {\n                 stmts: s.into_iter().collect(),\n                 rules,\n-                id: sess.next_node_id(),\n+                id: resolver.next_node_id(),\n                 span: syntax_pos::DUMMY_SP,\n             }\n         }\n \n-        fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n+        fn block_to_stmt(b: ast::Block, resolver: &mut Resolver<'_>) -> ast::Stmt {\n             let expr = P(ast::Expr {\n-                id: sess.next_node_id(),\n+                id: resolver.next_node_id(),\n                 kind: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n             });\n \n             ast::Stmt {\n-                id: sess.next_node_id(),\n+                id: resolver.next_node_id(),\n                 kind: ast::StmtKind::Expr(expr),\n                 span: syntax_pos::DUMMY_SP,\n             }\n         }\n \n-        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.sess);\n+        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.resolver);\n         let loop_expr = P(ast::Expr {\n             kind: ast::ExprKind::Loop(P(empty_block), None),\n-            id: self.sess.next_node_id(),\n+            id: self.resolver.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n         });\n \n         let loop_stmt = ast::Stmt {\n-            id: self.sess.next_node_id(),\n+            id: self.resolver.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n             kind: ast::StmtKind::Expr(loop_expr),\n         };\n@@ -877,7 +882,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n                     // we put a Some in there earlier with that replace(), so this is valid\n                     let new_blocks = self.nested_blocks.take().unwrap();\n                     self.nested_blocks = old_blocks;\n-                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, &self.sess)));\n+                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, self.resolver)));\n                 }\n \n                 let mut new_block = ast::Block {\n@@ -891,7 +896,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n                         old_blocks.push(new_block);\n                     }\n \n-                    stmt_to_block(b.rules, Some(loop_stmt), self.sess)\n+                    stmt_to_block(b.rules, Some(loop_stmt), &mut self.resolver)\n                 } else {\n                     //push `loop {}` onto the end of our fresh block and yield that\n                     new_block.stmts.push(loop_stmt);"}, {"sha": "ed0911379c4b3ccf79204a7c97706ba531186ace", "filename": "src/librustc_lexer/src/cursor.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -41,10 +41,20 @@ impl<'a> Cursor<'a> {\n     /// If requested position doesn't exist, `EOF_CHAR` is returned.\n     /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n     /// it should be checked with `is_eof` method.\n-    pub(crate) fn nth_char(&self, n: usize) -> char {\n+    fn nth_char(&self, n: usize) -> char {\n         self.chars().nth(n).unwrap_or(EOF_CHAR)\n     }\n \n+    /// Peeks the next symbol from the input stream without consuming it.\n+    pub(crate) fn first(&self) -> char {\n+        self.nth_char(0)\n+    }\n+\n+    /// Peeks the second symbol from the input stream without consuming it.\n+    pub(crate) fn second(&self) -> char {\n+        self.nth_char(1)\n+    }\n+\n     /// Checks if there is nothing more to consume.\n     pub(crate) fn is_eof(&self) -> bool {\n         self.chars.as_str().is_empty()"}, {"sha": "3cecb4317b19a5f660875ab8dad86fec8797a063", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 149, "deletions": 122, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,7 +1,7 @@\n //! Low-level Rust lexer.\n //!\n //! Tokens produced by this lexer are not yet ready for parsing the Rust syntax,\n-//! for that see `libsyntax::parse::lexer`, which converts this basic token stream\n+//! for that see `librustc_parse::lexer`, which converts this basic token stream\n //! into wide tokens used by actual parser.\n //!\n //! The purpose of this crate is to convert raw sources into a labeled sequence\n@@ -18,6 +18,8 @@ mod cursor;\n pub mod unescape;\n \n use crate::cursor::{Cursor, EOF_CHAR};\n+use self::TokenKind::*;\n+use self::LiteralKind::*;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -116,7 +118,6 @@ pub enum TokenKind {\n     /// Unknown token, not expected by the lexer, e.g. \"\u2116\"\n     Unknown,\n }\n-use self::TokenKind::*;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum LiteralKind {\n@@ -137,7 +138,6 @@ pub enum LiteralKind {\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n     RawByteStr { n_hashes: usize, started: bool, terminated: bool },\n }\n-use self::LiteralKind::*;\n \n /// Base of numeric literal encoding according to its prefix.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n@@ -241,14 +241,13 @@ pub fn is_id_continue(c: char) -> bool {\n         || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n }\n \n-\n impl Cursor<'_> {\n     /// Parses a token from the input string.\n     fn advance_token(&mut self) -> Token {\n         let first_char = self.bump().unwrap();\n         let token_kind = match first_char {\n             // Slash, comment or block comment.\n-            '/' => match self.nth_char(0) {\n+            '/' => match self.first() {\n                 '/' => self.line_comment(),\n                 '*' => self.block_comment(),\n                 _ => Slash,\n@@ -257,8 +256,8 @@ impl Cursor<'_> {\n             // Whitespace sequence.\n             c if is_whitespace(c) => self.whitespace(),\n \n-            // Raw string literal or identifier.\n-            'r' => match (self.nth_char(0), self.nth_char(1)) {\n+            // Raw identifier, raw string literal or identifier.\n+            'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n                     let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n@@ -273,7 +272,7 @@ impl Cursor<'_> {\n             },\n \n             // Byte literal, byte string literal, raw byte string literal or identifier.\n-            'b' => match (self.nth_char(0), self.nth_char(1)) {\n+            'b' => match (self.first(), self.second()) {\n                 ('\\'', _) => {\n                     self.bump();\n                     let terminated = self.single_quoted_string();\n@@ -366,31 +365,23 @@ impl Cursor<'_> {\n     }\n \n     fn line_comment(&mut self) -> TokenKind {\n-        debug_assert!(self.prev() == '/' && self.nth_char(0) == '/');\n+        debug_assert!(self.prev() == '/' && self.first() == '/');\n         self.bump();\n-        loop {\n-            match self.nth_char(0) {\n-                '\\n' => break,\n-                EOF_CHAR if self.is_eof() => break,\n-                _ => {\n-                    self.bump();\n-                }\n-            }\n-        }\n+        self.eat_while(|c| c != '\\n');\n         LineComment\n     }\n \n     fn block_comment(&mut self) -> TokenKind {\n-        debug_assert!(self.prev() == '/' && self.nth_char(0) == '*');\n+        debug_assert!(self.prev() == '/' && self.first() == '*');\n         self.bump();\n         let mut depth = 1usize;\n         while let Some(c) = self.bump() {\n             match c {\n-                '/' if self.nth_char(0) == '*' => {\n+                '/' if self.first() == '*' => {\n                     self.bump();\n                     depth += 1;\n                 }\n-                '*' if self.nth_char(0) == '/' => {\n+                '*' if self.first() == '/' => {\n                     self.bump();\n                     depth -= 1;\n                     if depth == 0 {\n@@ -409,31 +400,27 @@ impl Cursor<'_> {\n \n     fn whitespace(&mut self) -> TokenKind {\n         debug_assert!(is_whitespace(self.prev()));\n-        while is_whitespace(self.nth_char(0)) {\n-            self.bump();\n-        }\n+        self.eat_while(is_whitespace);\n         Whitespace\n     }\n \n     fn raw_ident(&mut self) -> TokenKind {\n         debug_assert!(\n             self.prev() == 'r'\n-                && self.nth_char(0) == '#'\n-                && is_id_start(self.nth_char(1))\n+                && self.first() == '#'\n+                && is_id_start(self.second())\n         );\n+        // Eat \"#\" symbol.\n         self.bump();\n-        self.bump();\n-        while is_id_continue(self.nth_char(0)) {\n-            self.bump();\n-        }\n+        // Eat the identifier part of RawIdent.\n+        self.eat_identifier();\n         RawIdent\n     }\n \n     fn ident(&mut self) -> TokenKind {\n         debug_assert!(is_id_start(self.prev()));\n-        while is_id_continue(self.nth_char(0)) {\n-            self.bump();\n-        }\n+        // Start is already eaten, eat the rest of identifier.\n+        self.eat_while(is_id_continue);\n         Ident\n     }\n \n@@ -442,7 +429,7 @@ impl Cursor<'_> {\n         let mut base = Base::Decimal;\n         if first_digit == '0' {\n             // Attempt to parse encoding base.\n-            let has_digits = match self.nth_char(0) {\n+            let has_digits = match self.first() {\n                 'b' => {\n                     base = Base::Binary;\n                     self.bump();\n@@ -476,23 +463,23 @@ impl Cursor<'_> {\n             self.eat_decimal_digits();\n         };\n \n-        match self.nth_char(0) {\n+        match self.first() {\n             // Don't be greedy if this is actually an\n             // integer literal followed by field/method access or a range pattern\n             // (`0..2` and `12.foo()`)\n-            '.' if self.nth_char(1) != '.'\n-                && !is_id_start(self.nth_char(1)) =>\n+            '.' if self.second() != '.'\n+                && !is_id_start(self.second()) =>\n             {\n                 // might have stuff after the ., and if it does, it needs to start\n                 // with a number\n                 self.bump();\n                 let mut empty_exponent = false;\n-                if self.nth_char(0).is_digit(10) {\n+                if self.first().is_digit(10) {\n                     self.eat_decimal_digits();\n-                    match self.nth_char(0) {\n+                    match self.first() {\n                         'e' | 'E' => {\n                             self.bump();\n-                            empty_exponent = self.float_exponent().is_err()\n+                            empty_exponent = !self.eat_float_exponent();\n                         }\n                         _ => (),\n                     }\n@@ -501,7 +488,7 @@ impl Cursor<'_> {\n             }\n             'e' | 'E' => {\n                 self.bump();\n-                let empty_exponent = self.float_exponent().is_err();\n+                let empty_exponent = !self.eat_float_exponent();\n                 Float { base, empty_exponent }\n             }\n             _ => Int { base, empty_int: false },\n@@ -510,65 +497,76 @@ impl Cursor<'_> {\n \n     fn lifetime_or_char(&mut self) -> TokenKind {\n         debug_assert!(self.prev() == '\\'');\n-        let mut starts_with_number = false;\n-\n-        // Check if the first symbol after '\\'' is a valid identifier\n-        // character or a number (not a digit followed by '\\'').\n-        if (is_id_start(self.nth_char(0))\n-            || self.nth_char(0).is_digit(10) && {\n-                starts_with_number = true;\n-                true\n-            })\n-            && self.nth_char(1) != '\\''\n-        {\n-            self.bump();\n \n-            // Skip the identifier.\n-            while is_id_continue(self.nth_char(0)) {\n-                self.bump();\n-            }\n+        let can_be_a_lifetime = if self.second() == '\\'' {\n+            // It's surely not a lifetime.\n+            false\n+        } else {\n+            // If the first symbol is valid for identifier, it can be a lifetime.\n+            // Also check if it's a number for a better error reporting (so '0 will\n+            // be reported as invalid lifetime and not as unterminated char literal).\n+            is_id_start(self.first()) || self.first().is_digit(10)\n+        };\n \n-            return if self.nth_char(0) == '\\'' {\n-                self.bump();\n-                let kind = Char { terminated: true };\n-                Literal { kind, suffix_start: self.len_consumed() }\n-            } else {\n-                Lifetime { starts_with_number }\n-            };\n+        if !can_be_a_lifetime {\n+            let terminated = self.single_quoted_string();\n+            let suffix_start = self.len_consumed();\n+            if terminated {\n+                self.eat_literal_suffix();\n+            }\n+            let kind = Char { terminated };\n+            return Literal { kind, suffix_start };\n         }\n \n-        // This is not a lifetime (checked above), parse a char literal.\n-        let terminated = self.single_quoted_string();\n-        let suffix_start = self.len_consumed();\n-        if terminated {\n-            self.eat_literal_suffix();\n+        // Either a lifetime or a character literal with\n+        // length greater than 1.\n+\n+        let starts_with_number = self.first().is_digit(10);\n+\n+        // Skip the literal contents.\n+        // First symbol can be a number (which isn't a valid identifier start),\n+        // so skip it without any checks.\n+        self.bump();\n+        self.eat_while(is_id_continue);\n+\n+        // Check if after skipping literal contents we've met a closing\n+        // single quote (which means that user attempted to create a\n+        // string with single quotes).\n+        if self.first() == '\\'' {\n+            self.bump();\n+            let kind = Char { terminated: true };\n+            return Literal { kind, suffix_start: self.len_consumed() };\n         }\n-        let kind = Char { terminated };\n-        return Literal { kind, suffix_start };\n+\n+        return Lifetime { starts_with_number };\n     }\n \n     fn single_quoted_string(&mut self) -> bool {\n         debug_assert!(self.prev() == '\\'');\n-        // Parse `'''` as a single char literal.\n-        if self.nth_char(0) == '\\'' && self.nth_char(1) == '\\'' {\n+        // Check if it's a one-symbol literal.\n+        if self.second() == '\\'' && self.first() != '\\\\' {\n+            self.bump();\n             self.bump();\n+            return true;\n         }\n+\n+        // Literal has more than one symbol.\n+\n         // Parse until either quotes are terminated or error is detected.\n-        let mut first = true;\n         loop {\n-            match self.nth_char(0) {\n-                // Probably beginning of the comment, which we don't want to include\n-                // to the error report.\n-                '/' if !first => break,\n-                // Newline without following '\\'' means unclosed quote, stop parsing.\n-                '\\n' if self.nth_char(1) != '\\'' => break,\n-                // End of file, stop parsing.\n-                EOF_CHAR if self.is_eof() => break,\n+            match self.first() {\n                 // Quotes are terminated, finish parsing.\n                 '\\'' => {\n                     self.bump();\n                     return true;\n                 }\n+                // Probably beginning of the comment, which we don't want to include\n+                // to the error report.\n+                '/' => break,\n+                // Newline without following '\\'' means unclosed quote, stop parsing.\n+                '\\n' if self.second() != '\\'' => break,\n+                // End of file, stop parsing.\n+                EOF_CHAR if self.is_eof() => break,\n                 // Escaped slash is considered one character, so bump twice.\n                 '\\\\' => {\n                     self.bump();\n@@ -579,71 +577,80 @@ impl Cursor<'_> {\n                     self.bump();\n                 }\n             }\n-            first = false;\n         }\n+        // String was not terminated.\n         false\n     }\n \n     /// Eats double-quoted string and returns true\n     /// if string is terminated.\n     fn double_quoted_string(&mut self) -> bool {\n         debug_assert!(self.prev() == '\"');\n-        loop {\n-            match self.nth_char(0) {\n+        while let Some(c) = self.bump() {\n+            match c {\n                 '\"' => {\n-                    self.bump();\n                     return true;\n                 }\n-                EOF_CHAR if self.is_eof() => return false,\n-                '\\\\' if self.nth_char(1) == '\\\\' || self.nth_char(1) == '\"' => {\n+                '\\\\' if self.first() == '\\\\' || self.first() == '\"' => {\n+                    // Bump again to skip escaped character.\n                     self.bump();\n                 }\n                 _ => (),\n             }\n-            self.bump();\n         }\n+        // End of file reached.\n+        false\n     }\n \n     /// Eats the double-quoted string and returns a tuple of\n     /// (amount of the '#' symbols, raw string started, raw string terminated)\n     fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n         debug_assert!(self.prev() == 'r');\n+        let mut started: bool = false;\n+        let mut finished: bool = false;\n+\n         // Count opening '#' symbols.\n-        let n_hashes = {\n-            let mut acc: usize = 0;\n-            loop {\n-                match self.bump() {\n-                    Some('#') => acc += 1,\n-                    Some('\"') => break acc,\n-                    None | Some(_) => return (acc, false, false),\n-                }\n+        let n_hashes = self.eat_while(|c| c == '#');\n+\n+        // Check that string is started.\n+        match self.bump() {\n+            Some('\"') => started = true,\n+            _ => return (n_hashes, started, finished),\n+        }\n+\n+        // Skip the string contents and on each '#' character met, check if this is\n+        // a raw string termination.\n+        while !finished {\n+            self.eat_while(|c| c != '\"');\n+\n+            if self.is_eof() {\n+                return (n_hashes, started, finished);\n             }\n-        };\n \n-        // Skip the string itself and check that amount of closing '#'\n-        // symbols is equal to the amount of opening ones.\n-        loop {\n-            match self.bump() {\n-                Some('\"') => {\n-                    let mut acc = n_hashes;\n-                    while self.nth_char(0) == '#' && acc > 0 {\n-                        self.bump();\n-                        acc -= 1;\n-                    }\n-                    if acc == 0 {\n-                        return (n_hashes, true, true);\n-                    }\n+            // Eat closing double quote.\n+            self.bump();\n+\n+            // Check that amount of closing '#' symbols\n+            // is equal to the amount of opening ones.\n+            let mut hashes_left = n_hashes;\n+            let is_closing_hash = |c| {\n+                if c == '#' && hashes_left != 0 {\n+                    hashes_left -= 1;\n+                    true\n+                } else {\n+                    false\n                 }\n-                Some(_) => (),\n-                None => return (n_hashes, true, false),\n-            }\n+            };\n+            finished = self.eat_while(is_closing_hash) == n_hashes;\n         }\n+\n+        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {\n         let mut has_digits = false;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 '_' => {\n                     self.bump();\n                 }\n@@ -660,7 +667,7 @@ impl Cursor<'_> {\n     fn eat_hexadecimal_digits(&mut self) -> bool {\n         let mut has_digits = false;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 '_' => {\n                     self.bump();\n                 }\n@@ -674,23 +681,43 @@ impl Cursor<'_> {\n         has_digits\n     }\n \n-    fn float_exponent(&mut self) -> Result<(), ()> {\n+    /// Eats the float exponent. Returns true if at least one digit was met,\n+    /// and returns false otherwise.\n+    fn eat_float_exponent(&mut self) -> bool {\n         debug_assert!(self.prev() == 'e' || self.prev() == 'E');\n-        if self.nth_char(0) == '-' || self.nth_char(0) == '+' {\n+        if self.first() == '-' || self.first() == '+' {\n             self.bump();\n         }\n-        if self.eat_decimal_digits() { Ok(()) } else { Err(()) }\n+        self.eat_decimal_digits()\n     }\n \n-    // Eats the suffix if it's an identifier.\n+    // Eats the suffix of the literal, e.g. \"_u8\".\n     fn eat_literal_suffix(&mut self) {\n-        if !is_id_start(self.nth_char(0)) {\n+        self.eat_identifier();\n+    }\n+\n+    // Eats the identifier.\n+    fn eat_identifier(&mut self) {\n+        if !is_id_start(self.first()) {\n             return;\n         }\n         self.bump();\n \n-        while is_id_continue(self.nth_char(0)) {\n+        self.eat_while(is_id_continue);\n+    }\n+\n+    /// Eats symbols while predicate returns true or until the end of file is reached.\n+    /// Returns amount of eaten symbols.\n+    fn eat_while<F>(&mut self, mut predicate: F) -> usize\n+    where\n+        F: FnMut(char) -> bool\n+    {\n+        let mut eaten: usize = 0;\n+        while predicate(self.first()) && !self.is_eof() {\n+            eaten += 1;\n             self.bump();\n         }\n+\n+        eaten\n     }\n }"}, {"sha": "e73414174fb3524002bedbaee0d342660c26ff46", "filename": "src/librustc_lint/array_into_iter.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,91 @@\n+use crate::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::{\n+    lint::FutureIncompatibleInfo,\n+    hir,\n+    ty::{\n+        self,\n+        adjustment::{Adjust, Adjustment},\n+    },\n+};\n+use syntax::{\n+    errors::Applicability,\n+    symbol::sym,\n+};\n+\n+\n+declare_lint! {\n+    pub ARRAY_INTO_ITER,\n+    Warn,\n+    \"detects calling `into_iter` on arrays\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #66145 <https://github.com/rust-lang/rust/issues/66145>\",\n+        edition: None,\n+    };\n+}\n+\n+declare_lint_pass!(\n+    /// Checks for instances of calling `into_iter` on arrays.\n+    ArrayIntoIter => [ARRAY_INTO_ITER]\n+);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+        // We only care about method call expressions.\n+        if let hir::ExprKind::MethodCall(call, span, args) = &expr.kind {\n+            if call.ident.name != sym::into_iter {\n+                return;\n+            }\n+\n+            // Check if the method call actually calls the libcore\n+            // `IntoIterator::into_iter`.\n+            let def_id = cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+            match cx.tcx.trait_of_item(def_id) {\n+                Some(trait_id) if cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_id) => {},\n+                _ => return,\n+            };\n+\n+            // As this is a method call expression, we have at least one\n+            // argument.\n+            let receiver_arg = &args[0];\n+\n+            // Test if the original `self` type is an array type.\n+            match cx.tables.expr_ty(receiver_arg).kind {\n+                ty::Array(..) => {}\n+                _ => return,\n+            }\n+\n+            // Make sure that the first adjustment is an autoref coercion.\n+            match cx.tables.expr_adjustments(receiver_arg).get(0) {\n+                Some(Adjustment { kind: Adjust::Borrow(_), .. }) => {}\n+                _ => return,\n+            }\n+\n+            // Emit lint diagnostic.\n+            let target = match cx.tables.expr_ty_adjusted(receiver_arg).kind {\n+                ty::Ref(_, ty::TyS { kind: ty::Array(..), ..}, _) => \"[T; N]\",\n+                ty::Ref(_, ty::TyS { kind: ty::Slice(..), ..}, _) => \"[T]\",\n+\n+                // We know the original first argument type is an array type,\n+                // we know that the first adjustment was an autoref coercion\n+                // and we know that `IntoIterator` is the trait involved. The\n+                // array cannot be coerced to something other than a reference\n+                // to an array or to a slice.\n+                _ => bug!(\"array type coerced to something other than array or slice\"),\n+            };\n+            let msg = format!(\n+                \"this method call currently resolves to `<&{} as IntoIterator>::into_iter` (due \\\n+                    to autoref coercions), but that might change in the future when \\\n+                    `IntoIterator` impls for arrays are added.\",\n+                target,\n+            );\n+            cx.struct_span_lint(ARRAY_INTO_ITER, *span, &msg)\n+                .span_suggestion(\n+                    call.ident.span,\n+                    \"use `.iter()` instead of `.into_iter()` to avoid ambiguity\",\n+                    \"iter\".into(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+}"}, {"sha": "38624034022f0bc81f5959304512efb9afe6d250", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -706,7 +706,7 @@ impl EarlyLintPass for DeprecatedAttr {\n             }\n         }\n         if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n-            let path_str = pprust::path_to_string(&attr.path);\n+            let path_str = pprust::path_to_string(&attr.get_normal_item().path);\n             let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n         }\n@@ -736,7 +736,7 @@ impl UnusedDocComment {\n         let mut sugared_span: Option<Span> = None;\n \n         while let Some(attr) = attrs.next() {\n-            if attr.is_sugared_doc {\n+            if attr.is_doc_comment() {\n                 sugared_span = Some(\n                     sugared_span.map_or_else(\n                         || attr.span,\n@@ -745,7 +745,7 @@ impl UnusedDocComment {\n                 );\n             }\n \n-            if attrs.peek().map(|next_attr| next_attr.is_sugared_doc).unwrap_or_default() {\n+            if attrs.peek().map(|next_attr| next_attr.is_doc_comment()).unwrap_or_default() {\n                 continue;\n             }\n \n@@ -926,8 +926,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n-                if to_mt == hir::Mutability::MutMutable &&\n-                   from_mt == hir::Mutability::MutImmutable {\n+                if to_mt == hir::Mutability::Mutable &&\n+                   from_mt == hir::Mutability::Immutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }\n@@ -1476,14 +1476,12 @@ impl KeywordIdents {\n         let mut lint = cx.struct_span_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            &format!(\"`{}` is a keyword in the {} edition\",\n-                     ident.as_str(),\n-                     next_edition),\n+            &format!(\"`{}` is a keyword in the {} edition\", ident, next_edition),\n         );\n         lint.span_suggestion(\n             ident.span,\n             \"you can use a raw identifier to stay compatible\",\n-            format!(\"r#{}\", ident.as_str()),\n+            format!(\"r#{}\", ident),\n             Applicability::MachineApplicable,\n         );\n         lint.emit()\n@@ -1905,30 +1903,45 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n \n         /// Determine if this expression is a \"dangerous initialization\".\n         fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n-            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n             // `transmute` is inside an anonymous module (the `extern` block?);\n             // `Invalid` represents the empty string and matches that.\n+            // FIXME(#66075): use diagnostic items.  Somehow, that does not seem to work\n+            // on intrinsics right now.\n             const TRANSMUTE_PATH: &[Symbol] =\n                 &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n \n             if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n+                // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n-                    if cx.match_def_path(def_id, ZEROED_PATH) {\n+                    if cx.tcx.is_diagnostic_item(sym::mem_zeroed, def_id) {\n                         return Some(InitKind::Zeroed);\n-                    }\n-                    if cx.match_def_path(def_id, UININIT_PATH) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, def_id) {\n                         return Some(InitKind::Uninit);\n-                    }\n-                    if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                    } else if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n                         if is_zero(&args[0]) {\n                             return Some(InitKind::Zeroed);\n                         }\n                     }\n-                    // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n-                    // `MaybeUninit::uninit().assume_init()`.\n+                }\n+            } else if let hir::ExprKind::MethodCall(_, _, ref args) = expr.kind {\n+                // Find problematic calls to `MaybeUninit::assume_init`.\n+                let def_id = cx.tables.type_dependent_def_id(expr.hir_id)?;\n+                if cx.tcx.is_diagnostic_item(sym::assume_init, def_id) {\n+                    // This is a call to *some* method named `assume_init`.\n+                    // See if the `self` parameter is one of the dangerous constructors.\n+                    if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n+                        if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n+                            let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+\n+                            if cx.tcx.is_diagnostic_item(sym::maybe_uninit_zeroed, def_id) {\n+                                return Some(InitKind::Zeroed);\n+                            } else if cx.tcx.is_diagnostic_item(sym::maybe_uninit_uninit, def_id) {\n+                                return Some(InitKind::Uninit);\n+                            }\n+                        }\n+                    }\n                 }\n             }\n \n@@ -1949,6 +1962,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n+                RawPtr(tm) if matches!(tm.ty.kind, Dynamic(..)) => // raw ptr to dyn Trait\n+                    Some((format!(\"The vtable of a wide raw pointer must be non-null\"), None)),\n                 // Primitive types with other constraints.\n                 Bool if init == InitKind::Uninit =>\n                     Some((format!(\"Booleans must be `true` or `false`\"), None)),\n@@ -2032,7 +2047,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                 );\n                 err.span_label(expr.span,\n                     \"this code causes undefined behavior when executed\");\n-                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead, \\\n+                    and only call `assume_init` after initialization is done\");\n                 if let Some(span) = span {\n                     err.span_note(span, &msg);\n                 } else {"}, {"sha": "a1e50018f8aa245d693fdf618e8d9e0f7cbde3e8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -15,12 +15,14 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]\n+#![feature(matches_macro)]\n \n #![recursion_limit=\"256\"]\n \n #[macro_use]\n extern crate rustc;\n \n+mod array_into_iter;\n mod error_codes;\n mod nonstandard_style;\n mod redundant_semicolon;\n@@ -56,6 +58,7 @@ use types::*;\n use unused::*;\n use non_ascii_idents::*;\n use rustc::lint::internal::*;\n+use array_into_iter::ArrayIntoIter;\n \n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n@@ -130,6 +133,8 @@ macro_rules! late_lint_passes {\n             // FIXME: Turn the computation of types which implement Debug into a query\n             // and change this to a module lint pass\n             MissingDebugImplementations: MissingDebugImplementations::default(),\n+\n+            ArrayIntoIter: ArrayIntoIter,\n         ]);\n     )\n }\n@@ -334,6 +339,18 @@ fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/57742\");\n     store.register_removed(\"incoherent_fundamental_impls\",\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/46205\");\n+    store.register_removed(\"legacy_constructor_visibility\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/39207\");\n+    store.register_removed(\"legacy_disrectory_ownership\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/37872\");\n+    store.register_removed(\"safe_extern_statics\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/36247\");\n+    store.register_removed(\"parenthesized_params_in_types_and_modules\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/42238\");\n+    store.register_removed(\"duplicate_macro_exports\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/35896\");\n+    store.register_removed(\"nested_impl_trait\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/59014\");\n }\n \n fn register_internals(store: &mut lint::LintStore) {"}, {"sha": "65e0940920bd741a3babfa0f4e7027c83aca450a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 88, "deletions": 50, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::{ExprKind, Node};\n use crate::hir::def_id::DefId;\n use rustc::hir::lowering::is_range_literal;\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx, SizeSkeleton};\n use rustc::{lint, util};\n use rustc_index::vec::Idx;\n@@ -68,7 +68,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     max: u128,\n     expr: &'tcx hir::Expr,\n     parent_expr: &'tcx hir::Expr,\n-    ty: impl std::fmt::Debug,\n+    ty: &str,\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n@@ -83,15 +83,15 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n             let mut err = cx.struct_span_lint(\n                 OVERFLOWING_LITERALS,\n                 parent_expr.span,\n-                &format!(\"range endpoint is out of range for `{:?}`\", ty),\n+                &format!(\"range endpoint is out of range for `{}`\", ty),\n             );\n             if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n                 use ast::{LitKind, LitIntType};\n                 // We need to preserve the literal's suffix,\n                 // as it may determine typing information.\n                 let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n                     LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n                     _ => bug!(),\n                 };\n@@ -161,11 +161,11 @@ fn report_bin_hex_error(\n     let (t, actually) = match ty {\n         attr::IntType::SignedInt(t) => {\n             let actually = sign_extend(val, size) as i128;\n-            (format!(\"{:?}\", t), actually.to_string())\n+            (t.name_str(), actually.to_string())\n         }\n         attr::IntType::UnsignedInt(t) => {\n             let actually = truncate(val, size);\n-            (format!(\"{:?}\", t), actually.to_string())\n+            (t.name_str(), actually.to_string())\n         }\n     };\n     let mut err = cx.struct_span_lint(\n@@ -204,7 +204,7 @@ fn report_bin_hex_error(\n //  - `uX` => `uY`\n //\n // No suggestion for: `isize`, `usize`.\n-fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<String> {\n+fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static str> {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     macro_rules! find_fit {\n@@ -215,10 +215,10 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<String> {\n                 match $ty {\n                     $($type => {\n                         $(if !negative && val <= uint_ty_range($utypes).1 {\n-                            return Some(format!(\"{:?}\", $utypes))\n+                            return Some($utypes.name_str())\n                         })*\n                         $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n-                            return Some(format!(\"{:?}\", $itypes))\n+                            return Some($itypes.name_str())\n                         })*\n                         None\n                     },)+\n@@ -281,7 +281,7 @@ fn lint_int_literal<'a, 'tcx>(\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.kind {\n                 if is_range_literal(cx.sess(), par_e)\n-                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n+                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n                 {\n                     // The overflowing literal lint was overridden.\n                     return;\n@@ -292,7 +292,7 @@ fn lint_int_literal<'a, 'tcx>(\n         cx.span_lint(\n             OVERFLOWING_LITERALS,\n             e.span,\n-            &format!(\"literal out of range for `{:?}`\", t),\n+            &format!(\"literal out of range for `{}`\", t.name_str()),\n         );\n     }\n }\n@@ -338,6 +338,7 @@ fn lint_uint_literal<'a, 'tcx>(\n                 }\n                 hir::ExprKind::Struct(..)\n                     if is_range_literal(cx.sess(), par_e) => {\n+                        let t = t.name_str();\n                         if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n                             // The overflowing literal lint was overridden.\n                             return;\n@@ -353,7 +354,7 @@ fn lint_uint_literal<'a, 'tcx>(\n         cx.span_lint(\n             OVERFLOWING_LITERALS,\n             e.span,\n-            &format!(\"literal out of range for `{:?}`\", t),\n+            &format!(\"literal out of range for `{}`\", t.name_str()),\n         );\n     }\n }\n@@ -379,8 +380,7 @@ fn lint_literal<'a, 'tcx>(\n         }\n         ty::Float(t) => {\n             let is_infinite = match lit.node {\n-                ast::LitKind::Float(v, _) |\n-                ast::LitKind::FloatUnsuffixed(v) => {\n+                ast::LitKind::Float(v, _) => {\n                     match t {\n                         ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n                         ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n@@ -389,9 +389,11 @@ fn lint_literal<'a, 'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.span_lint(OVERFLOWING_LITERALS,\n-                             e.span,\n-                             &format!(\"literal out of range for `{:?}`\", t));\n+                cx.span_lint(\n+                    OVERFLOWING_LITERALS,\n+                    e.span,\n+                    &format!(\"literal out of range for `{}`\", t.name_str()),\n+                );\n             }\n         }\n         _ => {}\n@@ -835,16 +837,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::Array(ty, _) => self.check_type_for_ffi(cache, ty),\n \n             ty::FnPtr(sig) => {\n-                match sig.abi() {\n-                    Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n-                        return FfiUnsafe {\n-                            ty,\n-                            reason: \"this function pointer has Rust-specific calling convention\",\n-                            help: Some(\"consider using an `extern fn(...) -> ...` \\\n-                                        function pointer instead\"),\n-                        }\n-                    }\n-                    _ => {}\n+                if self.is_internal_abi(sig.abi()) {\n+                    return FfiUnsafe {\n+                        ty,\n+                        reason: \"this function pointer has Rust-specific calling convention\",\n+                        help: Some(\"consider using an `extern fn(...) -> ...` \\\n+                                    function pointer instead\"),\n+                    };\n                 }\n \n                 let sig = cx.erase_late_bound_regions(&sig);\n@@ -871,7 +870,10 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Foreign(..) => FfiSafe,\n \n-            ty::Param(..) |\n+            // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n+            //  so they are currently ignored for the purposes of this lint, see #65134.\n+            ty::Param(..) | ty::Projection(..) => FfiSafe,\n+\n             ty::Infer(..) |\n             ty::Bound(..) |\n             ty::Error |\n@@ -880,7 +882,6 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::GeneratorWitness(..) |\n             ty::Placeholder(..) |\n             ty::UnnormalizedProjection(..) |\n-            ty::Projection(..) |\n             ty::Opaque(..) |\n             ty::FnDef(..) => bug!(\"unexpected type in foreign function: {:?}\", ty),\n         }\n@@ -892,11 +893,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         sp: Span,\n         note: &str,\n         help: Option<&str>,\n+        is_foreign_item: bool,\n     ) {\n         let mut diag = self.cx.struct_span_lint(\n             IMPROPER_CTYPES,\n             sp,\n-            &format!(\"`extern` block uses type `{}`, which is not FFI-safe\", ty),\n+            &format!(\n+                \"`extern` {} uses type `{}`, which is not FFI-safe\",\n+                if is_foreign_item { \"block\" } else { \"fn\" },\n+                ty,\n+            ),\n         );\n         diag.span_label(sp, \"not FFI-safe\");\n         if let Some(help) = help {\n@@ -911,9 +917,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         diag.emit();\n     }\n \n-    fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n-        use crate::rustc::ty::TypeFoldable;\n-\n+    fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>, is_foreign_item: bool) -> bool {\n         struct ProhibitOpaqueTypes<'tcx> {\n             ty: Option<Ty<'tcx>>,\n         };\n@@ -937,70 +941,81 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 sp,\n                 \"opaque types have no C equivalent\",\n                 None,\n+                is_foreign_item,\n             );\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>) {\n+    fn check_type_for_ffi_and_report_errors(\n+        &mut self,\n+        sp: Span,\n+        ty: Ty<'tcx>,\n+        is_foreign_item: bool,\n+    ) {\n         // We have to check for opaque types before `normalize_erasing_regions`,\n         // which will replace opaque types with their underlying concrete type.\n-        if self.check_for_opaque_ty(sp, ty) {\n+        if self.check_for_opaque_ty(sp, ty, is_foreign_item) {\n             // We've already emitted an error due to an opaque type.\n             return;\n         }\n \n-        // it is only OK to use this function because extern fns cannot have\n-        // any generic types right now:\n-        let ty = self.cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-\n+        let ty = self.cx.tcx.normalize_erasing_regions(self.cx.param_env, ty);\n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n+                self.emit_ffi_unsafe_type_lint(\n+                    ty, sp, \"composed only of `PhantomData`\", None, is_foreign_item);\n             }\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n+                self.emit_ffi_unsafe_type_lint(\n+                    ty, sp, reason, help, is_foreign_item);\n             }\n         }\n     }\n \n-    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl) {\n+    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl, is_foreign_item: bool) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, is_foreign_item);\n         }\n \n         if let hir::Return(ref ret_hir) = decl.output {\n             let ret_ty = sig.output();\n             if !ret_ty.is_unit() {\n-                self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty);\n+                self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, is_foreign_item);\n             }\n         }\n     }\n \n     fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, ty);\n+        self.check_type_for_ffi_and_report_errors(span, ty, true);\n+    }\n+\n+    fn is_internal_abi(&self, abi: Abi) -> bool {\n+        if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n         let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n-        if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n-            // Don't worry about types in internal ABIs.\n-        } else {\n+        if !vis.is_internal_abi(abi) {\n             match it.kind {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {\n-                    vis.check_foreign_fn(it.hir_id, decl);\n+                    vis.check_foreign_fn(it.hir_id, decl, true);\n                 }\n                 hir::ForeignItemKind::Static(ref ty, _) => {\n                     vis.check_foreign_static(it.hir_id, ty.span);\n@@ -1009,6 +1024,29 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n             }\n         }\n     }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: hir::intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        _: &'tcx hir::Body,\n+        _: Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        use hir::intravisit::FnKind;\n+\n+        let abi = match kind {\n+            FnKind::ItemFn(_, _, header, ..) => (header.abi),\n+            FnKind::Method(_, sig, ..) => (sig.header.abi),\n+            _ => return,\n+        };\n+\n+        let mut vis = ImproperCTypesVisitor { cx };\n+        if !vis.is_internal_abi(abi) {\n+            vis.check_foreign_fn(hir_id, decl, false);\n+        }\n+    }\n }\n \n declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);"}, {"sha": "642b8e3279d6655b9707475d7e50cd58a510d82d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -10,7 +10,7 @@ use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::errors::{Applicability, pluralise};\n+use syntax::errors::{Applicability, pluralize};\n use syntax::feature_gate::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use syntax::print::pprust;\n use syntax::symbol::{kw, sym};\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 return true;\n             }\n \n-            let plural_suffix = pluralise!(plural_len);\n+            let plural_suffix = pluralize!(plural_len);\n \n             match ty.kind {\n                 ty::Adt(..) if ty.is_box() => {"}, {"sha": "b1431563f21cbc90461246548710103beb1c2b7f", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -13,7 +13,7 @@ doctest = false\n flate2 = \"1.0\"\n log = \"0.4\"\n memmap = \"0.6\"\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n@@ -23,4 +23,5 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n stable_deref_trait = \"1.0.0\"\n syntax = { path = \"../libsyntax\" }\n syntax_expand = { path = \"../libsyntax_expand\" }\n+rustc_parse = { path = \"../librustc_parse\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "05e3ee3322e59d031b96bb805fcde3a50c2cbbcd", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::schema::{CrateRoot, CrateDep};\n+use crate::rmeta::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lock, Once, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n@@ -121,7 +121,7 @@ impl<'a> CrateLoader<'a> {\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n             let source = &self.cstore.get_crate_data(cnum).source;\n-            if let Some(entry) = self.sess.opts.externs.get(&*name.as_str()) {\n+            if let Some(entry) = self.sess.opts.externs.get(&name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 let found = entry.locations.iter().filter_map(|l| l.as_ref()).any(|l| {\n                     let l = fs::canonicalize(l).ok();"}, {"sha": "c6c8ee575a98abdda0849974ef1cb4227c89eb45", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,7 +1,7 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use crate::schema;\n+use crate::rmeta;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -17,7 +17,7 @@ use syntax_expand::base::SyntaxExtension;\n use syntax_pos;\n use proc_macro::bridge::client::ProcMacro;\n \n-pub use crate::cstore_impl::{provide, provide_extern};\n+pub use crate::rmeta::{provide, provide_extern};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -49,7 +49,7 @@ crate struct CrateMetadata {\n     /// lifetime is only used behind `Lazy`, and therefore acts like an\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     /// is being used to decode those values.\n-    crate root: schema::CrateRoot<'static>,\n+    crate root: rmeta::CrateRoot<'static>,\n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n@@ -59,7 +59,7 @@ crate struct CrateMetadata {\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n-    crate trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n+    crate trait_impls: FxHashMap<(u32, DefIndex), rmeta::Lazy<[DefIndex]>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     crate raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate."}, {"sha": "ac9d78e9a515c199f5f3477a99e9a48d329b2b82", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,15 +26,11 @@ extern crate rustc_data_structures;\n \n pub mod error_codes;\n \n-mod encoder;\n-mod decoder;\n mod dependency_format;\n-mod cstore_impl;\n mod foreign_modules;\n mod link_args;\n mod native_libs;\n-mod schema;\n-mod table;\n+mod rmeta;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "b40d58a681976c8cbfa5fb888840c3aef07c05a9", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -11,7 +11,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().attrs.iter() {\n-        if attr.path == sym::link_args {\n+        if attr.has_name(sym::link_args) {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(&linkarg.as_str());\n             }"}, {"sha": "88d7595b063da20985a6fd004e96fb73552cafb9", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -214,7 +214,7 @@\n \n use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n-use crate::schema::{METADATA_HEADER, rustc_version};\n+use crate::rmeta::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;"}, {"sha": "c9de66a5c87262422bb8593cab060406f755508d", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -68,7 +68,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         Some(name) => name,\n                         None => continue, // skip like historical compilers\n                     };\n-                    lib.kind = match &kind.as_str()[..] {\n+                    lib.kind = match &*kind.as_str() {\n                         \"static\" => cstore::NativeStatic,\n                         \"static-nobundle\" => cstore::NativeStaticNobundle,\n                         \"dylib\" => cstore::NativeUnknown,"}, {"sha": "7cebf2512d64521286ff4316d63f1fdcee854c57", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "renamed", "additions": 67, "deletions": 61, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,8 +1,8 @@\n // Decoding metadata from a single crate's metadata\n \n use crate::cstore::{self, CrateMetadata, MetadataBlob};\n-use crate::schema::*;\n-use crate::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::*;\n+use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n@@ -40,6 +40,10 @@ use syntax_pos::symbol::{Symbol, sym};\n use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n \n+pub use cstore_impl::{provide, provide_extern};\n+\n+mod cstore_impl;\n+\n crate struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n@@ -464,7 +468,7 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n \n@@ -507,7 +511,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    crate fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    fn item_name(&self, item_index: DefIndex) -> Symbol {\n         if !self.is_proc_macro(item_index) {\n             self.def_key(item_index)\n                 .disambiguated_data\n@@ -519,7 +523,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.kind(index).def_kind()\n         } else {\n@@ -529,11 +533,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n         self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n-    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+    fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n         let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n@@ -563,7 +567,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -633,7 +637,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -658,52 +662,54 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    crate fn get_predicates(\n+    fn get_explicit_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_predicates_defined_on(\n+    fn get_inferred_outlives(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.predicates_defined_on.get(self, item_id).unwrap().decode((self, tcx))\n+    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+        self.root.per_def.inferred_outlives.get(self, item_id).map(|predicates| {\n+            predicates.decode((self, tcx))\n+        }).unwrap_or_default()\n     }\n \n-    crate fn get_super_predicates(\n+    fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n+    fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n             false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n-    crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root.per_def.deprecation.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .map(|depr| depr.decode(self))\n     }\n \n-    crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n             false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n@@ -717,31 +723,31 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    crate fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    crate fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    crate fn get_coerce_unsized_info(\n+    fn get_coerce_unsized_info(\n         &self,\n         id: DefIndex,\n     ) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    crate fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -750,7 +756,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    crate fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -763,7 +769,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    crate fn get_diagnostic_items(\n+    fn get_diagnostic_items(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n@@ -780,7 +786,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over each child of the given item.\n-    crate fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n+    fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n         if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n@@ -919,12 +925,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n             self.root.per_def.mir.get(self, id).is_some()\n     }\n \n-    crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root.per_def.mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n@@ -933,7 +939,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    crate fn get_promoted_mir(\n+    fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -946,7 +952,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+    fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n         match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n@@ -957,7 +963,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n@@ -990,12 +996,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+    fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n         self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty())\n             .decode(self).collect()\n     }\n \n-    crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n+    fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n@@ -1004,7 +1010,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n@@ -1016,7 +1022,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n+    fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1032,7 +1038,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect::<Vec<_>>())\n     }\n \n-    crate fn get_struct_field_names(\n+    fn get_struct_field_names(\n         &self,\n         id: DefIndex,\n         sess: &Session,\n@@ -1058,7 +1064,7 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    crate fn get_inherent_implementations_for_type(\n+    fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -1070,7 +1076,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_implementations_for_trait(\n+    fn get_implementations_for_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n@@ -1101,7 +1107,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1118,7 +1124,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    crate fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1127,7 +1133,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n+    fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1136,7 +1142,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_dylib_dependency_formats(\n+    fn get_dylib_dependency_formats(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n@@ -1150,7 +1156,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    crate fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1161,7 +1167,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+    fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n@@ -1171,7 +1177,7 @@ impl<'a, 'tcx> CrateMetadata {\n         param_names.decode(self).collect()\n     }\n \n-    crate fn exported_symbols(\n+    fn exported_symbols(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n@@ -1184,22 +1190,22 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_rendered_const(&self, id: DefIndex) -> String {\n+    fn get_rendered_const(&self, id: DefIndex) -> String {\n         match self.kind(id) {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n-    crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n+    fn get_macro(&self, id: DefIndex) -> MacroDef {\n         match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }\n \n-    crate fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n+    fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n@@ -1209,7 +1215,7 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n          match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n@@ -1218,7 +1224,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n@@ -1227,22 +1233,22 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n+    fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic |\n-            EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n+            EntryKind::ForeignImmStatic => Some(hir::Mutability::Immutable),\n             EntryKind::MutStatic |\n-            EntryKind::ForeignMutStatic => Some(hir::MutMutable),\n+            EntryKind::ForeignMutStatic => Some(hir::Mutability::Mutable),\n             _ => None,\n         }\n     }\n \n-    crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n-    crate fn def_key(&self, index: DefIndex) -> DefKey {\n+    fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n@@ -1252,13 +1258,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    crate fn def_path(&self, id: DefIndex) -> DefPath {\n+    fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n-    crate fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n \n@@ -1356,7 +1362,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this\n     /// method is cached in the `dep_node_index` field.\n-    pub(super) fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n         let mut dep_node_index = self.dep_node_index.load();\n \n         if unlikely!(dep_node_index == DepNodeIndex::INVALID) {", "previous_filename": "src/librustc_metadata/decoder.rs"}, {"sha": "015866548cd3846d3c3e191b647fc7113ab50c83", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "renamed", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,9 +1,8 @@\n use crate::cstore::{self, LoadedMacro};\n-use crate::encoder;\n use crate::link_args;\n use crate::native_libs;\n use crate::foreign_modules;\n-use crate::schema;\n+use crate::rmeta::{self, encoder};\n \n use rustc::ty::query::QueryConfig;\n use rustc::middle::cstore::{CrateSource, CrateStore, DepKind, EncodedMetadata, NativeLibraryKind};\n@@ -19,6 +18,8 @@ use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::svh::Svh;\n+use rustc_parse::source_file_to_stream;\n+use rustc_parse::parser::emit_unclosed_delims;\n \n use smallvec::SmallVec;\n use std::any::Any;\n@@ -28,12 +29,9 @@ use std::sync::Arc;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n-use syntax::parse::source_file_to_stream;\n-use syntax::parse::parser::emit_unclosed_delims;\n use syntax::source_map::Spanned;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n-use rustc_index::bit_set::BitSet;\n \n macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n@@ -95,8 +93,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generics_of => {\n         tcx.arena.alloc(cdata.get_generics(def_id.index, tcx.sess))\n     }\n-    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n-    predicates_defined_on => { cdata.get_predicates_defined_on(def_id.index, tcx) }\n+    explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n+    inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n         tcx.arena.alloc(cdata.get_trait_def(def_id.index, tcx.sess))\n@@ -123,9 +121,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n-    }\n+    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n@@ -529,6 +525,6 @@ impl CrateStore for cstore::CStore {\n \n     fn metadata_encoding_version(&self) -> &[u8]\n     {\n-        schema::METADATA_HEADER\n+        rmeta::METADATA_HEADER\n     }\n }", "previous_filename": "src/librustc_metadata/cstore_impl.rs"}, {"sha": "26055d329bcbd19736321a6604a474600b172a67", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "renamed", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,5 @@\n-use crate::schema::*;\n-use crate::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::*;\n+use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n@@ -76,8 +76,8 @@ struct PerDefTables<'tcx> {\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n-    predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-    predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    explicit_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    inferred_outlives: PerDefTable<Lazy<&'tcx [(ty::Predicate<'tcx>, Span)]>>,\n     super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n@@ -524,8 +524,8 @@ impl<'tcx> EncodeContext<'tcx> {\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n-            predicates: self.per_def.predicates.encode(&mut self.opaque),\n-            predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+            explicit_predicates: self.per_def.explicit_predicates.encode(&mut self.opaque),\n+            inferred_outlives: self.per_def.inferred_outlives.encode(&mut self.opaque),\n             super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n \n             mir: self.per_def.mir.encode(&mut self.opaque),\n@@ -542,7 +542,6 @@ impl<'tcx> EncodeContext<'tcx> {\n         let attrs = tcx.hir().krate_attrs();\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n-        let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n         let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n@@ -553,7 +552,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             panic_strategy: tcx.sess.panic_strategy(),\n             edition: tcx.sess.edition(),\n             has_global_allocator: has_global_allocator,\n-            has_panic_handler: has_panic_handler,\n+            has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n             has_default_lib_allocator: has_default_lib_allocator,\n             plugin_registrar_fn: tcx.plugin_registrar_fn(LOCAL_CRATE).map(|id| id.index),\n             proc_macro_decls_static: if is_proc_macro {\n@@ -676,7 +675,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -719,7 +719,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -777,7 +778,8 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n     }\n \n     fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n@@ -820,7 +822,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -830,15 +833,18 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n-    fn encode_predicates(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n-        record!(self.per_def.predicates[def_id] <- self.tcx.predicates_of(def_id));\n+    fn encode_explicit_predicates(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_explicit_predicates({:?})\", def_id);\n+        record!(self.per_def.explicit_predicates[def_id] <-\n+            self.tcx.explicit_predicates_of(def_id));\n     }\n \n-    fn encode_predicates_defined_on(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n-        record!(self.per_def.predicates_defined_on[def_id] <-\n-            self.tcx.predicates_defined_on(def_id))\n+    fn encode_inferred_outlives(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_inferred_outlives({:?})\", def_id);\n+        let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n+        if !inferred_outlives.is_empty() {\n+            record!(self.per_def.inferred_outlives[def_id] <- inferred_outlives);\n+        }\n     }\n \n     fn encode_super_predicates(&mut self, def_id: DefId) {\n@@ -920,7 +926,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -948,7 +955,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n-                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n+                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n \n                     EntryKind::AssocConst(container,\n                         ConstQualif { mir },\n@@ -987,7 +994,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n             hir::ImplItemKind::Method(ref sig, _) => {\n@@ -1078,19 +1086,19 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         record!(self.per_def.kind[def_id] <- match item.kind {\n-            hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n-            hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Mutable, _) => EntryKind::MutStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Immutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = self.tcx.at(item.span).mir_const_qualif(def_id).0;\n+                let mir = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n                     ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n-            hir::ItemKind::Fn(_, header, .., body) => {\n+            hir::ItemKind::Fn(ref sig, .., body) => {\n                 let data = FnData {\n-                    asyncness: header.asyncness,\n-                    constness: header.constness,\n+                    asyncness: sig.header.asyncness,\n+                    constness: sig.header.constness,\n                     param_names: self.encode_fn_param_names_for_body(body),\n                 };\n \n@@ -1261,22 +1269,11 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::TraitAlias(..) => {\n                 self.encode_generics(def_id);\n-                self.encode_predicates(def_id);\n+                self.encode_explicit_predicates(def_id);\n+                self.encode_inferred_outlives(def_id);\n             }\n             _ => {}\n         }\n-        // The only time that `predicates_defined_on` is used (on\n-        // an external item) is for traits, during chalk lowering,\n-        // so only encode it in that case as an efficiency\n-        // hack. (No reason not to expand it in the future if\n-        // necessary.)\n-        match item.kind {\n-            hir::ItemKind::Trait(..) |\n-            hir::ItemKind::TraitAlias(..) => {\n-                self.encode_predicates_defined_on(def_id);\n-            }\n-            _ => {} // not *wrong* for other kinds of items, but not needed\n-        }\n         match item.kind {\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::TraitAlias(..) => {\n@@ -1287,14 +1284,14 @@ impl EncodeContext<'tcx> {\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n-            hir::ItemKind::Fn(_, header, ..) => {\n+            hir::ItemKind::Fn(ref sig, ..) => {\n                 let generics = tcx.generics_of(def_id);\n                 let needs_inline =\n                     (generics.requires_monomorphization(tcx) ||\n                         tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                         !self.metadata_output_only();\n                 let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                needs_inline || header.constness == hir::Constness::Const || always_encode_mir\n+                needs_inline || sig.header.constness == hir::Constness::Const || always_encode_mir\n             }\n             _ => false,\n         };\n@@ -1371,14 +1368,15 @@ impl EncodeContext<'tcx> {\n         let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = self.tcx.mir_const_qualif(def_id).0;\n+        let mir = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -1573,8 +1571,10 @@ impl EncodeContext<'tcx> {\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n-            hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Mutable) =>\n+                EntryKind::ForeignMutStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Immutable) =>\n+                EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n         record!(self.per_def.visibility[def_id] <-\n@@ -1589,7 +1589,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n     }\n }\n \n@@ -1782,7 +1783,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+pub(super) fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n ", "previous_filename": "src/librustc_metadata/encoder.rs"}, {"sha": "990a3d984b225ef8776c23788f89eb682985ce7d", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "renamed", "additions": 97, "deletions": 91, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,4 +1,5 @@\n-use crate::table::PerDefTable;\n+use decoder::Metadata;\n+use table::PerDefTable;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -13,7 +14,6 @@ use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n-\n use rustc_serialize::Encodable;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n@@ -23,6 +23,12 @@ use syntax_pos::{self, Span};\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+pub use decoder::{provide, provide_extern};\n+\n+mod decoder;\n+mod encoder;\n+mod table;\n+\n crate fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -31,18 +37,15 @@ crate fn rustc_version() -> String {\n /// Metadata encoding version.\n /// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n-const METADATA_VERSION: u8 = 4;\n+const METADATA_VERSION: u8 = 5;\n \n /// Metadata header which includes `METADATA_VERSION`.\n-/// To get older versions of rustc to ignore this metadata,\n-/// there are 4 zero bytes at the start, which are treated\n-/// as a length of 0 by old compilers.\n ///\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-crate const METADATA_HEADER: &[u8; 12] =\n-    &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n+crate const METADATA_HEADER: &[u8; 8] =\n+    &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n@@ -104,13 +107,13 @@ crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n-    pub position: NonZeroUsize,\n-    pub meta: Meta,\n+    position: NonZeroUsize,\n+    meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-     crate fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n+     fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -120,13 +123,13 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n }\n \n impl<T: Encodable> Lazy<T> {\n-    crate fn from_position(position: NonZeroUsize) -> Lazy<T> {\n+    fn from_position(position: NonZeroUsize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n impl<T: Encodable> Lazy<[T]> {\n-    crate fn empty() -> Lazy<[T]> {\n+    fn empty() -> Lazy<[T]> {\n         Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n     }\n }\n@@ -143,7 +146,7 @@ impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T>\n \n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-crate enum LazyState {\n+enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n@@ -171,46 +174,46 @@ macro_rules! Lazy {\n crate struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n-    pub extra_filename: String,\n+    extra_filename: String,\n     pub hash: Svh,\n     pub disambiguator: CrateDisambiguator,\n     pub panic_strategy: PanicStrategy,\n-    pub edition: Edition,\n+    edition: Edition,\n     pub has_global_allocator: bool,\n-    pub has_panic_handler: bool,\n+    has_panic_handler: bool,\n     pub has_default_lib_allocator: bool,\n-    pub plugin_registrar_fn: Option<DefIndex>,\n-    pub proc_macro_decls_static: Option<DefIndex>,\n-    pub proc_macro_stability: Option<attr::Stability>,\n+    plugin_registrar_fn: Option<DefIndex>,\n+    proc_macro_decls_static: Option<DefIndex>,\n+    proc_macro_stability: Option<attr::Stability>,\n \n     pub crate_deps: Lazy<[CrateDep]>,\n-    pub dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n-    pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n-    pub lang_items: Lazy<[(DefIndex, usize)]>,\n-    pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n-    pub diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n-    pub native_libraries: Lazy<[NativeLibrary]>,\n-    pub foreign_modules: Lazy<[ForeignModule]>,\n-    pub source_map: Lazy<[syntax_pos::SourceFile]>,\n+    dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n+    lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n+    lang_items: Lazy<[(DefIndex, usize)]>,\n+    lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n+    native_libraries: Lazy<[NativeLibrary]>,\n+    foreign_modules: Lazy<[ForeignModule]>,\n+    source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: Lazy<[TraitImpls]>,\n-    pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n+    exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub per_def: LazyPerDefTables<'tcx>,\n+    per_def: LazyPerDefTables<'tcx>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n     pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n-    pub compiler_builtins: bool,\n+    compiler_builtins: bool,\n     pub needs_allocator: bool,\n     pub needs_panic_runtime: bool,\n-    pub no_builtins: bool,\n+    no_builtins: bool,\n     pub panic_runtime: bool,\n     pub profiler_runtime: bool,\n     pub sanitizer_runtime: bool,\n-    pub symbol_mangling_version: SymbolManglingVersion,\n+    symbol_mangling_version: SymbolManglingVersion,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -230,30 +233,33 @@ crate struct TraitImpls {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct LazyPerDefTables<'tcx> {\n-    pub kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n-    pub visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n-    pub span: Lazy!(PerDefTable<Lazy<Span>>),\n-    pub attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n-    pub children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    pub stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n-    pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n-\n-    pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n-    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n-    pub impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n-    pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n-    pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-    pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-    pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-\n-    pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n-    pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n+    kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n+    visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n+    span: Lazy!(PerDefTable<Lazy<Span>>),\n+    attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n+    children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n+    deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n+    ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n+    impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n+    inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n+    generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n+    explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n+    // doesn't handle shorthands in its own (de)serialization impls,\n+    // as it's an `enum` for which we want to derive (de)serialization,\n+    // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n+    // Also, as an optimization, a missing entry indicates an empty `&[]`.\n+    inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n+    super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n+    promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-crate enum EntryKind<'tcx> {\n+enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n@@ -288,74 +294,74 @@ crate enum EntryKind<'tcx> {\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-crate struct ConstQualif {\n-    pub mir: u8,\n+struct ConstQualif {\n+    mir: u8,\n }\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct RenderedConst(pub String);\n+struct RenderedConst(String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct ModData {\n-    pub reexports: Lazy<[def::Export<hir::HirId>]>,\n+struct ModData {\n+    reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MacroDef {\n-    pub body: String,\n-    pub legacy: bool,\n+struct MacroDef {\n+    body: String,\n+    legacy: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData {\n-    pub asyncness: hir::IsAsync,\n-    pub constness: hir::Constness,\n-    pub param_names: Lazy<[ast::Name]>,\n+struct FnData {\n+    asyncness: hir::IsAsync,\n+    constness: hir::Constness,\n+    param_names: Lazy<[ast::Name]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData {\n-    pub ctor_kind: CtorKind,\n-    pub discr: ty::VariantDiscr,\n+struct VariantData {\n+    ctor_kind: CtorKind,\n+    discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n-    pub ctor: Option<DefIndex>,\n+    ctor: Option<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitData {\n-    pub unsafety: hir::Unsafety,\n-    pub paren_sugar: bool,\n-    pub has_auto_impl: bool,\n-    pub is_marker: bool,\n+struct TraitData {\n+    unsafety: hir::Unsafety,\n+    paren_sugar: bool,\n+    has_auto_impl: bool,\n+    is_marker: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct ImplData {\n-    pub polarity: ty::ImplPolarity,\n-    pub defaultness: hir::Defaultness,\n-    pub parent_impl: Option<DefId>,\n+struct ImplData {\n+    polarity: ty::ImplPolarity,\n+    defaultness: hir::Defaultness,\n+    parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n-    pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n+    coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n }\n \n \n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-crate enum AssocContainer {\n+enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n     ImplFinal,\n }\n \n impl AssocContainer {\n-    crate fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n+    fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n         match *self {\n             AssocContainer::TraitRequired |\n             AssocContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -365,7 +371,7 @@ impl AssocContainer {\n         }\n     }\n \n-    crate fn defaultness(&self) -> hir::Defaultness {\n+    fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n             AssocContainer::TraitRequired => hir::Defaultness::Default {\n                 has_value: false,\n@@ -382,17 +388,17 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData {\n-    pub fn_data: FnData,\n-    pub container: AssocContainer,\n-    pub has_self: bool,\n+struct MethodData {\n+    fn_data: FnData,\n+    container: AssocContainer,\n+    has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct GeneratorData<'tcx> {\n-    pub layout: mir::GeneratorLayout<'tcx>,\n+struct GeneratorData<'tcx> {\n+    layout: mir::GeneratorLayout<'tcx>,\n }\n \n // Tags used for encoding Spans:\n-crate const TAG_VALID_SPAN: u8 = 0;\n-crate const TAG_INVALID_SPAN: u8 = 1;\n+const TAG_VALID_SPAN: u8 = 0;\n+const TAG_INVALID_SPAN: u8 = 1;", "previous_filename": "src/librustc_metadata/schema.rs"}, {"sha": "613d92c6d7b0b9c34aa4dc995bf9f5d0e19eacc8", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "renamed", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,5 +1,4 @@\n-use crate::decoder::Metadata;\n-use crate::schema::*;\n+use crate::rmeta::*;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc_serialize::{Encodable, opaque::Encoder};\n@@ -12,7 +11,7 @@ use log::debug;\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n-crate trait FixedSizeEncoding: Default {\n+pub(super) trait FixedSizeEncoding: Default {\n     const BYTE_LEN: usize;\n \n     // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n@@ -126,7 +125,7 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n // FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n // when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n // (not sure if that is possible given that the `Vec` is being resized now)\n-crate struct Table<T> where Option<T>: FixedSizeEncoding {\n+pub(super) struct Table<T> where Option<T>: FixedSizeEncoding {\n     // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n     // once that starts being allowed by the compiler (i.e. lazy normalization).\n     bytes: Vec<u8>,\n@@ -143,7 +142,7 @@ impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n }\n \n impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n-    crate fn set(&mut self, i: usize, value: T) {\n+    fn set(&mut self, i: usize, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n@@ -157,7 +156,7 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n         Some(value).write_to_bytes_at(&mut self.bytes, i);\n     }\n \n-    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let pos = buf.position();\n         buf.emit_raw_bytes(&self.bytes);\n         Lazy::from_position_and_meta(\n@@ -178,7 +177,7 @@ impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n         i: usize,\n@@ -194,7 +193,7 @@ impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n /// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n // FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n // and by using `newtype_index!` to define `DefIndex`.\n-crate struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n+pub(super) struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n \n impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n     fn default() -> Self {\n@@ -203,12 +202,12 @@ impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n }\n \n impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    crate fn set(&mut self, def_id: DefId, value: T) {\n+    pub(super) fn set(&mut self, def_id: DefId, value: T) {\n         assert!(def_id.is_local());\n         self.0.set(def_id.index.index(), value);\n     }\n \n-    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let lazy = self.0.encode(buf);\n         Lazy::from_position_and_meta(lazy.position, lazy.meta)\n     }\n@@ -229,7 +228,7 @@ impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n \n     /// Given the metadata, extract out the value at a particular DefIndex (if any).\n     #[inline(never)]\n-    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n         def_index: DefIndex,", "previous_filename": "src/librustc_metadata/table.rs"}, {"sha": "8c62640353a9e83c2c0db36ac324b539c11a0013", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,4 +26,4 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "ebc25138a06191d452469d24d13bf59e38eb3493", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 102, "deletions": 54, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -2,9 +2,9 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n-    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n-    Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n+    FakeReadCause, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -380,42 +380,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let first_borrow_desc;\n         let mut err = match (\n             gen_borrow_kind,\n-            \"immutable\",\n-            \"mutable\",\n             issued_borrow.kind,\n-            \"immutable\",\n-            \"mutable\",\n         ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) => {\n+            (BorrowKind::Shared, BorrowKind::Mut { .. }) => {\n                 first_borrow_desc = \"mutable \";\n                 self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n-                    lft,\n+                    \"immutable\",\n                     issued_span,\n                     \"it\",\n-                    rgt,\n+                    \"mutable\",\n                     &msg_borrow,\n                     None,\n                 )\n             }\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n                 self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n-                    lft,\n+                    \"mutable\",\n                     issued_span,\n                     \"it\",\n-                    rgt,\n+                    \"immutable\",\n                     &msg_borrow,\n                     None,\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_mutably_borrow_multiply(\n                     span,\n@@ -427,7 +423,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Unique, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_uniquely_borrow_by_two_closures(\n                     span,\n@@ -437,25 +433,45 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n-                let mut err = self.cannot_mutate_in_match_guard(\n-                    span,\n-                    issued_span,\n-                    &desc_place,\n-                    \"mutably borrow\",\n-                );\n-                borrow_spans.var_span_label(\n-                    &mut err,\n-                    format!(\n-                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n-                    ),\n-                );\n+            (BorrowKind::Mut { .. }, BorrowKind::Shallow)\n+            | (BorrowKind::Unique, BorrowKind::Shallow) => {\n+                if let Some(immutable_section_description) = self.classify_immutable_section(\n+                    &issued_borrow.assigned_place,\n+                ) {\n+                    let mut err = self.cannot_mutate_in_immutable_section(\n+                        span,\n+                        issued_span,\n+                        &desc_place,\n+                        immutable_section_description,\n+                        \"mutably borrow\",\n+                    );\n+                    borrow_spans.var_span_label(\n+                        &mut err,\n+                        format!(\n+                            \"borrow occurs due to use of `{}`{}\",\n+                            desc_place,\n+                            borrow_spans.describe(),\n+                        ),\n+                    );\n \n-                return err;\n+                    return err;\n+                } else {\n+                    first_borrow_desc = \"immutable \";\n+                    self.cannot_reborrow_already_borrowed(\n+                        span,\n+                        &desc_place,\n+                        &msg_place,\n+                        \"mutable\",\n+                        issued_span,\n+                        \"it\",\n+                        \"immutable\",\n+                        &msg_borrow,\n+                        None,\n+                    )\n+                }\n             }\n \n-            (BorrowKind::Unique, _, _, _, _, _) => {\n+            (BorrowKind::Unique, _) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_uniquely_borrow_by_one_closure(\n                     span,\n@@ -469,42 +485,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             },\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Shared, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n                     \"\",\n-                    lft,\n+                    \"immutable\",\n                     issued_span,\n                     \"\",\n                     None,\n                     second_borrow_desc,\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n                     \"\",\n-                    lft,\n+                    \"mutable\",\n                     issued_span,\n                     \"\",\n                     None,\n                     second_borrow_desc,\n                 )\n             }\n \n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n+            (BorrowKind::Shared, BorrowKind::Shared)\n+            | (BorrowKind::Shared, BorrowKind::Shallow)\n+            | (BorrowKind::Shallow, BorrowKind::Mut { .. })\n+            | (BorrowKind::Shallow, BorrowKind::Unique)\n+            | (BorrowKind::Shallow, BorrowKind::Shared)\n+            | (BorrowKind::Shallow, BorrowKind::Shallow) => unreachable!(),\n         };\n \n         if issued_spans == borrow_spans {\n@@ -974,7 +990,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut err = self.cannot_borrow_across_destructor(borrow_span);\n \n         let what_was_dropped = match self.describe_place(place.as_ref()) {\n-            Some(name) => format!(\"`{}`\", name.as_str()),\n+            Some(name) => format!(\"`{}`\", name),\n             None => String::from(\"temporary value\"),\n         };\n \n@@ -1429,20 +1445,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let loan_span = loan_spans.args_or_use();\n \n         if loan.kind == BorrowKind::Shallow {\n-            let mut err = self.cannot_mutate_in_match_guard(\n-                span,\n-                loan_span,\n-                &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-                \"assign\",\n-            );\n-            loan_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            );\n+            if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n+                let mut err = self.cannot_mutate_in_immutable_section(\n+                    span,\n+                    loan_span,\n+                    &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+                    section,\n+                    \"assign\",\n+                );\n+                loan_spans.var_span_label(\n+                    &mut err,\n+                    format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+                );\n \n-            err.buffer(&mut self.errors_buffer);\n+                err.buffer(&mut self.errors_buffer);\n \n-            return;\n+                return;\n+            }\n         }\n \n         let mut err = self.cannot_assign_to_borrowed(\n@@ -1593,6 +1612,35 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    /// Describe the reason for the fake borrow that was assigned to `place`.\n+    fn classify_immutable_section(&self, place: &Place<'tcx>) -> Option<&'static str> {\n+        use rustc::mir::visit::Visitor;\n+        struct FakeReadCauseFinder<'a, 'tcx> {\n+            place: &'a Place<'tcx>,\n+            cause: Option<FakeReadCause>,\n+        }\n+        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'_, 'tcx> {\n+            fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n+                match statement {\n+                    Statement {\n+                        kind: StatementKind::FakeRead(cause, box ref place),\n+                        ..\n+                    } if *place == *self.place => {\n+                        self.cause = Some(*cause);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+        let mut visitor = FakeReadCauseFinder { place, cause: None };\n+        visitor.visit_body(&self.body);\n+        match visitor.cause {\n+            Some(FakeReadCause::ForMatchGuard) => Some(\"match guard\"),\n+            Some(FakeReadCause::ForIndex) => Some(\"indexing expression\"),\n+            _ => None,\n+        }\n+    }\n+\n     /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n     /// borrow of local value that does not live long enough.\n     fn annotate_argument_and_return_for_borrow("}, {"sha": "f932a6bf1558f56a683c9a53caf786cd7f47cc4c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -137,7 +137,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             };\n             let bm = *tables.pat_binding_modes().get(var_hir_id)\n                 .expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::MutMutable) {\n+            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n                 upvar.mutability = Mutability::Mut;\n             }\n             upvar\n@@ -235,7 +235,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n-            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n+            kind: hir::ExprKind::Closure(.., Some(hir::Movability::Static)),\n             ..\n         }) => false,\n         _ => true,\n@@ -2118,10 +2118,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::Mutability::Immutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n-                                    hir::MutMutable => {\n+                                    hir::Mutability::Mutable => {\n                                         let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n@@ -2141,10 +2141,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::Mutability::Immutable => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n-                                    hir::MutMutable => {\n+                                    hir::Mutability::Mutable => {\n                                         Ok(RootPlace {\n                                             place_base: place.base,\n                                             place_projection: place.projection,"}, {"sha": "11e89de810e5b1ac51d9bec631c7ef51fc03743e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -271,7 +271,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // we have an explicit self. Do the same thing in this case and check\n                         // for a `self: &mut Self` to suggest removing the `&mut`.\n                         if let ty::Ref(\n-                            _, _, hir::Mutability::MutMutable\n+                            _, _, hir::Mutability::Mutable\n                         ) = local_decl.ty.kind {\n                             true\n                         } else {\n@@ -593,7 +593,7 @@ fn suggest_ampmut<'tcx>(\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n+    assert_eq!(ty_mut.mutbl, hir::Mutability::Immutable);\n     (highlight_span,\n      if local_decl.ty.is_region_ptr() {\n          format!(\"&mut {}\", ty_mut.ty)\n@@ -629,7 +629,7 @@ fn annotate_struct_field(\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {\n                 if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n-                    mutbl: hir::Mutability::MutImmutable,\n+                    mutbl: hir::Mutability::Immutable,\n                     ref ty\n                 }) = field.ty.kind {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and"}, {"sha": "37fc0b09e5b9fd058b1e951eba3d9145cd6123ee", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 112, "deletions": 58, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -36,6 +36,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{self, ObligationCause, PredicateObligations};\n use rustc::ty::adjustment::{PointerCast};\n+use rustc::ty::cast::CastTy;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind, UserSubsts};\n use rustc::ty::{\n@@ -2137,7 +2138,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_from = match op.ty(body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n-                                mutbl: hir::MutMutable,\n+                                mutbl: hir::Mutability::Mutable,\n                             }) => ty_from,\n                             _ => {\n                                 span_mirbug!(\n@@ -2152,7 +2153,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_to = match ty.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n-                                mutbl: hir::MutImmutable,\n+                                mutbl: hir::Mutability::Immutable,\n                             }) => ty_to,\n                             _ => {\n                                 span_mirbug!(\n@@ -2177,72 +2178,125 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ty_from,\n                                 ty_to,\n                                 terr\n-                            )\n+                            );\n                         }\n                     }\n \n-                    CastKind::Misc => {\n-                        if let ty::Ref(_, mut ty_from, _) = op.ty(body, tcx).kind {\n-                            let (mut ty_to, mutability) = if let ty::RawPtr(ty::TypeAndMut {\n-                                ty: ty_to,\n-                                mutbl,\n-                            }) = ty.kind {\n-                                (ty_to, mutbl)\n-                            } else {\n+                    CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n+                        let ty_from = op.ty(body, tcx);\n+\n+                        let opt_ty_elem = match ty_from.kind {\n+                            ty::RawPtr(\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: array_ty }\n+                            ) => {\n+                                match array_ty.kind {\n+                                    ty::Array(ty_elem, _) => Some(ty_elem),\n+                                    _ => None,\n+                                }\n+                            }\n+                            _ => None,\n+                        };\n+\n+                        let ty_elem = match opt_ty_elem {\n+                            Some(ty_elem) => ty_elem,\n+                            None => {\n                                 span_mirbug!(\n                                     self,\n                                     rvalue,\n-                                    \"invalid cast types {:?} -> {:?}\",\n-                                    op.ty(body, tcx),\n+                                    \"ArrayToPointer cast from unexpected type {:?}\",\n+                                    ty_from,\n+                                );\n+                                return;\n+                            }\n+                        };\n+\n+                        let ty_to = match ty.kind {\n+                            ty::RawPtr(\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: ty_to }\n+                            ) => {\n+                                ty_to\n+                            }\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"ArrayToPointer cast to unexpected type {:?}\",\n                                     ty,\n                                 );\n                                 return;\n-                            };\n-\n-                            // Handle the direct cast from `&[T; N]` to `*const T` by unwrapping\n-                            // any array we find.\n-                            while let ty::Array(ty_elem_from, _) = ty_from.kind {\n-                                ty_from = ty_elem_from;\n-                                if let ty::Array(ty_elem_to, _) = ty_to.kind {\n-                                    ty_to = ty_elem_to;\n-                                } else {\n-                                    break;\n-                                }\n                             }\n+                        };\n \n-                            if let hir::MutMutable = mutability {\n-                                if let Err(terr) = self.eq_types(\n-                                    ty_from,\n-                                    ty_to,\n-                                    location.to_locations(),\n-                                    ConstraintCategory::Cast,\n-                                ) {\n-                                    span_mirbug!(\n-                                        self,\n-                                        rvalue,\n-                                        \"equating {:?} with {:?} yields {:?}\",\n-                                        ty_from,\n-                                        ty_to,\n-                                        terr\n-                                    )\n-                                }\n-                            } else {\n-                                if let Err(terr) = self.sub_types(\n-                                    ty_from,\n-                                    ty_to,\n-                                    location.to_locations(),\n-                                    ConstraintCategory::Cast,\n-                                ) {\n-                                    span_mirbug!(\n-                                        self,\n-                                        rvalue,\n-                                        \"relating {:?} with {:?} yields {:?}\",\n-                                        ty_from,\n-                                        ty_to,\n-                                        terr\n-                                    )\n+                        if let Err(terr) = self.sub_types(\n+                            ty_elem,\n+                            ty_to,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"relating {:?} with {:?} yields {:?}\",\n+                                ty_elem,\n+                                ty_to,\n+                                terr\n+                            )\n+                        }\n+                    }\n+\n+                    CastKind::Misc => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::RPtr(ref_tm)), Some(CastTy::Ptr(ptr_tm))) => {\n+                                if let hir::Mutability::Mutable = ptr_tm.mutbl {\n+                                    if let Err(terr) = self.eq_types(\n+                                        ref_tm.ty,\n+                                        ptr_tm.ty,\n+                                        location.to_locations(),\n+                                        ConstraintCategory::Cast,\n+                                    ) {\n+                                        span_mirbug!(\n+                                            self,\n+                                            rvalue,\n+                                            \"equating {:?} with {:?} yields {:?}\",\n+                                            ref_tm.ty,\n+                                            ptr_tm.ty,\n+                                            terr\n+                                        )\n+                                    }\n+                                } else {\n+                                    if let Err(terr) = self.sub_types(\n+                                        ref_tm.ty,\n+                                        ptr_tm.ty,\n+                                        location.to_locations(),\n+                                        ConstraintCategory::Cast,\n+                                    ) {\n+                                        span_mirbug!(\n+                                            self,\n+                                            rvalue,\n+                                            \"relating {:?} with {:?} yields {:?}\",\n+                                            ref_tm.ty,\n+                                            ptr_tm.ty,\n+                                            terr\n+                                        )\n+                                    }\n                                 }\n-                            }\n+                            },\n+                            (None, _)\n+                            | (_, None)\n+                            | (_, Some(CastTy::FnPtr))\n+                            | (Some(CastTy::Float), Some(CastTy::Ptr(_)))\n+                            | (Some(CastTy::Ptr(_)), Some(CastTy::Float))\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Float)) => span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"Invalid cast {:?} -> {:?}\",\n+                                ty_from,\n+                                ty,\n+                            ),\n+                            _ => (),\n                         }\n                     }\n                 }\n@@ -2450,13 +2504,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             });\n \n                             match mutbl {\n-                                hir::Mutability::MutImmutable => {\n+                                hir::Mutability::Immutable => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n                                     break;\n                                 }\n-                                hir::Mutability::MutMutable => {\n+                                hir::Mutability::Mutable => {\n                                     // Mutable reference. We *do* need the base\n                                     // to be valid, because after the base becomes\n                                     // invalid, someone else can use our mutable deref."}, {"sha": "fbedac45ddf3c9ba7dc655a86b4f6c0c726b96e9", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -90,7 +90,7 @@ pub enum DefiningTy<'tcx> {\n     /// The MIR is a generator. The signature is that generators take\n     /// no parameters and return the result of\n     /// `ClosureSubsts::generator_return_ty`.\n-    Generator(DefId, SubstsRef<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n \n     /// The MIR is a fn item with the given `DefId` and substs. The signature\n     /// of the function can be bound then with the `fn_sig` query."}, {"sha": "f0d2927ba45e70af68034f845718d23260b51607", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n \n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n-                if let ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) = ty.kind {\n+                if let ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) = ty.kind {\n                     // For both derefs of raw pointers and `&T`\n                     // references, the original path is `Copy` and\n                     // therefore not significant.  In particular,"}, {"sha": "87a431a7fb80d3a102228be6eb521f93e0a87eec", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -246,11 +246,13 @@ fn place_components_conflict<'tcx>(\n                     debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n                     return false;\n                 }\n-                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Immutable), _) => {\n                     // Shouldn't be tracked\n                     bug!(\"Tracking borrow behind shared reference.\");\n                 }\n-                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n+                (ProjectionElem::Deref,\n+                 ty::Ref(_, _, hir::Mutability::Mutable),\n+                 AccessDepth::Drop) => {\n                     // Values behind a mutable reference are not access either by dropping a\n                     // value, or by StorageDead\n                     debug!(\"borrow_conflicts_with_place: drop access behind ptr\");"}, {"sha": "57833cac9cb44a9a88982cacd99f95f9c5490bf5", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -149,7 +149,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::MutImmutable\n+                            hir::Mutability::Immutable\n                             ) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows.\n@@ -160,7 +160,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::MutMutable,\n+                            hir::Mutability::Mutable,\n                             ) => {\n                             self.next = Some(PlaceRef {\n                                 base: cursor.base,"}, {"sha": "d3e013acc9e3a8ed17fee81e8beb06aa97b0f4cc", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 252, "deletions": 51, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,9 +4,11 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use syntax_pos::Span;\n \n use rustc_index::vec::Idx;\n \n@@ -68,6 +70,17 @@ impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n+    ///\n+    /// WARNING: Any user code might:\n+    /// * Invalidate any slice bounds checks performed.\n+    /// * Change the address that this `Place` refers to.\n+    /// * Modify the memory that this place refers to.\n+    /// * Invalidate the memory that this place refers to, this will be caught\n+    ///   by borrow checking.\n+    ///\n+    /// Extra care is needed if any user code is allowed to run between calling\n+    /// this method and using it, as is the case for `match` and index\n+    /// expressions.\n     pub fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -83,7 +96,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr, Mutability::Mut)\n+        self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n \n     /// Compile `expr`, yielding a place that we can move from etc.\n@@ -114,14 +127,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr, Mutability::Not)\n+        self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n         mutability: Mutability,\n+        fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         debug!(\n             \"expr_as_place(block={:?}, expr={:?}, mutability={:?})\",\n@@ -137,63 +151,40 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 lint_level,\n                 value,\n             } => this.in_scope((region_scope, source_info), lint_level, |this| {\n-                if mutability == Mutability::Not {\n-                    this.as_read_only_place_builder(block, value)\n-                } else {\n-                    this.as_place_builder(block, value)\n-                }\n+                let value = this.hir.mirror(value);\n+                this.expr_as_place(block, value, mutability, fake_borrow_temps)\n             }),\n             ExprKind::Field { lhs, name } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n+                let lhs = this.hir.mirror(lhs);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    lhs,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, arg));\n+                let arg = this.hir.mirror(arg);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    arg,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => {\n-                let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n-\n-                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n-                // Making this a *fresh* temporary also means we do not have to worry about\n-                // the index changing later: Nothing will ever change this temporary.\n-                // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n-                let idx = unpack!(block = this.as_temp(\n+                this.lower_index_expression(\n                     block,\n-                    expr.temp_lifetime,\n+                    lhs,\n                     index,\n-                    Mutability::Not,\n-                ));\n-\n-                let slice = place_builder.clone().into_place(this.hir.tcx());\n-                // bounds check:\n-                let (len, lt) = (\n-                    this.temp(usize_ty.clone(), expr_span),\n-                    this.temp(bool_ty, expr_span),\n-                );\n-                this.cfg.push_assign(\n-                    block,\n-                    source_info, // len = len(slice)\n-                    &len,\n-                    Rvalue::Len(slice),\n-                );\n-                this.cfg.push_assign(\n-                    block,\n-                    source_info, // lt = idx < len\n-                    &lt,\n-                    Rvalue::BinaryOp(\n-                        BinOp::Lt,\n-                        Operand::Copy(Place::from(idx)),\n-                        Operand::Copy(len.clone()),\n-                    ),\n-                );\n-\n-                let msg = BoundsCheck {\n-                    len: Operand::Move(len),\n-                    index: Operand::Copy(Place::from(idx)),\n-                };\n-                let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n-                success.and(place_builder.index(idx))\n+                    mutability,\n+                    fake_borrow_temps,\n+                    expr.temp_lifetime,\n+                    expr_span,\n+                    source_info,\n+                )\n             }\n             ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n@@ -215,7 +206,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, source));\n+                let source = this.hir.mirror(source);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    source,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n                         CanonicalUserTypeAnnotation {\n@@ -309,4 +306,208 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// Lower an index expression\n+    ///\n+    /// This has two complications;\n+    ///\n+    /// * We need to do a bounds check.\n+    /// * We need to ensure that the bounds check can't be invalidated using an\n+    ///   expression like `x[1][{x = y; 2}]`. We use fake borrows here to ensure\n+    ///   that this is the case.\n+    fn lower_index_expression(\n+        &mut self,\n+        mut block: BasicBlock,\n+        base: ExprRef<'tcx>,\n+        index: ExprRef<'tcx>,\n+        mutability: Mutability,\n+        fake_borrow_temps: Option<&mut Vec<Local>>,\n+        temp_lifetime: Option<region::Scope>,\n+        expr_span: Span,\n+        source_info: SourceInfo\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let lhs = self.hir.mirror(base);\n+\n+        let base_fake_borrow_temps = &mut Vec::new();\n+        let is_outermost_index = fake_borrow_temps.is_none();\n+        let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n+\n+        let base_place = unpack!(block = self.expr_as_place(\n+            block,\n+            lhs,\n+            mutability,\n+            Some(fake_borrow_temps),\n+        ));\n+\n+        // Making this a *fresh* temporary means we do not have to worry about\n+        // the index changing later: Nothing will ever change this temporary.\n+        // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n+        let idx = unpack!(block = self.as_temp(\n+            block,\n+            temp_lifetime,\n+            index,\n+            Mutability::Not,\n+        ));\n+\n+        block = self.bounds_check(\n+            block,\n+            base_place.clone().into_place(self.hir.tcx()),\n+            idx,\n+            expr_span,\n+            source_info,\n+        );\n+\n+        if is_outermost_index {\n+            self.read_fake_borrows(block, fake_borrow_temps, source_info)\n+        } else {\n+            self.add_fake_borrows_of_base(\n+                &base_place,\n+                block,\n+                fake_borrow_temps,\n+                expr_span,\n+                source_info,\n+            );\n+        }\n+\n+        block.and(base_place.index(idx))\n+    }\n+\n+    fn bounds_check(\n+        &mut self,\n+        block: BasicBlock,\n+        slice: Place<'tcx>,\n+        index: Local,\n+        expr_span: Span,\n+        source_info: SourceInfo,\n+    ) -> BasicBlock {\n+        let usize_ty = self.hir.usize_ty();\n+        let bool_ty = self.hir.bool_ty();\n+        // bounds check:\n+        let len = self.temp(usize_ty, expr_span);\n+        let lt = self.temp(bool_ty, expr_span);\n+\n+        // len = len(slice)\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &len,\n+            Rvalue::Len(slice),\n+        );\n+        // lt = idx < len\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &lt,\n+            Rvalue::BinaryOp(\n+                BinOp::Lt,\n+                Operand::Copy(Place::from(index)),\n+                Operand::Copy(len.clone()),\n+            ),\n+        );\n+        let msg = BoundsCheck {\n+            len: Operand::Move(len),\n+            index: Operand::Copy(Place::from(index)),\n+        };\n+        // assert!(lt, \"...\")\n+        self.assert(block, Operand::Move(lt), true, msg, expr_span)\n+    }\n+\n+    fn add_fake_borrows_of_base(\n+        &mut self,\n+        base_place: &PlaceBuilder<'tcx>,\n+        block: BasicBlock,\n+        fake_borrow_temps: &mut Vec<Local>,\n+        expr_span: Span,\n+        source_info: SourceInfo,\n+    ) {\n+        let tcx = self.hir.tcx();\n+        let place_ty = Place::ty_from(\n+            &base_place.base,\n+            &base_place.projection,\n+            &self.local_decls,\n+            tcx,\n+        );\n+        if let ty::Slice(_) = place_ty.ty.kind {\n+            // We need to create fake borrows to ensure that the bounds\n+            // check that we just did stays valid. Since we can't assign to\n+            // unsized values, we only need to ensure that none of the\n+            // pointers in the base place are modified.\n+            for (idx, elem) in base_place.projection.iter().enumerate().rev() {\n+                match elem {\n+                    ProjectionElem::Deref => {\n+                        let fake_borrow_deref_ty = Place::ty_from(\n+                            &base_place.base,\n+                            &base_place.projection[..idx],\n+                            &self.local_decls,\n+                            tcx,\n+                        ).ty;\n+                        let fake_borrow_ty = tcx.mk_imm_ref(\n+                            tcx.lifetimes.re_erased,\n+                            fake_borrow_deref_ty,\n+                        );\n+                        let fake_borrow_temp = self.local_decls.push(\n+                            LocalDecl::new_temp(fake_borrow_ty, expr_span)\n+                        );\n+                        let projection = tcx.intern_place_elems(&base_place.projection[..idx]);\n+                        self.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            &fake_borrow_temp.into(),\n+                            Rvalue::Ref(\n+                                tcx.lifetimes.re_erased,\n+                                BorrowKind::Shallow,\n+                                Place {\n+                                    base: base_place.base.clone(),\n+                                    projection,\n+                                }\n+                            ),\n+                        );\n+                        fake_borrow_temps.push(fake_borrow_temp);\n+                    }\n+                    ProjectionElem::Index(_) => {\n+                        let index_ty = Place::ty_from(\n+                            &base_place.base,\n+                            &base_place.projection[..idx],\n+                            &self.local_decls,\n+                            tcx,\n+                        );\n+                        match index_ty.ty.kind {\n+                            // The previous index expression has already\n+                            // done any index expressions needed here.\n+                            ty::Slice(_) => break,\n+                            ty::Array(..) => (),\n+                            _ => bug!(\"unexpected index base\"),\n+                        }\n+                    }\n+                    ProjectionElem::Field(..)\n+                    | ProjectionElem::Downcast(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } => (),\n+                }\n+            }\n+        }\n+    }\n+\n+    fn read_fake_borrows(\n+        &mut self,\n+        block: BasicBlock,\n+        fake_borrow_temps: &mut Vec<Local>,\n+        source_info: SourceInfo,\n+    ) {\n+        // All indexes have been evaluated now, read all of the\n+        // fake borrows so that they are live across those index\n+        // expressions.\n+        for temp in fake_borrow_temps {\n+            self.cfg.push(\n+                block,\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::FakeRead(\n+                        FakeReadCause::ForIndex,\n+                        Box::new(Place::from(*temp)),\n+                    )\n+                }\n+            );\n+        }\n+    }\n }"}, {"sha": "f9b77a4b5dd2adcc52320aa57841ed895d013084", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 10, "deletions": 85, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,6 +1,5 @@\n //! See docs in `build/expr/mod.rs`.\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -9,11 +8,16 @@ use crate::hair::*;\n use rustc::middle::region;\n use rustc::mir::interpret::PanicInfo;\n use rustc::mir::*;\n-use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, UpvarSubsts};\n+use rustc::ty::{self, Ty, UpvarSubsts};\n use syntax_pos::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    /// See comment on `as_local_operand`\n+    /// Returns an rvalue suitable for use until the end of the current\n+    /// scope expression.\n+    ///\n+    /// The operand returned from this function will *not be valid* after\n+    /// an ExprKind::Scope is passed, so please do *not* return it from\n+    /// functions to avoid bad miscompiles.\n     pub fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -23,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(\n+    fn as_rvalue<M>(\n         &mut self,\n         block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -66,16 +70,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n-            ExprKind::Borrow {\n-                borrow_kind,\n-                arg,\n-            } => {\n-                let arg_place = match borrow_kind {\n-                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n-                    _ => unpack!(block = this.as_place(block, arg)),\n-                };\n-                block.and(Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place))\n-            }\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n                 let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n@@ -256,77 +250,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))\n             }\n-            ExprKind::Adt {\n-                adt_def,\n-                variant_index,\n-                substs,\n-                user_ty,\n-                fields,\n-                base,\n-            } => {\n-                // see (*) above\n-                let is_union = adt_def.is_union();\n-                let active_field_index = if is_union {\n-                    Some(fields[0].name.index())\n-                } else {\n-                    None\n-                };\n-\n-                // first process the set of fields that were provided\n-                // (evaluating them in order given by user)\n-                let fields_map: FxHashMap<_, _> = fields\n-                    .into_iter()\n-                    .map(|f| {\n-                        (\n-                            f.name,\n-                            unpack!(block = this.as_operand(block, scope, f.expr)),\n-                        )\n-                    }).collect();\n-\n-                let field_names = this.hir.all_fields(adt_def, variant_index);\n-\n-                let fields = if let Some(FruInfo { base, field_types }) = base {\n-                    let base = unpack!(block = this.as_place(block, base));\n-\n-                    // MIR does not natively support FRU, so for each\n-                    // base-supplied field, generate an operand that\n-                    // reads it from the base.\n-                    field_names\n-                        .into_iter()\n-                        .zip(field_types.into_iter())\n-                        .map(|(n, ty)| match fields_map.get(&n) {\n-                            Some(v) => v.clone(),\n-                            None => this.consume_by_copy_or_move(this.hir.tcx().mk_place_field(\n-                                base.clone(),\n-                                n,\n-                                ty,\n-                            )),\n-                        })\n-                        .collect()\n-                } else {\n-                    field_names\n-                        .iter()\n-                        .filter_map(|n| fields_map.get(n).cloned())\n-                        .collect()\n-                };\n-\n-                let inferred_ty = expr.ty;\n-                let user_ty = user_ty.map(|ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span: source_info.span,\n-                        user_ty: ty,\n-                        inferred_ty,\n-                    })\n-                });\n-                let adt = box AggregateKind::Adt(\n-                    adt_def,\n-                    variant_index,\n-                    substs,\n-                    user_ty,\n-                    active_field_index,\n-                );\n-                block.and(Rvalue::Aggregate(adt, fields))\n-            }\n             ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n                 block = unpack!(this.stmt_expr(block, expr, None));\n                 block.and(this.unit_rvalue())\n@@ -351,6 +274,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n+            | ExprKind::Borrow { .. }\n+            | ExprKind::Adt { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::LogicalOp { .. }\n             | ExprKind::Call { .. }"}, {"sha": "ae5289986e77cc537ccdef36cbca6e615950a892", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -48,19 +48,19 @@ impl Category {\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n+            | ExprKind::Adt { .. }\n+            | ExprKind::Borrow { .. }\n             | ExprKind::Call { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n \n             ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n-            | ExprKind::Adt { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Unary { .. }\n             | ExprKind::Binary { .. }\n             | ExprKind::Box { .. }\n             | ExprKind::Cast { .. }\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n-            | ExprKind::Borrow { .. }\n             | ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n             | ExprKind::Yield { .. }"}, {"sha": "404ca3204e6c0038ade679a506ecea8215c1ea78", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 101, "deletions": 6, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,7 +4,9 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n use rustc::mir::*;\n-use rustc::ty;\n+use rustc::ty::{self, CanonicalUserTypeAnnotation};\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::symbol::sym;\n \n use rustc_target::spec::abi::Abi;\n \n@@ -200,16 +202,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     ty::FnDef(def_id, _) => {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n-                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                            Some(this.hir.tcx().item_name(def_id))\n                         } else {\n                             None\n                         }\n                     }\n                     _ => None,\n                 };\n-                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n-                if intrinsic == Some(\"move_val_init\") {\n+                if let Some(sym::move_val_init) = intrinsic {\n                     // `move_val_init` has \"magic\" semantics - the second argument is\n                     // always evaluated \"directly\" into the first one.\n \n@@ -271,6 +272,102 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Use { source } => {\n                 this.into(destination, block, source)\n             }\n+            ExprKind::Borrow { arg, borrow_kind } => {\n+                // We don't do this in `as_rvalue` because we use `as_place`\n+                // for borrow expressions, so we cannot create an `RValue` that\n+                // remains valid across user code. `as_rvalue` is usually called\n+                // by this method anyway, so this shouldn't cause too many\n+                // unnecessary temporaries.\n+                let arg_place = match borrow_kind {\n+                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n+                    _ => unpack!(block = this.as_place(block, arg)),\n+                };\n+                let borrow = Rvalue::Ref(\n+                    this.hir.tcx().lifetimes.re_erased,\n+                    borrow_kind,\n+                    arg_place,\n+                );\n+                this.cfg.push_assign(block, source_info, destination, borrow);\n+                block.unit()\n+            }\n+            ExprKind::Adt {\n+                adt_def,\n+                variant_index,\n+                substs,\n+                user_ty,\n+                fields,\n+                base,\n+            } => {\n+                // See the notes for `ExprKind::Array` in `as_rvalue` and for\n+                // `ExprKind::Borrow` above.\n+                let is_union = adt_def.is_union();\n+                let active_field_index = if is_union {\n+                    Some(fields[0].name.index())\n+                } else {\n+                    None\n+                };\n+\n+                let scope =  this.local_scope();\n+\n+                // first process the set of fields that were provided\n+                // (evaluating them in order given by user)\n+                let fields_map: FxHashMap<_, _> = fields\n+                    .into_iter()\n+                    .map(|f| {\n+                        (\n+                            f.name,\n+                            unpack!(block = this.as_operand(block, scope, f.expr)),\n+                        )\n+                    }).collect();\n+\n+                let field_names = this.hir.all_fields(adt_def, variant_index);\n+\n+                let fields = if let Some(FruInfo { base, field_types }) = base {\n+                    let base = unpack!(block = this.as_place(block, base));\n+\n+                    // MIR does not natively support FRU, so for each\n+                    // base-supplied field, generate an operand that\n+                    // reads it from the base.\n+                    field_names\n+                        .into_iter()\n+                        .zip(field_types.into_iter())\n+                        .map(|(n, ty)| match fields_map.get(&n) {\n+                            Some(v) => v.clone(),\n+                            None => this.consume_by_copy_or_move(\n+                                this.hir.tcx().mk_place_field(base.clone(), n, ty),\n+                            ),\n+                        }).collect()\n+                } else {\n+                    field_names\n+                        .iter()\n+                        .filter_map(|n| fields_map.get(n).cloned())\n+                        .collect()\n+                };\n+\n+                let inferred_ty = expr.ty;\n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+                        span: source_info.span,\n+                        user_ty: ty,\n+                        inferred_ty,\n+                    })\n+                });\n+                let adt = box AggregateKind::Adt(\n+                    adt_def,\n+                    variant_index,\n+                    substs,\n+                    user_ty,\n+                    active_field_index,\n+                );\n+                this.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    destination,\n+                    Rvalue::Aggregate(adt, fields)\n+                );\n+                block.unit()\n+            }\n+\n \n             // These cases don't actually need a destination\n             ExprKind::Assign { .. }\n@@ -325,10 +422,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Cast { .. }\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n-            | ExprKind::Borrow { .. }\n             | ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n-            | ExprKind::Adt { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n             | ExprKind::Yield { .. } => {"}, {"sha": "fb605bb2b557b9e5defd21e5d4bedcc832ff41e1", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -30,17 +30,22 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n         Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n-        | Node::Item(hir::Item { kind: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n+        | Node::Item(\n+            hir::Item {\n+                kind: hir::ItemKind::Fn(hir::FnSig { decl, .. }, _, body_id),\n+                ..\n+            }\n+        )\n         | Node::ImplItem(\n             hir::ImplItem {\n-                kind: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, body_id),\n+                kind: hir::ImplItemKind::Method(hir::FnSig { decl, .. }, body_id),\n                 ..\n             }\n         )\n         | Node::TraitItem(\n             hir::TraitItem {\n                 kind: hir::TraitItemKind::Method(\n-                    hir::MethodSig { decl, .. },\n+                    hir::FnSig { decl, .. },\n                     hir::TraitMethod::Provided(body_id),\n                 ),\n                 ..\n@@ -576,7 +581,7 @@ where\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                     debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                        if bm == ty::BindByValue(hir::MutMutable) {\n+                        if bm == ty::BindByValue(hir::Mutability::Mutable) {\n                             mutability = Mutability::Mut;\n                         } else {\n                             mutability = Mutability::Not;"}, {"sha": "707ad1511826a67751d9cc8ceedb0bc0954e05b6", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -118,7 +118,7 @@ fn op_to_const<'tcx>(\n                     0,\n                 ),\n             };\n-            let len = b.to_usize(&ecx.tcx.tcx).unwrap();\n+            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n             let start = start.try_into().unwrap();\n             let len: usize = len.try_into().unwrap();\n             ConstValue::Slice {"}, {"sha": "b9e75a576cad877ba5c03b27488e29fb2ad2f75a", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -45,10 +45,7 @@ crate fn lit_to_const<'tcx>(\n             trunc(n as u128)?\n         },\n         LitKind::Int(n, _) => trunc(n)?,\n-        LitKind::Float(n, fty) => {\n-            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n-        }\n-        LitKind::FloatUnsuffixed(n) => {\n+        LitKind::Float(n, _) => {\n             let fty = match ty.kind {\n                 ty::Float(fty) => fty,\n                 _ => bug!()"}, {"sha": "2ff690b7ccc9f179a76f6d1f5c570cb408eee9c1", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -628,6 +628,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             let cast = if cx.tables().is_coercion_cast(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n+            } else if cx.tables().expr_ty(source).is_region_ptr() {\n+                // Special cased so that we can type check that the element\n+                // type of the source matches the pointed to type of the\n+                // destination.\n+                ExprKind::Pointer { source: source.to_ref(), cast: PointerCast::ArrayToPointer }\n             } else {\n                 // check whether this is casting an enum variant discriminant\n                 // to prevent cycles, we refer to the discriminant initializer\n@@ -855,8 +860,8 @@ impl ToBorrowKind for AutoBorrowMutability {\n impl ToBorrowKind for hir::Mutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n         match *self {\n-            hir::MutMutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n-            hir::MutImmutable => BorrowKind::Shared,\n+            hir::Mutability::Mutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n+            hir::Mutability::Immutable => BorrowKind::Shared,\n         }\n     }\n }\n@@ -1008,7 +1013,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::MutImmutable,\n+                                                               mutbl: hir::Mutability::Immutable,\n                                                            });\n                         Expr {\n                             ty: closure_ty,\n@@ -1029,7 +1034,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::MutMutable,\n+                                                               mutbl: hir::Mutability::Mutable,\n                                                            });\n                         Expr {\n                             ty: closure_ty,"}, {"sha": "b43042f2b17457b0a9b773c9a29d51f9de2185de", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -257,7 +257,7 @@ pub enum ExprKind<'tcx> {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n         upvars: Vec<ExprRef<'tcx>>,\n-        movability: Option<hir::GeneratorMovability>,\n+        movability: Option<hir::Movability>,\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,"}, {"sha": "982330baf9c9568cc386b2b5adce11befa4c3dbd", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 344, "deletions": 249, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -586,8 +586,10 @@ enum Constructor<'tcx> {\n     ConstantValue(&'tcx ty::Const<'tcx>, Span),\n     /// Ranges of literal values (`2..=5` and `2..5`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n-    /// Array patterns of length n.\n-    Slice(u64),\n+    /// Array patterns of length `n`.\n+    FixedLenSlice(u64),\n+    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n+    VarLenSlice(u64, u64),\n }\n \n // Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n@@ -601,7 +603,11 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n                 Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n                 Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n             ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n-            (Constructor::Slice(a), Constructor::Slice(b)) => a == b,\n+            (Constructor::FixedLenSlice(a), Constructor::FixedLenSlice(b)) => a == b,\n+            (\n+                Constructor::VarLenSlice(a_prefix, a_suffix),\n+                Constructor::VarLenSlice(b_prefix, b_suffix),\n+            ) => a_prefix == b_prefix && a_suffix == b_suffix,\n             _ => false,\n         }\n     }\n@@ -610,7 +616,7 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            Slice { .. } => true,\n+            FixedLenSlice { .. } | VarLenSlice { .. } => true,\n             _ => false,\n         }\n     }\n@@ -644,7 +650,8 @@ impl<'tcx> Constructor<'tcx> {\n                     ty::Const::from_bits(tcx, *hi, ty),\n                 )\n             }\n-            Constructor::Slice(val) => format!(\"[{}]\", val),\n+            Constructor::FixedLenSlice(val) => format!(\"[{}]\", val),\n+            Constructor::VarLenSlice(prefix, suffix) => format!(\"[{}, .., {}]\", prefix, suffix),\n             _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n         }\n     }\n@@ -657,44 +664,183 @@ impl<'tcx> Constructor<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         other_ctors: &Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n-        let mut refined_ctors = vec![self.clone()];\n-        for other_ctor in other_ctors {\n-            if other_ctor == self {\n-                // If a constructor appears in a `match` arm, we can\n-                // eliminate it straight away.\n-                refined_ctors = vec![]\n-            } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, other_ctor) {\n-                // Refine the required constructors for the type by subtracting\n-                // the range defined by the current constructor pattern.\n-                refined_ctors = interval.subtract_from(tcx, param_env, refined_ctors);\n+        match *self {\n+            // Those constructors can only match themselves.\n+            Single | Variant(_) => {\n+                if other_ctors.iter().any(|c| c == self) {\n+                    vec![]\n+                } else {\n+                    vec![self.clone()]\n+                }\n+            }\n+            FixedLenSlice(self_len) => {\n+                let overlaps = |c: &Constructor<'_>| match *c {\n+                    FixedLenSlice(other_len) => other_len == self_len,\n+                    VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n+                    _ => false,\n+                };\n+                if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n             }\n+            VarLenSlice(..) => {\n+                let mut remaining_ctors = vec![self.clone()];\n+\n+                // For each used ctor, subtract from the current set of constructors.\n+                // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+                // Remember, `VarLenSlice(i, j)` covers the union of `FixedLenSlice` from\n+                // `i + j` to infinity.\n+                for neg_ctor in other_ctors {\n+                    remaining_ctors = remaining_ctors\n+                        .into_iter()\n+                        .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n+                            // Compute `pos_ctor \\ neg_ctor`.\n+                            match (&pos_ctor, neg_ctor) {\n+                                (&FixedLenSlice(pos_len), &VarLenSlice(neg_prefix, neg_suffix)) => {\n+                                    let neg_len = neg_prefix + neg_suffix;\n+                                    if neg_len <= pos_len {\n+                                        smallvec![]\n+                                    } else {\n+                                        smallvec![pos_ctor]\n+                                    }\n+                                }\n+                                (\n+                                    &VarLenSlice(pos_prefix, pos_suffix),\n+                                    &VarLenSlice(neg_prefix, neg_suffix),\n+                                ) => {\n+                                    let neg_len = neg_prefix + neg_suffix;\n+                                    let pos_len = pos_prefix + pos_suffix;\n+                                    if neg_len <= pos_len {\n+                                        smallvec![]\n+                                    } else {\n+                                        (pos_len..neg_len).map(FixedLenSlice).collect()\n+                                    }\n+                                }\n+                                (&VarLenSlice(pos_prefix, pos_suffix), &FixedLenSlice(neg_len)) => {\n+                                    let pos_len = pos_prefix + pos_suffix;\n+                                    if neg_len < pos_len {\n+                                        smallvec![pos_ctor]\n+                                    } else {\n+                                        (pos_len..neg_len)\n+                                            .map(FixedLenSlice)\n+                                            // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n+                                            .chain(Some(VarLenSlice(\n+                                                neg_len + 1 - pos_suffix,\n+                                                pos_suffix,\n+                                            )))\n+                                            .collect()\n+                                    }\n+                                }\n+                                _ if pos_ctor == *neg_ctor => smallvec![],\n+                                _ => smallvec![pos_ctor],\n+                            }\n+                        })\n+                        .collect();\n+\n+                    // If the constructors that have been considered so far already cover\n+                    // the entire range of `self`, no need to look at more constructors.\n+                    if remaining_ctors.is_empty() {\n+                        break;\n+                    }\n+                }\n \n-            // If the constructor patterns that have been considered so far\n-            // already cover the entire range of values, then we know the\n-            // constructor is not missing, and we can move on to the next one.\n-            if refined_ctors.is_empty() {\n-                break;\n+                remaining_ctors\n             }\n-        }\n+            ConstantRange(..) | ConstantValue(..) => {\n+                let mut remaining_ctors = vec![self.clone()];\n+                for other_ctor in other_ctors {\n+                    if other_ctor == self {\n+                        // If a constructor appears in a `match` arm, we can\n+                        // eliminate it straight away.\n+                        remaining_ctors = vec![]\n+                    } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, other_ctor) {\n+                        // Refine the required constructors for the type by subtracting\n+                        // the range defined by the current constructor pattern.\n+                        remaining_ctors = interval.subtract_from(tcx, param_env, remaining_ctors);\n+                    }\n \n-        // If a constructor has not been matched, then it is missing.\n-        // We add `refined_ctors` instead of `self`, because then we can\n-        // provide more detailed error information about precisely which\n-        // ranges have been omitted.\n-        refined_ctors\n+                    // If the constructor patterns that have been considered so far\n+                    // already cover the entire range of values, then we know the\n+                    // constructor is not missing, and we can move on to the next one.\n+                    if remaining_ctors.is_empty() {\n+                        break;\n+                    }\n+                }\n+\n+                // If a constructor has not been matched, then it is missing.\n+                // We add `remaining_ctors` instead of `self`, because then we can\n+                // provide more detailed error information about precisely which\n+                // ranges have been omitted.\n+                remaining_ctors\n+            }\n+        }\n     }\n \n     /// This returns one wildcard pattern for each argument to this constructor.\n     fn wildcard_subpatterns<'a>(\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> impl Iterator<Item = Pat<'tcx>> + DoubleEndedIterator {\n-        constructor_sub_pattern_tys(cx, self, ty).into_iter().map(|ty| Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: box PatKind::Wild,\n-        })\n+    ) -> Vec<Pat<'tcx>> {\n+        debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n+        match ty.kind {\n+            ty::Tuple(ref fs) => {\n+                fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n+            }\n+            ty::Slice(ty) | ty::Array(ty, _) => match *self {\n+                FixedLenSlice(length) => (0..length).map(|_| Pat::wildcard_from_ty(ty)).collect(),\n+                VarLenSlice(prefix, suffix) => {\n+                    (0..prefix + suffix).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+                }\n+                ConstantValue(..) => vec![],\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n+            ty::Adt(adt, substs) => {\n+                if adt.is_box() {\n+                    // Use T as the sub pattern type of Box<T>.\n+                    vec![Pat::wildcard_from_ty(substs.type_at(0))]\n+                } else {\n+                    let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n+                    let is_non_exhaustive =\n+                        variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                    variant\n+                        .fields\n+                        .iter()\n+                        .map(|field| {\n+                            let is_visible =\n+                                adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                            let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                            match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                                // Treat all uninhabited types in non-exhaustive variants as\n+                                // `TyErr`.\n+                                (_, true, true) => cx.tcx.types.err,\n+                                // Treat all non-visible fields as `TyErr`. They can't appear in\n+                                // any other pattern from this match (because they are private), so\n+                                // their type does not matter - but we don't want to know they are\n+                                // uninhabited.\n+                                (false, ..) => cx.tcx.types.err,\n+                                (true, ..) => {\n+                                    let ty = field.ty(cx.tcx, substs);\n+                                    match ty.kind {\n+                                        // If the field type returned is an array of an unknown\n+                                        // size return an TyErr.\n+                                        ty::Array(_, len)\n+                                            if len\n+                                                .try_eval_usize(cx.tcx, cx.param_env)\n+                                                .is_none() =>\n+                                        {\n+                                            cx.tcx.types.err\n+                                        }\n+                                        _ => ty,\n+                                    }\n+                                }\n+                            }\n+                        })\n+                        .map(Pat::wildcard_from_ty)\n+                        .collect()\n+                }\n+            }\n+            _ => vec![],\n+        }\n     }\n \n     /// This computes the arity of a constructor. The arity of a constructor\n@@ -707,7 +853,8 @@ impl<'tcx> Constructor<'tcx> {\n         match ty.kind {\n             ty::Tuple(ref fs) => fs.len() as u64,\n             ty::Slice(..) | ty::Array(..) => match *self {\n-                Slice(length) => length,\n+                FixedLenSlice(length) => length,\n+                VarLenSlice(prefix, suffix) => prefix + suffix,\n                 ConstantValue(..) => 0,\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n@@ -764,9 +911,18 @@ impl<'tcx> Constructor<'tcx> {\n \n             ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n \n-            ty::Slice(_) | ty::Array(..) => {\n-                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-            }\n+            ty::Slice(_) | ty::Array(..) => match self {\n+                FixedLenSlice(_) => {\n+                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+                }\n+                VarLenSlice(prefix_len, _suffix_len) => {\n+                    let prefix = subpatterns.by_ref().take(*prefix_len as usize).collect();\n+                    let suffix = subpatterns.collect();\n+                    let wild = Pat::wildcard_from_ty(ty);\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                }\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n \n             _ => match *self {\n                 ConstantValue(value, _) => PatKind::Constant { value },\n@@ -784,7 +940,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Like `apply`, but where all the subpatterns are wildcards `_`.\n     fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n-        let subpatterns = self.wildcard_subpatterns(cx, ty).rev();\n+        let subpatterns = self.wildcard_subpatterns(cx, ty).into_iter().rev();\n         self.apply(cx, ty, subpatterns)\n     }\n }\n@@ -831,7 +987,7 @@ impl<'tcx> Usefulness<'tcx> {\n     fn apply_wildcard(self, ty: Ty<'tcx>) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let wild = Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+                let wild = Pat::wildcard_from_ty(ty);\n                 UsefulWithWitness(\n                     witnesses\n                         .into_iter()\n@@ -884,7 +1040,6 @@ pub enum WitnessPreference {\n #[derive(Copy, Clone, Debug)]\n struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n-    max_slice_length: u64,\n     span: Span,\n }\n \n@@ -980,14 +1135,14 @@ fn all_constructors<'a, 'tcx>(\n             .collect(),\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![Slice(len)] }\n+            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![FixedLenSlice(len)] }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n-                vec![Slice(0)]\n+                vec![FixedLenSlice(0)]\n             } else {\n-                (0..pcx.max_slice_length + 1).map(|length| Slice(length)).collect()\n+                vec![VarLenSlice(0, 0)]\n             }\n         }\n         ty::Adt(def, substs) if def.is_enum() => def\n@@ -1042,108 +1197,6 @@ fn all_constructors<'a, 'tcx>(\n     ctors\n }\n \n-fn max_slice_length<'p, 'a, 'tcx, I>(cx: &mut MatchCheckCtxt<'a, 'tcx>, patterns: I) -> u64\n-where\n-    I: Iterator<Item = &'p Pat<'tcx>>,\n-    'tcx: 'p,\n-{\n-    // The exhaustiveness-checking paper does not include any details on\n-    // checking variable-length slice patterns. However, they are matched\n-    // by an infinite collection of fixed-length array patterns.\n-    //\n-    // Checking the infinite set directly would take an infinite amount\n-    // of time. However, it turns out that for each finite set of\n-    // patterns `P`, all sufficiently large array lengths are equivalent:\n-    //\n-    // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n-    // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n-    // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n-    // the same subset of `P`.\n-    //\n-    // Because of that, each witness for reachability-checking from one\n-    // of the sufficiently-large lengths can be transformed to an\n-    // equally-valid witness from any other length, so we only have\n-    // to check slice lengths from the \"minimal sufficiently-large length\"\n-    // and below.\n-    //\n-    // Note that the fact that there is a *single* `s\u2098` for each `m`\n-    // not depending on the specific pattern in `P` is important: if\n-    // you look at the pair of patterns\n-    //     `[true, ..]`\n-    //     `[.., false]`\n-    // Then any slice of length \u22651 that matches one of these two\n-    // patterns can be trivially turned to a slice of any\n-    // other length \u22651 that matches them and vice-versa - for\n-    // but the slice from length 2 `[false, true]` that matches neither\n-    // of these patterns can't be turned to a slice from length 1 that\n-    // matches neither of these patterns, so we have to consider\n-    // slices from length 2 there.\n-    //\n-    // Now, to see that that length exists and find it, observe that slice\n-    // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n-    // \"variable-length\" patterns (`[_, .., _]`).\n-    //\n-    // For fixed-length patterns, all slices with lengths *longer* than\n-    // the pattern's length have the same outcome (of not matching), so\n-    // as long as `L` is greater than the pattern's length we can pick\n-    // any `s\u2098` from that length and get the same result.\n-    //\n-    // For variable-length patterns, the situation is more complicated,\n-    // because as seen above the precise value of `s\u2098` matters.\n-    //\n-    // However, for each variable-length pattern `p` with a prefix of length\n-    // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n-    // `sl\u209a` elements are examined.\n-    //\n-    // Therefore, as long as `L` is positive (to avoid concerns about empty\n-    // types), all elements after the maximum prefix length and before\n-    // the maximum suffix length are not examined by any variable-length\n-    // pattern, and therefore can be added/removed without affecting\n-    // them - creating equivalent patterns from any sufficiently-large\n-    // length.\n-    //\n-    // Of course, if fixed-length patterns exist, we must be sure\n-    // that our length is large enough to miss them all, so\n-    // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n-    //\n-    // for example, with the above pair of patterns, all elements\n-    // but the first and last can be added/removed, so any\n-    // witness of length \u22652 (say, `[false, false, true]`) can be\n-    // turned to a witness from any other length \u22652.\n-\n-    let mut max_prefix_len = 0;\n-    let mut max_suffix_len = 0;\n-    let mut max_fixed_len = 0;\n-\n-    for row in patterns {\n-        match *row.kind {\n-            PatKind::Constant { value } => {\n-                // extract the length of an array/slice from a constant\n-                match (value.val, &value.ty.kind) {\n-                    (_, ty::Array(_, n)) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, n.eval_usize(cx.tcx, cx.param_env))\n-                    }\n-                    (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n-                let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n-                max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n-            }\n-            PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n-                max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n-                max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n-}\n-\n /// An inclusive interval, used for precise integer exhaustiveness checking.\n /// `IntRange`s always store a contiguous range. This means that values are\n /// encoded such that `0` encodes the minimum value for the integer,\n@@ -1508,20 +1561,19 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n         ty,\n-        max_slice_length: max_slice_length(cx, matrix.heads().chain(Some(v.head()))),\n         span,\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    if let Some(constructors) = pat_constructors(cx, v.head(), pcx) {\n-        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n+    if let Some(constructor) = pat_constructor(cx, v.head(), pcx) {\n+        debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         split_grouped_constructors(\n             cx.tcx,\n             cx.param_env,\n-            constructors,\n+            pcx,\n+            vec![constructor],\n             matrix,\n-            pcx.ty,\n             pcx.span,\n             Some(hir_id),\n         )\n@@ -1533,7 +1585,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         debug!(\"is_useful - expanding wildcard\");\n \n         let used_ctors: Vec<Constructor<'_>> =\n-            matrix.heads().flat_map(|p| pat_constructors(cx, p, pcx).unwrap_or(vec![])).collect();\n+            matrix.heads().filter_map(|p| pat_constructor(cx, p, pcx)).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -1583,19 +1635,13 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n             let (all_ctors, _) = missing_ctors.into_inner();\n-            split_grouped_constructors(\n-                cx.tcx,\n-                cx.param_env,\n-                all_ctors,\n-                matrix,\n-                pcx.ty,\n-                DUMMY_SP,\n-                None,\n-            )\n-            .into_iter()\n-            .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id))\n-            .find(|result| result.is_useful())\n-            .unwrap_or(NotUseful)\n+            split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n+                .into_iter()\n+                .map(|c| {\n+                    is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id)\n+                })\n+                .find(|result| result.is_useful())\n+                .unwrap_or(NotUseful)\n         } else {\n             let matrix = matrix.specialize_wildcard();\n             let v = v.to_tail();\n@@ -1673,7 +1719,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty).collect();\n+    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty);\n     let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n     v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n@@ -1682,44 +1728,39 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n         .unwrap_or(NotUseful)\n }\n \n-/// Determines the constructors that the given pattern can be specialized to.\n-///\n-/// In most cases, there's only one constructor that a specific pattern\n-/// represents, such as a specific enum variant or a specific literal value.\n-/// Slice patterns, however, can match slices of different lengths. For instance,\n-/// `[a, b, tail @ ..]` can match a slice of length 2, 3, 4 and so on.\n-///\n+/// Determines the constructor that the given pattern can be specialized to.\n /// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(\n+fn pat_constructor<'tcx>(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     pat: &Pat<'tcx>,\n     pcx: PatCtxt<'tcx>,\n-) -> Option<Vec<Constructor<'tcx>>> {\n+) -> Option<Constructor<'tcx>> {\n     match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructors(cx, subpattern, pcx),\n+        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructor(cx, subpattern, pcx),\n         PatKind::Binding { .. } | PatKind::Wild => None,\n-        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(vec![Single]),\n+        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(Single),\n         PatKind::Variant { adt_def, variant_index, .. } => {\n-            Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n+            Some(Variant(adt_def.variants[variant_index].def_id))\n         }\n-        PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n-        PatKind::Range(PatRange { lo, hi, end }) => Some(vec![ConstantRange(\n+        PatKind::Constant { value } => Some(ConstantValue(value, pat.span)),\n+        PatKind::Range(PatRange { lo, hi, end }) => Some(ConstantRange(\n             lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n             hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n             lo.ty,\n             end,\n             pat.span,\n-        )]),\n+        )),\n         PatKind::Array { .. } => match pcx.ty.kind {\n-            ty::Array(_, length) => Some(vec![Slice(length.eval_usize(cx.tcx, cx.param_env))]),\n+            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(cx.tcx, cx.param_env))),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty),\n         },\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() as u64 + suffix.len() as u64;\n+            let prefix = prefix.len() as u64;\n+            let suffix = suffix.len() as u64;\n             if slice.is_some() {\n-                Some((pat_len..pcx.max_slice_length + 1).map(Slice).collect())\n+                Some(VarLenSlice(prefix, suffix))\n             } else {\n-                Some(vec![Slice(pat_len)])\n+                Some(FixedLenSlice(prefix + suffix))\n             }\n         }\n         PatKind::Or { .. } => {\n@@ -1728,68 +1769,6 @@ fn pat_constructors<'tcx>(\n     }\n }\n \n-/// This computes the types of the sub patterns that a constructor should be\n-/// expanded to.\n-///\n-/// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n-fn constructor_sub_pattern_tys<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Vec<Ty<'tcx>> {\n-    debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n-    match ty.kind {\n-        ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n-        ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n-            Slice(length) => (0..length).map(|_| ty).collect(),\n-            ConstantValue(..) => vec![],\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n-        },\n-        ty::Ref(_, rty, _) => vec![rty],\n-        ty::Adt(adt, substs) => {\n-            if adt.is_box() {\n-                // Use T as the sub pattern type of Box<T>.\n-                vec![substs.type_at(0)]\n-            } else {\n-                let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n-                let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                variant\n-                    .fields\n-                    .iter()\n-                    .map(|field| {\n-                        let is_visible =\n-                            adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                        let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                        match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                            // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n-                            (_, true, true) => cx.tcx.types.err,\n-                            // Treat all non-visible fields as `TyErr`. They can't appear in any\n-                            // other pattern from this match (because they are private), so their\n-                            // type does not matter - but we don't want to know they are\n-                            // uninhabited.\n-                            (false, ..) => cx.tcx.types.err,\n-                            (true, ..) => {\n-                                let ty = field.ty(cx.tcx, substs);\n-                                match ty.kind {\n-                                    // If the field type returned is an array of an unknown size\n-                                    // return an TyErr.\n-                                    ty::Array(_, len)\n-                                        if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                    {\n-                                        cx.tcx.types.err\n-                                    }\n-                                    _ => ty,\n-                                }\n-                            }\n-                        }\n-                    })\n-                    .collect()\n-            }\n-        }\n-        _ => vec![],\n-    }\n-}\n-\n // checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n // meaning all other types will compare unequal and thus equal patterns often do not cause the\n // second pattern to lint about unreachable match arms.\n@@ -1900,21 +1879,22 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n ///\n /// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n /// ranges that case.\n+///\n+/// This also splits variable-length slices into fixed-length slices.\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     matrix: &Matrix<'p, 'tcx>,\n-    ty: Ty<'tcx>,\n     span: Span,\n     hir_id: Option<HirId>,\n ) -> Vec<Constructor<'tcx>> {\n+    let ty = pcx.ty;\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n-            // special-case constant ranges.\n             ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n                 // We only care about finding all the subranges within the range of the constructor\n                 // range. Anything else is irrelevant, because it is guaranteed to result in\n@@ -1996,6 +1976,121 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n+            VarLenSlice(self_prefix, self_suffix) => {\n+                // The exhaustiveness-checking paper does not include any details on\n+                // checking variable-length slice patterns. However, they are matched\n+                // by an infinite collection of fixed-length array patterns.\n+                //\n+                // Checking the infinite set directly would take an infinite amount\n+                // of time. However, it turns out that for each finite set of\n+                // patterns `P`, all sufficiently large array lengths are equivalent:\n+                //\n+                // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+                // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+                // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+                // the same subset of `P`.\n+                //\n+                // Because of that, each witness for reachability-checking from one\n+                // of the sufficiently-large lengths can be transformed to an\n+                // equally-valid witness from any other length, so we only have\n+                // to check slice lengths from the \"minimal sufficiently-large length\"\n+                // and below.\n+                //\n+                // Note that the fact that there is a *single* `s\u2098` for each `m`\n+                // not depending on the specific pattern in `P` is important: if\n+                // you look at the pair of patterns\n+                //     `[true, ..]`\n+                //     `[.., false]`\n+                // Then any slice of length \u22651 that matches one of these two\n+                // patterns can be trivially turned to a slice of any\n+                // other length \u22651 that matches them and vice-versa - for\n+                // but the slice from length 2 `[false, true]` that matches neither\n+                // of these patterns can't be turned to a slice from length 1 that\n+                // matches neither of these patterns, so we have to consider\n+                // slices from length 2 there.\n+                //\n+                // Now, to see that that length exists and find it, observe that slice\n+                // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+                // \"variable-length\" patterns (`[_, .., _]`).\n+                //\n+                // For fixed-length patterns, all slices with lengths *longer* than\n+                // the pattern's length have the same outcome (of not matching), so\n+                // as long as `L` is greater than the pattern's length we can pick\n+                // any `s\u2098` from that length and get the same result.\n+                //\n+                // For variable-length patterns, the situation is more complicated,\n+                // because as seen above the precise value of `s\u2098` matters.\n+                //\n+                // However, for each variable-length pattern `p` with a prefix of length\n+                // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+                // `sl\u209a` elements are examined.\n+                //\n+                // Therefore, as long as `L` is positive (to avoid concerns about empty\n+                // types), all elements after the maximum prefix length and before\n+                // the maximum suffix length are not examined by any variable-length\n+                // pattern, and therefore can be added/removed without affecting\n+                // them - creating equivalent patterns from any sufficiently-large\n+                // length.\n+                //\n+                // Of course, if fixed-length patterns exist, we must be sure\n+                // that our length is large enough to miss them all, so\n+                // we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n+                //\n+                // for example, with the above pair of patterns, all elements\n+                // but the first and last can be added/removed, so any\n+                // witness of length \u22652 (say, `[false, false, true]`) can be\n+                // turned to a witness from any other length \u22652.\n+\n+                let mut max_prefix_len = self_prefix;\n+                let mut max_suffix_len = self_suffix;\n+                let mut max_fixed_len = 0;\n+\n+                for row in matrix.heads() {\n+                    match *row.kind {\n+                        PatKind::Constant { value } => {\n+                            // extract the length of an array/slice from a constant\n+                            match (value.val, &value.ty.kind) {\n+                                (_, ty::Array(_, n)) => {\n+                                    max_fixed_len =\n+                                        cmp::max(max_fixed_len, n.eval_usize(tcx, param_env))\n+                                }\n+                                (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n+                                    max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                        PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                            let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n+                            max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n+                        }\n+                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                            max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n+                            max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                // For diagnostics, we keep the prefix and suffix lengths separate, so in the case\n+                // where `max_fixed_len + 1` is the largest, we adapt `max_prefix_len` accordingly,\n+                // so that `L = max_prefix_len + max_suffix_len`.\n+                if max_fixed_len + 1 >= max_prefix_len + max_suffix_len {\n+                    // The subtraction can't overflow thanks to the above check.\n+                    // The new `max_prefix_len` is also guaranteed to be larger than its previous\n+                    // value.\n+                    max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n+                }\n+\n+                // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n+                // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n+                // are treated independently as fixed-lengths slices, and lengths above are\n+                // captured by a final VarLenSlice constructor.\n+                split_ctors.extend(\n+                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLenSlice),\n+                );\n+                split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+            }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),\n         }\n@@ -2238,7 +2333,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            Slice(..) => {\n+            FixedLenSlice(..) | VarLenSlice(..) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}, {"sha": "ffb3ae44ae1e95a16238459b74d429b73ead8755", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::{self, Pat};\n \n use std::slice;\n \n-use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n+use syntax_pos::{MultiSpan, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -351,7 +351,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if bm != ty::BindByValue(hir::MutImmutable) {\n+                if bm != ty::BindByValue(hir::Mutability::Immutable) {\n                     // Nothing to check.\n                     return true;\n                 }\n@@ -491,7 +491,7 @@ fn check_not_useful(\n     matrix: &Matrix<'_, 'tcx>,\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+    let wild_pattern = super::Pat::wildcard_from_ty(ty);\n     match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n@@ -548,7 +548,7 @@ fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n }\n \n fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n-    format!(\"pattern{} {} not covered\", rustc_errors::pluralise!(witnesses.len()), joined_patterns)\n+    format!(\"pattern{} {} not covered\", rustc_errors::pluralize!(witnesses.len()), joined_patterns)\n }\n \n /// Point at the definition of non-covered `enum` variants."}, {"sha": "f613f6f4b99b90a840fb19fe03cbd44adc0bb8f3", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,7 +26,7 @@ use rustc_index::vec::Idx;\n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone, Debug)]\n pub enum PatternError {\n@@ -55,6 +55,11 @@ pub struct Pat<'tcx> {\n     pub kind: Box<PatKind<'tcx>>,\n }\n \n+impl<'tcx> Pat<'tcx> {\n+    pub(crate) fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n+    }\n+}\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct PatTyProj<'tcx> {\n@@ -293,10 +298,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 match self.ty.kind {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n-                        write!(f, \"&\")?;\n-                        if mutbl == hir::MutMutable {\n-                            write!(f, \"mut \")?;\n-                        }\n+                        write!(f, \"&{}\", mutbl.prefix_str())?;\n                     }\n                     _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n                 }\n@@ -594,14 +596,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n-                    ty::BindByValue(hir::MutMutable) =>\n+                    ty::BindByValue(hir::Mutability::Mutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),\n-                    ty::BindByValue(hir::MutImmutable) =>\n+                    ty::BindByValue(hir::Mutability::Immutable) =>\n                         (Mutability::Not, BindingMode::ByValue),\n-                    ty::BindByReference(hir::MutMutable) =>\n+                    ty::BindByReference(hir::Mutability::Mutable) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Mut { allow_two_phase_borrow: false })),\n-                    ty::BindByReference(hir::MutImmutable) =>\n+                    ty::BindByReference(hir::Mutability::Immutable) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Shared)),\n                 };"}, {"sha": "1fb8b3ca63fcf228739a3729a12603888a24f27b", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,7 +26,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.unsize_into(src, dest)?;\n             }\n \n-            Misc | Pointer(PointerCast::MutToConstPointer) => {\n+            Misc\n+            | Pointer(PointerCast::MutToConstPointer)\n+            | Pointer(PointerCast::ArrayToPointer) => {\n                 let src = self.read_immediate(src)?;\n                 let res = self.cast_immediate(src, dest.layout)?;\n                 self.write_immediate(res, dest)?;\n@@ -260,7 +262,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n-                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Immediate::new_slice(\n                     ptr,\n@@ -279,7 +281,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n-                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar()?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable);\n                 self.write_immediate(val, dest)\n             }"}, {"sha": "8e901068a8d26f78176b343d7788ffac6a02b6f2", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -447,7 +447,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len = metadata.expect(\"slice fat ptr must have vtable\").to_usize(self)?;\n+                let len = metadata.expect(\"slice fat ptr must have length\").to_machine_usize(self)?;\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big."}, {"sha": "68bb0a3e435df1c386b5bfe37d08e2bd58c5eace", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -192,20 +192,18 @@ for\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Handle trait object vtables\n-            if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n-                        referenced_ty, self.ecx.param_env).kind\n-                {\n-                    if let Ok(vtable) = meta.unwrap().to_ptr() {\n-                        // explitly choose `Immutable` here, since vtables are immutable, even\n-                        // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n-                    }\n+            if let ty::Dynamic(..) =\n+                self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                    referenced_ty, self.ecx.param_env).kind\n+            {\n+                if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n+                    // explitly choose `Immutable` here, since vtables are immutable, even\n+                    // if the reference of the fat pointer is mutable\n+                    self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                 }\n             }\n-            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n@@ -216,21 +214,21 @@ for\n                 // const qualification enforces it. We can lift it in the future.\n                 match (self.mode, mutability) {\n                     // immutable references are fine everywhere\n-                    (_, hir::Mutability::MutImmutable) => {},\n+                    (_, hir::Mutability::Immutable) => {},\n                     // all is \"good and well\" in the unsoundness of `static mut`\n \n                     // mutable references are ok in `static`. Either they are treated as immutable\n                     // because they are behind an immutable one, or they are behind an `UnsafeCell`\n                     // and thus ok.\n-                    (InternMode::Static, hir::Mutability::MutMutable) => {},\n+                    (InternMode::Static, hir::Mutability::Mutable) => {},\n                     // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase, hir::Mutability::MutMutable) |\n-                    (InternMode::Const, hir::Mutability::MutMutable) => {\n+                    (InternMode::ConstBase, hir::Mutability::Mutable) |\n+                    (InternMode::Const, hir::Mutability::Mutable) => {\n                         match referenced_ty.kind {\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n-                                if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n+                                if mplace.meta.unwrap().to_machine_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n                         }\n                     },\n@@ -243,7 +241,7 @@ for\n                     // If there's an immutable reference or we are inside a static, then our\n                     // mutable reference is equivalent to an immutable one. As an example:\n                     // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                    (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n+                    (Mutability::Mutable, hir::Mutability::Mutable) => Mutability::Mutable,\n                     _ => Mutability::Immutable,\n                 };\n                 // Recursing behind references changes the intern mode for constants in order to\n@@ -275,9 +273,9 @@ pub fn intern_const_alloc_recursive(\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match place_mut {\n-        Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n+        Some(hir::Mutability::Immutable) => (Mutability::Immutable, InternMode::Static),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n+        Some(hir::Mutability::Mutable) => (Mutability::Mutable, InternMode::Static),\n         // consts, promoteds. FIXME: what about array lengths, array initializers?\n         None => (Mutability::Immutable, InternMode::ConstBase),\n     };"}, {"sha": "39f10d8e6045dfeb7a731eeefb4b3344eced17a7", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -95,10 +95,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n \n-        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n+        let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n         match intrinsic_name {\n             \"caller_location\" => {\n-                let caller = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n+                let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+                let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n                 let location = self.alloc_caller_location(\n                     Symbol::intern(&caller.file.name.to_string()),\n                     caller.line as u32,\n@@ -262,8 +263,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see the Miri code, `src/operator.rs`).\n                 if a.is_bits() && b.is_bits() {\n-                    let a = a.to_usize(self)?;\n-                    let b = b.to_usize(self)?;\n+                    let a = a.to_machine_usize(self)?;\n+                    let b = b.to_machine_usize(self)?;\n                     if a == b && a != 0 {\n                         self.write_scalar(Scalar::from_int(0, isize_layout.size), dest)?;\n                         return Ok(true);"}, {"sha": "88bfcd63129fa9759fa27e9bab358e109438cc23", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -37,7 +37,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let col_out = self.force_ptr(self.mplace_field(location, 2)?.ptr)?;\n \n         let layout = &self.tcx.data_layout;\n-        let alloc = self.memory.get_mut(file_ptr_out.alloc_id)?;\n+        // We just allocated this, so we can skip the bounds checks.\n+        let alloc = self.memory.get_raw_mut(file_ptr_out.alloc_id)?;\n \n         alloc.write_scalar(layout, file_ptr_out, file.into(), ptr_size)?;\n         alloc.write_scalar(layout, file_len_out, file_len.into(), ptr_size)?;"}, {"sha": "e929b0855834e98a2e3834ae8f147bf18993eeb6", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -210,7 +210,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, kind);\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => self.get(ptr.alloc_id)?.size,\n+            None => self.get_raw(ptr.alloc_id)?.size,\n         };\n         self.copy(\n             ptr,\n@@ -314,16 +314,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         align: Align,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let align = if M::CHECK_ALIGN { Some(align) } else { None };\n-        self.check_ptr_access_align(sptr, size, align)\n+        self.check_ptr_access_align(sptr, size, align, CheckInAllocMsg::MemoryAccessTest)\n     }\n \n     /// Like `check_ptr_access`, but *definitely* checks alignment when `align`\n-    /// is `Some` (overriding `M::CHECK_ALIGN`).\n-    pub(super) fn check_ptr_access_align(\n+    /// is `Some` (overriding `M::CHECK_ALIGN`). Also lets the caller control\n+    /// the error message for the out-of-bounds case.\n+    pub fn check_ptr_access_align(\n         &self,\n         sptr: Scalar<M::PointerTag>,\n         size: Size,\n         align: Option<Align>,\n+        msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n             if offset % align.bytes() == 0 {\n@@ -368,7 +370,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_inbounds_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                end_ptr.check_inbounds_alloc(allocation_size, msg)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -478,7 +480,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ).0)\n     }\n \n-    pub fn get(\n+    /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n+    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCtx` instead!\n+    pub fn get_raw(\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n@@ -511,7 +515,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_mut(\n+    /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n+    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCtx` instead!\n+    pub fn get_raw_mut(\n         &mut self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n@@ -553,7 +559,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n         // # Regular allocations\n-        // Don't use `self.get` here as that will\n+        // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a static's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n@@ -625,7 +631,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_mut(id)?.mutability = Mutability::Immutable;\n+        self.get_raw_mut(id)?.mutability = Mutability::Immutable;\n         Ok(())\n     }\n \n@@ -774,15 +780,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(ptr) => ptr,\n             None => return Ok(&[]), // zero-sized access\n         };\n-        self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n+        self.get_raw(ptr.alloc_id)?.get_bytes(self, ptr, size)\n     }\n \n     /// Reads a 0-terminated sequence of bytes from memory. Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n     pub fn read_c_str(&self, ptr: Scalar<M::PointerTag>) -> InterpResult<'tcx, &[u8]> {\n         let ptr = self.force_ptr(ptr)?; // We need to read at least 1 byte, so we *need* a ptr.\n-        self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n+        self.get_raw(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n     /// Writes the given stream of bytes into memory.\n@@ -802,7 +808,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             None => return Ok(()), // zero-sized access\n         };\n         let tcx = self.tcx.tcx;\n-        self.get_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n+        self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n     }\n \n     /// Expects the caller to have checked bounds and alignment.\n@@ -830,16 +836,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_undef_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations = self.get(src.alloc_id)?\n+        let relocations = self.get_raw(src.alloc_id)?\n             .prepare_relocation_copy(self, src, size, dest, length);\n \n         let tcx = self.tcx.tcx;\n \n         // This checks relocation edges on the src.\n-        let src_bytes = self.get(src.alloc_id)?\n+        let src_bytes = self.get_raw(src.alloc_id)?\n             .get_bytes_with_undef_and_ptr(&tcx, src, size)?\n             .as_ptr();\n-        let dest_bytes = self.get_mut(dest.alloc_id)?\n+        let dest_bytes = self.get_raw_mut(dest.alloc_id)?\n             .get_bytes_mut(&tcx, dest, size * length)?\n             .as_mut_ptr();\n \n@@ -878,7 +884,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // copy definedness to the destination\n         self.copy_undef_mask(src, dest, size, length)?;\n         // copy the relocations to the destination\n-        self.get_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n+        self.get_raw_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n \n         Ok(())\n     }\n@@ -897,11 +903,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let src_alloc = self.get(src.alloc_id)?;\n+        let src_alloc = self.get_raw(src.alloc_id)?;\n         let compressed = src_alloc.compress_undef_range(src, size);\n \n         // now fill in all the data\n-        let dest_allocation = self.get_mut(dest.alloc_id)?;\n+        let dest_allocation = self.get_raw_mut(dest.alloc_id)?;\n         dest_allocation.mark_compressed_undef_range(&compressed, dest, size, repeat);\n \n         Ok(())\n@@ -913,7 +919,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         match scalar {\n             Scalar::Ptr(ptr) => Ok(ptr),\n-            _ => M::int_to_ptr(&self, scalar.to_usize(self)?)\n+            _ => M::int_to_ptr(&self, scalar.to_machine_usize(self)?)\n         }\n     }\n "}, {"sha": "79762b87b0a8502e9f6291e7fac4f7181ad125ce", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -82,26 +82,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n             Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n         }\n     }\n-\n-    /// Converts the immediate into a pointer (or a pointer-sized integer).\n-    /// Throws away the second half of a ScalarPair!\n-    #[inline]\n-    pub fn to_scalar_ptr(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        match self {\n-            Immediate::Scalar(ptr) |\n-            Immediate::ScalarPair(ptr, _) => ptr.not_undef(),\n-        }\n-    }\n-\n-    /// Converts the value into its metadata.\n-    /// Throws away the first half of a ScalarPair!\n-    #[inline]\n-    pub fn to_meta(self) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n-        Ok(match self {\n-            Immediate::Scalar(_) => None,\n-            Immediate::ScalarPair(_, meta) => Some(meta.not_undef()?),\n-        })\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -268,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory\n-                    .get(ptr.alloc_id)?\n+                    .get_raw(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(ImmTy {\n                     imm: scalar.into(),\n@@ -286,10 +266,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n                 let b_ptr = ptr.offset(b_offset, self)?;\n                 let a_val = self.memory\n-                    .get(ptr.alloc_id)?\n+                    .get_raw(ptr.alloc_id)?\n                     .read_scalar(self, a_ptr, a_size)?;\n                 let b_val = self.memory\n-                    .get(ptr.alloc_id)?\n+                    .get_raw(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n                 Ok(Some(ImmTy {\n                     imm: Immediate::ScalarPair(a_val, b_val),"}, {"sha": "0bd47edc046602d50dcdf3081b3453bd13c80248", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -195,7 +195,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind {\n                 ty::Slice(..) | ty::Str =>\n-                    return self.mplace.meta.unwrap().to_usize(cx),\n+                    return self.mplace.meta.unwrap().to_machine_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -287,17 +287,23 @@ where\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n+        let pointee_type = val.layout.ty.builtin_deref(true)\n+            .expect(\"`ref_to_mplace` called on non-ptr type\")\n+            .ty;\n         let layout = self.layout_of(pointee_type)?;\n+        let (ptr, meta) = match *val {\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n+            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+        };\n \n         let mplace = MemPlace {\n-            ptr: val.to_scalar_ptr()?,\n+            ptr,\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n             // alignment can only be more restrictive.\n             align: layout.align.abi,\n-            meta: val.to_meta()?,\n+            meta,\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n@@ -802,7 +808,7 @@ where\n                     _ => bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                             dest.layout)\n                 }\n-                self.memory.get_mut(ptr.alloc_id)?.write_scalar(\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n                     tcx, ptr, scalar, dest.layout.size\n                 )\n             }\n@@ -824,10 +830,10 @@ where\n                 // fields do not match the `ScalarPair` components.\n \n                 self.memory\n-                    .get_mut(ptr.alloc_id)?\n+                    .get_raw_mut(ptr.alloc_id)?\n                     .write_scalar(tcx, ptr, a_val, a_size)?;\n                 self.memory\n-                    .get_mut(b_ptr.alloc_id)?\n+                    .get_raw_mut(b_ptr.alloc_id)?\n                     .write_scalar(tcx, b_ptr, b_val, b_size)\n             }\n         }"}, {"sha": "1df98f079cc104957575686d85cba453074f803d", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -392,7 +392,7 @@ impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n     for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n {\n     fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n-        self.get(*id).ok()\n+        self.get_raw(*id).ok()\n     }\n }\n "}, {"sha": "e10bb85d52df8b97b29806e63d60d979562417ce", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -445,7 +445,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ptr_size,\n                     self.tcx.data_layout.pointer_align.abi,\n                 )?.expect(\"cannot be a ZST\");\n-                let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n+                let fn_ptr = self.memory.get_raw(vtable_slot.alloc_id)?\n                     .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n                 let drop_fn = self.memory.get_fn(fn_ptr)?;\n "}, {"sha": "c15425321ec0123a249ae2be1ce3c4a0ce2d8762", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -63,35 +63,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let drop = Instance::resolve_drop_in_place(*tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n-        // no need to do any alignment checks on the memory accesses below, because we know the\n+        // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n-        self.memory\n-            .get_mut(vtable.alloc_id)?\n-            .write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n-\n-        let size_ptr = vtable.offset(ptr_size, self)?;\n-        self.memory\n-            .get_mut(size_ptr.alloc_id)?\n-            .write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, self)?;\n-        self.memory\n-            .get_mut(align_ptr.alloc_id)?\n-            .write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n+        let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n+        vtable_alloc.write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n+\n+        let size_ptr = vtable.offset(ptr_size, tcx)?;\n+        vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n+        let align_ptr = vtable.offset(ptr_size * 2, tcx)?;\n+        vtable_alloc.write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n                 let instance = ty::Instance::resolve_for_vtable(\n-                    *self.tcx,\n+                    *tcx,\n                     self.param_env,\n                     def_id,\n                     substs,\n                 ).ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n-                self.memory\n-                    .get_mut(method_ptr.alloc_id)?\n+                // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n+                self.memory.get_raw_mut(vtable.alloc_id)?\n                     .write_ptr_sized(tcx, method_ptr, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n@@ -114,7 +109,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.tcx.data_layout.pointer_align.abi,\n         )?.expect(\"cannot be a ZST\");\n         let drop_fn = self.memory\n-            .get(vtable.alloc_id)?\n+            .get_raw(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n             .not_undef()?;\n         // We *need* an instance here, no other kind of function value, to be able\n@@ -140,7 +135,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             3*pointer_size,\n             self.tcx.data_layout.pointer_align.abi,\n         )?.expect(\"cannot be a ZST\");\n-        let alloc = self.memory.get(vtable.alloc_id)?;\n+        let alloc = self.memory.get_raw(vtable.alloc_id)?;\n         let size = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size, self)?"}, {"sha": "d698b2e8d8f80d42f1d5fbb468eb824b2cdc7bd0", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::fx::FxHashSet;\n use std::hash::Hash;\n \n use super::{\n-    GlobalAlloc, InterpResult,\n+    GlobalAlloc, InterpResult, CheckInAllocMsg,\n     Scalar, OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n@@ -282,7 +282,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                 // FIXME: More checks for the vtable.\n             }\n             ty::Slice(..) | ty::Str => {\n-                let _len = try_validation!(meta.unwrap().to_usize(self.ecx),\n+                let _len = try_validation!(meta.unwrap().to_machine_usize(self.ecx),\n                     \"non-integer slice length in wide pointer\", self.path);\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n@@ -388,49 +388,41 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                // Check pointer part.\n-                if self.ref_tracking_for_consts.is_some() {\n-                    // Integers/floats in CTFE: For consistency with integers, we do not\n-                    // accept undef.\n-                    let _ptr = try_validation!(value.to_scalar_ptr(),\n-                        \"undefined address in raw pointer\", self.path);\n-                } else {\n-                    // Remain consistent with `usize`: Accept anything.\n-                }\n-\n-                // Check metadata.\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                // We are conservative with undef for integers, but try to\n+                // actually enforce our current rules for raw pointers.\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle wide pointers.\n                 // Check metadata early, for better diagnostics\n-                let ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", self.path);\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n                 // Make sure this is dereferencable and all.\n-                let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n+                let (size, align) = self.ecx.size_and_align_of(place.meta, place.layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n-                    .unwrap_or_else(|| (layout.size, layout.align.abi));\n+                    .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n                 let ptr: Option<_> = match\n-                    self.ecx.memory.check_ptr_access_align(ptr, size, Some(align))\n+                    self.ecx.memory.check_ptr_access_align(\n+                        place.ptr,\n+                        size,\n+                        Some(align),\n+                        CheckInAllocMsg::InboundsTest,\n+                    )\n                 {\n                     Ok(ptr) => ptr,\n                     Err(err) => {\n                         info!(\n                             \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                            ptr, size, align\n+                            place.ptr, size, align\n                         );\n                         match err.kind {\n                             err_unsup!(InvalidNullPointerUsage) =>\n@@ -454,7 +446,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 };\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n-                    let place = self.ecx.ref_to_mplace(value)?;\n                     if let Some(ptr) = ptr { // not a ZST\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n@@ -595,6 +586,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     _ => false,\n                 }\n             } => {\n+                // Optimized handling for arrays of integer/float type.\n+\n                 // bailing out for zsts is ok, since the array element type can only be int/float\n                 if op.layout.is_zst() {\n                     return Ok(());\n@@ -614,6 +607,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n \n+                // This is the optimization: we just check the entire range at once.\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n                 // In run-time mode, we accept pointers in here.  This is actually more\n@@ -622,8 +616,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n-                // We also accept undef, for consistency with the type-based checks.\n-                match self.ecx.memory.get(ptr.alloc_id)?.check_bytes(\n+                // We also accept undef, for consistency with the slow path.\n+                match self.ecx.memory.get_raw(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,\n                     size,"}, {"sha": "be3bbf46f1c76067029c3bc92e113126b4f6479c", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,6 +26,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(associated_type_bounds)]\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n+#![feature(bool_to_option)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "49cdd9142345dbfe49b8ae17a91ea4e555834814", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1071,7 +1071,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.kind {\n-            hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n+            hir::ImplItemKind::Method(hir::FnSig { .. }, _) => {\n                 let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n                 self.push_if_root(def_id);\n             }"}, {"sha": "2913d6e59eb3f21e7b17703b38c09175ab2b1920", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -456,7 +456,7 @@ impl CloneShimBuilder<'tcx> {\n             Mutability::Not,\n             tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                 ty,\n-                mutbl: hir::Mutability::MutImmutable,\n+                mutbl: hir::Mutability::Immutable,\n             })\n         );\n \n@@ -736,7 +736,7 @@ fn build_call_shim<'tcx>(\n                 Mutability::Not,\n                 tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n-                    mutbl: hir::Mutability::MutMutable\n+                    mutbl: hir::Mutability::Mutable\n                 }),\n                 span\n             ));"}, {"sha": "a5b711e75a603e01535d1bde8c7d74bfe312be10", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -82,8 +82,8 @@ impl ConstKind {\n \n             HirKind::Const => ConstKind::Const,\n \n-            HirKind::Static(hir::MutImmutable) => ConstKind::Static,\n-            HirKind::Static(hir::MutMutable) => ConstKind::StaticMut,\n+            HirKind::Static(hir::Mutability::Immutable) => ConstKind::Static,\n+            HirKind::Static(hir::Mutability::Mutable) => ConstKind::StaticMut,\n         };\n \n         Some(mode)"}, {"sha": "496a56790679b41d922570682f157f1e6b91bb01", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -123,7 +123,7 @@ pub trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = QualifSet(bits).contains::<Self>();\n "}, {"sha": "e29239a4536c27e169a2c497cfda9ebebc0dd76c", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::cast::CastTy;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n-use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n+use rustc::lint::builtin::{SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n@@ -208,23 +208,20 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n             PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n                 if self.tcx.is_mutable_static(def_id) {\n-                    self.require_unsafe(\"use of mutable static\",\n+                    self.require_unsafe(\n+                        \"use of mutable static\",\n                         \"mutable statics can be mutated by multiple threads: aliasing \\\n-                         violations or data races will cause undefined behavior\",\n-                         UnsafetyViolationKind::General);\n+                        violations or data races will cause undefined behavior\",\n+                        UnsafetyViolationKind::General,\n+                    );\n                 } else if self.tcx.is_foreign_item(def_id) {\n-                    let source_info = self.source_info;\n-                    let lint_root =\n-                        self.source_scope_local_data[source_info.scope].lint_root;\n-                    self.register_violations(&[UnsafetyViolation {\n-                        source_info,\n-                        description: Symbol::intern(\"use of extern static\"),\n-                        details: Symbol::intern(\n-                            \"extern statics are not controlled by the Rust type system: \\\n-                            invalid data, aliasing violations or data races will cause \\\n-                            undefined behavior\"),\n-                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                    }], &[]);\n+                    self.require_unsafe(\n+                        \"use of extern static\",\n+                        \"extern statics are not controlled by the Rust type system: \\\n+                        invalid data, aliasing violations or data races will cause \\\n+                        undefined behavior\",\n+                        UnsafetyViolationKind::General,\n+                    );\n                 }\n             }\n         }\n@@ -351,8 +348,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                     match violation.kind {\n                         UnsafetyViolationKind::GeneralAndConstFn |\n                         UnsafetyViolationKind::General => {},\n-                        UnsafetyViolationKind::BorrowPacked(_) |\n-                        UnsafetyViolationKind::ExternStatic(_) => if self.min_const_fn {\n+                        UnsafetyViolationKind::BorrowPacked(_) => if self.min_const_fn {\n                             // const fns don't need to be backwards compatible and can\n                             // emit these violations as a hard error instead of a backwards\n                             // compat lint\n@@ -380,8 +376,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                             UnsafetyViolationKind::GeneralAndConstFn => {},\n                             // these things are forbidden in const fns\n                             UnsafetyViolationKind::General |\n-                            UnsafetyViolationKind::BorrowPacked(_) |\n-                            UnsafetyViolationKind::ExternStatic(_) => {\n+                            UnsafetyViolationKind::BorrowPacked(_) => {\n                                 let mut violation = violation.clone();\n                                 // const fns don't need to be backwards compatible and can\n                                 // emit these violations as a hard error instead of a backwards\n@@ -576,10 +571,10 @@ fn is_enclosed(\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n-            kind: hir::ItemKind::Fn(_, header, _, _),\n+            kind: hir::ItemKind::Fn(ref sig, _, _),\n             ..\n         })) = tcx.hir().find(parent_id) {\n-            match header.unsafety {\n+            match sig.header.unsafety {\n                 hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n                 hir::Unsafety::Normal => None,\n             }\n@@ -642,18 +637,10 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                 struct_span_err!(\n                     tcx.sess, source_info.span, E0133,\n                     \"{} is unsafe and requires unsafe function or block\", description)\n-                    .span_label(source_info.span, &description.as_str()[..])\n-                    .note(&details.as_str()[..])\n+                    .span_label(source_info.span, &*description.as_str())\n+                    .note(&details.as_str())\n                     .emit();\n             }\n-            UnsafetyViolationKind::ExternStatic(lint_hir_id) => {\n-                tcx.lint_node_note(SAFE_EXTERN_STATICS,\n-                              lint_hir_id,\n-                              source_info.span,\n-                              &format!(\"{} is unsafe and requires unsafe function or block \\\n-                                        (error E0133)\", &description.as_str()[..]),\n-                              &details.as_str()[..]);\n-            }\n             UnsafetyViolationKind::BorrowPacked(lint_hir_id) => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n                     tcx.unsafe_derive_on_repr_packed(impl_def_id);\n@@ -662,8 +649,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                                   lint_hir_id,\n                                   source_info.span,\n                                   &format!(\"{} is unsafe and requires unsafe function or block \\\n-                                            (error E0133)\", &description.as_str()[..]),\n-                                  &details.as_str()[..]);\n+                                            (error E0133)\", description),\n+                                  &details.as_str());\n                 }\n             }\n         }"}, {"sha": "a0d04bd593212ff828d3ee3462f863b45a4fe2f2", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n     StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n-    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n+    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock, RETURN_PLACE,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -25,6 +25,7 @@ use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n+use crate::rustc::ty::subst::Subst;\n use crate::interpret::{\n     self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n     StackPopCleanup, LocalValue, LocalState, AllocId, Frame,\n@@ -269,6 +270,7 @@ struct ConstPropagator<'mir, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    ret: Option<OpTy<'tcx, ()>>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -308,11 +310,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n         let can_const_prop = CanConstProp::check(body);\n \n+        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n+\n+        let ret =\n+            ecx\n+                .layout_of(body.return_ty().subst(tcx, substs))\n+                .ok()\n+                // Don't bother allocating memory for ZST types which have no values.\n+                .filter(|ret_layout| !ret_layout.is_zst())\n+                .map(|ret_layout| ecx.allocate(ret_layout, MemoryKind::Stack));\n+\n         ecx.push_stack_frame(\n-            Instance::new(def_id, &InternalSubsts::identity_for_item(tcx, def_id)),\n+            Instance::new(def_id, substs),\n             span,\n             dummy_body,\n-            None,\n+            ret.map(Into::into),\n             StackPopCleanup::None {\n                 cleanup: false,\n             },\n@@ -327,6 +339,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             source_scope_local_data,\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n+            ret: ret.map(Into::into),\n         }\n     }\n \n@@ -335,6 +348,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n+        if local == RETURN_PLACE {\n+            // Try to read the return place as an immediate so that if it is representable as a\n+            // scalar, we can handle it as such, but otherwise, just return the value as is.\n+            return match self.ret.map(|ret| self.ecx.try_read_immediate(ret)) {\n+                Some(Ok(Ok(imm))) => Some(imm.into()),\n+                _ => self.ret,\n+            };\n+        }\n+\n         self.ecx.access_local(self.ecx.frame(), local, None).ok()\n     }\n \n@@ -643,7 +665,8 @@ impl CanConstProp {\n             //        lint for x != y\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n-            *val = body.local_kind(local) == LocalKind::Temp;\n+            let local_kind = body.local_kind(local);\n+            *val = local_kind == LocalKind::Temp || local_kind == LocalKind::ReturnPointer;\n \n             if !*val {\n                 trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n@@ -731,7 +754,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             }\n                         } else {\n                             trace!(\"can't propagate into {:?}\", local);\n-                            self.remove_const(local);\n+                            if local != RETURN_PLACE {\n+                                self.remove_const(local);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "37c239001a505f429a486a662fd11598a9078429", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -392,7 +392,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n \n     let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut {\n         ty: gen_ty,\n-        mutbl: hir::MutMutable\n+        mutbl: hir::Mutability::Mutable\n     });\n \n     // Replace the by value generator argument\n@@ -977,7 +977,7 @@ fn create_generator_drop_shim<'tcx>(\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n-            mutbl: hir::Mutability::MutMutable,\n+            mutbl: hir::Mutability::Mutable,\n         }),\n         user_ty: UserTypeProjections::none(),\n         name: None,\n@@ -1192,7 +1192,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n                 (substs.upvar_tys(def_id, tcx).collect(),\n                  substs.witness(def_id, tcx),\n                  substs.discr_ty(tcx),\n-                 movability == hir::GeneratorMovability::Movable)\n+                 movability == hir::Movability::Movable)\n             }\n             _ => bug!(),\n         };"}, {"sha": "02ed12eda67a2ad4d071e5fcd09d2931bb1aafec", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -36,6 +36,7 @@ pub mod const_prop;\n pub mod generator;\n pub mod inline;\n pub mod uniform_array_move_out;\n+pub mod uninhabited_enum_branching;\n \n pub(crate) fn provide(providers: &mut Providers<'_>) {\n     self::qualify_consts::provide(providers);\n@@ -210,13 +211,14 @@ fn mir_validated(\n     }\n \n     let mut body = tcx.mir_const(def_id).steal();\n-    let qualify_and_promote_pass = qualify_consts::QualifyAndPromoteConstants::default();\n+    let promote_pass = promote_consts::PromoteTemps::default();\n     run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        &qualify_and_promote_pass,\n+        &qualify_consts::QualifyAndPromoteConstants::default(),\n+        &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n-    let promoted = qualify_and_promote_pass.promoted.into_inner();\n+    let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n@@ -257,6 +259,8 @@ fn run_optimization_passes<'tcx>(\n \n \n         // Optimizations begin.\n+        &uninhabited_enum_branching::UninhabitedEnumBranching,\n+        &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n         &uniform_array_move_out::RestoreSubsliceArrayMoveOut::new(tcx),\n         &inline::Inline,\n "}, {"sha": "48a58f1d0ee57a9adcfa37ebfdcc248fde334084", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 140, "deletions": 2, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -17,20 +17,76 @@ use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, List, TyCtxt};\n+use rustc::ty::{self, List, TyCtxt, TypeFoldable};\n use rustc::ty::subst::InternalSubsts;\n use rustc::ty::cast::CastTy;\n use syntax::ast::LitKind;\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_index::vec::{IndexVec, Idx};\n+use rustc_index::bit_set::HybridBitSet;\n use rustc_target::spec::abi::Abi;\n \n+use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::transform::{MirPass, MirSource};\n use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn};\n \n+/// A `MirPass` for promotion.\n+///\n+/// In this case, \"promotion\" entails the following:\n+/// - Extract promotable temps in `fn` and `const fn` into their own MIR bodies.\n+/// - Extend lifetimes in `const` and `static` by removing `Drop` and `StorageDead`.\n+/// - Emit errors if the requirements of `#[rustc_args_required_const]` are not met.\n+///\n+/// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n+/// newly created `StaticKind::Promoted`.\n+#[derive(Default)]\n+pub struct PromoteTemps<'tcx> {\n+    pub promoted_fragments: Cell<IndexVec<Promoted, Body<'tcx>>>,\n+}\n+\n+impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        // There's not really any point in promoting errorful MIR.\n+        //\n+        // This does not include MIR that failed const-checking, which we still try to promote.\n+        if body.return_ty().references_error() {\n+            tcx.sess.delay_span_bug(body.span, \"PromoteTemps: MIR had errors\");\n+            return;\n+        }\n+\n+        if src.promoted.is_some() {\n+            return;\n+        }\n+\n+        let def_id = src.def_id();\n+\n+        let item = Item::new(tcx, def_id, body);\n+        let mut rpo = traversal::reverse_postorder(body);\n+        let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+\n+        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+\n+        // For now, lifetime extension is done in `const` and `static`s without creating promoted\n+        // MIR fragments by removing `Drop` and `StorageDead` for each referent. However, this will\n+        // not work inside loops when they are allowed in `const`s.\n+        //\n+        // FIXME: use promoted MIR fragments everywhere?\n+        let promoted_fragments = if should_create_promoted_mir_fragments(item.const_kind) {\n+            promote_candidates(def_id, body, tcx, temps, promotable_candidates)\n+        } else {\n+            // FIXME: promote const array initializers in consts.\n+            remove_drop_and_storage_dead_on_promoted_locals(tcx, body, &promotable_candidates);\n+            IndexVec::new()\n+        };\n+\n+        self.promoted_fragments.set(promoted_fragments);\n+    }\n+}\n+\n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TempState {\n@@ -199,6 +255,8 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                             bb: location.block,\n                             index: 2,\n                         });\n+\n+                        return; // Don't double count `simd_shuffle` candidates\n                     }\n                 }\n \n@@ -536,7 +594,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         // is gone - we can always promote constants even if they\n                         // fail to pass const-checking, as compilation would've\n                         // errored independently and promotion can't change that.\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n                         if bits == super::qualify_consts::QUALIF_ERROR_BIT {\n                             self.tcx.sess.delay_span_bug(\n                                 constant.span,\n@@ -1152,3 +1210,83 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n             should_promote={:?} feature_flag={:?}\", mir_def_id, should_promote, feature_flag);\n     should_promote && !feature_flag\n }\n+\n+fn should_create_promoted_mir_fragments(const_kind: Option<ConstKind>) -> bool {\n+    match const_kind {\n+        Some(ConstKind::ConstFn) | None => true,\n+        Some(ConstKind::Const) | Some(ConstKind::Static) | Some(ConstKind::StaticMut) => false,\n+    }\n+}\n+\n+/// In `const` and `static` everything without `StorageDead`\n+/// is `'static`, we don't have to create promoted MIR fragments,\n+/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+fn remove_drop_and_storage_dead_on_promoted_locals(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    promotable_candidates: &[Candidate],\n+) {\n+    debug!(\"run_pass: promotable_candidates={:?}\", promotable_candidates);\n+\n+    // Removing `StorageDead` will cause errors for temps declared inside a loop body. For now we\n+    // simply skip promotion if a loop exists, since loops are not yet allowed in a `const`.\n+    //\n+    // FIXME: Just create MIR fragments for `const`s instead of using this hackish approach?\n+    if body.is_cfg_cyclic() {\n+        tcx.sess.delay_span_bug(body.span, \"Control-flow cycle detected in `const`\");\n+        return;\n+    }\n+\n+    // The underlying local for promotion contexts like `&temp` and `&(temp.proj)`.\n+    let mut requires_lifetime_extension = HybridBitSet::new_empty(body.local_decls.len());\n+\n+    promotable_candidates\n+        .iter()\n+        .filter_map(|c| {\n+            match c {\n+                Candidate::Ref(loc) => Some(loc),\n+                Candidate::Repeat(_) | Candidate::Argument { .. } => None,\n+            }\n+        })\n+        .map(|&Location { block, statement_index }| {\n+            // FIXME: store the `Local` for each `Candidate` when it is created.\n+            let place = match &body[block].statements[statement_index].kind {\n+                StatementKind::Assign(box ( _, Rvalue::Ref(_, _, place))) => place,\n+                _ => bug!(\"`Candidate::Ref` without corresponding assignment\"),\n+            };\n+\n+            match place.base {\n+                PlaceBase::Local(local) => local,\n+                PlaceBase::Static(_) => bug!(\"`Candidate::Ref` for a non-local\"),\n+            }\n+        })\n+        .for_each(|local| {\n+            requires_lifetime_extension.insert(local);\n+        });\n+\n+    // Remove `Drop` terminators and `StorageDead` statements for all promotable temps that require\n+    // lifetime extension.\n+    for block in body.basic_blocks_mut() {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::StorageDead(index) => !requires_lifetime_extension.contains(index),\n+                _ => true\n+            }\n+        });\n+        let terminator = block.terminator_mut();\n+        match &terminator.kind {\n+            TerminatorKind::Drop {\n+                location,\n+                target,\n+                ..\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if requires_lifetime_extension.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "39720af4cb5d60f26053b1055a99a69981036a7f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 41, "deletions": 550, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -6,7 +6,6 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -16,11 +15,9 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::query::Providers;\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n-use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n-use syntax::ast::LitKind;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -33,7 +30,6 @@ use std::usize;\n \n use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n-use super::promote_consts::{self, Candidate, TempState};\n use crate::transform::check_consts::ops::{self, NonConstOp};\n \n /// What kind of item we are in.\n@@ -71,7 +67,7 @@ impl fmt::Display for Mode {\n     }\n }\n \n-const QUALIF_COUNT: usize = 4;\n+const QUALIF_COUNT: usize = 2;\n \n // FIXME(eddyb) once we can use const generics, replace this array with\n // something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n@@ -80,20 +76,20 @@ struct PerQualif<T>([T; QUALIF_COUNT]);\n \n impl<T: Clone> PerQualif<T> {\n     fn new(x: T) -> Self {\n-        PerQualif([x.clone(), x.clone(), x.clone(), x])\n+        PerQualif([x.clone(), x])\n     }\n }\n \n impl<T> PerQualif<T> {\n     fn as_mut(&mut self) -> PerQualif<&mut T> {\n-        let [x0, x1, x2, x3] = &mut self.0;\n-        PerQualif([x0, x1, x2, x3])\n+        let [x0, x1] = &mut self.0;\n+        PerQualif([x0, x1])\n     }\n \n     fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n-        let [x0, x1, x2, x3] = self.0;\n-        let [y0, y1, y2, y3] = other.0;\n-        PerQualif([(x0, y0), (x1, y1), (x2, y2), (x3, y3)])\n+        let [x0, x1] = self.0;\n+        let [y0, y1] = other.0;\n+        PerQualif([(x0, y0), (x1, y1)])\n     }\n }\n \n@@ -260,7 +256,7 @@ trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n \n@@ -429,195 +425,6 @@ impl Qualif for NeedsDrop {\n     }\n }\n \n-/// Not promotable at all - non-`const fn` calls, `asm!`,\n-/// pointer comparisons, ptr-to-int casts, etc.\n-/// Inside a const context all constness rules apply, so promotion simply has to follow the regular\n-/// constant rules (modulo interior mutability or `Drop` rules which are handled `HasMutInterior`\n-/// and `NeedsDrop` respectively). Basically this duplicates the checks that the const-checking\n-/// visitor enforces by emitting errors when working in const context.\n-struct IsNotPromotable;\n-\n-impl Qualif for IsNotPromotable {\n-    const IDX: usize = 2;\n-\n-    fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n-        match static_.kind {\n-            StaticKind::Promoted(_, _) => unreachable!(),\n-            StaticKind::Static => {\n-                // Only allow statics (not consts) to refer to other statics.\n-                // FIXME(eddyb) does this matter at all for promotion?\n-                let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n-\n-                !allowed ||\n-                    cx.tcx.get_attrs(static_.def_id).iter().any(\n-                        |attr| attr.check_name(sym::thread_local)\n-                    )\n-            }\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            match elem {\n-                ProjectionElem::Deref |\n-                ProjectionElem::Downcast(..) => return true,\n-\n-                ProjectionElem::ConstantIndex {..} |\n-                ProjectionElem::Subslice {..} |\n-                ProjectionElem::Index(_) => {}\n-\n-                ProjectionElem::Field(..) => {\n-                    if cx.mode == Mode::NonConstFn {\n-                        let base_ty = Place::ty_from(place.base, proj_base, cx.body, cx.tcx).ty;\n-                        if let Some(def) = base_ty.ty_adt_def() {\n-                            // No promotion of union field accesses.\n-                            if def.is_union() {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Self::in_projection_structurally(cx, place)\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::NonConstFn => {\n-                let operand_ty = operand.ty(cx.body, cx.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                match (cast_in, cast_out) {\n-                    (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) => {\n-                        // in normal functions, mark such casts as not promotable\n-                        return true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::NonConstFn => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).kind {\n-                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n-                            op == BinOp::Le || op == BinOp::Lt ||\n-                            op == BinOp::Ge || op == BinOp::Gt ||\n-                            op == BinOp::Offset);\n-\n-                    // raw pointer operations are not allowed inside promoteds\n-                    return true;\n-                }\n-            }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return true,\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        callee: &Operand<'tcx>,\n-        args: &[Operand<'tcx>],\n-        _return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        let fn_ty = callee.ty(cx.body, cx.tcx);\n-        match fn_ty.kind {\n-            ty::FnDef(def_id, _) => {\n-                match cx.tcx.fn_sig(def_id).abi() {\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic => {\n-                        assert!(!cx.tcx.is_const_fn(def_id));\n-                        match &cx.tcx.item_name(def_id).as_str()[..] {\n-                            | \"size_of\"\n-                            | \"min_align_of\"\n-                            | \"needs_drop\"\n-                            | \"type_id\"\n-                            | \"bswap\"\n-                            | \"bitreverse\"\n-                            | \"ctpop\"\n-                            | \"cttz\"\n-                            | \"cttz_nonzero\"\n-                            | \"ctlz\"\n-                            | \"ctlz_nonzero\"\n-                            | \"wrapping_add\"\n-                            | \"wrapping_sub\"\n-                            | \"wrapping_mul\"\n-                            | \"unchecked_shl\"\n-                            | \"unchecked_shr\"\n-                            | \"rotate_left\"\n-                            | \"rotate_right\"\n-                            | \"add_with_overflow\"\n-                            | \"sub_with_overflow\"\n-                            | \"mul_with_overflow\"\n-                            | \"saturating_add\"\n-                            | \"saturating_sub\"\n-                            | \"transmute\"\n-                            | \"simd_insert\"\n-                            | \"simd_extract\"\n-                            | \"ptr_offset_from\"\n-                            => return true,\n-\n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {\n-                        let is_const_fn =\n-                            cx.tcx.is_const_fn(def_id) ||\n-                            cx.tcx.is_unstable_const_fn(def_id).is_some() ||\n-                            cx.is_const_panic_fn(def_id);\n-                        if !is_const_fn {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => return true,\n-        }\n-\n-        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n-    }\n-}\n-\n-/// Refers to temporaries which cannot be promoted *implicitly*.\n-/// Explicit promotion happens e.g. for constant arguments declared via `rustc_args_required_const`.\n-/// Implicit promotion has almost the same rules, except that disallows `const fn` except for\n-/// those marked `#[rustc_promotable]`. This is to avoid changing a legitimate run-time operation\n-/// into a failing compile-time operation e.g. due to addresses being compared inside the function.\n-struct IsNotImplicitlyPromotable;\n-\n-impl Qualif for IsNotImplicitlyPromotable {\n-    const IDX: usize = 3;\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        callee: &Operand<'tcx>,\n-        args: &[Operand<'tcx>],\n-        _return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        if cx.mode == Mode::NonConstFn {\n-            if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).kind {\n-                // Never promote runtime `const fn` calls of\n-                // functions without `#[rustc_promotable]`.\n-                if !cx.tcx.is_promotable_const_fn(def_id) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n-    }\n-}\n-\n // Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n macro_rules! static_assert_seq_qualifs {\n     ($i:expr => $first:ident $(, $rest:ident)*) => {\n@@ -632,35 +439,28 @@ macro_rules! static_assert_seq_qualifs {\n     };\n }\n static_assert_seq_qualifs!(\n-    0 => HasMutInterior, NeedsDrop, IsNotPromotable, IsNotImplicitlyPromotable\n+    0 => HasMutInterior, NeedsDrop\n );\n \n impl ConstCx<'_, 'tcx> {\n     fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n         qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[IsNotImplicitlyPromotable] =\n-            IsNotImplicitlyPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n         qualifs\n     }\n \n     fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n         qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_local(self, local);\n-        qualifs[IsNotImplicitlyPromotable] = IsNotImplicitlyPromotable::in_local(self, local);\n         qualifs\n     }\n \n     fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n         qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_value(self, source);\n-        qualifs[IsNotImplicitlyPromotable] = IsNotImplicitlyPromotable::in_value(self, source);\n         qualifs\n     }\n }\n@@ -675,11 +475,6 @@ struct Checker<'a, 'tcx> {\n \n     span: Span,\n     def_id: DefId,\n-    rpo: ReversePostorder<'a, 'tcx>,\n-\n-    temp_promotion_state: IndexVec<Local, TempState>,\n-    promotion_candidates: Vec<Candidate>,\n-    unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n     suppress_errors: bool,\n@@ -708,10 +503,6 @@ impl Deref for Checker<'a, 'tcx> {\n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n-        let mut rpo = traversal::reverse_postorder(body);\n-        let (temps, unchecked_promotion_candidates) =\n-            promote_consts::collect_temps_and_candidates(tcx, body, &mut rpo);\n-        rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n \n@@ -732,24 +523,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            if !temps[local].is_promotable() {\n-                cx.per_local[IsNotPromotable].insert(local);\n-            }\n-            if let LocalKind::Var = body.local_kind(local) {\n-                // Sanity check to prevent implicit and explicit promotion of\n-                // named locals\n-                assert!(cx.per_local[IsNotPromotable].contains(local));\n-            }\n         }\n \n         Checker {\n             cx,\n             span: body.span,\n             def_id,\n-            rpo,\n-            temp_promotion_state: temps,\n-            promotion_candidates: vec![],\n-            unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n         }\n@@ -794,16 +573,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let mut qualifs = self.qualifs_in_value(source);\n \n         match source {\n-            ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) => {\n+            ValueSource::Rvalue(&Rvalue::Ref(_, kind, _)) => {\n                 // Getting `true` from `HasMutInterior::in_rvalue` means\n                 // the borrowed place is disallowed from being borrowed,\n                 // due to either a mutable borrow (with some exceptions),\n                 // or an shared borrow of a value with interior mutability.\n-                // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n+                // Then `HasMutInterior` is cleared\n                 // to avoid duplicate errors (e.g. from reborrowing).\n                 if qualifs[HasMutInterior] {\n                     qualifs[HasMutInterior] = false;\n-                    qualifs[IsNotPromotable] = true;\n \n                     debug!(\"suppress_errors: {}\", self.suppress_errors);\n                     if self.mode.requires_const_checking() && !self.suppress_errors {\n@@ -833,57 +611,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n-                    // Don't promote BorrowKind::Shallow borrows, as they don't\n-                    // reach codegen.\n-                    // FIXME(eddyb) the two other kinds of borrow (`Shallow` and `Unique`)\n-                    // aren't promoted here but *could* be promoted as part of a larger\n-                    // value because `IsNotPromotable` isn't being set for them,\n-                    // need to figure out what is the intended behavior.\n-\n-                    // We might have a candidate for promotion.\n-                    let candidate = Candidate::Ref(location);\n-                    // Start by traversing to the \"base\", with non-deref projections removed.\n-                    let deref_proj =\n-                        place.projection.iter().rev().find(|&elem| *elem == ProjectionElem::Deref);\n-\n-                    debug!(\n-                        \"qualify_consts: promotion candidate: place={:?} {:?}\",\n-                        place.base, deref_proj\n-                    );\n-                    // We can only promote interior borrows of promotable temps (non-temps\n-                    // don't get promoted anyway).\n-                    // (If we bailed out of the loop due to a `Deref` above, we will definitely\n-                    // not enter the conditional here.)\n-                    if let (PlaceBase::Local(local), None) = (&place.base, deref_proj) {\n-                        if self.body.local_kind(*local) == LocalKind::Temp {\n-                            debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                            // The borrowed place doesn't have `HasMutInterior`\n-                            // (from `in_rvalue`), so we can safely ignore\n-                            // `HasMutInterior` from the local's qualifications.\n-                            // This allows borrowing fields which don't have\n-                            // `HasMutInterior`, from a type that does, e.g.:\n-                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                            let mut local_qualifs = self.qualifs_in_local(*local);\n-                            // Any qualifications, except HasMutInterior (see above), disqualify\n-                            // from promotion.\n-                            // This is, in particular, the \"implicit promotion\" version of\n-                            // the check making sure that we don't run drop glue during const-eval.\n-                            local_qualifs[HasMutInterior] = false;\n-                            if !local_qualifs.0.iter().any(|&qualif| qualif) {\n-                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                                self.promotion_candidates.push(candidate);\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            ValueSource::Rvalue(&Rvalue::Repeat(ref operand, _)) => {\n-                debug!(\"assign: self.cx.mode={:?} self.def_id={:?} location={:?} operand={:?}\",\n-                       self.cx.mode, self.def_id, location, operand);\n-                if self.should_promote_repeat_expression(operand) &&\n-                        self.tcx.features().const_in_array_repeat_expressions {\n-                    self.promotion_candidates.push(Candidate::Repeat(location));\n                 }\n             },\n             _ => {},\n@@ -922,14 +649,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let kind = self.body.local_kind(index);\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n-        // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::NonConstFn {\n-            if kind != LocalKind::Temp ||\n-               !self.temp_promotion_state[index].is_promotable() {\n-                return;\n-            }\n-        }\n-\n         // this is overly restrictive, because even full assignments do not clear the qualif\n         // While we could special case full assignments, this would be inconsistent with\n         // aggregates where we overwrite all fields via assignments, which would not get\n@@ -939,22 +658,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 per_local.insert(index);\n             }\n         }\n-\n-        // Ensure the `IsNotPromotable` qualification is preserved.\n-        // NOTE(eddyb) this is actually unnecessary right now, as\n-        // we never replace the local's qualif, but we might in\n-        // the future, and so it serves to catch changes that unset\n-        // important bits (in which case, asserting `contains` could\n-        // be replaced with calling `insert` to re-set the bit).\n-        if kind == LocalKind::Temp {\n-            if !self.temp_promotion_state[index].is_promotable() {\n-                assert!(self.cx.per_local[IsNotPromotable].contains(index));\n-            }\n-        }\n     }\n \n     /// Check a whole const, static initializer or const fn.\n-    fn check_const(&mut self) -> (u8, &'tcx BitSet<Local>) {\n+    fn check_const(&mut self) -> u8 {\n         use crate::transform::check_consts as new_checker;\n \n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n@@ -976,7 +683,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n         let mut bb = START_BLOCK;\n-        let mut has_controlflow_error = false;\n         loop {\n             seen_blocks.insert(bb.index());\n \n@@ -1017,7 +723,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n-                    has_controlflow_error = true;\n                     self.not_const(ops::Loop);\n                     validator.check_op(ops::Loop);\n                     break;\n@@ -1044,118 +749,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        // Collect all the temps we need to promote.\n-        let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n-\n-        // HACK(eddyb) don't try to validate promotion candidates if any\n-        // parts of the control-flow graph were skipped due to an error.\n-        let promotion_candidates = if has_controlflow_error {\n-            let unleash_miri = self\n-                .tcx\n-                .sess\n-                .opts\n-                .debugging_opts\n-                .unleash_the_miri_inside_of_you;\n-            if !unleash_miri {\n-                self.tcx.sess.delay_span_bug(\n-                    body.span,\n-                    \"check_const: expected control-flow error(s)\",\n-                );\n-            }\n-            self.promotion_candidates.clone()\n-        } else {\n-            self.valid_promotion_candidates()\n-        };\n-        debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n-        for candidate in promotion_candidates {\n-            match candidate {\n-                Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n-                    if let StatementKind::Assign(box(_, Rvalue::Repeat(\n-                        Operand::Move(place),\n-                        _\n-                    ))) = &self.body[bb].statements[stmt_idx].kind {\n-                        if let Some(index) = place.as_local() {\n-                            promoted_temps.insert(index);\n-                        }\n-                    }\n-                }\n-                Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                    if let StatementKind::Assign(\n-                        box(\n-                            _,\n-                            Rvalue::Ref(_, _, place)\n-                        )\n-                    ) = &self.body[bb].statements[stmt_idx].kind {\n-                        if let Some(index) = place.as_local() {\n-                            promoted_temps.insert(index);\n-                        }\n-                    }\n-                }\n-                Candidate::Argument { .. } => {}\n-            }\n-        }\n-\n-        let mut qualifs = self.qualifs_in_local(RETURN_PLACE);\n-\n-        // Account for errors in consts by using the\n-        // conservative type qualification instead.\n-        if qualifs[IsNotPromotable] {\n-            qualifs = self.qualifs_in_any_value_of_ty(body.return_ty());\n-        }\n-\n-        (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n-    }\n-\n-    /// Get the subset of `unchecked_promotion_candidates` that are eligible\n-    /// for promotion.\n-    // FIXME(eddyb) replace the old candidate gathering with this.\n-    fn valid_promotion_candidates(&self) -> Vec<Candidate> {\n-        // Sanity-check the promotion candidates.\n-        let candidates = promote_consts::validate_candidates(\n-            self.tcx,\n-            self.body,\n-            self.def_id,\n-            &self.temp_promotion_state,\n-            &self.unchecked_promotion_candidates,\n-        );\n-\n-        if candidates != self.promotion_candidates {\n-            let report = |msg, candidate| {\n-                let span = match candidate {\n-                    Candidate::Ref(loc) |\n-                    Candidate::Repeat(loc) => self.body.source_info(loc).span,\n-                    Candidate::Argument { bb, .. } => {\n-                        self.body[bb].terminator().source_info.span\n-                    }\n-                };\n-                self.tcx.sess.span_err(span, &format!(\"{}: {:?}\", msg, candidate));\n-            };\n-\n-            for &c in &self.promotion_candidates {\n-                if !candidates.contains(&c) {\n-                    report(\"invalidated old candidate\", c);\n-                }\n-            }\n-\n-            for &c in &candidates {\n-                if !self.promotion_candidates.contains(&c) {\n-                    report(\"extra new candidate\", c);\n-                }\n-            }\n-\n-            bug!(\"promotion candidate validation mismatches (see above)\");\n-        }\n-\n-        candidates\n-    }\n-\n-    /// Returns `true` if the operand of a repeat expression is promotable.\n-    fn should_promote_repeat_expression(&self, operand: &Operand<'tcx>) -> bool {\n-        let not_promotable = IsNotImplicitlyPromotable::in_operand(self, operand) ||\n-                             IsNotPromotable::in_operand(self, operand);\n-        debug!(\"should_promote_repeat_expression: operand={:?} not_promotable={:?}\",\n-               operand, not_promotable);\n-        !not_promotable\n+        self.qualifs_in_local(RETURN_PLACE).encode_to_bits()\n     }\n }\n \n@@ -1468,16 +1062,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             let fn_ty = func.ty(self.body, self.tcx);\n-            let mut callee_def_id = None;\n-            let mut is_shuffle = false;\n             match fn_ty.kind {\n                 ty::FnDef(def_id, _) => {\n-                    callee_def_id = Some(def_id);\n                     match self.tcx.fn_sig(def_id).abi() {\n                         Abi::RustIntrinsic |\n                         Abi::PlatformIntrinsic => {\n                             assert!(!self.tcx.is_const_fn(def_id));\n-                            match &self.tcx.item_name(def_id).as_str()[..] {\n+                            match &*self.tcx.item_name(def_id).as_str() {\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n@@ -1496,10 +1087,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     }\n                                 }\n \n-                                name if name.starts_with(\"simd_shuffle\") => {\n-                                    is_shuffle = true;\n-                                }\n-\n                                 // no need to check feature gates, intrinsics are only callable\n                                 // from the libstd or with forever unstable feature gates\n                                 _ => {}\n@@ -1587,36 +1174,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n             }\n \n-            // No need to do anything in constants and statics, as everything is \"constant\" anyway\n-            // so promotion would be useless.\n-            if self.mode != Mode::Static && self.mode != Mode::Const {\n-                let constant_args = callee_def_id.and_then(|id| {\n-                    args_required_const(self.tcx, id)\n-                }).unwrap_or_default();\n-                for (i, arg) in args.iter().enumerate() {\n-                    if !(is_shuffle && i == 2 || constant_args.contains(&i)) {\n-                        continue;\n-                    }\n-\n-                    let candidate = Candidate::Argument { bb: location.block, index: i };\n-                    // Since the argument is required to be constant,\n-                    // we care about constness, not promotability.\n-                    // If we checked for promotability, we'd miss out on\n-                    // the results of function calls (which are never promoted\n-                    // in runtime code).\n-                    // This is not a problem, because the argument explicitly\n-                    // requests constness, in contrast to regular promotion\n-                    // which happens even without the user requesting it.\n-                    //\n-                    // `promote_consts` is responsible for emitting the error if\n-                    // the argument is not promotable.\n-                    if !IsNotPromotable::in_operand(self, arg) {\n-                        debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                        self.promotion_candidates.push(candidate);\n-                    }\n-                }\n-            }\n-\n             // Check callee and argument operands.\n             self.visit_operand(func, location);\n             for arg in args {\n@@ -1720,9 +1277,9 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n // FIXME(eddyb) this is only left around for the validation logic\n // in `promote_consts`, see the comment in `validate_operand`.\n-pub(super) const QUALIF_ERROR_BIT: u8 = 1 << IsNotPromotable::IDX;\n+pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n \n-fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n+fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1731,7 +1288,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return (QUALIF_ERROR_BIT, tcx.arena.alloc(BitSet::new_empty(0)));\n+        return QUALIF_ERROR_BIT;\n     }\n \n     Checker::new(tcx, def_id, body, Mode::Const).check_const()\n@@ -1767,53 +1324,34 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n         let mode = determine_mode(tcx, hir_id, def_id);\n \n         debug!(\"run_pass: mode={:?}\", mode);\n-        if let Mode::NonConstFn | Mode::ConstFn = mode {\n-            // This is ugly because Checker holds onto mir,\n-            // which can't be mutated until its scope ends.\n-            let (temps, candidates) = {\n-                let mut checker = Checker::new(tcx, def_id, body, mode);\n-                if let Mode::ConstFn = mode {\n-                    let use_min_const_fn_checks =\n-                        !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                        tcx.is_min_const_fn(def_id);\n-                    if use_min_const_fn_checks {\n-                        // Enforce `min_const_fn` for stable `const fn`s.\n-                        use super::qualify_min_const_fn::is_min_const_fn;\n-                        if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                            error_min_const_fn_violation(tcx, span, err);\n-                            return;\n-                        }\n-\n-                        // `check_const` should not produce any errors, but better safe than sorry\n-                        // FIXME(#53819)\n-                        // NOTE(eddyb) `check_const` is actually needed for promotion inside\n-                        // `min_const_fn` functions.\n-                    }\n-\n-                    // Enforce a constant-like CFG for `const fn`.\n-                    checker.check_const();\n-                } else {\n-                    while let Some((bb, data)) = checker.rpo.next() {\n-                        checker.visit_basic_block_data(bb, data);\n-                    }\n+        if let Mode::NonConstFn = mode {\n+            // No need to const-check a non-const `fn` now that we don't do promotion here.\n+            return;\n+        } else if let Mode::ConstFn = mode {\n+            let mut checker = Checker::new(tcx, def_id, body, mode);\n+            let use_min_const_fn_checks =\n+                !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                tcx.is_min_const_fn(def_id);\n+            if use_min_const_fn_checks {\n+                // Enforce `min_const_fn` for stable `const fn`s.\n+                use super::qualify_min_const_fn::is_min_const_fn;\n+                if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                    error_min_const_fn_violation(tcx, span, err);\n+                    return;\n                 }\n+            }\n \n-                let promotion_candidates = checker.valid_promotion_candidates();\n-                (checker.temp_promotion_state, promotion_candidates)\n-            };\n-\n-            // Do the actual promotion, now that we know what's viable.\n-            self.promoted.set(\n-                promote_consts::promote_candidates(def_id, body, tcx, temps, candidates)\n-            );\n+            // `check_const` should not produce any errors, but better safe than sorry\n+            // FIXME(#53819)\n+            // Enforce a constant-like CFG for `const fn`.\n+            checker.check_const();\n         } else {\n             check_short_circuiting_in_const_local(tcx, body, mode);\n \n-            let promoted_temps = match mode {\n-                Mode::Const => tcx.mir_const_qualif(def_id).1,\n-                _ => Checker::new(tcx, def_id, body, mode).check_const().1,\n+            match mode {\n+                Mode::Const => tcx.mir_const_qualif(def_id),\n+                _ => Checker::new(tcx, def_id, body, mode).check_const(),\n             };\n-            remove_drop_and_storage_dead_on_promoted_locals(body, promoted_temps);\n         }\n \n         if mode == Mode::Static && !tcx.has_attr(def_id, sym::thread_local) {\n@@ -1829,8 +1367,8 @@ fn determine_mode(tcx: TyCtxt<'_>, hir_id: HirId, def_id: DefId) -> Mode {\n         hir::BodyOwnerKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n         hir::BodyOwnerKind::Fn => Mode::NonConstFn,\n         hir::BodyOwnerKind::Const => Mode::Const,\n-        hir::BodyOwnerKind::Static(hir::MutImmutable) => Mode::Static,\n-        hir::BodyOwnerKind::Static(hir::MutMutable) => Mode::StaticMut,\n+        hir::BodyOwnerKind::Static(hir::Mutability::Immutable) => Mode::Static,\n+        hir::BodyOwnerKind::Static(hir::Mutability::Mutable) => Mode::StaticMut,\n     }\n }\n \n@@ -1874,40 +1412,6 @@ fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>,\n     }\n }\n \n-/// In `const` and `static` everything without `StorageDead`\n-/// is `'static`, we don't have to create promoted MIR fragments,\n-/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n-fn remove_drop_and_storage_dead_on_promoted_locals(\n-    body: &mut Body<'tcx>,\n-    promoted_temps: &BitSet<Local>,\n-) {\n-    debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n-\n-    for block in body.basic_blocks_mut() {\n-        block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::StorageDead(index) => !promoted_temps.contains(index),\n-                _ => true\n-            }\n-        });\n-        let terminator = block.terminator_mut();\n-        match &terminator.kind {\n-            TerminatorKind::Drop {\n-                location,\n-                target,\n-                ..\n-            } => {\n-                if let Some(index) = location.as_local() {\n-                    if promoted_temps.contains(index) {\n-                        terminator.kind = TerminatorKind::Goto { target: *target };\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n     let ty = body.return_ty();\n     tcx.infer_ctxt().enter(|infcx| {\n@@ -1921,19 +1425,6 @@ fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId)\n     });\n }\n \n-fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n-    let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n-    let mut ret = FxHashSet::default();\n-    for meta in attr.meta_item_list()? {\n-        match meta.literal()?.kind {\n-            LitKind::Int(a, _) => { ret.insert(a as usize); }\n-            _ => return None,\n-        }\n-    }\n-    Some(ret)\n-}\n-\n fn validator_mismatch(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,"}, {"sha": "83bde5ed34eaeca6f080407088b17b28bd70de8d", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -80,7 +80,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.kind {\n-            ty::Ref(_, _, hir::Mutability::MutMutable) => return Err((\n+            ty::Ref(_, _, hir::Mutability::Mutable) => return Err((\n                 span,\n                 \"mutable references in const fn are unstable\".into(),\n             )),\n@@ -150,7 +150,8 @@ fn check_rvalue(\n                 _ => check_operand(tcx, operand, span, def_id, body),\n             }\n         }\n-        Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, _) => {\n+        Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, _)\n+        | Rvalue::Cast(CastKind::Pointer(PointerCast::ArrayToPointer), operand, _) => {\n             check_operand(tcx, operand, span, def_id, body)\n         }\n         Rvalue::Cast(CastKind::Pointer(PointerCast::UnsafeFnPointer), _, _) |\n@@ -402,7 +403,7 @@ fn check_terminator(\n ///\n /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    match &tcx.item_name(def_id).as_str()[..] {\n+    match &*tcx.item_name(def_id).as_str() {\n         | \"size_of\"\n         | \"min_align_of\"\n         | \"needs_drop\""}, {"sha": "f6b09f20bab679976b7af399128144c01a3c6670", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -359,13 +359,20 @@ impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n         // Ignore stores of constants because `ConstProp` and `CopyProp` can remove uses of many\n         // of these locals. However, if the local is still needed, then it will be referenced in\n         // another place and we'll mark it as being used there.\n-        if ctx == PlaceContext::MutatingUse(MutatingUseContext::Store) {\n-            let stmt =\n-                &self.body.basic_blocks()[location.block].statements[location.statement_index];\n-            if let StatementKind::Assign(box (p, Rvalue::Use(Operand::Constant(c)))) = &stmt.kind {\n-                if p.as_local().is_some() {\n-                    trace!(\"skipping store of const value {:?} to {:?}\", c, local);\n-                    return;\n+        if ctx == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n+           ctx == PlaceContext::MutatingUse(MutatingUseContext::Projection) {\n+            let block = &self.body.basic_blocks()[location.block];\n+            if location.statement_index != block.statements.len() {\n+                let stmt =\n+                    &block.statements[location.statement_index];\n+\n+                if let StatementKind::Assign(\n+                    box (p, Rvalue::Use(Operand::Constant(c)))\n+                ) = &stmt.kind {\n+                    if !p.is_indirect() {\n+                        trace!(\"skipping store of const value {:?} to {:?}\", c, p);\n+                        return;\n+                    }\n                 }\n             }\n         }\n@@ -392,7 +399,7 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n                     self.map[*l].is_some()\n                 }\n                 StatementKind::Assign(box (place, _)) => {\n-                    if let Some(local) = place.as_local() {\n+                    if let PlaceBase::Local(local) = place.base {\n                         self.map[local].is_some()\n                     } else {\n                         true"}, {"sha": "a6c18aee6a8891cc8b91ffb8eeb79ea5090e9d8c", "filename": "src/librustc_mir/transform/uninhabited_enum_branching.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,126 @@\n+//! A pass that eliminates branches on uninhabited enum variants.\n+\n+use crate::transform::{MirPass, MirSource};\n+use rustc::mir::{\n+    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n+};\n+use rustc::ty::layout::{Abi, TyLayout, Variants};\n+use rustc::ty::{Ty, TyCtxt};\n+\n+pub struct UninhabitedEnumBranching;\n+\n+fn get_discriminant_local(terminator: &TerminatorKind<'_>) -> Option<Local> {\n+    if let TerminatorKind::SwitchInt { discr: Operand::Move(p), .. } = terminator {\n+        p.as_local()\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If the basic block terminates by switching on a discriminant, this returns the `Ty` the\n+/// discriminant is read from. Otherwise, returns None.\n+fn get_switched_on_type<'tcx>(\n+    block_data: &BasicBlockData<'tcx>,\n+    body: &Body<'tcx>,\n+) -> Option<Ty<'tcx>> {\n+    let terminator = block_data.terminator();\n+\n+    // Only bother checking blocks which terminate by switching on a local.\n+    if let Some(local) = get_discriminant_local(&terminator.kind) {\n+        let stmt_before_term = (block_data.statements.len() > 0)\n+            .then_with(|| &block_data.statements[block_data.statements.len() - 1].kind);\n+\n+        if let Some(StatementKind::Assign(box (l, Rvalue::Discriminant(place)))) = stmt_before_term\n+        {\n+            if l.as_local() == Some(local) {\n+                if let Some(r_local) = place.as_local() {\n+                    let ty = body.local_decls[r_local].ty;\n+\n+                    if ty.is_enum() {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn variant_discriminants<'tcx>(\n+    layout: &TyLayout<'tcx>,\n+    ty: Ty<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+) -> Vec<u128> {\n+    match &layout.details.variants {\n+        Variants::Single { index } => vec![index.as_u32() as u128],\n+        Variants::Multiple { variants, .. } => variants\n+            .iter_enumerated()\n+            .filter_map(|(idx, layout)| {\n+                (layout.abi != Abi::Uninhabited)\n+                    .then_with(|| ty.discriminant_for_variant(tcx, idx).unwrap().val)\n+            })\n+            .collect(),\n+    }\n+}\n+\n+impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if source.promoted.is_some() {\n+            return;\n+        }\n+\n+        trace!(\"UninhabitedEnumBranching starting for {:?}\", source);\n+\n+        let basic_block_count = body.basic_blocks().len();\n+\n+        for bb in 0..basic_block_count {\n+            let bb = BasicBlock::from_usize(bb);\n+            trace!(\"processing block {:?}\", bb);\n+\n+            let discriminant_ty =\n+                if let Some(ty) = get_switched_on_type(&body.basic_blocks()[bb], body) {\n+                    ty\n+                } else {\n+                    continue;\n+                };\n+\n+            let layout = tcx.layout_of(tcx.param_env(source.def_id()).and(discriminant_ty));\n+\n+            let allowed_variants = if let Ok(layout) = layout {\n+                variant_discriminants(&layout, discriminant_ty, tcx)\n+            } else {\n+                continue;\n+            };\n+\n+            trace!(\"allowed_variants = {:?}\", allowed_variants);\n+\n+            if let TerminatorKind::SwitchInt { values, targets, .. } =\n+                &mut body.basic_blocks_mut()[bb].terminator_mut().kind\n+            {\n+                let vals = &*values;\n+                let zipped = vals.iter().zip(targets.into_iter());\n+\n+                let mut matched_values = Vec::with_capacity(allowed_variants.len());\n+                let mut matched_targets = Vec::with_capacity(allowed_variants.len() + 1);\n+\n+                for (val, target) in zipped {\n+                    if allowed_variants.contains(val) {\n+                        matched_values.push(*val);\n+                        matched_targets.push(*target);\n+                    } else {\n+                        trace!(\"eliminating {:?} -> {:?}\", val, target);\n+                    }\n+                }\n+\n+                // handle the \"otherwise\" branch\n+                matched_targets.push(targets.pop().unwrap());\n+\n+                *values = matched_values.into();\n+                *targets = matched_targets;\n+            } else {\n+                unreachable!()\n+            }\n+        }\n+    }\n+}"}, {"sha": "bf01ad1a0236f917ba9d04d96f9c3b3b8f5a4ec4", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -395,23 +395,25 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_mutate_in_match_guard(\n+    crate fn cannot_mutate_in_immutable_section(\n         &self,\n         mutate_span: Span,\n-        match_span: Span,\n-        match_place: &str,\n+        immutable_span: Span,\n+        immutable_place: &str,\n+        immutable_section: &str,\n         action: &str,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             mutate_span,\n             E0510,\n-            \"cannot {} `{}` in match guard\",\n+            \"cannot {} `{}` in {}\",\n             action,\n-            match_place,\n+            immutable_place,\n+            immutable_section,\n         );\n         err.span_label(mutate_span, format!(\"cannot {}\", action));\n-        err.span_label(match_span, String::from(\"value is immutable in match guard\"));\n+        err.span_label(immutable_span, format!(\"value is immutable in {}\", immutable_section));\n         err\n     }\n "}, {"sha": "67e5bfafafd12fe7f1223382ebb877c4891d68e4", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -521,7 +521,7 @@ where\n \n         let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n             ty,\n-            mutbl: hir::Mutability::MutMutable\n+            mutbl: hir::Mutability::Mutable\n         });\n         let ref_place = self.new_temp(ref_ty);\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n@@ -580,7 +580,7 @@ where\n \n         let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n             ty: ety,\n-            mutbl: hir::Mutability::MutMutable\n+            mutbl: hir::Mutability::Mutable\n         });\n         let ptr = &Place::from(self.new_temp(ref_ty));\n         let can_go = &Place::from(self.new_temp(tcx.types.bool));"}, {"sha": "4579f9d472d81fb1d0d7b76a1b3d9cfd2a4b53a3", "filename": "src/librustc_parse/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,21 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_parse\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_parse\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+bitflags = \"1.0\"\n+log = \"0.4\"\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+syntax = { path = \"../libsyntax\" }\n+errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_lexer = { path = \"../librustc_lexer\" }\n+rustc_target = { path = \"../librustc_target\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "cf74e09a3772d3d567108cf67bbe89671934f2f4", "filename": "src/librustc_parse/error_codes.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Ferror_codes.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,174 @@\n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80\n+// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n+// `:set tw=0` to disable.\n+syntax::register_diagnostics! {\n+\n+E0178: r##\"\n+In types, the `+` type operator has low precedence, so it is often necessary\n+to use parentheses.\n+\n+For example:\n+\n+```compile_fail,E0178\n+trait Foo {}\n+\n+struct Bar<'a> {\n+    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n+    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n+    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n+    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n+}\n+```\n+\n+More details can be found in [RFC 438].\n+\n+[RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n+\"##,\n+\n+E0583: r##\"\n+A file wasn't found for an out-of-line module.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+mod file_that_doesnt_exist; // error: file not found for module\n+\n+fn main() {}\n+```\n+\n+Please be sure that a file corresponding to the module exists. If you\n+want to use a module named `file_that_doesnt_exist`, you need to have a file\n+named `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\n+same directory.\n+\"##,\n+\n+E0584: r##\"\n+A doc comment that is not attached to anything has been encountered.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0584\n+trait Island {\n+    fn lost();\n+\n+    /// I'm lost!\n+}\n+```\n+\n+A little reminder: a doc comment has to be placed before the item it's supposed\n+to document. So if you want to document the `Island` trait, you need to put a\n+doc comment before it, not inside it. Same goes for the `lost` method: the doc\n+comment needs to be before it:\n+\n+```\n+/// I'm THE island!\n+trait Island {\n+    /// I'm lost!\n+    fn lost();\n+}\n+```\n+\"##,\n+\n+E0585: r##\"\n+A documentation comment that doesn't document anything was found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0585\n+fn main() {\n+    // The following doc comment will fail:\n+    /// This is a useless doc comment!\n+}\n+```\n+\n+Documentation comments need to be followed by items, including functions,\n+types, modules, etc. Examples:\n+\n+```\n+/// I'm documenting the following struct:\n+struct Foo;\n+\n+/// I'm documenting the following function:\n+fn foo() {}\n+```\n+\"##,\n+\n+E0586: r##\"\n+An inclusive range was used with no end.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0586\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1..=]; // error: inclusive range was used with no end\n+}\n+```\n+\n+An inclusive range needs an end in order to *include* it. If you just need a\n+start and no end, use a non-inclusive range (with `..`):\n+\n+```\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1..]; // ok!\n+}\n+```\n+\n+Or put an end to your inclusive range:\n+\n+```\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1..=3]; // ok!\n+}\n+```\n+\"##,\n+\n+E0704: r##\"\n+This error indicates that a incorrect visibility restriction was specified.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0704\n+mod foo {\n+    pub(foo) struct Bar {\n+        x: i32\n+    }\n+}\n+```\n+\n+To make struct `Bar` only visible in module `foo` the `in` keyword should be\n+used:\n+```\n+mod foo {\n+    pub(in crate::foo) struct Bar {\n+        x: i32\n+    }\n+}\n+# fn main() {}\n+```\n+\n+For more information see the Rust Reference on [Visibility].\n+\n+[Visibility]: https://doc.rust-lang.org/reference/visibility-and-privacy.html\n+\"##,\n+\n+E0743: r##\"\n+C-variadic has been used on a non-foreign function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0743\n+fn foo2(x: u8, ...) {} // error!\n+```\n+\n+Only foreign functions can use C-variadic (`...`). It is used to give an\n+undefined number of parameters to a given function (like `printf` in C). The\n+equivalent in Rust would be to use macros directly.\n+\"##,\n+\n+;\n+\n+}"}, {"sha": "5de63cb39d16b1555ab377dfad440b6caeb3d1a6", "filename": "src/librustc_parse/lexer/mod.rs", "status": "renamed", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,7 +1,7 @@\n-use crate::parse::token::{self, Token, TokenKind};\n-use crate::sess::ParseSess;\n-use crate::symbol::{sym, Symbol};\n-use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n+use syntax::token::{self, Token, TokenKind};\n+use syntax::sess::ParseSess;\n+use syntax::symbol::{sym, Symbol};\n+use syntax::util::comments;\n \n use errors::{FatalError, DiagnosticBuilder};\n use syntax_pos::{BytePos, Pos, Span};\n@@ -13,12 +13,10 @@ use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n \n-#[cfg(test)]\n-mod tests;\n-\n-pub mod comments;\n mod tokentrees;\n mod unicode_chars;\n+mod unescape_error_reporting;\n+use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n pub struct UnmatchedBrace {\n@@ -34,7 +32,8 @@ pub struct StringReader<'a> {\n     /// Initial position, read-only.\n     start_pos: BytePos,\n     /// The absolute offset within the source_map of the current character.\n-    pos: BytePos,\n+    // FIXME(#64197): `pub` is needed by tests for now.\n+    pub pos: BytePos,\n     /// Stop reading src at this index.\n     end_src_index: usize,\n     /// Source text to tokenize.\n@@ -68,7 +67,7 @@ impl<'a> StringReader<'a> {\n         let end = sess.source_map().lookup_byte_offset(span.hi());\n \n         // Make the range zero-length if the span is invalid.\n-        if span.lo() > span.hi() || begin.sf.start_pos != end.sf.start_pos {\n+        if begin.sf.start_pos != end.sf.start_pos {\n             span = span.shrink_to_lo();\n         }\n \n@@ -178,7 +177,7 @@ impl<'a> StringReader<'a> {\n             rustc_lexer::TokenKind::LineComment => {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n-                let tok = if is_doc_comment(string) {\n+                let tok = if comments::is_line_doc_comment(string) {\n                     self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n@@ -191,7 +190,7 @@ impl<'a> StringReader<'a> {\n                 let string = self.str_from(start);\n                 // block comments starting with \"/**\" or \"/*!\" are doc-comments\n                 // but comments with only \"*\"s between two \"/\"s are not\n-                let is_doc_comment = is_block_doc_comment(string);\n+                let is_doc_comment = comments::is_block_doc_comment(string);\n \n                 if !terminated {\n                     let msg = if is_doc_comment {\n@@ -642,18 +641,3 @@ impl<'a> StringReader<'a> {\n         }\n     }\n }\n-\n-fn is_doc_comment(s: &str) -> bool {\n-    let res = (s.starts_with(\"///\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'/') ||\n-              s.starts_with(\"//!\");\n-    debug!(\"is {:?} a doc comment? {}\", s, res);\n-    res\n-}\n-\n-fn is_block_doc_comment(s: &str) -> bool {\n-    // Prevent `/**/` from being parsed as a doc comment\n-    let res = ((s.starts_with(\"/**\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'*') ||\n-               s.starts_with(\"/*!\")) && s.len() >= 5;\n-    debug!(\"is {:?} a doc comment? {}\", s, res);\n-    res\n-}", "previous_filename": "src/libsyntax/parse/lexer/mod.rs"}, {"sha": "1353591308b2e9446a10a99c26b59ae31cdceeb0", "filename": "src/librustc_parse/lexer/tokentrees.rs", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Ftokentrees.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,10 +3,11 @@ use syntax_pos::Span;\n \n use super::{StringReader, UnmatchedBrace};\n \n-use crate::print::pprust::token_to_string;\n-use crate::parse::token::{self, Token};\n-use crate::parse::PResult;\n-use crate::tokenstream::{DelimSpan, IsJoint::{self, *}, TokenStream, TokenTree, TreeAndJoint};\n+use syntax::print::pprust::token_to_string;\n+use syntax::token::{self, Token};\n+use syntax::tokenstream::{DelimSpan, IsJoint::{self, *}, TokenStream, TokenTree, TreeAndJoint};\n+\n+use errors::PResult;\n \n impl<'a> StringReader<'a> {\n     crate fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {", "previous_filename": "src/libsyntax/parse/lexer/tokentrees.rs"}, {"sha": "a5749d07e62b5c25fa2195cc369b19c39735032c", "filename": "src/librustc_parse/lexer/unescape_error_reporting.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -6,7 +6,7 @@ use std::iter::once;\n use rustc_lexer::unescape::{EscapeError, Mode};\n use syntax_pos::{Span, BytePos};\n \n-use crate::errors::{Handler, Applicability};\n+use syntax::errors::{Handler, Applicability};\n \n pub(crate) fn emit_unescape_error(\n     handler: &Handler,", "previous_filename": "src/libsyntax/parse/unescape_error_reporting.rs"}, {"sha": "6eb995b61d3feeeb062f7388e61900d8e20f6f4c", "filename": "src/librustc_parse/lexer/unicode_chars.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Funicode_chars.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,7 +4,7 @@\n use super::StringReader;\n use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::{BytePos, Pos, Span, symbol::kw};\n-use crate::parse::token;\n+use crate::token;\n \n #[rustfmt::skip] // for line breaks\n const UNICODE_ARRAY: &[(char, &str, char)] = &[", "previous_filename": "src/libsyntax/parse/lexer/unicode_chars.rs"}, {"sha": "9f507d5319edbcccf073ed55ea3857d9f636c59a", "filename": "src/librustc_parse/lib.rs", "status": "renamed", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,15 +1,14 @@\n //! The main parser interface.\n \n-use crate::ast;\n-use crate::parse::parser::{Parser, emit_unclosed_delims, make_unclosed_delims_error};\n-use crate::parse::token::Nonterminal;\n-use crate::tokenstream::{self, TokenStream, TokenTree};\n-use crate::print::pprust;\n-use crate::sess::ParseSess;\n-\n-use errors::{FatalError, Level, Diagnostic, DiagnosticBuilder};\n-#[cfg(target_arch = \"x86_64\")]\n-use rustc_data_structures::static_assert_size;\n+#![feature(crate_visibility_modifier)]\n+\n+use syntax::ast;\n+use syntax::print::pprust;\n+use syntax::sess::ParseSess;\n+use syntax::token::{self, Nonterminal};\n+use syntax::tokenstream::{self, TokenStream, TokenTree};\n+\n+use errors::{PResult, FatalError, Level, Diagnostic};\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::{Span, SourceFile, FileName};\n \n@@ -19,24 +18,14 @@ use std::str;\n \n use log::info;\n \n-#[cfg(test)]\n-mod tests;\n+pub const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n \n #[macro_use]\n pub mod parser;\n+use parser::{Parser, emit_unclosed_delims, make_unclosed_delims_error};\n pub mod lexer;\n-pub mod token;\n-\n-crate mod classify;\n-crate mod literal;\n-crate mod unescape_error_reporting;\n-\n-pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n-\n-// `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n-// (See also the comment on `DiagnosticBuilderInner`.)\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PResult<'_, bool>, 16);\n+pub mod validate_attr;\n+pub mod error_codes;\n \n #[derive(Clone)]\n pub struct Directory<'a> {\n@@ -51,7 +40,7 @@ pub enum DirectoryOwnership {\n         relative: Option<ast::Ident>,\n     },\n     UnownedViaBlock,\n-    UnownedViaMod(bool /* legacy warnings? */),\n+    UnownedViaMod,\n }\n \n // A bunch of utility functions of the form `parse_<thing>_from_<source>`\n@@ -287,7 +276,7 @@ pub fn parse_in_attr<'a, T>(\n ) -> PResult<'a, T> {\n     let mut parser = Parser::new(\n         sess,\n-        attr.tokens.clone(),\n+        attr.get_normal_item().tokens.clone(),\n         None,\n         false,\n         false,\n@@ -393,18 +382,22 @@ fn prepend_attrs(\n \n         let source = pprust::attribute_to_string(attr);\n         let macro_filename = FileName::macro_expansion_source_code(&source);\n-        if attr.is_sugared_doc {\n-            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n-            builder.push(stream);\n-            continue\n-        }\n+\n+        let item = match attr.kind {\n+            ast::AttrKind::Normal(ref item) => item,\n+            ast::AttrKind::DocComment(_) => {\n+                let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n+                builder.push(stream);\n+                continue\n+            }\n+        };\n \n         // synthesize # [ $path $tokens ] manually here\n         let mut brackets = tokenstream::TokenStreamBuilder::new();\n \n         // For simple paths, push the identifier directly\n-        if attr.path.segments.len() == 1 && attr.path.segments[0].args.is_none() {\n-            let ident = attr.path.segments[0].ident;\n+        if item.path.segments.len() == 1 && item.path.segments[0].args.is_none() {\n+            let ident = item.path.segments[0].ident;\n             let token = token::Ident(ident.name, ident.as_str().starts_with(\"r#\"));\n             brackets.push(tokenstream::TokenTree::token(token, ident.span));\n \n@@ -415,7 +408,7 @@ fn prepend_attrs(\n             brackets.push(stream);\n         }\n \n-        brackets.push(attr.tokens.clone());\n+        brackets.push(item.tokens.clone());\n \n         // The span we list here for `#` and for `[ ... ]` are both wrong in\n         // that it encompasses more than each token, but it hopefully is \"good", "previous_filename": "src/libsyntax/parse/mod.rs"}, {"sha": "524b551e54cb3b51fccbce148c6582f107626ec2", "filename": "src/librustc_parse/parser/attr.rs", "status": "renamed", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,9 +1,11 @@\n-use super::{SeqSep, PResult, Parser, TokenType, PathStyle};\n-use crate::attr;\n-use crate::ast;\n-use crate::parse::token::{self, Nonterminal, DelimToken};\n-use crate::tokenstream::{TokenStream, TokenTree};\n-use crate::source_map::Span;\n+use super::{SeqSep, Parser, TokenType, PathStyle};\n+use syntax::attr;\n+use syntax::ast;\n+use syntax::util::comments;\n+use syntax::token::{self, Nonterminal, DelimToken};\n+use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax_pos::{Span, Symbol};\n+use errors::PResult;\n \n use log::debug;\n \n@@ -43,7 +45,7 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = attr::mk_sugared_doc_attr(s, self.token.span);\n+                    let attr = self.mk_doc_comment(s);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -60,6 +62,11 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n+    fn mk_doc_comment(&self, s: Symbol) -> ast::Attribute {\n+        let style = comments::doc_comment_style(&s.as_str());\n+        attr::mk_doc_comment(style, s, self.token.span)\n+    }\n+\n     /// Matches `attribute = # ! [ meta_item ]`.\n     ///\n     /// If `permit_inner` is `true`, then a leading `!` indicates an inner\n@@ -149,13 +156,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(ast::Attribute {\n-            item,\n-            id: attr::mk_attr_id(),\n-            style,\n-            is_sugared_doc: false,\n-            span,\n-        })\n+        Ok(attr::mk_attr_from_item(style, item, span))\n     }\n \n     /// Parses an inner part of an attribute (the path and following tokens).\n@@ -229,7 +230,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::DocComment(s) => {\n                     // We need to get the position of this token before we bump.\n-                    let attr = attr::mk_sugared_doc_attr(s, self.token.span);\n+                    let attr = self.mk_doc_comment(s);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n@@ -260,7 +261,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `cfg_attr(pred, attr_item_list)` where `attr_item_list` is comma-delimited.\n-    crate fn parse_cfg_attr(&mut self) -> PResult<'a, (ast::MetaItem, Vec<(ast::AttrItem, Span)>)> {\n+    pub fn parse_cfg_attr(&mut self) -> PResult<'a, (ast::MetaItem, Vec<(ast::AttrItem, Span)>)> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n         let cfg_predicate = self.parse_meta_item()?;", "previous_filename": "src/libsyntax/parse/parser/attr.rs"}, {"sha": "38eae008537d728acf9fa0344aa83afb1bb3f637", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "renamed", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,18 +1,18 @@\n-use super::{\n-    BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType,\n-    SeqSep, PResult, Parser\n-};\n-use crate::ast::{\n+use super::{BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType, SeqSep, Parser};\n+\n+use syntax::ast::{\n     self, Param, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item, ItemKind,\n     Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind,\n };\n-use crate::parse::token::{self, TokenKind, token_can_begin_expr};\n-use crate::print::pprust;\n-use crate::ptr::P;\n-use crate::symbol::{kw, sym};\n-use crate::ThinVec;\n-use crate::util::parser::AssocOp;\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId, pluralise};\n+use syntax::token::{self, TokenKind, token_can_begin_expr};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::symbol::{kw, sym};\n+use syntax::ThinVec;\n+use syntax::util::parser::AssocOp;\n+use syntax::struct_span_err;\n+\n+use errors::{PResult, Applicability, DiagnosticBuilder, DiagnosticId, pluralize};\n use rustc_data_structures::fx::FxHashSet;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan, SpanSnippetError};\n use log::{debug, trace};\n@@ -289,7 +289,7 @@ impl<'a> Parser<'a> {\n             };\n             (format!(\"expected one of {}, found {}\", expect, actual),\n                 (self.sess.source_map().next_point(self.prev_span),\n-                format!(\"expected one of {} here\", short_expect)))\n+                format!(\"expected one of {}\", short_expect)))\n         } else if expected.is_empty() {\n             (format!(\"unexpected token: {}\", actual),\n                 (self.prev_span, \"unexpected token after this\".to_string()))\n@@ -360,11 +360,11 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn maybe_annotate_with_ascription(\n-        &self,\n+        &mut self,\n         err: &mut DiagnosticBuilder<'_>,\n         maybe_expected_semicolon: bool,\n     ) {\n-        if let Some((sp, likely_path)) = self.last_type_ascription {\n+        if let Some((sp, likely_path)) = self.last_type_ascription.take() {\n             let sm = self.sess.source_map();\n             let next_pos = sm.lookup_char_pos(self.token.span.lo());\n             let op_pos = sm.lookup_char_pos(sp.hi());\n@@ -515,11 +515,11 @@ impl<'a> Parser<'a> {\n             self.diagnostic()\n                 .struct_span_err(\n                     span,\n-                    &format!(\"unmatched angle bracket{}\", pluralise!(total_num_of_gt)),\n+                    &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n                 )\n                 .span_suggestion(\n                     span,\n-                    &format!(\"remove extra angle bracket{}\", pluralise!(total_num_of_gt)),\n+                    &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 )\n@@ -1088,8 +1088,15 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n-        self.token.is_ident() &&\n-            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n+        (self.token == token::Lt && // `foo:<bar`, likely a typoed turbofish.\n+            self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+        ) ||\n+            self.token.is_ident() &&\n+            match node {\n+                // `foo::` \u2192 `foo:` or `foo.bar::` \u2192 `foo.bar:`\n+                ast::ExprKind::Path(..) | ast::ExprKind::Field(..) => true,\n+                _ => false,\n+            } &&\n             !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n             self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n             self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`", "previous_filename": "src/libsyntax/parse/parser/diagnostics.rs"}, {"sha": "dadb91f8b3c16b52db036800022ef9205067cefe", "filename": "src/librustc_parse/parser/expr.rs", "status": "renamed", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,26 +1,24 @@\n-use super::{Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle, BlockMode};\n+use super::{Parser, Restrictions, PrevTokenKind, TokenType, PathStyle, BlockMode};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n use super::pat::{GateOr, PARAM_EXPECTED};\n use super::diagnostics::Error;\n+use crate::maybe_recover_from_interpolated_ty_qpath;\n \n-use crate::parse::literal::LitError;\n-\n-use crate::ast::{\n+use syntax::ast::{\n     self, DUMMY_NODE_ID, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode,\n     Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm, Ty, TyKind,\n     FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field, Lit,\n };\n-use crate::maybe_recover_from_interpolated_ty_qpath;\n-use crate::parse::classify;\n-use crate::parse::token::{self, Token, TokenKind};\n-use crate::print::pprust;\n-use crate::ptr::P;\n-use crate::source_map::{self, Span};\n-use crate::symbol::{kw, sym};\n-use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n-\n-use errors::Applicability;\n+use syntax::token::{self, Token, TokenKind};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::source_map::{self, Span};\n+use syntax::util::classify;\n+use syntax::util::literal::LitError;\n+use syntax::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n+use syntax_pos::symbol::{kw, sym};\n use syntax_pos::Symbol;\n+use errors::{PResult, Applicability};\n use std::mem;\n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -252,7 +250,7 @@ impl<'a> Parser<'a> {\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                self.sess.gated_spans.type_ascription.borrow_mut().push(lhs.span);\n+                self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n@@ -455,7 +453,7 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span = lo.to(span);\n-                self.sess.gated_spans.box_syntax.borrow_mut().push(span);\n+                self.sess.gated_spans.gate(sym::box_syntax, span);\n                 (span, ExprKind::Box(e))\n             }\n             token::Ident(..) if self.token.is_ident_named(sym::not) => {\n@@ -1045,7 +1043,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let span = lo.to(hi);\n-                    self.sess.gated_spans.yields.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::generators, span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -1116,7 +1114,11 @@ impl<'a> Parser<'a> {\n                 Err(self.span_fatal(token.span, &msg))\n             }\n             Err(err) => {\n-                let (lit, span) = (token.expect_lit(), token.span);\n+                let span = token.span;\n+                let lit = match token.kind {\n+                    token::Literal(lit) => lit,\n+                    _ => unreachable!(),\n+                };\n                 self.bump();\n                 self.error_literal_from_token(err, lit, span);\n                 // Pack possible quotes and prefixes from the original literal into\n@@ -1264,7 +1266,7 @@ impl<'a> Parser<'a> {\n         outer_attrs: ThinVec<Attribute>,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n-            self.sess.gated_spans.label_break_value.borrow_mut().push(label.ident.span);\n+            self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n         }\n \n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -1293,7 +1295,7 @@ impl<'a> Parser<'a> {\n         };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.async_closure.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n@@ -1415,8 +1417,7 @@ impl<'a> Parser<'a> {\n \n         if let ExprKind::Let(..) = cond.kind {\n             // Remove the last feature gating of a `let` expression since it's stable.\n-            let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n-            debug_assert_eq!(cond.span, last.unwrap());\n+            self.sess.gated_spans.ungate_last(sym::let_chains, cond.span);\n         }\n \n         Ok(cond)\n@@ -1433,7 +1434,7 @@ impl<'a> Parser<'a> {\n             |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         )?;\n         let span = lo.to(expr.span);\n-        self.sess.gated_spans.let_chains.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::let_chains, span);\n         Ok(self.mk_expr(span, ExprKind::Let(pat, expr), attrs))\n     }\n \n@@ -1654,7 +1655,7 @@ impl<'a> Parser<'a> {\n             Err(error)\n         } else {\n             let span = span_lo.to(body.span);\n-            self.sess.gated_spans.try_blocks.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::try_blocks, span);\n             Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n         }\n     }", "previous_filename": "src/libsyntax/parse/parser/expr.rs"}, {"sha": "ba5eafc0ed722b200582e0d0332097701370459c", "filename": "src/librustc_parse/parser/generics.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,9 +1,11 @@\n-use super::{Parser, PResult};\n+use super::Parser;\n \n-use crate::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n-use crate::parse::token;\n-use crate::source_map::DUMMY_SP;\n-use crate::symbol::kw;\n+use syntax::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n+use syntax::token;\n+use syntax::source_map::DUMMY_SP;\n+use syntax_pos::symbol::{kw, sym};\n+\n+use errors::PResult;\n \n impl<'a> Parser<'a> {\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -62,7 +64,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.const_generics.borrow_mut().push(lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_span));\n \n         Ok(GenericParam {\n             ident,", "previous_filename": "src/libsyntax/parse/parser/generics.rs"}, {"sha": "3e21436d3136e36d0ade4371757f6a19747ee09c", "filename": "src/librustc_parse/parser/item.rs", "status": "renamed", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,25 +1,25 @@\n-use super::{Parser, PResult, PathStyle};\n+use super::{Parser, PathStyle};\n use super::diagnostics::{Error, dummy_arg, ConsumeClosingDelim};\n \n use crate::maybe_whole;\n-use crate::ptr::P;\n-use crate::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle, AnonConst, Item, ItemKind};\n-use crate::ast::{ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n-use crate::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n-use crate::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n-use crate::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n-use crate::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, MethodSig, SelfKind, Param};\n-use crate::parse::token;\n-use crate::tokenstream::{TokenTree, TokenStream};\n-use crate::symbol::{kw, sym};\n-use crate::source_map::{self, respan, Span};\n-use crate::ThinVec;\n+\n+use syntax::ast::{self, Abi, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n+use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n+use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n+use syntax::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n+use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n+use syntax::ptr::P;\n+use syntax::ThinVec;\n+use syntax::token;\n+use syntax::tokenstream::{TokenTree, TokenStream};\n+use syntax::source_map::{self, respan, Span};\n+use syntax_pos::BytePos;\n+use syntax_pos::symbol::{kw, sym};\n \n use log::debug;\n use std::mem;\n-use rustc_target::spec::abi::Abi;\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n-use syntax_pos::BytePos;\n+use errors::{PResult, Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n /// Whether the type alias or associated type is a concrete type or an opaque type.\n #[derive(Debug)]\n@@ -111,7 +111,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n-            let opt_abi = self.parse_opt_abi()?;\n+            let abi = self.parse_opt_abi()?;\n \n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM\n@@ -120,12 +120,12 @@ impl<'a> Parser<'a> {\n                     unsafety: Unsafety::Normal,\n                     asyncness: respan(fn_span, IsAsync::NotAsync),\n                     constness: respan(fn_span, Constness::NotConst),\n-                    abi: opt_abi.unwrap_or(Abi::C),\n+                    abi,\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return Ok(Some(\n-                    self.parse_item_foreign_mod(lo, opt_abi, vis, attrs, extern_sp)?,\n+                    self.parse_item_foreign_mod(lo, abi, vis, attrs, extern_sp)?,\n                 ));\n             }\n \n@@ -147,9 +147,7 @@ impl<'a> Parser<'a> {\n                 let unsafety = self.parse_unsafety();\n \n                 if self.check_keyword(kw::Extern) {\n-                    self.sess.gated_spans.const_extern_fn.borrow_mut().push(\n-                        lo.to(self.token.span)\n-                    );\n+                    self.sess.gated_spans.gate(sym::const_extern_fn, lo.to(self.token.span));\n                 }\n                 let abi = self.parse_extern_abi()?;\n                 self.bump(); // `fn`\n@@ -201,7 +199,7 @@ impl<'a> Parser<'a> {\n                     unsafety,\n                     asyncness,\n                     constness: respan(fn_span, Constness::NotConst),\n-                    abi: Abi::Rust,\n+                    abi: Abi::new(sym::Rust, fn_span),\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             }\n@@ -238,7 +236,7 @@ impl<'a> Parser<'a> {\n                 unsafety: Unsafety::Normal,\n                 asyncness: respan(fn_span, IsAsync::NotAsync),\n                 constness: respan(fn_span, Constness::NotConst),\n-                abi: Abi::Rust,\n+                abi: Abi::new(sym::Rust, fn_span),\n             };\n             return self.parse_item_fn(lo, vis, attrs, header);\n         }\n@@ -483,12 +481,14 @@ impl<'a> Parser<'a> {\n     /// Emits an expected-item-after-attributes error.\n     fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a,  ()> {\n         let message = match attrs.last() {\n-            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n-            _ => \"expected item after attributes\",\n+            Some(&Attribute { kind: AttrKind::DocComment(_), .. }) =>\n+                \"expected item after doc comment\",\n+            _ =>\n+                \"expected item after attributes\",\n         };\n \n         let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n-        if attrs.last().unwrap().is_sugared_doc {\n+        if attrs.last().unwrap().is_doc_comment() {\n             err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n         }\n         Err(err)\n@@ -830,7 +830,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n \n-            self.sess.gated_spans.trait_alias.borrow_mut().push(whole_span);\n+            self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n             Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n         } else {\n@@ -1113,15 +1113,13 @@ impl<'a> Parser<'a> {\n     fn parse_item_foreign_mod(\n         &mut self,\n         lo: Span,\n-        opt_abi: Option<Abi>,\n+        abi: Abi,\n         visibility: Visibility,\n         mut attrs: Vec<Attribute>,\n         extern_sp: Span,\n     ) -> PResult<'a, P<Item>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n-        let abi = opt_abi.unwrap_or(Abi::C);\n-\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let mut foreign_items = vec![];\n@@ -1712,7 +1710,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_span);\n \n         if !def.legacy {\n-            self.sess.gated_spans.decl_macro.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::decl_macro, span);\n         }\n \n         Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n@@ -1799,11 +1797,11 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Option<P<Item>>> {\n         let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n             is_self_allowed: false,\n-            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            allow_c_variadic: header.abi.symbol == sym::C && header.unsafety == Unsafety::Unsafe,\n             is_name_required: |_| true,\n         })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let kind = ItemKind::Fn(decl, header, generics, body);\n+        let kind = ItemKind::Fn(FnSig { decl, header }, generics, body);\n         self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n     }\n \n@@ -1900,14 +1898,14 @@ impl<'a> Parser<'a> {\n     fn parse_method_sig(\n         &mut self,\n         is_name_required: fn(&token::Token) -> bool,\n-    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n+    ) -> PResult<'a, (Ident, FnSig, Generics)> {\n         let header = self.parse_fn_front_matter()?;\n         let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n             is_self_allowed: true,\n             allow_c_variadic: false,\n             is_name_required,\n         })?;\n-        Ok((ident, MethodSig { header, decl }, generics))\n+        Ok((ident, FnSig { header, decl }, generics))\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -1928,7 +1926,7 @@ impl<'a> Parser<'a> {\n         let asyncness = respan(self.prev_span, asyncness);\n         let unsafety = self.parse_unsafety();\n         let (constness, unsafety, abi) = if is_const_fn {\n-            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n+            (respan(const_span, Constness::Const), unsafety, Abi::default())\n         } else {\n             let abi = self.parse_extern_abi()?;\n             (respan(self.prev_span, Constness::NotConst), unsafety, abi)", "previous_filename": "src/libsyntax/parse/parser/item.rs"}, {"sha": "a491d91e20fb23ecdd4def6449993e651671d31e", "filename": "src/librustc_parse/parser/mod.rs", "status": "renamed", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -11,25 +11,26 @@ mod generics;\n mod diagnostics;\n use diagnostics::Error;\n \n-use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n+use crate::{Directory, DirectoryOwnership};\n+use crate::lexer::UnmatchedBrace;\n+\n+use syntax::ast::{\n+    self, Abi, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n };\n-use crate::parse::{PResult, Directory, DirectoryOwnership};\n-use crate::parse::lexer::UnmatchedBrace;\n-use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use crate::parse::token::{self, Token, TokenKind, DelimToken};\n-use crate::print::pprust;\n-use crate::ptr::P;\n-use crate::sess::ParseSess;\n-use crate::source_map::respan;\n-use crate::symbol::{kw, sym, Symbol};\n-use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n-use crate::ThinVec;\n-\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n-use rustc_target::spec::abi::{self, Abi};\n+\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::token::{self, Token, TokenKind, DelimToken};\n+use syntax::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n+use syntax::sess::ParseSess;\n+use syntax::source_map::respan;\n+use syntax::struct_span_err;\n+use syntax::util::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, BytePos, DUMMY_SP, FileName};\n+use rustc_data_structures::thin_vec::ThinVec;\n+use errors::{PResult, Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use log::debug;\n \n use std::borrow::Cow;\n@@ -209,12 +210,12 @@ impl TokenCursor {\n         loop {\n             let tree = if !self.frame.open_delim {\n                 self.frame.open_delim = true;\n-                TokenTree::open_tt(self.frame.span.open, self.frame.delim)\n+                TokenTree::open_tt(self.frame.span, self.frame.delim)\n             } else if let Some(tree) = self.frame.tree_cursor.next() {\n                 tree\n             } else if !self.frame.close_delim {\n                 self.frame.close_delim = true;\n-                TokenTree::close_tt(self.frame.span.close, self.frame.delim)\n+                TokenTree::close_tt(self.frame.span, self.frame.delim)\n             } else if let Some(frame) = self.stack.pop() {\n                 self.frame = frame;\n                 continue\n@@ -1121,7 +1122,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            self.sess.gated_spans.crate_visibility_modifier.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_span);\n             return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n@@ -1206,48 +1207,41 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    /// Parses `extern` followed by an optional ABI string, or nothing.\n+    /// Parses `extern string_literal?`.\n+    /// If `extern` is not found, the Rust ABI is used.\n+    /// If `extern` is found and a `string_literal` does not follow, the C ABI is used.\n     fn parse_extern_abi(&mut self) -> PResult<'a, Abi> {\n-        if self.eat_keyword(kw::Extern) {\n-            Ok(self.parse_opt_abi()?.unwrap_or(Abi::C))\n+        Ok(if self.eat_keyword(kw::Extern) {\n+            self.parse_opt_abi()?\n         } else {\n-            Ok(Abi::Rust)\n-        }\n+            Abi::default()\n+        })\n     }\n \n-    /// Parses a string as an ABI spec on an extern type or module. Consumes\n-    /// the `extern` keyword, if one is found.\n-    fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n-        match self.token.kind {\n-            token::Literal(token::Lit { kind: token::Str, symbol, suffix }) |\n-            token::Literal(token::Lit { kind: token::StrRaw(..), symbol, suffix }) => {\n-                self.expect_no_suffix(self.token.span, \"an ABI spec\", suffix);\n-                self.bump();\n-                match abi::lookup(&symbol.as_str()) {\n-                    Some(abi) => Ok(Some(abi)),\n-                    None => {\n-                        self.error_on_invalid_abi(symbol);\n-                        Ok(None)\n-                    }\n+    /// Parses a string literal as an ABI spec.\n+    /// If one is not found, the \"C\" ABI is used.\n+    fn parse_opt_abi(&mut self) -> PResult<'a, Abi> {\n+        let span = if self.token.can_begin_literal_or_bool() {\n+            let ast::Lit { span, kind, .. } = self.parse_lit()?;\n+            match kind {\n+                ast::LitKind::Str(symbol, _) => return Ok(Abi::new(symbol, span)),\n+                ast::LitKind::Err(_) => {}\n+                _ => {\n+                    self.struct_span_err(span, \"non-string ABI literal\")\n+                        .span_suggestion(\n+                            span,\n+                            \"specify the ABI with a string literal\",\n+                            \"\\\"C\\\"\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n                 }\n             }\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    /// Emit an error where `symbol` is an invalid ABI.\n-    fn error_on_invalid_abi(&self, symbol: Symbol) {\n-        let prev_span = self.prev_span;\n-        struct_span_err!(\n-            self.sess.span_diagnostic,\n-            prev_span,\n-            E0703,\n-            \"invalid ABI: found `{}`\",\n-            symbol\n-        )\n-        .span_label(prev_span, \"invalid ABI\")\n-        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-        .emit();\n+            span\n+        } else {\n+            self.prev_span\n+        };\n+        Ok(Abi::new(sym::C, span))\n     }\n \n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error.", "previous_filename": "src/libsyntax/parse/parser.rs"}, {"sha": "3110f15e80b6ed80a49693dbc14b6ca66f99855c", "filename": "src/librustc_parse/parser/module.rs", "status": "renamed", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,13 +1,16 @@\n-use super::{Parser, PResult};\n+use super::Parser;\n use super::item::ItemInfo;\n use super::diagnostics::Error;\n \n-use crate::attr;\n-use crate::ast::{self, Ident, Attribute, ItemKind, Mod, Crate};\n-use crate::parse::{new_sub_parser_from_file, DirectoryOwnership};\n-use crate::parse::token::{self, TokenKind};\n-use crate::source_map::{SourceMap, Span, DUMMY_SP, FileName};\n-use crate::symbol::sym;\n+use crate::{new_sub_parser_from_file, DirectoryOwnership};\n+\n+use syntax::attr;\n+use syntax::ast::{self, Ident, Attribute, ItemKind, Mod, Crate};\n+use syntax::token::{self, TokenKind};\n+use syntax::source_map::{SourceMap, Span, DUMMY_SP, FileName};\n+\n+use syntax_pos::symbol::sym;\n+use errors::PResult;\n \n use std::path::{self, Path, PathBuf};\n \n@@ -21,7 +24,6 @@ pub(super) struct ModulePath {\n pub(super) struct ModulePathSuccess {\n     pub path: PathBuf,\n     pub directory_ownership: DirectoryOwnership,\n-    warn: bool,\n }\n \n impl<'a> Parser<'a> {\n@@ -38,34 +40,22 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     pub(super) fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n-        let (in_cfg, outer_attrs) = {\n-            // FIXME(Centril): This results in a cycle between config and parsing.\n-            // Consider using dynamic dispatch via `self.sess` to disentangle the knot.\n-            let mut strip_unconfigured = crate::config::StripUnconfigured {\n-                sess: self.sess,\n-                features: None, // Don't perform gated feature checking.\n-            };\n-            let mut outer_attrs = outer_attrs.to_owned();\n-            strip_unconfigured.process_cfg_attrs(&mut outer_attrs);\n-            (!self.cfg_mods || strip_unconfigured.in_cfg(&outer_attrs), outer_attrs)\n-        };\n+        // HACK(Centril): See documentation on `ParseSess::process_cfg_mod`.\n+        let (in_cfg, outer_attrs) = (self.sess.process_cfg_mod)(\n+            self.sess,\n+            self.cfg_mods,\n+            outer_attrs,\n+        );\n \n         let id_span = self.token.span;\n         let id = self.parse_ident()?;\n         if self.eat(&token::Semi) {\n             if in_cfg && self.recurse_into_file_modules {\n                 // This mod is in an external file. Let's go get it!\n-                let ModulePathSuccess { path, directory_ownership, warn } =\n+                let ModulePathSuccess { path, directory_ownership } =\n                     self.submod_path(id, &outer_attrs, id_span)?;\n-                let (module, mut attrs) =\n+                let (module, attrs) =\n                     self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n-                // Record that we fetched the mod from an external file.\n-                if warn {\n-                    let attr = attr::mk_attr_outer(\n-                        attr::mk_word_item(Ident::with_dummy_span(sym::warn_directory_ownership)));\n-                    attr::mark_known(&attr);\n-                    attrs.push(attr);\n-                }\n                 Ok((id, ItemKind::Mod(module), Some(attrs)))\n             } else {\n                 let placeholder = ast::Mod {\n@@ -136,17 +126,16 @@ impl<'a> Parser<'a> {\n                     // `#[path]` included and contains a `mod foo;` declaration.\n                     // If you encounter this, it's your own darn fault :P\n                     Some(_) => DirectoryOwnership::Owned { relative: None },\n-                    _ => DirectoryOwnership::UnownedViaMod(true),\n+                    _ => DirectoryOwnership::UnownedViaMod,\n                 },\n                 path,\n-                warn: false,\n             });\n         }\n \n         let relative = match self.directory.ownership {\n             DirectoryOwnership::Owned { relative } => relative,\n             DirectoryOwnership::UnownedViaBlock |\n-            DirectoryOwnership::UnownedViaMod(_) => None,\n+            DirectoryOwnership::UnownedViaMod => None,\n         };\n         let paths = Parser::default_submod_path(\n                         id, relative, &self.directory.path, self.sess.source_map());\n@@ -167,12 +156,7 @@ impl<'a> Parser<'a> {\n                 }\n                 Err(err)\n             }\n-            DirectoryOwnership::UnownedViaMod(warn) => {\n-                if warn {\n-                    if let Ok(result) = paths.result {\n-                        return Ok(ModulePathSuccess { warn: true, ..result });\n-                    }\n-                }\n+            DirectoryOwnership::UnownedViaMod => {\n                 let mut err = self.diagnostic().struct_span_err(id_sp,\n                     \"cannot declare a new module at this location\");\n                 if !id_sp.is_dummy() {\n@@ -210,7 +194,7 @@ impl<'a> Parser<'a> {\n             // `/` to `\\`.\n             #[cfg(windows)]\n             let s = s.replace(\"/\", \"\\\\\");\n-            Some(dir_path.join(s))\n+            Some(dir_path.join(&*s))\n         } else {\n             None\n         }\n@@ -229,7 +213,7 @@ impl<'a> Parser<'a> {\n         // `./<id>.rs` and `./<id>/mod.rs`.\n         let relative_prefix_string;\n         let relative_prefix = if let Some(ident) = relative {\n-            relative_prefix_string = format!(\"{}{}\", ident.as_str(), path::MAIN_SEPARATOR);\n+            relative_prefix_string = format!(\"{}{}\", ident, path::MAIN_SEPARATOR);\n             &relative_prefix_string\n         } else {\n             \"\"\n@@ -250,14 +234,12 @@ impl<'a> Parser<'a> {\n                 directory_ownership: DirectoryOwnership::Owned {\n                     relative: Some(id),\n                 },\n-                warn: false,\n             }),\n             (false, true) => Ok(ModulePathSuccess {\n                 path: secondary_path,\n                 directory_ownership: DirectoryOwnership::Owned {\n                     relative: None,\n                 },\n-                warn: false,\n             }),\n             (false, false) => Err(Error::FileNotFoundForModule {\n                 mod_name: mod_name.clone(),\n@@ -314,7 +296,7 @@ impl<'a> Parser<'a> {\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            self.directory.path.to_mut().push(&path.as_str());\n+            self.directory.path.to_mut().push(&*path.as_str());\n             self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n         } else {\n             // We have to push on the current module name in the case of relative\n@@ -325,10 +307,10 @@ impl<'a> Parser<'a> {\n             // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n             if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n                 if let Some(ident) = relative.take() { // remove the relative offset\n-                    self.directory.path.to_mut().push(ident.as_str());\n+                    self.directory.path.to_mut().push(&*ident.as_str());\n                 }\n             }\n-            self.directory.path.to_mut().push(&id.as_str());\n+            self.directory.path.to_mut().push(&*id.as_str());\n         }\n     }\n }", "previous_filename": "src/libsyntax/parse/parser/module.rs"}, {"sha": "b068a4f16a533dde86713a99675d0a8f30bb3a2c", "filename": "src/librustc_parse/parser/pat.rs", "status": "renamed", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,17 +1,15 @@\n-use super::{Parser, PResult, PathStyle};\n-\n+use super::{Parser, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n-use crate::ptr::P;\n-use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n-use crate::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n-use crate::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n-use crate::parse::token::{self};\n-use crate::print::pprust;\n-use crate::source_map::{respan, Span, Spanned};\n-use crate::symbol::kw;\n-use crate::ThinVec;\n-\n-use errors::{Applicability, DiagnosticBuilder};\n+use syntax::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n+use syntax::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n+use syntax::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n+use syntax::ptr::P;\n+use syntax::print::pprust;\n+use syntax::ThinVec;\n+use syntax::token;\n+use syntax::source_map::{respan, Span, Spanned};\n+use syntax_pos::symbol::{kw, sym};\n+use errors::{PResult, Applicability, DiagnosticBuilder};\n \n type Expected = Option<&'static str>;\n \n@@ -52,11 +50,8 @@ impl<'a> Parser<'a> {\n         // and no other gated or-pattern has been parsed thus far,\n         // then we should really gate the leading `|`.\n         // This complicated procedure is done purely for diagnostics UX.\n-        if gated_leading_vert {\n-            let mut or_pattern_spans = self.sess.gated_spans.or_patterns.borrow_mut();\n-            if or_pattern_spans.is_empty() {\n-                or_pattern_spans.push(leading_vert_span);\n-            }\n+        if gated_leading_vert && self.sess.gated_spans.is_ungated(sym::or_patterns) {\n+            self.sess.gated_spans.gate(sym::or_patterns, leading_vert_span);\n         }\n \n         Ok(pat)\n@@ -117,7 +112,7 @@ impl<'a> Parser<'a> {\n \n         // Feature gate the or-pattern if instructed:\n         if gate_or == GateOr::Yes {\n-            self.sess.gated_spans.or_patterns.borrow_mut().push(or_pattern_span);\n+            self.sess.gated_spans.gate(sym::or_patterns, or_pattern_span);\n         }\n \n         Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n@@ -325,7 +320,7 @@ impl<'a> Parser<'a> {\n             } else if self.eat_keyword(kw::Box) {\n                 // Parse `box pat`\n                 let pat = self.parse_pat_with_range_pat(false, None)?;\n-                self.sess.gated_spans.box_patterns.borrow_mut().push(lo.to(self.prev_span));\n+                self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n                 PatKind::Box(pat)\n             } else if self.can_be_ident_pat() {\n                 // Parse `ident @ pat`\n@@ -612,7 +607,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn excluded_range_end(&self, span: Span) -> RangeEnd {\n-        self.sess.gated_spans.exclusive_range_pattern.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::exclusive_range_pattern, span);\n         RangeEnd::Excluded\n     }\n ", "previous_filename": "src/libsyntax/parse/parser/pat.rs"}, {"sha": "68307440712a870f9b07bb07494e2c1aa6eaafe7", "filename": "src/librustc_parse/parser/path.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,15 +1,15 @@\n-use super::{Parser, PResult, TokenType};\n-\n-use crate::{maybe_whole, ThinVec};\n-use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n-use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use crate::parse::token::{self, Token};\n-use crate::source_map::{Span, BytePos};\n-use crate::symbol::kw;\n+use super::{Parser, TokenType};\n+use crate::maybe_whole;\n+use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n+use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use syntax::ThinVec;\n+use syntax::token::{self, Token};\n+use syntax::source_map::{Span, BytePos};\n+use syntax_pos::symbol::{kw, sym};\n \n use std::mem;\n use log::debug;\n-use errors::{Applicability, pluralise};\n+use errors::{PResult, Applicability, pluralize};\n \n /// Specifies how to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n@@ -368,14 +368,14 @@ impl<'a> Parser<'a> {\n                         span,\n                         &format!(\n                             \"unmatched angle bracket{}\",\n-                            pluralise!(snapshot.unmatched_angle_bracket_count)\n+                            pluralize!(snapshot.unmatched_angle_bracket_count)\n                         ),\n                     )\n                     .span_suggestion(\n                         span,\n                         &format!(\n                             \"remove extra angle bracket{}\",\n-                            pluralise!(snapshot.unmatched_angle_bracket_count)\n+                            pluralize!(snapshot.unmatched_angle_bracket_count)\n                         ),\n                         String::new(),\n                         Applicability::MachineApplicable,\n@@ -426,7 +426,7 @@ impl<'a> Parser<'a> {\n \n                 // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                 if let AssocTyConstraintKind::Bound { .. } = kind {\n-                    self.sess.gated_spans.associated_type_bounds.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                 }\n \n                 constraints.push(AssocTyConstraint {", "previous_filename": "src/libsyntax/parse/parser/path.rs"}, {"sha": "a5f20691d077c761859dea833492ccbda4eab8f9", "filename": "src/librustc_parse/parser/stmt.rs", "status": "renamed", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,20 +1,23 @@\n-use super::{Parser, PResult, Restrictions, PrevTokenKind, SemiColonMode, BlockMode};\n+use super::{Parser, Restrictions, PrevTokenKind, SemiColonMode, BlockMode};\n use super::expr::LhsExpr;\n use super::path::PathStyle;\n use super::pat::GateOr;\n use super::diagnostics::Error;\n-\n-use crate::ptr::P;\n-use crate::{maybe_whole, ThinVec};\n-use crate::ast::{self, DUMMY_NODE_ID, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n-use crate::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac, MacDelimiter};\n-use crate::parse::{classify, DirectoryOwnership};\n-use crate::parse::token;\n-use crate::source_map::{respan, Span};\n-use crate::symbol::{kw, sym};\n+use crate::maybe_whole;\n+use crate::DirectoryOwnership;\n+\n+use syntax::ThinVec;\n+use syntax::ptr::P;\n+use syntax::ast;\n+use syntax::ast::{DUMMY_NODE_ID, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n+use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac, MacDelimiter};\n+use syntax::util::classify;\n+use syntax::token;\n+use syntax::source_map::{respan, Span};\n+use syntax::symbol::{kw, sym};\n \n use std::mem;\n-use errors::Applicability;\n+use errors::{PResult, Applicability};\n \n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n@@ -397,6 +400,7 @@ impl<'a> Parser<'a> {\n             }\n             let stmt = match self.parse_full_stmt(false) {\n                 Err(mut err) => {\n+                    self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(Stmt {", "previous_filename": "src/libsyntax/parse/parser/stmt.rs"}, {"sha": "fccabee24047f638b4e0f30b2e0f16b50746ba46", "filename": "src/librustc_parse/parser/ty.rs", "status": "renamed", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,16 +1,18 @@\n-use super::{Parser, PResult, PathStyle, PrevTokenKind, TokenType};\n+use super::{Parser, PathStyle, PrevTokenKind, TokenType};\n use super::item::ParamCfg;\n \n use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n-use crate::ptr::P;\n-use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n-use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n-use crate::ast::{Mutability, AnonConst, Mac};\n-use crate::parse::token::{self, Token};\n-use crate::source_map::Span;\n-use crate::symbol::{kw};\n \n-use errors::{Applicability, pluralise};\n+use syntax::ptr::P;\n+use syntax::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n+use syntax::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n+use syntax::ast::{Mutability, AnonConst, Mac};\n+use syntax::token::{self, Token};\n+use syntax::source_map::Span;\n+use syntax::struct_span_fatal;\n+use syntax_pos::symbol::kw;\n+\n+use errors::{PResult, Applicability, pluralize};\n \n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n /// `IDENT<<u8 as Trait>::AssocTy>`.\n@@ -412,7 +414,7 @@ impl<'a> Parser<'a> {\n                 }\n                 err.span_suggestion_hidden(\n                     bound_list,\n-                    &format!(\"remove the trait bound{}\", pluralise!(negative_bounds_len)),\n+                    &format!(\"remove the trait bound{}\", pluralize!(negative_bounds_len)),\n                     new_bound_list,\n                     Applicability::MachineApplicable,\n                 );", "previous_filename": "src/libsyntax/parse/parser/ty.rs"}, {"sha": "bbe0dc1c35f1b8407113785e4bd7fb736bf50cf1", "filename": "src/librustc_parse/validate_attr.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,111 @@\n+//! Meta-syntax validation logic of attributes for post-expansion.\n+\n+use errors::{PResult, Applicability};\n+use syntax::ast::{self, Attribute, AttrKind, Ident, MetaItem};\n+use syntax::attr::{AttributeTemplate, mk_name_value_item_str};\n+use syntax::early_buffered_lints::BufferedEarlyLintId;\n+use syntax::feature_gate::BUILTIN_ATTRIBUTE_MAP;\n+use syntax::token;\n+use syntax::tokenstream::TokenTree;\n+use syntax::sess::ParseSess;\n+use syntax_pos::{Symbol, sym};\n+\n+pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n+    let attr_info =\n+        attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).map(|a| **a);\n+\n+    // Check input tokens for built-in and key-value attributes.\n+    match attr_info {\n+        // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n+        Some((name, _, template, _)) if name != sym::rustc_dummy =>\n+            check_builtin_attribute(sess, attr, name, template),\n+        _ => if let Some(TokenTree::Token(token)) = attr.get_normal_item().tokens.trees().next() {\n+            if token == token::Eq {\n+                // All key-value attributes are restricted to meta-item syntax.\n+                parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n+            }\n+        }\n+    }\n+}\n+\n+pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, MetaItem> {\n+    Ok(match attr.kind {\n+        AttrKind::Normal(ref item) => MetaItem {\n+            path: item.path.clone(),\n+            kind: super::parse_in_attr(sess, attr, |p| p.parse_meta_item_kind())?,\n+            span: attr.span,\n+        },\n+        AttrKind::DocComment(comment) => {\n+            mk_name_value_item_str(Ident::new(sym::doc, attr.span), comment, attr.span)\n+        }\n+    })\n+}\n+\n+pub fn check_builtin_attribute(\n+    sess: &ParseSess,\n+    attr: &Attribute,\n+    name: Symbol,\n+    template: AttributeTemplate,\n+) {\n+    // Some special attributes like `cfg` must be checked\n+    // before the generic check, so we skip them here.\n+    let should_skip = |name| name == sym::cfg;\n+    // Some of previously accepted forms were used in practice,\n+    // report them as warnings for now.\n+    let should_warn = |name| name == sym::doc || name == sym::ignore ||\n+                             name == sym::inline || name == sym::link ||\n+                             name == sym::test || name == sym::bench;\n+\n+    match parse_meta(sess, attr) {\n+        Ok(meta) => if !should_skip(name) && !template.compatible(&meta.kind) {\n+            let error_msg = format!(\"malformed `{}` attribute input\", name);\n+            let mut msg = \"attribute must be of the form \".to_owned();\n+            let mut suggestions = vec![];\n+            let mut first = true;\n+            if template.word {\n+                first = false;\n+                let code = format!(\"#[{}]\", name);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.list {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                first = false;\n+                let code = format!(\"#[{}({})]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.name_value_str {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if should_warn(name) {\n+                sess.buffer_lint(\n+                    BufferedEarlyLintId::IllFormedAttributeInput,\n+                    meta.span,\n+                    ast::CRATE_NODE_ID,\n+                    &msg,\n+                );\n+            } else {\n+                sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n+                    .span_suggestions(\n+                        meta.span,\n+                        if suggestions.len() == 1 {\n+                            \"must be of the form\"\n+                        } else {\n+                            \"the following are the possible correct uses\"\n+                        },\n+                        suggestions.into_iter(),\n+                        Applicability::HasPlaceholders,\n+                    ).emit();\n+            }\n+        }\n+        Err(mut err) => err.emit(),\n+    }\n+}"}, {"sha": "556189208f1c25d848fe320079fc6db08dcbde71", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -12,8 +12,9 @@ path = \"lib.rs\"\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_parse = { path = \"../librustc_parse\" }\n+rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n-rustc_target = { path = \"../librustc_target\" }\n-rustc_index = { path = \"../librustc_index\" }"}, {"sha": "ec5572914d8ee55968822588322a7839aada1fd6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 30, "deletions": 118, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -7,55 +7,30 @@\n // or type checking or some other kind of complex analysis.\n \n use std::mem;\n-use syntax::print::pprust;\n use rustc::lint;\n-use rustc::lint::builtin::{BuiltinLintDiagnostics, NESTED_IMPL_TRAIT};\n use rustc::session::Session;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_parse::validate_attr;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::expand::is_proc_macro_attr;\n use syntax::feature_gate::is_builtin_attr;\n+use syntax::print::pprust;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n use syntax_pos::{Span, MultiSpan};\n use errors::{Applicability, FatalError};\n \n-#[derive(Copy, Clone, Debug)]\n-struct OuterImplTrait {\n-    span: Span,\n-\n-    /// rust-lang/rust#57979: a bug in original implementation caused\n-    /// us to fail sometimes to record an outer `impl Trait`.\n-    /// Therefore, in order to reliably issue a warning (rather than\n-    /// an error) in the *precise* places where we are newly injecting\n-    /// the diagnostic, we have to distinguish between the places\n-    /// where the outer `impl Trait` has always been recorded, versus\n-    /// the places where it has only recently started being recorded.\n-    only_recorded_since_pull_request_57730: bool,\n-}\n-\n-impl OuterImplTrait {\n-    /// This controls whether we should downgrade the nested impl\n-    /// trait diagnostic to a warning rather than an error, based on\n-    /// whether the outer impl trait had been improperly skipped in\n-    /// earlier implementations of the analysis on the stable\n-    /// compiler.\n-    fn should_warn_instead_of_error(&self) -> bool {\n-        self.only_recorded_since_pull_request_57730\n-    }\n-}\n-\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     /// Nested `impl Trait` _is_ allowed in associated type position,\n     /// e.g., `impl Iterator<Item = impl Debug>`.\n-    outer_impl_trait: Option<OuterImplTrait>,\n+    outer_impl_trait: Option<Span>,\n \n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     /// or `Foo::Bar<impl Trait>`\n@@ -65,26 +40,10 @@ struct AstValidator<'a> {\n     /// certain positions.\n     is_assoc_ty_bound_banned: bool,\n \n-    /// rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n-    /// until PRs #57730 and #57981 landed: it would jump directly to\n-    /// walk_ty rather than visit_ty (or skip recurring entirely for\n-    /// impl trait in projections), and thus miss some cases. We track\n-    /// whether we should downgrade to a warning for short-term via\n-    /// these booleans.\n-    warning_period_57979_didnt_record_next_impl_trait: bool,\n-    warning_period_57979_impl_trait_in_proj: bool,\n-\n     lint_buffer: &'a mut lint::LintBuffer,\n }\n \n impl<'a> AstValidator<'a> {\n-    fn with_impl_trait_in_proj_warning<T>(&mut self, v: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let old = mem::replace(&mut self.warning_period_57979_impl_trait_in_proj, v);\n-        let ret = f(self);\n-        self.warning_period_57979_impl_trait_in_proj = old;\n-        ret\n-    }\n-\n     fn with_banned_impl_trait(&mut self, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.is_impl_trait_banned, true);\n         f(self);\n@@ -97,22 +56,15 @@ impl<'a> AstValidator<'a> {\n         self.is_assoc_ty_bound_banned = old;\n     }\n \n-    fn with_impl_trait(&mut self, outer: Option<OuterImplTrait>, f: impl FnOnce(&mut Self)) {\n+    fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         f(self);\n         self.outer_impl_trait = old;\n     }\n \n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n         match constraint.kind {\n-            AssocTyConstraintKind::Equality { ref ty } => {\n-                // rust-lang/rust#57979: bug in old `visit_generic_args` called\n-                // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n-                // if it happened to occur at `ty`.\n-                if let TyKind::ImplTrait(..) = ty.kind {\n-                    self.warning_period_57979_didnt_record_next_impl_trait = true;\n-                }\n-            }\n+            AssocTyConstraintKind::Equality { .. } => {}\n             AssocTyConstraintKind::Bound { .. } => {\n                 if self.is_assoc_ty_bound_banned {\n                     self.err_handler().span_err(constraint.span,\n@@ -124,37 +76,11 @@ impl<'a> AstValidator<'a> {\n         self.visit_assoc_ty_constraint(constraint);\n     }\n \n-    fn visit_ty_from_generic_args(&mut self, ty: &'a Ty) {\n-        // rust-lang/rust#57979: bug in old `visit_generic_args` called\n-        // `walk_ty` rather than `visit_ty`, skippping outer `impl Trait`\n-        // if it happened to occur at `ty`.\n-        if let TyKind::ImplTrait(..) = ty.kind {\n-            self.warning_period_57979_didnt_record_next_impl_trait = true;\n-        }\n-        self.visit_ty(ty);\n-    }\n-\n-    fn outer_impl_trait(&mut self, span: Span) -> OuterImplTrait {\n-        let only_recorded_since_pull_request_57730 =\n-            self.warning_period_57979_didnt_record_next_impl_trait;\n-\n-        // (This flag is designed to be set to `true`, and then only\n-        // reach the construction point for the outer impl trait once,\n-        // so its safe and easiest to unconditionally reset it to\n-        // false.)\n-        self.warning_period_57979_didnt_record_next_impl_trait = false;\n-\n-        OuterImplTrait {\n-            span, only_recorded_since_pull_request_57730,\n-        }\n-    }\n-\n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n         match t.kind {\n             TyKind::ImplTrait(..) => {\n-                let outer_impl_trait = self.outer_impl_trait(t.span);\n-                self.with_impl_trait(Some(outer_impl_trait), |this| visit::walk_ty(this, t))\n+                self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n             TyKind::Path(ref qself, ref path) => {\n                 // We allow these:\n@@ -328,7 +254,7 @@ impl<'a> AstValidator<'a> {\n                 let arr = [sym::allow, sym::cfg, sym::cfg_attr, sym::deny, sym::forbid, sym::warn];\n                 !arr.contains(&attr.name_or_empty()) && is_builtin_attr(attr)\n             })\n-            .for_each(|attr| if attr.is_sugared_doc {\n+            .for_each(|attr| if attr.is_doc_comment() {\n                 let mut err = self.err_handler().struct_span_err(\n                     attr.span,\n                     \"documentation comments cannot be applied to function parameters\"\n@@ -444,6 +370,10 @@ fn validate_generics_order<'a>(\n }\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        validate_attr::check_meta(&self.session.parse_sess, attr);\n+    }\n+\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match &expr.kind {\n             ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n@@ -484,40 +414,29 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             TyKind::ImplTrait(_, ref bounds) => {\n                 if self.is_impl_trait_banned {\n-                    if self.warning_period_57979_impl_trait_in_proj {\n-                        self.lint_buffer.buffer_lint(\n-                            NESTED_IMPL_TRAIT, ty.id, ty.span,\n-                            \"`impl Trait` is not allowed in path parameters\");\n-                    } else {\n-                        struct_span_err!(self.session, ty.span, E0667,\n-                            \"`impl Trait` is not allowed in path parameters\").emit();\n-                    }\n+                    struct_span_err!(\n+                        self.session, ty.span, E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit();\n                 }\n \n-                if let Some(outer_impl_trait) = self.outer_impl_trait {\n-                    if outer_impl_trait.should_warn_instead_of_error() {\n-                        self.lint_buffer.buffer_lint_with_diagnostic(\n-                            NESTED_IMPL_TRAIT, ty.id, ty.span,\n-                            \"nested `impl Trait` is not allowed\",\n-                            BuiltinLintDiagnostics::NestedImplTrait {\n-                                outer_impl_trait_span: outer_impl_trait.span,\n-                                inner_impl_trait_span: ty.span,\n-                            });\n-                    } else {\n-                        struct_span_err!(self.session, ty.span, E0666,\n-                            \"nested `impl Trait` is not allowed\")\n-                            .span_label(outer_impl_trait.span, \"outer `impl Trait`\")\n-                            .span_label(ty.span, \"nested `impl Trait` here\")\n-                            .emit();\n-                    }\n+                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n+                    struct_span_err!(\n+                        self.session, ty.span, E0666,\n+                        \"nested `impl Trait` is not allowed\"\n+                    )\n+                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n+                    .span_label(ty.span, \"nested `impl Trait` here\")\n+                    .emit();\n                 }\n \n                 if !bounds.iter()\n                           .any(|b| if let GenericBound::Trait(..) = *b { true } else { false }) {\n                     self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n                 }\n \n-                self.with_impl_trait_in_proj_warning(true, |this| this.walk_ty(ty));\n+                self.walk_ty(ty);\n                 return;\n             }\n             _ => {}\n@@ -575,12 +494,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         .note(\"only trait implementations may be annotated with default\").emit();\n                 }\n             }\n-            ItemKind::Fn(ref decl, ref header, ref generics, _) => {\n-                self.visit_fn_header(header);\n-                self.check_fn_decl(decl);\n+            ItemKind::Fn(ref sig, ref generics, _) => {\n+                self.visit_fn_header(&sig.header);\n+                self.check_fn_decl(&sig.decl);\n                 // We currently do not permit const generics in `const fn`, as\n                 // this is tantamount to allowing compile-time dependent typing.\n-                if header.constness.node == Constness::Const {\n+                if sig.header.constness.node == Constness::Const {\n                     // Look for const generics and error if we find any.\n                     for param in &generics.params {\n                         match param.kind {\n@@ -654,11 +573,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, sym::path);\n-                if attr::contains_name(&item.attrs, sym::warn_directory_ownership) {\n-                    let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n-                    let msg = \"cannot declare a new module at this location\";\n-                    self.lint_buffer.buffer_lint(lint, item.id, item.span, msg);\n-                }\n             }\n             ItemKind::Union(ref vdata, _) => {\n                 if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {\n@@ -731,7 +645,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 if let Some(ref type_) = data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n                     // so it is also allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(None, |this| this.visit_ty_from_generic_args(type_));\n+                    self.with_impl_trait(None, |this| this.visit_ty(type_));\n                 }\n             }\n         }\n@@ -849,8 +763,6 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut lint::LintBuffe\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n-        warning_period_57979_didnt_record_next_impl_trait: false,\n-        warning_period_57979_impl_trait_in_proj: false,\n         lint_buffer: lints,\n     };\n     visit::walk_crate(&mut validator, krate);"}, {"sha": "2aeec029cc334dee7f57da7b60409eb3bf46af95", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -569,16 +569,27 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if self.should_warn_about_item(item) {\n-            // For items that have a definition with a signature followed by a\n-            // block, point only at the signature.\n+            // For most items, we want to highlight its identifier\n             let span = match item.kind {\n                 hir::ItemKind::Fn(..) |\n                 hir::ItemKind::Mod(..) |\n                 hir::ItemKind::Enum(..) |\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Trait(..) |\n-                hir::ItemKind::Impl(..) => self.tcx.sess.source_map().def_span(item.span),\n+                hir::ItemKind::Impl(..) => {\n+                    // FIXME(66095): Because item.span is annotated with things\n+                    // like expansion data, and ident.span isn't, we use the\n+                    // def_span method if it's part of a macro invocation\n+                    // (and thus has asource_callee set).\n+                    // We should probably annotate ident.span with the macro\n+                    // context, but that's a larger change.\n+                    if item.span.source_callee().is_some() {\n+                        self.tcx.sess.source_map().def_span(item.span)\n+                    } else {\n+                        item.ident.span\n+                    }\n+                },\n                 _ => item.span,\n             };\n             let participle = match item.kind {"}, {"sha": "60525ba6b39c44f81f08f3e714d3674a1f14a3d5", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::TyCtxt;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Node, Destination, GeneratorMovability};\n+use rustc::hir::{self, Node, Destination, Movability};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n@@ -59,7 +59,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n             hir::ExprKind::Closure(_, ref function_decl, b, span, movability) => {\n-                let cx = if let Some(GeneratorMovability::Static) = movability {\n+                let cx = if let Some(Movability::Static) = movability {\n                     AsyncClosure(span)\n                 } else {\n                     Closure(span)"}, {"sha": "3f4b87a97c7736fc59452cec0578c3821e2808fa", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -101,7 +101,6 @@ impl<'a> Registry<'a> {\n \n     /// Register an attribute with an attribute type.\n     ///\n-    /// Registered attributes will bypass the `custom_attribute` feature gate.\n     /// `Whitelisted` attributes will additionally not trigger the `unused_attribute`\n     /// lint. `CrateLevel` attributes will not be allowed on anything other than a crate.\n     pub fn register_attribute(&mut self, name: Symbol, ty: AttributeType) {"}, {"sha": "33b2bd36b7ded07761cf266cecdd01150180714c", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -21,4 +21,4 @@ errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "0fcac5aab625e3ecc54e7e7e4a2120e562628ee2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -33,7 +33,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind};\n use syntax::feature_gate::is_builtin_attr;\n-use syntax::parse::token::{self, Token};\n+use syntax::token::{self, Token};\n use syntax::print::pprust;\n use syntax::{span_err, struct_span_err};\n use syntax::source_map::{respan, Spanned};\n@@ -141,8 +141,7 @@ impl<'a> Resolver<'a> {\n     crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         match res {\n             Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n-            Res::NonMacroAttr(attr_kind) =>\n-                Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            Res::NonMacroAttr(attr_kind) => Some(self.non_macro_attr(attr_kind.is_used())),\n             _ => None,\n         }\n     }\n@@ -449,7 +448,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                                     name: kw::PathRoot,\n                                     span: source.ident.span,\n                                 },\n-                                id: Some(self.r.session.next_node_id()),\n+                                id: Some(self.r.next_node_id()),\n                             });\n                             source.ident.name = crate_name;\n                         }\n@@ -1229,8 +1228,10 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n-        if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope));\n+        if !attr.is_doc_comment() && is_builtin_attr(attr) {\n+            self.r.builtin_attrs.push(\n+                (attr.get_normal_item().path.segments[0].ident, self.parent_scope)\n+            );\n         }\n         visit::walk_attribute(self, attr);\n     }"}, {"sha": "0624b5eedfb8aaa0660868d5dcd2d815c6cd3b10", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -26,7 +26,7 @@\n use crate::Resolver;\n use crate::resolve_imports::ImportDirectiveSubclass;\n \n-use errors::pluralise;\n+use errors::pluralize;\n \n use rustc::util::nodemap::NodeMap;\n use rustc::{lint, ty};\n@@ -297,7 +297,7 @@ impl Resolver<'_> {\n                 }).collect::<Vec<String>>();\n             span_snippets.sort();\n             let msg = format!(\"unused import{}{}\",\n-                            pluralise!(len),\n+                            pluralize!(len),\n                             if !span_snippets.is_empty() {\n                                 format!(\": {}\", span_snippets.join(\", \"))\n                             } else {"}, {"sha": "771519b86c151850eac8f5131971e1b23ca25df8", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::hygiene::MacroKind;\n use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{path_names_to_string, KNOWN_TOOLS};\n+use crate::path_names_to_string;\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n@@ -400,6 +400,14 @@ impl<'a> Resolver<'a> {\n                 Scope::Module(module) => {\n                     this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n+                Scope::RegisteredAttrs => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::Registered);\n+                    if filter_fn(res) {\n+                        suggestions.extend(this.registered_attrs.iter().map(|ident| {\n+                            TypoSuggestion::from_res(ident.name, res)\n+                        }));\n+                    }\n+                }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n                         let res = binding.res();\n@@ -439,8 +447,8 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::ToolPrelude => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                    suggestions.extend(KNOWN_TOOLS.iter().map(|name| {\n-                        TypoSuggestion::from_res(*name, res)\n+                    suggestions.extend(this.registered_tools.iter().map(|ident| {\n+                        TypoSuggestion::from_res(ident.name, res)\n                     }));\n                 }\n                 Scope::StdLibPrelude => {"}, {"sha": "3340566a8758e81dfcc7c438c4b67da6985cb19a", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -731,7 +731,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         match item.kind {\n             ItemKind::TyAlias(_, ref generics) |\n             ItemKind::OpaqueTy(_, ref generics) |\n-            ItemKind::Fn(_, _, ref generics, _) => {\n+            ItemKind::Fn(_, ref generics, _) => {\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes),\n                                             |this| visit::walk_item(this, item));\n             }\n@@ -1539,25 +1539,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n                     partial_res\n                 } else {\n-                    // Add a temporary hack to smooth the transition to new struct ctor\n-                    // visibility rules. See #38932 for more details.\n-                    let mut res = None;\n-                    if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n-                        if let Some((ctor_res, ctor_vis))\n-                                = self.r.struct_constructors.get(&def_id).cloned() {\n-                            if is_expected(ctor_res) &&\n-                               self.r.is_accessible_from(ctor_vis, self.parent_scope.module) {\n-                                let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n-                                self.r.lint_buffer.buffer_lint(lint, id, span,\n-                                    \"private struct constructors are not usable through \\\n-                                     re-exports in outer modules\",\n-                                );\n-                                res = Some(PartialRes::new(ctor_res));\n-                            }\n-                        }\n-                    }\n-\n-                    res.unwrap_or_else(|| report_errors(self, Some(partial_res.base_res())))\n+                    report_errors(self, Some(partial_res.base_res()))\n                 }\n             }\n             Some(partial_res) if source.defer_to_typeck() => {\n@@ -1876,7 +1858,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                     None\n                                 }\n                             });\n-                            find_best_match_for_name(names, &*ident.as_str(), None)\n+                            find_best_match_for_name(names, &ident.as_str(), None)\n                         });\n                         self.r.record_partial_res(expr.id, PartialRes::new(Res::Err));\n                         self.r.report_error("}, {"sha": "88c675a6ce5baf957735c3453b53c71b705655a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -36,7 +36,6 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n use syntax::{struct_span_err, unwrap_or};\n-use syntax::expand::SpecialDerives;\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ast::{CRATE_NODE_ID, Crate};\n use syntax::ast::{ItemKind, Path};\n@@ -75,8 +74,6 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-const KNOWN_TOOLS: &[Name] = &[sym::clippy, sym::rustfmt];\n-\n enum Weak {\n     Yes,\n     No,\n@@ -103,6 +100,7 @@ enum Scope<'a> {\n     MacroRules(LegacyScope<'a>),\n     CrateRoot,\n     Module(Module<'a>),\n+    RegisteredAttrs,\n     MacroUsePrelude,\n     BuiltinAttrs,\n     LegacyPluginHelpers,\n@@ -622,7 +620,6 @@ enum AmbiguityKind {\n     Import,\n     BuiltinAttr,\n     DeriveHelper,\n-    LegacyHelperVsPrelude,\n     LegacyVsModern,\n     GlobVsOuter,\n     GlobVsGlob,\n@@ -639,8 +636,6 @@ impl AmbiguityKind {\n                 \"built-in attribute vs any other name\",\n             AmbiguityKind::DeriveHelper =>\n                 \"derive helper attribute vs any other name\",\n-            AmbiguityKind::LegacyHelperVsPrelude =>\n-                \"legacy plugin helper attribute vs name from prelude\",\n             AmbiguityKind::LegacyVsModern =>\n                 \"`macro_rules` vs non-`macro_rules` from other module\",\n             AmbiguityKind::GlobVsOuter =>\n@@ -917,6 +912,8 @@ pub struct Resolver<'a> {\n     crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Name, SyntaxExtension>,\n+    registered_attrs: FxHashSet<Ident>,\n+    registered_tools: FxHashSet<Ident>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n@@ -934,12 +931,10 @@ pub struct Resolver<'a> {\n     multi_segment_macro_resolutions: Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n                                           Option<Res>)>,\n     builtin_attrs: Vec<(Ident, ParentScope<'a>)>,\n-    /// Some built-in derives mark items they are applied to so they are treated specially later.\n+    /// `derive(Copy)` marks items they are applied to so they are treated specially later.\n     /// Derive macros cannot modify the item themselves and have to store the markers in the global\n     /// context, so they attach the markers to derive container IDs using this resolver table.\n-    /// FIXME: Find a way for `PartialEq` and `Eq` to emulate `#[structural_match]`\n-    /// by marking the produced impls rather than the original items.\n-    special_derives: FxHashMap<ExpnId, SpecialDerives>,\n+    containers_deriving_copy: FxHashSet<ExpnId>,\n     /// Parent scopes in which the macros were invoked.\n     /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n     invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n@@ -964,6 +959,8 @@ pub struct Resolver<'a> {\n     variant_vis: DefIdMap<ty::Visibility>,\n \n     lint_buffer: lint::LintBuffer,\n+\n+    next_node_id: NodeId,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1078,15 +1075,13 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         &mut self.definitions\n     }\n \n-    fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool {\n-        let def_id = self.definitions.local_def_id(node_id);\n-        let expn_id = self.definitions.expansion_that_defined(def_id.index);\n-        self.has_derives(expn_id, derives)\n-    }\n-\n     fn lint_buffer(&mut self) -> &mut lint::LintBuffer {\n         &mut self.lint_buffer\n     }\n+\n+    fn next_node_id(&mut self) -> NodeId {\n+        self.next_node_id()\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1141,6 +1136,9 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n+        let (registered_attrs, registered_tools) =\n+            macros::registered_attrs_and_tools(session, &krate.attrs);\n+\n         let mut invocation_parent_scopes = FxHashMap::default();\n         invocation_parent_scopes.insert(ExpnId::root(), ParentScope::module(graph_root));\n \n@@ -1210,6 +1208,8 @@ impl<'a> Resolver<'a> {\n             crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n+            registered_attrs,\n+            registered_tools,\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n@@ -1228,16 +1228,25 @@ impl<'a> Resolver<'a> {\n             single_segment_macro_resolutions: Default::default(),\n             multi_segment_macro_resolutions: Default::default(),\n             builtin_attrs: Default::default(),\n-            special_derives: Default::default(),\n+            containers_deriving_copy: Default::default(),\n             active_features:\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n                     .chain(features.declared_lang_features.iter().map(|(feat, ..)| *feat))\n                     .collect(),\n             variant_vis: Default::default(),\n             lint_buffer: lint::LintBuffer::default(),\n+            next_node_id: NodeId::from_u32(1),\n         }\n     }\n \n+    pub fn next_node_id(&mut self) -> NodeId {\n+        let next = self.next_node_id.as_usize()\n+            .checked_add(1)\n+            .expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_usize(next);\n+        self.next_node_id\n+    }\n+\n     pub fn lint_buffer(&mut self) -> &mut lint::LintBuffer {\n         &mut self.lint_buffer\n     }\n@@ -1314,10 +1323,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn has_derives(&self, expn_id: ExpnId, markers: SpecialDerives) -> bool {\n-        self.special_derives.get(&expn_id).map_or(false, |m| m.contains(markers))\n-    }\n-\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         let _prof_timer =\n@@ -1482,6 +1487,7 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroRules(..) => true,\n                 Scope::CrateRoot => true,\n                 Scope::Module(..) => true,\n+                Scope::RegisteredAttrs => use_prelude,\n                 Scope::MacroUsePrelude => use_prelude || rust_2015,\n                 Scope::BuiltinAttrs => true,\n                 Scope::LegacyPluginHelpers => use_prelude || rust_2015,\n@@ -1526,11 +1532,12 @@ impl<'a> Resolver<'a> {\n                             match ns {\n                                 TypeNS => Scope::ExternPrelude,\n                                 ValueNS => Scope::StdLibPrelude,\n-                                MacroNS => Scope::MacroUsePrelude,\n+                                MacroNS => Scope::RegisteredAttrs,\n                             }\n                         }\n                     }\n                 }\n+                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n                 Scope::MacroUsePrelude => Scope::StdLibPrelude,\n                 Scope::BuiltinAttrs => Scope::LegacyPluginHelpers,\n                 Scope::LegacyPluginHelpers => break, // nowhere else to search\n@@ -1686,11 +1693,11 @@ impl<'a> Resolver<'a> {\n                 if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n-            }\n-            if ns == TypeNS && KNOWN_TOOLS.contains(&ident.name) {\n-                let binding = (Res::ToolMod, ty::Visibility::Public,\n-                               DUMMY_SP, ExpnId::root()).to_name_binding(self.arenas);\n-                return Some(LexicalScopeBinding::Item(binding));\n+                if let Some(ident) = self.registered_tools.get(&ident) {\n+                    let binding = (Res::ToolMod, ty::Visibility::Public,\n+                                   ident.span, ExpnId::root()).to_name_binding(self.arenas);\n+                    return Some(LexicalScopeBinding::Item(binding));\n+                }\n             }\n             if let Some(prelude) = self.prelude {\n                 if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n@@ -2840,9 +2847,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn new_ast_path_segment(&self, ident: Ident) -> ast::PathSegment {\n+    fn new_ast_path_segment(&mut self, ident: Ident) -> ast::PathSegment {\n         let mut seg = ast::PathSegment::from_ident(ident);\n-        seg.id = self.session.next_node_id();\n+        seg.id = self.next_node_id();\n         seg\n     }\n "}, {"sha": "2d125a459c86b701947294d7445859809e1c6e19", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 82, "deletions": 72, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,18 +3,18 @@\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n-use crate::{ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n-use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n+use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::Namespace::*;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::def_id;\n use rustc::middle::stability;\n+use rustc::session::Session;\n+use rustc::util::nodemap::FxHashSet;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n-use syntax::attr::StabilityLevel;\n+use syntax::attr::{self, StabilityLevel};\n use syntax::edition::Edition;\n-use syntax::expand::SpecialDerives;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n use syntax::print::pprust;\n@@ -94,9 +94,49 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n     }\n }\n \n+/// The code common between processing `#![register_tool]` and `#![register_attr]`.\n+fn registered_idents(\n+    sess: &Session,\n+    attrs: &[ast::Attribute],\n+    attr_name: Symbol,\n+    descr: &str,\n+) -> FxHashSet<Ident> {\n+    let mut registered = FxHashSet::default();\n+    for attr in attr::filter_by_name(attrs, attr_name) {\n+        for nested_meta in attr.meta_item_list().unwrap_or_default() {\n+            match nested_meta.ident() {\n+                Some(ident) => if let Some(old_ident) = registered.replace(ident) {\n+                    let msg = format!(\"{} `{}` was already registered\", descr, ident);\n+                    sess.struct_span_err(ident.span, &msg)\n+                        .span_label(old_ident.span, \"already registered here\").emit();\n+                }\n+                None => {\n+                    let msg = format!(\"`{}` only accepts identifiers\", attr_name);\n+                    let span = nested_meta.span();\n+                    sess.struct_span_err(span, &msg).span_label(span, \"not an identifier\").emit();\n+                }\n+            }\n+        }\n+    }\n+    registered\n+}\n+\n+crate fn registered_attrs_and_tools(\n+    sess: &Session,\n+    attrs: &[ast::Attribute],\n+) -> (FxHashSet<Ident>, FxHashSet<Ident>) {\n+    let registered_attrs = registered_idents(sess, attrs, sym::register_attr, \"attribute\");\n+    let mut registered_tools = registered_idents(sess, attrs, sym::register_tool, \"tool\");\n+    // We implicitly add `rustfmt` and `clippy` to known tools,\n+    // but it's not an error to register them explicitly.\n+    let predefined_tools = [sym::clippy, sym::rustfmt];\n+    registered_tools.extend(predefined_tools.iter().cloned().map(Ident::with_dummy_span));\n+    (registered_attrs, registered_tools)\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> NodeId {\n-        self.session.next_node_id()\n+        self.next_node_id()\n     }\n \n     fn resolve_dollar_crates(&mut self) {\n@@ -180,7 +220,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n+                (&attr.get_normal_item().path,\n+                 MacroKind::Attr,\n+                 self.arenas.alloc_ast_paths(derives),\n+                 after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n                 (&mac.path, MacroKind::Bang, &[][..], false),\n             InvocationKind::Derive { ref path, .. } =>\n@@ -255,12 +298,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n     }\n \n-    fn has_derives(&self, expn_id: ExpnId, derives: SpecialDerives) -> bool {\n-        self.has_derives(expn_id, derives)\n+    fn has_derive_copy(&self, expn_id: ExpnId) -> bool {\n+        self.containers_deriving_copy.contains(&expn_id)\n     }\n \n-    fn add_derives(&mut self, expn_id: ExpnId, derives: SpecialDerives) {\n-        *self.special_derives.entry(expn_id).or_default() |= derives;\n+    fn add_derive_copy(&mut self, expn_id: ExpnId) {\n+        self.containers_deriving_copy.insert(expn_id);\n     }\n }\n \n@@ -414,10 +457,9 @@ impl<'a> Resolver<'a> {\n             struct Flags: u8 {\n                 const MACRO_RULES        = 1 << 0;\n                 const MODULE             = 1 << 1;\n-                const PRELUDE            = 1 << 2;\n-                const MISC_SUGGEST_CRATE = 1 << 3;\n-                const MISC_SUGGEST_SELF  = 1 << 4;\n-                const MISC_FROM_PRELUDE  = 1 << 5;\n+                const MISC_SUGGEST_CRATE = 1 << 2;\n+                const MISC_SUGGEST_SELF  = 1 << 3;\n+                const MISC_FROM_PRELUDE  = 1 << 4;\n             }\n         }\n \n@@ -451,6 +493,10 @@ impl<'a> Resolver<'a> {\n         // Go through all the scopes and try to resolve the name.\n         let break_result = self.visit_scopes(scope_set, parent_scope, orig_ident,\n                                              |this, scope, use_prelude, ident| {\n+            let ok = |res, span, arenas| Ok((\n+                (res, ty::Visibility::Public, span, ExpnId::root()).to_name_binding(arenas),\n+                Flags::empty(),\n+            ));\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n@@ -459,10 +505,8 @@ impl<'a> Resolver<'a> {\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n                                                       parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n-                                let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                               ty::Visibility::Public, derive.span, ExpnId::root())\n-                                               .to_name_binding(this.arenas);\n-                                result = Ok((binding, Flags::empty()));\n+                                let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                                result = ok(res, derive.span, this.arenas);\n                                 break;\n                             }\n                             Ok(_) | Err(Determinacy::Determined) => {}\n@@ -529,41 +573,39 @@ impl<'a> Resolver<'a> {\n                         Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                     }\n                 }\n+                Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n+                    Some(ident) => ok(\n+                        Res::NonMacroAttr(NonMacroAttrKind::Registered), ident.span, this.arenas\n+                    ),\n+                    None => Err(Determinacy::Determined)\n+                }\n                 Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n-                    Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n+                    Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n                     None => Err(Determinacy::determined(\n                         this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     ))\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n-                    let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                   ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n-                                   .to_name_binding(this.arenas);\n-                    Ok((binding, Flags::PRELUDE))\n+                    ok(Res::NonMacroAttr(NonMacroAttrKind::Builtin), DUMMY_SP, this.arenas)\n                 } else {\n                     Err(Determinacy::Determined)\n                 }\n                 Scope::LegacyPluginHelpers => if this.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == *name) {\n-                    let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                   ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n-                                   .to_name_binding(this.arenas);\n-                    Ok((binding, Flags::PRELUDE))\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+                    ok(res, DUMMY_SP, this.arenas)\n                 } else {\n                     Err(Determinacy::Determined)\n                 }\n                 Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n-                    Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                    Some(binding) => Ok((binding, Flags::empty())),\n                     None => Err(Determinacy::determined(\n                         this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     )),\n                 }\n-                Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {\n-                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n-                                   .to_name_binding(this.arenas);\n-                    Ok((binding, Flags::PRELUDE))\n-                } else {\n-                    Err(Determinacy::Determined)\n+                Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n+                    Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n+                    None => Err(Determinacy::Determined)\n                 }\n                 Scope::StdLibPrelude => {\n                     let mut result = Err(Determinacy::Determined);\n@@ -577,19 +619,15 @@ impl<'a> Resolver<'a> {\n                             path_span,\n                         ) {\n                             if use_prelude || this.is_builtin_macro(binding.res()) {\n-                                result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n+                                result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n                             }\n                         }\n                     }\n                     result\n                 }\n                 Scope::BuiltinTypes => match this.primitive_type_table.primitive_types\n                                                  .get(&ident.name).cloned() {\n-                    Some(prim_ty) => {\n-                        let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n-                                       DUMMY_SP, ExpnId::root()).to_name_binding(this.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    }\n+                    Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n                     None => Err(Determinacy::Determined)\n                 }\n             };\n@@ -606,20 +644,13 @@ impl<'a> Resolver<'a> {\n                         if res != innermost_res {\n                             let builtin = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n                             let derive_helper = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n-                            let legacy_helper =\n-                                Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n \n                             let ambiguity_error_kind = if is_import {\n                                 Some(AmbiguityKind::Import)\n                             } else if innermost_res == builtin || res == builtin {\n                                 Some(AmbiguityKind::BuiltinAttr)\n                             } else if innermost_res == derive_helper || res == derive_helper {\n                                 Some(AmbiguityKind::DeriveHelper)\n-                            } else if innermost_res == legacy_helper &&\n-                                      flags.contains(Flags::PRELUDE) ||\n-                                      res == legacy_helper &&\n-                                      innermost_flags.contains(Flags::PRELUDE) {\n-                                Some(AmbiguityKind::LegacyHelperVsPrelude)\n                             } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n                                       flags.contains(Flags::MODULE) &&\n                                       !this.disambiguate_legacy_vs_modern(innermost_binding,\n@@ -679,20 +710,7 @@ impl<'a> Resolver<'a> {\n             return Ok(binding);\n         }\n \n-        let determinacy = Determinacy::determined(determinacy == Determinacy::Determined || force);\n-        if determinacy == Determinacy::Determined && macro_kind == Some(MacroKind::Attr) &&\n-           self.session.features_untracked().custom_attribute {\n-            // For single-segment attributes interpret determinate \"no resolution\" as a custom\n-            // attribute. (Lexical resolution implies the first segment and attr kind should imply\n-            // the last segment, so we are certainly working with a single-segment attribute here.)\n-            assert!(ns == MacroNS);\n-            let binding = (Res::NonMacroAttr(NonMacroAttrKind::Custom),\n-                           ty::Visibility::Public, orig_ident.span, ExpnId::root())\n-                           .to_name_binding(self.arenas);\n-            Ok(binding)\n-        } else {\n-            Err(determinacy)\n-        }\n+        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n     }\n \n     crate fn finalize_macro_resolutions(&mut self) {\n@@ -703,16 +721,7 @@ impl<'a> Resolver<'a> {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n                     // situations should be reported as ambiguity errors, so this is a bug.\n-                    if initial_res == Res::NonMacroAttr(NonMacroAttrKind::Custom) {\n-                        // Yeah, legacy custom attributes are implemented using forced resolution\n-                        // (which is a best effort error recovery tool, basically), so we can't\n-                        // promise their resolution won't change later.\n-                        let msg = format!(\"inconsistent resolution for a macro: first {}, then {}\",\n-                                          initial_res.descr(), res.descr());\n-                        this.session.span_err(span, &msg);\n-                    } else {\n-                        span_bug!(span, \"inconsistent resolution for a macro\");\n-                    }\n+                    span_bug!(span, \"inconsistent resolution for a macro\");\n                 }\n             } else {\n                 // It's possible that the macro was unresolved (indeterminate) and silently\n@@ -824,7 +833,8 @@ impl<'a> Resolver<'a> {\n                                          res: Option<Res>, span: Span) {\n         if let Some(Res::NonMacroAttr(kind)) = res {\n             if kind != NonMacroAttrKind::Tool && binding.map_or(true, |b| b.is_import()) {\n-                let msg = format!(\"cannot use a {} through an import\", kind.descr());\n+                let msg =\n+                    format!(\"cannot use {} {} through an import\", kind.article(), kind.descr());\n                 let mut err = self.session.struct_span_err(span, &msg);\n                 if let Some(binding) = binding {\n                     err.span_note(binding.span, &format!(\"the {} imported here\", kind.descr()));"}, {"sha": "083b11daaa1532b183143d218461502ed9f4724c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -11,23 +11,19 @@ use crate::{Resolver, ResolutionError, BindingKey, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n use crate::diagnostics::Suggestion;\n \n-use errors::{Applicability, pluralise};\n+use errors::{Applicability, pluralize};\n \n use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n use rustc::lint::builtin::BuiltinLintDiagnostics;\n-use rustc::lint::builtin::{\n-    DUPLICATE_MACRO_EXPORTS,\n-    PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-    UNUSED_IMPORTS,\n-};\n+use rustc::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::{self, PartialRes, Export};\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n-use syntax::ast::{Ident, Name, NodeId, CRATE_NODE_ID};\n+use syntax::ast::{Ident, Name, NodeId};\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n@@ -496,13 +492,13 @@ impl<'a> Resolver<'a> {\n                         if let (&NameBindingKind::Res(_, true), &NameBindingKind::Res(_, true)) =\n                                (&old_binding.kind, &binding.kind) {\n \n-                            this.lint_buffer.buffer_lint_with_diagnostic(\n-                                DUPLICATE_MACRO_EXPORTS,\n-                                CRATE_NODE_ID,\n+                            this.session.struct_span_err(\n                                 binding.span,\n                                 &format!(\"a macro named `{}` has already been exported\", key.ident),\n-                                BuiltinLintDiagnostics::DuplicatedMacroExports(\n-                                    key.ident, old_binding.span, binding.span));\n+                            )\n+                            .span_label(binding.span, format!(\"`{}` already exported\", key.ident))\n+                            .span_note(old_binding.span, \"previous macro export is now shadowed\")\n+                            .emit();\n \n                             resolution.binding = Some(binding);\n                         } else {\n@@ -730,7 +726,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             let msg = format!(\n                 \"unresolved import{} {}\",\n-                pluralise!(paths.len()),\n+                pluralize!(paths.len()),\n                 paths.join(\", \"),\n             );\n "}, {"sha": "50b3be6dca1c3d1ee208b3aa36b230653945895e", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -13,7 +13,7 @@ log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n-rustc_target = { path = \"../librustc_target\" }\n+rustc_parse = { path = \"../librustc_parse\" }\n serde_json = \"1\"\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "92c391fb4a338ca8189305e3299b1cf4ca99f375", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -24,7 +24,7 @@ use std::path::Path;\n use std::env;\n \n use syntax::ast::{self, Attribute, NodeId, PatKind};\n-use syntax::parse::token;\n+use syntax::token;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{\n     bounds_to_string,\n@@ -272,7 +272,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n     fn process_method(\n         &mut self,\n-        sig: &'l ast::MethodSig,\n+        sig: &'l ast::FnSig,\n         body: Option<&'l ast::Block>,\n         id: ast::NodeId,\n         ident: ast::Ident,\n@@ -1334,8 +1334,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     );\n                 }\n             }\n-            Fn(ref decl, ref header, ref ty_params, ref body) => {\n-                self.process_fn(item, &decl, &header, ty_params, &body)\n+            Fn(ref sig, ref ty_params, ref body) => {\n+                self.process_fn(item, &sig.decl, &sig.header, ty_params, &body)\n             }\n             Static(ref typ, _, ref expr) => self.process_static_or_const_item(item, typ, expr),\n             Const(ref typ, ref expr) => self.process_static_or_const_item(item, &typ, &expr),"}, {"sha": "424d57c8fe7fa7175afd200865a2fb86843e6ffa", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -29,7 +29,7 @@ use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, Attribute, DUMMY_NODE_ID, NodeId, PatKind};\n use syntax::source_map::Spanned;\n-use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n+use syntax::util::comments::strip_doc_comment_decoration;\n use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{param_to_string, ty_to_string};\n@@ -180,7 +180,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.kind {\n-            ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n+            ast::ItemKind::Fn(ref sig, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n@@ -190,7 +190,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(decl, generics),\n+                    value: make_signature(&sig.decl, generics),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -885,7 +885,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         for attr in attrs {\n             if attr.check_name(sym::doc) {\n                 if let Some(val) = attr.value_str() {\n-                    if attr.is_sugared_doc {\n+                    if attr.is_doc_comment() {\n                         result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n                     } else {\n                         result.push_str(&val.as_str());\n@@ -1195,7 +1195,7 @@ fn null_id() -> rls_data::Id {\n fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls_data::Attribute> {\n     attrs.into_iter()\n     // Only retain real attributes. Doc comments are lowered separately.\n-    .filter(|attr| attr.path != sym::doc)\n+    .filter(|attr| !attr.has_name(sym::doc))\n     .map(|mut attr| {\n         // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n         // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "d1b9b8ff44ddbdaee5c96597734938845c50329e", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -32,7 +32,7 @@ use rls_data::{SigElement, Signature};\n use rustc::hir::def::{Res, DefKind};\n use syntax::ast::{self, NodeId};\n use syntax::print::pprust;\n-\n+use syntax_pos::sym;\n \n pub fn item_signature(item: &ast::Item, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -72,7 +72,7 @@ pub fn method_signature(\n     id: NodeId,\n     ident: ast::Ident,\n     generics: &ast::Generics,\n-    m: &ast::MethodSig,\n+    m: &ast::FnSig,\n     scx: &SaveContext<'_, '_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -157,6 +157,12 @@ fn text_sig(text: String) -> Signature {\n     }\n }\n \n+fn push_abi(text: &mut String, abi: ast::Abi) {\n+    if abi.symbol != sym::Rust {\n+        text.push_str(&format!(\"extern \\\"{}\\\" \", abi.symbol));\n+    }\n+}\n+\n impl Sig for ast::Ty {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n@@ -231,11 +237,7 @@ impl Sig for ast::Ty {\n                 if f.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                if f.abi != rustc_target::spec::abi::Abi::Rust {\n-                    text.push_str(\"extern\");\n-                    text.push_str(&f.abi.to_string());\n-                    text.push(' ');\n-                }\n+                push_abi(&mut text, f.abi);\n                 text.push_str(\"fn(\");\n \n                 let mut defs = vec![];\n@@ -374,7 +376,7 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n+            ast::ItemKind::Fn(ast::FnSig { ref decl, header }, ref generics, _) => {\n                 let mut text = String::new();\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");\n@@ -385,11 +387,7 @@ impl Sig for ast::Item {\n                 if header.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                if header.abi != rustc_target::spec::abi::Abi::Rust {\n-                    text.push_str(\"extern\");\n-                    text.push_str(&header.abi.to_string());\n-                    text.push(' ');\n-                }\n+                push_abi(&mut text, header.abi);\n                 text.push_str(\"fn \");\n \n                 let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n@@ -934,7 +932,7 @@ fn make_method_signature(\n     id: NodeId,\n     ident: ast::Ident,\n     generics: &ast::Generics,\n-    m: &ast::MethodSig,\n+    m: &ast::FnSig,\n     scx: &SaveContext<'_, '_>,\n ) -> Result {\n     // FIXME code dup with function signature\n@@ -948,11 +946,7 @@ fn make_method_signature(\n     if m.header.unsafety == ast::Unsafety::Unsafe {\n         text.push_str(\"unsafe \");\n     }\n-    if m.header.abi != rustc_target::spec::abi::Abi::Rust {\n-        text.push_str(\"extern\");\n-        text.push_str(&m.header.abi.to_string());\n-        text.push(' ');\n-    }\n+    push_abi(&mut text, m.header.abi);\n     text.push_str(\"fn \");\n \n     let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;"}, {"sha": "f2f512bc8e5ab0f378ea71ee446f812f789c05e0", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,9 +1,7 @@\n-use rustc::session::Session;\n-\n use crate::generated_code;\n-\n-use syntax::parse::lexer::{self, StringReader};\n-use syntax::parse::token::{self, TokenKind};\n+use rustc::session::Session;\n+use rustc_parse::lexer::{self, StringReader};\n+use syntax::token::{self, TokenKind};\n use syntax_pos::*;\n \n #[derive(Clone)]"}, {"sha": "18b121f9c5bef64d6fa3f35dabebcb43415ae63d", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -23,8 +23,8 @@ fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgAbi<'a, Ty>, i: usize) -> Option<Reg>\n {\n     match ret.layout.field(cx, i).abi {\n         abi::Abi::Scalar(ref scalar) => match scalar.value {\n-            abi::Float(abi::FloatTy::F32) => Some(Reg::f32()),\n-            abi::Float(abi::FloatTy::F64) => Some(Reg::f64()),\n+            abi::F32 => Some(Reg::f32()),\n+            abi::F64 => Some(Reg::f64()),\n             _ => None\n         },\n         _ => None\n@@ -107,7 +107,7 @@ fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n \n                 // We only care about aligned doubles\n                 if let abi::Abi::Scalar(ref scalar) = field.abi {\n-                    if let abi::Float(abi::FloatTy::F64) = scalar.value {\n+                    if let abi::F64 = scalar.value {\n                         if offset.is_aligned(dl.f64_align.abi) {\n                             // Insert enough integers to cover [last_offset, offset)\n                             assert!(last_offset.is_aligned(dl.f64_align.abi));"}, {"sha": "aced12aa32acba0c266d785e920907e38be0a9a8", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -287,7 +287,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                 let kind = match scalar.value {\n                     abi::Int(..) |\n                     abi::Pointer => RegKind::Integer,\n-                    abi::Float(_) => RegKind::Float,\n+                    abi::F32 | abi::F64 => RegKind::Float,\n                 };\n                 HomogeneousAggregate::Homogeneous(Reg {\n                     kind,\n@@ -554,7 +554,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),\n-            \"powerpc\" => powerpc::compute_abi_info(cx, self),\n+            \"powerpc\" => powerpc::compute_abi_info(self),\n             \"powerpc64\" => powerpc64::compute_abi_info(cx, self),\n             \"s390x\" => s390x::compute_abi_info(cx, self),\n             \"msp430\" => msp430::compute_abi_info(self),"}, {"sha": "740bd7222f237034bbcc7a6d6dbbd430a71b6980", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,49 +1,28 @@\n-use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n-fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(32);\n-    } else {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n+    if ret.layout.is_aggregate() {\n         ret.make_indirect();\n-        *offset += cx.data_layout().pointer_size;\n+    } else {\n+        ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    let dl = cx.data_layout();\n-    let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n-\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform {\n-            unit: Reg::i32(),\n-            total: size\n-        });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with(Reg::i32());\n-        }\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-\n-    *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    let mut offset = Size::ZERO;\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n     if !fn_abi.ret.is_ignore() {\n-        classify_ret(cx, &mut fn_abi.ret, &mut offset);\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n     for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg(cx, arg, &mut offset);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "452ca024e61b47a9fb3d10986c8f87d1093fa6b9", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -45,7 +45,7 @@ fn classify_arg<'a, Ty, C>(cx: &C, arg: &ArgAbi<'a, Ty>)\n                 match scalar.value {\n                     abi::Int(..) |\n                     abi::Pointer => Class::Int,\n-                    abi::Float(_) => Class::Sse\n+                    abi::F32 | abi::F64 => Class::Sse\n                 }\n             }\n "}, {"sha": "2d7e05037ba0d7f99fb404731c609e914fbeb75e", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 8, "deletions": 56, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -3,11 +3,9 @@ pub use Primitive::*;\n \n use crate::spec::Target;\n \n-use std::fmt;\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n use rustc_index::vec::{Idx, IndexVec};\n-use syntax_pos::symbol::{sym, Symbol};\n use syntax_pos::Span;\n \n pub mod call;\n@@ -534,49 +532,6 @@ impl Integer {\n     }\n }\n \n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n-         PartialOrd, Ord)]\n-pub enum FloatTy {\n-    F32,\n-    F64,\n-}\n-\n-impl fmt::Debug for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n-impl FloatTy {\n-    pub fn ty_to_string(self) -> &'static str {\n-        match self {\n-            FloatTy::F32 => \"f32\",\n-            FloatTy::F64 => \"f64\",\n-        }\n-    }\n-\n-    pub fn to_symbol(self) -> Symbol {\n-        match self {\n-            FloatTy::F32 => sym::f32,\n-            FloatTy::F64 => sym::f64,\n-        }\n-    }\n-\n-    pub fn bit_width(self) -> usize {\n-        match self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n-}\n-\n /// Fundamental unit of memory access and layout.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Primitive {\n@@ -588,7 +543,8 @@ pub enum Primitive {\n     /// a negative integer passed by zero-extension will appear positive in\n     /// the callee, and most operations on it will produce the wrong values.\n     Int(Integer, bool),\n-    Float(FloatTy),\n+    F32,\n+    F64,\n     Pointer\n }\n \n@@ -598,8 +554,8 @@ impl Primitive {\n \n         match self {\n             Int(i, _) => i.size(),\n-            Float(FloatTy::F32) => Size::from_bits(32),\n-            Float(FloatTy::F64) => Size::from_bits(64),\n+            F32 => Size::from_bits(32),\n+            F64 => Size::from_bits(64),\n             Pointer => dl.pointer_size\n         }\n     }\n@@ -609,15 +565,15 @@ impl Primitive {\n \n         match self {\n             Int(i, _) => i.align(dl),\n-            Float(FloatTy::F32) => dl.f32_align,\n-            Float(FloatTy::F64) => dl.f64_align,\n+            F32 => dl.f32_align,\n+            F64 => dl.f64_align,\n             Pointer => dl.pointer_align\n         }\n     }\n \n     pub fn is_float(self) -> bool {\n         match self {\n-            Float(_) => true,\n+            F32 | F64 => true,\n             _ => false\n         }\n     }\n@@ -738,11 +694,7 @@ impl FieldPlacement {\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Union(count) => {\n-                assert!(i < count,\n-                        \"Tried to access field {} of union with {} fields\", i, count);\n-                Size::ZERO\n-            },\n+            FieldPlacement::Union(_) => Size::ZERO,\n             FieldPlacement::Array { stride, count } => {\n                 let i = i as u64;\n                 assert!(i < count);"}, {"sha": "4cd2f13d09cbd3d0d6eff7c7865ce33bfc228a03", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -362,6 +362,7 @@ supported_targets! {\n     (\"armv7-unknown-linux-gnueabi\", armv7_unknown_linux_gnueabi),\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n     (\"thumbv7neon-unknown-linux-gnueabihf\", thumbv7neon_unknown_linux_gnueabihf),\n+    (\"thumbv7neon-unknown-linux-musleabihf\", thumbv7neon_unknown_linux_musleabihf),\n     (\"armv7-unknown-linux-musleabi\", armv7_unknown_linux_musleabi),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),\n@@ -793,7 +794,10 @@ pub struct TargetOptions {\n     pub merge_functions: MergeFunctions,\n \n     /// Use platform dependent mcount function\n-    pub target_mcount: String\n+    pub target_mcount: String,\n+\n+    /// LLVM ABI name, corresponds to the '-mabi' parameter available in multilib C compilers\n+    pub llvm_abiname: String,\n }\n \n impl Default for TargetOptions {\n@@ -880,6 +884,7 @@ impl Default for TargetOptions {\n             override_export_symbols: None,\n             merge_functions: MergeFunctions::Aliases,\n             target_mcount: \"mcount\".to_string(),\n+            llvm_abiname: \"\".to_string(),\n         }\n     }\n }\n@@ -1196,6 +1201,7 @@ impl Target {\n         key!(override_export_symbols, opt_list);\n         key!(merge_functions, MergeFunctions)?;\n         key!(target_mcount);\n+        key!(llvm_abiname);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -1414,6 +1420,7 @@ impl ToJson for Target {\n         target_option_val!(override_export_symbols);\n         target_option_val!(merge_functions);\n         target_option_val!(target_mcount);\n+        target_option_val!(llvm_abiname);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "1270f391731b2db1fd1f7426870f3d2f5b37c822", "filename": "src/librustc_target/spec/thumbv7neon_unknown_linux_musleabihf.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fspec%2Fthumbv7neon_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fspec%2Fthumbv7neon_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv7neon_unknown_linux_musleabihf.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -0,0 +1,37 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+// This target is for musl Linux on ARMv7 with thumb mode enabled\n+// (for consistency with Android and Debian-based distributions)\n+// and with NEON unconditionally enabled and, therefore, with 32 FPU\n+// registers enabled as well. See section A2.6.2 on page A2-56 in\n+// https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf\n+\n+pub fn target() -> TargetResult {\n+    let base = super::linux_musl_base::opts();\n+    Ok(Target {\n+        // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n+        // uses it to determine the calling convention and float ABI, and LLVM\n+        // doesn't support the \"musleabihf\" value.\n+        llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        // Most of these settings are copied from the thumbv7neon_unknown_linux_gnueabihf\n+        // target.\n+        options: TargetOptions {\n+            features: \"+v7,+thumb-mode,+thumb2,+vfp3,+neon\".to_string(),\n+            cpu: \"generic\".to_string(),\n+            max_atomic_width: Some(64),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}mcount\".to_string(),\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "ce7b338345caf6e4fed10c2c7313e40d42ca9cbd", "filename": "src/librustc_target/spec/windows_base.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -4,33 +4,6 @@ use std::default::Default;\n pub fn opts() -> TargetOptions {\n     let mut pre_link_args = LinkArgs::new();\n     pre_link_args.insert(LinkerFlavor::Gcc, vec![\n-            // And here, we see obscure linker flags #45. On windows, it has been\n-            // found to be necessary to have this flag to compile liblibc.\n-            //\n-            // First a bit of background. On Windows, the file format is not ELF,\n-            // but COFF (at least according to LLVM). COFF doesn't officially allow\n-            // for section names over 8 characters, apparently. Our metadata\n-            // section, \".note.rustc\", you'll note is over 8 characters.\n-            //\n-            // On more recent versions of gcc on mingw, apparently the section name\n-            // is *not* truncated, but rather stored elsewhere in a separate lookup\n-            // table. On older versions of gcc, they apparently always truncated th\n-            // section names (at least in some cases). Truncating the section name\n-            // actually creates \"invalid\" objects [1] [2], but only for some\n-            // introspection tools, not in terms of whether it can be loaded.\n-            //\n-            // Long story short, passing this flag forces the linker to *not*\n-            // truncate section names (so we can find the metadata section after\n-            // it's compiled). The real kicker is that rust compiled just fine on\n-            // windows for quite a long time *without* this flag, so I have no idea\n-            // why it suddenly started failing for liblibc. Regardless, we\n-            // definitely don't want section name truncation, so we're keeping this\n-            // flag for windows.\n-            //\n-            // [1] - https://sourceware.org/bugzilla/show_bug.cgi?id=13130\n-            // [2] - https://code.google.com/p/go/issues/detail?id=2139\n-            \"-Wl,--enable-long-section-names\".to_string(),\n-\n             // Tell GCC to avoid linker plugins, because we are not bundling\n             // them with Windows installer, and Rust does its own LTO anyways.\n             \"-fno-use-linker-plugin\".to_string(),"}, {"sha": "a9b184a7b306869a57337590273d5992091d3147", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -16,4 +16,4 @@ rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "3ad68d4a9dfa668c511590954f5432c9194b77b1", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -243,7 +243,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Float(..) |\n         ty::RawPtr(..) |\n         ty::Never |\n-        ty::Ref(_, _, hir::MutImmutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Immutable) => (),\n \n         // Non parametric primitive types.\n         ty::Infer(ty::IntVar(_)) |\n@@ -319,7 +319,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Generator(..) |\n         ty::Str |\n         ty::Slice(..) |\n-        ty::Ref(_, _, hir::MutMutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Mutable) => (),\n \n         ty::Bound(..) |\n         ty::GeneratorWitness(..) |"}, {"sha": "d77ec3010f4b7843d49d68d7d8b0aab1a020b5bc", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n+use rustc::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n use rustc::traits::{TraitEngine, Normalized, ObligationCause, TraitEngineExt};\n use rustc::ty::query::Providers;\n@@ -172,7 +173,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         return Ok(());\n     }\n \n-    if tcx.trivial_dropck_outlives(ty) {\n+    if trivial_dropck_outlives(tcx, ty) {\n         return Ok(());\n     }\n "}, {"sha": "96ba4d497cbf570c3319e875e8c8c5297cc37768", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -76,6 +76,6 @@ crate fn generator(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_generator(\n         def_id,\n         InternalSubsts::bound_vars_for_item(tcx, def_id),\n-        hir::GeneratorMovability::Movable\n+        hir::Movability::Movable\n     )\n }"}, {"sha": "60a7a2f45989c728627411528e555bdaa504530c", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -17,7 +17,7 @@ rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_target = { path = \"../librustc_target\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_index = { path = \"../librustc_index\" }"}, {"sha": "5c66151338272f9a7b0402a686ba088cfba5c07a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -23,7 +23,7 @@ use rustc_target::spec::abi;\n use crate::require_c_abi_if_c_variadic;\n use smallvec::SmallVec;\n use syntax::ast;\n-use syntax::errors::pluralise;\n+use syntax::errors::pluralize;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::symbol::sym;\n@@ -392,7 +392,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     quantifier,\n                     bound,\n                     kind,\n-                    pluralise!(bound),\n+                    pluralize!(bound),\n                 ))\n             };\n \n@@ -1360,7 +1360,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 span,\n                 E0191,\n                 \"the value of the associated type{} {} must be specified\",\n-                pluralise!(associated_types.len()),\n+                pluralize!(associated_types.len()),\n                 names,\n             );\n             let (suggest, potential_assoc_types_spans) ="}, {"sha": "6a35f9b84525824cfe4efba9cff3c2faa340f275", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -430,8 +430,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let contains_ref_bindings = arms.iter()\n             .filter_map(|a| a.pat.contains_explicit_ref_binding())\n             .max_by_key(|m| match *m {\n-                hir::MutMutable => 1,\n-                hir::MutImmutable => 0,\n+                hir::Mutability::Mutable => 1,\n+                hir::Mutability::Immutable => 0,\n             });\n \n         if let Some(m) = contains_ref_bindings {"}, {"sha": "c195e91a52be7a0655d16c6bd38415711e1a497f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -215,8 +215,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                                 // For initial two-phase borrow\n                                 // deployment, conservatively omit\n                                 // overloaded function call ops."}, {"sha": "3245f2cca79cbe2aa5cda07fd1e483542e069537", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -341,10 +341,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                          tstr);\n         match self.expr_ty.kind {\n             ty::Ref(_, _, mt) => {\n-                let mtstr = match mt {\n-                    hir::MutMutable => \"mut \",\n-                    hir::MutImmutable => \"\",\n-                };\n+                let mtstr = mt.prefix_str();\n                 if self.cast_ty.is_trait() {\n                     match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                         Ok(s) => {\n@@ -630,7 +627,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n-        if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n+        if m_expr.mutbl == hir::Mutability::Immutable &&\n+            m_cast.mutbl == hir::Mutability::Immutable {\n             if let ty::Array(ety, _) = m_expr.ty.kind {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n@@ -639,6 +637,15 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 // need to special-case obtaining a raw pointer\n                 // from a region pointer to a vector.\n \n+                // Coerce to a raw pointer so that we generate AddressOf in MIR.\n+                let array_ptr_type = fcx.tcx.mk_ptr(m_expr);\n+                fcx.try_coerce(self.expr, self.expr_ty, array_ptr_type, AllowTwoPhase::No)\n+                    .unwrap_or_else(|_| bug!(\n+                        \"could not cast from reference to array to pointer to array ({:?} to {:?})\",\n+                        self.expr_ty,\n+                        array_ptr_type,\n+                    ));\n+\n                 // this will report a type mismatch if needed\n                 fcx.demand_eqtype(self.span, ety, m_cast.ty);\n                 return Ok(CastKind::ArrayPtrCast);"}, {"sha": "30cb0d4f96766925203bac150276f09279a7087a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -36,10 +36,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_expr_closure(\n         &self,\n         expr: &hir::Expr,\n-        _capture: hir::CaptureClause,\n+        _capture: hir::CaptureBy,\n         decl: &'tcx hir::FnDecl,\n         body_id: hir::BodyId,\n-        gen: Option<hir::GeneratorMovability>,\n+        gen: Option<hir::Movability>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         debug!(\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         opt_kind: Option<ty::ClosureKind>,\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n-        gen: Option<hir::GeneratorMovability>,\n+        gen: Option<hir::Movability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n         debug!("}, {"sha": "a105755ca9aac3470e81f551fef3a63b7823d7fd", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -99,10 +99,10 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n                        -> RelateResult<'tcx, ()> {\n     match (from_mutbl, to_mutbl) {\n-        (hir::MutMutable, hir::MutMutable) |\n-        (hir::MutImmutable, hir::MutImmutable) |\n-        (hir::MutMutable, hir::MutImmutable) => Ok(()),\n-        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability),\n+        (hir::Mutability::Mutable, hir::Mutability::Mutable) |\n+        (hir::Mutability::Immutable, hir::Mutability::Immutable) |\n+        (hir::Mutability::Mutable, hir::Mutability::Immutable) => Ok(()),\n+        (hir::Mutability::Immutable, hir::Mutability::Mutable) => Err(TypeError::Mutability),\n     }\n }\n \n@@ -410,7 +410,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl == hir::Mutability::Immutable && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -422,7 +422,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n+            assert_eq!(mt_b.mutbl, hir::Mutability::Immutable); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -439,8 +439,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n-            hir::MutImmutable => AutoBorrowMutability::Immutable,\n-            hir::MutMutable => AutoBorrowMutability::Mutable {\n+            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                 allow_two_phase_borrow: self.allow_two_phase,\n             }\n         };\n@@ -485,8 +485,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n                 let mutbl = match mutbl_b {\n-                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                    hir::MutMutable => AutoBorrowMutability::Mutable {\n+                    hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                    hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                         // We don't allow two-phase borrows here, at least for initial\n                         // implementation. If it happens that this coercion is a function argument,\n                         // the reborrow in coerce_borrowed_ptr will pick it up."}, {"sha": "2f0b1c358f08dc8a9e2143ca137994e1f9467f62", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -10,7 +10,7 @@ use rustc::util::common::ErrorReported;\n use errors::{Applicability, DiagnosticId};\n \n use syntax_pos::Span;\n-use syntax::errors::pluralise;\n+use syntax::errors::pluralize;\n \n use super::{Inherited, FnCtxt, potentially_plural_count};\n \n@@ -532,8 +532,8 @@ fn compare_self_type<'tcx>(\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Immutable) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mutable) => \"&mut self\".to_owned(),\n                 _ => format!(\"self: {}\", self_arg_ty)\n             }\n         })\n@@ -649,9 +649,9 @@ fn compare_number_of_generics<'tcx>(\n                      declaration has {} {kind} parameter{}\",\n                     trait_.ident,\n                     impl_count,\n-                    pluralise!(impl_count),\n+                    pluralize!(impl_count),\n                     trait_count,\n-                    pluralise!(trait_count),\n+                    pluralize!(trait_count),\n                     kind = kind,\n                 ),\n                 DiagnosticId::Error(\"E0049\".into()),\n@@ -666,7 +666,7 @@ fn compare_number_of_generics<'tcx>(\n                         \"expected {} {} parameter{}\",\n                         trait_count,\n                         kind,\n-                        pluralise!(trait_count),\n+                        pluralize!(trait_count),\n                     ));\n                 }\n                 for span in spans {\n@@ -681,7 +681,7 @@ fn compare_number_of_generics<'tcx>(\n                     \"found {} {} parameter{}{}\",\n                     impl_count,\n                     kind,\n-                    pluralise!(impl_count),\n+                    pluralize!(impl_count),\n                     suffix.unwrap_or_else(|| String::new()),\n                 ));\n             }"}, {"sha": "5d9b3a8fba4d77e613f63ee23cdd65145ef265b4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }) = parent {\n                 if let Ok(src) = cm.span_to_snippet(sp) {\n                     for field in fields {\n-                        if field.ident.as_str() == src.as_str() && field.is_shorthand {\n+                        if field.ident.as_str() == src && field.is_shorthand {\n                             return true;\n                         }\n                     }\n@@ -398,24 +398,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // bar(&x); // error, expected &mut\n                 // ```\n                 let ref_ty = match mutability {\n-                    hir::Mutability::MutMutable => {\n+                    hir::Mutability::Mutable => {\n                         self.tcx.mk_mut_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n-                    hir::Mutability::MutImmutable => {\n+                    hir::Mutability::Immutable => {\n                         self.tcx.mk_imm_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n                     if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.kind {\n                         let clone_trait = self.tcx.lang_items().clone_trait().unwrap();\n-                        if let ([arg], Some(true), \"clone\") = (\n+                        if let ([arg], Some(true), sym::clone) = (\n                             &args[..],\n                             self.tables.borrow().type_dependent_def_id(expr.hir_id).map(|did| {\n                                 let ai = self.tcx.associated_item(did);\n                                 ai.container == ty::TraitContainer(clone_trait)\n                             }),\n-                            &segment.ident.as_str()[..],\n+                            segment.ident.name,\n                         ) {\n                             // If this expression had a clone call when suggesting borrowing\n                             // we want to suggest removing it because it'd now be unecessary.\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })) = self.tcx.hir().find(\n                             self.tcx.hir().get_parent_node(expr.hir_id),\n                         ) {\n-                            if mutability == hir::Mutability::MutMutable {\n+                            if mutability == hir::Mutability::Mutable {\n                                 // Found the following case:\n                                 // fn foo(opt: &mut Option<String>){ opt = None }\n                                 //                                   ---   ^^^^\n@@ -470,12 +470,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         return Some(match mutability {\n-                            hir::Mutability::MutMutable => (\n+                            hir::Mutability::Mutable => (\n                                 sp,\n                                 \"consider mutably borrowing here\",\n                                 format!(\"{}&mut {}\", field_name, sugg_expr),\n                             ),\n-                            hir::Mutability::MutImmutable => (\n+                            hir::Mutability::Immutable => (\n                                 sp,\n                                 \"consider borrowing here\",\n                                 format!(\"{}&{}\", field_name, sugg_expr),\n@@ -553,7 +553,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_for_cast(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,"}, {"sha": "cfe36b57c2da18ab86ec90627cca99477136bd7c", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88717319142e162ae2f48124d94f33d2c21bc2ce/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=88717319142e162ae2f48124d94f33d2c21bc2ce", "patch": "@@ -17,7 +17,7 @@ use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n \n-use errors::{Applicability, DiagnosticBuilder, pluralise};\n+use errors::{Applicability, DiagnosticBuilder, pluralize};\n use syntax_pos::hygiene::DesugaringKind;\n use syntax::ast;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -363,8 +363,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let method = self.register_infer_ok_obligations(ok);\n                         if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                             let mutbl = match mutbl {\n-                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                                     // (It shouldn't actually matter for unary ops whether\n                                     // we enable two-phase borrows or not, since a unary\n                                     // op has no additional operands.)\n@@ -583,21 +583,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     assert!(e_ty.is_unit());\n                     let ty = coerce.expected_ty();\n-                    coerce.coerce_forced_unit(self, &cause, &mut |err| {\n-                        let val = match ty.kind {\n-                            ty::Bool => \"true\",\n-                            ty::Char => \"'a'\",\n-                            ty::Int(_) | ty::Uint(_) => \"42\",\n-                            ty::Float(_) => \"3.14159\",\n-                            ty::Error | ty::Never => return,\n-                            _ => \"value\",\n-                        };\n-                        let msg = \"give it a value of the expected type\";\n-                        let label = destination.label\n-                            .map(|l| format!(\" {}\", l.ident))\n-                            .unwrap_or_else(String::new);\n-                        let sugg = format!(\"break{} {}\", label, val);\n-                        err.span_suggestion(expr.span, msg, sugg, Applicability::HasPlaceholders);\n+                    coerce.coerce_forced_unit(self, &cause, &mut |mut err| {\n+                        self.suggest_mismatched_types_on_tail(\n+                            &mut err,\n+                            expr,\n+                            ty,\n+                            e_ty,\n+                            cause.span,\n+                            target_id,\n+                        );\n+                        if let Some(val) = ty_kind_suggestion(ty) {\n+                            let label = destination.label\n+                                .map(|l| format!(\" {}\", l.ident))\n+                                .unwrap_or_else(String::new);\n+                            err.span_suggestion(\n+                                expr.span,\n+                                \"give it a value of the expected type\",\n+                                format!(\"break{} {}\", label, val),\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n                     }, false);\n                 }\n             } else {\n@@ -1210,7 +1215,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             struct_span_err!(tcx.sess, span, E0063,\n                              \"missing field{} {}{} in initializer of `{}`\",\n-                             pluralise!(remaining_fields.len()),\n+                             pluralize!(remaining_fields.len()),\n                              remaining_fields_names,\n                              truncated_fields_error,\n                              adt_ty)\n@@ -1717,3 +1722,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.mk_unit()\n     }\n }\n+\n+pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n+    Some(match ty.kind {\n+        ty::Bool => \"true\",\n+        ty::Char => \"'a'\",\n+        ty::Int(_) | ty::Uint(_) => \"42\",\n+        ty::Float(_) => \"3.14159\",\n+        ty::Error | ty::Never => return None,\n+        _ => \"value\",\n+    })\n+}"}]}