{"sha": "c37ee1a7e04419bf91a280357bfbb950d99512b3", "node_id": "C_kwDOAAsO6NoAKGMzN2VlMWE3ZTA0NDE5YmY5MWEyODAzNTdiZmJiOTUwZDk5NTEyYjM", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-07-27T15:55:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-27T15:55:07Z"}, "message": "Rollup merge of #99728 - cjgillot:ast-lifetimes-anon-clean, r=petrochenkov\n\nClean up HIR-based lifetime resolution\n\nBased on https://github.com/rust-lang/rust/pull/97313.\n\nFixes #98932.\n\nr? `@petrochenkov`", "tree": {"sha": "69357e651fe65c3e40fe9899aad8e06746b399a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69357e651fe65c3e40fe9899aad8e06746b399a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c37ee1a7e04419bf91a280357bfbb950d99512b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi4V/bCRBK7hj4Ov3rIwAAqZ8IAJZDuXcwzp6YTJIKrmAj6EWG\nXXHViMsUMhRsiJxFCNA4ep1U9aJeMhFz4ccYVfoPs2n1da6gF2y+JNJlc3vZtXvn\nokcCSKSFii1bJ2ntZ+1wybaPvilk+SgHXOY988ZBtfiSnd+zIWJxEN4n1D7fYFzD\nc5hHjmf092cXE4gojIiPlR9QmZI8XLJ8Z8EGtu2xkga3rMpwzpkM7x+Q/hgUo1o8\nDCpoLf3RyIX6Z+MGn70+O/uJNXju3g0bChoAMscRkHoOrqLqGkjPFIQZASfuBO5M\nNI/EUHnhLfns0PWciBQjn9kDAay/acla4JdfWIoQnqPhKo/sleMT/XbqEGpNrKI=\n=h39B\n-----END PGP SIGNATURE-----\n", "payload": "tree 69357e651fe65c3e40fe9899aad8e06746b399a4\nparent a7f4eb995589283d5729e6a99f578da9ab043988\nparent 4b2f06b8a91fde63a744c4b297030893d4a92c92\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1658937307 +0200\ncommitter GitHub <noreply@github.com> 1658937307 +0200\n\nRollup merge of #99728 - cjgillot:ast-lifetimes-anon-clean, r=petrochenkov\n\nClean up HIR-based lifetime resolution\n\nBased on https://github.com/rust-lang/rust/pull/97313.\n\nFixes #98932.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c37ee1a7e04419bf91a280357bfbb950d99512b3", "html_url": "https://github.com/rust-lang/rust/commit/c37ee1a7e04419bf91a280357bfbb950d99512b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c37ee1a7e04419bf91a280357bfbb950d99512b3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f4eb995589283d5729e6a99f578da9ab043988", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f4eb995589283d5729e6a99f578da9ab043988", "html_url": "https://github.com/rust-lang/rust/commit/a7f4eb995589283d5729e6a99f578da9ab043988"}, {"sha": "4b2f06b8a91fde63a744c4b297030893d4a92c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b2f06b8a91fde63a744c4b297030893d4a92c92", "html_url": "https://github.com/rust-lang/rust/commit/4b2f06b8a91fde63a744c4b297030893d4a92c92"}], "stats": {"total": 949, "additions": 202, "deletions": 747}, "files": [{"sha": "a1bf0f94964bb70e8d342dd18b868482cb0bbb89", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -1883,29 +1883,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n-            LifetimeRes::Anonymous { binder, elided } => {\n-                let mut l_name = None;\n-                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n-                        let p_id = self.next_node_id();\n-                        let p_def_id = self.create_def(\n-                            captured_lifetimes.parent_def_id,\n-                            p_id,\n-                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                        );\n-                        captured_lifetimes\n-                            .captures\n-                            .insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n-                        l_name = Some(hir::LifetimeName::Param(p_def_id, ParamName::Fresh));\n-                    }\n-                    self.captured_lifetimes = Some(captured_lifetimes);\n-                };\n-                l_name.unwrap_or(if elided {\n-                    hir::LifetimeName::Implicit\n-                } else {\n-                    hir::LifetimeName::Underscore\n-                })\n-            }\n+            LifetimeRes::Infer => hir::LifetimeName::Infer,\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),"}, {"sha": "0662d4d882f6a8cdda2215ee29dec8dbdac5995b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -589,8 +589,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n             hir::LifetimeName::Param(_, hir::ParamName::Fresh)\n             | hir::LifetimeName::ImplicitObjectLifetimeDefault\n-            | hir::LifetimeName::Implicit\n-            | hir::LifetimeName::Underscore => {\n+            | hir::LifetimeName::Infer => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "be5b7eccbafb2ef34cc1bd53fd2924fe265ac2fe", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -738,13 +738,8 @@ pub enum LifetimeRes {\n         binder: NodeId,\n     },\n     /// This variant is used for anonymous lifetimes that we did not resolve during\n-    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n-    Anonymous {\n-        /// Id of the introducing place. See `Param`.\n-        binder: NodeId,\n-        /// Whether this lifetime was spelled or elided.\n-        elided: bool,\n-    },\n+    /// late resolution.  Those lifetimes will be inferred by typechecking.\n+    Infer,\n     /// Explicit `'static` lifetime.\n     Static,\n     /// Resolution failure."}, {"sha": "f71400898e60b44fa561f49917a481dd650c9ce5", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -90,9 +90,6 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(LocalDefId, ParamName),\n \n-    /// User wrote nothing (e.g., the lifetime in `&u32`).\n-    Implicit,\n-\n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n     /// lifetime that they default to must appear elsewhere within the\n@@ -110,8 +107,9 @@ pub enum LifetimeName {\n     /// that was already reported.\n     Error,\n \n-    /// User wrote specifies `'_`.\n-    Underscore,\n+    /// User wrote an anonymous lifetime, either `'_` or nothing.\n+    /// The semantics of this lifetime should be inferred by typechecking code.\n+    Infer,\n \n     /// User wrote `'static`.\n     Static,\n@@ -120,10 +118,8 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n-            | LifetimeName::Error => Ident::empty(),\n-            LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n+            LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Error => Ident::empty(),\n+            LifetimeName::Infer => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(_, param_name) => param_name.ident(),\n         }\n@@ -132,8 +128,7 @@ impl LifetimeName {\n     pub fn is_anonymous(&self) -> bool {\n         match *self {\n             LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n-            | LifetimeName::Underscore\n+            | LifetimeName::Infer\n             | LifetimeName::Param(_, ParamName::Fresh)\n             | LifetimeName::Error => true,\n             LifetimeName::Static | LifetimeName::Param(..) => false,\n@@ -142,9 +137,7 @@ impl LifetimeName {\n \n     pub fn is_elided(&self) -> bool {\n         match self {\n-            LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n-            | LifetimeName::Underscore => true,\n+            LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Infer => true,\n \n             // It might seem surprising that `Fresh` counts as\n             // *not* elided -- but this is because, as far as the code"}, {"sha": "640974115b926e2075a9b26f42d13c3c7b4c0352", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -496,9 +496,8 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         | LifetimeName::Param(_, ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n-        | LifetimeName::Implicit\n         | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Underscore => {}\n+        | LifetimeName::Infer => {}\n     }\n }\n "}, {"sha": "c1b201da69121c92e5a1b2e63a068a90836a376a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -100,23 +100,6 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                 // the lifetime of the TyRptr\n                 let hir_id = lifetime.hir_id;\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n-                    // Find the index of the anonymous region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (\n-                        Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n-                        ty::BrAnon(br_index),\n-                    ) => {\n-                        debug!(\n-                            \"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n-                            debruijn_index, anon_index, br_index\n-                        );\n-                        if debruijn_index == self.current_index && anon_index == br_index {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n@@ -151,8 +134,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n                             | rl::Region::EarlyBound(_, _)\n-                            | rl::Region::LateBound(_, _, _)\n-                            | rl::Region::LateBoundAnon(_, _, _),\n+                            | rl::Region::LateBound(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -206,16 +188,6 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (\n-                Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n-                ty::BrAnon(br_index),\n-            ) => {\n-                if debruijn_index == self.current_index && anon_index == br_index {\n-                    self.found_it = true;\n-                    return;\n-                }\n-            }\n-\n             (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n@@ -239,7 +211,6 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n                     rl::Region::Static\n                     | rl::Region::EarlyBound(_, _)\n                     | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::LateBoundAnon(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )\n                 | None,"}, {"sha": "9b2f44567053225e81a7b2f6c19d71a0819b0d26", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -12,7 +12,6 @@ pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n     LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n-    LateBoundAnon(ty::DebruijnIndex, /* late-bound index */ u32, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n "}, {"sha": "ed65100ae77511584e0c70b190c899be0e15d18a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 104, "deletions": 135, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -262,9 +262,6 @@ enum LifetimeRibKind {\n     /// error on default object bounds (e.g., `Box<dyn Foo>`).\n     AnonymousReportError,\n \n-    /// Pass responsibility to `resolve_lifetime` code for all cases.\n-    AnonymousPassThrough(NodeId),\n-\n     /// Replace all anonymous lifetimes by provided lifetime.\n     Elided(LifetimeRes),\n \n@@ -698,14 +695,25 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     },\n                     |this| {\n                         this.visit_generic_params(&bare_fn.generic_params, false);\n-                        this.resolve_fn_signature(\n-                            ty.id,\n-                            None,\n-                            false,\n-                            // We don't need to deal with patterns in parameters, because\n-                            // they are not possible for foreign or bodiless functions.\n-                            bare_fn.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n-                            &bare_fn.decl.output,\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: ty.id,\n+                                report_in_path: false,\n+                            },\n+                            |this| {\n+                                this.resolve_fn_signature(\n+                                    ty.id,\n+                                    false,\n+                                    // We don't need to deal with patterns in parameters, because\n+                                    // they are not possible for foreign or bodiless functions.\n+                                    bare_fn\n+                                        .decl\n+                                        .inputs\n+                                        .iter()\n+                                        .map(|Param { ty, .. }| (None, &**ty)),\n+                                    &bare_fn.decl.output,\n+                                )\n+                            },\n                         );\n                     },\n                 )\n@@ -785,12 +793,19 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n                 self.visit_fn_header(&sig.header);\n                 self.visit_generics(generics);\n-                self.resolve_fn_signature(\n-                    fn_id,\n-                    None,\n-                    sig.decl.has_self(),\n-                    sig.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n-                    &sig.decl.output,\n+                self.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousCreateParameter {\n+                        binder: fn_id,\n+                        report_in_path: false,\n+                    },\n+                    |this| {\n+                        this.resolve_fn_signature(\n+                            fn_id,\n+                            sig.decl.has_self(),\n+                            sig.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n+                            &sig.decl.output,\n+                        )\n+                    },\n                 );\n                 return;\n             }\n@@ -815,15 +830,22 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         let declaration = &sig.decl;\n                         let async_node_id = sig.header.asyncness.opt_return_id();\n \n-                        this.resolve_fn_signature(\n-                            fn_id,\n-                            async_node_id,\n-                            declaration.has_self(),\n-                            declaration\n-                                .inputs\n-                                .iter()\n-                                .map(|Param { pat, ty, .. }| (Some(&**pat), &**ty)),\n-                            &declaration.output,\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: fn_id,\n+                                report_in_path: async_node_id.is_some(),\n+                            },\n+                            |this| {\n+                                this.resolve_fn_signature(\n+                                    fn_id,\n+                                    declaration.has_self(),\n+                                    declaration\n+                                        .inputs\n+                                        .iter()\n+                                        .map(|Param { pat, ty, .. }| (Some(&**pat), &**ty)),\n+                                    &declaration.output,\n+                                )\n+                            },\n                         );\n \n                         // Construct the list of in-scope lifetime parameters for async lowering.\n@@ -868,7 +890,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             let previous_state = replace(&mut this.in_func_body, true);\n                             // Resolve the function body, potentially inside the body of an async closure\n                             this.with_lifetime_rib(\n-                                LifetimeRibKind::AnonymousPassThrough(fn_id),\n+                                LifetimeRibKind::Elided(LifetimeRes::Infer),\n                                 |this| this.visit_block(body),\n                             );\n \n@@ -896,7 +918,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         this.with_lifetime_rib(\n                             match binder {\n                                 ClosureBinder::NotPresent => {\n-                                    LifetimeRibKind::AnonymousPassThrough(fn_id)\n+                                    LifetimeRibKind::Elided(LifetimeRes::Infer)\n                                 }\n                                 ClosureBinder::For { .. } => LifetimeRibKind::AnonymousReportError,\n                             },\n@@ -908,7 +930,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         let previous_state = replace(&mut this.in_func_body, true);\n                         // Resolve the function body, potentially inside the body of an async closure\n                         this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(fn_id),\n+                            LifetimeRibKind::Elided(LifetimeRes::Infer),\n                             |this| this.visit_expr(body),\n                         );\n \n@@ -1038,12 +1060,19 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 kind: LifetimeBinderKind::PolyTrait,\n                                 ..\n                             } => {\n-                                self.resolve_fn_signature(\n-                                    binder,\n-                                    None,\n-                                    false,\n-                                    p_args.inputs.iter().map(|ty| (None, &**ty)),\n-                                    &p_args.output,\n+                                self.with_lifetime_rib(\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder,\n+                                        report_in_path: false,\n+                                    },\n+                                    |this| {\n+                                        this.resolve_fn_signature(\n+                                            binder,\n+                                            false,\n+                                            p_args.inputs.iter().map(|ty| (None, &**ty)),\n+                                            &p_args.output,\n+                                        )\n+                                    },\n                                 );\n                                 break;\n                             }\n@@ -1053,8 +1082,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 visit::walk_generic_args(self, path_span, args);\n                                 break;\n                             }\n-                            LifetimeRibKind::AnonymousPassThrough(..)\n-                            | LifetimeRibKind::AnonymousCreateParameter { .. }\n+                            LifetimeRibKind::AnonymousCreateParameter { .. }\n                             | LifetimeRibKind::AnonymousReportError\n                             | LifetimeRibKind::Elided(_)\n                             | LifetimeRibKind::ElisionFailure\n@@ -1415,8 +1443,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                     | LifetimeRibKind::AnonymousReportError\n                                     | LifetimeRibKind::ElisionFailure => Some(LifetimeUseSet::Many),\n                                     // An anonymous lifetime is legal here, go ahead.\n-                                    LifetimeRibKind::AnonymousPassThrough(_)\n-                                    | LifetimeRibKind::AnonymousCreateParameter { .. } => {\n+                                    LifetimeRibKind::AnonymousCreateParameter { .. } => {\n                                         Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n                                     }\n                                     // Only report if eliding the lifetime would have the same\n@@ -1527,14 +1554,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n                     return;\n                 }\n-                LifetimeRibKind::AnonymousPassThrough(node_id) => {\n-                    self.record_lifetime_res(\n-                        lifetime.id,\n-                        LifetimeRes::Anonymous { binder: node_id, elided },\n-                        elision_candidate,\n-                    );\n-                    return;\n-                }\n                 LifetimeRibKind::Elided(res) => {\n                     self.record_lifetime_res(lifetime.id, res, elision_candidate);\n                     return;\n@@ -1632,6 +1651,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 | PathSource::Struct\n                 | PathSource::TupleStruct(..) => false,\n             };\n+            if !missing && !segment.has_generic_args {\n+                continue;\n+            }\n \n             let elided_lifetime_span = if segment.has_generic_args {\n                 // If there are brackets, but not generic arguments, then use the opening bracket\n@@ -1653,37 +1675,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             if !missing {\n                 // Do not create a parameter for patterns and expressions.\n-                for rib in self.lifetime_ribs.iter().rev() {\n-                    match rib.kind {\n-                        LifetimeRibKind::AnonymousPassThrough(binder) => {\n-                            let res = LifetimeRes::Anonymous { binder, elided: true };\n-                            for id in node_ids {\n-                                self.record_lifetime_res(id, res, LifetimeElisionCandidate::Named);\n-                            }\n-                            break;\n-                        }\n-                        // `LifetimeRes::Error`, which would usually be used in the case of\n-                        // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n-                        // we simply resolve to an implicit lifetime, which will be checked later, at\n-                        // which point a suitable error will be emitted.\n-                        LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n-                            // FIXME(cjgillot) This resolution is wrong, but this does not matter\n-                            // since these cases are erroneous anyway.  Lifetime resolution should\n-                            // emit a \"missing lifetime specifier\" diagnostic.\n-                            let res =\n-                                LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n-                            for id in node_ids {\n-                                self.record_lifetime_res(id, res, LifetimeElisionCandidate::Named);\n-                            }\n-                            break;\n-                        }\n-                        LifetimeRibKind::AnonymousCreateParameter { .. }\n-                        | LifetimeRibKind::Elided(_)\n-                        | LifetimeRibKind::ElisionFailure\n-                        | LifetimeRibKind::Generics { .. }\n-                        | LifetimeRibKind::ConstGeneric\n-                        | LifetimeRibKind::AnonConst => {}\n-                    }\n+                for id in node_ids {\n+                    self.record_lifetime_res(\n+                        id,\n+                        LifetimeRes::Infer,\n+                        LifetimeElisionCandidate::Named,\n+                    );\n                 }\n                 continue;\n             }\n@@ -1750,19 +1747,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         }\n                         break;\n                     }\n-                    // `PassThrough` is the normal case.\n-                    LifetimeRibKind::AnonymousPassThrough(binder) => {\n-                        let res = LifetimeRes::Anonymous { binder, elided: true };\n-                        let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n-                        for id in node_ids {\n-                            self.record_lifetime_res(\n-                                id,\n-                                res,\n-                                replace(&mut candidate, LifetimeElisionCandidate::Ignore),\n-                            );\n-                        }\n-                        break;\n-                    }\n                     LifetimeRibKind::Elided(res) => {\n                         let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n                         for id in node_ids {\n@@ -1837,15 +1821,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             )\n         }\n         match res {\n-            LifetimeRes::Param { .. }\n-            | LifetimeRes::Fresh { .. }\n-            | LifetimeRes::Anonymous { .. }\n-            | LifetimeRes::Static => {\n+            LifetimeRes::Param { .. } | LifetimeRes::Fresh { .. } | LifetimeRes::Static => {\n                 if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n                     candidates.insert(res, candidate);\n                 }\n             }\n-            LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n+            LifetimeRes::Infer | LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n         }\n     }\n \n@@ -1864,18 +1845,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn resolve_fn_signature(\n         &mut self,\n         fn_id: NodeId,\n-        async_node_id: Option<NodeId>,\n         has_self: bool,\n         inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)> + Clone,\n         output_ty: &'ast FnRetTy,\n     ) {\n         // Add each argument to the rib.\n-        let parameter_rib = LifetimeRibKind::AnonymousCreateParameter {\n-            binder: fn_id,\n-            report_in_path: async_node_id.is_some(),\n-        };\n-        let elision_lifetime =\n-            self.with_lifetime_rib(parameter_rib, |this| this.resolve_fn_params(has_self, inputs));\n+        let elision_lifetime = self.resolve_fn_params(has_self, inputs);\n         debug!(?elision_lifetime);\n \n         let outer_failures = take(&mut self.diagnostic_metadata.current_elision_failures);\n@@ -2268,26 +2243,23 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Static), |this| {\n                         this.visit_ty(ty);\n                     });\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(item.id),\n-                        |this| {\n-                            if let Some(expr) = expr {\n-                                let constant_item_kind = match item.kind {\n-                                    ItemKind::Const(..) => ConstantItemKind::Const,\n-                                    ItemKind::Static(..) => ConstantItemKind::Static,\n-                                    _ => unreachable!(),\n-                                };\n-                                // We already forbid generic params because of the above item rib,\n-                                // so it doesn't matter whether this is a trivial constant.\n-                                this.with_constant_rib(\n-                                    IsRepeatExpr::No,\n-                                    HasGenericParams::Yes,\n-                                    Some((item.ident, constant_item_kind)),\n-                                    |this| this.visit_expr(expr),\n-                                );\n-                            }\n-                        },\n-                    );\n+                    this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                        if let Some(expr) = expr {\n+                            let constant_item_kind = match item.kind {\n+                                ItemKind::Const(..) => ConstantItemKind::Const,\n+                                ItemKind::Static(..) => ConstantItemKind::Static,\n+                                _ => unreachable!(),\n+                            };\n+                            // We already forbid generic params because of the above item rib,\n+                            // so it doesn't matter whether this is a trivial constant.\n+                            this.with_constant_rib(\n+                                IsRepeatExpr::No,\n+                                HasGenericParams::Yes,\n+                                Some((item.ident, constant_item_kind)),\n+                                |this| this.visit_expr(expr),\n+                            );\n+                        }\n+                    });\n                 });\n             }\n \n@@ -2544,7 +2516,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         // Type parameters can already be used and as associated consts are\n                         // not used as part of the type system, this is far less surprising.\n                         self.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(item.id),\n+                            LifetimeRibKind::Elided(LifetimeRes::Infer),\n                             |this| {\n                                 this.with_constant_rib(\n                                     IsRepeatExpr::No,\n@@ -2717,17 +2689,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     //\n                     // Type parameters can already be used and as associated consts are\n                     // not used as part of the type system, this is far less surprising.\n-                    self.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(item.id),\n-                        |this| {\n-                            this.with_constant_rib(\n-                                IsRepeatExpr::No,\n-                                HasGenericParams::Yes,\n-                                None,\n-                                |this| this.visit_expr(expr),\n-                            )\n-                        },\n-                    );\n+                    self.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                        this.with_constant_rib(\n+                            IsRepeatExpr::No,\n+                            HasGenericParams::Yes,\n+                            None,\n+                            |this| this.visit_expr(expr),\n+                        )\n+                    });\n                 }\n             }\n             AssocItemKind::Fn(box Fn { generics, .. }) => {"}, {"sha": "94460e33d8b01a62b8be14afca238e9da2680555", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 56, "deletions": 512, "changes": 568, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! Resolution of early vs late bound lifetimes.\n //!\n //! Name resolution for lifetimes is performed on the AST and embedded into HIR.  From this\n@@ -21,10 +20,9 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::borrow::Cow;\n-use std::cell::Cell;\n use std::fmt;\n use std::mem::take;\n \n@@ -33,8 +31,6 @@ trait RegionExt {\n \n     fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n-    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n-\n     fn id(&self) -> Option<DefId>;\n \n     fn shifted(self, amount: u32) -> Region;\n@@ -65,16 +61,9 @@ impl RegionExt for Region {\n         (def_id, Region::LateBound(depth, idx, def_id.to_def_id()))\n     }\n \n-    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region {\n-        let i = index.get();\n-        index.set(i + 1);\n-        let depth = ty::INNERMOST;\n-        Region::LateBoundAnon(depth, named_late_bound_vars + i, i)\n-    }\n-\n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static | Region::LateBoundAnon(..) => None,\n+            Region::Static => None,\n \n             Region::EarlyBound(_, id) | Region::LateBound(_, _, id) | Region::Free(_, id) => {\n                 Some(id)\n@@ -87,9 +76,6 @@ impl RegionExt for Region {\n             Region::LateBound(debruijn, idx, id) => {\n                 Region::LateBound(debruijn.shifted_in(amount), idx, id)\n             }\n-            Region::LateBoundAnon(debruijn, index, anon_index) => {\n-                Region::LateBoundAnon(debruijn.shifted_in(amount), index, anon_index)\n-            }\n             _ => self,\n         }\n     }\n@@ -99,9 +85,6 @@ impl RegionExt for Region {\n             Region::LateBound(debruijn, index, id) => {\n                 Region::LateBound(debruijn.shifted_out_to_binder(binder), index, id)\n             }\n-            Region::LateBoundAnon(debruijn, index, anon_index) => {\n-                Region::LateBoundAnon(debruijn.shifted_out_to_binder(binder), index, anon_index)\n-            }\n             _ => self,\n         }\n     }\n@@ -193,10 +176,6 @@ enum Scope<'a> {\n \n         s: ScopeRef<'a>,\n \n-        /// In some cases not allowing late bounds allows us to avoid ICEs.\n-        /// This is almost ways set to true.\n-        allow_late_bound: bool,\n-\n         /// If this binder comes from a where clause, specify how it was created.\n         /// This is used to diagnose inaccessible lifetimes in APIT:\n         /// ```ignore (illustrative)\n@@ -215,9 +194,8 @@ enum Scope<'a> {\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n-    /// on them (e.g., due to ambiguity). For more details, see `Elide`.\n+    /// on them (e.g., due to ambiguity).\n     Elision {\n-        elide: Elide,\n         s: ScopeRef<'a>,\n     },\n \n@@ -273,7 +251,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 opaque_type_parent,\n                 scope_type,\n                 hir_id,\n-                allow_late_bound,\n                 where_bound_origin,\n                 s: _,\n             } => f\n@@ -283,16 +260,13 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n-                .field(\"allow_late_bound\", allow_late_bound)\n                 .field(\"where_bound_origin\", where_bound_origin)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::Body { id, s: _ } => {\n                 f.debug_struct(\"Body\").field(\"id\", id).field(\"s\", &\"..\").finish()\n             }\n-            Scope::Elision { elide, s: _ } => {\n-                f.debug_struct(\"Elision\").field(\"elide\", elide).field(\"s\", &\"..\").finish()\n-            }\n+            Scope::Elision { s: _ } => f.debug_struct(\"Elision\").field(\"s\", &\"..\").finish(),\n             Scope::ObjectLifetimeDefault { lifetime, s: _ } => f\n                 .debug_struct(\"ObjectLifetimeDefault\")\n                 .field(\"lifetime\", lifetime)\n@@ -309,21 +283,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-enum Elide {\n-    /// Use a fresh anonymous late-bound lifetime each time, by\n-    /// incrementing the counter to generate sequential indices. All\n-    /// anonymous lifetimes must start *after* named bound vars.\n-    FreshLateAnon(u32, Cell<u32>),\n-    /// Always use this one lifetime.\n-    Exact(Region),\n-    /// Less or more than one lifetime were found, error on unspecified.\n-    Error,\n-    /// Forbid lifetime elision inside of a larger scope where it would be\n-    /// permitted. For example, in let position impl trait.\n-    Forbid,\n-}\n-\n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n@@ -486,9 +445,6 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n             ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n         }\n-        Region::LateBoundAnon(_, _, anon_idx) => {\n-            ty::BoundVariableKind::Region(ty::BrAnon(*anon_idx))\n-        }\n         _ => bug!(\"{:?} is not a late region\", region),\n     }\n }\n@@ -623,7 +579,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 next_early_index,\n                 opaque_type_parent: false,\n                 scope_type: BinderScopeType::Normal,\n-                allow_late_bound: true,\n                 where_bound_origin: None,\n             };\n \n@@ -664,8 +619,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n-                let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n-                self.with(scope, |this| intravisit::walk_item(this, item));\n+                self.with(Scope::Elision { s: self.scope }, |this| {\n+                    intravisit::walk_item(this, item)\n+                });\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n                 // Opaque types are visited when we visit the\n@@ -741,7 +697,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n-                    allow_late_bound: false,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -794,7 +749,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: true,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -819,13 +773,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // `Box<dyn Debug + 'static>`.\n                         self.resolve_object_lifetime_default(lifetime)\n                     }\n-                    LifetimeName::Implicit | LifetimeName::Underscore => {\n+                    LifetimeName::Infer => {\n                         // If the user writes `'_`, we use the *ordinary* elision\n                         // rules. So the `'_` in e.g., `Box<dyn Debug + '_>` will be\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n-                        self.resolve_elided_lifetimes(&[lifetime])\n                     }\n                     LifetimeName::Param(..) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n@@ -860,7 +813,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // position impl Trait\n                         let scope = Scope::TraitRefBoundary { s: self.scope };\n                         self.with(scope, |this| {\n-                            let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n+                            let scope = Scope::Elision { s: this.scope };\n                             this.with(scope, |this| {\n                                 intravisit::walk_item(this, opaque_ty);\n                             })\n@@ -936,7 +889,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index_for_opaque_type();\n                 debug!(?index);\n \n-                let mut elision = None;\n                 let mut lifetimes = FxIndexMap::default();\n                 let mut non_lifetime_count = 0;\n                 debug!(?generics.params);\n@@ -945,15 +897,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             lifetimes.insert(def_id, reg);\n-                            if let hir::ParamName::Plain(Ident {\n-                                name: kw::UnderscoreLifetime,\n-                                ..\n-                            }) = param.name\n-                            {\n-                                // Pick the elided lifetime \"definition\" if one exists\n-                                // and use it to make an elision scope.\n-                                elision = Some(reg);\n-                            }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -963,51 +906,24 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let next_early_index = index + non_lifetime_count;\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n-                if let Some(elision_region) = elision {\n-                    let scope =\n-                        Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n-                    self.with(scope, |this| {\n-                        let scope = Scope::Binder {\n-                            hir_id: ty.hir_id,\n-                            lifetimes,\n-                            next_early_index,\n-                            s: this.scope,\n-                            opaque_type_parent: false,\n-                            scope_type: BinderScopeType::Normal,\n-                            allow_late_bound: false,\n-                            where_bound_origin: None,\n-                        };\n-                        this.with(scope, |this| {\n-                            this.visit_generics(generics);\n-                            let scope = Scope::TraitRefBoundary { s: this.scope };\n-                            this.with(scope, |this| {\n-                                for bound in bounds {\n-                                    this.visit_param_bound(bound);\n-                                }\n-                            })\n-                        });\n-                    });\n-                } else {\n-                    let scope = Scope::Binder {\n-                        hir_id: ty.hir_id,\n-                        lifetimes,\n-                        next_early_index,\n-                        s: self.scope,\n-                        opaque_type_parent: false,\n-                        scope_type: BinderScopeType::Normal,\n-                        allow_late_bound: false,\n-                        where_bound_origin: None,\n-                    };\n-                    self.with(scope, |this| {\n-                        let scope = Scope::TraitRefBoundary { s: this.scope };\n-                        this.with(scope, |this| {\n-                            this.visit_generics(generics);\n-                            for bound in bounds {\n-                                this.visit_param_bound(bound);\n-                            }\n-                        })\n-                    });\n-                }\n+                let scope = Scope::Binder {\n+                    hir_id: ty.hir_id,\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    opaque_type_parent: false,\n+                    scope_type: BinderScopeType::Normal,\n+                    where_bound_origin: None,\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |this| {\n+                        this.visit_generics(generics);\n+                        for bound in bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+                    })\n+                });\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }\n@@ -1051,7 +967,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: false,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -1113,7 +1028,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: true,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -1135,15 +1049,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         match lifetime_ref.name {\n-            hir::LifetimeName::ImplicitObjectLifetimeDefault\n-            | hir::LifetimeName::Implicit\n-            | hir::LifetimeName::Underscore => self.resolve_elided_lifetimes(&[lifetime_ref]),\n             hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n             hir::LifetimeName::Param(param_def_id, _) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n             // If we've already reported an error, just ignore `lifetime_ref`.\n             hir::LifetimeName::Error => {}\n+            // Those will be resolved by typechecking.\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Infer => {}\n         }\n     }\n \n@@ -1156,12 +1069,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'tcx>,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        _: Span,\n+        _: hir::HirId,\n+    ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n             hir::FnRetTy::Return(ref ty) => Some(&**ty),\n         };\n-        self.visit_fn_like_elision(&fd.inputs, output);\n+        self.visit_fn_like_elision(&fd.inputs, output, matches!(fk, intravisit::FnKind::Closure));\n+        intravisit::walk_fn_kind(self, fk);\n+        self.visit_nested_body(body_id)\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n@@ -1219,7 +1141,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n-                            allow_late_bound: true,\n                             where_bound_origin: Some(origin),\n                         };\n                         this.with(scope, |this| {\n@@ -1292,7 +1213,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: self.next_early_index(),\n                     opaque_type_parent: false,\n                     scope_type,\n-                    allow_late_bound: true,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -1343,7 +1263,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             next_early_index,\n             opaque_type_parent: false,\n             scope_type,\n-            allow_late_bound: true,\n             where_bound_origin: None,\n         };\n         self.with(scope, |this| {\n@@ -1597,7 +1516,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             s: self.scope,\n             opaque_type_parent: true,\n             scope_type: BinderScopeType::Normal,\n-            allow_late_bound: true,\n             where_bound_origin: None,\n         };\n         self.with(scope, walk);\n@@ -1773,30 +1691,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n \n         if generic_args.parenthesized {\n-            self.visit_fn_like_elision(generic_args.inputs(), Some(generic_args.bindings[0].ty()));\n+            self.visit_fn_like_elision(\n+                generic_args.inputs(),\n+                Some(generic_args.bindings[0].ty()),\n+                false,\n+            );\n             return;\n         }\n \n-        let mut elide_lifetimes = true;\n-        let lifetimes: Vec<_> = generic_args\n-            .args\n-            .iter()\n-            .filter_map(|arg| match arg {\n-                hir::GenericArg::Lifetime(lt) => {\n-                    if !lt.is_elided() {\n-                        elide_lifetimes = false;\n-                    }\n-                    Some(lt)\n-                }\n-                _ => None,\n-            })\n-            .collect();\n-        // We short-circuit here if all are elided in order to pluralize\n-        // possible errors\n-        if elide_lifetimes {\n-            self.resolve_elided_lifetimes(&lifetimes);\n-        } else {\n-            lifetimes.iter().for_each(|lt| self.visit_lifetime(lt));\n+        for arg in generic_args.args {\n+            if let hir::GenericArg::Lifetime(lt) = arg {\n+                self.visit_lifetime(lt);\n+            }\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -2052,380 +1958,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         &mut self,\n         inputs: &'tcx [hir::Ty<'tcx>],\n         output: Option<&'tcx hir::Ty<'tcx>>,\n+        in_closure: bool,\n     ) {\n-        debug!(\"visit_fn_like_elision: enter\");\n-        let mut scope = &*self.scope;\n-        let hir_id = loop {\n-            match scope {\n-                Scope::Binder { hir_id, allow_late_bound: true, .. } => {\n-                    break *hir_id;\n-                }\n-                Scope::ObjectLifetimeDefault { ref s, .. }\n-                | Scope::Elision { ref s, .. }\n-                | Scope::Supertrait { ref s, .. }\n-                | Scope::TraitRefBoundary { ref s, .. } => {\n-                    scope = *s;\n-                }\n-                Scope::Root\n-                | Scope::Body { .. }\n-                | Scope::Binder { allow_late_bound: false, .. } => {\n-                    // See issues #83907 and #83693. Just bail out from looking inside.\n-                    // See the issue #95023 for not allowing late bound\n-                    self.tcx.sess.delay_span_bug(\n-                        rustc_span::DUMMY_SP,\n-                        \"In fn_like_elision without appropriate scope above\",\n-                    );\n-                    return;\n-                }\n-            }\n-        };\n-        // While not strictly necessary, we gather anon lifetimes *before* actually\n-        // visiting the argument types.\n-        let mut gather = GatherAnonLifetimes { anon_count: 0 };\n-        for input in inputs {\n-            gather.visit_ty(input);\n-        }\n-        trace!(?gather.anon_count);\n-        let late_bound_vars = self.map.late_bound_vars.entry(hir_id).or_default();\n-        let named_late_bound_vars = late_bound_vars.len() as u32;\n-        late_bound_vars.extend(\n-            (0..gather.anon_count).map(|var| ty::BoundVariableKind::Region(ty::BrAnon(var))),\n-        );\n-        let arg_scope = Scope::Elision {\n-            elide: Elide::FreshLateAnon(named_late_bound_vars, Cell::new(0)),\n-            s: self.scope,\n-        };\n-        self.with(arg_scope, |this| {\n+        self.with(Scope::Elision { s: self.scope }, |this| {\n             for input in inputs {\n                 this.visit_ty(input);\n             }\n-        });\n-\n-        let Some(output) = output else { return };\n-\n-        debug!(\"determine output\");\n-\n-        // Figure out if there's a body we can get argument names from,\n-        // and whether there's a `self` argument (treated specially).\n-        let mut assoc_item_kind = None;\n-        let mut impl_self = None;\n-        let parent = self.tcx.hir().get_parent_node(output.hir_id);\n-        match self.tcx.hir().get(parent) {\n-            // `fn` definitions and methods.\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. }) => {}\n-\n-            Node::TraitItem(&hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. }) => {\n-                if let hir::ItemKind::Trait(.., ref trait_items) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n-                {\n-                    assoc_item_kind =\n-                        trait_items.iter().find(|ti| ti.id.hir_id() == parent).map(|ti| ti.kind);\n-                }\n-            }\n-\n-            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, _), .. }) => {\n-                if let hir::ItemKind::Impl(hir::Impl { ref self_ty, ref items, .. }) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n-                {\n-                    impl_self = Some(self_ty);\n-                    assoc_item_kind =\n-                        items.iter().find(|ii| ii.id.hir_id() == parent).map(|ii| ii.kind);\n-                }\n-            }\n-\n-            // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => {},\n-\n-            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => {},\n-\n-            // Everything else (only closures?) doesn't\n-            // actually enjoy elision in return types.\n-            _ => {\n-                self.visit_ty(output);\n-                return;\n-            }\n-        };\n-\n-        let has_self = match assoc_item_kind {\n-            Some(hir::AssocItemKind::Fn { has_self }) => has_self,\n-            _ => false,\n-        };\n-\n-        // In accordance with the rules for lifetime elision, we can determine\n-        // what region to use for elision in the output type in two ways.\n-        // First (determined here), if `self` is by-reference, then the\n-        // implied output region is the region of the self parameter.\n-        if has_self {\n-            struct SelfVisitor<'a> {\n-                map: &'a NamedRegionMap,\n-                impl_self: Option<&'a hir::TyKind<'a>>,\n-                lifetime: Set1<Region>,\n-            }\n-\n-            impl SelfVisitor<'_> {\n-                // Look for `self: &'a Self` - also desugared from `&'a self`,\n-                // and if that matches, use it for elision and return early.\n-                fn is_self_ty(&self, res: Res) -> bool {\n-                    if let Res::SelfTy { .. } = res {\n-                        return true;\n-                    }\n-\n-                    // Can't always rely on literal (or implied) `Self` due\n-                    // to the way elision rules were originally specified.\n-                    if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) =\n-                        self.impl_self\n-                    {\n-                        match path.res {\n-                            // Permit the types that unambiguously always\n-                            // result in the same type constructor being used\n-                            // (it can't differ between `Self` and `self`).\n-                            Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum, _)\n-                            | Res::PrimTy(_) => return res == path.res,\n-                            _ => {}\n-                        }\n-                    }\n-\n-                    false\n-                }\n-            }\n-\n-            impl<'a> Visitor<'a> for SelfVisitor<'a> {\n-                fn visit_ty(&mut self, ty: &'a hir::Ty<'a>) {\n-                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n-                        {\n-                            if self.is_self_ty(path.res) {\n-                                if let Some(lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                                    self.lifetime.insert(*lifetime);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    intravisit::walk_ty(self, ty)\n-                }\n-            }\n-\n-            let mut visitor = SelfVisitor {\n-                map: self.map,\n-                impl_self: impl_self.map(|ty| &ty.kind),\n-                lifetime: Set1::Empty,\n-            };\n-            visitor.visit_ty(&inputs[0]);\n-            if let Set1::One(lifetime) = visitor.lifetime {\n-                let scope = Scope::Elision { elide: Elide::Exact(lifetime), s: self.scope };\n-                self.with(scope, |this| this.visit_ty(output));\n-                return;\n+            if !in_closure && let Some(output) = output {\n+                this.visit_ty(output);\n             }\n-        }\n-\n-        // Second, if there was exactly one lifetime (either a substitution or a\n-        // reference) in the arguments, then any anonymous regions in the output\n-        // have that lifetime.\n-        let mut possible_implied_output_region = None;\n-        let mut lifetime_count = 0;\n-        for input in inputs.iter().skip(has_self as usize) {\n-            let mut gather = GatherLifetimes {\n-                map: self.map,\n-                outer_index: ty::INNERMOST,\n-                have_bound_regions: false,\n-                lifetimes: Default::default(),\n-            };\n-            gather.visit_ty(input);\n-\n-            lifetime_count += gather.lifetimes.len();\n-\n-            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n-            }\n-        }\n-\n-        let elide = if lifetime_count == 1 {\n-            Elide::Exact(possible_implied_output_region.unwrap())\n-        } else {\n-            Elide::Error\n-        };\n-\n-        debug!(?elide);\n-\n-        let scope = Scope::Elision { elide, s: self.scope };\n-        self.with(scope, |this| this.visit_ty(output));\n-\n-        struct GatherLifetimes<'a> {\n-            map: &'a NamedRegionMap,\n-            outer_index: ty::DebruijnIndex,\n-            have_bound_regions: bool,\n-            lifetimes: FxHashSet<Region>,\n-        }\n-\n-        impl<'v, 'a> Visitor<'v> for GatherLifetimes<'a> {\n-            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    self.outer_index.shift_in(1);\n-                }\n-                match ty.kind {\n-                    hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n-                        for bound in bounds {\n-                            self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                        }\n-\n-                        // Stay on the safe side and don't include the object\n-                        // lifetime default (which may not end up being used).\n-                        if !lifetime.is_elided() {\n-                            self.visit_lifetime(lifetime);\n-                        }\n-                    }\n-                    _ => {\n-                        intravisit::walk_ty(self, ty);\n-                    }\n-                }\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    self.outer_index.shift_out(1);\n-                }\n-            }\n-\n-            fn visit_generic_param(&mut self, param: &hir::GenericParam<'_>) {\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // FIXME(eddyb) Do we want this? It only makes a difference\n-                    // if this `for<'a>` lifetime parameter is never used.\n-                    self.have_bound_regions = true;\n-                }\n-\n-                intravisit::walk_generic_param(self, param);\n-            }\n-\n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &hir::PolyTraitRef<'_>,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                self.outer_index.shift_in(1);\n-                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.outer_index.shift_out(1);\n-            }\n-\n-            fn visit_param_bound(&mut self, bound: &hir::GenericBound<'_>) {\n-                if let hir::GenericBound::LangItemTrait { .. } = bound {\n-                    self.outer_index.shift_in(1);\n-                    intravisit::walk_param_bound(self, bound);\n-                    self.outer_index.shift_out(1);\n-                } else {\n-                    intravisit::walk_param_bound(self, bound);\n-                }\n-            }\n-\n-            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                    match lifetime {\n-                        Region::LateBound(debruijn, _, _)\n-                        | Region::LateBoundAnon(debruijn, _, _)\n-                            if debruijn < self.outer_index =>\n-                        {\n-                            self.have_bound_regions = true;\n-                        }\n-                        _ => {\n-                            // FIXME(jackh726): nested trait refs?\n-                            self.lifetimes.insert(lifetime.shifted_out_to_binder(self.outer_index));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        struct GatherAnonLifetimes {\n-            anon_count: u32,\n-        }\n-        impl<'v> Visitor<'v> for GatherAnonLifetimes {\n-            #[instrument(skip(self), level = \"trace\")]\n-            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-                // If we enter a `BareFn`, then we enter a *new* binding scope\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    return;\n-                }\n-                intravisit::walk_ty(self, ty);\n-            }\n-\n-            fn visit_generic_args(\n-                &mut self,\n-                path_span: Span,\n-                generic_args: &'v hir::GenericArgs<'v>,\n-            ) {\n-                // parenthesized args enter a new elision scope\n-                if generic_args.parenthesized {\n-                    return;\n-                }\n-                intravisit::walk_generic_args(self, path_span, generic_args)\n-            }\n-\n-            #[instrument(skip(self), level = \"trace\")]\n-            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if lifetime_ref.is_elided() {\n-                    self.anon_count += 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[&'tcx hir::Lifetime]) {\n-        debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n-\n-        if lifetime_refs.is_empty() {\n-            return;\n-        }\n-\n-        let mut late_depth = 0;\n-        let mut scope = self.scope;\n-        loop {\n-            match *scope {\n-                // Do not assign any resolution, it will be inferred.\n-                Scope::Body { .. } => return,\n-\n-                Scope::Root => break,\n-\n-                Scope::Binder { s, scope_type, .. } => {\n-                    match scope_type {\n-                        BinderScopeType::Normal => late_depth += 1,\n-                        BinderScopeType::Concatenating => {}\n-                    }\n-                    scope = s;\n-                }\n-\n-                Scope::Elision {\n-                    elide: Elide::FreshLateAnon(named_late_bound_vars, ref counter),\n-                    ..\n-                } => {\n-                    for lifetime_ref in lifetime_refs {\n-                        let lifetime =\n-                            Region::late_anon(named_late_bound_vars, counter).shifted(late_depth);\n-\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n-                    }\n-                    return;\n-                }\n-\n-                Scope::Elision { elide: Elide::Exact(l), .. } => {\n-                    let lifetime = l.shifted(late_depth);\n-                    for lifetime_ref in lifetime_refs {\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n-                    }\n-                    return;\n-                }\n-\n-                Scope::Elision { elide: Elide::Error, .. }\n-                | Scope::Elision { elide: Elide::Forbid, .. } => break,\n-\n-                Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n-                    scope = s;\n-                }\n-            }\n-        }\n-\n-        for lt in lifetime_refs {\n-            self.tcx.sess.delay_span_bug(lt.span, \"Missing lifetime specifier\");\n+        });\n+        if in_closure && let Some(output) = output {\n+            self.visit_ty(output);\n         }\n     }\n "}, {"sha": "08e8e6f7d0f402d18d9273702e983ffab5324733", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -221,14 +221,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::LateBoundAnon(debruijn, index, anon_index)) => {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::from_u32(index),\n-                    kind: ty::BrAnon(anon_index),\n-                };\n-                tcx.mk_region(ty::ReLateBound(debruijn, br))\n-            }\n-\n             Some(rl::Region::EarlyBound(index, id)) => {\n                 let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id: id, index, name }))"}, {"sha": "60c0694ca0e453e986c73bf36d737e3b2f77fc40", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -1346,16 +1346,8 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n             match self.tcx.named_region(lt.hir_id) {\n                 Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(\n-                    rl::Region::LateBound(debruijn, _, _)\n-                    | rl::Region::LateBoundAnon(debruijn, _, _),\n-                ) if debruijn < self.outer_index => {}\n-                Some(\n-                    rl::Region::LateBound(..)\n-                    | rl::Region::LateBoundAnon(..)\n-                    | rl::Region::Free(..),\n-                )\n-                | None => {\n+                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n+                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n                     self.has_late_bound_regions = Some(lt.span);\n                 }\n             }"}, {"sha": "929b82bfc432e993dce2423e88022fd67284e5c2", "filename": "src/test/ui/impl-header-lifetime-elision/constant-used-as-arraylen.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fconstant-used-as-arraylen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fconstant-used-as-arraylen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fconstant-used-as-arraylen.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// Verify that we do not ICE when anonymous lifetimes appear inside an AnonConst.\n+\n+pub struct EntriesBuffer(Box<[[u8; HashesEntry::LEN]; 5]>);\n+\n+impl EntriesBuffer {\n+    pub fn iter_child_buffers(&mut self) -> impl Iterator<Item = &mut [u8; HashesEntry::LEN]> {\n+        self.0.iter_mut()\n+    }\n+\n+    pub fn iter_child_buffers_explicit(\n+        &mut self,\n+    ) -> impl Iterator<Item = &mut [u8; HashesEntry::<'_>::LEN]> {\n+        self.0.iter_mut()\n+    }\n+}\n+\n+pub struct HashesEntry<'a>(&'a [u8]);\n+\n+impl HashesEntry<'_> {\n+    pub const LEN: usize = 1;\n+}\n+\n+fn main() {}"}, {"sha": "3f69cc2038839c815a6e4c94221dffe7c7e1807a", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -615,7 +615,7 @@ struct BodyLifetimeChecker {\n impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        if lifetime.name.ident().name != kw::Empty && lifetime.name.ident().name != kw::StaticLifetime {\n+        if lifetime.name.ident().name != kw::UnderscoreLifetime && lifetime.name.ident().name != kw::StaticLifetime {\n             self.lifetimes_used_in_body = true;\n         }\n     }"}, {"sha": "a0ca7e6ff1e22b78f2cd4c08a8ca29c6cea71e8c", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -166,7 +166,7 @@ fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName])\n     // - There's only one output lifetime bound using `+ '_`\n     // - All input lifetimes are explicitly bound to the output\n     input_lifetimes.is_empty()\n-        || (output_lifetimes.len() == 1 && matches!(output_lifetimes[0], LifetimeName::Underscore))\n+        || (output_lifetimes.len() == 1 && matches!(output_lifetimes[0], LifetimeName::Infer))\n         || input_lifetimes\n             .iter()\n             .all(|in_lt| output_lifetimes.iter().any(|out_lt| in_lt == out_lt))"}, {"sha": "3c5ea2d94144faf0718772b5342befcc510c7b8e", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37ee1a7e04419bf91a280357bfbb950d99512b3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=c37ee1a7e04419bf91a280357bfbb950d99512b3", "patch": "@@ -351,7 +351,7 @@ impl fmt::Display for RefPrefix {\n                 name.fmt(f)?;\n                 f.write_char(' ')?;\n             },\n-            LifetimeName::Underscore => f.write_str(\"'_ \")?,\n+            LifetimeName::Infer => f.write_str(\"'_ \")?,\n             LifetimeName::Static => f.write_str(\"'static \")?,\n             _ => (),\n         }"}]}