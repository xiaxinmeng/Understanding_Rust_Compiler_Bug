{"sha": "d118997b9318b750676a7fe5b8896219f98d9e6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMTg5OTdiOTMxOGI3NTA2NzZhN2ZlNWI4ODk2MjE5Zjk4ZDllNmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T14:21:29Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T14:44:43Z"}, "message": "Remove assoc_type_by_name helper", "tree": {"sha": "0ec33a8c39d0815d288a575dc4986f8029f5f4d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ec33a8c39d0815d288a575dc4986f8029f5f4d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d118997b9318b750676a7fe5b8896219f98d9e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d118997b9318b750676a7fe5b8896219f98d9e6e", "html_url": "https://github.com/rust-lang/rust/commit/d118997b9318b750676a7fe5b8896219f98d9e6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d118997b9318b750676a7fe5b8896219f98d9e6e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bc8f1f4f8d7bded19517205f8522a0110204f51", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8f1f4f8d7bded19517205f8522a0110204f51", "html_url": "https://github.com/rust-lang/rust/commit/9bc8f1f4f8d7bded19517205f8522a0110204f51"}], "stats": {"total": 73, "additions": 34, "deletions": 39}, "files": [{"sha": "50e6409b1d60ed0f4779e10f151775227020493b", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=d118997b9318b750676a7fe5b8896219f98d9e6e", "patch": "@@ -740,19 +740,15 @@ impl Trait {\n         db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n     }\n \n-    pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n-        db.trait_data(self.id).associated_type_by_name(name).map(TypeAlias::from)\n-    }\n-\n     pub fn associated_type_by_name_including_super_traits(\n         self,\n         db: &impl HirDatabase,\n         name: &Name,\n     ) -> Option<TypeAlias> {\n         all_super_traits(db, self.id)\n             .into_iter()\n-            .map(Trait::from)\n-            .find_map(|t| t.associated_type_by_name(db, name))\n+            .find_map(|t| db.trait_data(t).associated_type_by_name(name))\n+            .map(TypeAlias::from)\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {"}, {"sha": "ae68234aca2edf57bb49a45ebc728ca93575fe18", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=d118997b9318b750676a7fe5b8896219f98d9e6e", "patch": "@@ -10,7 +10,7 @@ use hir_expand::name;\n use log::{info, warn};\n use ra_db::CrateId;\n \n-use crate::{db::HirDatabase, Trait};\n+use crate::db::HirDatabase;\n \n use super::{\n     traits::{InEnvironment, Solution},\n@@ -49,12 +49,12 @@ fn deref_by_trait(\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n     let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n-        LangItemTarget::TraitId(t) => Trait::from(t),\n+        LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };\n-    let target = deref_trait.associated_type_by_name(db, &name::TARGET_TYPE)?;\n+    let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n \n-    let generic_params = db.generic_params(target.id.into());\n+    let generic_params = db.generic_params(target.into());\n     if generic_params.count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type\n@@ -69,7 +69,7 @@ fn deref_by_trait(\n \n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(0),\n-        projection_ty: super::ProjectionTy { associated_ty: target.id, parameters },\n+        projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n     let obligation = super::Obligation::Projection(projection);"}, {"sha": "b023ae69014b6bd3ec148615f8e6b5076c74548e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=d118997b9318b750676a7fe5b8896219f98d9e6e", "patch": "@@ -43,7 +43,7 @@ use crate::{\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, Trait, VariantDef,\n+    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -582,20 +582,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n         let path = known::std_iter_into_iterator();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::ITEM_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE).map(TypeAlias::from)\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n         let path = known::std_ops_try();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::OK_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE).map(TypeAlias::from)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n         let path = known::std_future_future();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE).map(TypeAlias::from)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {"}, {"sha": "0ac7920bbdd583cf958e7f834b67e58c2a549cd4", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=d118997b9318b750676a7fe5b8896219f98d9e6e", "patch": "@@ -263,16 +263,14 @@ impl Ty {\n         });\n         let traits = traits_from_env.flat_map(|t| all_super_traits(db, t.id)).map(Trait::from);\n         for t in traits {\n-            if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n+            if let Some(associated_ty) = db.trait_data(t.id).associated_type_by_name(&segment.name)\n+            {\n                 let substs = Substs::build_for_def(db, t.id)\n                     .push(self_ty.clone())\n                     .fill_with_unknown()\n                     .build();\n                 // FIXME handle type parameters on the segment\n-                return Ty::Projection(ProjectionTy {\n-                    associated_ty: associated_ty.id,\n-                    parameters: substs,\n-                });\n+                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n         }\n         Ty::Unknown"}, {"sha": "78f4b3e27e693df9c5319aaecad6f4969a8b3d14", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d118997b9318b750676a7fe5b8896219f98d9e6e/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=d118997b9318b750676a7fe5b8896219f98d9e6e", "patch": "@@ -9,7 +9,7 @@ use chalk_ir::{\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n-use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TypeAliasId};\n+use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId};\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n@@ -459,7 +459,7 @@ where\n                 [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n             {\n                 if let Some(actual_trait) = get_fn_trait(self.db, self.krate, fn_trait) {\n-                    if trait_ == actual_trait {\n+                    if trait_.id == actual_trait {\n                         let impl_ = super::ClosureFnTraitImplData { def, expr, fn_trait };\n                         result.push(Impl::ClosureFnTraitImpl(impl_).to_chalk(self.db));\n                     }\n@@ -661,6 +661,7 @@ fn impl_block_datum(\n     };\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n+    let trait_data = db.trait_data(trait_.id);\n     let associated_ty_value_ids = impl_block\n         .items(db)\n         .into_iter()\n@@ -670,7 +671,7 @@ fn impl_block_datum(\n         })\n         .filter(|type_alias| {\n             // don't include associated types that don't exist in the trait\n-            trait_.associated_type_by_name(db, &type_alias.name(db)).is_some()\n+            trait_data.associated_type_by_name(&type_alias.name(db)).is_some()\n         })\n         .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n         .collect();\n@@ -713,7 +714,7 @@ fn closure_fn_trait_impl_datum(\n     // and don't want to return a valid value only to find out later that FnOnce\n     // is broken\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n+    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n@@ -735,8 +736,8 @@ fn closure_fn_trait_impl_datum(\n     let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n \n     let trait_ref = TraitRef {\n-        trait_,\n-        substs: Substs::build_for_def(db, trait_.id).push(self_ty).push(arg_ty).build(),\n+        trait_: trait_.into(),\n+        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n     let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone()).to_chalk(db);\n@@ -783,10 +784,10 @@ fn type_alias_associated_ty_value(\n         .target_trait_ref(db)\n         .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n         .trait_;\n-    let assoc_ty = trait_\n-        .associated_type_by_name(db, &type_alias.name(db))\n-        .expect(\"assoc ty value should not exist\") // validated when building the impl data as well\n-        .id;\n+    let assoc_ty = db\n+        .trait_data(trait_.id)\n+        .associated_type_by_name(&type_alias.name(db))\n+        .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let generic_params = db.generic_params(impl_block.id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n@@ -819,10 +820,10 @@ fn closure_fn_trait_output_assoc_ty_value(\n     let fn_once_trait =\n         get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n \n-    let output_ty_id = fn_once_trait\n-        .associated_type_by_name(db, &name::OUTPUT_TYPE)\n-        .expect(\"assoc ty value should not exist\")\n-        .id;\n+    let output_ty_id = db\n+        .trait_data(fn_once_trait)\n+        .associated_type_by_name(&name::OUTPUT_TYPE)\n+        .expect(\"assoc ty value should not exist\");\n \n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n \n@@ -834,10 +835,10 @@ fn closure_fn_trait_output_assoc_ty_value(\n     Arc::new(value)\n }\n \n-fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n+fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<TraitId> {\n     let target = db.lang_item(krate.crate_id, fn_trait.lang_item_name().into())?;\n     match target {\n-        LangItemTarget::TraitId(t) => Some(t.into()),\n+        LangItemTarget::TraitId(t) => Some(t),\n         _ => None,\n     }\n }"}]}