{"sha": "a9b6205aff943d44820df53d63d14a06b319b9dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YjYyMDVhZmY5NDNkNDQ4MjBkZjUzZDYzZDE0YTA2YjMxOWI5ZGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-28T21:37:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-06T16:42:46Z"}, "message": "break dep-graph into modules, parameterize DepNode\n\nit is useful later to customize how change the type we use for reference\nitems away from DefId", "tree": {"sha": "7755216f4f44edf533195805697e806c02c68c1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7755216f4f44edf533195805697e806c02c68c1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9b6205aff943d44820df53d63d14a06b319b9dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b6205aff943d44820df53d63d14a06b319b9dd", "html_url": "https://github.com/rust-lang/rust/commit/a9b6205aff943d44820df53d63d14a06b319b9dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9b6205aff943d44820df53d63d14a06b319b9dd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1e68b9e2d75e66bc866a194b744ddf8502ca129", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e68b9e2d75e66bc866a194b744ddf8502ca129", "html_url": "https://github.com/rust-lang/rust/commit/b1e68b9e2d75e66bc866a194b744ddf8502ca129"}], "stats": {"total": 654, "additions": 411, "deletions": 243}, "files": [{"sha": "446313f7037f3d4470419f17cc54c7bc08c379c1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Debug;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum DepNode<D: Clone + Debug> {\n+    // The `D` type is \"how definitions are identified\".\n+    // During compilation, it is always `DefId`, but when serializing\n+    // it is mapped to `DefPath`.\n+\n+    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n+    // distinct from the krate module). This is basically a hash of\n+    // the entire krate, so if you read from `Krate` (e.g., by calling\n+    // `tcx.map.krate()`), we will have to assume that any change\n+    // means that you need to be recompiled. This is because the\n+    // `Krate` value gives you access to all other items. To avoid\n+    // this fate, do not call `tcx.map.krate()`; instead, prefer\n+    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n+    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n+    // access to the krate, but you must remember to add suitable\n+    // edges yourself for the individual items that you read.\n+    Krate,\n+\n+    // Represents the HIR node with the given node-id\n+    Hir(D),\n+\n+    // Represents different phases in the compiler.\n+    CrateReader,\n+    CollectLanguageItems,\n+    CheckStaticRecursion,\n+    ResolveLifetimes,\n+    RegionResolveCrate,\n+    CheckLoops,\n+    PluginRegistrar,\n+    StabilityIndex,\n+    CollectItem(D),\n+    Coherence,\n+    EffectCheck,\n+    Liveness,\n+    Resolve,\n+    EntryPoint,\n+    CheckEntryFn,\n+    CoherenceCheckImpl(D),\n+    CoherenceOverlapCheck(D),\n+    CoherenceOverlapCheckSpecial(D),\n+    CoherenceOverlapInherentCheck(D),\n+    CoherenceOrphanCheck(D),\n+    Variance,\n+    WfCheck(D),\n+    TypeckItemType(D),\n+    TypeckItemBody(D),\n+    Dropck,\n+    DropckImpl(D),\n+    CheckConst(D),\n+    Privacy,\n+    IntrinsicCheck(D),\n+    MatchCheck(D),\n+    MirMapConstruction(D),\n+    MirTypeck(D),\n+    BorrowCheck(D),\n+    RvalueCheck(D),\n+    Reachability,\n+    DeadCheck,\n+    StabilityCheck,\n+    LateLintCheck,\n+    IntrinsicUseCheck,\n+    TransCrate,\n+    TransCrateItem(D),\n+    TransInlinedItem(D),\n+    TransWriteMetadata,\n+\n+    // Nodes representing bits of computed IR in the tcx. Each shared\n+    // table in the tcx (or elsewhere) maps to one of these\n+    // nodes. Often we map multiple tables to the same node if there\n+    // is no point in distinguishing them (e.g., both the type and\n+    // predicates for an item wind up in `ItemSignature`). Other\n+    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n+    // might be mergable are kept distinct because the sets of def-ids\n+    // to which they apply are disjoint, and hence we might as well\n+    // have distinct labels for easier debugging.\n+    ImplOrTraitItems(D),\n+    ItemSignature(D),\n+    FieldTy(D),\n+    TraitItemDefIds(D),\n+    InherentImpls(D),\n+    ImplItems(D),\n+\n+    // The set of impls for a given trait. Ultimately, it would be\n+    // nice to get more fine-grained here (e.g., to include a\n+    // simplified type), but we can't do that until we restructure the\n+    // HIR to distinguish the *header* of an impl from its body.  This\n+    // is because changes to the header may change the self-type of\n+    // the impl and hence would require us to be more conservative\n+    // than changes in the impl body.\n+    TraitImpls(D),\n+\n+    // Nodes representing caches. To properly handle a true cache, we\n+    // don't use a DepTrackingMap, but rather we push a task node.\n+    // Otherwise the write into the map would be incorrectly\n+    // attributed to the first task that happened to fill the cache,\n+    // which would yield an overly conservative dep-graph.\n+    TraitItems(D),\n+    ReprHints(D),\n+    TraitSelect(D),\n+}\n+\n+impl<D: Clone + Debug> DepNode<D> {\n+    /// Used in testing\n+    pub fn from_label_string(label: &str, data: D) -> Result<DepNode<D>, ()> {\n+        macro_rules! check {\n+            ($($name:ident,)*) => {\n+                match label {\n+                    $(stringify!($name) => Ok(DepNode::$name(data)),)*\n+                    _ => Err(())\n+                }\n+            }\n+        }\n+\n+        check! {\n+            CollectItem,\n+            BorrowCheck,\n+            TransCrateItem,\n+            TypeckItemType,\n+            TypeckItemBody,\n+            ImplOrTraitItems,\n+            ItemSignature,\n+            FieldTy,\n+            TraitItemDefIds,\n+            InherentImpls,\n+            ImplItems,\n+            TraitImpls,\n+            ReprHints,\n+        }\n+    }\n+\n+    pub fn map_def<E, OP>(&self, mut op: OP) -> Option<DepNode<E>>\n+        where OP: FnMut(&D) -> Option<E>, E: Clone + Debug\n+    {\n+        use self::DepNode::*;\n+\n+        match *self {\n+            Krate => Some(Krate),\n+            CrateReader => Some(CrateReader),\n+            CollectLanguageItems => Some(CollectLanguageItems),\n+            CheckStaticRecursion => Some(CheckStaticRecursion),\n+            ResolveLifetimes => Some(ResolveLifetimes),\n+            RegionResolveCrate => Some(RegionResolveCrate),\n+            CheckLoops => Some(CheckLoops),\n+            PluginRegistrar => Some(PluginRegistrar),\n+            StabilityIndex => Some(StabilityIndex),\n+            Coherence => Some(Coherence),\n+            EffectCheck => Some(EffectCheck),\n+            Liveness => Some(Liveness),\n+            Resolve => Some(Resolve),\n+            EntryPoint => Some(EntryPoint),\n+            CheckEntryFn => Some(CheckEntryFn),\n+            Variance => Some(Variance),\n+            Dropck => Some(Dropck),\n+            Privacy => Some(Privacy),\n+            Reachability => Some(Reachability),\n+            DeadCheck => Some(DeadCheck),\n+            StabilityCheck => Some(StabilityCheck),\n+            LateLintCheck => Some(LateLintCheck),\n+            IntrinsicUseCheck => Some(IntrinsicUseCheck),\n+            TransCrate => Some(TransCrate),\n+            TransWriteMetadata => Some(TransWriteMetadata),\n+            Hir(ref d) => op(d).map(Hir),\n+            CollectItem(ref d) => op(d).map(CollectItem),\n+            CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n+            CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n+            CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n+            CoherenceOverlapInherentCheck(ref d) => op(d).map(CoherenceOverlapInherentCheck),\n+            CoherenceOrphanCheck(ref d) => op(d).map(CoherenceOrphanCheck),\n+            WfCheck(ref d) => op(d).map(WfCheck),\n+            TypeckItemType(ref d) => op(d).map(TypeckItemType),\n+            TypeckItemBody(ref d) => op(d).map(TypeckItemBody),\n+            DropckImpl(ref d) => op(d).map(DropckImpl),\n+            CheckConst(ref d) => op(d).map(CheckConst),\n+            IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n+            MatchCheck(ref d) => op(d).map(MatchCheck),\n+            MirMapConstruction(ref d) => op(d).map(MirMapConstruction),\n+            MirTypeck(ref d) => op(d).map(MirTypeck),\n+            BorrowCheck(ref d) => op(d).map(BorrowCheck),\n+            RvalueCheck(ref d) => op(d).map(RvalueCheck),\n+            TransCrateItem(ref d) => op(d).map(TransCrateItem),\n+            TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n+            ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n+            ItemSignature(ref d) => op(d).map(ItemSignature),\n+            FieldTy(ref d) => op(d).map(FieldTy),\n+            TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n+            InherentImpls(ref d) => op(d).map(InherentImpls),\n+            ImplItems(ref d) => op(d).map(ImplItems),\n+            TraitImpls(ref d) => op(d).map(TraitImpls),\n+            TraitItems(ref d) => op(d).map(TraitItems),\n+            ReprHints(ref d) => op(d).map(ReprHints),\n+            TraitSelect(ref d) => op(d).map(TraitSelect),\n+        }\n+    }\n+}"}, {"sha": "922d32a3067969f626a299f4a19d01ddbc83f69b", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::cell::RefCell;\n use std::ops::Index;\n@@ -29,7 +30,7 @@ pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n-    fn to_dep_node(key: &Self::Key) -> DepNode;\n+    fn to_dep_node(key: &Self::Key) -> DepNode<DefId>;\n }\n \n impl<M: DepTrackingMapConfig> DepTrackingMap<M> {"}, {"sha": "10f3d21f2af6d37eeb265f293278785543b99dfb", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -9,11 +9,13 @@\n // except according to those terms.\n \n use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n-pub struct DepGraphEdges {\n-    nodes: Vec<DepNode>,\n-    indices: FnvHashMap<DepNode, IdIndex>,\n+pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n+    nodes: Vec<DepNode<D>>,\n+    indices: FnvHashMap<DepNode<D>, IdIndex>,\n     edges: FnvHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n@@ -40,8 +42,8 @@ enum OpenNode {\n     Ignore,\n }\n \n-impl DepGraphEdges {\n-    pub fn new() -> DepGraphEdges {\n+impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n+    pub fn new() -> DepGraphEdges<D> {\n         DepGraphEdges {\n             nodes: vec![],\n             indices: FnvHashMap(),\n@@ -50,12 +52,12 @@ impl DepGraphEdges {\n         }\n     }\n \n-    fn id(&self, index: IdIndex) -> DepNode {\n-        self.nodes[index.index()]\n+    fn id(&self, index: IdIndex) -> DepNode<D> {\n+        self.nodes[index.index()].clone()\n     }\n \n     /// Creates a node for `id` in the graph.\n-    fn make_node(&mut self, id: DepNode) -> IdIndex {\n+    fn make_node(&mut self, id: DepNode<D>) -> IdIndex {\n         if let Some(&i) = self.indices.get(&id) {\n             return i;\n         }\n@@ -80,7 +82,7 @@ impl DepGraphEdges {\n         assert_eq!(popped_node, OpenNode::Ignore);\n     }\n \n-    pub fn push_task(&mut self, key: DepNode) {\n+    pub fn push_task(&mut self, key: DepNode<D>) {\n         let top_node = self.current_node();\n \n         let new_node = self.make_node(key);\n@@ -93,23 +95,23 @@ impl DepGraphEdges {\n         }\n     }\n \n-    pub fn pop_task(&mut self, key: DepNode) {\n+    pub fn pop_task(&mut self, key: DepNode<D>) {\n         let popped_node = self.open_nodes.pop().unwrap();\n         assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n     }\n \n     /// Indicates that the current task `C` reads `v` by adding an\n     /// edge from `v` to `C`. If there is no current task, panics. If\n     /// you want to suppress this edge, use `ignore`.\n-    pub fn read(&mut self, v: DepNode) {\n+    pub fn read(&mut self, v: DepNode<D>) {\n         let source = self.make_node(v);\n         self.add_edge_from_current_node(|current| (source, current))\n     }\n \n     /// Indicates that the current task `C` writes `v` by adding an\n     /// edge from `C` to `v`. If there is no current task, panics. If\n     /// you want to suppress this edge, use `ignore`.\n-    pub fn write(&mut self, v: DepNode) {\n+    pub fn write(&mut self, v: DepNode<D>) {\n         let target = self.make_node(v);\n         self.add_edge_from_current_node(|current| (current, target))\n     }\n@@ -153,7 +155,7 @@ impl DepGraphEdges {\n         }\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<D> {\n         let edges: Vec<_> = self.edges.iter()\n                                       .map(|&(i, j)| (self.id(i), self.id(j)))\n                                       .collect();"}, {"sha": "741ad65c29fda373a9bb17129c16299f5b6f6871", "filename": "src/librustc/dep_graph/graph.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use std::rc::Rc;\n+\n+use super::dep_node::DepNode;\n+use super::query::DepGraphQuery;\n+use super::raii;\n+use super::thread::{DepGraphThreadData, DepMessage};\n+\n+#[derive(Clone)]\n+pub struct DepGraph {\n+    data: Rc<DepGraphThreadData>\n+}\n+\n+impl DepGraph {\n+    pub fn new(enabled: bool) -> DepGraph {\n+        DepGraph {\n+            data: Rc::new(DepGraphThreadData::new(enabled))\n+        }\n+    }\n+\n+    /// True if we are actually building a dep-graph. If this returns false,\n+    /// then the other methods on this `DepGraph` will have no net effect.\n+    #[inline]\n+    pub fn enabled(&self) -> bool {\n+        self.data.enabled()\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery<DefId> {\n+        self.data.query()\n+    }\n+\n+    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n+        raii::IgnoreTask::new(&self.data)\n+    }\n+\n+    pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> raii::DepTask<'graph> {\n+        raii::DepTask::new(&self.data, key)\n+    }\n+\n+    pub fn with_ignore<OP,R>(&self, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_ignore();\n+        op()\n+    }\n+\n+    pub fn with_task<OP,R>(&self, key: DepNode<DefId>, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_task(key);\n+        op()\n+    }\n+\n+    pub fn read(&self, v: DepNode<DefId>) {\n+        self.data.enqueue(DepMessage::Read(v));\n+    }\n+\n+    pub fn write(&self, v: DepNode<DefId>) {\n+        self.data.enqueue(DepMessage::Write(v));\n+    }\n+}"}, {"sha": "49481dcb79672faecec8a671dc2f05c515b8b5c3", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 200, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -8,211 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::thread::{DepGraphThreadData, DepMessage};\n-use hir::def_id::DefId;\n-use syntax::ast::NodeId;\n-use ty::TyCtxt;\n-use hir;\n-use hir::intravisit::Visitor;\n-use std::rc::Rc;\n-\n+mod dep_node;\n mod dep_tracking_map;\n mod edges;\n+mod graph;\n mod query;\n mod raii;\n mod thread;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum DepNode {\n-    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    // distinct from the krate module). This is basically a hash of\n-    // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.map.krate()`), we will have to assume that any change\n-    // means that you need to be recompiled. This is because the\n-    // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.map.krate()`; instead, prefer\n-    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    // access to the krate, but you must remember to add suitable\n-    // edges yourself for the individual items that you read.\n-    Krate,\n-\n-    // Represents the HIR node with the given node-id\n-    Hir(DefId),\n-\n-    // Represents different phases in the compiler.\n-    CrateReader,\n-    CollectLanguageItems,\n-    CheckStaticRecursion,\n-    ResolveLifetimes,\n-    RegionResolveCrate,\n-    CheckLoops,\n-    PluginRegistrar,\n-    StabilityIndex,\n-    CollectItem(DefId),\n-    Coherence,\n-    EffectCheck,\n-    Liveness,\n-    Resolve,\n-    EntryPoint,\n-    CheckEntryFn,\n-    CoherenceCheckImpl(DefId),\n-    CoherenceOverlapCheck(DefId),\n-    CoherenceOverlapCheckSpecial(DefId),\n-    CoherenceOverlapInherentCheck(DefId),\n-    CoherenceOrphanCheck(DefId),\n-    Variance,\n-    WfCheck(DefId),\n-    TypeckItemType(DefId),\n-    TypeckItemBody(DefId),\n-    Dropck,\n-    DropckImpl(DefId),\n-    CheckConst(DefId),\n-    Privacy,\n-    IntrinsicCheck(DefId),\n-    MatchCheck(DefId),\n-    MirMapConstruction(DefId),\n-    MirTypeck(NodeId),\n-    BorrowCheck(DefId),\n-    RvalueCheck(DefId),\n-    Reachability,\n-    DeadCheck,\n-    StabilityCheck,\n-    LateLintCheck,\n-    IntrinsicUseCheck,\n-    TransCrate,\n-    TransCrateItem(DefId),\n-    TransInlinedItem(DefId),\n-    TransWriteMetadata,\n-\n-    // Nodes representing bits of computed IR in the tcx. Each shared\n-    // table in the tcx (or elsewhere) maps to one of these\n-    // nodes. Often we map multiple tables to the same node if there\n-    // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`). Other\n-    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n-    // might be mergable are kept distinct because the sets of def-ids\n-    // to which they apply are disjoint, and hence we might as well\n-    // have distinct labels for easier debugging.\n-    ImplOrTraitItems(DefId),\n-    ItemSignature(DefId),\n-    FieldTy(DefId),\n-    TraitItemDefIds(DefId),\n-    InherentImpls(DefId),\n-    ImplItems(DefId),\n-\n-    // The set of impls for a given trait. Ultimately, it would be\n-    // nice to get more fine-grained here (e.g., to include a\n-    // simplified type), but we can't do that until we restructure the\n-    // HIR to distinguish the *header* of an impl from its body.  This\n-    // is because changes to the header may change the self-type of\n-    // the impl and hence would require us to be more conservative\n-    // than changes in the impl body.\n-    TraitImpls(DefId),\n-\n-    // Nodes representing caches. To properly handle a true cache, we\n-    // don't use a DepTrackingMap, but rather we push a task node.\n-    // Otherwise the write into the map would be incorrectly\n-    // attributed to the first task that happened to fill the cache,\n-    // which would yield an overly conservative dep-graph.\n-    TraitItems(DefId),\n-    ReprHints(DefId),\n-    TraitSelect(DefId),\n-}\n-\n-#[derive(Clone)]\n-pub struct DepGraph {\n-    data: Rc<DepGraphThreadData>\n-}\n-\n-impl DepGraph {\n-    pub fn new(enabled: bool) -> DepGraph {\n-        DepGraph {\n-            data: Rc::new(DepGraphThreadData::new(enabled))\n-        }\n-    }\n-\n-    /// True if we are actually building a dep-graph. If this returns false,\n-    /// then the other methods on this `DepGraph` will have no net effect.\n-    #[inline]\n-    pub fn enabled(&self) -> bool {\n-        self.data.enabled()\n-    }\n-\n-    pub fn query(&self) -> DepGraphQuery {\n-        self.data.query()\n-    }\n-\n-    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n-        raii::IgnoreTask::new(&self.data)\n-    }\n-\n-    pub fn in_task<'graph>(&'graph self, key: DepNode) -> raii::DepTask<'graph> {\n-        raii::DepTask::new(&self.data, key)\n-    }\n-\n-    pub fn with_ignore<OP,R>(&self, op: OP) -> R\n-        where OP: FnOnce() -> R\n-    {\n-        let _task = self.in_ignore();\n-        op()\n-    }\n-\n-    pub fn with_task<OP,R>(&self, key: DepNode, op: OP) -> R\n-        where OP: FnOnce() -> R\n-    {\n-        let _task = self.in_task(key);\n-        op()\n-    }\n-\n-    pub fn read(&self, v: DepNode) {\n-        self.data.enqueue(DepMessage::Read(v));\n-    }\n-\n-    pub fn write(&self, v: DepNode) {\n-        self.data.enqueue(DepMessage::Write(v));\n-    }\n-}\n+mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-\n+pub use self::dep_node::DepNode;\n+pub use self::graph::DepGraph;\n pub use self::query::DepGraphQuery;\n-\n-/// Visit all the items in the krate in some order. When visiting a\n-/// particular item, first create a dep-node by calling `dep_node_fn`\n-/// and push that onto the dep-graph stack of tasks, and also create a\n-/// read edge from the corresponding AST node. This is used in\n-/// compiler passes to automatically record the item that they are\n-/// working on.\n-pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &TyCtxt<'tcx>,\n-                                          mut dep_node_fn: F,\n-                                          visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n-{\n-    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: &'visit TyCtxt<'tcx>,\n-        dep_node_fn: &'visit mut F,\n-        visitor: &'visit mut V\n-    }\n-\n-    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n-    {\n-        fn visit_item(&mut self, i: &'tcx hir::Item) {\n-            let item_def_id = self.tcx.map.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id);\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-            self.visitor.visit_item(i)\n-        }\n-    }\n-\n-    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n-    let mut tracking_visitor = TrackingVisitor {\n-        tcx: tcx,\n-        dep_node_fn: &mut dep_node_fn,\n-        visitor: visitor\n-    };\n-    krate.visit_all_items(&mut tracking_visitor)\n-}\n+pub use self::visit::visit_all_items_in_krate;"}, {"sha": "acc6660da6e8934ae144aa78e6d4456490681d48", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -10,16 +10,20 @@\n \n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n \n use super::DepNode;\n \n-pub struct DepGraphQuery {\n-    pub graph: Graph<DepNode, ()>,\n-    pub indices: FnvHashMap<DepNode, NodeIndex>,\n+pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n+    pub graph: Graph<DepNode<D>, ()>,\n+    pub indices: FnvHashMap<DepNode<D>, NodeIndex>,\n }\n \n-impl DepGraphQuery {\n-    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n+    pub fn new(nodes: &[DepNode<D>],\n+               edges: &[(DepNode<D>, DepNode<D>)])\n+               -> DepGraphQuery<D> {\n         let mut graph = Graph::new();\n         let mut indices = FnvHashMap();\n         for node in nodes {\n@@ -39,27 +43,43 @@ impl DepGraphQuery {\n         }\n     }\n \n-    pub fn nodes(&self) -> Vec<DepNode> {\n+    pub fn contains_node(&self, node: &DepNode<D>) -> bool {\n+        self.indices.contains_key(&node)\n+    }\n+\n+    pub fn nodes(&self) -> Vec<DepNode<D>> {\n         self.graph.all_nodes()\n                   .iter()\n                   .map(|n| n.data.clone())\n                   .collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(DepNode,DepNode)> {\n+    pub fn edges(&self) -> Vec<(DepNode<D>,DepNode<D>)> {\n         self.graph.all_edges()\n                   .iter()\n                   .map(|edge| (edge.source(), edge.target()))\n-                  .map(|(s, t)| (self.graph.node_data(s).clone(), self.graph.node_data(t).clone()))\n+                  .map(|(s, t)| (self.graph.node_data(s).clone(),\n+                                 self.graph.node_data(t).clone()))\n                   .collect()\n     }\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn dependents(&self, node: DepNode) -> Vec<DepNode> {\n+    pub fn transitive_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.depth_traverse(index)\n-                      .map(|dependent_node| self.graph.node_data(dependent_node).clone())\n+                      .map(|s| self.graph.node_data(s).clone())\n+                      .collect()\n+        } else {\n+            vec![]\n+        }\n+    }\n+\n+    /// Just the outgoing edges from `node`.\n+    pub fn immediate_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+        if let Some(&index) = self.indices.get(&node) {\n+            self.graph.successor_nodes(index)\n+                      .map(|s| self.graph.node_data(s).clone())\n                       .collect()\n         } else {\n             vec![]"}, {"sha": "13151d169fc3f78843405d5a1829ec9d2823d985", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n use super::DepNode;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n pub struct DepTask<'graph> {\n     data: &'graph DepGraphThreadData,\n-    key: DepNode,\n+    key: DepNode<DefId>,\n }\n \n impl<'graph> DepTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData, key: DepNode) -> DepTask<'graph> {\n+    pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n+               -> DepTask<'graph> {\n         data.enqueue(DepMessage::PushTask(key));\n         DepTask { data: data, key: key }\n     }"}, {"sha": "5b0e4a909c8d3d7aeeade5edc26361eb2da149ae", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -18,6 +18,7 @@\n //! to accumulate more messages. This way we only ever have two vectors\n //! allocated (and both have a fairly large capacity).\n \n+use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n use std::cell::Cell;\n use std::sync::mpsc::{self, Sender, Receiver};\n@@ -28,10 +29,10 @@ use super::DepNode;\n use super::edges::DepGraphEdges;\n \n pub enum DepMessage {\n-    Read(DepNode),\n-    Write(DepNode),\n-    PushTask(DepNode),\n-    PopTask(DepNode),\n+    Read(DepNode<DefId>),\n+    Write(DepNode<DefId>),\n+    PushTask(DepNode<DefId>),\n+    PopTask(DepNode<DefId>),\n     PushIgnore,\n     PopIgnore,\n     Query,\n@@ -57,7 +58,7 @@ pub struct DepGraphThreadData {\n     swap_out: Sender<Vec<DepMessage>>,\n \n     // where to receive query results\n-    query_in: Receiver<DepGraphQuery>,\n+    query_in: Receiver<DepGraphQuery<DefId>>,\n }\n \n const INITIAL_CAPACITY: usize = 2048;\n@@ -105,7 +106,7 @@ impl DepGraphThreadData {\n         self.swap_out.send(old_messages).unwrap();\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<DefId> {\n         assert!(self.enabled, \"cannot query if dep graph construction not enabled\");\n         self.enqueue(DepMessage::Query);\n         self.swap();\n@@ -155,7 +156,7 @@ impl DepGraphThreadData {\n /// Definition of the depgraph thread.\n pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n             swap_out: Sender<Vec<DepMessage>>,\n-            query_out: Sender<DepGraphQuery>) {\n+            query_out: Sender<DepGraphQuery<DefId>>) {\n     let mut edges = DepGraphEdges::new();\n \n     // the compiler thread always expects a fresh buffer to be"}, {"sha": "8ce177efe92a5c8ec67c0eb8dae6ceb0b811ed4f", "filename": "src/librustc/dep_graph/visit.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use ty::TyCtxt;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+\n+use super::dep_node::DepNode;\n+\n+\n+/// Visit all the items in the krate in some order. When visiting a\n+/// particular item, first create a dep-node by calling `dep_node_fn`\n+/// and push that onto the dep-graph stack of tasks, and also create a\n+/// read edge from the corresponding AST node. This is used in\n+/// compiler passes to automatically record the item that they are\n+/// working on.\n+pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &TyCtxt<'tcx>,\n+                                          mut dep_node_fn: F,\n+                                          visitor: &mut V)\n+    where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+{\n+    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n+        tcx: &'visit TyCtxt<'tcx>,\n+        dep_node_fn: &'visit mut F,\n+        visitor: &'visit mut V\n+    }\n+\n+    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+    {\n+        fn visit_item(&mut self, i: &'tcx hir::Item) {\n+            let item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(item_def_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id);\n+            debug!(\"Started task {:?}\", task_id);\n+            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+            self.visitor.visit_item(i)\n+        }\n+    }\n+\n+    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n+    let mut tracking_visitor = TrackingVisitor {\n+        tcx: tcx,\n+        dep_node_fn: &mut dep_node_fn,\n+        visitor: visitor\n+    };\n+    krate.visit_all_items(&mut tracking_visitor)\n+}"}, {"sha": "044fe7767f4cc06529d3e700e383089fa0f1c842", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -208,7 +208,7 @@ impl<'ast> Map<'ast> {\n         self.dep_graph.read(self.dep_node(id));\n     }\n \n-    fn dep_node(&self, id0: NodeId) -> DepNode {\n+    fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n         let map = self.map.borrow();\n         let mut id = id0;\n         loop {"}, {"sha": "88327ab19a5cb66350a06e707fa9954766d62b55", "filename": "src/librustc/ty/ivar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fivar.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepNode;\n+use hir::def_id::DefId;\n use ty::{Ty, TyS};\n use ty::tls;\n \n@@ -46,7 +47,7 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn get(&self, dep_node: DepNode) -> Option<Ty<'tcx>> {\n+    pub fn get(&self, dep_node: DepNode<DefId>) -> Option<Ty<'tcx>> {\n         tls::with(|tcx| tcx.dep_graph.read(dep_node));\n         self.untracked_get()\n     }\n@@ -61,11 +62,11 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn unwrap(&self, dep_node: DepNode) -> Ty<'tcx> {\n+    pub fn unwrap(&self, dep_node: DepNode<DefId>) -> Ty<'tcx> {\n         self.get(dep_node).unwrap()\n     }\n \n-    pub fn fulfill(&self, dep_node: DepNode, value: Ty<'lt>) {\n+    pub fn fulfill(&self, dep_node: DepNode<DefId>, value: Ty<'lt>) {\n         tls::with(|tcx| tcx.dep_graph.write(dep_node));\n \n         // Invariant (A) is fulfilled, because by (B), every alias"}, {"sha": "57b1dd66bea9d353185e7ab3f2f43304e589cf30", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -24,7 +24,7 @@ macro_rules! dep_map_ty {\n         impl<'tcx> DepTrackingMapConfig for $ty_name<'tcx> {\n             type Key = $key;\n             type Value = $value;\n-            fn to_dep_node(key: &$key) -> DepNode { DepNode::$node_name(*key) }\n+            fn to_dep_node(key: &$key) -> DepNode<DefId> { DepNode::$node_name(*key) }\n         }\n     }\n }"}, {"sha": "46615fca90429e0920bd2c30f41d48833ee60454", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -887,7 +887,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n     }\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n-    fn dep_node(&self) -> DepNode {\n+    fn dep_node(&self) -> DepNode<DefId> {\n         DepNode::TraitSelect(self.def_id())\n     }\n \n@@ -906,7 +906,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         self.0.def_id()\n     }\n \n-    pub fn dep_node(&self) -> DepNode {\n+    pub fn dep_node(&self) -> DepNode<DefId> {\n         // ok to skip binder since depnode does not care about regions\n         self.0.dep_node()\n     }\n@@ -2666,7 +2666,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn visit_all_items_in_krate<V,F>(&self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n     {\n         dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n     }"}, {"sha": "11ac1fa8f82a18e30a7116198afc42695a4d7838", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -584,7 +584,8 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(id));\n+        let def_id = tcx.map.local_def_id(id);\n+        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(def_id));\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n         let infcx = infer::new_infer_ctxt(tcx,\n                                           &tcx.tables,"}, {"sha": "c1802a5f0a9c2c3114ce887353dad818bd4968e3", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b6205aff943d44820df53d63d14a06b319b9dd/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=a9b6205aff943d44820df53d63d14a06b319b9dd", "patch": "@@ -179,7 +179,7 @@ pub struct TraitSelectionCache<'tcx> {\n impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     type Key = ty::PolyTraitRef<'tcx>;\n     type Value = traits::Vtable<'tcx, ()>;\n-    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode {\n+    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n         ty::tls::with(|tcx| {\n             let lifted_key = tcx.lift(key).unwrap();\n             lifted_key.to_poly_trait_predicate().dep_node()"}]}