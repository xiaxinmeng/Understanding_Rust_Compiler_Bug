{"sha": "b3290d322e32a1110fd31e9a9ecd246252c1c67c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMjkwZDMyMmUzMmExMTEwZmQzMWU5YTllY2QyNDYyNTJjMWM2N2M=", "commit": {"author": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-01-22T05:33:37Z"}, "committer": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-01-23T19:44:28Z"}, "message": "Make some borrow checker errors more user friendly\n\nA mutable and immutable borrow place some restrictions on what you can\nwith the variable until the borrow ends. This commit attempts to convey\nto the user what those restrictions are. Also, if the original borrow is\na mutable borrow, the error message has been changed (more specifically,\ni. \"cannot borrow `x` as immutable because it is also borrowed as\nmutable\" and ii. \"cannot borrow `x` as mutable more than once\" have\nbeen changed to \"cannot borrow `x` because it is already borrowed as\nmutable\").\n\nIn addition, this adds a (custom) span note to communicate where the\noriginal borrow ends.", "tree": {"sha": "1496c722764433c99773d6ab575ade8cd90dc250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1496c722764433c99773d6ab575ade8cd90dc250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3290d322e32a1110fd31e9a9ecd246252c1c67c", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3290d322e32a1110fd31e9a9ecd246252c1c67c", "html_url": "https://github.com/rust-lang/rust/commit/b3290d322e32a1110fd31e9a9ecd246252c1c67c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3290d322e32a1110fd31e9a9ecd246252c1c67c/comments", "author": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43cffe9d719170bd342b10d1bb81911f0e14a7c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/43cffe9d719170bd342b10d1bb81911f0e14a7c4", "html_url": "https://github.com/rust-lang/rust/commit/43cffe9d719170bd342b10d1bb81911f0e14a7c4"}], "stats": {"total": 177, "additions": 144, "deletions": 33}, "files": [{"sha": "b6341374a7d2b9402aa2d621217a92306c0fa536", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -248,6 +248,9 @@ impl Session_ {\n     pub fn span_note(&self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n+    pub fn span_end_note(&self, sp: Span, msg: &str) {\n+        self.span_diagnostic.span_end_note(sp, msg)\n+    }\n     pub fn note(&self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }"}, {"sha": "0fd92079489ae152565dc4958742777192cf1e93", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -231,34 +231,47 @@ impl<'a> CheckLoanCtxt<'a> {\n             if restr.loan_path != loan2.loan_path { continue; }\n \n             match (new_loan.mutbl, old_loan.mutbl) {\n-                (MutableMutability, MutableMutability) => {\n+                (_, MutableMutability) => {\n+                    let var = self.bccx.loan_path_to_str(new_loan.loan_path);\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as mutable \\\n-                              more than once at a time\",\n-                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                        format!(\"cannot borrow `{}` because it is already \\\n+                                 borrowed as mutable\", var));\n                     self.bccx.span_note(\n                         old_loan.span,\n-                        format!(\"previous borrow of `{}` as mutable occurs here\",\n-                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n-                    return false;\n+                        format!(\"previous borrow of `{0}` as mutable occurs \\\n+                                 here; the mutable borrow prevents subsequent \\\n+                                 moves, borrows, or modification of `{0}` \\\n+                                 until the borrow ends\", var));\n                 }\n \n-                _ => {\n+                (_, mutability) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n-                              it is also borrowed as {}\",\n+                              it is already borrowed as {}\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path),\n                              self.bccx.mut_to_str(new_loan.mutbl),\n                              self.bccx.mut_to_str(old_loan.mutbl)));\n-                    self.bccx.span_note(\n-                        old_loan.span,\n-                        format!(\"previous borrow of `{}` occurs here\",\n-                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n-                    return false;\n+\n+                    let var = self.bccx.loan_path_to_str(new_loan.loan_path);\n+                    let mut note = format!(\"previous borrow of `{}` occurs \\\n+                                            here\", var);\n+                    if mutability == ImmutableMutability {\n+                        note.push_str(format!(\"; the immutable borrow prevents \\\n+                                               subsequent moves or mutable\n+                                               borrows of `{}` until the\n+                                               borrow ends\", var));\n+                    }\n+                    self.bccx.span_note(old_loan.span, note);\n                 }\n             }\n+\n+            let old_loan_span = ast_map::node_span(self.tcx().items,\n+                                                   old_loan.kill_scope);\n+            self.bccx.span_end_note(old_loan_span,\n+                                    \"previous borrow ends here\");\n+            return false;\n         }\n \n         true"}, {"sha": "f1cccab12399dc5cc52b42e40f9d019ddde0be72", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -631,6 +631,10 @@ impl BorrowckCtxt {\n         self.tcx.sess.span_note(s, m);\n     }\n \n+    pub fn span_end_note(&self, s: Span, m: &str) {\n+        self.tcx.sess.span_end_note(s, m);\n+    }\n+\n     pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {"}, {"sha": "bad95374123a3fbdb95b1d30297beafbf75df014", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -311,10 +311,6 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn adjust_span(&self, sp: Span) -> Span {\n-        sp\n-    }\n-\n     pub fn span_to_str(&self, sp: Span) -> ~str {\n         {\n             let files = self.files.borrow();"}, {"sha": "a9d3f6fea24107f88b79b1088896b99903cbd44d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 76, "deletions": 12, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -19,12 +19,16 @@ use extra::term;\n \n static BUG_REPORT_URL: &'static str =\n     \"http://static.rust-lang.org/doc/master/complement-bugreport.html\";\n+// maximum number of lines we will print for each error; arbitrary.\n+static MAX_LINES: uint = 6u;\n \n pub trait Emitter {\n     fn emit(&self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: Level);\n+    fn custom_emit(&self, cm: &codemap::CodeMap,\n+                   sp: Span, msg: &str, lvl: Level);\n }\n \n /// This structure is used to signify that a task has failed with a fatal error\n@@ -55,6 +59,9 @@ impl SpanHandler {\n     pub fn span_note(@self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Note);\n     }\n+    pub fn span_end_note(@self, sp: Span, msg: &str) {\n+        self.handler.custom_emit(&*self.cm, sp, msg, Note);\n+    }\n     pub fn span_bug(@self, sp: Span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n@@ -122,6 +129,10 @@ impl Handler {\n             lvl: Level) {\n         self.emit.emit(cmsp, msg, lvl);\n     }\n+    pub fn custom_emit(@self, cm: &codemap::CodeMap,\n+                       sp: Span, msg: &str, lvl: Level) {\n+        self.emit.custom_emit(cm, sp, msg, lvl);\n+    }\n }\n \n pub fn ice_msg(msg: &str) -> ~str {\n@@ -239,17 +250,34 @@ impl Emitter for DefaultEmitter {\n             msg: &str,\n             lvl: Level) {\n         match cmsp {\n-            Some((cm, sp)) => {\n-                let sp = cm.adjust_span(sp);\n-                let ss = cm.span_to_str(sp);\n-                let lines = cm.span_to_lines(sp);\n-                print_diagnostic(ss, lvl, msg);\n-                highlight_lines(cm, sp, lvl, lines);\n-                print_macro_backtrace(cm, sp);\n-            }\n+            Some((cm, sp)) => emit(cm, sp, msg, lvl, false),\n             None => print_diagnostic(\"\", lvl, msg),\n         }\n     }\n+\n+    fn custom_emit(&self, cm: &codemap::CodeMap,\n+                   sp: Span, msg: &str, lvl: Level) {\n+        emit(cm, sp, msg, lvl, true);\n+    }\n+}\n+\n+fn emit(cm: &codemap::CodeMap, sp: Span,\n+        msg: &str, lvl: Level, custom: bool) {\n+    let ss = cm.span_to_str(sp);\n+    let lines = cm.span_to_lines(sp);\n+    if custom {\n+        // we want to tell compiletest/runtest to look at the last line of the\n+        // span (since `custom_highlight_lines` displays an arrow to the end of\n+        // the span)\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n+        let ses = cm.span_to_str(span_end);\n+        print_diagnostic(ses, lvl, msg);\n+        custom_highlight_lines(cm, sp, lvl, lines);\n+    } else {\n+        print_diagnostic(ss, lvl, msg);\n+        highlight_lines(cm, sp, lvl, lines);\n+    }\n+    print_macro_backtrace(cm, sp);\n }\n \n fn highlight_lines(cm: &codemap::CodeMap,\n@@ -260,12 +288,10 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     let mut err = io::stderr();\n     let err = &mut err as &mut io::Writer;\n \n-    // arbitrarily only print up to six lines of the error\n-    let max_lines = 6u;\n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n-    if display_lines.len() > max_lines {\n-        display_lines = display_lines.slice(0u, max_lines);\n+    if display_lines.len() > MAX_LINES {\n+        display_lines = display_lines.slice(0u, MAX_LINES);\n         elided = true;\n     }\n     // Print the offending lines\n@@ -319,6 +345,44 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     }\n }\n \n+// Here are the differences between this and the normal `highlight_lines`:\n+// `custom_highlight_lines` will always put arrow on the last byte of the\n+// span (instead of the first byte). Also, when the span is too long (more\n+// than 6 lines), `custom_highlight_lines` will print the first line, then\n+// dot dot dot, then last line, whereas `highlight_lines` prints the first\n+// six lines.\n+fn custom_highlight_lines(cm: &codemap::CodeMap,\n+                          sp: Span,\n+                          lvl: Level,\n+                          lines: &codemap::FileLines) {\n+    let fm = lines.file;\n+    let mut err = io::stderr();\n+    let err = &mut err as &mut io::Writer;\n+\n+    let lines = lines.lines.as_slice();\n+    if lines.len() > MAX_LINES {\n+        write!(err, \"{}:{} {}\\n\", fm.name,\n+               lines[0] + 1, fm.get_line(lines[0] as int));\n+        write!(err, \"...\\n\");\n+        let last_line = lines[lines.len()-1];\n+        write!(err, \"{}:{} {}\\n\", fm.name,\n+               last_line + 1, fm.get_line(last_line as int));\n+    } else {\n+        for line in lines.iter() {\n+            write!(err, \"{}:{} {}\\n\", fm.name,\n+                   *line + 1, fm.get_line(*line as int));\n+        }\n+    }\n+    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n+    let hi = cm.lookup_char_pos(sp.hi);\n+    // Span seems to use half-opened interval, so subtract 1\n+    let skip = last_line_start.len() + hi.col.to_uint() - 1;\n+    let mut s = ~\"\";\n+    skip.times(|| s.push_char(' '));\n+    s.push_char('^');\n+    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()));\n+}\n+\n fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));"}, {"sha": "c338aac2ddf5ecc452633ee2e7143c5e6c3bc3ac", "filename": "src/test/compile-fail/borrowck-borrow-mut-object-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -18,7 +18,7 @@ trait Foo {\n \n fn test(x: &mut Foo) {\n     let _y = x.f1();\n-    x.f2(); //~ ERROR cannot borrow `*x` as mutable more than once at a time\n+    x.f2(); //~ ERROR cannot borrow `*x` because it is already borrowed as mutable\n }\n \n fn main() {}"}, {"sha": "3c01045369f28a5b5517d8759d91d73733f5f496", "filename": "src/test/compile-fail/borrowck-report-with-custom-diagnostic.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fborrowck-report-with-custom-diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fborrowck-report-with-custom-diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-report-with-custom-diagnostic.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -0,0 +1,31 @@\n+#[allow(dead_code)];\n+fn main() {\n+    // Original borrow ends at end of function\n+    let mut x = 1u;\n+    let y = &mut x;\n+    let z = &x; //~ ERROR cannot borrow\n+}\n+//~^ NOTE previous borrow ends here\n+\n+fn foo() {\n+    match true {\n+        true => {\n+            // Original borrow ends at end of match arm\n+            let mut x = 1u;\n+            let y = &x;\n+            let z = &mut x; //~ ERROR cannot borrow\n+        }\n+     //~^ NOTE previous borrow ends here\n+        false => ()\n+    }\n+}\n+\n+fn bar() {\n+    // Original borrow ends at end of closure\n+    || {\n+        let mut x = 1u;\n+        let y = &mut x;\n+        let z = &mut x; //~ ERROR cannot borrow\n+    };\n+ //~^ NOTE previous borrow ends here\n+}"}, {"sha": "5b8079b832e79a914bfee15306c2272c63aa8b0d", "filename": "src/test/compile-fail/mut-cant-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     let m = RefCell::new(0);\n     let mut b = m.borrow_mut();\n     let b1 = b.get();\n-    let b2 = b.get(); //~ ERROR cannot borrow `b` as mutable more than once at a time\n+    let b2 = b.get(); //~ ERROR cannot borrow `b` because it is already borrowed as mutable\n }"}, {"sha": "21ffc1ae7f9341312f1f3062ea8666ef4f4c0c2d", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3290d322e32a1110fd31e9a9ecd246252c1c67c/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=b3290d322e32a1110fd31e9a9ecd246252c1c67c", "patch": "@@ -12,6 +12,6 @@ fn main() {\n     let mut xs = ~[1, 2, 3, 4];\n \n     for x in xs.mut_iter() {\n-        xs.push(1) //~ ERROR cannot borrow `xs` as mutable\n+        xs.push(1) //~ ERROR cannot borrow `xs` because it is already borrowed as mutable\n     }\n }"}]}