{"sha": "c27779f59b451949599d6f6ca74e8eb1026b02c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNzc3OWY1OWI0NTE5NDk1OTlkNmY2Y2E3NGU4ZWIxMDI2YjAyYzA=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-08-11T07:23:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-11T07:23:47Z"}, "message": "Rollup merge of #75226 - pnadon:miri-undef-uninit, r=RalfJung\n\nMiri: Renamed \"undef\" to \"uninit\"\n\nRenamed remaining references to \"undef\" to \"uninit\" when referring to Miri.\n\nImpacted directories are:\n\n- `src/librustc_codegen_llvm/consts.rs`\n- `src/librustc_middle/mir/interpret/`\n- `src/librustc_middle/ty/print/pretty.rs`\n- `src/librustc_mir/`\n- `src/tools/clippy/clippy_lints/src/consts.rs`\n\nUpon building Miri based on the new changes it was verified that no changes needed to be made with the Miri project.\n\nRelated issue #71193", "tree": {"sha": "8b178c1a52426c85cd67f94fbfe3227790c0f39b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b178c1a52426c85cd67f94fbfe3227790c0f39b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c27779f59b451949599d6f6ca74e8eb1026b02c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfMkeDCRBK7hj4Ov3rIwAAdHIIAD516HCnUFJ+GCCcqYaDnV/s\ndYToVMEKY9M6SFz6Q2xHoZ29b+5TwJPZVemFaQ5m8U6TrAVuaQUFkF5IBMkckfM3\nuWgXRJAXlvQSfFkjkG+fF/oUAzdR6kQIp7PK3u5l+be/dGfm6Tb5MOp72bEbPdHk\ntmv28muNMX1Y0ON0MweVO84lLoKKseZHSJ6eiK+BKp+3848hVHZrYdIbaEycYO/e\nREp1YiT/fL/Y7FUHW17jQzCLnOf3xguvDddgS+W13k/6u8fr4CDTMoSEzxWk9N9e\nu65LtHP67GSChFEQnehY4qV1CCa7WV9c+V8qBJzKgyLKMRTWqTNzMR7c3HFx2rA=\n=v9va\n-----END PGP SIGNATURE-----\n", "payload": "tree 8b178c1a52426c85cd67f94fbfe3227790c0f39b\nparent f26f201d42df2a42124383eafaa23eb97f620718\nparent 0c6e8b61b6a4df87216570931c687874f28022fd\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1597130627 +0900\ncommitter GitHub <noreply@github.com> 1597130627 +0900\n\nRollup merge of #75226 - pnadon:miri-undef-uninit, r=RalfJung\n\nMiri: Renamed \"undef\" to \"uninit\"\n\nRenamed remaining references to \"undef\" to \"uninit\" when referring to Miri.\n\nImpacted directories are:\n\n- `src/librustc_codegen_llvm/consts.rs`\n- `src/librustc_middle/mir/interpret/`\n- `src/librustc_middle/ty/print/pretty.rs`\n- `src/librustc_mir/`\n- `src/tools/clippy/clippy_lints/src/consts.rs`\n\nUpon building Miri based on the new changes it was verified that no changes needed to be made with the Miri project.\n\nRelated issue #71193\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c27779f59b451949599d6f6ca74e8eb1026b02c0", "html_url": "https://github.com/rust-lang/rust/commit/c27779f59b451949599d6f6ca74e8eb1026b02c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c27779f59b451949599d6f6ca74e8eb1026b02c0/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f26f201d42df2a42124383eafaa23eb97f620718", "url": "https://api.github.com/repos/rust-lang/rust/commits/f26f201d42df2a42124383eafaa23eb97f620718", "html_url": "https://github.com/rust-lang/rust/commit/f26f201d42df2a42124383eafaa23eb97f620718"}, {"sha": "0c6e8b61b6a4df87216570931c687874f28022fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6e8b61b6a4df87216570931c687874f28022fd", "html_url": "https://github.com/rust-lang/rust/commit/0c6e8b61b6a4df87216570931c687874f28022fd"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "024834bfe2aa558a9f252f7420b831dfd557d7a4", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -41,15 +41,15 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             // some arbitrary byte value.\n             //\n             // FIXME: relay undef bytes to codegen as undef const bytes\n-            let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(next_offset..offset);\n+            let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);\n             llvals.push(cx.const_bytes(bytes));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n             // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n             // affect interpreter execution (we inspect the result after interpreter execution),\n             // and we properly interpret the relocation as a relocation pointer offset.\n-            alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n+            alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n@@ -74,7 +74,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         // arbitrary byte value.\n         //\n         // FIXME: relay undef bytes to codegen as undef const bytes\n-        let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(range);\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n         llvals.push(cx.const_bytes(bytes));\n     }\n \n@@ -452,7 +452,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // BSS.\n                     let all_bytes_are_zero = alloc.relocations().is_empty()\n                         && alloc\n-                            .inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n                             .all(|&byte| byte == 0);\n \n@@ -480,7 +480,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // because we are doing this access to inspect the final interpreter state (not\n                     // as part of the interpreter execution).\n                     let bytes =\n-                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len());\n+                        alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n                         bytes.as_ptr().cast(),"}, {"sha": "b23deb2e3bc9b5fe75b368a32dade4c538a0dd72", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -154,10 +154,10 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n-    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// from `get_bytes_with_uninit_and_ptr` in that it does no relocation checks (even on the\n     /// edges) at all. It further ignores `AllocationExtra` callbacks.\n     /// This must not be used for reads affecting the interpreter execution.\n-    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+    pub fn inspect_with_uninit_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n         &self.bytes[range]\n     }\n \n@@ -194,7 +194,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n-    /// `get_bytes_with_undef_and_ptr` instead,\n+    /// `get_bytes_with_uninit_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n@@ -244,7 +244,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr(\n+    pub fn get_bytes_with_uninit_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -302,19 +302,19 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n-    /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n+    /// relocation. If `allow_uninit_and_ptr` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor uninitialized bytes.\n     pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        allow_ptr_and_undef: bool,\n+        allow_uninit_and_ptr: bool,\n     ) -> InterpResult<'tcx> {\n         // Check bounds and relocations on the edges.\n-        self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n         // Check uninit and ptr.\n-        if !allow_ptr_and_undef {\n+        if !allow_uninit_and_ptr {\n             self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         }\n@@ -361,7 +361,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         // `get_bytes_unchecked` tests relocation edges.\n-        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        let bytes = self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n         if self.is_init(ptr, size).is_err() {\n@@ -594,7 +594,7 @@ impl InitMaskCompressed {\n /// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the initialization mask.\n-    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n+    pub fn compress_uninit_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n         // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n@@ -636,8 +636,8 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         size: Size,\n         repeat: u64,\n     ) {\n-        // An optimization where we can just overwrite an entire range of definedness bits if\n-        // they are going to be uniformly `1` or `0`.\n+        // An optimization where we can just overwrite an entire range of initialization\n+        // bits if they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n             self.init_mask.set_range_inbounds(\n                 dest.offset,"}, {"sha": "50c76e29663f66af14c4355652bd973b3da74030", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> ConstValue<'tcx> {\n \n     pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n         if let ConstValue::Slice { data, start, end } = *self {\n-            ::std::str::from_utf8(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+            ::std::str::from_utf8(data.inspect_with_uninit_and_ptr_outside_interpreter(start..end))\n                 .ok()\n         } else {\n             None"}, {"sha": "87944db60de66d8e7b7ede44364d6756363e34bf", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -1107,7 +1107,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are\n                 // no relocations (we have an active slice reference here). We don't use\n                 // this result to affect interpreter execution.\n-                let byte_str = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let byte_str = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 self.pretty_print_byte_str(byte_str)\n             }\n             (\n@@ -1117,7 +1117,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are no\n                 // relocations (we have an active `str` reference here). We don't use this\n                 // result to affect interpreter execution.\n-                let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let slice = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n                 p!(write(\"{:?}\", s));\n                 Ok(self)"}, {"sha": "705a547262f027463b157ab9ab736a4ac07ede49", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -926,7 +926,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n-        // (`get_bytes_with_undef_and_ptr` below checks that there are no\n+        // (`get_bytes_with_uninit_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations =\n             self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n@@ -935,7 +935,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // This checks relocation edges on the src.\n         let src_bytes =\n-            self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n+            self.get_raw(src.alloc_id)?.get_bytes_with_uninit_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n             self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n \n@@ -948,7 +948,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let dest_bytes = dest_bytes.as_mut_ptr();\n \n         // Prepare a copy of the initialization mask.\n-        let compressed = self.get_raw(src.alloc_id)?.compress_undef_range(src, size);\n+        let compressed = self.get_raw(src.alloc_id)?.compress_uninit_range(src, size);\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range"}, {"sha": "0b58caef54d2bf2cb7cc679d9e7e8ed27dae89f2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -106,7 +106,7 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n                 }\n                 ScalarMaybeUninit::Uninit => cx.typed_value(\n                     |mut this| {\n-                        this.write_str(\"{undef \")?;\n+                        this.write_str(\"{uninit \")?;\n                         Ok(this)\n                     },\n                     |this| this.print_type(ty),"}, {"sha": "20fd8e43361d6561d9c3cb7c74e52c0d5ee8016b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -61,7 +61,7 @@ impl<Tag> MemPlaceMeta<Tag> {\n pub struct MemPlace<Tag = ()> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n-    /// However, it may never be undef.\n+    /// However, it may never be uninit.\n     pub ptr: Scalar<Tag>,\n     pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n@@ -729,7 +729,7 @@ where\n                         \"Size mismatch when writing bits\"\n                     )\n                 }\n-                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // undef can have any size\n+                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n                 Immediate::ScalarPair(_, _) => {\n                     // FIXME: Can we check anything here?\n                 }"}, {"sha": "9cd20340138cf290bf539c05a9a9ecc9a7bb6e08", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -508,12 +508,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     }\n                 } else {\n                     // At run-time, for now, we accept *anything* for these types, including\n-                    // undef. We should fix that, but let's start low.\n+                    // uninit. We should fix that, but let's start low.\n                 }\n                 Ok(true)\n             }\n             ty::RawPtr(..) => {\n-                // We are conservative with undef for integers, but try to\n+                // We are conservative with uninit for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place = try_validation!(\n@@ -807,12 +807,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n-                // We also accept undef, for consistency with the slow path.\n+                // We also accept uninit, for consistency with the slow path.\n                 match self.ecx.memory.get_raw(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_ptr_and_undef*/ self.ref_tracking_for_consts.is_none(),\n+                    /*allow_uninit_and_ptr*/ self.ref_tracking_for_consts.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}"}, {"sha": "07b13af6ba77678ab1b8a10c842b8837db87b18b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -1076,7 +1076,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 // ```rust\n                 // let mut x = 42;\n                 // x = SOME_MUTABLE_STATIC;\n-                // // x must now be undefined\n+                // // x must now be uninit\n                 // ```\n                 // FIXME: we overzealously erase the entire local, because that's easier to\n                 // implement."}, {"sha": "c3dbac08ed800faa53580d697845f03e0cdc6c16", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -743,8 +743,8 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n         if let Some(&(tag, target_id)) = alloc.relocations().get(&i) {\n             // Memory with a relocation must be defined\n             let j = i.bytes_usize();\n-            let offset =\n-                alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n+            let offset = alloc\n+                .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n             let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n             let offset = Size::from_bytes(offset);\n             let relocation_width = |bytes| bytes * 3;\n@@ -803,7 +803,7 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n \n             // Checked definedness (and thus range) and relocations. This access also doesn't\n             // influence interpreter execution but is only for debugging.\n-            let c = alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + 1)[0];\n+            let c = alloc.inspect_with_uninit_and_ptr_outside_interpreter(j..j + 1)[0];\n             write!(w, \"{:02x}\", c)?;\n             if c.is_ascii_control() || c >= 0x80 {\n                 ascii.push('.');"}, {"sha": "c77b80bc23733e1b4495e07f78c1210eafd388c4", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c27779f59b451949599d6f6ca74e8eb1026b02c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=c27779f59b451949599d6f6ca74e8eb1026b02c0", "patch": "@@ -517,7 +517,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n             ty::Ref(_, tam, _) => match tam.kind {\n                 ty::Str => String::from_utf8(\n-                    data.inspect_with_undef_and_ptr_outside_interpreter(start..end)\n+                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),\n                 )\n                 .ok()\n@@ -530,7 +530,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n             ty::Array(sub_type, len) => match sub_type.kind {\n                 ty::Float(FloatTy::F32) => match miri_to_const(len) {\n                     Some(Constant::Int(len)) => alloc\n-                        .inspect_with_undef_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n                         .chunks(4)\n                         .map(|chunk| {\n@@ -544,7 +544,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 },\n                 ty::Float(FloatTy::F64) => match miri_to_const(len) {\n                     Some(Constant::Int(len)) => alloc\n-                        .inspect_with_undef_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()\n                         .chunks(8)\n                         .map(|chunk| {"}]}