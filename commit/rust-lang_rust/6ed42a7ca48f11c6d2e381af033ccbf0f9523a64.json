{"sha": "6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "node_id": "C_kwDOAAsO6NoAKDZlZDQyYTdjYTQ4ZjExYzZkMmUzODFhZjAzM2NjYmYwZjk1MjNhNjQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-18T09:43:49Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-18T09:44:46Z"}, "message": "Check const Drop impls considering ConstIfConst bounds", "tree": {"sha": "878214cc083b299280ee18b219224b2c02915c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/878214cc083b299280ee18b219224b2c02915c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "html_url": "https://github.com/rust-lang/rust/commit/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9eb0b3b7ba13ea80733f418ac28e8988d60588d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9eb0b3b7ba13ea80733f418ac28e8988d60588d", "html_url": "https://github.com/rust-lang/rust/commit/f9eb0b3b7ba13ea80733f418ac28e8988d60588d"}], "stats": {"total": 382, "additions": 221, "deletions": 161}, "files": [{"sha": "1269f2207d5ad95ce90565f4d35dd967a40adbfc", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -4,11 +4,12 @@\n \n use rustc_errors::ErrorReported;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::TraitEngine;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n-    self, ImplSource, Obligation, ObligationCause, SelectionContext,\n+    self, FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n \n use super::ConstCx;\n@@ -161,28 +162,46 @@ impl Qualif for NeedsNonConstDrop {\n             // without having the lang item present.\n             return false;\n         };\n-        let trait_ref =\n-            ty::TraitRef { def_id: drop_trait, substs: cx.tcx.mk_substs_trait(ty, &[]) };\n+\n         let obligation = Obligation::new(\n             ObligationCause::dummy(),\n             cx.param_env,\n             ty::Binder::dummy(ty::TraitPredicate {\n-                trait_ref,\n+                trait_ref: ty::TraitRef {\n+                    def_id: drop_trait,\n+                    substs: cx.tcx.mk_substs_trait(ty, &[]),\n+                },\n                 constness: ty::BoundConstness::ConstIfConst,\n                 polarity: ty::ImplPolarity::Positive,\n             }),\n         );\n \n-        let implsrc = cx.tcx.infer_ctxt().enter(|infcx| {\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n-            selcx.select(&obligation)\n-        });\n-        !matches!(\n-            implsrc,\n-            Ok(Some(\n+            let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n+                // If we couldn't select a const drop candidate, then it's bad\n+                return true;\n+            };\n+\n+            if !matches!(\n+                impl_src,\n                 ImplSource::ConstDrop(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n-            ))\n-        )\n+            ) {\n+                // If our const drop candidate is not ConstDrop or implied by param,\n+                // then it's bad\n+                return true;\n+            }\n+\n+            // If we successfully found one, then select all of the predicates\n+            // implied by our const drop impl.\n+            let mut fcx = FulfillmentContext::new();\n+            for nested in impl_src.nested_obligations() {\n+                fcx.register_predicate_obligation(&infcx, nested);\n+            }\n+\n+            // If we had any errors, then it's bad\n+            !fcx.select_all_or_error(&infcx).is_empty()\n+        })\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "b7ccfac8063d7742a8f45742583c94a97b3f69b2", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -566,7 +566,7 @@ pub enum ImplSource<'tcx, N> {\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n \n     /// ImplSource for a `const Drop` implementation.\n-    ConstDrop(ImplSourceConstDropData),\n+    ConstDrop(ImplSourceConstDropData<N>),\n }\n \n impl<'tcx, N> ImplSource<'tcx, N> {\n@@ -581,10 +581,10 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData)\n-            | ImplSource::ConstDrop(ImplSourceConstDropData) => Vec::new(),\n+            | ImplSource::Pointee(ImplSourcePointeeData) => Vec::new(),\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n+            ImplSource::ConstDrop(i) => i.nested,\n         }\n     }\n \n@@ -599,10 +599,10 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::FnPointer(d) => &d.nested,\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData)\n-            | ImplSource::ConstDrop(ImplSourceConstDropData) => &[],\n+            | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n+            ImplSource::ConstDrop(i) => &i.nested,\n         }\n     }\n \n@@ -661,9 +661,9 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                     nested: d.nested.into_iter().map(f).collect(),\n                 })\n             }\n-            ImplSource::ConstDrop(ImplSourceConstDropData) => {\n-                ImplSource::ConstDrop(ImplSourceConstDropData)\n-            }\n+            ImplSource::ConstDrop(i) => ImplSource::ConstDrop(ImplSourceConstDropData {\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n         }\n     }\n }\n@@ -755,8 +755,10 @@ pub struct ImplSourceDiscriminantKindData;\n #[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub struct ImplSourcePointeeData;\n \n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourceConstDropData;\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n+pub struct ImplSourceConstDropData<N> {\n+    pub nested: Vec<N>,\n+}\n \n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {"}, {"sha": "e18f04d92eec49d500a198f817dcab666a743611", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -146,8 +146,8 @@ pub enum SelectionCandidate<'tcx> {\n \n     BuiltinUnsizeCandidate,\n \n-    /// Implementation of `const Drop`.\n-    ConstDropCandidate,\n+    /// Implementation of `const Drop`, optionally from a custom `impl const Drop`.\n+    ConstDropCandidate(Option<DefId>),\n }\n \n /// The result of trait evaluation. The order is important"}, {"sha": "6ce9f5eea349125d8b0423cc6486f6c454e97281", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -120,12 +120,17 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n     }\n }\n \n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDropData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ImplSourceConstDropData(nested={:?})\", self.nested)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n TrivialTypeFoldableAndLiftImpls! {\n     super::IfExpressionCause,\n     super::ImplSourceDiscriminantKindData,\n     super::ImplSourcePointeeData,\n-    super::ImplSourceConstDropData,\n }"}, {"sha": "20297518a5945c62d56cbd262c0c14d32696e478", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 62, "deletions": 130, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -307,13 +307,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             } else if lang_items.drop_trait() == Some(def_id)\n                 && obligation.predicate.skip_binder().constness == ty::BoundConstness::ConstIfConst\n             {\n-                if obligation.param_env.constness() == hir::Constness::Const {\n-                    self.assemble_const_drop_candidates(obligation, stack, &mut candidates)?;\n-                } else {\n-                    debug!(\"passing ~const Drop bound; in non-const context\");\n-                    // `~const Drop` when we are not in a const context has no effect.\n-                    candidates.vec.push(ConstDropCandidate)\n-                }\n+                self.assemble_const_drop_candidates(obligation, &mut candidates);\n             } else {\n                 if lang_items.clone_trait() == Some(def_id) {\n                     // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n@@ -918,139 +912,77 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn assemble_const_drop_candidates<'a>(\n+    fn assemble_const_drop_candidates(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        obligation_stack: &TraitObligationStack<'a, 'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        let mut stack: Vec<(Ty<'tcx>, usize)> = vec![(obligation.self_ty().skip_binder(), 0)];\n-\n-        while let Some((ty, depth)) = stack.pop() {\n-            let mut noreturn = false;\n-\n-            self.check_recursion_depth(depth, obligation)?;\n-            let mut new_candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n-            let mut copy_obligation =\n-                obligation.with(obligation.predicate.rebind(ty::TraitPredicate {\n-                    trait_ref: ty::TraitRef {\n-                        def_id: self.tcx().require_lang_item(hir::LangItem::Copy, None),\n-                        substs: self.tcx().mk_substs_trait(ty, &[]),\n-                    },\n-                    constness: ty::BoundConstness::NotConst,\n-                    polarity: ty::ImplPolarity::Positive,\n-                }));\n-            copy_obligation.recursion_depth = depth + 1;\n-            self.assemble_candidates_from_impls(&copy_obligation, &mut new_candidates);\n-            let copy_conditions = self.copy_clone_conditions(&copy_obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut new_candidates);\n-            let copy_stack = self.push_stack(obligation_stack.list(), &copy_obligation);\n-            self.assemble_candidates_from_caller_bounds(&copy_stack, &mut new_candidates)?;\n-\n-            let const_drop_obligation =\n-                obligation.with(obligation.predicate.rebind(ty::TraitPredicate {\n-                    trait_ref: ty::TraitRef {\n-                        def_id: self.tcx().require_lang_item(hir::LangItem::Drop, None),\n-                        substs: self.tcx().mk_substs_trait(ty, &[]),\n-                    },\n-                    constness: ty::BoundConstness::ConstIfConst,\n-                    polarity: ty::ImplPolarity::Positive,\n-                }));\n-\n-            let const_drop_stack = self.push_stack(obligation_stack.list(), &const_drop_obligation);\n-            self.assemble_candidates_from_caller_bounds(&const_drop_stack, &mut new_candidates)?;\n-\n-            if !new_candidates.vec.is_empty() {\n-                noreturn = true;\n-            }\n-            debug!(?new_candidates.vec, \"assemble_const_drop_candidates\");\n-\n-            match ty.kind() {\n-                ty::Int(_)\n-                | ty::Uint(_)\n-                | ty::Float(_)\n-                | ty::Infer(ty::IntVar(_))\n-                | ty::Infer(ty::FloatVar(_))\n-                | ty::FnPtr(_)\n-                | ty::Never\n-                | ty::Ref(..)\n-                | ty::FnDef(..)\n-                | ty::RawPtr(_)\n-                | ty::Bool\n-                | ty::Char\n-                | ty::Str\n-                | ty::Foreign(_) => {} // Do nothing. These types satisfy `const Drop`.\n-\n-                ty::Adt(def, subst) => {\n-                    let mut set = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n-                    self.assemble_candidates_from_impls(\n-                        &obligation.with(obligation.predicate.map_bound(|mut pred| {\n-                            pred.trait_ref.substs = self.tcx().mk_substs_trait(ty, &[]);\n-                            pred\n-                        })),\n-                        &mut set,\n-                    );\n-                    stack.extend(def.all_fields().map(|f| (f.ty(self.tcx(), subst), depth + 1)));\n-\n-                    debug!(?set.vec, \"assemble_const_drop_candidates - ty::Adt\");\n-                    if set.vec.into_iter().any(|candidate| {\n-                        if let SelectionCandidate::ImplCandidate(did) = candidate {\n-                            matches!(self.tcx().impl_constness(did), hir::Constness::NotConst)\n-                        } else {\n-                            false\n-                        }\n-                    }) {\n-                        if !noreturn {\n-                            // has non-const Drop\n-                            return Ok(());\n-                        }\n-                        debug!(\"not returning\");\n-                    }\n-                }\n-\n-                ty::Array(ty, _) => stack.push((ty, depth + 1)),\n-\n-                ty::Tuple(_) => stack.extend(ty.tuple_fields().map(|t| (t, depth + 1))),\n+    ) {\n+        // If the predicate is `~const Drop` in a non-const environment, we don't actually need\n+        // to check anything. We'll short-circuit checking any obligations in confirmation, too.\n+        if obligation.param_env.constness() == hir::Constness::NotConst {\n+            candidates.vec.push(ConstDropCandidate(None));\n+            return;\n+        }\n \n-                ty::Closure(_, substs) => {\n-                    let substs = substs.as_closure();\n-                    let ty = self.infcx.shallow_resolve(substs.tupled_upvars_ty());\n-                    stack.push((ty, depth + 1));\n-                }\n+        let self_ty = self.infcx().shallow_resolve(obligation.self_ty());\n+        match self_ty.skip_binder().kind() {\n+            ty::Opaque(..)\n+            | ty::Dynamic(..)\n+            | ty::Error(_)\n+            | ty::Bound(..)\n+            | ty::Param(_)\n+            | ty::Placeholder(_)\n+            | ty::Never\n+            | ty::Foreign(_)\n+            | ty::Projection(_) => {\n+                // We don't know if these are `~const Drop`, at least\n+                // not structurally... so don't push a candidate.\n+            }\n \n-                ty::Generator(_, substs, _) => {\n-                    let substs = substs.as_generator();\n-                    let ty = self.infcx.shallow_resolve(substs.tupled_upvars_ty());\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Infer(ty::IntVar(_))\n+            | ty::Infer(ty::FloatVar(_))\n+            | ty::Str\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::Tuple(_)\n+            | ty::GeneratorWitness(_) => {\n+                // These are built-in, and cannot have a custom `impl const Drop`.\n+                candidates.vec.push(ConstDropCandidate(None));\n+            }\n \n-                    stack.push((ty, depth + 1));\n-                    stack.push((substs.witness(), depth + 1));\n-                }\n+            ty::Adt(..) => {\n+                // Find a custom `impl Drop` impl, if it exists\n+                let relevant_impl = self.tcx().find_map_relevant_impl(\n+                    obligation.predicate.def_id(),\n+                    obligation.predicate.skip_binder().trait_ref.self_ty(),\n+                    Some,\n+                );\n \n-                ty::GeneratorWitness(tys) => stack.extend(\n-                    self.tcx().erase_late_bound_regions(*tys).iter().map(|t| (t, depth + 1)),\n-                ),\n-\n-                ty::Slice(ty) => stack.push((ty, depth + 1)),\n-\n-                ty::Opaque(..)\n-                | ty::Dynamic(..)\n-                | ty::Error(_)\n-                | ty::Bound(..)\n-                | ty::Infer(_)\n-                | ty::Placeholder(_)\n-                | ty::Projection(..)\n-                | ty::Param(..) => {\n-                    if !noreturn {\n-                        return Ok(());\n+                if let Some(impl_def_id) = relevant_impl {\n+                    // Check that `impl Drop` is actually const, if there is a custom impl\n+                    if self.tcx().impl_constness(impl_def_id) == hir::Constness::Const {\n+                        candidates.vec.push(ConstDropCandidate(Some(impl_def_id)));\n                     }\n-                    debug!(\"not returning\");\n+                } else {\n+                    // Otherwise check the ADT like a built-in type (structurally)\n+                    candidates.vec.push(ConstDropCandidate(None));\n                 }\n             }\n-            debug!(?stack, \"assemble_const_drop_candidates - in loop\");\n-        }\n-        // all types have passed.\n-        candidates.vec.push(ConstDropCandidate);\n \n-        Ok(())\n+            ty::Infer(_) => {\n+                candidates.ambiguous = true;\n+            }\n+        }\n     }\n }"}, {"sha": "9d62614031c2267235e1d59536aeb64e9256af8e", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 104, "deletions": 2, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -80,7 +80,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 param_env: obligation.param_env.without_const(),\n                 ..*obligation\n             };\n-\n             obligation = &new_obligation;\n         }\n \n@@ -159,7 +158,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::TraitUpcasting(data))\n             }\n \n-            ConstDropCandidate => Ok(ImplSource::ConstDrop(ImplSourceConstDropData)),\n+            ConstDropCandidate(def_id) => {\n+                let data = self.confirm_const_drop_candidate(obligation, def_id)?;\n+                Ok(ImplSource::ConstDrop(data))\n+            }\n         }\n     }\n \n@@ -1087,4 +1089,104 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         Ok(ImplSourceBuiltinData { nested })\n     }\n+\n+    fn confirm_const_drop_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_def_id: Option<DefId>,\n+    ) -> Result<ImplSourceConstDropData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        // `~const Drop` in a non-const environment is always trivially true, since our type is `Drop`\n+        if obligation.param_env.constness() == Constness::NotConst {\n+            return Ok(ImplSourceConstDropData { nested: vec![] });\n+        }\n+\n+        let tcx = self.tcx();\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+\n+        let nested_tys = match *self_ty.skip_binder().kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Infer(ty::IntVar(_))\n+            | ty::Infer(ty::FloatVar(_))\n+            | ty::Str\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Projection(_) => vec![],\n+\n+            ty::Adt(def, substs) => def.all_fields().map(|f| f.ty(tcx, substs)).collect(),\n+\n+            ty::Array(ty, _) | ty::Slice(ty) => vec![ty],\n+\n+            ty::Tuple(tys) => tys.iter().map(|ty| ty.expect_ty()).collect(),\n+\n+            ty::Closure(_, substs) => vec![substs.as_closure().tupled_upvars_ty()],\n+\n+            ty::Generator(_, substs, _) => {\n+                vec![substs.as_generator().tupled_upvars_ty(), substs.as_generator().witness()]\n+            }\n+\n+            ty::GeneratorWitness(tys) => tcx.erase_late_bound_regions(tys).to_vec(),\n+\n+            ty::Opaque(_, _)\n+            | ty::Dynamic(_, _)\n+            | ty::Error(_)\n+            | ty::Bound(_, _)\n+            | ty::Param(_)\n+            | ty::Placeholder(_)\n+            | ty::Never\n+            | ty::Foreign(_)\n+            | ty::Infer(_) => {\n+                unreachable!();\n+            }\n+        };\n+\n+        info!(\n+            \"confirm_const_drop_candidate: self_ty={:?}, nested_tys={:?} impl_def_id={:?}\",\n+            self_ty, nested_tys, impl_def_id\n+        );\n+\n+        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+        let mut nested = vec![];\n+\n+        // If we have a custom `impl const Drop`, then check it like a regular impl candidate.\n+        if let Some(impl_def_id) = impl_def_id {\n+            nested.extend(self.confirm_impl_candidate(obligation, impl_def_id).nested);\n+        }\n+\n+        for ty in nested_tys {\n+            let predicate = self.infcx.commit_unconditionally(|_| {\n+                normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    self_ty\n+                        .rebind(ty::TraitPredicate {\n+                            trait_ref: ty::TraitRef {\n+                                def_id: self.tcx().require_lang_item(LangItem::Drop, None),\n+                                substs: self.tcx().mk_substs_trait(ty, &[]),\n+                            },\n+                            constness: ty::BoundConstness::ConstIfConst,\n+                            polarity: ty::ImplPolarity::Positive,\n+                        })\n+                        .to_predicate(tcx),\n+                    &mut nested,\n+                )\n+            });\n+\n+            nested.push(Obligation::with_depth(\n+                cause.clone(),\n+                obligation.recursion_depth + 1,\n+                obligation.param_env,\n+                predicate,\n+            ));\n+        }\n+\n+        Ok(ImplSourceConstDropData { nested })\n+    }\n }"}, {"sha": "558ecd393b614319bdadc26cd0c64f001a46b2fb", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed42a7ca48f11c6d2e381af033ccbf0f9523a64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6ed42a7ca48f11c6d2e381af033ccbf0f9523a64", "patch": "@@ -1153,7 +1153,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     GeneratorCandidate => {}\n                     // FnDef where the function is const\n                     FnPointerCandidate { is_const: true } => {}\n-                    ConstDropCandidate => {}\n+                    ConstDropCandidate(_) => {}\n                     _ => {\n                         // reject all other types of candidates\n                         continue;\n@@ -1537,7 +1537,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n-        // and `DiscriminantKindCandidate` to anything else.\n+        // `DiscriminantKindCandidate`, and `ConstDropCandidate` to anything else.\n         //\n         // This is a fix for #53123 and prevents winnowing from accidentally extending the\n         // lifetime of a variable.\n@@ -1554,15 +1554,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 BuiltinCandidate { has_nested: false }\n                 | DiscriminantKindCandidate\n                 | PointeeCandidate\n-                | ConstDropCandidate,\n+                | ConstDropCandidate(_),\n                 _,\n             ) => true,\n             (\n                 _,\n                 BuiltinCandidate { has_nested: false }\n                 | DiscriminantKindCandidate\n                 | PointeeCandidate\n-                | ConstDropCandidate,\n+                | ConstDropCandidate(_),\n             ) => false,\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {"}]}