{"sha": "69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZmZjZGNjY2ZlYzZlMmFmNjdjM2IwYjFlMmViZWYyZDMzODQ3YmQ=", "commit": {"author": {"name": "Ben Gamari", "email": "bgamari.foss@gmail.com", "date": "2014-07-12T04:50:57Z"}, "committer": {"name": "Ben Gamari", "email": "bgamari.foss@gmail.com", "date": "2014-07-15T22:54:47Z"}, "message": "libsyntax::ast: Derive Show impls", "tree": {"sha": "5d52cac0f1a964740cf466c4b24956256d233a5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d52cac0f1a964740cf466c4b24956256d233a5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd", "html_url": "https://github.com/rust-lang/rust/commit/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd/comments", "author": {"login": "bgamari", "id": 1010174, "node_id": "MDQ6VXNlcjEwMTAxNzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1010174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bgamari", "html_url": "https://github.com/bgamari", "followers_url": "https://api.github.com/users/bgamari/followers", "following_url": "https://api.github.com/users/bgamari/following{/other_user}", "gists_url": "https://api.github.com/users/bgamari/gists{/gist_id}", "starred_url": "https://api.github.com/users/bgamari/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bgamari/subscriptions", "organizations_url": "https://api.github.com/users/bgamari/orgs", "repos_url": "https://api.github.com/users/bgamari/repos", "events_url": "https://api.github.com/users/bgamari/events{/privacy}", "received_events_url": "https://api.github.com/users/bgamari/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bgamari", "id": 1010174, "node_id": "MDQ6VXNlcjEwMTAxNzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1010174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bgamari", "html_url": "https://github.com/bgamari", "followers_url": "https://api.github.com/users/bgamari/followers", "following_url": "https://api.github.com/users/bgamari/following{/other_user}", "gists_url": "https://api.github.com/users/bgamari/gists{/gist_id}", "starred_url": "https://api.github.com/users/bgamari/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bgamari/subscriptions", "organizations_url": "https://api.github.com/users/bgamari/orgs", "repos_url": "https://api.github.com/users/bgamari/repos", "events_url": "https://api.github.com/users/bgamari/events{/privacy}", "received_events_url": "https://api.github.com/users/bgamari/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de111e69a89c15e77f5f0c49c2f6ab4c25aa89c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/de111e69a89c15e77f5f0c49c2f6ab4c25aa89c1", "html_url": "https://github.com/rust-lang/rust/commit/de111e69a89c15e77f5f0c49c2f6ab4c25aa89c1"}], "stats": {"total": 152, "additions": 82, "deletions": 70}, "files": [{"sha": "857cb4c0162ce530d930950aa3699ca722db97ca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd", "patch": "@@ -152,7 +152,7 @@ impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n@@ -162,7 +162,7 @@ pub struct Lifetime {\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// std::cmp::PartialEq  .  It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Path {\n     pub span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -174,7 +174,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n@@ -208,15 +208,15 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Share.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n     StaticRegionTyParamBound,\n     UnboxedFnTyParamBound(UnboxedFnTy),\n     OtherRegionTyParamBound(Span) // FIXME -- just here until work for #5723 lands\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n@@ -228,7 +228,7 @@ pub struct TyParam {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub ty_params: OwnedSlice<TyParam>,\n@@ -250,7 +250,7 @@ impl Generics {\n /// used to drive conditional compilation\n pub type CrateConfig = Vec<Gc<MetaItem>> ;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -261,7 +261,7 @@ pub struct Crate {\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n-#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n     MetaList(InternedString, Vec<Gc<MetaItem>>),\n@@ -293,7 +293,7 @@ impl PartialEq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<Gc<Stmt>>,\n@@ -303,26 +303,26 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: Pat_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FieldPat {\n     pub ident: Ident,\n     pub pat: Gc<Pat>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n@@ -354,7 +354,7 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ExprVstore {\n     /// ~[1, 2, 3, 4]\n     ExprVstoreUniq,\n@@ -364,7 +364,7 @@ pub enum ExprVstore {\n     ExprVstoreMutSlice,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BinOp {\n     BiAdd,\n     BiSub,\n@@ -386,7 +386,7 @@ pub enum BinOp {\n     BiGt,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum UnOp {\n     UnBox,\n     UnUniq,\n@@ -397,7 +397,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n     StmtDecl(Gc<Decl>, NodeId),\n@@ -414,7 +414,7 @@ pub enum Stmt_ {\n \n /// Where a local declaration came from: either a true `let ... =\n /// ...;`, or one desugared from the pattern of a for loop.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum LocalSource {\n     LocalLet,\n     LocalFor,\n@@ -423,7 +423,7 @@ pub enum LocalSource {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Local {\n     pub ty: P<Ty>,\n     pub pat: Gc<Pat>,\n@@ -435,7 +435,7 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Decl_ {\n     /// A local (let) binding:\n     DeclLocal(Gc<Local>),\n@@ -444,15 +444,15 @@ pub enum Decl_ {\n }\n \n /// represents one arm of a 'match'\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<Gc<Pat>>,\n     pub guard: Option<Gc<Expr>>,\n     pub body: Gc<Expr>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Field {\n     pub ident: SpannedIdent,\n     pub expr: Gc<Expr>,\n@@ -461,26 +461,26 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n     ExprVstore(Gc<Expr>, ExprVstore),\n     /// First expr is the place; second expr is the value.\n@@ -547,7 +547,7 @@ pub enum Expr_ {\n /// makes any real sense. You could write them elsewhere but nothing\n /// else knows what to do with them, so you'll probably get a syntax\n /// error.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n@@ -621,7 +621,7 @@ pub enum TokenTree {\n // macro system. Congratulations.\n pub type Matcher = Spanned<Matcher_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Matcher_ {\n     /// Match one token\n     MatchTok(::parse::token::Token),\n@@ -638,7 +638,7 @@ pub type Mac = Spanned<Mac_>;\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n /// There's only one flavor, now, so this could presumably be simplified.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Mac_ {\n     // NB: the additional ident for a macro_rules-style macro is actually\n     // stored in the enclosing item. Oog.\n@@ -670,13 +670,13 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TypeField {\n     pub ident: Ident,\n     pub mt: MutTy,\n@@ -685,7 +685,7 @@ pub struct TypeField {\n \n /// Represents a required method in a trait declaration,\n /// one without a default implementation\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -702,7 +702,7 @@ pub struct TypeMethod {\n /// a default implementation A trait method is either required (meaning it\n /// doesn't have an implementation, just a signature) or provided (meaning it\n /// has a default implementation).\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n     Provided(Gc<Method>),\n@@ -779,15 +779,15 @@ impl FloatTy {\n }\n \n // NB PartialEq method appears below.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n }\n \n /// Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -813,7 +813,7 @@ impl fmt::Show for Onceness {\n }\n \n /// Represents the type of a closure\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<Lifetime>,\n     pub fn_style: FnStyle,\n@@ -826,20 +826,20 @@ pub struct ClosureTy {\n     pub bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: FnStyle,\n     pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct UnboxedFnTy {\n     pub decl: P<FnDecl>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Ty_ {\n     TyNil,\n     TyBot, /* bottom type */\n@@ -863,13 +863,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n@@ -882,7 +882,7 @@ pub struct InlineAsm {\n }\n \n /// represents an argument in a function header\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: Gc<Pat>,\n@@ -910,7 +910,7 @@ impl Arg {\n }\n \n /// represents the header (not the body) of a function declaration\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: P<Ty>,\n@@ -935,7 +935,7 @@ impl fmt::Show for FnStyle {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum RetStyle {\n     /// Functions with return type ! that always\n     /// raise an error or exit (i.e. never return to the caller)\n@@ -945,7 +945,7 @@ pub enum RetStyle {\n }\n \n /// Represents the kind of 'self' associated with a method\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ExplicitSelf_ {\n     /// No self\n     SelfStatic,\n@@ -959,23 +959,23 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Method {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub node: Method_\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Method_ {\n     /// Represents a method declaration\n     MethDecl(Ident, Generics, ExplicitSelf, FnStyle, P<FnDecl>, P<Block>, Visibility),\n     /// Represents a macro in method position\n     MethMac(Mac),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -985,31 +985,31 @@ pub struct Mod {\n     pub items: Vec<Gc<Item>>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n     pub items: Vec<Gc<ForeignItem>>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct VariantArg {\n     pub ty: P<Ty>,\n     pub id: NodeId,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n     StructVariantKind(Gc<StructDef>),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Variant_ {\n     pub name: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1021,7 +1021,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct PathListIdent_ {\n     pub name: Ident,\n     pub id: NodeId,\n@@ -1031,7 +1031,7 @@ pub type PathListIdent = Spanned<PathListIdent_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ViewPath_ {\n \n     /// `quux = foo::bar::baz`\n@@ -1048,15 +1048,15 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ViewItem {\n     pub node: ViewItem_,\n     pub attrs: Vec<Attribute>,\n     pub vis: Visibility,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ViewItem_ {\n     /// Ident: name used to refer to this crate in the code\n     /// optional (InternedString,StrStyle): if present, this is a location\n@@ -1072,17 +1072,17 @@ pub type Attribute = Spanned<Attribute_>;\n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct AttrId(pub uint);\n \n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n@@ -1096,13 +1096,13 @@ pub struct Attribute_ {\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n /// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n /// same as the impl's node id).\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash,   Show)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Visibility {\n     Public,\n     Inherited,\n@@ -1117,7 +1117,7 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n@@ -1136,7 +1136,7 @@ impl StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     /// Element of a tuple-like struct\n@@ -1152,7 +1152,7 @@ impl StructFieldKind {\n     }\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct StructDef {\n     /// Fields, not including ctor\n     pub fields: Vec<StructField>,\n@@ -1169,7 +1169,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1179,7 +1179,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, Gc<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n@@ -1202,7 +1202,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1212,7 +1212,7 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1221,7 +1221,7 @@ pub enum ForeignItem_ {\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedItem {\n     IIItem(Gc<Item>),\n     IIMethod(DefId /* impl id */, bool /* is provided */, Gc<Method>),"}, {"sha": "7eb6709919aaf082198e5a3d1778d75b0eb9ea89", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=69ffcdcccfec6e2af67c3b0b1e2ebef2d33847bd", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt;\n use std::default::Default;\n use std::hash;\n use std::{mem, raw, ptr, slice};\n@@ -22,6 +23,17 @@ pub struct OwnedSlice<T> {\n     len: uint,\n }\n \n+impl<T:fmt::Show> fmt::Show for OwnedSlice<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(\"OwnedSlice {{\".fmt(fmt));\n+        for i in self.iter() {\n+            try!(i.fmt(fmt));\n+        }\n+        try!(\"}}\".fmt(fmt));\n+        Ok(())\n+    }\n+}\n+\n #[unsafe_destructor]\n impl<T> Drop for OwnedSlice<T> {\n     fn drop(&mut self) {"}]}