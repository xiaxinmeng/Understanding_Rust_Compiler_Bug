{"sha": "873bf46dc1677f24724cf2009703cf5c2a69a07a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3M2JmNDZkYzE2NzdmMjQ3MjRjZjIwMDk3MDNjZjVjMmE2OWEwN2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-29T09:50:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-29T09:50:12Z"}, "message": "Rollup merge of #70101 - tmiasko:intrinsics-copy, r=eddyb\n\nAdd copy bound to atomic & numeric intrinsics", "tree": {"sha": "e272f54887c1901a3f21c8cf3072fdccdda65945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e272f54887c1901a3f21c8cf3072fdccdda65945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/873bf46dc1677f24724cf2009703cf5c2a69a07a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJegG9UCRBK7hj4Ov3rIwAAdHIIAGJXVJBnvuSLg6n+0SVPRy6s\niIUR3tN8Lu0BV+H5B+R5cbEJzG3rJSMloAM+J4+/FKa/ek2NjSNRk2Gva6oZnmeG\nPvxi7Uv+xmzd7DK2InUuFWQRKxvy4HUilakqzYYzFaeqy9sLd7l6HLDAzB3ViQQg\nUAtcPPlCSso4iiTi/WXk9McLlHlcjrG0/pn/zvaXMwJXjNF8xucG24Mq6fzgUvtu\ntzYE15M4l9Her0u8Npb+v+0gudaGqlbuwwI3P1CrkrjOlgUSzTZ6H2cfcoYsEnFQ\nq5bJ8cf2zZ89epl7XfcY8OtmV+oqhSbIYUzA3G6XND7TFYcFXL6GngUraEeiHh0=\n=GRZz\n-----END PGP SIGNATURE-----\n", "payload": "tree e272f54887c1901a3f21c8cf3072fdccdda65945\nparent c51fcb5f3847cc70de316db0b4c46f23fc8d0d35\nparent ec853b6b60e9cbe7b07458f9c33f0bb3f52e0776\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585475412 +0200\ncommitter GitHub <noreply@github.com> 1585475412 +0200\n\nRollup merge of #70101 - tmiasko:intrinsics-copy, r=eddyb\n\nAdd copy bound to atomic & numeric intrinsics\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/873bf46dc1677f24724cf2009703cf5c2a69a07a", "html_url": "https://github.com/rust-lang/rust/commit/873bf46dc1677f24724cf2009703cf5c2a69a07a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/873bf46dc1677f24724cf2009703cf5c2a69a07a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c51fcb5f3847cc70de316db0b4c46f23fc8d0d35", "url": "https://api.github.com/repos/rust-lang/rust/commits/c51fcb5f3847cc70de316db0b4c46f23fc8d0d35", "html_url": "https://github.com/rust-lang/rust/commit/c51fcb5f3847cc70de316db0b4c46f23fc8d0d35"}, {"sha": "ec853b6b60e9cbe7b07458f9c33f0bb3f52e0776", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec853b6b60e9cbe7b07458f9c33f0bb3f52e0776", "html_url": "https://github.com/rust-lang/rust/commit/ec853b6b60e9cbe7b07458f9c33f0bb3f52e0776"}], "stats": {"total": 224, "additions": 112, "deletions": 112}, "files": [{"sha": "0c956104221ebfce973188cc9845a22cfd72bbb0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/873bf46dc1677f24724cf2009703cf5c2a69a07a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/873bf46dc1677f24724cf2009703cf5c2a69a07a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=873bf46dc1677f24724cf2009703cf5c2a69a07a", "patch": "@@ -76,7 +76,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -86,7 +86,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -98,7 +98,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -110,7 +110,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -120,7 +120,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -132,7 +132,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -144,7 +144,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -156,7 +156,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -168,7 +168,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n@@ -179,7 +179,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -189,7 +189,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -201,7 +201,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -213,7 +213,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -223,7 +223,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -235,7 +235,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -247,7 +247,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -259,7 +259,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -271,7 +271,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n@@ -280,24 +280,24 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n-    pub fn atomic_load<T>(src: *const T) -> T;\n+    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n-    pub fn atomic_load_acq<T>(src: *const T) -> T;\n+    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n-    pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n-    pub fn atomic_load_unordered<T>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n@@ -306,24 +306,24 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n-    pub fn atomic_store<T>(dst: *mut T, val: T);\n+    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n-    pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n-    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);\n-    pub fn atomic_store_unordered<T>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n@@ -332,39 +332,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n@@ -373,39 +373,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n@@ -414,39 +414,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n@@ -455,39 +455,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n@@ -496,39 +496,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n@@ -537,39 +537,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n@@ -578,39 +578,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n@@ -619,39 +619,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n@@ -660,39 +660,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n@@ -701,39 +701,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n@@ -742,39 +742,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -1561,36 +1561,36 @@ extern \"rust-intrinsic\" {\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fadd_fast<T>(a: T, b: T) -> T;\n+    pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fsub_fast<T>(a: T, b: T) -> T;\n+    pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fmul_fast<T>(a: T, b: T) -> T;\n+    pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fdiv_fast<T>(a: T, b: T) -> T;\n+    pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn frem_fast<T>(a: T, b: T) -> T;\n+    pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     /// This is under stabilization at <https://github.com/rust-lang/rust/issues/67058>\n-    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n+    pub fn float_to_int_approx_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `count_ones` method. For example,\n     /// [`std::u32::count_ones`](../../std/primitive.u32.html#method.count_ones)\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n-    pub fn ctpop<T>(x: T) -> T;\n+    pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n@@ -1622,7 +1622,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 16);\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n-    pub fn ctlz<T>(x: T) -> T;\n+    pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n@@ -1639,7 +1639,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 3);\n     /// ```\n     #[rustc_const_unstable(feature = \"constctlz\", issue = \"none\")]\n-    pub fn ctlz_nonzero<T>(x: T) -> T;\n+    pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n     ///\n@@ -1671,7 +1671,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 16);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n-    pub fn cttz<T>(x: T) -> T;\n+    pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n@@ -1688,51 +1688,51 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n     #[rustc_const_unstable(feature = \"const_cttz\", issue = \"none\")]\n-    pub fn cttz_nonzero<T>(x: T) -> T;\n+    pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `swap_bytes` method. For example,\n     /// [`std::u32::swap_bytes`](../../std/primitive.u32.html#method.swap_bytes)\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n-    pub fn bswap<T>(x: T) -> T;\n+    pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `reverse_bits` method. For example,\n     /// [`std::u32::reverse_bits`](../../std/primitive.u32.html#method.reverse_bits)\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n-    pub fn bitreverse<T>(x: T) -> T;\n+    pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n+    pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n+    pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n+    pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n-    pub fn exact_div<T>(x: T, y: T) -> T;\n+    pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n@@ -1741,15 +1741,15 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_div` method. For example,\n     /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_div<T>(x: T, y: T) -> T;\n+    pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n     /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_rem<T>(x: T, y: T) -> T;\n+    pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n@@ -1758,83 +1758,83 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shl` method. For example,\n     /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n-    pub fn unchecked_shl<T>(x: T, y: T) -> T;\n+    pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_shr` method. For example,\n     /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n-    pub fn unchecked_shr<T>(x: T, y: T) -> T;\n+    pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_add<T>(x: T, y: T) -> T;\n+    pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_sub<T>(x: T, y: T) -> T;\n+    pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_mul<T>(x: T, y: T) -> T;\n+    pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n-    pub fn rotate_left<T>(x: T, y: T) -> T;\n+    pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n-    pub fn rotate_right<T>(x: T, y: T) -> T;\n+    pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_add` method. For example,\n     /// [`std::u32::checked_add`](../../std/primitive.u32.html#method.checked_add)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    pub fn wrapping_add<T>(a: T, b: T) -> T;\n+    pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_sub` method. For example,\n     /// [`std::u32::checked_sub`](../../std/primitive.u32.html#method.checked_sub)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    pub fn wrapping_sub<T>(a: T, b: T) -> T;\n+    pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_mul` method. For example,\n     /// [`std::u32::checked_mul`](../../std/primitive.u32.html#method.checked_mul)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    pub fn wrapping_mul<T>(a: T, b: T) -> T;\n+    pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n-    pub fn saturating_add<T>(a: T, b: T) -> T;\n+    pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n-    pub fn saturating_sub<T>(a: T, b: T) -> T;\n+    pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0."}]}