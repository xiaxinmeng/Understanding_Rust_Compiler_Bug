{"sha": "38abca8c2d7de08861cd61bc439efdb7cf4de398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YWJjYThjMmQ3ZGUwODg2MWNkNjFiYzQzOWVmZGI3Y2Y0ZGUzOTg=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@commure.com", "date": "2018-07-23T05:40:24Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@commure.com", "date": "2018-07-23T06:09:00Z"}, "message": "Point at internal span in format string", "tree": {"sha": "0e252e1fa78c65e3977e8328f5d0ae687c3cb1ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e252e1fa78c65e3977e8328f5d0ae687c3cb1ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38abca8c2d7de08861cd61bc439efdb7cf4de398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38abca8c2d7de08861cd61bc439efdb7cf4de398", "html_url": "https://github.com/rust-lang/rust/commit/38abca8c2d7de08861cd61bc439efdb7cf4de398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38abca8c2d7de08861cd61bc439efdb7cf4de398/comments", "author": null, "committer": null, "parents": [{"sha": "d3b3bc57670ab91a53b2100cf3dfe78947bfe077", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b3bc57670ab91a53b2100cf3dfe78947bfe077", "html_url": "https://github.com/rust-lang/rust/commit/d3b3bc57670ab91a53b2100cf3dfe78947bfe077"}], "stats": {"total": 242, "additions": 224, "deletions": 18}, "files": [{"sha": "f6dcebf8c50f56337718ecb6b62a80b6773e19b5", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=38abca8c2d7de08861cd61bc439efdb7cf4de398", "patch": "@@ -154,6 +154,7 @@ pub struct Parser<'a> {\n     style: Option<usize>,\n     /// How many newlines have been seen in the string so far, to adjust the error spans\n     seen_newlines: usize,\n+    pub arg_places: Vec<(usize, usize)>,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -168,9 +169,13 @@ impl<'a> Iterator for Parser<'a> {\n                     if self.consume('{') {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n-                        let ret = Some(NextArgument(self.argument()));\n-                        self.must_consume('}');\n-                        ret\n+                        let mut arg = self.argument();\n+                        if let Some(arg_pos) = self.must_consume('}').map(|end| {\n+                            (pos + raw + 1, end + raw + 2)\n+                        }) {\n+                            self.arg_places.push(arg_pos);\n+                        }\n+                        Some(NextArgument(arg))\n                     }\n                 }\n                 '}' => {\n@@ -211,6 +216,7 @@ impl<'a> Parser<'a> {\n             curarg: 0,\n             style,\n             seen_newlines: 0,\n+            arg_places: vec![],\n         }\n     }\n \n@@ -271,20 +277,22 @@ impl<'a> Parser<'a> {\n \n     /// Forces consumption of the specified character. If the character is not\n     /// found, an error is emitted.\n-    fn must_consume(&mut self, c: char) {\n+    fn must_consume(&mut self, c: char) -> Option<usize> {\n         self.ws();\n         let raw = self.style.unwrap_or(0);\n \n         let padding = raw + self.seen_newlines;\n         if let Some(&(pos, maybe)) = self.cur.peek() {\n             if c == maybe {\n                 self.cur.next();\n+                Some(pos)\n             } else {\n                 let pos = pos + padding + 1;\n                 self.err(format!(\"expected `{:?}`, found `{:?}`\", c, maybe),\n                          format!(\"expected `{}`\", c),\n                          pos,\n                          pos);\n+                None\n             }\n         } else {\n             let msg = format!(\"expected `{:?}` but string was terminated\", c);\n@@ -302,6 +310,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.err(msg, format!(\"expected `{:?}`\", c), pos, pos);\n             }\n+            None\n         }\n     }\n "}, {"sha": "4700f814e58538f8c5181b1f03a0adbc289119ab", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=38abca8c2d7de08861cd61bc439efdb7cf4de398", "patch": "@@ -21,7 +21,7 @@ use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use syntax::tokenstream;\n \n use std::collections::{HashMap, HashSet};\n@@ -264,28 +264,38 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// errors for the case where all arguments are positional and for when\n     /// there are named arguments or numbered positional arguments in the\n     /// format string.\n-    fn report_invalid_references(&self, numbered_position_args: bool) {\n+    fn report_invalid_references(&self, numbered_position_args: bool, arg_places: &[(usize, usize)]) {\n         let mut e;\n-        let mut refs: Vec<String> = self.invalid_refs\n-                                        .iter()\n-                                        .map(|r| r.to_string())\n-                                        .collect();\n+        let sps = arg_places.iter()\n+            .map(|&(start, end)| self.fmtsp.from_inner_byte_pos(start, end))\n+            .collect::<Vec<_>>();\n+        let sp = MultiSpan::from_spans(sps);\n+        let mut refs: Vec<_> = self.invalid_refs\n+            .iter()\n+            .map(|r| r.to_string())\n+            .collect();\n \n         if self.names.is_empty() && !numbered_position_args {\n-            e = self.ecx.mut_span_err(self.fmtsp,\n+            e = self.ecx.mut_span_err(sp,\n                 &format!(\"{} positional argument{} in format string, but {}\",\n                          self.pieces.len(),\n                          if self.pieces.len() > 1 { \"s\" } else { \"\" },\n                          self.describe_num_args()));\n         } else {\n             let arg_list = match refs.len() {\n-                1 => format!(\"argument {}\", refs.pop().unwrap()),\n-                _ => format!(\"arguments {head} and {tail}\",\n-                             tail=refs.pop().unwrap(),\n+                1 => {\n+                    let reg = refs.pop().unwrap();\n+                    format!(\"argument {}\", reg)\n+                },\n+                _ => {\n+                    let reg = refs.pop().unwrap();\n+                    format!(\"arguments {head} and {tail}\",\n+                             tail=reg,\n                              head=refs.join(\", \"))\n+                }\n             };\n \n-            e = self.ecx.mut_span_err(self.fmtsp,\n+            e = self.ecx.mut_span_err(sp,\n                 &format!(\"invalid reference to positional {} ({})\",\n                         arg_list,\n                         self.describe_num_args()));\n@@ -835,7 +845,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     }\n \n     if cx.invalid_refs.len() >= 1 {\n-        cx.report_invalid_references(numbered_position_args);\n+        cx.report_invalid_references(numbered_position_args, &parser.arg_places);\n     }\n \n     // Make sure that all arguments were used and all arguments have types."}, {"sha": "afe9bc152a36ce5321a5151388be59e7e628b8ff", "filename": "src/test/ui/ifmt-bad-arg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Ftest%2Fui%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Ftest%2Fui%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt-bad-arg.rs?ref=38abca8c2d7de08861cd61bc439efdb7cf4de398", "previous_filename": "src/test/compile-fail/ifmt-bad-arg.rs"}, {"sha": "4ad3c2b65504771f4392e482ce78e439e0e46bb4", "filename": "src/test/ui/ifmt-bad-arg.stderr", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr?ref=38abca8c2d7de08861cd61bc439efdb7cf4de398", "patch": "@@ -0,0 +1,187 @@\n+error: 1 positional argument in format string, but no arguments were given\n+  --> $DIR/ifmt-bad-arg.rs:16:14\n+   |\n+LL |     format!(\"{}\");\n+   |              ^^\n+\n+error: invalid reference to positional argument 1 (there is 1 argument)\n+  --> $DIR/ifmt-bad-arg.rs:19:14\n+   |\n+LL |     format!(\"{1}\", 1);\n+   |              ^^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:19:20\n+   |\n+LL |     format!(\"{1}\", 1);\n+   |                    ^\n+\n+error: 2 positional arguments in format string, but no arguments were given\n+  --> $DIR/ifmt-bad-arg.rs:23:14\n+   |\n+LL |     format!(\"{} {}\");\n+   |              ^^ ^^\n+\n+error: invalid reference to positional argument 1 (there is 1 argument)\n+  --> $DIR/ifmt-bad-arg.rs:26:14\n+   |\n+LL |     format!(\"{0} {1}\", 1);\n+   |              ^^^ ^^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: invalid reference to positional argument 2 (there are 2 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:29:14\n+   |\n+LL |     format!(\"{0} {1} {2}\", 1, 2);\n+   |              ^^^ ^^^ ^^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: invalid reference to positional argument 2 (there are 2 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:32:14\n+   |\n+LL |     format!(\"{} {value} {} {}\", 1, value=2);\n+   |              ^^ ^^^^^^^ ^^ ^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: invalid reference to positional arguments 3, 4 and 5 (there are 3 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:34:14\n+   |\n+LL |     format!(\"{name} {value} {} {} {} {} {} {}\", 0, name=1, value=2);\n+   |              ^^^^^^ ^^^^^^^ ^^ ^^ ^^ ^^ ^^ ^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: there is no argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:37:13\n+   |\n+LL |     format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: there is no argument named `bar`\n+  --> $DIR/ifmt-bad-arg.rs:37:13\n+   |\n+LL |     format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: there is no argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:41:13\n+   |\n+LL |     format!(\"{foo}\");                //~ ERROR: no argument named `foo`\n+   |             ^^^^^^^\n+\n+error: multiple unused formatting arguments\n+  --> $DIR/ifmt-bad-arg.rs:42:17\n+   |\n+LL |     format!(\"\", 1, 2);               //~ ERROR: multiple unused formatting arguments\n+   |             --  ^  ^\n+   |             |\n+   |             multiple missing formatting arguments\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:43:22\n+   |\n+LL |     format!(\"{}\", 1, 2);             //~ ERROR: argument never used\n+   |                      ^\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:44:20\n+   |\n+LL |     format!(\"{1}\", 1, 2);            //~ ERROR: argument never used\n+   |                    ^\n+\n+error: named argument never used\n+  --> $DIR/ifmt-bad-arg.rs:45:26\n+   |\n+LL |     format!(\"{}\", 1, foo=2);         //~ ERROR: named argument never used\n+   |                          ^\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:46:22\n+   |\n+LL |     format!(\"{foo}\", 1, foo=2);      //~ ERROR: argument never used\n+   |                      ^\n+\n+error: named argument never used\n+  --> $DIR/ifmt-bad-arg.rs:47:21\n+   |\n+LL |     format!(\"\", foo=2);              //~ ERROR: named argument never used\n+   |                     ^\n+\n+error: multiple unused formatting arguments\n+  --> $DIR/ifmt-bad-arg.rs:48:32\n+   |\n+LL |     format!(\"{} {}\", 1, 2, foo=1, bar=2);  //~ ERROR: multiple unused formatting arguments\n+   |             -------            ^      ^\n+   |             |\n+   |             multiple missing formatting arguments\n+\n+error: duplicate argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:50:33\n+   |\n+LL |     format!(\"{foo}\", foo=1, foo=2);  //~ ERROR: duplicate argument\n+   |                                 ^\n+   |\n+note: previously here\n+  --> $DIR/ifmt-bad-arg.rs:50:26\n+   |\n+LL |     format!(\"{foo}\", foo=1, foo=2);  //~ ERROR: duplicate argument\n+   |                          ^\n+\n+error: expected ident, positional arguments cannot follow named arguments\n+  --> $DIR/ifmt-bad-arg.rs:51:24\n+   |\n+LL |     format!(\"\", foo=1, 2);           //~ ERROR: positional arguments cannot follow\n+   |                        ^\n+\n+error: there is no argument named `valueb`\n+  --> $DIR/ifmt-bad-arg.rs:55:13\n+   |\n+LL |     format!(\"{valuea} {valueb}\", valuea=5, valuec=7);\n+   |             ^^^^^^^^^^^^^^^^^^^\n+\n+error: named argument never used\n+  --> $DIR/ifmt-bad-arg.rs:55:51\n+   |\n+LL |     format!(\"{valuea} {valueb}\", valuea=5, valuec=7);\n+   |                                                   ^\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/ifmt-bad-arg.rs:61:15\n+   |\n+LL |     format!(\"{\"); //~ ERROR: expected `'}'` but string was terminated\n+   |               ^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/ifmt-bad-arg.rs:63:18\n+   |\n+LL |     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n+   |                  ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/ifmt-bad-arg.rs:64:18\n+   |\n+LL |     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n+   |                  ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:66:27\n+   |\n+LL |     format!(\"foo %s baz\", \"bar\"); //~ ERROR: argument never used\n+   |                           ^^^^^\n+   |\n+   = help: `%s` should be written as `{}`\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+\n+error: aborting due to 26 previous errors\n+"}, {"sha": "f0ca576f652eba28bafb7b0acfad2668f432856d", "filename": "src/test/ui/macros/macro-backtrace-println.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38abca8c2d7de08861cd61bc439efdb7cf4de398/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr?ref=38abca8c2d7de08861cd61bc439efdb7cf4de398", "patch": "@@ -1,8 +1,8 @@\n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-backtrace-println.rs:24:30\n+  --> $DIR/macro-backtrace-println.rs:24:31\n    |\n LL |     ($fmt:expr) => (myprint!(concat!($fmt, \"/n\"))); //~ ERROR no arguments were given\n-   |                              ^^^^^^^^^^^^^^^^^^^\n+   |                               ^^\n ...\n LL |     myprintln!(\"{}\");\n    |     ----------------- in this macro invocation"}]}