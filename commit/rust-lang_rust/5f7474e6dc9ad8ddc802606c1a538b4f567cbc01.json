{"sha": "5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "node_id": "C_kwDOAAsO6NoAKDVmNzQ3NGU2ZGM5YWQ4ZGRjODAyNjA2YzFhNTM4YjRmNTY3Y2JjMDE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-07T04:01:06Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-11T23:38:48Z"}, "message": "Address comments", "tree": {"sha": "7bca31dbd341ab7191f30656a27b2be4192a443e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bca31dbd341ab7191f30656a27b2be4192a443e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "html_url": "https://github.com/rust-lang/rust/commit/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38d7e2734f3f005aa12a64422888e2cc4da4b4c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/38d7e2734f3f005aa12a64422888e2cc4da4b4c8", "html_url": "https://github.com/rust-lang/rust/commit/38d7e2734f3f005aa12a64422888e2cc4da4b4c8"}], "stats": {"total": 216, "additions": 131, "deletions": 85}, "files": [{"sha": "4244e67482cad5a0311cd75ec78bb0bdf54f9e3d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -1378,7 +1378,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> =\n             self.lower_generic_params_mut(&generics.params).collect();\n         let has_where_clause_predicates = !generics.where_clause.predicates.is_empty();\n-        let has_where_clause_token = generics.where_clause.has_where_token;\n         let where_clause_span = self.lower_span(generics.where_clause.span);\n         let span = self.lower_span(generics.span);\n         let res = f(self);\n@@ -1397,7 +1396,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             params: self.arena.alloc_from_iter(params),\n             predicates: self.arena.alloc_from_iter(predicates),\n             has_where_clause_predicates,\n-            has_where_clause_token,\n             where_clause_span,\n             span,\n         });"}, {"sha": "6fe95a21fa42af80ef5173f6468b49524c241bd7", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -1316,7 +1316,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     params: lifetime_defs,\n                     predicates: &[],\n                     has_where_clause_predicates: false,\n-                    has_where_clause_token: false,\n                     where_clause_span: lctx.lower_span(span),\n                     span: lctx.lower_span(span),\n                 }),\n@@ -1639,7 +1638,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     params: generic_params,\n                     predicates: &[],\n                     has_where_clause_predicates: false,\n-                    has_where_clause_token: false,\n                     where_clause_span: this.lower_span(span),\n                     span: this.lower_span(span),\n                 }),"}, {"sha": "bd5973f31cfae769b9aa09591e0c822ba884a999", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -536,7 +536,6 @@ pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub predicates: &'hir [WherePredicate<'hir>],\n     pub has_where_clause_predicates: bool,\n-    pub has_where_clause_token: bool,\n     pub where_clause_span: Span,\n     pub span: Span,\n }\n@@ -547,7 +546,6 @@ impl<'hir> Generics<'hir> {\n             params: &[],\n             predicates: &[],\n             has_where_clause_predicates: false,\n-            has_where_clause_token: false,\n             where_clause_span: DUMMY_SP,\n             span: DUMMY_SP,\n         };\n@@ -583,10 +581,6 @@ impl<'hir> Generics<'hir> {\n         }\n     }\n \n-    pub fn where_clause_span(&self) -> Option<Span> {\n-        if self.predicates.is_empty() { None } else { Some(self.where_clause_span) }\n-    }\n-\n     /// `Span` where further predicates would be suggested, accounting for trailing commas, like\n     ///  in `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n     pub fn tail_span_for_predicate_suggestion(&self) -> Span {\n@@ -607,10 +601,11 @@ impl<'hir> Generics<'hir> {\n     pub fn add_where_or_trailing_comma(&self) -> &'static str {\n         if self.has_where_clause_predicates {\n             \",\"\n-        } else if self.has_where_clause_token {\n-            \"\"\n-        } else {\n+        } else if self.where_clause_span.is_empty() {\n             \" where\"\n+        } else {\n+            // No where clause predicates, but we have `where` token\n+            \"\"\n         }\n     }\n "}, {"sha": "205ca72aae8a86304dadcf4afcd3b7c843379ed4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -2295,9 +2295,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             // (including the `where`)\n             if hir_generics.has_where_clause_predicates && dropped_predicate_count == num_predicates\n             {\n-                let where_span = hir_generics\n-                    .where_clause_span()\n-                    .expect(\"span of (nonempty) where clause should exist\");\n+                let where_span = hir_generics.where_clause_span;\n                 // Extend the where clause back to the closing `>` of the\n                 // generics, except for tuple struct, which have the `where`\n                 // after the fields of the struct."}, {"sha": "1acded8c6e499e7001d23b3d14d4ed055587c5ee", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -76,21 +76,21 @@ impl<'tcx> Ty<'tcx> {\n }\n \n pub trait IsSuggestable<'tcx> {\n+    /// Whether this makes sense to suggest in a diagnostic.\n+    ///\n+    /// We filter out certain types and constants since they don't provide\n+    /// meaningful rendered suggestions when pretty-printed. We leave some\n+    /// nonsense, such as region vars, since those render as `'_` and are\n+    /// usually okay to reinterpret as elided lifetimes.\n     fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool;\n-\n-    fn is_suggestable_modulo_impl_trait(self, tcx: TyCtxt<'tcx>, bound_str: &str) -> bool;\n }\n \n impl<'tcx, T> IsSuggestable<'tcx> for T\n where\n     T: TypeFoldable<'tcx>,\n {\n     fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool {\n-        self.visit_with(&mut IsSuggestableVisitor { tcx, bound_str: None }).is_continue()\n-    }\n-\n-    fn is_suggestable_modulo_impl_trait(self, tcx: TyCtxt<'tcx>, bound_str: &str) -> bool {\n-        self.visit_with(&mut IsSuggestableVisitor { tcx, bound_str: Some(bound_str) }).is_continue()\n+        self.visit_with(&mut IsSuggestableVisitor { tcx }).is_continue()\n     }\n }\n \n@@ -119,7 +119,7 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n         &format!(\n             \"consider {} `where` clause, but there might be an alternative better way to express \\\n              this requirement\",\n-            if generics.has_where_clause_token { \"extending the\" } else { \"introducing a\" },\n+            if generics.where_clause_span.is_empty() { \"introducing a\" } else { \"extending the\" },\n         ),\n         format!(\"{} {}: {}\", generics.add_where_or_trailing_comma(), param_name, constraint),\n         Applicability::MaybeIncorrect,\n@@ -417,12 +417,11 @@ impl<'v> hir::intravisit::Visitor<'v> for StaticLifetimeVisitor<'v> {\n     }\n }\n \n-pub struct IsSuggestableVisitor<'tcx, 's> {\n+pub struct IsSuggestableVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    bound_str: Option<&'s str>,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx, '_> {\n+impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n     type BreakTy = ();\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -462,12 +461,13 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx, '_> {\n             }\n \n             Param(param) => {\n-                if let Some(found_bound_str) =\n-                    param.name.as_str().strip_prefix(\"impl \").map(|s| s.trim_start())\n-                {\n-                    if self.bound_str.map_or(true, |bound_str| bound_str != found_bound_str) {\n-                        return ControlFlow::Break(());\n-                    }\n+                // FIXME: It would be nice to make this not use string manipulation,\n+                // but it's pretty hard to do this, since `ty::ParamTy` is missing\n+                // sufficient info to determine if it is synthetic, and we don't\n+                // always have a convenient way of getting `ty::Generics` at the call\n+                // sites we invoke `IsSuggestable::is_suggestable`.\n+                if param.name.as_str().starts_with(\"impl \") {\n+                    return ControlFlow::Break(());\n                 }\n             }\n "}, {"sha": "84547dca45363c696552f58fb06927758959744d", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -39,6 +39,13 @@ impl GenericParamDefKind {\n             GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => true,\n         }\n     }\n+\n+    pub fn is_synthetic(&self) -> bool {\n+        match self {\n+            GenericParamDefKind::Type { synthetic, .. } => *synthetic,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "353547a2fb8cb59b39a7d27a1690de6fcb56a2c9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 95, "deletions": 48, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -7,6 +7,7 @@ use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::normalize_to;\n \n+use hir::HirId;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n@@ -23,7 +24,7 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ToPredicate, Ty, TyCtxt, TypeFoldable,\n+    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n@@ -331,7 +332,8 @@ fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, St\n /// param for cleaner code.\n fn suggest_restriction<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    generics: &hir::Generics<'tcx>,\n+    hir_id: HirId,\n+    hir_generics: &hir::Generics<'tcx>,\n     msg: &str,\n     err: &mut Diagnostic,\n     fn_sig: Option<&hir::FnSig<'_>>,\n@@ -344,24 +346,37 @@ fn suggest_restriction<'tcx>(\n     //              &Ident\n     super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n ) {\n-    if generics.where_clause_span.from_expansion()\n-        || generics.where_clause_span.desugaring_kind().is_some()\n+    if hir_generics.where_clause_span.from_expansion()\n+        || hir_generics.where_clause_span.desugaring_kind().is_some()\n     {\n         return;\n     }\n+    let Some(item_id) = hir_id.as_owner() else { return; };\n+    let generics = tcx.generics_of(item_id);\n     // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n-    if let Some((bound_str, fn_sig)) =\n+    if let Some((param, bound_str, fn_sig)) =\n         fn_sig.zip(projection).and_then(|(sig, p)| match p.self_ty().kind() {\n             // Shenanigans to get the `Trait` from the `impl Trait`.\n             ty::Param(param) => {\n-                // `fn foo(t: impl Trait)`\n-                //                 ^^^^^ get this string\n-                param.name.as_str().strip_prefix(\"impl \").map(|s| (s.trim_start().to_string(), sig))\n+                let param_def = generics.type_param(param, tcx);\n+                if param_def.kind.is_synthetic() {\n+                    let bound_str =\n+                        param_def.name.as_str().strip_prefix(\"impl \")?.trim_start().to_string();\n+                    return Some((param_def, bound_str, sig));\n+                }\n+                None\n             }\n             _ => None,\n         })\n     {\n-        if !trait_pred.is_suggestable_modulo_impl_trait(tcx, &bound_str) {\n+        let type_param_name = hir_generics.params.next_type_param_name(Some(&bound_str));\n+        let trait_pred = trait_pred.fold_with(&mut ReplaceImplTraitFolder {\n+            tcx,\n+            param,\n+            replace_ty: ty::ParamTy::new(generics.count() as u32, Symbol::intern(&type_param_name))\n+                .to_ty(tcx),\n+        });\n+        if !trait_pred.is_suggestable(tcx) {\n             return;\n         }\n         // We know we have an `impl Trait` that doesn't satisfy a required projection.\n@@ -373,52 +388,21 @@ fn suggest_restriction<'tcx>(\n         // where `T: Trait`.\n         let mut ty_spans = vec![];\n         for input in fn_sig.decl.inputs {\n-            struct ReplaceImplTraitVisitor<'a> {\n-                ty_spans: &'a mut Vec<Span>,\n-                bound_str: &'a str,\n-            }\n-            impl<'a, 'hir> hir::intravisit::Visitor<'hir> for ReplaceImplTraitVisitor<'a> {\n-                fn visit_ty(&mut self, t: &'hir hir::Ty<'hir>) {\n-                    if let hir::TyKind::Path(hir::QPath::Resolved(\n-                        None,\n-                        hir::Path { segments: [segment], .. },\n-                    )) = t.kind\n-                    {\n-                        if segment.ident.as_str().strip_prefix(\"impl \").map(|s| s.trim_start())\n-                            == Some(self.bound_str)\n-                        {\n-                            // `fn foo(t: impl Trait)`\n-                            //            ^^^^^^^^^^ get this to suggest `T` instead\n-\n-                            // There might be more than one `impl Trait`.\n-                            self.ty_spans.push(t.span);\n-                            return;\n-                        }\n-                    }\n-                    hir::intravisit::walk_ty(self, t);\n-                }\n-            }\n-            ReplaceImplTraitVisitor { ty_spans: &mut ty_spans, bound_str: &bound_str }\n+            ReplaceImplTraitVisitor { ty_spans: &mut ty_spans, param_did: param.def_id }\n                 .visit_ty(input);\n         }\n-\n-        let type_param_name = generics.params.next_type_param_name(Some(&bound_str));\n         // The type param `T: Trait` we will suggest to introduce.\n         let type_param = format!(\"{}: {}\", type_param_name, bound_str);\n \n-        // FIXME: modify the `trait_pred` instead of string shenanigans.\n-        // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-        let pred = trait_pred.to_predicate(tcx).to_string();\n-        let pred = pred.replace(&format!(\"impl {}\", bound_str), &type_param_name);\n         let mut sugg = vec![\n-            if let Some(span) = generics.span_for_param_suggestion() {\n+            if let Some(span) = hir_generics.span_for_param_suggestion() {\n                 (span, format!(\", {}\", type_param))\n             } else {\n-                (generics.span, format!(\"<{}>\", type_param))\n+                (hir_generics.span, format!(\"<{}>\", type_param))\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`\n-            predicate_constraint(generics, pred),\n+            predicate_constraint(hir_generics, trait_pred.to_predicate(tcx).to_string()),\n         ];\n         sugg.extend(ty_spans.into_iter().map(|s| (s, type_param_name.to_string())));\n \n@@ -436,13 +420,15 @@ fn suggest_restriction<'tcx>(\n         }\n         // Trivial case: `T` needs an extra bound: `T: Bound`.\n         let (sp, suggestion) = match (\n-            generics\n+            hir_generics\n                 .params\n                 .iter()\n                 .find(|p| !matches!(p.kind, hir::GenericParamKind::Type { synthetic: true, .. })),\n             super_traits,\n         ) {\n-            (_, None) => predicate_constraint(generics, trait_pred.to_predicate(tcx).to_string()),\n+            (_, None) => {\n+                predicate_constraint(hir_generics, trait_pred.to_predicate(tcx).to_string())\n+            }\n             (None, Some((ident, []))) => (\n                 ident.span.shrink_to_hi(),\n                 format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n@@ -452,7 +438,7 @@ fn suggest_restriction<'tcx>(\n                 format!(\" + {}\", trait_pred.print_modifiers_and_trait_path()),\n             ),\n             (Some(_), Some((_, []))) => (\n-                generics.span.shrink_to_hi(),\n+                hir_generics.span.shrink_to_hi(),\n                 format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n             ),\n         };\n@@ -496,6 +482,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n                         self.tcx,\n+                        hir_id,\n                         &generics,\n                         \"`Self`\",\n                         err,\n@@ -515,7 +502,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_pred, None,\n+                        self.tcx, hir_id, &generics, \"`Self`\", err, None, projection, trait_pred,\n+                        None,\n                     );\n                     return;\n                 }\n@@ -536,6 +524,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n                         self.tcx,\n+                        hir_id,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -555,6 +544,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n                         self.tcx,\n+                        hir_id,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -583,6 +573,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 | hir::Node::ImplItem(hir::ImplItem { generics, .. })\n                     if param_ty =>\n                 {\n+                    // We skip the 0'th subst (self) because we do not want\n+                    // to consider the predicate as not suggestible if the\n+                    // self type is an arg position `impl Trait` -- instead,\n+                    // we handle that by adding ` + Bound` below.\n+                    // FIXME(compiler-errors): It would be nice to do the same\n+                    // this that we do in `suggest_restriction` and pull the\n+                    // `impl Trait` into a new generic if it shows up somewhere\n+                    // else in the predicate.\n                     if !trait_pred.skip_binder().trait_ref.substs[1..]\n                         .iter()\n                         .all(|g| g.is_suggestable(self.tcx))\n@@ -2994,3 +2992,52 @@ fn suggest_trait_object_return_type_alternatives(\n         );\n     }\n }\n+\n+/// Collect the spans that we see the generic param `param_did`\n+struct ReplaceImplTraitVisitor<'a> {\n+    ty_spans: &'a mut Vec<Span>,\n+    param_did: DefId,\n+}\n+\n+impl<'a, 'hir> hir::intravisit::Visitor<'hir> for ReplaceImplTraitVisitor<'a> {\n+    fn visit_ty(&mut self, t: &'hir hir::Ty<'hir>) {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(\n+            None,\n+            hir::Path { res: hir::def::Res::Def(_, segment_did), .. },\n+        )) = t.kind\n+        {\n+            if self.param_did == *segment_did {\n+                // `fn foo(t: impl Trait)`\n+                //            ^^^^^^^^^^ get this to suggest `T` instead\n+\n+                // There might be more than one `impl Trait`.\n+                self.ty_spans.push(t.span);\n+                return;\n+            }\n+        }\n+\n+        hir::intravisit::walk_ty(self, t);\n+    }\n+}\n+\n+// Replace `param` with `replace_ty`\n+struct ReplaceImplTraitFolder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param: &'tcx ty::GenericParamDef,\n+    replace_ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReplaceImplTraitFolder<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Param(ty::ParamTy { index, .. }) = t.kind() {\n+            if self.param.index == *index {\n+                return self.replace_ty;\n+            }\n+        }\n+        t.super_fold_with(self)\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+}"}, {"sha": "d613edf0ab0c46a71947eb7456dcd7c9af26358e", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "patch": "@@ -211,7 +211,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n             Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                generics.where_clause_span()\n+                Some(generics.where_clause_span)\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n@@ -401,14 +401,17 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         .emit();\n                         error = true;\n                     }\n-                    if let Some(sp) = generics.where_clause_span() {\n+                    if generics.has_where_clause_predicates {\n                         struct_span_err!(\n                             tcx.sess,\n-                            sp,\n+                            generics.where_clause_span,\n                             E0647,\n                             \"start function is not allowed to have a `where` clause\"\n                         )\n-                        .span_label(sp, \"start function cannot have a `where` clause\")\n+                        .span_label(\n+                            generics.where_clause_span,\n+                            \"start function cannot have a `where` clause\",\n+                        )\n                         .emit();\n                         error = true;\n                     }"}]}