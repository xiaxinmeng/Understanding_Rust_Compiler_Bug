{"sha": "0f7770ae43dd0d97686eb85fccb38801ff30117b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNzc3MGFlNDNkZDBkOTc2ODZlYjg1ZmNjYjM4ODAxZmYzMDExN2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-10T12:47:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-10T12:47:23Z"}, "message": "Merge #5292\n\n5292: Goto type definition improvements r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "754d726b02595db4dcc4594712e30ca97a336988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/754d726b02595db4dcc4594712e30ca97a336988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f7770ae43dd0d97686eb85fccb38801ff30117b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfCGNbCRBK7hj4Ov3rIwAAdHIIAEov0ken5ZeRmEtALMtaVu7g\nxrVd9Q3dl0EBrhdKzx39LehI0d+belLTXuxp5AcQJjfJm6l9Em5xd19kRxDU4qtA\nI5XT2p5CKSEkjL/QGqeOjTDkB/AHrdLFVFLqMojEPmVvAVejsUTqS0sq8oSevdEW\nMECyjstgtunfX984KdOAgSdr5yy5R7Dy3gyqOTQBepWNBJDE0CJuU63n0EQjUEpT\nqdEL7aaNHwEnyiQ80e+6GGeiyEEI1BFdnQsX4gqakEV9C9Dm7EHxAtoFVDAM+uwr\n7hZNVFE57HGO8TpbfI3x4T/swnoEyEllW3CKP53YrbdxGkogoBzkSRiyy9UF1qI=\n=XZhZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 754d726b02595db4dcc4594712e30ca97a336988\nparent 5fa8f8e3761363098c80e11842682dffcee171d8\nparent 075380dd56439cdaf1967b7298e10b96b995fc07\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594385243 +0000\ncommitter GitHub <noreply@github.com> 1594385243 +0000\n\nMerge #5292\n\n5292: Goto type definition improvements r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7770ae43dd0d97686eb85fccb38801ff30117b", "html_url": "https://github.com/rust-lang/rust/commit/0f7770ae43dd0d97686eb85fccb38801ff30117b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f7770ae43dd0d97686eb85fccb38801ff30117b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fa8f8e3761363098c80e11842682dffcee171d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa8f8e3761363098c80e11842682dffcee171d8", "html_url": "https://github.com/rust-lang/rust/commit/5fa8f8e3761363098c80e11842682dffcee171d8"}, {"sha": "075380dd56439cdaf1967b7298e10b96b995fc07", "url": "https://api.github.com/repos/rust-lang/rust/commits/075380dd56439cdaf1967b7298e10b96b995fc07", "html_url": "https://github.com/rust-lang/rust/commit/075380dd56439cdaf1967b7298e10b96b995fc07"}], "stats": {"total": 176, "additions": 105, "deletions": 71}, "files": [{"sha": "0d877e44e97558cca015b47feaf29268203863f4", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=0f7770ae43dd0d97686eb85fccb38801ff30117b", "patch": "@@ -25,7 +25,7 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n     AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n-    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n+    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n use resolver::TypeNs;\n \n@@ -192,6 +192,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.type_of_pat(pat)\n     }\n \n+    pub fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n+        self.imp.type_of_self(param)\n+    }\n+\n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         self.imp.resolve_method_call(call)\n     }\n@@ -216,8 +220,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_path(path)\n     }\n \n-    pub fn resolve_variant(&self, record_lit: ast::RecordLit) -> Option<VariantId> {\n-        self.imp.resolve_variant(record_lit)\n+    pub fn resolve_variant(&self, record_lit: ast::RecordLit) -> Option<VariantDef> {\n+        self.imp.resolve_variant(record_lit).map(VariantDef::from)\n     }\n \n     pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n@@ -370,13 +374,17 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n-        self.analyze(expr.syntax()).type_of(self.db, &expr)\n+        self.analyze(expr.syntax()).type_of_expr(self.db, &expr)\n     }\n \n     pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n         self.analyze(pat.syntax()).type_of_pat(self.db, &pat)\n     }\n \n+    pub fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n+        self.analyze(param.syntax()).type_of_self(self.db, &param)\n+    }\n+\n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }"}, {"sha": "f74b78b23799c0526b71b64fe0588c97e1a6ffb6", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=0f7770ae43dd0d97686eb85fccb38801ff30117b", "patch": "@@ -115,7 +115,7 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub(crate) fn type_of(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n+    pub(crate) fn type_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = self.expr_id(db, expr)?;\n         let ty = self.infer.as_ref()?[expr_id].clone();\n         Type::new_with_resolver(db, &self.resolver, ty)\n@@ -127,6 +127,17 @@ impl SourceAnalyzer {\n         Type::new_with_resolver(db, &self.resolver, ty)\n     }\n \n+    pub(crate) fn type_of_self(\n+        &self,\n+        db: &dyn HirDatabase,\n+        param: &ast::SelfParam,\n+    ) -> Option<Type> {\n+        let src = InFile { file_id: self.file_id, value: param };\n+        let pat_id = self.body_source_map.as_ref()?.node_self_param(src)?;\n+        let ty = self.infer.as_ref()?[pat_id].clone();\n+        Type::new_with_resolver(db, &self.resolver, ty)\n+    }\n+\n     pub(crate) fn resolve_method_call(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "031ffe13f3b725d3e58ebf2ef9835d02f41e7cc6", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=0f7770ae43dd0d97686eb85fccb38801ff30117b", "patch": "@@ -302,6 +302,11 @@ impl BodySourceMap {\n         self.pat_map.get(&src).cloned()\n     }\n \n+    pub fn node_self_param(&self, node: InFile<&ast::SelfParam>) -> Option<PatId> {\n+        let src = node.map(|it| Either::Right(AstPtr::new(it)));\n+        self.pat_map.get(&src).cloned()\n+    }\n+\n     pub fn field_syntax(&self, expr: ExprId, field: usize) -> InFile<AstPtr<ast::RecordField>> {\n         self.field_map[&(expr, field)].clone()\n     }"}, {"sha": "8fc33d0311affff96c0dbe25cf614145e390b033", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=0f7770ae43dd0d97686eb85fccb38801ff30117b", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     ast::{self},\n     match_ast, AstNode,\n     SyntaxKind::*,\n-    SyntaxToken, TokenAtOffset,\n+    SyntaxToken, TokenAtOffset, T,\n };\n \n use crate::{\n@@ -32,9 +32,10 @@ pub(crate) fn goto_definition(\n     let file = sema.parse(position.file_id).syntax().clone();\n     let original_token = pick_best(file.token_at_offset(position.offset))?;\n     let token = sema.descend_into_macros(original_token.clone());\n+    let parent = token.parent();\n \n     let nav_targets = match_ast! {\n-        match (token.parent()) {\n+        match parent {\n             ast::NameRef(name_ref) => {\n                 reference_definition(&sema, &name_ref).to_vec()\n             },\n@@ -57,7 +58,7 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {\n         match n.kind() {\n-            IDENT | INT_NUMBER => 2,\n+            IDENT | INT_NUMBER | T![self] => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         }\n@@ -121,7 +122,8 @@ mod tests {\n             data => panic!(\"bad data: {}\", data),\n         }\n \n-        let mut navs = analysis.goto_definition(position).unwrap().unwrap().info;\n+        let mut navs =\n+            analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n         if navs.len() == 0 {\n             panic!(\"unresolved reference\")\n         }"}, {"sha": "069cb283e5a5a78207022a38b37f80fb5a097c6d", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7770ae43dd0d97686eb85fccb38801ff30117b/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=0f7770ae43dd0d97686eb85fccb38801ff30117b", "patch": "@@ -1,5 +1,5 @@\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n@@ -25,16 +25,17 @@ pub(crate) fn goto_type_definition(\n     let (ty, node) = sema.ancestors_with_macros(token.parent()).find_map(|node| {\n         let ty = match_ast! {\n             match node {\n-                ast::Expr(expr) => sema.type_of_expr(&expr)?,\n-                ast::Pat(pat) => sema.type_of_pat(&pat)?,\n+                ast::Expr(it) => sema.type_of_expr(&it)?,\n+                ast::Pat(it) => sema.type_of_pat(&it)?,\n+                ast::SelfParam(it) => sema.type_of_self(&it)?,\n                 _ => return None,\n             }\n         };\n \n         Some((ty, node))\n     })?;\n \n-    let adt_def = ty.autoderef(db).find_map(|ty| ty.as_adt())?;\n+    let adt_def = ty.autoderef(db).filter_map(|ty| ty.as_adt()).last()?;\n \n     let nav = adt_def.to_nav(db);\n     Some(RangeInfo::new(node.text_range(), vec![nav]))\n@@ -44,7 +45,7 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {\n         match n.kind() {\n-            IDENT | INT_NUMBER => 2,\n+            IDENT | INT_NUMBER | T![self] => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         }\n@@ -53,91 +54,98 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n \n #[cfg(test)]\n mod tests {\n-    use crate::mock_analysis::analysis_and_position;\n+    use ra_db::FileRange;\n \n-    fn check_goto(ra_fixture: &str, expected: &str) {\n-        let (analysis, pos) = analysis_and_position(ra_fixture);\n+    use crate::mock_analysis::MockAnalysis;\n \n-        let mut navs = analysis.goto_type_definition(pos).unwrap().unwrap().info;\n+    fn check(ra_fixture: &str) {\n+        let (mock, position) = MockAnalysis::with_files_and_position(ra_fixture);\n+        let (expected, data) = mock.annotation();\n+        assert!(data.is_empty());\n+        let analysis = mock.analysis();\n+\n+        let mut navs = analysis.goto_type_definition(position).unwrap().unwrap().info;\n         assert_eq!(navs.len(), 1);\n         let nav = navs.pop().unwrap();\n-        nav.assert_match(expected);\n+        assert_eq!(expected, FileRange { file_id: nav.file_id(), range: nav.range() });\n     }\n \n     #[test]\n     fn goto_type_definition_works_simple() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo;\n-            fn foo() {\n-                let f: Foo;\n-                f<|>\n-            }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..11 7..10\",\n+        check(\n+            r#\"\n+struct Foo;\n+     //^^^\n+fn foo() {\n+    let f: Foo; f<|>\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_type_definition_works_simple_ref() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo;\n-            fn foo() {\n-                let f: &Foo;\n-                f<|>\n-            }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..11 7..10\",\n+        check(\n+            r#\"\n+struct Foo;\n+     //^^^\n+fn foo() {\n+    let f: &Foo; f<|>\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_type_definition_works_through_macro() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            macro_rules! id {\n-                ($($tt:tt)*) => { $($tt)* }\n-            }\n-            struct Foo {}\n-            id! {\n-                fn bar() {\n-                    let f<|> = Foo {};\n-                }\n-            }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 52..65 59..62\",\n+        check(\n+            r#\"\n+macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n+struct Foo {}\n+     //^^^\n+id! {\n+    fn bar() { let f<|> = Foo {}; }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_type_definition_for_param() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo;\n-            fn foo(<|>f: Foo) {}\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..11 7..10\",\n+        check(\n+            r#\"\n+struct Foo;\n+     //^^^\n+fn foo(<|>f: Foo) {}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_type_definition_for_tuple_field() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo;\n-            struct Bar(Foo);\n-            fn foo() {\n-                let bar = Bar(Foo);\n-                bar.<|>0;\n-            }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..11 7..10\",\n+        check(\n+            r#\"\n+struct Foo;\n+     //^^^\n+struct Bar(Foo);\n+fn foo() {\n+    let bar = Bar(Foo);\n+    bar.<|>0;\n+}\n+\"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_def_for_self_param() {\n+        check(\n+            r#\"\n+struct Foo;\n+     //^^^\n+impl Foo {\n+    fn f(&self<|>) {}\n+}\n+\"#,\n+        )\n+    }\n }"}]}