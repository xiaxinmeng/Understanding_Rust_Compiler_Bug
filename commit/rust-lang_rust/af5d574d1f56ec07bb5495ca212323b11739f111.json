{"sha": "af5d574d1f56ec07bb5495ca212323b11739f111", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNWQ1NzRkMWY1NmVjMDdiYjU0OTVjYTIxMjMyM2IxMTczOWYxMTE=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2016-01-26T21:10:21Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2016-02-04T15:28:06Z"}, "message": "Prevent the immediate panic uncovered by #31109 and add a test.\n\nThe code there still triggers an ICE, but for different reasons (const eval unwraps the parse result).", "tree": {"sha": "5febe44f8de7b6565543ffff74de13ee3a2cd5dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5febe44f8de7b6565543ffff74de13ee3a2cd5dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af5d574d1f56ec07bb5495ca212323b11739f111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af5d574d1f56ec07bb5495ca212323b11739f111", "html_url": "https://github.com/rust-lang/rust/commit/af5d574d1f56ec07bb5495ca212323b11739f111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af5d574d1f56ec07bb5495ca212323b11739f111/comments", "author": null, "committer": null, "parents": [{"sha": "a8dc1f974be05b80b2edf17b62eee47e38edf2de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8dc1f974be05b80b2edf17b62eee47e38edf2de", "html_url": "https://github.com/rust-lang/rust/commit/a8dc1f974be05b80b2edf17b62eee47e38edf2de"}], "stats": {"total": 47, "additions": 39, "deletions": 8}, "files": [{"sha": "c0690c24bbb68601bf48307bbea69dcf715e25e7", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af5d574d1f56ec07bb5495ca212323b11739f111/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af5d574d1f56ec07bb5495ca212323b11739f111/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=af5d574d1f56ec07bb5495ca212323b11739f111", "patch": "@@ -230,18 +230,15 @@ fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, ParseFloatError> {\n     if let Some(x) = trivial_cases(&decimal) {\n         return Ok(x);\n     }\n-    // AlgorithmM and AlgorithmR both compute approximately `f * 10^e`.\n-    let max_digits = decimal.integral.len() + decimal.fractional.len() +\n-                     decimal.exp.abs() as usize;\n     // Remove/shift out the decimal point.\n     let e = decimal.exp - decimal.fractional.len() as i64;\n     if let Some(x) = algorithm::fast_path(decimal.integral, decimal.fractional, e) {\n         return Ok(x);\n     }\n     // Big32x40 is limited to 1280 bits, which translates to about 385 decimal digits.\n-    // If we exceed this, perhaps while calculating `f * 10^e` in Algorithm R or Algorithm M,\n-    // we'll crash. So we error out before getting too close, with a generous safety margin.\n-    if max_digits > 375 {\n+    // If we exceed this, we'll crash, so we error out before getting too close (within 10^10).\n+    let upper_bound = bound_intermediate_digits(&decimal, e);\n+    if upper_bound > 375 {\n         return Err(pfe_invalid());\n     }\n     let f = digits_to_big(decimal.integral, decimal.fractional);\n@@ -251,7 +248,7 @@ fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, ParseFloatError> {\n     // FIXME These bounds are rather conservative. A more careful analysis of the failure modes\n     // of Bellerophon could allow using it in more cases for a massive speed up.\n     let exponent_in_range = table::MIN_E <= e && e <= table::MAX_E;\n-    let value_in_range = max_digits <= T::max_normal_digits();\n+    let value_in_range = upper_bound <= T::max_normal_digits() as u64;\n     if exponent_in_range && value_in_range {\n         Ok(algorithm::bellerophon(&f, e))\n     } else {\n@@ -288,13 +285,36 @@ fn simplify(decimal: &mut Decimal) {\n     }\n }\n \n+/// Quick and dirty upper bound on the size (log10) of the largest value that Algorithm R and\n+/// Algorithm M will compute while working on the given decimal.\n+fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n+    // We don't need to worry too much about overflow here thanks to trivial_cases() and the\n+    // parser, which filter out the most extreme inputs for us.\n+    let f_len: u64 = decimal.integral.len() as u64 + decimal.fractional.len() as u64;\n+    if e >= 0 {\n+        // In the case e >= 0, both algorithms compute about `f * 10^e`. Algorithm R proceeds to\n+        // do some complicated calculations with this but we can ignore that for the upper bound\n+        // because it also reduces the fraction beforehand, so we have plenty of buffer there.\n+        f_len + (e as u64)\n+    } else {\n+        // If e < 0, Algorithm R does roughly the same thing, but Algorithm M differs:\n+        // It tries to find a positive number k such that `f << k / 10^e` is an in-range\n+        // significand. This will result in about `2^53 * f * 10^e` < `10^17 * f * 10^e`.\n+        // One input that triggers this is 0.33...33 (375 x 3).\n+        f_len + (e.abs() as u64) + 17\n+    }\n+}\n+\n /// Detect obvious overflows and underflows without even looking at the decimal digits.\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n         return Some(T::zero());\n     }\n-    // This is a crude approximation of ceil(log10(the real value)).\n+    // This is a crude approximation of ceil(log10(the real value)). We don't need to worry too\n+    // much about overflow here because the input length is tiny (at least compared to 2^64) and\n+    // the parser already handles exponents whose absolute value is greater than 10^18\n+    // (which is still 10^19 short of 2^64).\n     let max_place = decimal.exp + decimal.integral.len() as i64;\n     if max_place > T::inf_cutoff() {\n         return Some(T::infinity());"}, {"sha": "a96c29575685b2efb2cf03c1785c6c7f5d747a0f", "filename": "src/libcoretest/num/dec2flt/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af5d574d1f56ec07bb5495ca212323b11739f111/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af5d574d1f56ec07bb5495ca212323b11739f111/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs?ref=af5d574d1f56ec07bb5495ca212323b11739f111", "patch": "@@ -136,6 +136,17 @@ fn massive_exponent() {\n     assert_eq!(format!(\"1e{}000\", max).parse(), Ok(f64::INFINITY));\n }\n \n+#[test]\n+fn borderline_overflow() {\n+    let mut s = \"0.\".to_string();\n+    for _ in 0..375 {\n+        s.push('3');\n+    }\n+    // At the time of this writing, this returns Err(..), but this is a bug that should be fixed.\n+    // It makes no sense to enshrine that in a test, the important part is that it doesn't panic.\n+    let _ = s.parse::<f64>();\n+}\n+\n #[bench]\n fn bench_0(b: &mut test::Bencher) {\n     b.iter(|| \"0.0\".parse::<f64>());"}]}