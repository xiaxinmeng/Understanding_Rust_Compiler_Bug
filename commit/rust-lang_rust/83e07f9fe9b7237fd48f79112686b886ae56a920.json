{"sha": "83e07f9fe9b7237fd48f79112686b886ae56a920", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZTA3ZjlmZTliNzIzN2ZkNDhmNzkxMTI2ODZiODg2YWU1NmE5MjA=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-29T13:56:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Added self argument for Codegen CommonMethod trait methods", "tree": {"sha": "03aedb499c06100f6c4cdd7d46bb9237374c59ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03aedb499c06100f6c4cdd7d46bb9237374c59ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83e07f9fe9b7237fd48f79112686b886ae56a920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83e07f9fe9b7237fd48f79112686b886ae56a920", "html_url": "https://github.com/rust-lang/rust/commit/83e07f9fe9b7237fd48f79112686b886ae56a920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83e07f9fe9b7237fd48f79112686b886ae56a920/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3258448045d672b0cd273cb1ea9381b470c2ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3258448045d672b0cd273cb1ea9381b470c2ca2", "html_url": "https://github.com/rust-lang/rust/commit/d3258448045d672b0cd273cb1ea9381b470c2ca2"}], "stats": {"total": 237, "additions": 119, "deletions": 118}, "files": [{"sha": "7f700b3314df9fe9f81a64a3dea0bb8779fff570", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -529,8 +529,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe {\n             let llty = CodegenCx::val_ty(load);\n             let v = [\n-                CodegenCx::c_uint_big(llty, range.start),\n-                CodegenCx::c_uint_big(llty, range.end)\n+                self.cx.c_uint_big(llty, range.start),\n+                self.cx.c_uint_big(llty, range.end)\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n@@ -863,7 +863,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let undef = llvm::LLVMGetUndef(type_::Type::vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, CodegenCx::c_i32(self.cx, 0));\n             let vec_i32_ty = type_::Type::vector(type_::Type::i32(self.cx), num_elts as u64);\n-            self.shuffle_vector(vec, undef, CodegenCx::c_null(vec_i32_ty))\n+            self.shuffle_vector(vec, undef, self.cx.c_null(vec_i32_ty))\n         }\n     }\n "}, {"sha": "11940e9b0afb342b435fb8da1f9986434c7d4cb8", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -208,51 +208,51 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     // LLVM constant constructors.\n-    fn c_null(t: &'ll Type) -> &'ll Value {\n+    fn c_null(&self, t: &'ll Type) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstNull(t)\n         }\n     }\n \n-    fn c_undef(t: &'ll Type) -> &'ll Value {\n+    fn c_undef(&self, t: &'ll Type) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetUndef(t)\n         }\n     }\n \n-    fn c_int(t: &'ll Type, i: i64) -> &'ll Value {\n+    fn c_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstInt(t, i as u64, True)\n         }\n     }\n \n-    fn c_uint(t: &'ll Type, i: u64) -> &'ll Value {\n+    fn c_uint(&self, t: &'ll Type, i: u64) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstInt(t, i, False)\n         }\n     }\n \n-    fn c_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n+    fn c_uint_big(&self, t: &'ll Type, u: u128) -> &'ll Value {\n         unsafe {\n             let words = [u as u64, (u >> 64) as u64];\n             llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n         }\n     }\n \n     fn c_bool(&self, val: bool) -> &'ll Value {\n-        Self::c_uint(Type::i1(&self), val as u64)\n+        &self.c_uint(Type::i1(&self), val as u64)\n     }\n \n     fn c_i32(&self, i: i32) -> &'ll Value {\n-        Self::c_int(Type::i32(&self), i as i64)\n+        &self.c_int(Type::i32(&self), i as i64)\n     }\n \n     fn c_u32(&self, i: u32) -> &'ll Value {\n-        Self::c_uint(Type::i32(&self), i as u64)\n+        &self.c_uint(Type::i32(&self), i as u64)\n     }\n \n     fn c_u64(&self, i: u64) -> &'ll Value {\n-        Self::c_uint(Type::i64(&self), i)\n+        &self.c_uint(Type::i64(&self), i)\n     }\n \n     fn c_usize(&self, i: u64) -> &'ll Value {\n@@ -262,11 +262,11 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n             assert!(i < (1<<bit_size));\n         }\n \n-        Self::c_uint(&self.isize_ty, i)\n+        &self.c_uint(&self.isize_ty, i)\n     }\n \n     fn c_u8(&self, i: u8) -> &'ll Value {\n-        Self::c_uint(Type::i8(&self), i as u64)\n+        &self.c_uint(Type::i8(&self), i as u64)\n     }\n \n \n@@ -489,9 +489,9 @@ pub fn shift_mask_val(\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = llty.int_width() - 1;\n             if invert {\n-                CodegenCx::c_int(mask_llty, !val as i64)\n+                bx.cx.c_int(mask_llty, !val as i64)\n             } else {\n-                CodegenCx::c_uint(mask_llty, val)\n+                bx.cx.c_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {"}, {"sha": "fe587bd8f83eacc7dc45fab7671848e1e5a79114", "filename": "src/librustc_codegen_llvm/interfaces/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -15,11 +15,11 @@ pub trait CommonMethods : Backend {\n     fn val_ty(v: Self::Value) -> Self::Type;\n \n     // Constant constructors\n-    fn c_null(t: Self::Type) -> Self::Value;\n-    fn c_undef(t: Self::Type) -> Self::Value;\n-    fn c_int(t: Self::Type, i: i64) -> Self::Value;\n-    fn c_uint(t: Self::Type, i: u64) -> Self::Value;\n-    fn c_uint_big(t: Self::Type, u: u128) -> Self::Value;\n+    fn c_null(&self, t: Self::Type) -> Self::Value;\n+    fn c_undef(&self, t: Self::Type) -> Self::Value;\n+    fn c_int(&self, t: Self::Type, i: i64) -> Self::Value;\n+    fn c_uint(&self, t: Self::Type, i: u64) -> Self::Value;\n+    fn c_uint_big(&self, t: Self::Type, u: u128) -> Self::Value;\n     fn c_bool(&self, val: bool) -> Self::Value;\n     fn c_i32(&self, i: i32) -> Self::Value;\n     fn c_u32(&self, i: u32) -> Self::Value;"}, {"sha": "490d3c45aa8f510e6ba0c9202ba8c9c0edad5c17", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -127,11 +127,11 @@ pub fn codegen_intrinsic_call(\n         },\n         \"likely\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), CodegenCx::c_bool(cx, true)], None)\n+            bx.call(expect, &[args[0].immediate(), bx.cx().c_bool(true)], None)\n         }\n         \"unlikely\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), CodegenCx::c_bool(cx, false)], None)\n+            bx.call(expect, &[args[0].immediate(), bx.cx().c_bool(false)], None)\n         }\n         \"try\" => {\n             try_intrinsic(bx, cx,\n@@ -147,7 +147,7 @@ pub fn codegen_intrinsic_call(\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            CodegenCx::c_usize(cx, cx.size_of(tp_ty).bytes())\n+            cx.c_usize(cx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -156,12 +156,12 @@ pub fn codegen_intrinsic_call(\n                     glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llsize\n             } else {\n-                CodegenCx::c_usize(cx, cx.size_of(tp_ty).bytes())\n+                cx.c_usize(cx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            CodegenCx::c_usize(cx, cx.align_of(tp_ty).abi())\n+            cx.c_usize(cx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -170,20 +170,20 @@ pub fn codegen_intrinsic_call(\n                     glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llalign\n             } else {\n-                CodegenCx::c_usize(cx, cx.align_of(tp_ty).abi())\n+                cx.c_usize(cx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            CodegenCx::c_usize(cx, cx.align_of(tp_ty).pref())\n+            cx.c_usize(cx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n             let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n-            CodegenCx::c_str_slice(cx, ty_name)\n+            cx.c_str_slice(ty_name)\n         }\n         \"type_id\" => {\n-            CodegenCx::c_u64(cx, cx.tcx.type_id_hash(substs.type_at(0)))\n+            cx.c_u64(cx.tcx.type_id_hash(substs.type_at(0)))\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n@@ -197,8 +197,8 @@ pub fn codegen_intrinsic_call(\n                     false,\n                     ty,\n                     llresult,\n-                    CodegenCx::c_u8(cx, 0),\n-                    CodegenCx::c_usize(cx, 1)\n+                    cx.c_u8(0),\n+                    cx.c_usize(1)\n                 );\n             }\n             return;\n@@ -210,7 +210,7 @@ pub fn codegen_intrinsic_call(\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            CodegenCx::c_bool(cx, bx.cx().type_needs_drop(tp_ty))\n+            cx.c_bool(bx.cx().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n@@ -287,9 +287,9 @@ pub fn codegen_intrinsic_call(\n             };\n             bx.call(expect, &[\n                 args[0].immediate(),\n-                CodegenCx::c_i32(cx, rw),\n+                cx.c_i32(rw),\n                 args[1].immediate(),\n-                CodegenCx::c_i32(cx, cache_type)\n+                cx.c_i32(cache_type)\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n@@ -302,12 +302,12 @@ pub fn codegen_intrinsic_call(\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = CodegenCx::c_bool(bx.cx(), false);\n+                            let y = cx.c_bool(false);\n                             let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = CodegenCx::c_bool(bx.cx(), true);\n+                            let y = cx.c_bool(true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n                             let llfn = cx.get_intrinsic(llvm_name);\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n@@ -388,7 +388,7 @@ pub fn codegen_intrinsic_call(\n                             } else {\n                                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                let width = CodegenCx::c_uint(Type::ix(cx, width), width);\n+                                let width = cx.c_uint(Type::ix(cx, width), width);\n                                 let shift = bx.urem(raw_shift, width);\n                                 let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n                                 let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n@@ -725,7 +725,7 @@ fn copy_intrinsic(\n ) -> &'ll Value {\n     let cx = bx.cx();\n     let (size, align) = cx.size_and_align_of(ty);\n-    let size = CodegenCx::c_usize(cx, size.bytes());\n+    let size = cx.c_usize(size.bytes());\n     let align = align.abi();\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n@@ -746,8 +746,8 @@ fn memset_intrinsic(\n ) -> &'ll Value {\n     let cx = bx.cx();\n     let (size, align) = cx.size_and_align_of(ty);\n-    let size = CodegenCx::c_usize(cx, size.bytes());\n-    let align = CodegenCx::c_i32(cx, align.abi() as i32);\n+    let size = cx.c_usize(size.bytes());\n+    let align = cx.c_i32(align.abi() as i32);\n     let dst = bx.pointercast(dst, Type::i8p(cx));\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n@@ -763,7 +763,7 @@ fn try_intrinsic(\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(CodegenCx::c_null(Type::i8p(&bx.cx())), dest, ptr_align);\n+        bx.store(bx.cx().c_null(Type::i8p(&bx.cx())), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n@@ -844,7 +844,7 @@ fn codegen_msvc_try(\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n-        normal.ret(CodegenCx::c_i32(cx, 0));\n+        normal.ret(cx.c_i32(0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n@@ -854,19 +854,19 @@ fn codegen_msvc_try(\n             Some(did) => ::consts::get_static(cx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n-        let tok = catchpad.catch_pad(cs, &[tydesc, CodegenCx::c_i32(cx, 0), slot]);\n+        let tok = catchpad.catch_pad(cs, &[tydesc, cx.c_i32(0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n         let i64_align = bx.tcx().data_layout.i64_align;\n         let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = CodegenCx::c_i32(cx, 1);\n+        let val1 = cx.c_i32(1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n         catchpad.store(arg1, local_ptr, i64_align);\n         catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n-        caught.ret(CodegenCx::c_i32(cx, 1));\n+        caught.ret(cx.c_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -922,7 +922,7 @@ fn codegen_gnu_try(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let local_ptr = llvm::get_param(bx.llfn(), 2);\n         bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(CodegenCx::c_i32(cx, 0));\n+        then.ret(cx.c_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n@@ -932,11 +932,11 @@ fn codegen_gnu_try(\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false);\n         let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n-        catch.add_clause(vals, CodegenCx::c_null(Type::i8p(cx)));\n+        catch.add_clause(vals, bx.cx().c_null(Type::i8p(cx)));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(cx).ptr_to()), ptr_align);\n-        catch.ret(CodegenCx::c_i32(cx, 1));\n+        catch.ret(cx.c_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -1125,13 +1125,13 @@ fn generic_simd_intrinsic(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(CodegenCx::c_i32(bx.cx(), idx as i32)),\n+                    Some(idx) => Some(bx.cx().c_i32(idx as i32)),\n                 }\n             })\n             .collect();\n         let indices = match indices {\n             Some(i) => i,\n-            None => return Ok(CodegenCx::c_null(llret_ty))\n+            None => return Ok(bx.cx().c_null(llret_ty))\n         };\n \n         return Ok(bx.shuffle_vector(args[0].immediate(),\n@@ -1387,7 +1387,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = Type::i32(bx.cx());\n-        let alignment = CodegenCx::c_i32(bx.cx(), bx.cx().align_of(in_elem).abi() as i32);\n+        let alignment = bx.cx().c_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1487,7 +1487,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = Type::i32(bx.cx());\n-        let alignment = CodegenCx::c_i32(bx.cx(), bx.cx().align_of(in_elem).abi() as i32);\n+        let alignment = bx.cx().c_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1565,8 +1565,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => CodegenCx::c_undef(Type::f32(bx.cx())),\n-                                64 => CodegenCx::c_undef(Type::f64(bx.cx())),\n+                                32 => bx.cx().c_undef(Type::f32(bx.cx())),\n+                                64 => bx.cx().c_undef(Type::f64(bx.cx())),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,"}, {"sha": "a4d7260c829db0702257f7f5918bdaa427264808", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -96,7 +96,7 @@ pub fn get_vtable(\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = CodegenCx::c_null(Type::i8p(cx));\n+    let nullptr = cx.c_null(Type::i8p(cx));\n \n     let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n     let methods = methods.iter().cloned().map(|opt_mth| {"}, {"sha": "737b25a1231bb853639782672db2a44ecae5e1c3", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -172,7 +172,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     slot.storage_dead(&bx);\n \n                     if !bx.sess().target.target.options.custom_unwind_resume {\n-                        let mut lp = CodegenCx::c_undef(self.landing_pad_type());\n+                        let mut lp = bx.cx().c_undef(self.landing_pad_type());\n                         lp = bx.insert_value(lp, lp0, 0);\n                         lp = bx.insert_value(lp, lp1, 1);\n                         bx.resume(lp);\n@@ -210,7 +210,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         }\n                     } else {\n                         let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n-                        let llval = CodegenCx::c_uint_big(switch_llty, values[0]);\n+                        let llval = bx.cx().c_uint_big(switch_llty, values[0]);\n                         let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                         bx.cond_br(cmp, lltrue, llfalse);\n                     }\n@@ -221,7 +221,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                            values.len());\n                     let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n                     for (&value, target) in values.iter().zip(targets) {\n-                        let llval = CodegenCx::c_uint_big(switch_llty, value);\n+                        let llval =bx.cx().c_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n                         bx.add_case(switch, llval, llbb)\n                     }\n@@ -563,7 +563,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            CodegenCx::c_undef(fn_ty.ret.memory_ty(bx.cx()).ptr_to())\n+                            bx.cx().c_undef(fn_ty.ret.memory_ty(bx.cx()).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -744,7 +744,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(CodegenCx::c_undef(ty.llvm_type(bx.cx())));\n+            llargs.push(bx.cx().c_undef(ty.llvm_type(bx.cx())));\n         }\n \n         if arg.is_ignore() {"}, {"sha": "ac614dbbda01d58d24d9c2a9fe3ffcaf934c1abb", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -40,11 +40,11 @@ pub fn scalar_to_llvm(\n     match cv {\n         Scalar::Bits { size: 0, .. } => {\n             assert_eq!(0, layout.value.size(cx).bytes());\n-            CodegenCx::c_undef(Type::ix(cx, 0))\n+            cx.c_undef(Type::ix(cx, 0))\n         },\n         Scalar::Bits { bits, size } => {\n             assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = CodegenCx::c_uint_big(Type::ix(cx, bitsize), bits);\n+            let llval = cx.c_uint_big(Type::ix(cx, bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n@@ -73,7 +73,7 @@ pub fn scalar_to_llvm(\n             };\n             let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n                 consts::bitcast(base_addr, Type::i8p(cx)),\n-                &CodegenCx::c_usize(cx, ptr.offset.bytes()),\n+                &cx.c_usize(ptr.offset.bytes()),\n                 1,\n             ) };\n             if layout.value != layout::Pointer {\n@@ -218,7 +218,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(&ty);\n                 let llty = bx.cx().layout_of(ty).llvm_type(bx.cx());\n-                (CodegenCx::c_undef(llty), ty)\n+                (bx.cx().c_undef(llty), ty)\n             })\n     }\n }"}, {"sha": "2ec4f70e8264bdbe48cfdafb3f07947dfc109e0f", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -420,7 +420,7 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = CodegenCx::c_null(Type::i8p(bx.cx()));\n+                let null = bx.cx().c_null(Type::i8p(bx.cx()));\n                 let sixty_four = CodegenCx::c_i32(bx.cx(), 64);\n                 cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);"}, {"sha": "1581302c28565d9dbd79b47b39c00a575ccffe36", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -73,7 +73,7 @@ impl OperandRef<'tcx, &'ll Value> {\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx, &'ll Value> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(CodegenCx::c_undef(layout.immediate_llvm_type(cx))),\n+            val: OperandValue::Immediate(cx.c_undef(layout.immediate_llvm_type(cx))),\n             layout\n         }\n     }\n@@ -167,7 +167,7 @@ impl OperandRef<'tcx, &'ll Value> {\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n-            let mut llpair = CodegenCx::c_undef(llty);\n+            let mut llpair = bx.cx().c_undef(llty);\n             llpair = bx.insert_value(llpair, base::from_immediate(bx, a), 0);\n             llpair = bx.insert_value(llpair, base::from_immediate(bx, b), 1);\n             llpair\n@@ -232,7 +232,7 @@ impl OperandRef<'tcx, &'ll Value> {\n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bx.extract_element(llval, CodegenCx::c_usize(bx.cx(), i as u64)))\n+                    bx.extract_element(llval, bx.cx().c_usize(i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -463,7 +463,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n                         PlaceRef::new_sized(\n-                            CodegenCx::c_undef(layout.llvm_type(bx.cx()).ptr_to()),\n+                            bx.cx().c_undef(layout.llvm_type(bx.cx()).ptr_to()),\n                             layout,\n                             layout.align,\n                         ).load(bx)"}, {"sha": "3ad9f87cd90c70dca461a442f9f567e79291d1e1", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -69,7 +69,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n             consts::bitcast(base_addr, Type::i8p(bx.cx())),\n-            &CodegenCx::c_usize(bx.cx(), offset.bytes()),\n+            &bx.cx().c_usize(offset.bytes()),\n             1,\n         )};\n         let llval = consts::bitcast(llval, layout.llvm_type(bx.cx()).ptr_to());\n@@ -103,7 +103,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 assert_eq!(count, 0);\n                 self.llextra.unwrap()\n             } else {\n-                CodegenCx::c_usize(cx, count)\n+                cx.c_usize(count)\n             }\n         } else {\n             bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n@@ -248,7 +248,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         let meta = self.llextra;\n \n-        let unaligned_offset = CodegenCx::c_usize(cx, offset.bytes());\n+        let unaligned_offset = cx.c_usize(offset.bytes());\n \n         // Get the alignment of the field\n         let (_, unsized_align) = glue::size_and_align_of_dst(bx, field.ty, meta);\n@@ -259,7 +259,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bx.sub(unsized_align, CodegenCx::c_usize(cx, 1u64));\n+        let align_sub_1 = bx.sub(unsized_align, cx.c_usize(1u64));\n         let offset = bx.and(bx.add(unaligned_offset, align_sub_1),\n         bx.neg(unsized_align));\n \n@@ -289,14 +289,14 @@ impl PlaceRef<'tcx, &'ll Value> {\n     ) -> &'ll Value {\n         let cast_to = bx.cx().layout_of(cast_to).immediate_llvm_type(bx.cx());\n         if self.layout.abi.is_uninhabited() {\n-            return CodegenCx::c_undef(cast_to);\n+            return bx.cx().c_undef(cast_to);\n         }\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(bx.cx().tcx, index).val);\n-                return CodegenCx::c_uint_big(cast_to, discr_val);\n+                return bx.cx().c_uint_big(cast_to, discr_val);\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n@@ -328,22 +328,22 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n                         // HACK(eddyb) Using `c_null` as it works on all types.\n-                        CodegenCx::c_null(niche_llty)\n+                        bx.cx().c_null(niche_llty)\n                     } else {\n-                        CodegenCx::c_uint_big(niche_llty, niche_start)\n+                        bx.cx().c_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(IntPredicate::IntEQ, lldiscr, niche_llval),\n-                        CodegenCx::c_uint(cast_to, niche_variants.start().as_u32() as u64),\n-                        CodegenCx::c_uint(cast_to, dataful_variant.as_u32() as u64))\n+                        bx.cx().c_uint(cast_to, niche_variants.start().as_u32() as u64),\n+                        bx.cx().c_uint(cast_to, dataful_variant.as_u32() as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n                     let delta = niche_start.wrapping_sub(niche_variants.start().as_u32() as u128);\n-                    let lldiscr = bx.sub(lldiscr, CodegenCx::c_uint_big(niche_llty, delta));\n+                    let lldiscr = bx.sub(lldiscr, bx.cx().c_uint_big(niche_llty, delta));\n                     let lldiscr_max =\n-                        CodegenCx::c_uint(niche_llty, niche_variants.end().as_u32() as u64);\n+                        bx.cx().c_uint(niche_llty, niche_variants.end().as_u32() as u64);\n                     bx.select(bx.icmp(IntPredicate::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n-                        CodegenCx::c_uint(cast_to, dataful_variant.as_u32() as u64))\n+                        bx.cx().c_uint(cast_to, dataful_variant.as_u32() as u64))\n                 }\n             }\n         }\n@@ -365,7 +365,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n                     .val;\n                 bx.store(\n-                    CodegenCx::c_uint_big(ptr.layout.llvm_type(bx.cx()), to),\n+                    bx.cx().c_uint_big(ptr.layout.llvm_type(bx.cx()), to),\n                     ptr.llval,\n                     ptr.align);\n             }\n@@ -381,10 +381,10 @@ impl PlaceRef<'tcx, &'ll Value> {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let llptr = bx.pointercast(self.llval, Type::i8(bx.cx()).ptr_to());\n-                        let fill_byte = CodegenCx::c_u8(bx.cx(), 0);\n+                        let fill_byte = bx.cx().c_u8(0);\n                         let (size, align) = self.layout.size_and_align();\n-                        let size = CodegenCx::c_usize(bx.cx(), size.bytes());\n-                        let align = CodegenCx::c_u32(bx.cx(), align.abi() as u32);\n+                        let size = bx.cx().c_usize(size.bytes());\n+                        let align = bx.cx().c_u32(align.abi() as u32);\n                         base::call_memset(bx, llptr, fill_byte, size, align, false);\n                     }\n \n@@ -396,9 +396,9 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n                         // HACK(eddyb) Using `c_null` as it works on all types.\n-                        CodegenCx::c_null(niche_llty)\n+                        bx.cx().c_null(niche_llty)\n                     } else {\n-                        CodegenCx::c_uint_big(niche_llty, niche_value)\n+                        bx.cx().c_uint_big(niche_llty, niche_value)\n                     };\n                     OperandValue::Immediate(niche_llval).store(bx, niche);\n                 }\n@@ -409,7 +409,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n     pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n                          -> PlaceRef<'tcx, &'ll Value> {\n         PlaceRef {\n-            llval: bx.inbounds_gep(self.llval, &[CodegenCx::c_usize(bx.cx(), 0), llindex]),\n+            llval: bx.inbounds_gep(self.llval, &[bx.cx().c_usize(0), llindex]),\n             llextra: None,\n             layout: self.layout.field(bx.cx(), 0),\n             align: self.align\n@@ -484,7 +484,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // so we generate an abort\n                         let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n-                        let llval = CodegenCx::c_undef(layout.llvm_type(bx.cx()).ptr_to());\n+                        let llval = bx.cx().c_undef(layout.llvm_type(bx.cx()).ptr_to());\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n                 }\n@@ -517,28 +517,28 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = CodegenCx::c_usize(bx.cx(), offset as u64);\n+                        let lloffset = bx.cx().c_usize(offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = CodegenCx::c_usize(bx.cx(), offset as u64);\n+                        let lloffset = bx.cx().c_usize(offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            CodegenCx::c_usize(bx.cx(), from as u64));\n+                            bx.cx().c_usize(from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem)\n                             .to_ty(bx.tcx());\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                CodegenCx::c_usize(bx.cx(), (from as u64) + (to as u64))));\n+                                bx.cx().c_usize((from as u64) + (to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new"}, {"sha": "90d47205c6fbe9b538e13b09e0e6659239bf1c10", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e07f9fe9b7237fd48f79112686b886ae56a920/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=83e07f9fe9b7237fd48f79112686b886ae56a920", "patch": "@@ -103,15 +103,15 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     return bx;\n                 }\n \n-                let start = dest.project_index(&bx, CodegenCx::c_usize(bx.cx(), 0)).llval;\n+                let start = dest.project_index(&bx, bx.cx().c_usize(0)).llval;\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n-                    let align = CodegenCx::c_i32(bx.cx(), dest.align.abi() as i32);\n-                    let size = CodegenCx::c_usize(bx.cx(), dest.layout.size.bytes());\n+                    let align = bx.cx().c_i32(dest.align.abi() as i32);\n+                    let size = bx.cx().c_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if CodegenCx::is_const_integral(v) && CodegenCx::const_to_uint(v) == 0 {\n-                        let fill = CodegenCx::c_u8(bx.cx(), 0);\n+                        let fill = bx.cx().c_u8(0);\n                         base::call_memset(&bx, start, fill, size, align, false);\n                         return bx;\n                     }\n@@ -124,7 +124,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }\n                 }\n \n-                let count = CodegenCx::c_usize(bx.cx(), count);\n+                let count = bx.cx().c_usize(count);\n                 let end = dest.project_index(&bx, count).llval;\n \n                 let header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n@@ -140,7 +140,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 cg_elem.val.store(&body_bx,\n                     PlaceRef::new_sized(current, cg_elem.layout, dest.align));\n \n-                let next = body_bx.inbounds_gep(current, &[CodegenCx::c_usize(bx.cx(), 1)]);\n+                let next = body_bx.inbounds_gep(current, &[bx.cx().c_usize(1)]);\n                 body_bx.br(header_bx.llbb());\n                 header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n \n@@ -292,8 +292,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         assert!(cast.is_llvm_immediate());\n                         let ll_t_out = cast.immediate_llvm_type(bx.cx());\n                         if operand.layout.abi.is_uninhabited() {\n+                            let val = OperandValue::Immediate(bx.cx().c_undef(ll_t_out));\n                             return (bx, OperandRef {\n-                                val: OperandValue::Immediate(CodegenCx::c_undef(ll_t_out)),\n+                                val,\n                                 layout: cast,\n                             });\n                         }\n@@ -307,7 +308,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     let discr_val = def\n                                         .discriminant_for_variant(bx.cx().tcx, index)\n                                         .val;\n-                                    let discr = CodegenCx::c_uint_big(ll_t_out, discr_val);\n+                                    let discr = bx.cx().c_uint_big(ll_t_out, discr_val);\n                                     return (bx, OperandRef {\n                                         val: OperandValue::Immediate(discr),\n                                         layout: cast,\n@@ -338,7 +339,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     base::call_assume(&bx, bx.icmp(\n                                         IntPredicate::IntULE,\n                                         llval,\n-                                        CodegenCx::c_uint_big(ll_t_in, *scalar.valid_range.end())\n+                                        bx.cx().c_uint_big(ll_t_in, *scalar.valid_range.end())\n                                     ));\n                                 }\n                             }\n@@ -489,7 +490,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bx.cx().type_is_sized(ty));\n-                let val = CodegenCx::c_usize(bx.cx(), bx.cx().size_of(ty).bytes());\n+                let val = bx.cx().c_usize(bx.cx().size_of(ty).bytes());\n                 let tcx = bx.tcx();\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -500,8 +501,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let (size, align) = bx.cx().size_and_align_of(content_ty);\n-                let llsize = CodegenCx::c_usize(bx.cx(), size.bytes());\n-                let llalign = CodegenCx::c_usize(bx.cx(), align.abi());\n+                let llsize = bx.cx().c_usize(size.bytes());\n+                let llalign = bx.cx().c_usize(align.abi());\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = box_layout.llvm_type(bx.cx());\n \n@@ -548,7 +549,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx().tcx);\n-                    return CodegenCx::c_usize(bx.cx(), n);\n+                    return bx.cx().c_usize(n);\n                 }\n             }\n         }\n@@ -606,7 +607,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_unit {\n-                CodegenCx::c_bool(bx.cx(), match op {\n+                bx.cx().c_bool(match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n@@ -685,7 +686,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         // while the current crate doesn't use overflow checks.\n         if !bx.cx().check_overflow {\n             let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, CodegenCx::c_bool(bx.cx(), false));\n+            return OperandValue::Pair(val, bx.cx().c_bool(false));\n         }\n \n         let (val, of) = match op {\n@@ -709,7 +710,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let invert_mask = common::shift_mask_val(&bx, lhs_llty, rhs_llty, true);\n                 let outer_bits = bx.and(rhs, invert_mask);\n \n-                let of = bx.icmp(IntPredicate::IntNE, outer_bits, CodegenCx::c_null(rhs_llty));\n+                let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().c_null(rhs_llty));\n                 let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n \n                 (val, of)\n@@ -836,9 +837,9 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n         use rustc_apfloat::Float;\n         const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n                                             << (Single::MAX_EXP - Single::PRECISION as i16);\n-        let max = CodegenCx::c_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n+        let max = bx.cx().c_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n-        let infinity_bits = CodegenCx::c_u32(bx.cx(), ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = bx.cx().c_u32(ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n         bx.select(overflow, infinity, bx.uitofp(x, float_ty))\n     } else {\n@@ -907,8 +908,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     }\n     let float_bits_to_llval = |bits| {\n         let bits_llval = match float_ty.float_width() {\n-            32 => CodegenCx::c_u32(bx.cx(), bits as u32),\n-            64 => CodegenCx::c_u64(bx.cx(), bits as u64),\n+            32 => bx.cx().c_u32(bits as u32),\n+            64 => bx.cx().c_u64(bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)\n@@ -963,8 +964,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // performed is ultimately up to the backend, but at least x86 does perform them.\n     let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n     let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n-    let int_max = CodegenCx::c_uint_big(int_ty, int_max(signed, int_ty));\n-    let int_min = CodegenCx::c_uint_big(int_ty, int_min(signed, int_ty) as u128);\n+    let int_max = bx.cx().c_uint_big(int_ty, int_max(signed, int_ty));\n+    let int_min = bx.cx().c_uint_big(int_ty, int_min(signed, int_ty) as u128);\n     let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n     let s1 = bx.select(greater, int_max, s0);\n \n@@ -973,7 +974,7 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // Therefore we only need to execute this step for signed integer types.\n     if signed {\n         // LLVM has no isNaN predicate, so we use (x == x) instead\n-        bx.select(bx.fcmp(RealPredicate::RealOEQ, x, x), s1, CodegenCx::c_uint(int_ty, 0))\n+        bx.select(bx.fcmp(RealPredicate::RealOEQ, x, x), s1, bx.cx().c_uint(int_ty, 0))\n     } else {\n         s1\n     }"}]}