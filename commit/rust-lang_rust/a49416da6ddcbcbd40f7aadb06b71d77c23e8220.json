{"sha": "a49416da6ddcbcbd40f7aadb06b71d77c23e8220", "node_id": "C_kwDOAAsO6NoAKGE0OTQxNmRhNmRkY2JjYmQ0MGY3YWFkYjA2YjcxZDc3YzIzZTgyMjA", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T15:14:04Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T15:14:04Z"}, "message": "Remove stub local debuginfo implementation\n\nIt isn't actually wired up and temporarily removing it will make changes\nto the debuginfo generation code much simpler.", "tree": {"sha": "9eb0bc551353939b659e46fd40485ef84c261c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eb0bc551353939b659e46fd40485ef84c261c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49416da6ddcbcbd40f7aadb06b71d77c23e8220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49416da6ddcbcbd40f7aadb06b71d77c23e8220", "html_url": "https://github.com/rust-lang/rust/commit/a49416da6ddcbcbd40f7aadb06b71d77c23e8220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49416da6ddcbcbd40f7aadb06b71d77c23e8220/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fc1366dfa0b5c9615be028e75f4f237f165831b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc1366dfa0b5c9615be028e75f4f237f165831b", "html_url": "https://github.com/rust-lang/rust/commit/5fc1366dfa0b5c9615be028e75f4f237f165831b"}], "stats": {"total": 244, "additions": 5, "deletions": 239}, "files": [{"sha": "fe04567af66c2c937b1a12a79df376815f0e7ae4", "filename": "src/base.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a49416da6ddcbcbd40f7aadb06b71d77c23e8220/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49416da6ddcbcbd40f7aadb06b71d77c23e8220/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=a49416da6ddcbcbd40f7aadb06b71d77c23e8220", "patch": "@@ -20,7 +20,6 @@ struct CodegenedFunction<'tcx> {\n     func: Function,\n     clif_comments: CommentWriter,\n     source_info_set: IndexSet<SourceInfo>,\n-    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n }\n \n pub(crate) fn codegen_and_compile_fn<'tcx>(\n@@ -112,7 +111,6 @@ fn codegen_fn<'tcx>(\n     let instance = fx.instance;\n     let clif_comments = fx.clif_comments;\n     let source_info_set = fx.source_info_set;\n-    let local_map = fx.local_map;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n@@ -130,15 +128,7 @@ fn codegen_fn<'tcx>(\n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    CodegenedFunction {\n-        instance,\n-        symbol_name,\n-        func_id,\n-        func,\n-        clif_comments,\n-        source_info_set,\n-        local_map,\n-    }\n+    CodegenedFunction { instance, symbol_name, func_id, func, clif_comments, source_info_set }\n }\n \n fn compile_fn<'tcx>(\n@@ -227,10 +217,8 @@ fn compile_fn<'tcx>(\n                 codegened_func.instance,\n                 codegened_func.func_id,\n                 codegened_func.symbol_name.name,\n-                isa,\n                 context,\n                 &codegened_func.source_info_set,\n-                codegened_func.local_map,\n             );\n         }\n         unwind_context.add_function(codegened_func.func_id, &context, isa);"}, {"sha": "7a330ff7d359ebbeda3bb98744899b0de41a0725", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 226, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/a49416da6ddcbcbd40f7aadb06b71d77c23e8220/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49416da6ddcbcbd40f7aadb06b71d77c23e8220/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=a49416da6ddcbcbd40f7aadb06b71d77c23e8220", "patch": "@@ -7,18 +7,11 @@ mod unwind;\n \n use crate::prelude::*;\n \n-use rustc_index::vec::IndexVec;\n-\n-use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{Endianness, LabelValueLoc, ValueLabel};\n+use cranelift_codegen::ir::Endianness;\n use cranelift_codegen::isa::TargetIsa;\n-use cranelift_codegen::ValueLocRange;\n \n-use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n-    LocationList, Range, RangeList, UnitEntryId,\n-};\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n+use gimli::write::{Address, AttributeValue, DwarfUnit, LineProgram, LineString, Range, RangeList};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n \n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n@@ -30,8 +23,6 @@ pub(crate) struct DebugContext<'tcx> {\n \n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n-\n-    types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n }\n \n impl<'tcx> DebugContext<'tcx> {\n@@ -101,124 +92,16 @@ impl<'tcx> DebugContext<'tcx> {\n             root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n-        DebugContext {\n-            tcx,\n-\n-            endian,\n-\n-            dwarf,\n-            unit_range_list: RangeList(Vec::new()),\n-\n-            types: FxHashMap::default(),\n-        }\n-    }\n-\n-    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let name = format!(\"{}\", ty);\n-        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-\n-        let type_id = match ty.kind() {\n-            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n-            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n-            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n-            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n-            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n-            ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let pointee = self.dwarf_ty(*pointee_ty);\n-\n-                let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc_hir::Mutability::Mut));\n-                type_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(pointee));\n-\n-                type_id\n-            }\n-            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let variant = adt_def.non_enum_variant();\n-\n-                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n-                    let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout.field(\n-                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                        field_idx,\n-                    );\n-\n-                    let field_type = self.dwarf_ty(field_layout.ty);\n-\n-                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n-                    let field_entry = self.dwarf.unit.get_mut(field_id);\n-\n-                    field_entry.set(\n-                        gimli::DW_AT_name,\n-                        AttributeValue::String(field_def.name.as_str().to_string().into_bytes()),\n-                    );\n-                    field_entry.set(\n-                        gimli::DW_AT_data_member_location,\n-                        AttributeValue::Udata(field_offset.bytes()),\n-                    );\n-                    field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n-                }\n-\n-                type_id\n-            }\n-            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n-\n-        self.types.insert(ty, type_id);\n-\n-        type_id\n-    }\n-\n-    fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let dw_ty = self.dwarf_ty(ty);\n-\n-        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n-        let var_entry = self.dwarf.unit.get_mut(var_id);\n-\n-        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-\n-        var_id\n+        DebugContext { tcx, endian, dwarf, unit_range_list: RangeList(Vec::new()) }\n     }\n \n     pub(crate) fn define_function(\n         &mut self,\n         instance: Instance<'tcx>,\n         func_id: FuncId,\n         name: &str,\n-        isa: &dyn TargetIsa,\n         context: &Context,\n         source_info_set: &indexmap::IndexSet<SourceInfo>,\n-        local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n     ) {\n         let symbol = func_id.as_u32() as usize;\n         let mir = self.tcx.instance_mir(instance.def);\n@@ -248,110 +131,5 @@ impl<'tcx> DebugContext<'tcx> {\n         );\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n-\n-        // FIXME make it more reliable and implement scopes before re-enabling this.\n-        if false {\n-            let value_labels_ranges = std::collections::HashMap::new(); // FIXME\n-\n-            for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    mir.local_decls[local].ty,\n-                );\n-                let var_id = self.define_local(entry_id, format!(\"{:?}\", local), ty);\n-\n-                let location = place_location(\n-                    self,\n-                    isa,\n-                    symbol,\n-                    &local_map,\n-                    &value_labels_ranges,\n-                    Place { local, projection: ty::List::empty() },\n-                );\n-\n-                let var_entry = self.dwarf.unit.get_mut(var_id);\n-                var_entry.set(gimli::DW_AT_location, location);\n-            }\n-        }\n-\n-        // FIXME create locals for all entries in mir.var_debug_info\n-    }\n-}\n-\n-fn place_location<'tcx>(\n-    debug_context: &mut DebugContext<'tcx>,\n-    isa: &dyn TargetIsa,\n-    symbol: usize,\n-    local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n-    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n-        ValueLabel,\n-        Vec<ValueLocRange>,\n-    >,\n-    place: Place<'tcx>,\n-) -> AttributeValue {\n-    assert!(place.projection.is_empty()); // FIXME implement them\n-\n-    match local_map[place.local].inner() {\n-        CPlaceInner::Var(_local, var) => {\n-            let value_label = cranelift_codegen::ir::ValueLabel::new(var.index());\n-            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n-                let loc_list = LocationList(\n-                    value_loc_ranges\n-                        .iter()\n-                        .map(|value_loc_range| Location::StartEnd {\n-                            begin: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.start),\n-                            },\n-                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n-                            data: translate_loc(isa, value_loc_range.loc).unwrap(),\n-                        })\n-                        .collect(),\n-                );\n-                let loc_list_id = debug_context.dwarf.unit.locations.add(loc_list);\n-\n-                AttributeValue::LocationListRef(loc_list_id)\n-            } else {\n-                // FIXME set value labels for unused locals\n-\n-                AttributeValue::Exprloc(Expression::new())\n-            }\n-        }\n-        CPlaceInner::VarPair(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::VarLane(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::Addr(_, _) => {\n-            // FIXME implement this (used by arguments and returns)\n-\n-            AttributeValue::Exprloc(Expression::new())\n-\n-            // For PointerBase::Stack:\n-            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot)).unwrap())\n-        }\n-    }\n-}\n-\n-// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(isa: &dyn TargetIsa, loc: LabelValueLoc) -> Option<Expression> {\n-    match loc {\n-        LabelValueLoc::Reg(reg) => {\n-            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n-            let mut expr = Expression::new();\n-            expr.op_reg(gimli::Register(machine_reg));\n-            Some(expr)\n-        }\n-        LabelValueLoc::SPOffset(offset) => {\n-            let mut expr = Expression::new();\n-            expr.op_breg(X86_64::RSP, offset);\n-            Some(expr)\n-        }\n     }\n }"}]}