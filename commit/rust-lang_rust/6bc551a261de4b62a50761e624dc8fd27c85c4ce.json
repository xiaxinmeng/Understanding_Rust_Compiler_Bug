{"sha": "6bc551a261de4b62a50761e624dc8fd27c85c4ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYzU1MWEyNjFkZTRiNjJhNTA3NjFlNjI0ZGM4ZmQyN2M4NWM0Y2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-05T02:48:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-05T02:48:03Z"}, "message": "Auto merge of #38093 - mikhail-m1:stack-overflow, r=arielb1\n\nfix stack overflow by enum and cont issue #36163\n\nsome paths were skipped while checking for recursion.\n\nI fixed bug reproduces on win64 cargo test. In previous PR #36458 time complexity was exponential in case of linked const values. Now it's linear.\n\nr? @alexcrichton", "tree": {"sha": "f9df07a0b7567120de9f008739597643c39912fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9df07a0b7567120de9f008739597643c39912fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bc551a261de4b62a50761e624dc8fd27c85c4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bc551a261de4b62a50761e624dc8fd27c85c4ce", "html_url": "https://github.com/rust-lang/rust/commit/6bc551a261de4b62a50761e624dc8fd27c85c4ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bc551a261de4b62a50761e624dc8fd27c85c4ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebeee0e27e32e212979d9f38d285b1dc2816cd0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebeee0e27e32e212979d9f38d285b1dc2816cd0a", "html_url": "https://github.com/rust-lang/rust/commit/ebeee0e27e32e212979d9f38d285b1dc2816cd0a"}, {"sha": "b8d8ab87c08f1a662db82198ab598f549df9cc22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8d8ab87c08f1a662db82198ab598f549df9cc22", "html_url": "https://github.com/rust-lang/rust/commit/b8d8ab87c08f1a662db82198ab598f549df9cc22"}], "stats": {"total": 151, "additions": 86, "deletions": 65}, "files": [{"sha": "b5be4aa5e64e2ac25195bbf653f0220238cb6808", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 60, "deletions": 65, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6bc551a261de4b62a50761e624dc8fd27c85c4ce/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc551a261de4b62a50761e624dc8fd27c85c4ce/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=6bc551a261de4b62a50761e624dc8fd27c85c4ce", "patch": "@@ -15,24 +15,23 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n use rustc::session::{CompileResult, Session};\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-use std::cell::RefCell;\n-\n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     // `discriminant_map` is a cache that associates the `NodeId`s of local\n     // variant definitions with the discriminant expression that applies to\n     // each one. If the variant uses the default values (starting from `0`),\n     // then `None` is stored.\n-    discriminant_map: RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n+    discriminant_map: NodeMap<Option<&'ast hir::Expr>>,\n+    detected_recursive_ids: NodeSet,\n }\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n@@ -90,46 +89,49 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n     }\n }\n \n-pub fn check_crate<'ast>(sess: &Session,\n-                         ast_map: &ast_map::Map<'ast>)\n-                         -> CompileResult {\n+pub fn check_crate<'ast>(sess: &Session, ast_map: &ast_map::Map<'ast>) -> CompileResult {\n     let _task = ast_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n \n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         ast_map: ast_map,\n-        discriminant_map: RefCell::new(NodeMap()),\n+        discriminant_map: NodeMap(),\n+        detected_recursive_ids: NodeSet(),\n     };\n     sess.track_errors(|| {\n         // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n         ast_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n     })\n }\n \n-struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n-    root_span: &'a Span,\n-    sess: &'a Session,\n-    ast_map: &'a ast_map::Map<'ast>,\n-    discriminant_map: &'a RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n+struct CheckItemRecursionVisitor<'a, 'b: 'a, 'ast: 'b> {\n+    root_span: &'b Span,\n+    sess: &'b Session,\n+    ast_map: &'b ast_map::Map<'ast>,\n+    discriminant_map: &'a mut NodeMap<Option<&'ast hir::Expr>>,\n     idstack: Vec<ast::NodeId>,\n+    detected_recursive_ids: &'a mut NodeSet,\n }\n \n-impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n-    fn new(v: &'a CheckCrateVisitor<'a, 'ast>,\n-           span: &'a Span)\n-           -> CheckItemRecursionVisitor<'a, 'ast> {\n+impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n+    fn new(v: &'a mut CheckCrateVisitor<'b, 'ast>, span: &'b Span) -> Self {\n         CheckItemRecursionVisitor {\n             root_span: span,\n             sess: v.sess,\n             ast_map: v.ast_map,\n-            discriminant_map: &v.discriminant_map,\n+            discriminant_map: &mut v.discriminant_map,\n             idstack: Vec::new(),\n+            detected_recursive_ids: &mut v.detected_recursive_ids,\n         }\n     }\n     fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F, span: Span)\n         where F: Fn(&mut Self)\n     {\n         if self.idstack.iter().any(|&x| x == id) {\n+            if self.detected_recursive_ids.contains(&id) {\n+                return;\n+            }\n+            self.detected_recursive_ids.insert(id);\n             let any_static = self.idstack.iter().any(|&x| {\n                 if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n                     if let hir::ItemStatic(..) = item.node {\n@@ -168,15 +170,14 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n     // So for every variant, we need to track whether there is an expression\n     // somewhere in the enum definition that controls its discriminant. We do\n     // this by starting from the end and searching backward.\n-    fn populate_enum_discriminants(&self, enum_definition: &'ast hir::EnumDef) {\n+    fn populate_enum_discriminants(&mut self, enum_definition: &'ast hir::EnumDef) {\n         // Get the map, and return if we already processed this enum or if it\n         // has no variants.\n-        let mut discriminant_map = self.discriminant_map.borrow_mut();\n         match enum_definition.variants.first() {\n             None => {\n                 return;\n             }\n-            Some(variant) if discriminant_map.contains_key(&variant.node.data.id()) => {\n+            Some(variant) if self.discriminant_map.contains_key(&variant.node.data.id()) => {\n                 return;\n             }\n             _ => {}\n@@ -190,24 +191,23 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n             // is affected by that expression.\n             if let Some(ref expr) = variant.node.disr_expr {\n                 for id in &variant_stack {\n-                    discriminant_map.insert(*id, Some(expr));\n+                    self.discriminant_map.insert(*id, Some(expr));\n                 }\n                 variant_stack.clear()\n             }\n         }\n         // If we are at the top, that always starts at 0, so any variant on the\n         // stack has a default value and does not need to be checked.\n         for id in &variant_stack {\n-            discriminant_map.insert(*id, None);\n+            self.discriminant_map.insert(*id, None);\n         }\n     }\n }\n \n-impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n+impl<'a, 'b: 'a, 'ast: 'b> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'b, 'ast> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n         NestedVisitorMap::OnlyBodies(&self.ast_map)\n     }\n-\n     fn visit_item(&mut self, it: &'ast hir::Item) {\n         self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it), it.span);\n     }\n@@ -227,7 +227,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                      _: ast::NodeId) {\n         let variant_id = variant.node.data.id();\n         let maybe_expr;\n-        if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n+        if let Some(get_expr) = self.discriminant_map.get(&variant_id) {\n             // This is necessary because we need to let the `discriminant_map`\n             // borrow fall out of scope, so that we can reborrow farther down.\n             maybe_expr = (*get_expr).clone();\n@@ -251,51 +251,46 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         self.with_item_id_pushed(ii.id, |v| intravisit::walk_impl_item(v, ii), ii.span);\n     }\n \n-    fn visit_expr(&mut self, e: &'ast hir::Expr) {\n-        match e.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                match path.def {\n-                    Def::Static(def_id, _) |\n-                    Def::AssociatedConst(def_id) |\n-                    Def::Const(def_id) => {\n-                        if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n-                            match self.ast_map.get(node_id) {\n-                                ast_map::NodeItem(item) => self.visit_item(item),\n-                                ast_map::NodeTraitItem(item) => self.visit_trait_item(item),\n-                                ast_map::NodeImplItem(item) => self.visit_impl_item(item),\n-                                ast_map::NodeForeignItem(_) => {}\n-                                _ => {\n-                                    span_bug!(e.span,\n-                                              \"expected item, found {}\",\n-                                              self.ast_map.node_to_string(node_id));\n-                                }\n-                            }\n+    fn visit_path(&mut self, path: &'ast hir::Path, _: ast::NodeId) {\n+        match path.def {\n+            Def::Static(def_id, _) |\n+            Def::AssociatedConst(def_id) |\n+            Def::Const(def_id) => {\n+                if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n+                    match self.ast_map.get(node_id) {\n+                        ast_map::NodeItem(item) => self.visit_item(item),\n+                        ast_map::NodeTraitItem(item) => self.visit_trait_item(item),\n+                        ast_map::NodeImplItem(item) => self.visit_impl_item(item),\n+                        ast_map::NodeForeignItem(_) => {}\n+                        _ => {\n+                            span_bug!(path.span,\n+                                      \"expected item, found {}\",\n+                                      self.ast_map.node_to_string(node_id));\n                         }\n                     }\n-                    // For variants, we only want to check expressions that\n-                    // affect the specific variant used, but we need to check\n-                    // the whole enum definition to see what expression that\n-                    // might be (if any).\n-                    Def::VariantCtor(variant_id, CtorKind::Const) => {\n-                        if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n-                            let variant = self.ast_map.expect_variant(variant_id);\n-                            let enum_id = self.ast_map.get_parent(variant_id);\n-                            let enum_item = self.ast_map.expect_item(enum_id);\n-                            if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n-                                self.populate_enum_discriminants(enum_def);\n-                                self.visit_variant(variant, generics, enum_id);\n-                            } else {\n-                                span_bug!(e.span,\n-                                          \"`check_static_recursion` found \\\n-                                           non-enum in Def::VariantCtor\");\n-                            }\n-                        }\n+                }\n+            }\n+            // For variants, we only want to check expressions that\n+            // affect the specific variant used, but we need to check\n+            // the whole enum definition to see what expression that\n+            // might be (if any).\n+            Def::VariantCtor(variant_id, CtorKind::Const) => {\n+                if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n+                    let variant = self.ast_map.expect_variant(variant_id);\n+                    let enum_id = self.ast_map.get_parent(variant_id);\n+                    let enum_item = self.ast_map.expect_item(enum_id);\n+                    if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n+                        self.populate_enum_discriminants(enum_def);\n+                        self.visit_variant(variant, generics, enum_id);\n+                    } else {\n+                        span_bug!(path.span,\n+                                  \"`check_static_recursion` found \\\n+                                    non-enum in Def::VariantCtor\");\n                     }\n-                    _ => (),\n                 }\n             }\n             _ => (),\n         }\n-        intravisit::walk_expr(self, e);\n+        intravisit::walk_path(self, path);\n     }\n }"}, {"sha": "9dad6ede776c240fe21ef8f52ad20bd044ccae6a", "filename": "src/test/compile-fail/issue-36163.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6bc551a261de4b62a50761e624dc8fd27c85c4ce/src%2Ftest%2Fcompile-fail%2Fissue-36163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc551a261de4b62a50761e624dc8fd27c85c4ce/src%2Ftest%2Fcompile-fail%2Fissue-36163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36163.rs?ref=6bc551a261de4b62a50761e624dc8fd27c85c4ce", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const A: i32 = Foo::B; //~ ERROR E0265\n+                       //~^ NOTE recursion not allowed in constant\n+\n+enum Foo {\n+    B = A, //~ ERROR E0265\n+           //~^ NOTE recursion not allowed in constant\n+}\n+\n+enum Bar {\n+    C = Bar::C, //~ ERROR E0265\n+                //~^ NOTE recursion not allowed in constant\n+}\n+\n+const D: i32 = A;\n+\n+fn main() {}"}]}