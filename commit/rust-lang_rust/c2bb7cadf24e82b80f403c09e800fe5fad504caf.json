{"sha": "c2bb7cadf24e82b80f403c09e800fe5fad504caf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmI3Y2FkZjI0ZTgyYjgwZjQwM2MwOWU4MDBmZTVmYWQ1MDRjYWY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-09-10T00:54:36Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-25T20:48:44Z"}, "message": "save-analysis: remove hacky, unnecessary code now that we have spans for every ident", "tree": {"sha": "d41e9788d1b3d05ab60df915d4119c6d2c8d59e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d41e9788d1b3d05ab60df915d4119c6d2c8d59e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2bb7cadf24e82b80f403c09e800fe5fad504caf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bb7cadf24e82b80f403c09e800fe5fad504caf", "html_url": "https://github.com/rust-lang/rust/commit/c2bb7cadf24e82b80f403c09e800fe5fad504caf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2bb7cadf24e82b80f403c09e800fe5fad504caf/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b49da276b307a58c7b3e5d5332fa32bccfb32f77", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49da276b307a58c7b3e5d5332fa32bccfb32f77", "html_url": "https://github.com/rust-lang/rust/commit/b49da276b307a58c7b3e5d5332fa32bccfb32f77"}], "stats": {"total": 469, "additions": 124, "deletions": 345}, "files": [{"sha": "d05f37cc0a1255eef81b17ff0e07189f42c7c6bf", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 69, "deletions": 100, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/c2bb7cadf24e82b80f403c09e800fe5fad504caf/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bb7cadf24e82b80f403c09e800fe5fad504caf/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c2bb7cadf24e82b80f403c09e800fe5fad504caf", "patch": "@@ -34,7 +34,6 @@ use std::env;\n \n use syntax::ast::{self, Attribute, NodeId, PatKind, CRATE_NODE_ID};\n use syntax::parse::token;\n-use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{\n     bounds_to_string,\n@@ -323,18 +322,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             self.visit_pat(&arg.pat);\n             let mut collector = PathCollector::new();\n             collector.visit_pat(&arg.pat);\n-            let span_utils = self.span.clone();\n \n             for (id, ident, ..) in collector.collected_idents {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n-                let sub_span = span_utils.span_for_last_ident(ident.span);\n-                if !self.span.filter_generated(sub_span, ident.span) {\n+                if !self.span.filter_generated(ident.span) {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+                    let span = self.span_from_span(ident.span);\n \n                     self.dumper.dump_def(\n                         &Access {\n@@ -373,7 +370,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident.name, span) {\n+        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident, span) {\n             let sig_str = ::make_signature(&sig.decl, &generics);\n             if body.is_some() {\n                 self.nest_tables(\n@@ -382,7 +379,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 );\n             }\n \n-            self.process_generic_params(&generics, span, &method_data.qualname, id);\n+            self.process_generic_params(&generics, &method_data.qualname, id);\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n@@ -415,7 +412,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_generic_params(\n         &mut self,\n         generics: &'l ast::Generics,\n-        full_span: Span,\n         prefix: &str,\n         id: NodeId,\n     ) {\n@@ -427,7 +423,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let name = escape(self.span.snippet(param_ss));\n                     // Append $id to name to make sure each one is unique.\n                     let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-                    if !self.span.filter_generated(Some(param_ss), full_span) {\n+                    if !self.span.filter_generated(param_ss) {\n                         let id = ::id_from_node_id(param.id, &self.save_ctxt);\n                         let span = self.span_from_span(param_ss);\n \n@@ -471,7 +467,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 item.id,\n                 |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n             );\n-            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+            self.process_generic_params(ty_params, &fn_data.qualname, item.id);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, item), fn_data);\n         }\n \n@@ -505,8 +501,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_assoc_const(\n         &mut self,\n         id: ast::NodeId,\n-        name: ast::Name,\n-        span: Span,\n+        ident: ast::Ident,\n         typ: &'l ast::Ty,\n         expr: Option<&'l ast::Expr>,\n         parent_id: DefId,\n@@ -515,19 +510,17 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n-        let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n-\n-        if !self.span.filter_generated(sub_span, span) {\n-            let sig = sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt);\n-            let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+        if !self.span.filter_generated(ident.span) {\n+            let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n+            let span = self.span_from_span(ident.span);\n \n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, vis, id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: ::id_from_node_id(id, &self.save_ctxt),\n                     span,\n-                    name: name.to_string(),\n+                    name: ident.name.to_string(),\n                     qualname,\n                     value: ty_to_string(&typ),\n                     parent: Some(::id_from_def_id(parent_id)),\n@@ -558,13 +551,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-        let (kind, keyword) = match item.node {\n-            ast::ItemKind::Struct(_, _) => (DefKind::Struct, keywords::Struct),\n-            ast::ItemKind::Union(_, _) => (DefKind::Union, keywords::Union),\n+        let kind = match item.node {\n+            ast::ItemKind::Struct(_, _) => DefKind::Struct,\n+            ast::ItemKind::Union(_, _) => DefKind::Union,\n             _ => unreachable!(),\n         };\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n         let (value, fields) = match item.node {\n             ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) |\n             ast::ItemKind::Union(ast::VariantData::Struct(ref fields, _), _) => {\n@@ -595,8 +587,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             _ => (String::new(), vec![]),\n         };\n \n-        if !self.span.filter_generated(sub_span, item.span) {\n-            let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n+        if !self.span.filter_generated(item.ident.span) {\n+            let span = self.span_from_span(item.ident.span);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item),\n                 Def {\n@@ -621,7 +613,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             self.visit_ty(&field.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+        self.process_generic_params(ty_params, &qualname, item.id);\n     }\n \n     fn process_enum(\n@@ -642,10 +634,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         for variant in &enum_definition.variants {\n             let name = variant.node.ident.name.to_string();\n             let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n+            let name_span = variant.node.ident.span;\n \n             match variant.node.data {\n                 ast::VariantData::Struct(ref fields, _) => {\n-                    let sub_span = self.span.span_for_first_ident(variant.span);\n                     let fields_str = fields\n                         .iter()\n                         .enumerate()\n@@ -655,9 +647,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         .collect::<Vec<_>>()\n                         .join(\", \");\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n-                    if !self.span.filter_generated(sub_span, variant.span) {\n-                        let span = self\n-                            .span_from_span(sub_span.expect(\"No span found for struct variant\"));\n+                    if !self.span.filter_generated(name_span) {\n+                        let span = self.span_from_span(name_span);\n                         let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n@@ -684,7 +675,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     }\n                 }\n                 ref v => {\n-                    let sub_span = self.span.span_for_first_ident(variant.span);\n                     let mut value = format!(\"{}::{}\", enum_data.name, name);\n                     if let &ast::VariantData::Tuple(ref fields, _) = v {\n                         value.push('(');\n@@ -695,9 +685,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                             .join(\", \"));\n                         value.push(')');\n                     }\n-                    if !self.span.filter_generated(sub_span, variant.span) {\n-                        let span =\n-                            self.span_from_span(sub_span.expect(\"No span found for tuple variant\"));\n+                    if !self.span.filter_generated(name_span) {\n+                        let span = self.span_from_span(name_span);\n                         let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n@@ -731,7 +720,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 self.visit_ty(&field.ty);\n             }\n         }\n-        self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n+        self.process_generic_params(ty_params, &enum_data.qualname, item.id);\n         self.dumper.dump_def(&access, enum_data);\n     }\n \n@@ -755,7 +744,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if let &Some(ref trait_ref) = trait_ref {\n             self.process_path(trait_ref.ref_id, &trait_ref.path);\n         }\n-        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n+        self.process_generic_params(type_parameters, \"\", item.id);\n         for impl_item in impl_items {\n             let map = &self.tcx.hir;\n             self.process_impl_item(impl_item, map.local_def_id(item.id));\n@@ -779,10 +768,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             val.push_str(\": \");\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n-        if !self.span.filter_generated(sub_span, item.span) {\n+        if !self.span.filter_generated(item.ident.span) {\n             let id = ::id_from_node_id(item.id, &self.save_ctxt);\n-            let span = self.span_from_span(sub_span.expect(\"No span found for trait\"));\n+            let span = self.span_from_span(item.ident.span);\n             let children = methods\n                 .iter()\n                 .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n@@ -815,21 +803,18 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             let trait_ref = &trait_ref.trait_ref;\n             if let Some(id) = self.lookup_def_id(trait_ref.ref_id) {\n-                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for trait ref\"));\n+                let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n+                if !self.span.filter_generated(sub_span) {\n+                    let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n                         kind: RefKind::Type,\n-                        span,\n+                        span: span.clone(),\n                         ref_id: ::id_from_def_id(id),\n                     });\n-                }\n \n-                if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    let sub_span = self.span_from_span(sub_span.expect(\"No span for inheritance\"));\n                     self.dumper.dump_relation(Relation {\n                         kind: RelationKind::SuperTrait,\n-                        span: sub_span,\n+                        span,\n                         from: ::id_from_def_id(id),\n                         to: ::id_from_node_id(item.id, &self.save_ctxt),\n                     });\n@@ -838,7 +823,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, &qualname, item.id);\n+        self.process_generic_params(generics, &qualname, item.id);\n         for method in methods {\n             let map = &self.tcx.hir;\n             self.process_trait_item(method, map.local_def_id(item.id))\n@@ -988,12 +973,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 };\n                 let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n-                for &Spanned { node: ref field, span } in fields {\n-                    let sub_span = self.span.span_for_first_ident(span);\n+                for &Spanned { node: ref field, .. } in fields {\n                     if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n-                        if !self.span.filter_generated(sub_span, span) {\n-                            let span =\n-                                self.span_from_span(sub_span.expect(\"No span fund for var ref\"));\n+                        if !self.span.filter_generated(field.ident.span) {\n+                            let span = self.span_from_span(field.ident.span);\n                             self.dumper.dump_ref(Ref {\n                                 kind: RefKind::Variable,\n                                 span,\n@@ -1034,7 +1017,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n-                    if !self.span.filter_generated(Some(ident.span), ident.span) {\n+                    if !self.span.filter_generated(ident.span) {\n                         let qualname = format!(\"{}${}\", ident.to_string(), id);\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n                         let span = self.span_from_span(ident.span);\n@@ -1109,14 +1092,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 None => String::new(),\n             };\n \n-            // Get the span only for the name of the variable (I hope the path\n-            // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(ident.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(sub_span, ident.span) {\n+            if !self.span.filter_generated(ident.span) {\n                 let qualname = format!(\"{}${}\", ident.to_string(), id);\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n-                let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+                let span = self.span_from_span(ident.span);\n \n                 self.dumper.dump_def(\n                     &Access {\n@@ -1190,8 +1170,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     trait_item.id,\n-                    trait_item.ident.name,\n-                    trait_item.span,\n+                    trait_item.ident,\n                     &ty,\n                     expr.as_ref().map(|e| &**e),\n                     trait_id,\n@@ -1214,11 +1193,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n-                let sub_span = self.span\n-                    .sub_span_after_keyword(trait_item.span, keywords::Type);\n \n-                if !self.span.filter_generated(sub_span, trait_item.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for assoc type\"));\n+                if !self.span.filter_generated(trait_item.ident.span) {\n+                    let span = self.span_from_span(trait_item.ident.span);\n                     let id = ::id_from_node_id(trait_item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n@@ -1263,8 +1240,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     impl_item.id,\n-                    impl_item.ident.name,\n-                    impl_item.span,\n+                    impl_item.ident,\n                     &ty,\n                     Some(expr),\n                     impl_id,\n@@ -1328,7 +1304,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             .map(::id_from_def_id);\n \n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(..) => {\n+            ast::UseTreeKind::Simple(alias, ..) => {\n                 let ident = use_tree.ident();\n                 let path = ast::Path {\n                     segments: prefix.segments\n@@ -1339,16 +1315,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     span: path.span,\n                 };\n \n-                let sub_span = self.span.span_for_last_ident(path.span);\n-                let alias_span = self.span.sub_span_after_keyword(use_tree.span, keywords::As);\n-                let ref_id = self.lookup_def_id(id);\n-\n-                if !self.span.filter_generated(sub_span, path.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for use\"));\n-                    let alias_span = alias_span.map(|sp| self.span_from_span(sp));\n+                let sub_span = path.segments.last().unwrap().ident.span;\n+                if !self.span.filter_generated(sub_span) {\n+                    let ref_id = self.lookup_def_id(id).map(|id| ::id_from_def_id(id));\n+                    let alias_span = alias.map(|i| self.span_from_span(i.span));\n+                    let span = self.span_from_span(sub_span);\n                     self.dumper.import(&access, Import {\n                         kind: ImportKind::Use,\n-                        ref_id: ref_id.map(|id| ::id_from_def_id(id)),\n+                        ref_id,\n                         span,\n                         alias_span,\n                         name: ident.to_string(),\n@@ -1377,9 +1351,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     Vec::new()\n                 };\n \n-                let sub_span = self.span.sub_span_of_token(use_tree.span,\n-                                                           token::BinOp(token::Star));\n-                if !self.span.filter_generated(sub_span, use_tree.span) {\n+                let sub_span =\n+                    self.span.sub_span_of_token(use_tree.span, token::BinOp(token::Star));\n+                if !self.span.filter_generated(use_tree.span) {\n                     let span =\n                         self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n                     self.dumper.import(&access, Import {\n@@ -1471,11 +1445,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 self.process_use_tree(use_tree, item.id, item, &prefix);\n             }\n             ExternCrate(_) => {\n-                let alias_span = self.span.span_for_last_ident(item.span);\n-\n-                if !self.span.filter_generated(alias_span, item.span) {\n-                    let span =\n-                        self.span_from_span(alias_span.expect(\"No span found for extern crate\"));\n+                let name_span = item.ident.span;\n+                if !self.span.filter_generated(name_span) {\n+                    let span = self.span_from_span(name_span);\n                     let parent = self.save_ctxt.tcx.hir.opt_local_def_id(item.id)\n                         .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n                         .map(::id_from_def_id);\n@@ -1518,9 +1490,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let value = ty_to_string(&ty);\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                if !self.span.filter_generated(sub_span, item.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for typedef\"));\n+                if !self.span.filter_generated(item.ident.span) {\n+                    let span = self.span_from_span(item.ident.span);\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n@@ -1543,15 +1514,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 }\n \n                 self.visit_ty(&ty);\n-                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+                self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Existential(ref _bounds, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 // FIXME do something with _bounds\n                 let value = String::new();\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                if !self.span.filter_generated(sub_span, item.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for typedef\"));\n+                if !self.span.filter_generated(item.ident.span) {\n+                    let span = self.span_from_span(item.ident.span);\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n@@ -1573,7 +1543,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     );\n                 }\n \n-                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+                self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Mac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1606,14 +1576,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.id) {\n-                    if let Some(sub_span) = self.span.sub_span_for_type_name(t.span) {\n-                        let span = self.span_from_span(sub_span);\n-                        self.dumper.dump_ref(Ref {\n-                            kind: RefKind::Type,\n-                            span,\n-                            ref_id: ::id_from_def_id(id),\n-                        });\n-                    }\n+                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    let span = self.span_from_span(sub_span);\n+                    self.dumper.dump_ref(Ref {\n+                        kind: RefKind::Type,\n+                        span,\n+                        ref_id: ::id_from_def_id(id),\n+                    });\n                 }\n \n                 self.write_sub_paths_truncated(path);\n@@ -1757,7 +1726,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         item.id,\n                         |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n                     );\n-                    self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n+                    self.process_generic_params(generics, &fn_data.qualname, item.id);\n                     self.dumper.dump_def(&access, fn_data);\n                 }\n "}, {"sha": "991172370148e7f239714a00f5057bdc19b3da1a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 44, "deletions": 72, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c2bb7cadf24e82b80f403c09e800fe5fad504caf/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bb7cadf24e82b80f403c09e800fe5fad504caf/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c2bb7cadf24e82b80f403c09e800fe5fad504caf", "patch": "@@ -60,9 +60,7 @@ use std::path::{Path, PathBuf};\n use syntax::ast::{self, Attribute, NodeId, PatKind};\n use syntax::source_map::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n-use syntax::parse::token;\n use syntax::print::pprust;\n-use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{arg_to_string, ty_to_string};\n use syntax::source_map::MacroAttribute;\n@@ -162,14 +160,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Fn);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::ForeignFunction,\n                     id: id_from_node_id(item.id, self),\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n                     value: make_signature(decl, generics),\n@@ -181,13 +177,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ForeignItemKind::Static(ref ty, m) => {\n-                let keyword = if m { keywords::Mut } else { keywords::Static };\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+            ast::ForeignItemKind::Static(ref ty, _) => {\n+                filter!(self.span_utils, item.ident.span);\n \n                 let id = ::id_from_node_id(item.id, self);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::ForeignStatic,\n@@ -214,13 +208,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Fn);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n                     id: id_from_node_id(item.id, self),\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n                     value: make_signature(decl, generics),\n@@ -232,19 +224,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ItemKind::Static(ref typ, mt, _) => {\n+            ast::ItemKind::Static(ref typ, ..) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-                let keyword = match mt {\n-                    ast::Mutability::Mutable => keywords::Mut,\n-                    ast::Mutability::Immutable => keywords::Static,\n-                };\n-\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Static,\n@@ -263,12 +249,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Const(ref typ, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Const);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Const,\n@@ -291,16 +275,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n \n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Mod);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Mod,\n                     id: id_from_node_id(item.id, self),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     value: filename.to_string(),\n                     parent: None,\n                     children: m.items\n@@ -316,9 +298,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Enum);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n                     .map(|v| v.node.ident.to_string())\n@@ -328,7 +308,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_node_id(item.id, self),\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     name,\n                     qualname,\n                     value,\n@@ -349,11 +329,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     if generated_code(path.span) {\n                         return None;\n                     }\n-                    let sub_span = self.span_utils.sub_span_for_type_name(path.span);\n-                    filter!(self.span_utils, sub_span, typ.span, None);\n+                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    filter!(self.span_utils, sub_span);\n \n                     let impl_id = self.next_impl_id();\n-                    let span = self.span_from_span(sub_span.unwrap());\n+                    let span = self.span_from_span(sub_span);\n \n                     let type_data = self.lookup_ref_id(typ.id);\n                     type_data.map(|type_data| {\n@@ -402,15 +382,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let sub_span = self.span_utils\n-                .sub_span_before_token(field.span, token::Colon);\n-            filter!(self.span_utils, sub_span, field.span, None);\n+            filter!(self.span_utils, ident.span);\n             let def_id = self.tcx.hir.local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n \n \n             let id = id_from_node_id(field.id, self);\n-            let span = self.span_from_span(sub_span.unwrap());\n+            let span = self.span_from_span(ident.span);\n \n             Some(Def {\n                 kind: DefKind::Field,\n@@ -433,7 +411,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> Option<Def> {\n+    pub fn get_method_data(&self, id: ast::NodeId, ident: ast::Ident, span: Span) -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n@@ -459,7 +437,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 qualname.push_str(&self.tcx.item_path_str(def_id));\n                                 self.tcx\n                                     .associated_items(def_id)\n-                                    .find(|item| item.ident.name == name)\n+                                    .find(|item| item.ident.name == ident.name)\n                                     .map(|item| decl_id = Some(item.def_id));\n                             }\n                             qualname.push_str(\">\");\n@@ -512,16 +490,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 },\n             };\n \n-        let qualname = format!(\"{}::{}\", qualname, name);\n+        let qualname = format!(\"{}::{}\", qualname, ident.name);\n \n-        let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n-        filter!(self.span_utils, sub_span, span, None);\n+        filter!(self.span_utils, ident.span);\n \n         Some(Def {\n             kind: DefKind::Method,\n             id: id_from_node_id(id, self),\n-            span: self.span_from_span(sub_span.unwrap()),\n-            name: name.to_string(),\n+            span: self.span_from_span(ident.span),\n+            name: ident.name.to_string(),\n             qualname,\n             // FIXME you get better data here by using the visitor.\n             value: String::new(),\n@@ -540,9 +517,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             if generated_code(span) {\n                 return None;\n             }\n-            let sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n-            filter!(self.span_utils, sub_span, span, None);\n-            let span = self.span_from_span(sub_span.unwrap());\n+            let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n+            filter!(self.span_utils, sub_span);\n+            let span = self.span_from_span(sub_span);\n             Some(Ref {\n                 kind: RefKind::Type,\n                 span,\n@@ -574,9 +551,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         let index = self.tcx.find_field_index(ident, variant).unwrap();\n-                        let sub_span = self.span_utils.span_for_last_ident(expr.span);\n-                        filter!(self.span_utils, sub_span, expr.span, None);\n-                        let span = self.span_from_span(sub_span.unwrap());\n+                        filter!(self.span_utils, ident.span);\n+                        let span = self.span_from_span(ident.span);\n                         return Some(Data::RefData(Ref {\n                             kind: RefKind::Variable,\n                             span,\n@@ -593,9 +569,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprKind::Struct(ref path, ..) => {\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::Adt(def, _) if !def.is_enum() => {\n-                        let sub_span = self.span_utils.span_for_last_ident(path.span);\n-                        filter!(self.span_utils, sub_span, path.span, None);\n-                        let span = self.span_from_span(sub_span.unwrap());\n+                        let sub_span = path.segments.last().unwrap().ident.span;\n+                        filter!(self.span_utils, sub_span);\n+                        let span = self.span_from_span(sub_span);\n                         Some(Data::RefData(Ref {\n                             kind: RefKind::Type,\n                             span,\n@@ -624,7 +600,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n                 let sub_span = seg.ident.span;\n-                filter!(self.span_utils, Some(sub_span), expr.span, None);\n+                filter!(self.span_utils, sub_span);\n                 let span = self.span_from_span(sub_span);\n                 Some(Data::RefData(Ref {\n                     kind: RefKind::Function,\n@@ -729,7 +705,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let def = self.get_path_def(id);\n         let last_seg = &path.segments[path.segments.len() - 1];\n         let sub_span = last_seg.ident.span;\n-        filter!(self.span_utils, Some(sub_span), path.span, None);\n+        filter!(self.span_utils, sub_span);\n         match def {\n             HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n                 let span = self.span_from_span(sub_span);\n@@ -753,13 +729,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Trait(def_id) if fn_type(path) => {\n                 // Function type bounds are desugared in the parser, so we have to\n                 // special case them here.\n-                let fn_span = self.span_utils.span_for_first_ident(path.span);\n-                fn_span.map(|span| {\n-                    Ref {\n-                        kind: RefKind::Type,\n-                        span: self.span_from_span(span),\n-                        ref_id: id_from_def_id(def_id),\n-                    }\n+                let fn_span = path.segments.first().unwrap().ident.span;\n+                Some(Ref {\n+                    kind: RefKind::Type,\n+                    span: self.span_from_span(fn_span),\n+                    ref_id: id_from_def_id(def_id),\n                 })\n             }\n             HirDef::Struct(def_id) |\n@@ -844,10 +818,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n         let index = self.tcx.find_field_index(field_ref.ident, variant).unwrap();\n-        // We don't really need a sub-span here, but no harm done\n-        let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n-        filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n-        let span = self.span_from_span(sub_span.unwrap());\n+        filter!(self.span_utils, field_ref.ident.span);\n+        let span = self.span_from_span(field_ref.ident.span);\n         Some(Ref {\n             kind: RefKind::Variable,\n             span,"}, {"sha": "902353da13f76072b14da48ef182521dcd23c1fd", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 11, "deletions": 173, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/c2bb7cadf24e82b80f403c09e800fe5fad504caf/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bb7cadf24e82b80f403c09e800fe5fad504caf/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=c2bb7cadf24e82b80f403c09e800fe5fad504caf", "patch": "@@ -16,7 +16,6 @@ use std::cell::Cell;\n \n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n-use syntax::symbol::keywords;\n use syntax_pos::*;\n \n #[derive(Clone)]\n@@ -67,131 +66,6 @@ impl<'a> SpanUtils<'a> {\n         lexer::StringReader::retokenize(&self.sess.parse_sess, span)\n     }\n \n-    // Re-parses a path and returns the span for the last identifier in the path\n-    pub fn span_for_last_ident(&self, span: Span) -> Option<Span> {\n-        let mut result = None;\n-\n-        let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0;\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return result;\n-            }\n-            if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n-                result = Some(ts.sp);\n-            }\n-\n-            bracket_count += match ts.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            }\n-        }\n-    }\n-\n-    // Return the span for the first identifier in the path.\n-    pub fn span_for_first_ident(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0;\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return None;\n-            }\n-            if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n-                return Some(ts.sp);\n-            }\n-\n-            bracket_count += match ts.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            }\n-        }\n-    }\n-\n-    // Return the span for the last ident before a `<` and outside any\n-    // angle brackets, or the last span.\n-    pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        let mut result = None;\n-\n-        // We keep track of the following two counts - the depth of nesting of\n-        // angle brackets, and the depth of nesting of square brackets. For the\n-        // angle bracket count, we only count tokens which occur outside of any\n-        // square brackets (i.e. bracket_count == 0). The intuition here is\n-        // that we want to count angle brackets in the type, but not any which\n-        // could be in expression context (because these could mean 'less than',\n-        // etc.).\n-        let mut angle_count = 0;\n-        let mut bracket_count = 0;\n-        loop {\n-            let next = toks.real_token();\n-\n-            if (next.tok == token::Lt || next.tok == token::Colon) && angle_count == 0\n-                && bracket_count == 0 && prev.tok.is_ident()\n-            {\n-                result = Some(prev.sp);\n-            }\n-\n-            if bracket_count == 0 {\n-                angle_count += match prev.tok {\n-                    token::Lt => 1,\n-                    token::Gt => -1,\n-                    token::BinOp(token::Shl) => 2,\n-                    token::BinOp(token::Shr) => -2,\n-                    _ => 0,\n-                };\n-            }\n-\n-            bracket_count += match prev.tok {\n-                token::OpenDelim(token::Bracket) => 1,\n-                token::CloseDelim(token::Bracket) => -1,\n-                _ => 0,\n-            };\n-\n-            if next.tok == token::Eof {\n-                break;\n-            }\n-            prev = next;\n-        }\n-        #[cfg(debug_assertions)] {\n-            if angle_count != 0 || bracket_count != 0 {\n-                let loc = self.sess.source_map().lookup_char_pos(span.lo());\n-                span_bug!(\n-                    span,\n-                    \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                    self.snippet(span),\n-                    loc.file.name,\n-                    loc.line\n-                );\n-            }\n-        }\n-        if result.is_none() && prev.tok.is_ident() {\n-            return Some(prev.sp);\n-        }\n-        result\n-    }\n-\n-    pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        loop {\n-            if prev.tok == token::Eof {\n-                return None;\n-            }\n-            let next = toks.real_token();\n-            if next.tok == tok {\n-                return Some(prev.sp);\n-            }\n-            prev = next;\n-        }\n-    }\n-\n     pub fn sub_span_of_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n@@ -205,28 +79,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn sub_span_after_keyword(&self, span: Span, keyword: keywords::Keyword) -> Option<Span> {\n-        self.sub_span_after(span, |t| t.is_keyword(keyword))\n-    }\n-\n-    fn sub_span_after<F: Fn(Token) -> bool>(&self, span: Span, f: F) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return None;\n-            }\n-            if f(ts.tok) {\n-                let ts = toks.real_token();\n-                if ts.tok == token::Eof {\n-                    return None;\n-                } else {\n-                    return Some(ts.sp);\n-                }\n-            }\n-        }\n-    }\n-\n     // // Return the name for a macro definition (identifier after first `!`)\n     // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n     //     let mut toks = self.retokenise_span(span);\n@@ -271,42 +123,28 @@ impl<'a> SpanUtils<'a> {\n     ///\n     /// Used to filter out spans of minimal value,\n     /// such as references to macro internal variables.\n-    pub fn filter_generated(&self, sub_span: Option<Span>, parent: Span) -> bool {\n-        if !generated_code(parent) {\n-            // Edge case - this occurs on generated code with incorrect expansion info.\n-            return sub_span.is_none()\n+    pub fn filter_generated(&self, span: Span) -> bool {\n+        if span.is_dummy() {\n+            return true;\n+        }\n+\n+        if !generated_code(span) {\n+            return false;\n         }\n-        // If sub_span is none, filter out generated code.\n-        let sub_span = match sub_span {\n-            Some(ss) => ss,\n-            None => return true,\n-        };\n \n         //If the span comes from a fake source_file, filter it.\n-        if !self.sess\n+        !self.sess\n             .source_map()\n-            .lookup_char_pos(parent.lo())\n+            .lookup_char_pos(span.lo())\n             .file\n             .is_real_file()\n-        {\n-            return true;\n-        }\n-\n-        // Otherwise, a generated span is deemed invalid if it is not a sub-span of the root\n-        // callsite. This filters out macro internal variables and most malformed spans.\n-        !parent.source_callsite().contains(sub_span)\n     }\n }\n \n macro_rules! filter {\n-    ($util: expr, $span: expr, $parent: expr, None) => {\n-        if $util.filter_generated($span, $parent) {\n+    ($util: expr, $parent: expr) => {\n+        if $util.filter_generated($parent) {\n             return None;\n         }\n     };\n-    ($util: expr, $span: ident, $parent: expr) => {\n-        if $util.filter_generated($span, $parent) {\n-            return;\n-        }\n-    };\n }"}]}