{"sha": "060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MGI1YzVlZjI3M2E2Yjc0Y2NiZDEwYzFkNGExZGViZmEyN2Q5ZGU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-11T20:00:07Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-11T22:25:08Z"}, "message": "Factor the `RefCell` out of the `Interner`.", "tree": {"sha": "63c0862d64c7c01fe52a02099e816f644e11aa02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63c0862d64c7c01fe52a02099e816f644e11aa02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "html_url": "https://github.com/rust-lang/rust/commit/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752d4419a060e007548cf56f85ff864a13589567", "url": "https://api.github.com/repos/rust-lang/rust/commits/752d4419a060e007548cf56f85ff864a13589567", "html_url": "https://github.com/rust-lang/rust/commit/752d4419a060e007548cf56f85ff864a13589567"}], "stats": {"total": 107, "additions": 41, "deletions": 66}, "files": [{"sha": "ab7ed223bb31820e23c59b7f2f68f84ce07e1e5b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "patch": "@@ -21,6 +21,7 @@ use util::interner::Interner;\n use tokenstream;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -477,20 +478,20 @@ pub type IdentInterner = Interner;\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n // FIXME(eddyb) #8726 This should probably use a thread-local reference.\n-pub fn with_ident_interner<T, F: FnOnce(&IdentInterner) -> T>(f: F) -> T {\n-    thread_local!(static KEY: IdentInterner = {\n-        mk_fresh_ident_interner()\n+pub fn with_ident_interner<T, F: FnOnce(&mut IdentInterner) -> T>(f: F) -> T {\n+    thread_local!(static KEY: RefCell<IdentInterner> = {\n+        RefCell::new(mk_fresh_ident_interner())\n     });\n-    KEY.with(f)\n+    KEY.with(|interner| f(&mut *interner.borrow_mut()))\n }\n \n /// Reset the ident interner to its initial state.\n pub fn reset_ident_interner() {\n-    with_ident_interner(|interner| interner.reset(mk_fresh_ident_interner()));\n+    with_ident_interner(|interner| *interner = mk_fresh_ident_interner());\n }\n \n pub fn clear_ident_interner() {\n-    with_ident_interner(|interner| interner.clear());\n+    with_ident_interner(|interner| *interner = IdentInterner::new());\n }\n \n /// Represents a string stored in the thread-local interner. Because the"}, {"sha": "6bb409715aa39ce999a502b8fde12b3bde60748c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 34, "deletions": 60, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "patch": "@@ -15,7 +15,6 @@\n use ast::Name;\n \n use std::borrow::Borrow;\n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::rc::Rc;\n \n@@ -28,85 +27,60 @@ impl Borrow<str> for RcStr {\n     }\n }\n \n+#[derive(Default)]\n pub struct Interner {\n-    map: RefCell<HashMap<RcStr, Name>>,\n-    vect: RefCell<Vec<Rc<String>> >,\n+    names: HashMap<RcStr, Name>,\n+    strings: Vec<Rc<String>>,\n }\n \n /// When traits can extend traits, we should extend index<Name,T> to get []\n impl Interner {\n     pub fn new() -> Self {\n-        Interner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n+        Interner::default()\n     }\n \n     pub fn prefill(init: &[&str]) -> Self {\n-        let rv = Interner::new();\n-        for &v in init { rv.intern(v); }\n-        rv\n-    }\n-\n-    pub fn intern<T: Borrow<str> + Into<String>>(&self, val: T) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = map.get(val.borrow()) {\n-            return idx;\n+        let mut this = Interner::new();\n+        for &string in init {\n+            this.intern(string);\n         }\n-\n-        let new_idx = Name(self.len() as u32);\n-        let val = Rc::new(val.into());\n-        map.insert(RcStr(val.clone()), new_idx);\n-        self.vect.borrow_mut().push(val);\n-        new_idx\n+        this\n     }\n \n-    pub fn gensym(&self, val: &str) -> Name {\n-        let new_idx = Name(self.len() as u32);\n-        // leave out of .map to avoid colliding\n-        self.vect.borrow_mut().push(Rc::new(val.to_owned()));\n-        new_idx\n-    }\n-\n-    // I want these gensyms to share name pointers\n-    // with existing entries. This would be automatic,\n-    // except that the existing gensym creates its\n-    // own managed ptr using to_managed. I think that\n-    // adding this utility function is the most\n-    // lightweight way to get what I want, though not\n-    // necessarily the cleanest.\n-\n-    /// Create a gensym with the same name as an existing\n-    /// entry.\n-    pub fn gensym_copy(&self, idx : Name) -> Name {\n-        let new_idx = Name(self.len() as u32);\n-        // leave out of map to avoid colliding\n-        let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect)[idx.0 as usize].clone();\n-        vect.push(existing);\n-        new_idx\n-    }\n+    pub fn intern<T: Borrow<str> + Into<String>>(&mut self, string: T) -> Name {\n+        if let Some(&name) = self.names.get(string.borrow()) {\n+            return name;\n+        }\n \n-    pub fn get(&self, idx: Name) -> Rc<String> {\n-        (*self.vect.borrow())[idx.0 as usize].clone()\n+        let name = Name(self.strings.len() as u32);\n+        let string = Rc::new(string.into());\n+        self.strings.push(string.clone());\n+        self.names.insert(RcStr(string), name);\n+        name\n     }\n \n-    pub fn len(&self) -> usize {\n-        self.vect.borrow().len()\n+    pub fn gensym(&mut self, string: &str) -> Name {\n+        let gensym = Name(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        self.strings.push(Rc::new(string.to_owned()));\n+        gensym\n     }\n \n-    pub fn find(&self, val: &str) -> Option<Name> {\n-        self.map.borrow().get(val).cloned()\n+    /// Create a gensym with the same name as an existing entry.\n+    pub fn gensym_copy(&mut self, name: Name) -> Name {\n+        let gensym = Name(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        let string = self.strings[name.0 as usize].clone();\n+        self.strings.push(string);\n+        gensym\n     }\n \n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n+    pub fn get(&self, name: Name) -> Rc<String> {\n+        self.strings[name.0 as usize].clone()\n     }\n \n-    pub fn reset(&self, other: Interner) {\n-        *self.map.borrow_mut() = other.map.into_inner();\n-        *self.vect.borrow_mut() = other.vect.into_inner();\n+    pub fn find(&self, string: &str) -> Option<Name> {\n+        self.names.get(string).cloned()\n     }\n }\n \n@@ -117,7 +91,7 @@ mod tests {\n \n     #[test]\n     fn interner_tests() {\n-        let i : Interner = Interner::new();\n+        let mut i: Interner = Interner::new();\n         // first one is zero:\n         assert_eq!(i.intern(\"dog\"), Name(0));\n         // re-use gets the same entry:"}]}