{"sha": "618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOGFlZWM1MWY2MWZiNmQ4MGNkNGZkZTllNWZjM2I5NzE0Y2E3MmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2020-07-22T21:51:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2020-07-22T22:05:05Z"}, "message": "Improve codegen for unchecked float casts on wasm\n\nThis commit improves codegen for unchecked casts on WebAssembly targets\nto use the singluar `iNN.trunc_fMM_{u,s}` instructions. Previously rustc\nwould codegen a bare `fptosi` and `fptoui` for float casts but for\nWebAssembly targets the codegen for these instructions is quite large.\nThis large codegen is due to the fact that LLVM can speculate these\ninstructions so the trapping behavior of WebAssembly needs to be\nprotected against in case they're speculated.\n\nThe change here is to update the codegen for the unchecked cast\nintrinsics to have a wasm-specific case where they call the appropriate\nLLVM intrinsic to generate the right wasm instruction. The intrinsic is\nexplicitly opting-in to undefined behavior so a trap here for\nout-of-bounds inputs on wasm should be acceptable.\n\ncc #73591", "tree": {"sha": "d540479224b03ad3ad6d3f1dfc27537bbc765295", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d540479224b03ad3ad6d3f1dfc27537bbc765295"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "html_url": "https://github.com/rust-lang/rust/commit/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e92106d457abd14f82adc29e7f2496861e07916", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e92106d457abd14f82adc29e7f2496861e07916", "html_url": "https://github.com/rust-lang/rust/commit/9e92106d457abd14f82adc29e7f2496861e07916"}], "stats": {"total": 112, "additions": 74, "deletions": 38}, "files": [{"sha": "33a3cdbfa9b443ff638b5e51d4f9c6bd3b851450", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "patch": "@@ -510,6 +510,14 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f64\", fn(t_f64) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f32\", fn(t_f32) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.signed.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.signed.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.signed.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.signed.i64.f64\", fn(t_f64) -> t_i64);\n \n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);"}, {"sha": "11b1c95c58b3e14e10dfb341bb1ccea0752fe4a5", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "patch": "@@ -629,27 +629,24 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n \n             sym::float_to_int_unchecked => {\n-                if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n+                let float_width = match float_type_width(arg_tys[0]) {\n+                    Some(width) => width,\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `float_to_int_unchecked` \\\n                                   intrinsic: expected basic float type, \\\n                                   found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n-                    return;\n-                }\n-                match int_type_width_signed(ret_ty, self.cx) {\n-                    Some((width, signed)) => {\n-                        if signed {\n-                            self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n-                        } else {\n-                            self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n-                        }\n+                                arg_tys[0]\n+                            ),\n+                        );\n+                        return;\n                     }\n+                };\n+                let (width, signed) = match int_type_width_signed(ret_ty, self.cx) {\n+                    Some(pair) => pair,\n                     None => {\n                         span_invalid_monomorphization_error(\n                             tcx.sess,\n@@ -663,7 +660,49 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         );\n                         return;\n                     }\n+                };\n+\n+                // The LLVM backend can reorder and speculate `fptosi` and\n+                // `fptoui`, so on WebAssembly the codegen for this instruction\n+                // is quite heavyweight. To avoid this heavyweight codegen we\n+                // instead use the raw wasm intrinsics which will lower to one\n+                // instruction in WebAssembly (`iNN.trunc_fMM_{s,u}`). This one\n+                // instruction will trap if the operand is out of bounds, but\n+                // that's ok since this intrinsic is UB if the operands are out\n+                // of bounds, so the behavior can be different on WebAssembly\n+                // than other targets.\n+                //\n+                // Note, however, that when the `nontrapping-fptoint` feature is\n+                // enabled in LLVM then LLVM will lower `fptosi` to\n+                // `iNN.trunc_sat_fMM_{s,u}`, so if that's the case we don't\n+                // bother with intrinsics.\n+                let mut result = None;\n+                if self.sess().target.target.arch == \"wasm32\"\n+                    && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+                {\n+                    let name = match (width, float_width, signed) {\n+                        (32, 32, true) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                        (32, 64, true) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                        (64, 32, true) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                        (64, 64, true) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                        (32, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                        (32, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                        (64, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                        (64, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                        _ => None,\n+                    };\n+                    if let Some(name) = name {\n+                        let intrinsic = self.get_intrinsic(name);\n+                        result = Some(self.call(intrinsic, &[args[0].immediate()], None));\n+                    }\n                 }\n+                result.unwrap_or_else(|| {\n+                    if signed {\n+                        self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                    } else {\n+                        self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n+                    }\n+                })\n             }\n \n             sym::discriminant_value => {"}, {"sha": "4e3bfcd439744cb77b60cdbcc8575cb9a4e3441f", "filename": "src/test/codegen/unchecked-float-casts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs?ref=618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "patch": "@@ -2,6 +2,7 @@\n // unchecked intrinsics.\n \n // compile-flags: -C opt-level=3\n+// ignore-wasm32 the wasm target is tested in `wasm_casts_*`\n \n #![crate_type = \"lib\"]\n "}, {"sha": "b7f8522fdfb033664327e8e7a65d84e1730af16c", "filename": "src/test/codegen/wasm_casts_trapping.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs?ref=618aeec51f61fb6d80cd4fde9e5fc3b9714ca72b", "patch": "@@ -38,7 +38,6 @@ pub fn cast_f32_i32(a: f32) -> i32 {\n     a as _\n }\n \n-\n // CHECK-LABEL: @cast_f64_u64\n #[no_mangle]\n pub fn cast_f64_u64(a: f64) -> u64 {\n@@ -84,77 +83,66 @@ pub fn cast_f32_u8(a: f32) -> u8 {\n     a as _\n }\n \n-\n-\n // CHECK-LABEL: @cast_unchecked_f64_i64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_i64(a: f64) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f64_i32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_i32(a: f64) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_i64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_i64(a: f32) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_i32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_i32(a: f32) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }\n \n-\n // CHECK-LABEL: @cast_unchecked_f64_u64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_u64(a: f64) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f64_u32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_u32(a: f64) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_u64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_u64(a: f32) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_u32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_u32(a: f32) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }"}]}