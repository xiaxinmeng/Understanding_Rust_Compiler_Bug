{"sha": "868b7c153ce6797c768cc2c43a564f34615f6f2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGI3YzE1M2NlNjc5N2M3NjhjYzJjNDNhNTY0ZjM0NjE1ZjZmMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-30T01:24:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-30T01:24:37Z"}, "message": "auto merge of #6073 : huonw/rust/core-rust-isaac, r=pcwalton\n\nThis replaces the wrapper around the runtime RNG with a pure Rust implementation of the same algorithm. This is much faster (up to 5x), and is hopefully safer.\r\n\r\nThere is still (a little) room for optimisation: testing by summing 100,000,000 random `u32`s indicates this is about ~~40-50%~~ 10% slower than the pure C implementation (running as standalone executable, not in the runtime).\r\n\r\n(Only 6d50d55 is part of this PR, the first two are from #6058, but are required for the rt rng to be correct to compare against in the tests.)", "tree": {"sha": "0f8cfeca16e6d929fabd3c387295d08669e9fa86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f8cfeca16e6d929fabd3c387295d08669e9fa86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868b7c153ce6797c768cc2c43a564f34615f6f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868b7c153ce6797c768cc2c43a564f34615f6f2d", "html_url": "https://github.com/rust-lang/rust/commit/868b7c153ce6797c768cc2c43a564f34615f6f2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868b7c153ce6797c768cc2c43a564f34615f6f2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ddb8d5cc66941763039d3f727465b7cc34a100", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ddb8d5cc66941763039d3f727465b7cc34a100", "html_url": "https://github.com/rust-lang/rust/commit/f1ddb8d5cc66941763039d3f727465b7cc34a100"}, {"sha": "d4b934bdce53107a0270f97985bc3152c638183e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b934bdce53107a0270f97985bc3152c638183e", "html_url": "https://github.com/rust-lang/rust/commit/d4b934bdce53107a0270f97985bc3152c638183e"}], "stats": {"total": 281, "additions": 234, "deletions": 47}, "files": [{"sha": "9fa099cabbfe9941d1e5579a08817272d1844aa2", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 234, "deletions": 47, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/868b7c153ce6797c768cc2c43a564f34615f6f2d/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868b7c153ce6797c768cc2c43a564f34615f6f2d/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=868b7c153ce6797c768cc2c43a564f34615f6f2d", "patch": "@@ -53,6 +53,7 @@ pub trait Rand {\n }\n \n impl Rand for int {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> int {\n         if int::bits == 32 {\n             rng.next() as int\n@@ -63,30 +64,35 @@ impl Rand for int {\n }\n \n impl Rand for i8 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i8 {\n         rng.next() as i8\n     }\n }\n \n impl Rand for i16 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i16 {\n         rng.next() as i16\n     }\n }\n \n impl Rand for i32 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i32 {\n         rng.next() as i32\n     }\n }\n \n impl Rand for i64 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> i64 {\n         (rng.next() as i64 << 32) | rng.next() as i64\n     }\n }\n \n impl Rand for uint {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> uint {\n         if uint::bits == 32 {\n             rng.next() as uint\n@@ -97,43 +103,50 @@ impl Rand for uint {\n }\n \n impl Rand for u8 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u8 {\n         rng.next() as u8\n     }\n }\n \n impl Rand for u16 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u16 {\n         rng.next() as u16\n     }\n }\n \n impl Rand for u32 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u32 {\n         rng.next()\n     }\n }\n \n impl Rand for u64 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> u64 {\n         (rng.next() as u64 << 32) | rng.next() as u64\n     }\n }\n \n impl Rand for float {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> float {\n         rng.gen::<f64>() as float\n     }\n }\n \n impl Rand for f32 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> f32 {\n         rng.gen::<f64>() as f32\n     }\n }\n \n static scale : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> f64 {\n         let u1 = rng.next() as f64;\n         let u2 = rng.next() as f64;\n@@ -144,12 +157,14 @@ impl Rand for f64 {\n }\n \n impl Rand for char {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> char {\n         rng.next() as char\n     }\n }\n \n impl Rand for bool {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> bool {\n         rng.next() & 1u32 == 1u32\n     }\n@@ -163,6 +178,7 @@ macro_rules! tuple_impl {\n             $( $tyvar : Rand ),*\n             > Rand for ( $( $tyvar ),* , ) {\n \n+            #[inline]\n             fn rand<R: Rng>(_rng: &R) -> ( $( $tyvar ),* , ) {\n                 (\n                     // use the $tyvar's to get the appropriate number of\n@@ -177,7 +193,10 @@ macro_rules! tuple_impl {\n     }\n }\n \n-impl Rand for () { fn rand<R: Rng>(_: &R) -> () { () } }\n+impl Rand for () {\n+    #[inline]\n+    fn rand<R: Rng>(_: &R) -> () { () }\n+}\n tuple_impl!{A}\n tuple_impl!{A, B}\n tuple_impl!{A, B, C}\n@@ -190,6 +209,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> Option<T> {\n         if rng.gen() {\n             Some(rng.gen())\n@@ -200,27 +220,22 @@ impl<T:Rand> Rand for Option<T> {\n }\n \n impl<T: Rand> Rand for ~T {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> ~T { ~rng.gen() }\n }\n \n impl<T: Rand> Rand for @T {\n+    #[inline]\n     fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n }\n \n-#[allow(non_camel_case_types)] // runtime type\n-pub enum rust_rng {}\n-\n #[abi = \"cdecl\"]\n pub mod rustrt {\n     use libc::size_t;\n-    use super::rust_rng;\n \n     pub extern {\n         unsafe fn rand_seed_size() -> size_t;\n         unsafe fn rand_gen_seed(buf: *mut u8, sz: size_t);\n-        unsafe fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n-        unsafe fn rand_next(rng: *rust_rng) -> u32;\n-        unsafe fn rand_free(rng: *rust_rng);\n     }\n }\n \n@@ -420,6 +435,7 @@ pub trait RngUtil {\n /// Extension methods for random number generators\n impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n+    #[inline(always)]\n     fn gen<T: Rand>(&self) -> T {\n         Rand::rand(self)\n     }\n@@ -566,73 +582,191 @@ pub fn rng() -> IsaacRng {\n     IsaacRng::new()\n }\n \n-pub struct IsaacRng {\n-    priv rng: *rust_rng,\n-}\n+static RAND_SIZE_LEN: u32 = 8;\n+static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n-impl Drop for IsaacRng {\n-    fn finalize(&self) {\n-        unsafe {\n-            rustrt::rand_free(self.rng);\n-        }\n-    }\n+/// A random number generator that uses the [ISAAC\n+/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+pub struct IsaacRng {\n+    priv mut cnt: u32,\n+    priv mut rsl: [u32, .. RAND_SIZE],\n+    priv mut mem: [u32, .. RAND_SIZE],\n+    priv mut a: u32,\n+    priv mut b: u32,\n+    priv mut c: u32\n }\n \n pub impl IsaacRng {\n-    priv fn from_rust_rng(rng: *rust_rng) -> IsaacRng {\n-        IsaacRng {\n-            rng: rng\n-        }\n-    }\n-\n-    /// Create an ISAAC random number generator with a system specified seed\n+    /// Create an ISAAC random number generator with a random seed.\n     fn new() -> IsaacRng {\n         IsaacRng::new_seeded(seed())\n     }\n \n-    /**\n-     * Create a random number generator using the specified seed. A generator\n-     * constructed with a given seed will generate the same sequence of values as\n-     * all other generators constructed with the same seed. The seed may be any\n-     * length.\n-     */\n+    /// Create an ISAAC random number generator with a seed. This can be any\n+    /// length, although the maximum number of bytes used is 1024 and any more\n+    /// will be silently ignored. A generator constructed with a given seed\n+    /// will generate the same sequence of values as all other generators\n+    /// constructed with the same seed.\n     fn new_seeded(seed: &[u8]) -> IsaacRng {\n-        unsafe {\n-            do vec::as_imm_buf(seed) |p, sz| {\n-                IsaacRng::from_rust_rng(rustrt::rand_new_seeded(p, sz as size_t))\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+\n+        let array_size = sys::size_of_val(&rng.rsl);\n+        let copy_length = cmp::min(array_size, seed.len());\n+\n+        // manually create a &mut [u8] slice of randrsl to copy into.\n+        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n+        vec::bytes::copy_memory(dest, seed, copy_length);\n+        rng.init(true);\n+        rng\n+    }\n+\n+    /// Create an ISAAC random number generator using the default\n+    /// fixed seed.\n+    fn new_unseeded() -> IsaacRng {\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+        rng.init(false);\n+        rng\n+    }\n+\n+    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n+    /// randomly).\n+    priv fn init(&self, use_rsl: bool) {\n+        macro_rules! init_mut_many (\n+            ($( $var:ident ),* = $val:expr ) => {\n+                let mut $( $var = $val ),*;\n+            }\n+        );\n+        init_mut_many!(a, b, c, d, e, f, g, h = 0x9e3779b9);\n+\n+\n+        macro_rules! mix(\n+            () => {{\n+                a^=b<<11; d+=a; b+=c;\n+                b^=c>>2;  e+=b; c+=d;\n+                c^=d<<8;  f+=c; d+=e;\n+                d^=e>>16; g+=d; e+=f;\n+                e^=f<<10; h+=e; f+=g;\n+                f^=g>>4;  a+=f; g+=h;\n+                g^=h<<8;  b+=g; h+=a;\n+                h^=a>>9;  c+=h; a+=b;\n+            }}\n+        );\n+\n+        for 4.times { mix!(); }\n+\n+        if use_rsl {\n+            macro_rules! memloop (\n+                ($arr:expr) => {{\n+                    for u32::range_step(0, RAND_SIZE, 8) |i| {\n+                        a+=$arr[i  ]; b+=$arr[i+1];\n+                        c+=$arr[i+2]; d+=$arr[i+3];\n+                        e+=$arr[i+4]; f+=$arr[i+5];\n+                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        mix!();\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                    }\n+                }}\n+            );\n+\n+            memloop!(self.rsl);\n+            memloop!(self.mem);\n+        } else {\n+            for u32::range_step(0, RAND_SIZE, 8) |i| {\n+                mix!();\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n             }\n         }\n+\n+        self.isaac();\n     }\n-}\n \n-impl Rng for IsaacRng {\n-    pub fn next(&self) -> u32 {\n-        unsafe {\n-            return rustrt::rand_next(self.rng);\n+    /// Refills the output buffer (`self.rsl`)\n+    #[inline]\n+    priv fn isaac(&self) {\n+        self.c += 1;\n+        // abbreviations\n+        let mut a = self.a, b = self.b + self.c;\n+        let mem = &mut self.mem;\n+        let rsl = &mut self.rsl;\n+\n+        static midpoint: uint =  RAND_SIZE as uint / 2;\n+\n+        macro_rules! ind (($x:expr) => { mem[($x >> 2) & (RAND_SIZE - 1)] });\n+        macro_rules! rngstep(\n+            ($j:expr, $shift:expr) => {{\n+                let base = base + $j;\n+                let mix = if $shift < 0 {\n+                    a >> -$shift as uint\n+                } else {\n+                    a << $shift as uint\n+                };\n+\n+                let x = mem[base  + mr_offset];\n+                a = (a ^ mix) + mem[base + m2_offset];\n+                let y = ind!(x) + a + b;\n+                mem[base + mr_offset] = y;\n+\n+                b = ind!(y >> RAND_SIZE_LEN) + x;\n+                rsl[base + mr_offset] = b;\n+            }}\n+        );\n+\n+        for [(0, midpoint), (midpoint, 0)].each |&(mr_offset, m2_offset)| {\n+            for uint::range_step(0, midpoint, 4) |base| {\n+                rngstep!(0, 13);\n+                rngstep!(1, -6);\n+                rngstep!(2, 2);\n+                rngstep!(3, -16);\n+            }\n         }\n+\n+        self.a = a;\n+        self.b = b;\n+        self.cnt = RAND_SIZE;\n     }\n }\n \n-/// Create a new random seed for IsaacRng::new_seeded\n-pub fn seed() -> ~[u8] {\n-    unsafe {\n-        let n = rustrt::rand_seed_size() as uint;\n-        let mut s = vec::from_elem(n, 0_u8);\n-        do vec::as_mut_buf(s) |p, sz| {\n-            rustrt::rand_gen_seed(p, sz as size_t)\n+impl Rng for IsaacRng {\n+    #[inline(always)]\n+    fn next(&self) -> u32 {\n+        if self.cnt == 0 {\n+            // make some more numbers\n+            self.isaac();\n         }\n-        s\n+        self.cnt -= 1;\n+        self.rsl[self.cnt]\n     }\n }\n \n-struct XorShiftRng {\n+/// An [Xorshift random number\n+/// generator](http://en.wikipedia.org/wiki/Xorshift). Not suitable for\n+/// cryptographic purposes.\n+pub struct XorShiftRng {\n     priv mut x: u32,\n     priv mut y: u32,\n     priv mut z: u32,\n     priv mut w: u32,\n }\n \n impl Rng for XorShiftRng {\n+    #[inline]\n     pub fn next(&self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n@@ -660,7 +794,18 @@ pub impl XorShiftRng {\n     fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n         XorShiftRng { x: x, y: y, z: z, w: w }\n     }\n+}\n \n+/// Create a new random seed.\n+pub fn seed() -> ~[u8] {\n+    unsafe {\n+        let n = rustrt::rand_seed_size() as uint;\n+        let mut s = vec::from_elem(n, 0_u8);\n+        do vec::as_mut_buf(s) |p, sz| {\n+            rustrt::rand_gen_seed(p, sz as size_t)\n+        }\n+        s\n+    }\n }\n \n // used to make space in TLS for a random number generator\n@@ -671,6 +816,7 @@ fn tls_rng_state(_v: @IsaacRng) {}\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * `task_rng().gen::<int>()`.\n  */\n+#[inline]\n pub fn task_rng() -> @IsaacRng {\n     let r : Option<@IsaacRng>;\n     unsafe {\n@@ -690,13 +836,15 @@ pub fn task_rng() -> @IsaacRng {\n \n // Allow direct chaining with `task_rng`\n impl<R: Rng> Rng for @R {\n+    #[inline(always)]\n     fn next(&self) -> u32 { (**self).next() }\n }\n \n /**\n  * Returns a random value of a Rand type, using the task's random number\n  * generator.\n  */\n+#[inline]\n pub fn random<T: Rand>() -> T {\n     (*task_rng()).gen()\n }\n@@ -879,6 +1027,45 @@ mod tests {\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n                      (f32, (f64, (float,)))) = random();\n     }\n+\n+    #[test]\n+    fn compare_isaac_implementation() {\n+        // This is to verify that the implementation of the ISAAC rng is\n+        // correct (i.e. matches the output of the upstream implementation,\n+        // which is in the runtime)\n+        use vec;\n+        use libc::size_t;\n+\n+        #[abi = \"cdecl\"]\n+        mod rustrt {\n+            use libc::size_t;\n+\n+            #[allow(non_camel_case_types)] // runtime type\n+            pub enum rust_rng {}\n+\n+            pub extern {\n+                unsafe fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n+                unsafe fn rand_next(rng: *rust_rng) -> u32;\n+                unsafe fn rand_free(rng: *rust_rng);\n+            }\n+        }\n+\n+        // run against several seeds\n+        for 10.times {\n+            unsafe {\n+                let seed = super::seed();\n+                let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n+                    rustrt::rand_new_seeded(p, sz as size_t)\n+                };\n+                let rng = IsaacRng::new_seeded(seed);\n+\n+                for 10000.times {\n+                    assert_eq!(rng.next(), rustrt::rand_next(rt_rng));\n+                }\n+                rustrt::rand_free(rt_rng);\n+            }\n+        }\n+    }\n }\n \n "}]}