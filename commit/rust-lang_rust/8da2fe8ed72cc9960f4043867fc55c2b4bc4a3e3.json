{"sha": "8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTJmZThlZDcyY2M5OTYwZjQwNDM4NjdmYzU1YzJiNGJjNGEzZTM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-11T14:01:19Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-15T13:28:28Z"}, "message": "Remove interior mutability from TraitDef by turning fields into queries.", "tree": {"sha": "d4bb47bd3744a484078f4b712fce3be859b77ba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4bb47bd3744a484078f4b712fce3be859b77ba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "html_url": "https://github.com/rust-lang/rust/commit/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77b7df33077aedfe8df903f95165872243f4acd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/77b7df33077aedfe8df903f95165872243f4acd4", "html_url": "https://github.com/rust-lang/rust/commit/77b7df33077aedfe8df903f95165872243f4acd4"}], "stats": {"total": 753, "additions": 300, "deletions": 453}, "files": [{"sha": "15c4469b74694c98d3108c0002a9840329f6b53f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -106,6 +106,8 @@ pub enum DepNode<D: Clone + Debug> {\n     UsedTraitImports(D),\n     ConstEval(D),\n     SymbolName(D),\n+    SpecializationGraph(D),\n+    ObjectSafety(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -264,6 +266,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n             ConstEval(ref d) => op(d).map(ConstEval),\n             SymbolName(ref d) => op(d).map(SymbolName),\n+            SpecializationGraph(ref d) => op(d).map(SpecializationGraph),\n+            ObjectSafety(ref d) => op(d).map(ObjectSafety),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             AllLocalTraitImpls => Some(AllLocalTraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),"}, {"sha": "470dcb4bd61e10e431bf8e3392e3734c288081c7", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -409,6 +409,67 @@ RFC. It is, however, [currently unimplemented][iss15872].\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n+E0119: r##\"\n+There are conflicting trait implementations for the same type.\n+Example of erroneous code:\n+\n+```compile_fail,E0119\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo {\n+    value: usize\n+}\n+\n+impl MyTrait for Foo { // error: conflicting implementations of trait\n+                       //        `MyTrait` for type `Foo`\n+    fn get(&self) -> usize { self.value }\n+}\n+```\n+\n+When looking for the implementation for the trait, the compiler finds\n+both the `impl<T> MyTrait for T` where T is all types and the `impl\n+MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n+this is an error. So, when you write:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+This makes the trait implemented on all types in the scope. So if you\n+try to implement it on another one after that, the implementations will\n+conflict. Example:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo;\n+\n+fn main() {\n+    let f = Foo;\n+\n+    f.get(); // the trait is implemented so we can use it\n+}\n+```\n+\"##,\n+\n E0133: r##\"\n Unsafe code was used outside of an unsafe function or block.\n "}, {"sha": "1823373348badfb8ef177602d852f4ed29ff0217", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -619,8 +619,6 @@ pub fn get_vtable_methods<'a, 'tcx>(\n     debug!(\"get_vtable_methods({:?})\", trait_ref);\n \n     supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-\n         let trait_methods = tcx.associated_items(trait_ref.def_id())\n             .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n@@ -782,3 +780,19 @@ impl<'tcx> TraitObligation<'tcx> {\n         ty::Binder(self.predicate.skip_binder().self_ty())\n     }\n }\n+\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        ..*providers\n+    };\n+}\n+\n+pub fn provide_extern(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        ..*providers\n+    };\n+}"}, {"sha": "0e3a53129d157fe2af455cacd25a59597c87b22f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -77,25 +77,6 @@ pub enum MethodViolationCode {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n-        // Because we query yes/no results frequently, we keep a cache:\n-        let def = self.trait_def(trait_def_id);\n-\n-        let result = def.object_safety().unwrap_or_else(|| {\n-            let result = self.object_safety_violations(trait_def_id).is_empty();\n-\n-            // Record just a yes/no result in the cache; this is what is\n-            // queried most frequently. Note that this may overwrite a\n-            // previous result, but always with the same thing.\n-            def.set_object_safety(result);\n-\n-            result\n-        });\n-\n-        debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n-\n-        result\n-    }\n \n     /// Returns the object safety violations that affect\n     /// astconv - currently, Self in supertraits. This is needed\n@@ -391,3 +372,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         error\n     }\n }\n+\n+pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         trait_def_id: DefId)\n+                                         -> bool {\n+    tcx.object_safety_violations(trait_def_id).is_empty()\n+}"}, {"sha": "d6f6350373ad8452d0edeaa5b29e82db302535df", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -1320,23 +1320,10 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = selcx.tcx().trait_def(trait_def_id);\n \n-    if !trait_def.is_complete(selcx.tcx()) {\n-        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-        for item in impl_node.items(selcx.tcx()) {\n-            if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n-                return Some(specialization_graph::NodeItem {\n-                    node: specialization_graph::Node::Impl(impl_def_id),\n-                    item: item,\n-                });\n-            }\n-        }\n-        None\n-    } else {\n-        trait_def\n-            .ancestors(impl_def_id)\n-            .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n-            .next()\n-    }\n+    trait_def\n+        .ancestors(selcx.tcx(), impl_def_id)\n+        .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n+        .next()\n }\n \n // # Cache"}, {"sha": "b3956e813c4b1103bdd26f1258e09f54a41220bf", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -27,6 +27,7 @@ use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n+use std::rc::Rc;\n \n pub mod specialization_graph;\n \n@@ -118,7 +119,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.trait_def(trait_def_id);\n \n-    let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n+    let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n@@ -285,3 +286,50 @@ impl SpecializesCache {\n         self.map.insert((a, b), result);\n     }\n }\n+\n+// Query provider for `specialization_graph_of`.\n+pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                      trait_id: DefId)\n+                                                      -> Rc<specialization_graph::Graph> {\n+    let mut sg = specialization_graph::Graph::new();\n+\n+    for &impl_def_id in tcx.trait_impls_of(trait_id).iter() {\n+        if impl_def_id.is_local() {\n+            // This is where impl overlap checking happens:\n+            let insert_result = sg.insert(tcx, impl_def_id);\n+            // Report error if there was one.\n+            if let Err(overlap) = insert_result {\n+                let mut err = struct_span_err!(tcx.sess,\n+                                               tcx.span_of_impl(impl_def_id).unwrap(),\n+                                               E0119,\n+                                               \"conflicting implementations of trait `{}`{}:\",\n+                                               overlap.trait_desc,\n+                                               overlap.self_desc.clone().map_or(String::new(),\n+                                                                                |ty| {\n+                    format!(\" for type `{}`\", ty)\n+                }));\n+\n+                match tcx.span_of_impl(overlap.with_impl) {\n+                    Ok(span) => {\n+                        err.span_label(span, format!(\"first implementation here\"));\n+                        err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n+                                       format!(\"conflicting implementation{}\",\n+                                                overlap.self_desc\n+                                                    .map_or(String::new(),\n+                                                            |ty| format!(\" for `{}`\", ty))));\n+                    }\n+                    Err(cname) => {\n+                        err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n+        } else {\n+            let parent = tcx.impl_parent(impl_def_id).unwrap_or(trait_id);\n+            sg.record_impl_from_cstore(tcx, parent, impl_def_id)\n+        }\n+    }\n+\n+    Rc::new(sg)\n+}"}, {"sha": "87c98a0ef0ed6daf16839d7a96f712dd99bde1f4", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -12,8 +12,9 @@ use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use traits::{self, Reveal};\n-use ty::{self, TyCtxt, TraitDef, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n+use std::rc::Rc;\n use syntax::ast::Name;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n@@ -301,18 +302,19 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-pub struct Ancestors<'a> {\n-    trait_def: &'a TraitDef,\n+pub struct Ancestors {\n+    trait_def_id: DefId,\n+    specialization_graph: Rc<Graph>,\n     current_source: Option<Node>,\n }\n \n-impl<'a> Iterator for Ancestors<'a> {\n+impl Iterator for Ancestors {\n     type Item = Node;\n     fn next(&mut self) -> Option<Node> {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n-            let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n-            if parent == self.trait_def.def_id {\n+            let parent = self.specialization_graph.parent(cur_impl);\n+            if parent == self.trait_def_id {\n                 self.current_source = Some(Node::Trait(parent));\n             } else {\n                 self.current_source = Some(Node::Impl(parent));\n@@ -336,7 +338,7 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n+impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n@@ -351,9 +353,14 @@ impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors<'a>(trait_def: &'a TraitDef, start_from_impl: DefId) -> Ancestors<'a> {\n+pub fn ancestors(tcx: TyCtxt,\n+                 trait_def_id: DefId,\n+                 start_from_impl: DefId)\n+                 -> Ancestors {\n+    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n     Ancestors {\n-        trait_def: trait_def,\n+        trait_def_id,\n+        specialization_graph,\n         current_source: Some(Node::Impl(start_from_impl)),\n     }\n }"}, {"sha": "188ef289ba9e42ece0540ff1bf86ce9453f953ea", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -18,10 +18,12 @@ use middle::region::RegionMaps;\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n+use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n+use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -98,6 +100,15 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl Key for (DefId, SimplifiedType) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n     fn map_crate(&self) -> CrateNum {\n         self.0.krate\n@@ -391,6 +402,24 @@ impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::relevant_trait_impls_for<'tcx> {\n+    fn describe(tcx: TyCtxt, (def_id, ty): (DefId, SimplifiedType)) -> String {\n+        format!(\"relevant impls for: `({}, {:?})`\", tcx.item_path_str(def_id), ty)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -820,6 +849,13 @@ define_maps! { <'tcx>\n     [] item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n     [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] trait_impls_of: TraitImpls(DefId) -> Rc<Vec<DefId>>,\n+    // Note that TraitDef::for_each_relevant_impl() will do type simplication for you.\n+    [] relevant_trait_impls_for: relevant_trait_impls_for((DefId, SimplifiedType))\n+        -> Rc<Vec<DefId>>,\n+    [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] is_object_safe: ObjectSafety(DefId) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -859,3 +895,7 @@ fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n     DepNode::CrateVariances\n }\n+\n+fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepNode<DefId> {\n+    DepNode::TraitImpls(def_id)\n+}"}, {"sha": "a86d7351ef472be7116ff228da20fcfc47d54c53", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -80,7 +80,7 @@ pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};\n \n-pub use self::trait_def::{TraitDef, TraitFlags};\n+pub use self::trait_def::TraitDef;\n \n pub use self::maps::queries;\n \n@@ -2324,37 +2324,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n-        let def = self.trait_def(trait_def_id);\n-        def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n-    }\n-\n-    /// Populates the type context with all the implementations for the given\n-    /// trait if necessary.\n-    pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n-        if trait_id.is_local() {\n-            return\n-        }\n-\n-        // The type is not local, hence we are reading this out of\n-        // metadata and don't need to track edges.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        let def = self.trait_def(trait_id);\n-        if def.flags.get().intersects(TraitFlags::HAS_REMOTE_IMPLS) {\n-            return;\n-        }\n-\n-        debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n-\n-        for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n-            let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n-\n-            // Record the trait->implementation mapping.\n-            let parent = self.impl_parent(impl_def_id).unwrap_or(trait_id);\n-            def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-        }\n-\n-        def.flags.set(def.flags.get() | TraitFlags::HAS_REMOTE_IMPLS);\n+        self.trait_def(trait_def_id).has_default_impl\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2603,6 +2573,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         adt_dtorck_constraint,\n         def_span,\n         trait_of_item,\n+        trait_impls_of: trait_def::trait_impls_of_provider,\n+        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }\n@@ -2611,6 +2583,8 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         adt_sized_constraint,\n         adt_dtorck_constraint,\n+        trait_impls_of: trait_def::trait_impls_of_provider,\n+        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }"}, {"sha": "b0357a35b8361cad4c374b5f70eeb98faf6350b6", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 78, "deletions": 258, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -8,18 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use traits::{self, specialization_graph};\n-use ty;\n+use hir::def_id::DefId;\n+use traits::specialization_graph;\n use ty::fast_reject;\n-use ty::{Ty, TyCtxt, TraitRef};\n-use std::cell::{Cell, RefCell};\n+use ty::fold::TypeFoldable;\n+use ty::{Ty, TyCtxt};\n+use std::rc::Rc;\n use hir;\n-use util::nodemap::FxHashMap;\n-\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n \n /// A trait's definition with type information.\n pub struct TraitDef {\n@@ -33,40 +28,7 @@ pub struct TraitDef {\n     /// be usable with the sugar (or without it).\n     pub paren_sugar: bool,\n \n-    // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n-    // simplified version of their `Self` type: impls with a simplifiable `Self`\n-    // are stored in `nonblanket_impls` keyed by it, while all other impls are\n-    // stored in `blanket_impls`.\n-    //\n-    // A similar division is used within `specialization_graph`, but the ones\n-    // here are (1) stored as a flat list for the trait and (2) populated prior\n-    // to -- and used while -- determining specialization order.\n-    //\n-    // FIXME: solve the reentrancy issues and remove these lists in favor of the\n-    // ones in `specialization_graph`.\n-    //\n-    // These lists are tracked by `DepNode::TraitImpls`; we don't use\n-    // a DepTrackingMap but instead have the `TraitDef` insert the\n-    // required reads/writes.\n-\n-    /// Impls of the trait.\n-    nonblanket_impls: RefCell<\n-        FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n-    >,\n-\n-    /// Blanket impls associated with the trait.\n-    blanket_impls: RefCell<Vec<DefId>>,\n-\n-    /// The specialization order for impls of this trait.\n-    pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n-\n-    /// Various flags\n-    pub flags: Cell<TraitFlags>,\n-\n-    /// The number of impls we've added from the local crate.\n-    /// When this number matches up the list in the HIR map,\n-    /// we're done, and the specialization graph is correct.\n-    local_impl_count: Cell<usize>,\n+    pub has_default_impl: bool,\n \n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n@@ -77,193 +39,28 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n     pub fn new(def_id: DefId,\n                unsafety: hir::Unsafety,\n                paren_sugar: bool,\n+               has_default_impl: bool,\n                def_path_hash: u64)\n                -> TraitDef {\n         TraitDef {\n-            def_id: def_id,\n-            paren_sugar: paren_sugar,\n-            unsafety: unsafety,\n-            nonblanket_impls: RefCell::new(FxHashMap()),\n-            blanket_impls: RefCell::new(vec![]),\n-            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n-            local_impl_count: Cell::new(0),\n-            specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n-            def_path_hash: def_path_hash,\n-        }\n-    }\n-\n-    // returns None if not yet calculated\n-    pub fn object_safety(&self) -> Option<bool> {\n-        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n-            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n-        } else {\n-            None\n+            def_id,\n+            paren_sugar,\n+            unsafety,\n+            has_default_impl,\n+            def_path_hash,\n         }\n     }\n \n-    pub fn set_object_safety(&self, is_safe: bool) {\n-        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n-        self.flags.set(\n-            self.flags.get() | if is_safe {\n-                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n-            } else {\n-                TraitFlags::OBJECT_SAFETY_VALID\n-            }\n-        );\n-    }\n-\n-    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.write(DepNode::TraitImpls(self.def_id));\n-    }\n-\n-    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.read(DepNode::TraitImpls(self.def_id));\n-    }\n-\n-    /// Records a basic trait-to-implementation mapping.\n-    ///\n-    /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                   impl_def_id: DefId,\n-                   impl_trait_ref: TraitRef<'tcx>)\n-                   -> bool {\n-        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n-               self, impl_trait_ref);\n-\n-        // Record the write into the impl set, but only for local\n-        // impls: external impls are handled differently.\n-        if impl_def_id.is_local() {\n-            self.write_trait_impls(tcx);\n-        }\n-\n-        // We don't want to borrow_mut after we already populated all impls,\n-        // so check if an impl is present with an immutable borrow first.\n-        if let Some(sty) = fast_reject::simplify_type(tcx,\n-                                                      impl_trait_ref.self_ty(), false) {\n-            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n-                if is.contains(&impl_def_id) {\n-                    return false; // duplicate - skip\n-                }\n-            }\n-\n-            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n-        } else {\n-            if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return false; // duplicate - skip\n-            }\n-            self.blanket_impls.borrow_mut().push(impl_def_id)\n-        }\n-\n-        true\n-    }\n-\n-    /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             impl_def_id: DefId,\n-                             impl_trait_ref: TraitRef<'tcx>) {\n-        assert!(impl_def_id.is_local());\n-        let was_new = self.record_impl(tcx, impl_def_id, impl_trait_ref);\n-        assert!(was_new);\n-\n-        self.local_impl_count.set(self.local_impl_count.get() + 1);\n-    }\n-\n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_has_default_impl(&self) {\n-        self.flags.set(self.flags.get() | TraitFlags::HAS_DEFAULT_IMPL);\n-    }\n-\n-    /// Records a trait-to-implementation mapping for a non-local impl.\n-    ///\n-    /// The `parent_impl` is the immediately-less-specialized impl, or the\n-    /// trait's def ID if the impl is not a specialization -- information that\n-    /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              impl_def_id: DefId,\n-                              impl_trait_ref: TraitRef<'tcx>,\n-                              parent_impl: DefId) {\n-        assert!(!impl_def_id.is_local());\n-\n-        // if the impl has not previously been recorded\n-        if self.record_impl(tcx, impl_def_id, impl_trait_ref) {\n-            // if the impl is non-local, it's placed directly into the\n-            // specialization graph using parent information drawn from metadata.\n-            self.specialization_graph.borrow_mut()\n-                .record_impl_from_cstore(tcx, parent_impl, impl_def_id)\n-        }\n-    }\n-\n-    /// Adds a local impl into the specialization graph, returning an error with\n-    /// overlap information if the impl overlaps but does not specialize an\n-    /// existing impl.\n-    pub fn add_impl_for_specialization(&self,\n-                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       impl_def_id: DefId)\n-                                       -> Result<(), traits::OverlapError> {\n-        assert!(impl_def_id.is_local());\n-\n-        self.specialization_graph.borrow_mut()\n-            .insert(tcx, impl_def_id)\n-    }\n-\n-    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a> {\n-        specialization_graph::ancestors(self, of_impl)\n-    }\n-\n-    /// Whether the impl set and specialization graphs are complete.\n-    pub fn is_complete(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-        ty::queries::coherent_trait::try_get(tcx, DUMMY_SP, (LOCAL_CRATE, self.def_id)).is_ok()\n-    }\n-\n-    /// If any local impls haven't been added yet, returns\n-    /// Some(list of local impls for this trait).\n-    fn missing_local_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                           -> Option<&'gcx [ast::NodeId]> {\n-        if self.flags.get().intersects(TraitFlags::HAS_LOCAL_IMPLS) {\n-            return None;\n-        }\n-\n-        if self.is_complete(tcx) {\n-            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n-            return None;\n-        }\n-\n-        let impls = tcx.hir.trait_impls(self.def_id);\n-        assert!(self.local_impl_count.get() <= impls.len());\n-        if self.local_impl_count.get() == impls.len() {\n-            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n-            return None;\n-        }\n-\n-        Some(impls)\n+    pub fn ancestors(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     of_impl: DefId)\n+                     -> specialization_graph::Ancestors {\n+        specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n-        self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-\n-        let local_impls = self.missing_local_impls(tcx);\n-        if let Some(impls) = local_impls {\n-            for &id in impls {\n-                f(tcx.hir.local_def_id(id));\n-            }\n-        }\n-        let mut f = |def_id: DefId| {\n-            if !(local_impls.is_some() && def_id.is_local()) {\n-                f(def_id);\n-            }\n-        };\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+        for &impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n             f(impl_def_id);\n         }\n-\n-        for v in self.nonblanket_impls.borrow().values() {\n-            for &impl_def_id in v {\n-                f(impl_def_id);\n-            }\n-        }\n     }\n \n     /// Iterate over every impl that could possibly match the\n@@ -273,25 +70,6 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {\n-        self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-\n-        let local_impls = self.missing_local_impls(tcx);\n-        if let Some(impls) = local_impls {\n-            for &id in impls {\n-                f(tcx.hir.local_def_id(id));\n-            }\n-        }\n-        let mut f = |def_id: DefId| {\n-            if !(local_impls.is_some() && def_id.is_local()) {\n-                f(def_id);\n-            }\n-        };\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n         // simplify_type(.., false) basically replaces type parameters and\n         // projections with infer-variables. This is, of course, done on\n         // the impl trait-ref when it is instantiated, but not on the\n@@ -304,29 +82,71 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         // replace `S` with anything - this impl of course can't be\n         // selected, and as there are hundreds of similar impls,\n         // considering them would significantly harm performance.\n-        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n-            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n-                for &impl_def_id in impls {\n-                    f(impl_def_id);\n-                }\n-            }\n+        let relevant_impls = if let Some(simplified_self_ty) =\n+                fast_reject::simplify_type(tcx, self_ty, true) {\n+            tcx.relevant_trait_impls_for((self.def_id, simplified_self_ty))\n         } else {\n-            for v in self.nonblanket_impls.borrow().values() {\n-                for &impl_def_id in v {\n-                    f(impl_def_id);\n-                }\n-            }\n+            tcx.trait_impls_of(self.def_id)\n+        };\n+\n+        for &impl_def_id in relevant_impls.iter() {\n+            f(impl_def_id);\n         }\n     }\n }\n \n-bitflags! {\n-    flags TraitFlags: u32 {\n-        const NO_TRAIT_FLAGS        = 0,\n-        const HAS_DEFAULT_IMPL      = 1 << 0,\n-        const IS_OBJECT_SAFE        = 1 << 1,\n-        const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const HAS_REMOTE_IMPLS      = 1 << 3,\n-        const HAS_LOCAL_IMPLS       = 1 << 4,\n+// Query provider for `trait_impls_of`.\n+pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                trait_id: DefId)\n+                                                -> Rc<Vec<DefId>> {\n+    let mut impls = if trait_id.is_local() {\n+        // Traits defined in the current crate can't have impls in upstream\n+        // crates, so we don't bother querying the cstore.\n+        Vec::new()\n+    } else {\n+        tcx.sess.cstore.implementations_of_trait(Some(trait_id))\n+    };\n+\n+    impls.extend(tcx.hir\n+                    .trait_impls(trait_id)\n+                    .iter()\n+                    .map(|&node_id| tcx.hir.local_def_id(node_id))\n+                    .filter(|&impl_def_id| {\n+                        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+                        !trait_ref.references_error()\n+                    }));\n+    Rc::new(impls)\n+}\n+\n+// Query provider for `relevant_trait_impls_for`.\n+pub(super) fn relevant_trait_impls_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    (trait_id, self_ty): (DefId, fast_reject::SimplifiedType))\n+    -> Rc<Vec<DefId>>\n+{\n+    let all_trait_impls = tcx.trait_impls_of(trait_id);\n+\n+    let relevant: Vec<DefId> = all_trait_impls\n+        .iter()\n+        .map(|&impl_def_id| impl_def_id)\n+        .filter(|&impl_def_id| {\n+            let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let impl_simple_self_ty = fast_reject::simplify_type(tcx,\n+                                                                 impl_trait_ref.self_ty(),\n+                                                                 false);\n+            if let Some(impl_simple_self_ty) = impl_simple_self_ty {\n+                impl_simple_self_ty == self_ty\n+            } else {\n+                // blanket impl (?)\n+                true\n+            }\n+        })\n+        .collect();\n+\n+    if all_trait_impls.len() == relevant.len() {\n+        // If we didn't filter anything out, re-use the existing vec.\n+        all_trait_impls\n+    } else {\n+        Rc::new(relevant)\n     }\n }"}, {"sha": "c23563e13be34873b3acfe1a3c22277eed7158eb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n+use rustc::traits;\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n@@ -892,6 +893,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n+    traits::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n@@ -900,6 +902,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     cstore::provide(&mut extern_providers);\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n+    traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);\n "}, {"sha": "941b965d9a4e2bd088fb4febe61605e32d8d9f09", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -505,16 +505,11 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n-        let def = ty::TraitDef::new(self.local_def_id(item_id),\n-                                    data.unsafety,\n-                                    data.paren_sugar,\n-                                    self.def_path_table.def_path_hash(item_id));\n-\n-        if data.has_default_impl {\n-            def.record_has_default_impl();\n-        }\n-\n-        def\n+        ty::TraitDef::new(self.local_def_id(item_id),\n+                          data.unsafety,\n+                          data.paren_sugar,\n+                          data.has_default_impl,\n+                          self.def_path_table.def_path_hash(item_id))\n     }\n \n     fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {"}, {"sha": "6a40174fa0227e6b800688fd9b6bd1a5d8363bd5", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -29,6 +29,7 @@\n \n #![cfg_attr(stage0, unstable(feature = \"rustc_private\", issue = \"27812\"))]\n #![cfg_attr(stage0, feature(staged_api))]\n+#![feature(sort_unstable)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "d304d79bc52c8342b8ce1ad65cf1226f2cfb277a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -1200,7 +1200,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_id: DefId,\n                                            impl_item: &hir::ImplItem)\n {\n-    let ancestors = trait_def.ancestors(impl_id);\n+    let ancestors = trait_def.ancestors(tcx, impl_id);\n \n     let kind = match impl_item.node {\n         hir::ImplItemKind::Const(..) => ty::AssociatedKind::Const,\n@@ -1330,7 +1330,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n-        let is_implemented = trait_def.ancestors(impl_id)\n+        let is_implemented = trait_def.ancestors(tcx, impl_id)\n             .defs(tcx, trait_item.name, trait_item.kind)\n             .next()\n             .map(|node_item| !node_item.node.is_from_trait())"}, {"sha": "165be49f7603de1d73ff00a03519187585980996", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -46,8 +46,6 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n         }\n \n         enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        let trait_def = tcx.trait_def(trait_ref.def_id);\n-        trait_def.record_local_impl(tcx, impl_def_id, trait_ref);\n     }\n }\n \n@@ -117,8 +115,6 @@ pub fn provide(providers: &mut Providers) {\n \n fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             (_, def_id): (CrateNum, DefId)) {\n-    tcx.populate_implementations_for_trait_if_necessary(def_id);\n-\n     let impls = tcx.hir.trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);"}, {"sha": "ba1d7b18e8c7faeb29dcc40e41f84cf13426d211", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -41,39 +41,10 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     let _task =\n         tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n-    let def = tcx.trait_def(trait_def_id);\n-\n-    // attempt to insert into the specialization graph\n-    let insert_result = def.add_impl_for_specialization(tcx, impl_def_id);\n-\n-    // insertion failed due to overlap\n-    if let Err(overlap) = insert_result {\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       tcx.span_of_impl(impl_def_id).unwrap(),\n-                                       E0119,\n-                                       \"conflicting implementations of trait `{}`{}:\",\n-                                       overlap.trait_desc,\n-                                       overlap.self_desc.clone().map_or(String::new(),\n-                                                                        |ty| {\n-            format!(\" for type `{}`\", ty)\n-        }));\n-\n-        match tcx.span_of_impl(overlap.with_impl) {\n-            Ok(span) => {\n-                err.span_label(span, \"first implementation here\");\n-                err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n-                               format!(\"conflicting implementation{}\",\n-                                        overlap.self_desc\n-                                            .map_or(String::new(),\n-                                                    |ty| format!(\" for `{}`\", ty))));\n-            }\n-            Err(cname) => {\n-                err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-            }\n-        }\n+    // Trigger building the specialization graph for the trait of this impl.\n+    // This will detect any overlap errors.\n+    tcx.specialization_graph_of(trait_def_id);\n \n-        err.emit();\n-    }\n \n     // check for overlap with the automatic `impl Trait for Trait`\n     if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {"}, {"sha": "cb1bd3e099d54c31ef6b468cf0cc619a1cb69e4a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -749,12 +749,12 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let def_path_hash = tcx.def_path_hash(def_id);\n-    let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash);\n-\n-    if tcx.hir.trait_is_auto(def_id) {\n-        def.record_has_default_impl();\n-    }\n-\n+    let has_default_impl = tcx.hir.trait_is_auto(def_id);\n+    let def = ty::TraitDef::new(def_id,\n+                                unsafety,\n+                                paren_sugar,\n+                                has_default_impl,\n+                                def_path_hash);\n     tcx.alloc_trait_def(def)\n }\n "}, {"sha": "f9ebe3fff5beb951478ecbe9f8442cc48b8cf679", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=8da2fe8ed72cc9960f4043867fc55c2b4bc4a3e3", "patch": "@@ -1524,67 +1524,6 @@ impl TypeWrapper {\n ```\n \"##,\n \n-E0119: r##\"\n-There are conflicting trait implementations for the same type.\n-Example of erroneous code:\n-\n-```compile_fail,E0119\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo {\n-    value: usize\n-}\n-\n-impl MyTrait for Foo { // error: conflicting implementations of trait\n-                       //        `MyTrait` for type `Foo`\n-    fn get(&self) -> usize { self.value }\n-}\n-```\n-\n-When looking for the implementation for the trait, the compiler finds\n-both the `impl<T> MyTrait for T` where T is all types and the `impl\n-MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n-this is an error. So, when you write:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-```\n-\n-This makes the trait implemented on all types in the scope. So if you\n-try to implement it on another one after that, the implementations will\n-conflict. Example:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo;\n-\n-fn main() {\n-    let f = Foo;\n-\n-    f.get(); // the trait is implemented so we can use it\n-}\n-```\n-\"##,\n-\n E0120: r##\"\n An attempt was made to implement Drop on a trait, which is not allowed: only\n structs and enums can implement Drop. An example causing this error:"}]}