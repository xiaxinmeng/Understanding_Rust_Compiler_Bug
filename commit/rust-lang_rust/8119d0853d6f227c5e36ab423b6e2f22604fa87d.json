{"sha": "8119d0853d6f227c5e36ab423b6e2f22604fa87d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMTlkMDg1M2Q2ZjIyN2M1ZTM2YWI0MjNiNmUyZjIyNjA0ZmE4N2Q=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-19T00:35:47Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-28T19:37:59Z"}, "message": "Track all predicates in errors, not just trait obligations\n\nSurface associated type projection bounds that could not be fulfilled in\nE0599 errors. Always present the list of unfulfilled trait bounds,\nregardless of whether we're pointing at the ADT or trait that didn't\nsatisfy it.", "tree": {"sha": "18d6127a160b0e44ed86f433f54bc488ad3eeb22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18d6127a160b0e44ed86f433f54bc488ad3eeb22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8119d0853d6f227c5e36ab423b6e2f22604fa87d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8119d0853d6f227c5e36ab423b6e2f22604fa87d", "html_url": "https://github.com/rust-lang/rust/commit/8119d0853d6f227c5e36ab423b6e2f22604fa87d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8119d0853d6f227c5e36ab423b6e2f22604fa87d/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad4777dbca1d4d1b052db01b1191862c9fbbad64", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4777dbca1d4d1b052db01b1191862c9fbbad64", "html_url": "https://github.com/rust-lang/rust/commit/ad4777dbca1d4d1b052db01b1191862c9fbbad64"}], "stats": {"total": 237, "additions": 134, "deletions": 103}, "files": [{"sha": "77c612cf34abd2937b985f305f3aea178f166302", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -581,6 +581,20 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n+    pub fn borrow_nested_obligations(&self) -> &[N] {\n+        match &self {\n+            VtableImpl(i) => &i.nested[..],\n+            VtableParam(n) => &n[..],\n+            VtableBuiltin(i) => &i.nested[..],\n+            VtableAutoImpl(d) => &d.nested[..],\n+            VtableClosure(c) => &c.nested[..],\n+            VtableGenerator(c) => &c.nested[..],\n+            VtableObject(d) => &d.nested[..],\n+            VtableFnPointer(d) => &d.nested[..],\n+            VtableTraitAlias(d) => &d.nested[..],\n+        }\n+    }\n+\n     pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n     where\n         F: FnMut(N) -> M,"}, {"sha": "fd85397760af7b8aba57116e66a30d3e9561ca8f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -14,7 +14,7 @@ use crate::check::FnCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n-use rustc::ty::{self, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TypeFoldable, WithConstness};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TypeFoldable, WithConstness};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -67,7 +67,7 @@ pub enum MethodError<'tcx> {\n // could lead to matches if satisfied, and a list of not-in-scope traits which may work.\n pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n-    pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n+    pub unsatisfied_predicates: Vec<ty::Predicate<'tcx>>,\n     pub out_of_scope_traits: Vec<DefId>,\n     pub lev_candidate: Option<ty::AssocItem>,\n     pub mode: probe::Mode,\n@@ -76,7 +76,7 @@ pub struct NoMatchData<'tcx> {\n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(\n         static_candidates: Vec<CandidateSource>,\n-        unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n+        unsatisfied_predicates: Vec<ty::Predicate<'tcx>>,\n         out_of_scope_traits: Vec<DefId>,\n         lev_candidate: Option<ty::AssocItem>,\n         mode: probe::Mode,"}, {"sha": "4f729c593cba483d76f2ce5d92637c7b977df56a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 35, "deletions": 45, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -14,8 +14,7 @@ use rustc::session::config::nightly_options;\n use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n use rustc::ty::{\n-    self, ParamEnvAnd, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n-    WithConstness,\n+    self, ParamEnvAnd, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -78,7 +77,7 @@ struct ProbeContext<'a, 'tcx> {\n \n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n-    unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n+    unsatisfied_predicates: Vec<ty::Predicate<'tcx>>,\n \n     is_suggestion: IsSuggestion,\n }\n@@ -1224,7 +1223,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &self,\n         self_ty: Ty<'tcx>,\n         probes: ProbesIter,\n-        possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>,\n+        possibly_unsatisfied_predicates: &mut Vec<ty::Predicate<'tcx>>,\n         unstable_candidates: Option<&mut Vec<(&'b Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>>\n     where\n@@ -1343,7 +1342,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &self,\n         self_ty: Ty<'tcx>,\n         probe: &Candidate<'tcx>,\n-        possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>,\n+        possibly_unsatisfied_predicates: &mut Vec<ty::Predicate<'tcx>>,\n     ) -> ProbeResult {\n         debug!(\"consider_probe: self_ty={:?} probe={:?}\", self_ty, probe);\n \n@@ -1398,47 +1397,40 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let predicate = trait_ref.without_const().to_predicate();\n                     let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n-                        if self.probe(|_| self.select_trait_candidate(trait_ref).is_err()) {\n+                        if self.probe(|_| {\n+                            match self.select_trait_candidate(trait_ref) {\n+                                Err(_) => return true,\n+                                Ok(Some(vtable))\n+                                    if !vtable.borrow_nested_obligations().is_empty() =>\n+                                {\n+                                    for obligation in vtable.borrow_nested_obligations() {\n+                                        // Determine exactly which obligation wasn't met, so\n+                                        // that we can give more context in the error.\n+                                        if !self.predicate_may_hold(&obligation) {\n+                                            result = ProbeResult::NoMatch;\n+                                            let o = self.resolve_vars_if_possible(obligation);\n+                                            possibly_unsatisfied_predicates.push(o.predicate);\n+                                        }\n+                                    }\n+                                }\n+                                _ => {\n+                                    // Some nested subobligation of this predicate\n+                                    // failed.\n+                                    //\n+                                    // FIXME: try to find the exact nested subobligation\n+                                    // and point at it rather than reporting the entire\n+                                    // trait-ref?\n+                                    result = ProbeResult::NoMatch;\n+                                    let predicate = self.resolve_vars_if_possible(&predicate);\n+                                    possibly_unsatisfied_predicates.push(predicate);\n+                                }\n+                            }\n+                            false\n+                        }) {\n                             // This candidate's primary obligation doesn't even\n                             // select - don't bother registering anything in\n                             // `potentially_unsatisfied_predicates`.\n                             return ProbeResult::NoMatch;\n-                        } else {\n-                            self.probe(|_| {\n-                                match self.select_trait_candidate(trait_ref) {\n-                                    Ok(Some(traits::VtableImpl(traits::VtableImplData {\n-                                        nested,\n-                                        ..\n-                                    }))) if !nested.is_empty() => {\n-                                        for obligation in nested {\n-                                            // Determine exactly which obligation wasn't met, so\n-                                            // that we can give more context in the error.\n-                                            if !self.predicate_may_hold(&obligation) {\n-                                                result = ProbeResult::NoMatch;\n-                                                if let Some(poly_trait_ref) =\n-                                                    obligation.predicate.to_opt_poly_trait_ref()\n-                                                {\n-                                                    let trait_ref = poly_trait_ref.clone();\n-                                                    let trait_ref = trait_ref.skip_binder();\n-                                                    possibly_unsatisfied_predicates\n-                                                        .push(*trait_ref);\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        // Some nested subobligation of this predicate\n-                                        // failed.\n-                                        //\n-                                        // FIXME: try to find the exact nested subobligation\n-                                        // and point at it rather than reporting the entire\n-                                        // trait-ref?\n-                                        result = ProbeResult::NoMatch;\n-                                        let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n-                                        possibly_unsatisfied_predicates.push(trait_ref);\n-                                    }\n-                                }\n-                            });\n                         }\n                     }\n                     vec![]\n@@ -1455,9 +1447,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n-                    if let &ty::Predicate::Trait(ref pred, _) = &o.predicate {\n-                        possibly_unsatisfied_predicates.push(pred.skip_binder().trait_ref);\n-                    }\n+                    possibly_unsatisfied_predicates.push(o.predicate);\n                 }\n             }\n "}, {"sha": "6edceeb15b3de8434542152796b242e0dea91a9c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -535,57 +535,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if !unsatisfied_predicates.is_empty() {\n+                    let def_span =\n+                        |def_id| self.tcx.sess.source_map().def_span(self.tcx.def_span(def_id));\n                     let mut bound_spans = vec![];\n                     let mut bound_list = unsatisfied_predicates\n                         .iter()\n-                        .filter_map(|p| {\n-                            let self_ty = p.self_ty();\n-                            match &self_ty.kind {\n-                                ty::Adt(def, _) => {\n-                                    bound_spans.push((\n-                                        self.tcx\n-                                            .sess\n-                                            .source_map()\n-                                            .def_span(self.tcx.def_span(def.did)),\n-                                        format!(\n-                                            \"the method `{}` exists but this type doesn't satisfy \\\n-                                             the bound `{}: {}`\",\n-                                            item_name,\n-                                            p.self_ty(),\n-                                            p.print_only_trait_path()\n-                                        ),\n-                                    ));\n-                                    None\n-                                }\n-                                ty::Dynamic(preds, _) => {\n-                                    for pred in *preds.skip_binder() {\n-                                        match pred {\n-                                            ty::ExistentialPredicate::Trait(tr) => bound_spans\n-                                                .push((\n-                                                    self.tcx\n-                                                        .sess\n-                                                        .source_map()\n-                                                        .def_span(self.tcx.def_span(tr.def_id)),\n-                                                    format!(\n-                                                        \"the method `{}` exists but this trait \\\n-                                                         doesn't satisfy the bound `{}: {}`\",\n-                                                        item_name,\n-                                                        p.self_ty(),\n-                                                        p.print_only_trait_path()\n-                                                    ),\n-                                                )),\n-                                            ty::ExistentialPredicate::Projection(_)\n-                                            | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                        .filter_map(|pred| match pred {\n+                            ty::Predicate::Projection(pred) => {\n+                                // `<Foo as Iterator>::Item = String`.\n+                                let trait_ref =\n+                                    pred.skip_binder().projection_ty.trait_ref(self.tcx);\n+                                let assoc = self\n+                                    .tcx\n+                                    .associated_item(pred.skip_binder().projection_ty.item_def_id);\n+                                let ty = pred.skip_binder().ty;\n+                                Some(format!(\"`{}::{} = {}`\", trait_ref, assoc.ident, ty))\n+                            }\n+                            ty::Predicate::Trait(poly_trait_ref, _) => {\n+                                let p = poly_trait_ref.skip_binder().trait_ref;\n+                                let self_ty = p.self_ty();\n+                                let path = p.print_only_trait_path();\n+                                match &self_ty.kind {\n+                                    ty::Adt(def, _) => {\n+                                        // Point at the type that couldn't satisfy the bound.\n+                                        bound_spans.push((\n+                                            def_span(def.did),\n+                                            format!(\"doesn't satisfy `{}: {}`\", self_ty, path),\n+                                        ));\n+                                    }\n+                                    ty::Dynamic(preds, _) => {\n+                                        // Point at the trait object that couldn't satisfy the bound.\n+                                        for pred in *preds.skip_binder() {\n+                                            match pred {\n+                                                ty::ExistentialPredicate::Trait(tr) => bound_spans\n+                                                    .push((\n+                                                        def_span(tr.def_id),\n+                                                        format!(\n+                                                            \"doesn't satisfy `{}: {}`\",\n+                                                            self_ty, path\n+                                                        ),\n+                                                    )),\n+                                                ty::ExistentialPredicate::Projection(_)\n+                                                | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                                            }\n                                         }\n                                     }\n-                                    None\n+                                    _ => {}\n                                 }\n-                                _ => Some(format!(\n-                                    \"`{}: {}`\",\n-                                    p.self_ty(),\n-                                    p.print_only_trait_path()\n-                                )),\n+                                Some(format!(\"`{}: {}`\", self_ty, path))\n                             }\n+                            _ => None,\n                         })\n                         .collect::<Vec<_>>();\n                     bound_list.sort();"}, {"sha": "3ed726dea35b6d8f1a1e944988f0ba3d54598391", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,11 +5,13 @@ LL | struct Bar<T: Foo> {\n    | ------------------ method `clone` not found for this\n ...\n LL | struct NotClone;\n-   | ---------------- the method `clone` exists but this type doesn't satisfy the bound `NotClone: std::clone::Clone`\n+   | ---------------- doesn't satisfy `NotClone: std::clone::Clone`\n ...\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method not found in `Bar<NotClone>`\n    |\n+   = note: the method `clone` exists but the following trait bounds were not satisfied:\n+           `NotClone: std::clone::Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "d5e3cf48f38eb652f4eca4fab481cd7f7d097258", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -16,7 +16,11 @@ LL |         .collect();\n   ::: $SRC_DIR/libcore/iter/adapters/mod.rs:LL:COL\n    |\n LL | pub struct Cloned<I> {\n-   | -------------------- the method `collect` exists but this type doesn't satisfy the bound `std::iter::Cloned<std::iter::TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:10:39: 13:6 found_e:_]>>: std::iter::Iterator`\n+   | -------------------- doesn't satisfy `std::iter::Cloned<std::iter::TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:10:39: 13:6 found_e:_]>>: std::iter::Iterator`\n+   |\n+   = note: the method `collect` exists but the following trait bounds were not satisfied:\n+           `<std::iter::TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:10:39: 13:6 found_e:_]> as std::iter::Iterator>::Item = &_`\n+           `std::iter::Cloned<std::iter::TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:10:39: 13:6 found_e:_]>>: std::iter::Iterator`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "63359be56bf419d15c40cfa75b401d4cd624c9a5", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,6 +5,7 @@ LL |     let _result = &Some(42).as_deref();\n    |                             ^^^^^^^^ help: there is a method with a similar name: `as_ref`\n    |\n    = note: the method `as_deref` exists but the following trait bounds were not satisfied:\n+           `<{integer} as std::ops::Deref>::Target = _`\n            `{integer}: std::ops::Deref`\n \n error: aborting due to previous error"}, {"sha": "b01b3448e17fd728fd8c153864cd4a04d0513366", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref_mut.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,6 +5,7 @@ LL |     let _result = &mut Some(42).as_deref_mut();\n    |                                 ^^^^^^^^^^^^ method not found in `std::option::Option<{integer}>`\n    |\n    = note: the method `as_deref_mut` exists but the following trait bounds were not satisfied:\n+           `<{integer} as std::ops::Deref>::Target = _`\n            `{integer}: std::ops::DerefMut`\n \n error: aborting due to previous error"}, {"sha": "754828419872b9ad33ea6783ecc5b6f72ffd4764", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,6 +5,7 @@ LL |     let _result = &Ok(42).as_deref();\n    |                           ^^^^^^^^ help: there is a method with a similar name: `as_ref`\n    |\n    = note: the method `as_deref` exists but the following trait bounds were not satisfied:\n+           `<{integer} as std::ops::Deref>::Target = _`\n            `{integer}: std::ops::Deref`\n \n error: aborting due to previous error"}, {"sha": "cf31bc4b56bf8001c34937d457f9def4ebebb616", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_err.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,6 +5,7 @@ LL |     let _result = &Err(41).as_deref_err();\n    |                            ^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut`\n    |\n    = note: the method `as_deref_err` exists but the following trait bounds were not satisfied:\n+           `<{integer} as std::ops::Deref>::Target = _`\n            `{integer}: std::ops::Deref`\n \n error: aborting due to previous error"}, {"sha": "586b35554553ef1a70ae4b1eaa585c456b5d31cc", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,6 +5,7 @@ LL |     let _result = &mut Ok(42).as_deref_mut();\n    |                               ^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_err`\n    |\n    = note: the method `as_deref_mut` exists but the following trait bounds were not satisfied:\n+           `<{integer} as std::ops::Deref>::Target = _`\n            `{integer}: std::ops::DerefMut`\n \n error: aborting due to previous error"}, {"sha": "fd0e43d7dbc15fc48d5a3f59b875b7f7e9dfe218", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_err.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -5,6 +5,7 @@ LL |     let _result = &mut Err(41).as_deref_mut_err();\n    |                                ^^^^^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut`\n    |\n    = note: the method `as_deref_mut_err` exists but the following trait bounds were not satisfied:\n+           `<{integer} as std::ops::Deref>::Target = _`\n            `{integer}: std::ops::DerefMut`\n \n error: aborting due to previous error"}, {"sha": "b0d747d201d3f74c5d767bf091b9c72125c09317", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -38,11 +38,13 @@ LL | pub struct Foo;\n    | ---------------\n    | |\n    | method `take` not found for this\n-   | the method `take` exists but this type doesn't satisfy the bound `Foo: std::iter::Iterator`\n+   | doesn't satisfy `Foo: std::iter::Iterator`\n ...\n LL |      .take()\n    |       ^^^^ method not found in `Foo`\n    |\n+   = note: the method `take` exists but the following trait bounds were not satisfied:\n+           `Foo: std::iter::Iterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `take`, perhaps you need to implement one of them:\n            candidate #1: `std::io::Read`"}, {"sha": "5f3353c89ccbe27ec8c52e79773442a3a9b6a10c", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -7,10 +7,12 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n   ::: $SRC_DIR/libcore/iter/adapters/mod.rs:LL:COL\n    |\n LL | pub struct Filter<I, P> {\n-   | ----------------------- the method `count` exists but this type doesn't satisfy the bound `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:11:39: 11:53]>: std::iter::Iterator`\n+   | ----------------------- doesn't satisfy `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:11:39: 11:53]>: std::iter::Iterator`\n    |\n    = note: the method `count` exists but the following trait bounds were not satisfied:\n-           `[closure@$DIR/issue-36053-2.rs:11:39: 11:53]: std::ops::FnMut<(&_,)>`\n+           `<[closure@$DIR/issue-36053-2.rs:11:39: 11:53] as std::ops::FnOnce<(&&str,)>>::Output = bool`\n+           `[closure@$DIR/issue-36053-2.rs:11:39: 11:53]: std::ops::FnMut<(&&str,)>`\n+           `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:11:39: 11:53]>: std::iter::Iterator`\n \n error[E0631]: type mismatch in closure arguments\n   --> $DIR/issue-36053-2.rs:11:32"}, {"sha": "5ab191b9270491a4cb5a47a4953126ec1c5b2e4a", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -2,10 +2,13 @@ error[E0599]: no method named `unwrap` found for enum `std::result::Result<(), F\n   --> $DIR/method-help-unsatisfied-bound.rs:5:7\n    |\n LL | struct Foo;\n-   | ----------- the method `unwrap` exists but this type doesn't satisfy the bound `Foo: std::fmt::Debug`\n+   | ----------- doesn't satisfy `Foo: std::fmt::Debug`\n ...\n LL |     a.unwrap();\n    |       ^^^^^^ method not found in `std::result::Result<(), Foo>`\n+   |\n+   = note: the method `unwrap` exists but the following trait bounds were not satisfied:\n+           `Foo: std::fmt::Debug`\n \n error: aborting due to previous error\n "}, {"sha": "14f37150c80704d5605e60b90fe09f41cda940d4", "filename": "src/test/ui/specialization/defaultimpl/specialization-trait-not-implemented.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -8,11 +8,13 @@ LL | struct MyStruct;\n    | ----------------\n    | |\n    | method `foo_one` not found for this\n-   | the method `foo_one` exists but this type doesn't satisfy the bound `MyStruct: Foo`\n+   | doesn't satisfy `MyStruct: Foo`\n ...\n LL |     println!(\"{}\", MyStruct.foo_one());\n    |                             ^^^^^^^ method not found in `MyStruct`\n    |\n+   = note: the method `foo_one` exists but the following trait bounds were not satisfied:\n+           `MyStruct: Foo`\n    = help: items from traits can only be used if the trait is implemented and in scope\n \n error: aborting due to previous error"}, {"sha": "2051ea33391931df1221589212288141967f9f27", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -14,11 +14,13 @@ LL | union U5<T> {\n    | ----------- method `clone` not found for this\n ...\n LL | struct CloneNoCopy;\n-   | ------------------- the method `clone` exists but this type doesn't satisfy the bound `CloneNoCopy: std::marker::Copy`\n+   | ------------------- doesn't satisfy `CloneNoCopy: std::marker::Copy`\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method not found in `U5<CloneNoCopy>`\n    |\n+   = note: the method `clone` exists but the following trait bounds were not satisfied:\n+           `CloneNoCopy: std::marker::Copy`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "f230d0d14d25a9cf57175dfa5bec4d759e4beec3", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -4,12 +4,15 @@ error[E0599]: no method named `clone` found for struct `std::boxed::Box<dyn Foo>\n LL | trait Foo {\n    | ---------\n    | |\n-   | the method `clone` exists but this trait doesn't satisfy the bound `dyn Foo: std::clone::Clone`\n-   | the method `clone` exists but this trait doesn't satisfy the bound `dyn Foo: std::marker::Sized`\n+   | doesn't satisfy `dyn Foo: std::clone::Clone`\n+   | doesn't satisfy `dyn Foo: std::marker::Sized`\n ...\n LL |     let _z = y.clone();\n    |                ^^^^^ method not found in `std::boxed::Box<dyn Foo>`\n    |\n+   = note: the method `clone` exists but the following trait bounds were not satisfied:\n+           `dyn Foo: std::clone::Clone`\n+           `dyn Foo: std::marker::Sized`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "12d719a10279658931c45d53ad12c4eafef2682c", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8119d0853d6f227c5e36ab423b6e2f22604fa87d/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=8119d0853d6f227c5e36ab423b6e2f22604fa87d", "patch": "@@ -2,11 +2,13 @@ error[E0599]: no method named `clone` found for struct `std::boxed::Box<R>` in t\n   --> $DIR/unique-pinned-nocopy.rs:12:16\n    |\n LL | struct R {\n-   | -------- the method `clone` exists but this type doesn't satisfy the bound `R: std::clone::Clone`\n+   | -------- doesn't satisfy `R: std::clone::Clone`\n ...\n LL |     let _j = i.clone();\n    |                ^^^^^ method not found in `std::boxed::Box<R>`\n    |\n+   = note: the method `clone` exists but the following trait bounds were not satisfied:\n+           `R: std::clone::Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}]}