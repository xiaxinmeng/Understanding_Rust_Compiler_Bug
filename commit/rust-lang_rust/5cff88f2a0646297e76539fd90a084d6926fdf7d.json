{"sha": "5cff88f2a0646297e76539fd90a084d6926fdf7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZmY4OGYyYTA2NDYyOTdlNzY1MzlmZDkwYTA4NGQ2OTI2ZmRmN2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-21T12:16:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:44:05Z"}, "message": "add a higher-ranked match routine\n\nCurrently, when projecting out of a higher-ranked where-clause, we\ninstantiate all higher-ranked regions with lifetime variables. This is\nunnecessary since the language rules ought to guarantee (modulo #32330)\nthat each of those higher-ranked regions is equated with some regions\nfrom the input types. This routine figures out what those regions are\nand just uses them. Also, since #32330 is not fully fixed, it detects\nwhen we may have unconstrained variables and indicates that in its\nreturn value.", "tree": {"sha": "f7bdd28609a873f70925b5dba7d761dd1e913d85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7bdd28609a873f70925b5dba7d761dd1e913d85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cff88f2a0646297e76539fd90a084d6926fdf7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cff88f2a0646297e76539fd90a084d6926fdf7d", "html_url": "https://github.com/rust-lang/rust/commit/5cff88f2a0646297e76539fd90a084d6926fdf7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cff88f2a0646297e76539fd90a084d6926fdf7d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b40529c5a9201efccead746e4c01f22dcbb89c8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b40529c5a9201efccead746e4c01f22dcbb89c8c", "html_url": "https://github.com/rust-lang/rust/commit/b40529c5a9201efccead746e4c01f22dcbb89c8c"}], "stats": {"total": 177, "additions": 177, "deletions": 0}, "files": [{"sha": "84b72d9be60a1d3f71d573e27615d695c5e88e5d", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5cff88f2a0646297e76539fd90a084d6926fdf7d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cff88f2a0646297e76539fd90a084d6926fdf7d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5cff88f2a0646297e76539fd90a084d6926fdf7d", "patch": "@@ -15,6 +15,7 @@ use super::{CombinedSnapshot,\n             InferCtxt,\n             LateBoundRegion,\n             HigherRankedType,\n+            SubregionOrigin,\n             SkolemizationMap};\n use super::combine::CombineFields;\n use super::region_inference::{TaintDirections};\n@@ -25,6 +26,19 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n+pub struct HrMatchResult<U> {\n+    pub value: U,\n+\n+    /// Normally, when we do a higher-ranked match operation, we\n+    /// expect all higher-ranked regions to be constrained as part of\n+    /// the match operation. However, in the transition period for\n+    /// #32330, it can happen that we sometimes have unconstrained\n+    /// regions that get instantiated with fresh variables. In that\n+    /// case, we collect the set of unconstrained bound regions here\n+    /// and replace them with fresh variables.\n+    pub unconstrained_regions: Vec<ty::BoundRegion>,\n+}\n+\n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n                                 -> RelateResult<'tcx, Binder<T>>\n@@ -79,6 +93,134 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         });\n     }\n \n+    /// The value consists of a pair `(t, u)` where `t` is the\n+    /// *matcher* and `u` is a *value*. The idea is to find a\n+    /// substitution `S` such that `S(t) == b`, and then return\n+    /// `S(u)`. In other words, find values for the late-bound regions\n+    /// in `a` that can make `t == b` and then replace the LBR in `u`\n+    /// with those values.\n+    ///\n+    /// This routine is (as of this writing) used in trait matching,\n+    /// particularly projection.\n+    ///\n+    /// NB. It should not happen that there are LBR appearing in `U`\n+    /// that do not appear in `T`. If that happens, those regions are\n+    /// unconstrained, and this routine replaces them with `'static`.\n+    pub fn higher_ranked_match<T, U>(&self,\n+                                     span: Span,\n+                                     a_pair: &Binder<(T, U)>,\n+                                     b_match: &T)\n+                                     -> RelateResult<'tcx, HrMatchResult<U>>\n+        where T: Relate<'tcx>,\n+              U: TypeFoldable<'tcx>\n+    {\n+        debug!(\"higher_ranked_match(a={:?}, b={:?})\",\n+               a_pair, b_match);\n+\n+        // Start a snapshot so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        return self.infcx.commit_if_ok(|snapshot| {\n+            // First, we instantiate each bound region in the matcher\n+            // with a skolemized region.\n+            let ((a_match, a_value), skol_map) =\n+                self.infcx.skolemize_late_bound_regions(a_pair, snapshot);\n+\n+            debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n+            debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n+\n+            // Equate types now that bound regions have been replaced.\n+            try!(self.equate().relate(&a_match, &b_match));\n+\n+            // Map each skolemized region to a vector of other regions that it\n+            // must be equated with. (Note that this vector may include other\n+            // skolemized regions from `skol_map`.)\n+            let skol_resolution_map: FnvHashMap<_, _> =\n+                skol_map\n+                .iter()\n+                .map(|(&br, &skol)| {\n+                    let tainted_regions =\n+                        self.infcx.tainted_regions(snapshot,\n+                                                   skol,\n+                                                   TaintDirections::incoming()); // [1]\n+\n+                    // [1] this routine executes after the skolemized\n+                    // regions have been *equated* with something\n+                    // else, so examining the incoming edges ought to\n+                    // be enough to collect all constraints\n+\n+                    (skol, (br, tainted_regions))\n+                })\n+                .collect();\n+\n+            // For each skolemized region, pick a representative -- which can\n+            // be any region from the sets above, except for other members of\n+            // `skol_map`. There should always be a representative if things\n+            // are properly well-formed.\n+            let mut unconstrained_regions = vec![];\n+            let skol_representatives: FnvHashMap<_, _> =\n+                skol_resolution_map\n+                .iter()\n+                .map(|(&skol, &(br, ref regions))| {\n+                    let representative =\n+                        regions.iter()\n+                               .filter(|r| !skol_resolution_map.contains_key(r))\n+                               .cloned()\n+                               .next()\n+                               .unwrap_or_else(|| { // [1]\n+                                   unconstrained_regions.push(br);\n+                                   self.infcx.next_region_var(\n+                                       LateBoundRegion(span, br, HigherRankedType))\n+                               });\n+\n+                    // [1] There should always be a representative,\n+                    // unless the higher-ranked region did not appear\n+                    // in the values being matched. We should reject\n+                    // as ill-formed cases that can lead to this, but\n+                    // right now we sometimes issue warnings (see\n+                    // #32330).\n+\n+                    (skol, representative)\n+                })\n+                .collect();\n+\n+            // Equate all the members of each skolemization set with the\n+            // representative.\n+            for (skol, &(_br, ref regions)) in &skol_resolution_map {\n+                let representative = &skol_representatives[skol];\n+                debug!(\"higher_ranked_match: \\\n+                        skol={:?} representative={:?} regions={:?}\",\n+                       skol, representative, regions);\n+                for region in regions.iter()\n+                                     .filter(|&r| !skol_resolution_map.contains_key(r))\n+                                     .filter(|&r| r != representative)\n+                {\n+                    let origin = SubregionOrigin::Subtype(self.trace.clone());\n+                    self.infcx.region_vars.make_eqregion(origin,\n+                                                         *representative,\n+                                                         *region);\n+                }\n+            }\n+\n+            // Replace the skolemized regions appearing in value with\n+            // their representatives\n+            let a_value =\n+                fold_regions_in(\n+                    self.tcx(),\n+                    &a_value,\n+                    |r, _| skol_representatives.get(&r).cloned().unwrap_or(r));\n+\n+            debug!(\"higher_ranked_match: value={:?}\", a_value);\n+\n+            // We are now done with these skolemized variables.\n+            self.infcx.pop_skolemized(skol_map, snapshot);\n+\n+            Ok(HrMatchResult {\n+                value: a_value,\n+                unconstrained_regions: unconstrained_regions,\n+            })\n+        });\n+    }\n+\n     pub fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>"}, {"sha": "ab9c056644571206929dca012bb067c2df809f56", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5cff88f2a0646297e76539fd90a084d6926fdf7d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cff88f2a0646297e76539fd90a084d6926fdf7d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5cff88f2a0646297e76539fd90a084d6926fdf7d", "patch": "@@ -45,6 +45,7 @@ use syntax::errors::DiagnosticBuilder;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use self::combine::CombineFields;\n+use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::unify_key::ToType;\n \n@@ -63,6 +64,7 @@ pub mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n+#[must_use]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n     pub obligations: PredicateObligations<'tcx>,\n@@ -1576,6 +1578,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n \n+    /// Given a higher-ranked projection predicate like:\n+    ///\n+    ///     for<'a> <T as Fn<&'a u32>>::Output = &'a u32\n+    ///\n+    /// and a target trait-ref like:\n+    ///\n+    ///     <T as Fn<&'x u32>>\n+    ///\n+    /// find a substitution `S` for the higher-ranked regions (here,\n+    /// `['a => 'x]`) such that the predicate matches the trait-ref,\n+    /// and then return the value (here, `&'a u32`) but with the\n+    /// substitution applied (hence, `&'x u32`).\n+    ///\n+    /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n+    /// details.\n+    pub fn match_poly_projection_predicate(&self,\n+                                           origin: TypeOrigin,\n+                                           match_a: ty::PolyProjectionPredicate<'tcx>,\n+                                           match_b: ty::TraitRef<'tcx>)\n+                                           -> RelateResult<HrMatchResult<Ty<'tcx>>>\n+    {\n+        let span = origin.span();\n+        let match_trait_ref = match_a.skip_binder().projection_ty.trait_ref;\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: TraitRefs(ExpectedFound::new(true, match_trait_ref, match_b))\n+        };\n+\n+        let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n+        self.combine_fields(true, trace)\n+            .higher_ranked_match(span, &match_pair, &match_b)\n+    }\n+\n     /// See `verify_generic_bound` method in `region_inference`\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,"}]}