{"sha": "5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MTVmZDVjOGNmNjVhOGVlYmQ0M2RkYjBkZTZmZjkyMGE1MDllY2U=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-02T15:12:53Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-02T15:12:53Z"}, "message": "Merge remote-tracking branch 'remotes/origin/incoming' into incoming", "tree": {"sha": "4e3d85a43f684fd9d3b2e80a6a9178f90e63d7ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e3d85a43f684fd9d3b2e80a6a9178f90e63d7ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "html_url": "https://github.com/rust-lang/rust/commit/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa3505d8ff043f0c1da62de4f517eed6defb6187", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3505d8ff043f0c1da62de4f517eed6defb6187", "html_url": "https://github.com/rust-lang/rust/commit/aa3505d8ff043f0c1da62de4f517eed6defb6187"}, {"sha": "2304fe6208404ce952aaa37e7634db570ff71f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2304fe6208404ce952aaa37e7634db570ff71f6c", "html_url": "https://github.com/rust-lang/rust/commit/2304fe6208404ce952aaa37e7634db570ff71f6c"}], "stats": {"total": 1111, "additions": 519, "deletions": 592}, "files": [{"sha": "d934e38c35d245d4ee379ddff9dfec9e5ae0388a", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -11,7 +11,7 @@ You're not off the hook even if you just stick to documentation; code examples i\n Pull requests will be treated as \"review requests\",\n and we will give feedback we expect to see corrected on [style](https://github.com/mozilla/rust/wiki/Note-style-guide) and substance before pulling.\n Changes contributed via pull request should focus on a single issue at a time, like any other.\n-We will not look accept pull-requests that try to \"sneak\" unrelated changes in.\n+We will not accept pull-requests that try to \"sneak\" unrelated changes in.\n \n Normally, all pull requests must include regression tests (see [Note-testsuite](https://github.com/mozilla/rust/wiki/Note-testsuite)) that test your change.\n Occasionally, a change will be very difficult to test for."}, {"sha": "80f8b8f49c1a4d8ea4286dad37126d473831e086", "filename": "doc/rust.md", "status": "modified", "additions": 43, "deletions": 99, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -908,6 +908,11 @@ function defined above on `[1, 2]` will instantiate type parameter `T`\n with `int`, and require the closure parameter to have type\n `fn(int)`.\n \n+The type parameters can also be explicitly supplied in a trailing\n+[path](#paths) component after the function name. This might be necessary\n+if there is not sufficient context to determine the type parameters. For\n+example, `sys::size_of::<u32>() == 4`.\n+\n Since a parameter type is opaque to the generic function, the set of\n operations that can be performed on it is limited. Values of parameter\n type can always be moved, but they can only be copied when the\n@@ -1085,6 +1090,15 @@ let p = Point(10, 11);\n let px: int = match p { Point(x, _) => x };\n ~~~~\n \n+A _unit-like struct_ is a structure without any fields, defined by leaving off the fields list entirely.\n+Such types will have a single value, just like the [unit value `()`](#unit-and-boolean-literals) of the unit type.\n+For example:\n+\n+~~~~\n+struct Cookie;\n+let c = [Cookie, Cookie, Cookie, Cookie];\n+~~~~\n+\n ### Enumerations\n \n An _enumeration_ is a simultaneous definition of a nominal [enumerated type](#enumerated-types) as well as a set of *constructors*,\n@@ -1285,19 +1299,22 @@ An _implementation_ is an item that implements a [trait](#traits) for a specific\n Implementations are defined with the keyword `impl`.\n \n ~~~~\n-# type Point = {x: float, y: float};\n+# struct Point {x: float, y: float};\n # type Surface = int;\n-# type BoundingBox = {x: float, y: float, width: float, height: float};\n+# struct BoundingBox {x: float, y: float, width: float, height: float};\n # trait Shape { fn draw(Surface); fn bounding_box() -> BoundingBox; }\n # fn do_draw_circle(s: Surface, c: Circle) { }\n \n-type Circle = {radius: float, center: Point};\n+struct Circle {\n+    radius: float,\n+    center: Point,\n+}\n \n impl Shape for Circle {\n     fn draw(s: Surface) { do_draw_circle(s, self); }\n     fn bounding_box() -> BoundingBox {\n         let r = self.radius;\n-        {x: self.center.x - r, y: self.center.y - r,\n+        BoundingBox{x: self.center.x - r, y: self.center.y - r,\n          width: 2.0 * r, height: 2.0 * r}\n     }\n }\n@@ -1590,7 +1607,8 @@ struct_expr : expr_path '{' ident ':' expr\n                       [ ',' ident ':' expr ] *\n                       [ \"..\" expr ] '}' |\n               expr_path '(' expr\n-                      [ ',' expr ] * ')'\n+                      [ ',' expr ] * ')' |\n+              expr_path\n ~~~~~~~~\n \n There are several forms of structure expressions.\n@@ -1600,23 +1618,28 @@ providing the field values of a new instance of the structure.\n A field name can be any identifier, and is separated from its value expression by a colon.\n To indicate that a field is mutable, the `mut` keyword is written before its name.\n \n-A _tuple structure expression_ constists of the [path](#paths) of a [structure item](#structures),\n+A _tuple structure expression_ consists of the [path](#paths) of a [structure item](#structures),\n followed by a parenthesized list of one or more comma-separated expressions\n (in other words, the path of a structured item followed by a tuple expression).\n The structure item must be a tuple structure item.\n \n+A _unit-like structure expression_ consists only of the [path](#paths) of a [structure item](#structures).\n+\n The following are examples of structure expressions:\n \n ~~~~\n # struct Point { x: float, y: float }\n # struct TuplePoint(float, float);\n # mod game { pub struct User { name: &str, age: uint, score: uint } }\n+# struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n let u = game::User {name: \"Joe\", age: 35u, score: 100_000};\n+some_fn::<Cookie>(Cookie);\n ~~~~\n \n A structure expression forms a new value of the named structure type.\n+Note that for a given *unit-like* structure type, this will always be the same value.\n \n A structure expression can terminate with the syntax `..` followed by an expression to denote a functional update.\n The expression following `..` (the base) must be of the same structure type as the new structure type being formed.\n@@ -1637,38 +1660,6 @@ rec_expr : '{' ident ':' expr\n                [ \"..\" expr ] '}'\n ~~~~~~~~\n \n-> **Note:** In future versions of Rust, record expressions and [record types](#record-types) will be removed.\n-\n-A [_record_](#record-types) _expression_ is one or more comma-separated\n-name-value pairs enclosed by braces. A fieldname can be any identifier,\n-and is separated from its value expression by a\n-colon. To indicate that a field is mutable, the `mut` keyword is\n-written before its name.\n-\n-~~~~\n-{x: 10f, y: 20f};\n-{name: \"Joe\", age: 35u, score: 100_000};\n-{ident: \"X\", mut count: 0u};\n-~~~~\n-\n-The order of the fields in a record expression is significant, and\n-determines the type of the resulting value. `{a: u8, b: u8}` and `{b:\n-u8, a: u8}` are two different fields.\n-\n-A record expression can terminate with the syntax `..` followed by an\n-expression to denote a functional update. The expression following\n-`..` (the base) must be of a record type that includes at least all the\n-fields mentioned in the record expression. A new record will be\n-created, of the same type as the base expression, with the given\n-values for the fields that were explicitly specified, and the values\n-in the base record for all other fields. The ordering of the fields in\n-such a record expression is not significant.\n-\n-~~~~\n-let base = {x: 1, y: 2, z: 3};\n-{y: 0, z: 10, .. base};\n-~~~~\n-\n ### Method-call expressions\n \n ~~~~~~~~{.ebnf .gram}\n@@ -1689,7 +1680,7 @@ field_expr : expr '.' ident\n \n A _field expression_ consists of an expression followed by a single dot and an identifier,\n when not immediately followed by a parenthesized expression-list (the latter is a [method call expression](#method-call-expressions)).\n-A field expression denotes a field of a [structure](#structure-types) or [record](#record-types).\n+A field expression denotes a field of a [structure](#structure-types).\n \n ~~~~~~~~ {.field}\n myrecord.myfield;\n@@ -1905,8 +1896,10 @@ An example of three different swap expressions:\n # let mut x = &mut [0];\n # let mut a = &mut [0];\n # let i = 0;\n-# let y = {mut z: 0};\n-# let b = {mut c: 0};\n+# struct S1 { z: int };\n+# struct S2 { c: int };\n+# let mut y = S1{z: 0};\n+# let mut b = S2{c: 0};\n \n x <-> a;\n x[i] <-> a[i];\n@@ -2040,12 +2033,14 @@ an optional reference slot to serve as the function's output, bound to the\n `lval` on the right hand side of the call. If the function eventually returns,\n then the expression completes.\n \n-An example of a call expression:\n+Some examples of call expressions:\n \n ~~~~\n # fn add(x: int, y: int) -> int { 0 }\n+# use core::from_str::FromStr::from_str;\n \n let x: int = add(1, 2);\n+let pi = from_str::<f32>(\"3.14\");\n ~~~~\n \n ### Lambda expressions\n@@ -2328,42 +2323,6 @@ match x {\n }\n ~~~~\n \n-Records and structures can also be pattern-matched and their fields bound to variables.\n-When matching fields of a record,\n-the fields being matched are specified first,\n-then a placeholder (`_`) represents the remaining fields.\n-\n-~~~~\n-# type options = {choose: bool, size: ~str};\n-# type player = {player: ~str, stats: (), options: options};\n-# fn load_stats() { }\n-# fn choose_player(r: &player) { }\n-# fn next_player() { }\n-\n-fn main() {\n-    let r = {\n-        player: ~\"ralph\",\n-        stats: load_stats(),\n-        options: {\n-            choose: true,\n-            size: ~\"small\"\n-        }\n-    };\n-\n-    match r {\n-      {options: {choose: true, _}, _} => {\n-        choose_player(&r)\n-      }\n-      {player: ref p, options: {size: ~\"small\", _}, _} => {\n-        log(info, (copy *p) + ~\" is small\");\n-      }\n-      _ => {\n-        next_player();\n-      }\n-    }\n-}\n-~~~~\n-\n Patterns that bind variables default to binding to a copy of the matched value. This can be made\n explicit using the ```copy``` keyword, changed to bind to a borrowed pointer by using the ```ref```\n keyword, or to a mutable borrowed pointer using ```ref mut```, or the value can be moved into\n@@ -2643,7 +2602,10 @@ the resulting `struct` value will always be laid out in memory in the order spec\n The fields of a `struct` may be qualified by [visibility modifiers](#visibility-modifiers),\n to restrict access to implementation-private data in a structure.\n \n-A `tuple struct` type is just like a structure type, except that the fields are anonymous.\n+A _tuple struct_ type is just like a structure type, except that the fields are anonymous.\n+\n+A _unit-like struct_ type is like a structure type, except that it has no fields.\n+The one value constructed by the associated [structure expression](#structure-expression) is the only value that inhabits such a type.\n \n ### Enumerated types\n \n@@ -2692,25 +2654,6 @@ let a: List<int> = Cons(7, @Cons(13, @Nil));\n ~~~~\n \n \n-### Record types\n-\n-> **Note:** Records are not nominal types, thus do not directly support recursion, visibility control,\n-> out-of-order field initialization, or coherent trait implementation.\n-> Records are therefore deprecated and will be removed in future versions of Rust.\n-> [Structure types](#structure-types) should be used instead.\n-\n-The record type-constructor forms a new heterogeneous product of values.\n-Fields of a record type are accessed by name and are arranged in memory in the order specified by the record type.\n-\n-An example of a record type and its use:\n-\n-~~~~\n-type Point = {x: int, y: int};\n-let p: Point = {x: 10, y: 11};\n-let px: int = p.x;\n-~~~~\n-\n-\n ### Pointer types\n \n All pointers in Rust are explicit first-class values.\n@@ -3040,7 +2983,8 @@ Some operations (such as field selection) implicitly dereference boxes. An\n example of an _implicit dereference_ operation performed on box values:\n \n ~~~~~~~~\n-let x = @{y: 10};\n+struct Foo { y: int }\n+let x = @Foo{y: 10};\n assert x.y == 10;\n ~~~~~~~~\n "}, {"sha": "e638579253fed8df756a02dbeaf9775c2a752516", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -166,9 +166,9 @@ operator. For example, I could write:\n # struct Point {x: float, y: float} // as before\n # struct Size {w: float, h: float} // as before\n # struct Rectangle {origin: Point, size: Size}\n-# let rect_stack  = &{origin: Point {x: 1f, y: 2f}, size: Size {w: 3f, h: 4f}};\n-# let rect_managed = @{origin: Point {x: 3f, y: 4f}, size: Size {w: 3f, h: 4f}};\n-# let rect_unique = ~{origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n+# let rect_stack  = &Rectangle {origin: Point {x: 1f, y: 2f}, size: Size {w: 3f, h: 4f}};\n+# let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f}, size: Size {w: 3f, h: 4f}};\n+# let rect_unique = ~Rectangle {origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n # fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n@@ -274,13 +274,14 @@ the following function is legal:\n \n ~~~\n # fn some_condition() -> bool { true }\n+# struct Foo { f: int }\n fn example3() -> int {\n-    let mut x = ~{f: 3};\n+    let mut x = ~Foo {f: 3};\n     if some_condition() {\n         let y = &x.f;      // -+ L\n         return *y;         //  |\n     }                      // -+\n-    x = ~{f: 4};\n+    x = ~Foo {f: 4};\n     ...\n # return 0;\n }"}, {"sha": "d89481766c0af3f742bc7dcb91d7ddae4fa9c928", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -183,7 +183,7 @@ pub mod raw {\n     use at_vec::{capacity, rustrt};\n     use cast::transmute;\n     use libc;\n-    use private::intrinsics::{move_val_init};\n+    use unstable::intrinsics::{move_val_init};\n     use ptr::addr_of;\n     use ptr;\n     use sys;"}, {"sha": "393a71562ad05bc311e440a04a31047c563cf5ae", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -154,7 +154,7 @@ fn debug_mem() -> bool {\n #[cfg(notest)]\n #[lang=\"annihilate\"]\n pub unsafe fn annihilate() {\n-    use rt::local_free;\n+    use unstable::lang::local_free;\n     use io::WriterUtil;\n     use io;\n     use libc;"}, {"sha": "d588f0c53b17e1f47dea3b9b12b23d733619a1ca", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -37,6 +37,70 @@ pub trait Eq {\n     pure fn ne(&self, other: &Self) -> bool;\n }\n \n+#[deriving_eq]\n+pub enum Ordering { Less, Equal, Greater }\n+\n+/// Trait for types that form a total order\n+pub trait TotalOrd {\n+    pure fn cmp(&self, other: &Self) -> Ordering;\n+}\n+\n+pure fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n+    if *a < *b { Less }\n+    else if *a > *b { Greater }\n+    else { Equal }\n+}\n+\n+impl TotalOrd for u8 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u16 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u32 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u64 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i8 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i16 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i32 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i64 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for int {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for uint {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n+}\n+\n /**\n * Trait for values that can be compared for a sort-order.\n *\n@@ -94,3 +158,15 @@ pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_int() {\n+        assert 5.cmp(&10) == Less;\n+        assert 10.cmp(&5) == Greater;\n+        assert 5.cmp(&5) == Equal;\n+        assert (-5).cmp(&12) == Less;\n+        assert 12.cmp(-5) == Greater;\n+    }\n+}"}, {"sha": "94272f63e6727388405413a19138e8dcc2bda0fc", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -12,7 +12,7 @@ use either::{Either, Left, Right};\n use kinds::Owned;\n use option;\n use option::{Option, Some, None, unwrap};\n-use private;\n+use unstable;\n use vec;\n \n use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n@@ -242,7 +242,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n }\n \n /// A channel that can be shared between many senders.\n-pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n+pub type SharedChan<T> = unstable::Exclusive<Chan<T>>;\n \n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     fn send(x: T) {\n@@ -268,7 +268,7 @@ impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n \n /// Converts a `chan` into a `shared_chan`.\n pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n-    private::exclusive(c)\n+    unstable::exclusive(c)\n }\n \n /// Receive a message from one of two endpoints."}, {"sha": "c8d2da28255f10b73915cc5542eaafb66cc8b9eb", "filename": "src/libcore/core.rc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -225,11 +225,13 @@ pub const debug : u32 = 4_u32;\n \n /* Unsupported interfaces */\n \n-// The runtime interface used by the compiler\n-#[cfg(notest)] pub mod rt;\n // Private APIs\n-pub mod private;\n-\n+pub mod unstable;\n+// NOTE: Remove after snapshot\n+#[cfg(stage0)]\n+pub mod private {\n+    pub use super::unstable::extfmt;\n+}\n \n /* For internal use, not exported */\n "}, {"sha": "7197de36404ede7c1cec124b8b5c1d58700921fe", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -62,17 +62,17 @@ pub struct DVec<A> {\n \n /// Creates a new, empty dvec\n pub pure fn DVec<A>() -> DVec<A> {\n-    DVec {mut data: ~[]}\n+    DVec {data: ~[]}\n }\n \n /// Creates a new dvec with a single element\n pub pure fn from_elem<A>(e: A) -> DVec<A> {\n-    DVec {mut data: ~[e]}\n+    DVec {data: ~[e]}\n }\n \n /// Creates a new dvec with the contents of a vector\n pub pure fn from_vec<A>(v: ~[A]) -> DVec<A> {\n-    DVec {mut data: v}\n+    DVec {data: v}\n }\n \n /// Consumes the vector and returns its contents"}, {"sha": "d4808bd111ffac921365e64c31fe4eb0c30a75d1", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -18,7 +18,7 @@ use num::strconv;\n use num;\n use ops;\n use option::Option;\n-use private::intrinsics::floorf32;\n+use unstable::intrinsics::floorf32;\n use from_str;\n use to_str;\n "}, {"sha": "5362a65f7cef7258b2f8630a1e4132c037285033", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -19,7 +19,7 @@ use num::strconv;\n use num;\n use ops;\n use option::Option;\n-use private::intrinsics::floorf64;\n+use unstable::intrinsics::floorf64;\n use to_str;\n use from_str;\n "}, {"sha": "cf74ec6d77a22df48cdeab399f3d548acc4de074", "filename": "src/libcore/os.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -35,7 +35,6 @@ use libc::{mode_t, pid_t, FILE};\n use option;\n use option::{Some, None};\n use prelude::*;\n-use private;\n use ptr;\n use str;\n use task;\n@@ -145,8 +144,8 @@ This uses a per-runtime lock to serialize access.\n FIXME #4726: It would probably be appropriate to make this a real global\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n-    use private::global::global_data_clone_create;\n-    use private::{Exclusive, exclusive};\n+    use unstable::global::global_data_clone_create;\n+    use unstable::{Exclusive, exclusive};\n \n     struct SharedValue(());\n     type ValueMutex = Exclusive<SharedValue>;\n@@ -322,8 +321,8 @@ pub struct Pipe { mut in: c_int, mut out: c_int }\n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n     unsafe {\n-        let mut fds = Pipe {mut in: 0 as c_int,\n-                        mut out: 0 as c_int };\n+        let mut fds = Pipe {in: 0 as c_int,\n+                        out: 0 as c_int };\n         assert (libc::pipe(&mut fds.in) == (0 as c_int));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n@@ -339,8 +338,8 @@ pub fn pipe() -> Pipe {\n         // fully understand. Here we explicitly make the pipe non-inheritable,\n         // which means to pass it to a subprocess they need to be duplicated\n         // first, as in rust_run_program.\n-        let mut fds = Pipe { mut in: 0 as c_int,\n-                    mut out: 0 as c_int };\n+        let mut fds = Pipe {in: 0 as c_int,\n+                    out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n         assert (res == 0 as c_int);\n@@ -566,13 +565,17 @@ pub fn path_exists(p: &Path) -> bool {\n  *\n  * If the given path is relative, return it prepended with the current working\n  * directory. If the given path is already an absolute path, return it\n- * as is.  This is a shortcut for calling os::getcwd().unsafe_join(p)\n+ * as is.\n  */\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n pub fn make_absolute(p: &Path) -> Path {\n-    getcwd().unsafe_join(p)\n+    if p.is_absolute {\n+        copy *p\n+    } else {\n+        getcwd().push_many(p.components)\n+    }\n }\n \n "}, {"sha": "58ab2ce78f5f98a1cf7007060c90bfc6bf58e099", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -91,9 +91,9 @@ use libc;\n use option;\n use option::{None, Option, Some, unwrap};\n use pipes;\n-use private::intrinsics;\n+use unstable::intrinsics;\n use ptr;\n-use private;\n+use unstable;\n use task;\n use vec;\n "}, {"sha": "e4be0cf98dd4e96b9a9ac035b369d46a4825ec66", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -24,10 +24,10 @@ pub use result::{Result, Ok, Err};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord};\n+pub use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{BaseIter, ReverseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use num::NumCast;\n pub use path::GenericPath;\n@@ -69,7 +69,7 @@ pub use option;\n pub use os;\n pub use path;\n pub use comm;\n-pub use private;\n+pub use unstable;\n pub use ptr;\n pub use rand;\n pub use result;"}, {"sha": "ecbce18e6daaef908a0e9c36c9d13c50b899d94c", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -14,7 +14,7 @@ use cast;\n use cmp::{Eq, Ord};\n use libc;\n use libc::{c_void, size_t};\n-use private::intrinsics::{memmove32,memmove64};\n+use unstable::intrinsics::{memmove32,memmove64};\n use ptr;\n use str;\n use sys;\n@@ -300,15 +300,15 @@ impl<T:Ord> Ord for &const T {\n pub fn test() {\n     unsafe {\n         struct Pair {mut fst: int, mut snd: int};\n-        let mut p = Pair {mut fst: 10, mut snd: 20};\n+        let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n         let iptr: *mut int = cast::reinterpret_cast(&pptr);\n         assert (*iptr == 10);;\n         *iptr = 30;\n         assert (*iptr == 30);\n         assert (p.fst == 30);;\n \n-        *pptr = Pair {mut fst: 50, mut snd: 60};\n+        *pptr = Pair {fst: 50, snd: 60};\n         assert (*iptr == 50);\n         assert (p.fst == 50);\n         assert (p.snd == 60);"}, {"sha": "f1e23f01e7b51f53bbfff3b46f347bf20e84e68a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -20,7 +20,7 @@\n use at_vec;\n use cast;\n use char;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use libc;\n use libc::size_t;\n use io::WriterUtil;\n@@ -773,6 +773,35 @@ pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n+pure fn cmp(a: &str, b: &str) -> Ordering {\n+    let low = uint::min(a.len(), b.len());\n+\n+    for uint::range(0, low) |idx| {\n+        match a[idx].cmp(&b[idx]) {\n+          Greater => return Greater,\n+          Less => return Less,\n+          Equal => ()\n+        }\n+    }\n+\n+    a.len().cmp(&b.len())\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for &str {\n+    pure fn cmp(&self, other: & &self/str) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for ~str {\n+    pure fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for @str {\n+    pure fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n+}\n+\n /// Bytewise slice less than\n pure fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n@@ -2389,6 +2418,7 @@ mod tests {\n     use ptr;\n     use str::*;\n     use vec;\n+    use cmp::{TotalOrd, Less, Equal, Greater};\n \n     #[test]\n     fn test_eq() {\n@@ -3395,4 +3425,12 @@ mod tests {\n         assert view(\"abcdef\", 1, 5).to_managed() == @\"bcde\";\n     }\n \n+    #[test]\n+    fn test_total_ord() {\n+        \"1234\".cmp(& &\"123\") == Greater;\n+        \"123\".cmp(& &\"1234\") == Less;\n+        \"1234\".cmp(& &\"1234\") == Equal;\n+        \"12345555\".cmp(& &\"123456\") == Less;\n+        \"22\".cmp(& &\"1234\") == Greater;\n+    }\n }"}, {"sha": "fc15276532282f4502b157606df70399bde06559", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -19,11 +19,7 @@ use prelude::*;\n use task::rt;\n use task::local_data::LocalDataKey;\n \n-#[cfg(notest)]\n-use rt::rust_task;\n-#[cfg(test)]\n-#[allow(non_camel_case_types)]\n-type rust_task = libc::c_void;\n+use super::rt::rust_task;\n \n pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }"}, {"sha": "6cc3657a32b4e106e3d7993f2f596a0ca99ba302", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -79,7 +79,7 @@ use option;\n use comm::{Chan, GenericChan, GenericPort, Port, stream};\n use pipes;\n use prelude::*;\n-use private;\n+use unstable;\n use ptr;\n use hashmap::linear::LinearSet;\n use task::local_data_priv::{local_get, local_set};\n@@ -123,7 +123,7 @@ struct TaskGroupData {\n     // tasks in this group.\n     mut descendants: TaskSet,\n }\n-type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n+type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n \n type TaskGroupInner = &mut Option<TaskGroupData>;\n \n@@ -153,7 +153,7 @@ struct AncestorNode {\n     mut ancestors:    AncestorList,\n }\n \n-enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n+enum AncestorList = Option<unstable::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n@@ -162,7 +162,7 @@ fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n }\n \n #[inline(always)]\n-fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n+fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n                        blk: fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n@@ -458,7 +458,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Main task, doing first spawn ever. Lazily initialise here.\n                 let mut members = new_taskset();\n                 taskset_insert(&mut members, spawner);\n-                let tasks = private::exclusive(Some(TaskGroupData {\n+                let tasks = unstable::exclusive(Some(TaskGroupData {\n                     members: members,\n                     descendants: new_taskset(),\n                 }));\n@@ -482,7 +482,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             (g, a, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n-            let g = private::exclusive(Some(TaskGroupData {\n+            let g = unstable::exclusive(Some(TaskGroupData {\n                 members:     new_taskset(),\n                 descendants: new_taskset(),\n             }));\n@@ -502,7 +502,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     };\n                 assert new_generation < uint::max_value;\n                 // Build a new node in the ancestor list.\n-                AncestorList(Some(private::exclusive(AncestorNode {\n+                AncestorList(Some(unstable::exclusive(AncestorNode {\n                     generation: new_generation,\n                     parent_group: Some(spawner_group.tasks.clone()),\n                     ancestors: old_ancestors,"}, {"sha": "8c0c029a90fcc1f031f181fb62ff8e2f406c025b", "filename": "src/libcore/unstable.rs", "status": "renamed", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -22,20 +22,23 @@ use task;\n use task::{TaskBuilder, atomically};\n use uint;\n \n-#[path = \"private/at_exit.rs\"]\n+#[path = \"unstable/at_exit.rs\"]\n pub mod at_exit;\n-#[path = \"private/global.rs\"]\n+#[path = \"unstable/global.rs\"]\n pub mod global;\n-#[path = \"private/finally.rs\"]\n+#[path = \"unstable/finally.rs\"]\n pub mod finally;\n-#[path = \"private/weak_task.rs\"]\n+#[path = \"unstable/weak_task.rs\"]\n pub mod weak_task;\n-#[path = \"private/exchange_alloc.rs\"]\n+#[path = \"unstable/exchange_alloc.rs\"]\n pub mod exchange_alloc;\n-#[path = \"private/intrinsics.rs\"]\n+#[path = \"unstable/intrinsics.rs\"]\n pub mod intrinsics;\n-#[path = \"private/extfmt.rs\"]\n+#[path = \"unstable/extfmt.rs\"]\n pub mod extfmt;\n+#[path = \"unstable/lang.rs\"]\n+#[cfg(notest)]\n+pub mod lang;\n \n extern mod rustrt {\n     pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n@@ -312,7 +315,7 @@ pub mod tests {\n     use cell::Cell;\n     use comm;\n     use option;\n-    use private::exclusive;\n+    use super::exclusive;\n     use result;\n     use task;\n     use uint;", "previous_filename": "src/libcore/private.rs"}, {"sha": "4785cb622cbc511da3335182658566418f97ffa2", "filename": "src/libcore/unstable/at_exit.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "previous_filename": "src/libcore/private/at_exit.rs"}, {"sha": "f59037445ebd0cc2087238e74b8f0322e9010351", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -14,7 +14,7 @@ use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n use cast::transmute;\n-use private::intrinsics::{atomic_xadd,atomic_xsub};\n+use unstable::intrinsics::{atomic_xadd,atomic_xsub};\n use ptr::null;\n use intrinsic::TyDesc;\n ", "previous_filename": "src/libcore/private/exchange_alloc.rs"}, {"sha": "616d37a133a9f18af4e6b5fba03105a5754c3cc0", "filename": "src/libcore/unstable/extfmt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "previous_filename": "src/libcore/private/extfmt.rs"}, {"sha": "ff75963511c3806cced8bf47f7a970e2c67e6ad5", "filename": "src/libcore/unstable/finally.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "previous_filename": "src/libcore/private/finally.rs"}, {"sha": "aa28310f7ba29a616ffbb68c2f2d75cbc3552f9a", "filename": "src/libcore/unstable/global.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -32,11 +32,11 @@ use libc::{c_void, uintptr_t};\n use option::{Option, Some, None};\n use ops::Drop;\n use pipes;\n-use private::{Exclusive, exclusive};\n-use private::{SharedMutableState, shared_mutable_state};\n-use private::{get_shared_immutable_state};\n-use private::at_exit::at_exit;\n-use private::intrinsics::atomic_cxchg;\n+use unstable::{Exclusive, exclusive};\n+use unstable::{SharedMutableState, shared_mutable_state};\n+use unstable::{get_shared_immutable_state};\n+use unstable::at_exit::at_exit;\n+use unstable::intrinsics::atomic_cxchg;\n use hashmap::linear::LinearMap;\n use sys::Closure;\n use task::spawn;", "previous_filename": "src/libcore/private/global.rs"}, {"sha": "8f0067b739335d15baf1582b362751cf021dbc89", "filename": "src/libcore/unstable/intrinsics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "previous_filename": "src/libcore/private/intrinsics.rs"}, {"sha": "e74052995e6cee69b660f960635c2a2562cb30ff", "filename": "src/libcore/unstable/lang.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -15,14 +15,11 @@ use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n-use private::exchange_alloc;\n+use unstable::exchange_alloc;\n use cast::transmute;\n \n use gc::{cleanup_stack_for_failure, gc, Word};\n \n-#[allow(non_camel_case_types)]\n-pub type rust_task = c_void;\n-\n #[cfg(target_word_size = \"32\")]\n pub const FROZEN_BIT: uint = 0x80000000;\n #[cfg(target_word_size = \"64\")]", "previous_filename": "src/libcore/rt.rs"}, {"sha": "0e1181f43dbc91c55ae7a25ccaa3f07cd2183aca", "filename": "src/libcore/unstable/weak_task.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -24,9 +24,9 @@ use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n use hashmap::linear::LinearMap;\n use ops::Drop;\n use option::{Some, None, swap_unwrap};\n-use private::at_exit::at_exit;\n-use private::finally::Finally;\n-use private::global::global_data_clone_create;\n+use unstable::at_exit::at_exit;\n+use unstable::finally::Finally;\n+use unstable::global::global_data_clone_create;\n use task::rt::{task_id, get_task_id};\n use task::{Task, task, spawn};\n ", "previous_filename": "src/libcore/private/weak_task.rs"}, {"sha": "925d78a3b81b0b86436767ef159695d610ce2741", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -15,14 +15,14 @@\n use container::{Container, Mutable};\n use cast::transmute;\n use cast;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use iter::BaseIter;\n use iter;\n use kinds::Copy;\n use libc;\n use libc::size_t;\n use option::{None, Option, Some};\n-use private::intrinsics;\n+use unstable::intrinsics;\n use ptr;\n use ptr::addr_of;\n use sys;\n@@ -1425,7 +1425,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n+pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1575,6 +1575,38 @@ impl<T:Eq> Eq for @[T] {\n \n // Lexicographical comparison\n \n+pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n+    let low = uint::min(a.len(), b.len());\n+\n+    for uint::range(0, low) |idx| {\n+        match a[idx].cmp(&b[idx]) {\n+          Greater => return Greater,\n+          Less => return Less,\n+          Equal => ()\n+        }\n+    }\n+\n+    a.len().cmp(&b.len())\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for &[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: & &self/[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for ~[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for @[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n@@ -2008,7 +2040,7 @@ pub mod raw {\n     use managed;\n     use option::{None, Some};\n     use option;\n-    use private::intrinsics;\n+    use unstable::intrinsics;\n     use ptr::addr_of;\n     use ptr;\n     use sys;\n@@ -2151,7 +2183,7 @@ pub mod bytes {\n     use vec;\n \n     /// Bytewise string comparison\n-    pub pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub pure fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = len(*a);\n         let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -2172,22 +2204,22 @@ pub mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n+    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n+    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n+    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n+    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n+    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n+    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n@@ -2429,6 +2461,7 @@ mod tests {\n     use option;\n     use sys;\n     use vec::*;\n+    use cmp::*;\n \n     fn square(n: uint) -> uint { return n * n; }\n \n@@ -2622,8 +2655,8 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = ~[::private::exclusive(()), ::private::exclusive(()),\n-                      ::private::exclusive(())];\n+        let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n+                      ::unstable::exclusive(())];\n         let mut _e = v.swap_remove(0);\n         assert (len(v) == 2);\n         _e = v.swap_remove(1);\n@@ -3942,6 +3975,14 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_total_ord() {\n+        [1, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n+        [1, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n+        [1, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n+        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n+        [2, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n+    }\n }\n \n // Local Variables:"}, {"sha": "ea59d6a54c6d626fdd3316b2ce9beed11cb4fb90", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -20,9 +20,9 @@ use core::cast;\n use core::cell::Cell;\n use core::pipes;\n use core::prelude::*;\n-use core::private::{SharedMutableState, shared_mutable_state};\n-use core::private::{clone_shared_mutable_state};\n-use core::private::{get_shared_mutable_state, get_shared_immutable_state};\n+use core::unstable::{SharedMutableState, shared_mutable_state};\n+use core::unstable::{clone_shared_mutable_state};\n+use core::unstable::{get_shared_mutable_state, get_shared_immutable_state};\n use core::ptr;\n use core::task;\n use core::util;"}, {"sha": "cbe0580a6096855af009a24f01b25c137938df0d", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -219,7 +219,7 @@ pub mod reader {\n     }\n \n     pub fn Decoder(d: Doc) -> Decoder {\n-        Decoder { mut parent: d, mut pos: d.start }\n+        Decoder { parent: d, pos: d.start }\n     }\n \n     priv impl Decoder {"}, {"sha": "4266cab0a056e162f96eeffbf4a2aa6edbdd4b7a", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -43,7 +43,7 @@ extern mod rustrt {\n /**\n  * Encapsulates an open TCP/IP connection through libuv\n  *\n- * `tcp_socket` is non-copyable/sendable and automagically handles closing the\n+ * `TcpSocket` is non-copyable/sendable and automagically handles closing the\n  * underlying libuv data structures when it goes out of scope. This is the\n  * data structure that is used for read/write operations over a TCP stream.\n  */\n@@ -66,10 +66,10 @@ pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n }\n \n /**\n- * A buffered wrapper for `net::tcp::tcp_socket`\n+ * A buffered wrapper for `net::tcp::TcpSocket`\n  *\n  * It is created with a call to `net::tcp::socket_buf()` and has impls that\n- * satisfy both the `io::reader` and `io::writer` traits.\n+ * satisfy both the `io::Reader` and `io::Writer` traits.\n  */\n pub struct TcpSocketBuf {\n     data: @TcpBufferedSocketData,\n@@ -89,7 +89,7 @@ pub struct TcpErrData {\n     err_msg: ~str,\n }\n \n-/// Details returned as part of a `result::err` result from `tcp::listen`\n+/// Details returned as part of a `Result::Err` result from `tcp::listen`\n pub enum TcpListenErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n@@ -116,7 +116,7 @@ pub enum TcpListenErrData {\n      */\n     AccessDenied\n }\n-/// Details returned as part of a `result::err` result from `tcp::connect`\n+/// Details returned as part of a `Result::Err` result from `tcp::connect`\n pub enum TcpConnectErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n@@ -139,9 +139,9 @@ pub enum TcpConnectErrData {\n  * # Returns\n  *\n  * A `result` that, if the operation succeeds, contains a\n- * `net::net::tcp_socket` that can be used to send and receive data to/from\n+ * `net::net::TcpSocket` that can be used to send and receive data to/from\n  * the remote host. In the event of failure, a\n- * `net::tcp::tcp_connect_err_data` instance will be returned\n+ * `net::tcp::TcpConnectErrData` instance will be returned\n  */\n pub fn connect(input_ip: ip::IpAddr, port: uint,\n                iotask: &IoTask)\n@@ -288,14 +288,14 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  *\n  * # Arguments\n  *\n- * * sock - a `tcp_socket` to write to\n+ * * sock - a `TcpSocket` to write to\n  * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n  * This value must remain valid for the duration of the `write` call\n  *\n  * # Returns\n  *\n- * A `result` object with a `nil` value as the `ok` variant, or a\n- * `tcp_err_data` value as the `err` variant\n+ * A `Result` object with a `()` value as the `Ok` variant, or a\n+ * `TcpErrData` value as the `Err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> result::Result<(), TcpErrData> {\n@@ -306,35 +306,35 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n }\n \n /**\n- * Write binary data to tcp stream; Returns a `future::future` value\n+ * Write binary data to tcp stream; Returns a `future::Future` value\n  * immediately\n  *\n  * # Safety\n  *\n  * This function can produce unsafe results if:\n  *\n  * 1. the call to `write_future` is made\n- * 2. the `future::future` value returned is never resolved via\n- * `future::get`\n- * 3. and then the `tcp_socket` passed in to `write_future` leaves\n+ * 2. the `future::Future` value returned is never resolved via\n+ * `Future::get`\n+ * 3. and then the `TcpSocket` passed in to `write_future` leaves\n  * scope and is destructed before the task that runs the libuv write\n  * operation completes.\n  *\n  * As such: If using `write_future`, always be sure to resolve the returned\n- * `future` so as to ensure libuv doesn't try to access a released write\n+ * `Future` so as to ensure libuv doesn't try to access a released write\n  * handle. Otherwise, use the blocking `tcp::write` function instead.\n  *\n  * # Arguments\n  *\n- * * sock - a `tcp_socket` to write to\n+ * * sock - a `TcpSocket` to write to\n  * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n  * This value must remain valid for the duration of the `write` call\n  *\n  * # Returns\n  *\n- * A `future` value that, once the `write` operation completes, resolves to a\n- * `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n- * value as the `err` variant\n+ * A `Future` value that, once the `write` operation completes, resolves to a\n+ * `Result` object with a `nil` value as the `Ok` variant, or a `TcpErrData`\n+ * value as the `Err` variant\n  */\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> future::Future<result::Result<(), TcpErrData>> {\n@@ -353,14 +353,14 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  *\n  * # Arguments\n  *\n- * * sock -- a `net::tcp::tcp_socket` for the connection to read from\n+ * * sock -- a `net::tcp::TcpSocket` for the connection to read from\n  *\n  * # Returns\n  *\n- * * A `result` instance that will either contain a\n- * `core::comm::port<tcp_read_result>` that the user can read (and\n- * optionally, loop on) from until `read_stop` is called, or a\n- * `tcp_err_data` record\n+ * * A `Result` instance that will either contain a\n+ * `core::comm::Port<Result<~[u8], TcpErrData>>` that the user can read\n+ * (and * optionally, loop on) from until `read_stop` is called, or a\n+ * `TcpErrData` record\n  */\n pub fn read_start(sock: &TcpSocket)\n     -> result::Result<@Port<\n@@ -376,7 +376,7 @@ pub fn read_start(sock: &TcpSocket)\n  *\n  * # Arguments\n  *\n- * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n+ * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket) ->\n     result::Result<(), TcpErrData> {\n@@ -387,17 +387,17 @@ pub fn read_stop(sock: &TcpSocket) ->\n }\n \n /**\n- * Reads a single chunk of data from `tcp_socket`; block until data/error\n+ * Reads a single chunk of data from `TcpSocket`; block until data/error\n  * recv'd\n  *\n  * Does a blocking read operation for a single chunk of data from a\n- * `tcp_socket` until a data arrives or an error is received. The provided\n+ * `TcpSocket` until a data arrives or an error is received. The provided\n  * `timeout_msecs` value is used to raise an error if the timeout period\n  * passes without any data received.\n  *\n  * # Arguments\n  *\n- * * `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+ * * `sock` - a `net::tcp::TcpSocket` that you wish to read from\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n@@ -408,31 +408,31 @@ pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n }\n \n /**\n- * Reads a single chunk of data; returns a `future::future<~[u8]>`\n+ * Reads a single chunk of data; returns a `future::Future<~[u8]>`\n  * immediately\n  *\n  * Does a non-blocking read operation for a single chunk of data from a\n- * `tcp_socket` and immediately returns a `future` value representing the\n- * result. When resolving the returned `future`, it will block until data\n+ * `TcpSocket` and immediately returns a `Future` value representing the\n+ * result. When resolving the returned `Future`, it will block until data\n  * arrives or an error is received. The provided `timeout_msecs`\n  * value is used to raise an error if the timeout period passes without any\n  * data received.\n  *\n  * # Safety\n  *\n  * This function can produce unsafe results if the call to `read_future` is\n- * made, the `future::future` value returned is never resolved via\n- * `future::get`, and then the `tcp_socket` passed in to `read_future` leaves\n+ * made, the `future::Future` value returned is never resolved via\n+ * `Future::get`, and then the `TcpSocket` passed in to `read_future` leaves\n  * scope and is destructed before the task that runs the libuv read\n  * operation completes.\n  *\n  * As such: If using `read_future`, always be sure to resolve the returned\n- * `future` so as to ensure libuv doesn't try to access a released read\n+ * `Future` so as to ensure libuv doesn't try to access a released read\n  * handle. Otherwise, use the blocking `tcp::read` function instead.\n  *\n  * # Arguments\n  *\n- * * `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+ * * `sock` - a `net::tcp::TcpSocket` that you wish to read from\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n@@ -445,7 +445,7 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n }\n \n /**\n- * Bind an incoming client connection to a `net::tcp::tcp_socket`\n+ * Bind an incoming client connection to a `net::tcp::TcpSocket`\n  *\n  * # Notes\n  *\n@@ -461,57 +461,57 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  *\n  * This implies that a port/chan pair must be used to make sure that the\n  * `new_connect_cb` call blocks until an attempt to create a\n- * `net::tcp::tcp_socket` is completed.\n+ * `net::tcp::TcpSocket` is completed.\n  *\n  * # Example\n  *\n  * Here, the `new_conn` is used in conjunction with `accept` from within\n  * a task spawned by the `new_connect_cb` passed into `listen`\n  *\n  * ~~~~~~~~~~~\n- * net::tcp::listen(remote_ip, remote_port, backlog)\n+ * do net::tcp::listen(remote_ip, remote_port, backlog, iotask,\n  *     // this callback is ran once after the connection is successfully\n  *     // set up\n- *     {|kill_ch|\n+ *     |kill_ch| {\n  *       // pass the kill_ch to your main loop or wherever you want\n  *       // to be able to externally kill the server from\n- *     }\n+ *     })\n  *     // this callback is ran when a new connection arrives\n- *     {|new_conn, kill_ch|\n- *     let cont_po = core::comm::port::<Option<tcp_err_data>>();\n- *     let cont_ch = core::comm::chan(cont_po);\n- *     task::spawn {||\n+ *     |new_conn, kill_ch| {\n+ *     let (cont_po, cont_ch) = comm::stream::<option::Option<TcpErrData>>();\n+ *     do task::spawn {\n  *         let accept_result = net::tcp::accept(new_conn);\n- *         if accept_result.is_err() {\n- *             core::comm::send(cont_ch, result::get_err(accept_result));\n- *             // fail?\n- *         }\n- *         else {\n- *             let sock = result::get(accept_result);\n- *             core::comm::send(cont_ch, true);\n- *             // do work here\n+ *         match accept_result {\n+ *             Err(accept_error) => {\n+ *                 cont_ch.send(Some(accept_error));\n+ *                 // fail?\n+ *             },\n+ *             Ok(sock) => {\n+ *                 cont_ch.send(None);\n+ *                 // do work here\n+ *             }\n  *         }\n  *     };\n- *     match core::comm::recv(cont_po) {\n+ *     match cont_po.recv() {\n  *       // shut down listen()\n- *       Some(err_data) { core::comm::send(kill_chan, Some(err_data)) }\n+ *       Some(err_data) => kill_ch.send(Some(err_data)),\n  *       // wait for next connection\n- *       None {}\n+ *       None => ()\n  *     }\n  * };\n  * ~~~~~~~~~~~\n  *\n  * # Arguments\n  *\n- * * `new_conn` - an opaque value used to create a new `tcp_socket`\n+ * * `new_conn` - an opaque value used to create a new `TcpSocket`\n  *\n  * # Returns\n  *\n- * On success, this function will return a `net::tcp::tcp_socket` as the\n- * `ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n+ * On success, this function will return a `net::tcp::TcpSocket` as the\n+ * `Ok` variant of a `Result`. The `net::tcp::TcpSocket` is anchored within\n  * the task that `accept` was called within for its lifetime. On failure,\n- * this function will return a `net::tcp::tcp_err_data` record\n- * as the `err` variant of a `result`.\n+ * this function will return a `net::tcp::TcpErrData` record\n+ * as the `Err` variant of a `Result`.\n  */\n pub fn accept(new_conn: TcpNewConnection)\n     -> result::Result<TcpSocket, TcpErrData> {\n@@ -600,27 +600,27 @@ pub fn accept(new_conn: TcpNewConnection)\n  *\n  * # Arguments\n  *\n- * * `host_ip` - a `net::ip::ip_addr` representing a unique IP\n+ * * `host_ip` - a `net::ip::IpAddr` representing a unique IP\n  * (versions 4 or 6)\n  * * `port` - a uint representing the port to listen on\n  * * `backlog` - a uint representing the number of incoming connections\n  * to cache in memory\n- * * `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+ * * `hl_loop` - a `uv_iotask::IoTask` that the tcp request will run on\n  * * `on_establish_cb` - a callback that is evaluated if/when the listener\n  * is successfully established. it takes no parameters\n  * * `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n  * whenever a client attempts to conect on the provided ip/port. the\n  * callback's arguments are:\n  *     * `new_conn` - an opaque type that can be passed to\n- *     `net::tcp::accept` in order to be converted to a `tcp_socket`.\n- *     * `kill_ch` - channel of type `core::comm::chan<Option<tcp_err_data>>`.\n+ *     `net::tcp::accept` in order to be converted to a `TcpSocket`.\n+ *     * `kill_ch` - channel of type `core::comm::Chan<Option<tcp_err_data>>`.\n  *     this channel can be used to send a message to cause `listen` to begin\n  *     closing the underlying libuv data structures.\n  *\n  * # returns\n  *\n- * a `result` instance containing empty data of type `()` on a\n- * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n+ * a `Result` instance containing empty data of type `()` on a\n+ * successful/normal shutdown, and a `TcpListenErrData` enum in the event\n  * of listen exiting because of an error\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n@@ -799,27 +799,27 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n \n \n /**\n- * Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n+ * Convert a `net::tcp::TcpSocket` to a `net::tcp::TcpSocketBuf`.\n  *\n- * This function takes ownership of a `net::tcp::tcp_socket`, returning it\n- * stored within a buffered wrapper, which can be converted to a `io::reader`\n- * or `io::writer`\n+ * This function takes ownership of a `net::tcp::TcpSocket`, returning it\n+ * stored within a buffered wrapper, which can be converted to a `io::Reader`\n+ * or `io::Writer`\n  *\n  * # Arguments\n  *\n- * * `sock` -- a `net::tcp::tcp_socket` that you want to buffer\n+ * * `sock` -- a `net::tcp::TcpSocket` that you want to buffer\n  *\n  * # Returns\n  *\n- * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n+ * A buffered wrapper that you can cast as an `io::Reader` or `io::Writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@TcpBufferedSocketData {\n         sock: sock, mut buf: ~[], buf_off: 0\n     })\n }\n \n-/// Convenience methods extending `net::tcp::tcp_socket`\n+/// Convenience methods extending `net::tcp::TcpSocket`\n pub impl TcpSocket {\n     pub fn read_start() -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n@@ -862,7 +862,7 @@ pub impl TcpSocket {\n     }\n }\n \n-/// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n+/// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Reader for TcpSocketBuf {\n     fn read(&self, buf: &mut [u8], len: uint) -> uint {\n         if len == 0 { return 0 }\n@@ -962,7 +962,7 @@ impl io::Reader for TcpSocketBuf {\n     }\n }\n \n-/// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n+/// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Writer for TcpSocketBuf {\n     pub fn write(&self, data: &[const u8]) {\n         unsafe {"}, {"sha": "a8a609b1f8ad01b05a5303d8524d5fd745de9ef2", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,7 +19,7 @@ use core::cell::Cell;\n use core::option;\n use core::pipes;\n use core::prelude::*;\n-use core::private::{Exclusive, exclusive};\n+use core::unstable::{Exclusive, exclusive};\n use core::ptr;\n use core::task;\n use core::util;\n@@ -87,7 +87,7 @@ enum Sem<Q> = Exclusive<SemInner<Q>>;\n #[doc(hidden)]\n fn new_sem<Q:Owned>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n-        mut count: count, waiters: new_waitqueue(), blocked: q }))\n+        count: count, waiters: new_waitqueue(), blocked: q }))\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)"}, {"sha": "a093351c4a76387e9674ad28268e9b878e59c02a", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 86, "deletions": 81, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -10,12 +10,8 @@\n \n //! An ordered map and set implemented as self-balancing binary search\n //! trees. The only requirement for the types is that the key implements\n-//! `Ord`, and that the `lt` method provides a total ordering.\n+//! `TotalOrd`.\n \n-use core::container::{Container, Mutable, Map, Set};\n-use core::cmp::{Eq, Ord};\n-use core::iter::{BaseIter, ReverseIter};\n-use core::option::{Option, Some, None};\n use core::prelude::*;\n \n // This is implemented as an AA tree, which is a simplified variation of\n@@ -39,7 +35,7 @@ pub struct TreeMap<K, V> {\n     priv length: uint\n }\n \n-impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n+impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n     pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n@@ -61,7 +57,8 @@ impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n }\n \n // Lexicographical comparison\n-pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n+pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n+                                 b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n \n@@ -78,7 +75,7 @@ pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     return a_len < b_len;\n }\n \n-impl<K:Ord,V> Ord for TreeMap<K, V> {\n+impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeMap<K, V>) -> bool {\n         lt(self, other)\n@@ -97,38 +94,38 @@ impl<K:Ord,V> Ord for TreeMap<K, V> {\n     }\n }\n \n-impl<K:Ord,V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n     pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<K:Ord,V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n \n-impl<K:Ord,V> Container for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     pure fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n-impl<K:Ord,V> Mutable for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n-impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     pure fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n@@ -146,12 +143,10 @@ impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n         loop {\n             match *current {\n               Some(ref r) => {\n-                if *key < r.key {\n-                    current = &r.left;\n-                } else if r.key < *key {\n-                    current = &r.right;\n-                } else {\n-                    return Some(&r.value);\n+                match key.cmp(&r.key) {\n+                   Less => current = &r.left,\n+                   Greater => current = &r.right,\n+                   Equal => return Some(&r.value)\n                 }\n               }\n               None => return None\n@@ -177,7 +172,7 @@ impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-pub impl <K:Ord,V> TreeMap<K, V> {\n+pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n@@ -207,7 +202,7 @@ pub struct TreeMapIterator<K, V> {\n /// Advance the iterator to the next node (in order) and return a\n /// tuple with a reference to the key and value. If there are no\n /// more nodes, return `None`.\n-pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n+pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n                         -> Option<(&r/K, &r/V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n@@ -226,8 +221,8 @@ pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n }\n \n /// Advance the iterator through the map\n-pub fn map_advance<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                          f: fn((&r/K, &r/V)) -> bool) {\n+pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n+                         f: fn((&r/K, &r/V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -242,25 +237,25 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl<T:Ord> BaseIter<T> for TreeSet<T> {\n+impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T:Ord> ReverseIter<T> for TreeSet<T> {\n+impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n     pure fn each_reverse(&self, f: fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n-impl<T:Eq + Ord> Eq for TreeSet<T> {\n+impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T:Ord> Ord for TreeSet<T> {\n+impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n     #[inline(always)]\n@@ -271,20 +266,20 @@ impl<T:Ord> Ord for TreeSet<T> {\n     pure fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n-impl<T:Ord> Container for TreeSet<T> {\n+impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     pure fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     pure fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n-impl<T:Ord> Mutable for TreeSet<T> {\n+impl<T: TotalOrd> Mutable for TreeSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Ord> Set<T> for TreeSet<T> {\n+impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n@@ -309,12 +304,10 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n-                if a1 < b1 {\n-                    a = set_next(&mut x);\n-                } else if b1 < a1 {\n-                    b = set_next(&mut y);\n-                } else {\n-                    return false;\n+                match a1.cmp(b1) {\n+                  Less => a = set_next(&mut x),\n+                  Greater => b = set_next(&mut y),\n+                  Equal => return false\n                 }\n             }\n         }\n@@ -341,13 +334,12 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if b1 < a1 {\n-                    return false\n+                match a1.cmp(b1) {\n+                  Less => (),\n+                  Greater => return false,\n+                  Equal => b = set_next(&mut y),\n                 }\n \n-                if !(a1 < b1) {\n-                    b = set_next(&mut y);\n-                }\n                 a = set_next(&mut x);\n             }\n         }\n@@ -373,11 +365,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if a1 < b1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     if !f(a1) { return }\n                     a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) { a = set_next(&mut x) }\n+                    if cmp == Equal { a = set_next(&mut x) }\n                     b = set_next(&mut y);\n                 }\n             }\n@@ -404,11 +398,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if a1 < b1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     if !f(a1) { return }\n                     a = set_next(&mut x);\n                 } else {\n-                    if b1 < a1 {\n+                    if cmp == Greater {\n                         if !f(b1) { return }\n                     } else {\n                         a = set_next(&mut x);\n@@ -434,10 +430,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n-                if a1 < b1 {\n+\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) {\n+                    if cmp == Equal {\n                         if !f(a1) { return }\n                     }\n                     b = set_next(&mut y);\n@@ -465,12 +464,14 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if b1 < a1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Greater {\n                     if !f(b1) { return }\n                     b = set_next(&mut y);\n                 } else {\n                     if !f(a1) { return }\n-                    if !(a1 < b1) {\n+                    if cmp == Equal {\n                         b = set_next(&mut y);\n                     }\n                     a = set_next(&mut x);\n@@ -480,7 +481,7 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n     }\n }\n \n-pub impl <T:Ord> TreeSet<T> {\n+pub impl <T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n@@ -498,12 +499,12 @@ pub struct TreeSetIterator<T> {\n \n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n-pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n+pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n     do map_next(&mut iter.iter).map |&(value, _)| { value }\n }\n \n /// Advance the iterator through the set\n-fn set_advance<T: Ord>(iter: &mut TreeSetIterator/&r<T>,\n+fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n                        f: fn(&r/T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n@@ -518,22 +519,22 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-pub impl <K:Ord,V> TreeNode<K, V> {\n+pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     #[inline(always)]\n     static pure fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n-pure fn each<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n                         f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each_reverse<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n                                 f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each_reverse(&x.right, f);\n@@ -542,7 +543,7 @@ pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n }\n \n // Remove left horizontal link by rotating right\n-fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n+fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.map_default(false, |x| x.level == node.level) {\n         let mut save = node.left.swap_unwrap();\n         node.left <-> save.right; // save.right now None\n@@ -553,7 +554,7 @@ fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n \n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n-fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n+fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.right.map_default(false,\n       |x| x.right.map_default(false, |y| y.level == node.level)) {\n         let mut save = node.right.swap_unwrap();\n@@ -564,24 +565,28 @@ fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n     }\n }\n \n-fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n-                     value: V) -> bool {\n+fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n+                          value: V) -> bool {\n     match *node {\n       Some(ref mut save) => {\n-        if key < save.key {\n+        match key.cmp(&save.key) {\n+          Less => {\n             let inserted = insert(&mut save.left, key, value);\n             skew(save);\n             split(save);\n             inserted\n-        } else if save.key < key {\n+          }\n+          Greater => {\n             let inserted = insert(&mut save.right, key, value);\n             skew(save);\n             split(save);\n             inserted\n-        } else {\n+          }\n+          Equal => {\n             save.key = key;\n             save.value = value;\n             false\n+          }\n         }\n       }\n       None => {\n@@ -591,8 +596,9 @@ fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n     }\n }\n \n-fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n-    fn heir_swap<K:Ord,V>(node: &mut ~TreeNode<K, V>,\n+fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n+                          key: &K) -> bool {\n+    fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                             child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n         do child.mutate |mut child| {\n@@ -611,11 +617,10 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n         return false // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (removed, this) = if save.key < *key {\n-            (remove(&mut save.right, key), false)\n-        } else if *key < save.key {\n-            (remove(&mut save.left, key), false)\n-        } else {\n+        let (removed, this) = match key.cmp(&save.key) {\n+          Less => (remove(&mut save.left, key), false),\n+          Greater => (remove(&mut save.right, key), false),\n+          Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n                     let mut left = save.left.swap_unwrap();\n@@ -637,6 +642,7 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n             } else {\n                 (true, true)\n             }\n+          }\n         };\n \n         if !this {\n@@ -682,12 +688,9 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n \n #[cfg(test)]\n mod test_treemap {\n+    use core::prelude::*;\n     use super::*;\n-    use core::cmp::{Ord, Eq};\n-    use core::option::{Some, Option, None};\n     use core::rand;\n-    use core::str;\n-    use core::vec;\n \n     #[test]\n     fn find_empty() {\n@@ -742,7 +745,8 @@ mod test_treemap {\n         assert m.find(&k1) == Some(&v1);\n     }\n \n-    fn check_equal<K:Eq + Ord,V:Eq>(ctrl: &[(K, V)], map: &TreeMap<K, V>) {\n+    fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n+                                            map: &TreeMap<K, V>) {\n         assert ctrl.is_empty() == map.is_empty();\n         for ctrl.each |x| {\n             let &(k, v) = x;\n@@ -762,11 +766,11 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_left<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n-                             parent: &~TreeNode<K, V>) {\n+    fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n+                                  parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key < parent.key;\n+            assert r.key.cmp(&parent.key) == Less;\n             assert r.level == parent.level - 1; // left is black\n             check_left(&r.left, r);\n             check_right(&r.right, r, false);\n@@ -775,11 +779,12 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_right<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n-                              parent: &~TreeNode<K, V>, parent_red: bool) {\n+    fn check_right<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n+                                   parent: &~TreeNode<K, V>,\n+                                   parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key > parent.key;\n+            assert r.key.cmp(&parent.key) == Greater;\n             let red = r.level == parent.level;\n             if parent_red { assert !red } // no dual horizontal links\n             assert red || r.level == parent.level - 1; // right red or black\n@@ -790,7 +795,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_structure<K:Ord,V>(map: &TreeMap<K, V>) {\n+    fn check_structure<K: TotalOrd, V>(map: &TreeMap<K, V>) {\n         match map.root {\n           Some(ref r) => {\n             check_left(&r.left, r);"}, {"sha": "52cfc078bace2c2b33515f22ddb07f1bf55f469a", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -18,9 +18,9 @@ use uv_iotask::{IoTask, spawn_iotask};\n use core::either::{Left, Right};\n use core::libc;\n use core::comm::{Port, Chan, SharedChan, select2i};\n-use core::private::global::{global_data_clone_create,\n+use core::unstable::global::{global_data_clone_create,\n                             global_data_clone};\n-use core::private::weak_task::weaken_task;\n+use core::unstable::weak_task::weaken_task;\n use core::str;\n use core::task::{task, SingleThreaded, spawn};\n use core::task;"}, {"sha": "e06e43f6287cecb903c778954c4862f18ec04b61", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -24,7 +24,7 @@ use ext::base::*;\n use ext::base;\n use ext::build;\n use ext::build::*;\n-use private::extfmt::ct::*;\n+use unstable::extfmt::ct::*;\n \n pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -57,7 +57,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n    -> @ast::expr {\n     fn make_path_vec(cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n         let intr = cx.parse_sess().interner;\n-        return ~[intr.intern(@~\"private\"), intr.intern(@~\"extfmt\"),\n+        return ~[intr.intern(@~\"unstable\"), intr.intern(@~\"extfmt\"),\n                  intr.intern(@~\"rt\"), intr.intern(ident)];\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span, nm: @~str) -> @ast::expr {"}, {"sha": "4c48b49b5d61eab3e8a800d0f5d7687854b0a874", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1130,15 +1130,10 @@ pub impl Parser {\n                 self.mk_expr(lo, hi, expr_tup(es))\n             }\n         } else if *self.token == token::LBRACE {\n-            if self.looking_at_record_literal() {\n-                ex = self.parse_record_literal();\n-                hi = self.span.hi;\n-            } else {\n-                self.bump();\n-                let blk = self.parse_block_tail(lo, default_blk);\n-                return self.mk_expr(blk.span.lo, blk.span.hi,\n-                                     expr_block(blk));\n-            }\n+            self.bump();\n+            let blk = self.parse_block_tail(lo, default_blk);\n+            return self.mk_expr(blk.span.lo, blk.span.hi,\n+                                 expr_block(blk));\n         } else if token::is_bar(&*self.token) {\n             return self.parse_lambda_expr();\n         } else if self.eat_keyword(&~\"if\") {\n@@ -1263,6 +1258,7 @@ pub impl Parser {\n                     self.bump();\n                     let mut fields = ~[];\n                     let mut base = None;\n+\n                     fields.push(self.parse_field(token::COLON));\n                     while *self.token != token::RBRACE {\n                         if self.try_parse_obsolete_with() {"}, {"sha": "282980f0faaea132f9f6adb49463cdad85f39be0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -714,30 +714,26 @@ pub fn print_struct(s: @ps,\n                     ident: ast::ident,\n                     span: codemap::span) {\n     print_ident(s, ident);\n-    nbsp(s);\n     print_generics(s, generics);\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n-        popen(s);\n-        let mut first = true;\n-        for struct_def.fields.each |field| {\n-            if first {\n-                first = false;\n-            } else {\n-                word_space(s, ~\",\");\n-            }\n-\n-            match field.node.kind {\n-                ast::named_field(*) => fail!(~\"unexpected named field\"),\n-                ast::unnamed_field => {\n-                    maybe_print_comment(s, field.span.lo);\n-                    print_type(s, field.node.ty);\n+        if !struct_def.fields.is_empty() {\n+            popen(s);\n+            do commasep(s, inconsistent, struct_def.fields) |s, field| {\n+                match field.node.kind {\n+                    ast::named_field(*) => fail!(~\"unexpected named field\"),\n+                    ast::unnamed_field => {\n+                        maybe_print_comment(s, field.span.lo);\n+                        print_type(s, field.node.ty);\n+                    }\n                 }\n             }\n+            pclose(s);\n         }\n-        pclose(s);\n         word(s.s, ~\";\");\n+        end(s);\n         end(s); // close the outer-box\n     } else {\n+        nbsp(s);\n         bopen(s);\n         hardbreak_if_not_bol(s);\n         do struct_def.dtor.iter |dtor| {\n@@ -1214,7 +1210,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                 print_expr(s, expr);\n                 end(s);\n             }\n-            _ => word(s.s, ~\",\")\n+            _ => (word(s.s, ~\",\"))\n         }\n         word(s.s, ~\"}\");\n       }"}, {"sha": "cbbf484ad557047ca071fc664ef13f29dde812d6", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -9,18 +9,23 @@\n // except according to those terms.\n \n // error-pattern: mismatched types\n-type clam = {x: @int, y: @int};\n+struct clam {\n+    x: @int,\n+    y: @int,\n+}\n \n-type fish = {a: @int};\n+struct fish {\n+    a: @int,\n+}\n \n fn main() {\n-    let a: clam = {x: @1, y: @2};\n-    let b: clam = {x: @10, y: @20};\n+    let a: clam = clam{x: @1, y: @2};\n+    let b: clam = clam{x: @10, y: @20};\n     let z: int = a.x + b.y;\n     log(debug, z);\n     assert (z == 21);\n-    let forty: fish = {a: @40};\n-    let two: fish = {a: @2};\n+    let forty: fish = fish{a: @40};\n+    let two: fish = fish{a: @2};\n     let answer: int = forty.a + two.a;\n     log(debug, answer);\n     assert (answer == 42);"}, {"sha": "3707dc923c8c19ca1b2b029581e8d1058712c77f", "filename": "src/test/compile-fail/bad-record-pat-2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:did not expect a record with a field `q`\n-\n-fn main() { match {x: 1, y: 2} { {x: x, q: q} => { } } }"}, {"sha": "a7ce8e2ef5c79f030571c12695982b074f4a0dbc", "filename": "src/test/compile-fail/bad-record-pat.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:expected a record with 2 fields, found one with 1\n-\n-fn main() { match {x: 1, y: 2} { {x: x} => { } } }"}, {"sha": "3e560c8eaf6eb57c7f83335ff7c5f52b56f52d77", "filename": "src/test/compile-fail/binop-add-tup-assign.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:+ cannot be applied to type `{x: bool}`\n-\n-fn main() { let x = {x: true}; x += {x: false}; }"}, {"sha": "660e951c84732dadd72b039e594513823bcf5e4c", "filename": "src/test/compile-fail/binop-add-tup.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:+ cannot be applied to type `{x: bool}`\n-\n-fn main() { let x = {x: true} + {x: false}; }"}, {"sha": "b3154c9742aca6e933c0cf05d71cef2af8f0b62f", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -9,9 +9,14 @@\n // except according to those terms.\n \n // error-pattern:`break` outside of loop\n+\n+struct Foo {\n+    t: ~str\n+}\n+\n fn main() {\n     let pth = break;\n \n-    let rs: {t: ~str} = {t: pth};\n+    let rs: Foo = Foo{t: pth};\n \n }"}, {"sha": "64d76d6fb7445963ed1f40e1c33f579aa193396a", "filename": "src/test/compile-fail/fru-extra-field.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,21 +0,0 @@\n-// -*- rust -*-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// error-pattern: record\n-\n-type point = {x: int, y: int};\n-\n-fn main() {\n-    let origin: point = {x: 0, y: 0};\n-\n-    let origin3d: point = {z: 0,.. origin};\n-}"}, {"sha": "9bd9db207799317462030f083e7daacebf159a48", "filename": "src/test/compile-fail/let-destruct-refutable.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:refutable pattern\n-// error-pattern:refutable pattern\n-\n-enum xx { xx(int), yy, }\n-\n-fn main() {\n-    let @{x: xx(x), y: y} = @{x: xx(10), y: 20};\n-    assert (x + y == 30);\n-\n-    let [a, b] = ~[1, 2];\n-}"}, {"sha": "d90e2f372a84e812f321c3fa0e76cbf089a68dd3", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = Some(private::exclusive(false));\n+    let x = Some(unstable::exclusive(false));\n     match x {\n         Some(copy z) => { //~ ERROR copying a value of non-copyable type\n             do z.with |b| { assert !*b; }"}, {"sha": "d84775d02ac6463de6b60bc4ad8126913458d317", "filename": "src/test/compile-fail/nonscalar-cast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,6 +10,10 @@\n \n // error-pattern:non-scalar cast\n \n+struct foo {\n+    x:int\n+}\n+\n fn main() {\n-  log(debug, { x: 1 } as int);\n+    log(debug, foo{ x: 1 } as int);\n }"}, {"sha": "962201aa9b966f8a1d09b2a3b1cff6f24fd2a24f", "filename": "src/test/compile-fail/rec-expected.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Frec-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Frec-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-expected.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-type foo = {a: int};\n-type bar = {b: int};\n-\n-fn want_foo(f: foo) {}\n-fn have_bar(b: bar) {\n-    want_foo(b); //~ ERROR expected a record with field `a`\n-}\n-\n-fn main() {}"}, {"sha": "aa4f9d0501a2aa641caa6a71c62c83fb15645d12", "filename": "src/test/compile-fail/rec-extend.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Frec-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Frec-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-extend.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:expected `int` but found `bool`\n-\n-fn main() {\n-\n-    let a = {foo: 0i};\n-\n-    let b = {foo: true,.. a};\n-}"}, {"sha": "2ad2f00ee266f180c2c210507ef87147724d6e65", "filename": "src/test/compile-fail/rec-missing-fields.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,19 +0,0 @@\n-// -*- rust -*-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// error-pattern: mismatched types\n-\n-// Issue #51.\n-\n-type point = {x: int, y: int};\n-\n-fn main() { let p: point = {x: 10}; log(debug, p.y); }"}, {"sha": "3b2591c3bfab6505f4b1f119eb9ecb48fb332243", "filename": "src/test/compile-fail/writing-through-read-alias.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,19 +0,0 @@\n-// -*- rust -*-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// error-pattern:assigning to immutable field\n-\n-type point = {x: int, y: int, z: int};\n-\n-fn f(p: point) { p.x = 13; }\n-\n-fn main() { let x: point = {x: 10, y: 11, z: 12}; f(x); }"}, {"sha": "4cc9dae7debface52b2caf6b0d8c79b03b5ed76b", "filename": "src/test/compile-fail/writing-to-immutable-rec.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: assigning to immutable field\n-fn main() { let r: {x: int} = {x: 1}; r.x = 6; }"}, {"sha": "0d54848a4a962016de32cbfa350da06967aa7535", "filename": "src/test/pretty/struct-tuple.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fpretty%2Fstruct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Fpretty%2Fstruct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstruct-tuple.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -0,0 +1,10 @@\n+// pp-exact\n+struct Foo;\n+struct Bar(int, int);\n+\n+fn main() {\n+    struct Foo2;\n+    struct Bar2(int, int, int);\n+    let a = Bar(5, 5);\n+    let b = Foo;\n+}"}, {"sha": "d9c348cf99335024987d89ac3fbe43fc61b522ae", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = Some(private::exclusive(true));\n+    let x = Some(unstable::exclusive(true));\n     match x {\n         Some(ref z) if z.with(|b| *b) => {\n             do z.with |b| { assert *b; }"}, {"sha": "86f23dd5210dff6387f53bcc8a9157d7e9b72430", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-use core::private::run_in_bare_thread;\n+use core::unstable::run_in_bare_thread;\n \n extern {\n     pub fn rust_dbg_call(cb: *u8,"}, {"sha": "e5107ba187cbb3cfea313372e4eb18e6c58d528b", "filename": "src/test/run-pass/lint-structural-records.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Frun-pass%2Flint-structural-records.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3505d8ff043f0c1da62de4f517eed6defb6187/src%2Ftest%2Frun-pass%2Flint-structural-records.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-structural-records.rs?ref=aa3505d8ff043f0c1da62de4f517eed6defb6187", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[warn(structural_records)];\n-pub fn main() {\n-    let _foo = {x:5};\n-}"}, {"sha": "d180f6c726043fdd3a6b2e222cf71d6740ed44fc", "filename": "src/test/run-pass/type-use-i1-versus-i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -11,5 +11,5 @@\n pub fn main() {\n     let mut x: bool = false;\n     // this line breaks it\n-    private::intrinsics::move_val_init(&mut x, false);\n+    unstable::intrinsics::move_val_init(&mut x, false);\n }"}, {"sha": "def49ef0f8c3395be5f266a35ec8fdb0f54bcf4e", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -24,7 +24,7 @@ fn make_uniq_closure<A:Owned + Copy>(a: A) -> fn~() -> uint {\n \n fn empty_pointy() -> @mut Pointy {\n     return @mut Pointy {\n-        mut a : none,\n+        a : none,\n         d : make_uniq_closure(~\"hi\")\n     }\n }"}]}