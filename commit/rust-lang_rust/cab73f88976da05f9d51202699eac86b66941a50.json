{"sha": "cab73f88976da05f9d51202699eac86b66941a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYjczZjg4OTc2ZGEwNWY5ZDUxMjAyNjk5ZWFjODZiNjY5NDFhNTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-28T06:02:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-28T17:12:05Z"}, "message": "Write metadata for more meta_item types. Issue #487", "tree": {"sha": "b3e3398417a219587360926449a388e8b03ba1dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3e3398417a219587360926449a388e8b03ba1dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cab73f88976da05f9d51202699eac86b66941a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cab73f88976da05f9d51202699eac86b66941a50", "html_url": "https://github.com/rust-lang/rust/commit/cab73f88976da05f9d51202699eac86b66941a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cab73f88976da05f9d51202699eac86b66941a50/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f53c4f79d75cd70264f54c1384daa9e653adbefe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f53c4f79d75cd70264f54c1384daa9e653adbefe", "html_url": "https://github.com/rust-lang/rust/commit/f53c4f79d75cd70264f54c1384daa9e653adbefe"}], "stats": {"total": 150, "additions": 95, "deletions": 55}, "files": [{"sha": "25c8b8b17d8f814d7788d50c3b08bbe7f6f45d9c", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -292,12 +292,10 @@ fn get_crate_meta_export(&session::session sess, &ast::crate c, str k,\n     for each (@ast::meta_item mi in crate_export_metas(c)) {\n         // FIXME (#487): Support all variants of meta_item\n         alt (mi.node) {\n-            case (ast::meta_key_value(?key, ?value)) {\n-                if (key == k) { v += [mi]; }\n-            }\n-            case (_) {\n-                sess.unimpl(\"meta_item variant\");\n+            case (ast::meta_name_value(?name, ?value)) {\n+                if (name == k) { v += [mi]; }\n             }\n+            case (_) {}\n         }\n     }\n     alt (vec::len(v)) {\n@@ -310,11 +308,11 @@ fn get_crate_meta_export(&session::session sess, &ast::crate c, str k,\n         }\n         case (1u) {\n             alt (v.(0).node) {\n-                case (ast::meta_key_value(_, ?value)) {\n+                case (ast::meta_name_value(_, ?value)) {\n                     ret value;\n                 }\n                 case (_) {\n-                    sess.unimpl(\"meta_item variant\");\n+                    ret default;\n                 }\n             }\n         }\n@@ -333,8 +331,11 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n                 case (ast::meta_word(?name)) {\n                     name\n                 }\n-                case (ast::meta_key_value(?key, _)) {\n-                    key\n+                case (ast::meta_name_value(?name, _)) {\n+                    name\n+                }\n+                case (ast::meta_list(?name, _)) {\n+                    name\n                 }\n             }\n         }\n@@ -344,8 +345,8 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n     let vec[mutable @ast::meta_item] v = [mutable ];\n     for each (@ast::meta_item mi in crate_export_metas(crate)) {\n         alt (mi.node) {\n-            case (ast::meta_key_value(?key, _)) {\n-                if (key != \"name\" && key != \"vers\") {\n+            case (ast::meta_name_value(?name, _)) {\n+                if (name != \"name\" && name != \"vers\") {\n                     v += [mutable mi];\n                 }\n             }\n@@ -359,13 +360,14 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n     for (@ast::meta_item m_ in v) {\n         auto m = m_;\n         alt (m.node) {\n-            case (ast::meta_key_value(?key, ?value)) {\n+            case (ast::meta_name_value(?key, ?value)) {\n                 sha.input_str(len_and_str(key));\n                 sha.input_str(len_and_str(value));\n             }\n             case (ast::meta_word(?name)) {\n                 sha.input_str(len_and_str(name));\n             }\n+            case (_) {}\n         }\n     }\n     ret truncated_sha1_result(sha);"}, {"sha": "abc1c11a44afff8f49cd958e21deb358425676e1", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -103,7 +103,7 @@ type meta_item = spanned[meta_item_];\n tag meta_item_ {\n     meta_word(ident);\n     meta_list(ident, vec[@meta_item]);\n-    meta_key_value(ident, str);\n+    meta_name_value(ident, str);\n }\n \n type block = spanned[block_];"}, {"sha": "d39c30607624813734090af55cac0b97e928723d", "filename": "src/comp/front/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Ffront%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Ffront%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ffold.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -104,8 +104,8 @@ fn fold_meta_item_(&@meta_item mi, ast_fold fld) -> @meta_item {\n                      auto fold_meta_item = bind fold_meta_item_(_,fld);\n                      meta_list(id, map(fold_meta_item, mis))\n                  }\n-                 case (meta_key_value(?id,?s)) {\n-                     meta_key_value(fld.fold_ident(id),s)\n+                 case (meta_name_value(?id,?s)) {\n+                     meta_name_value(fld.fold_ident(id),s)\n                  }\n              },\n              span=mi.span);"}, {"sha": "801a02d6511f159d1245cfa23cfc861029465ddc", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -2142,7 +2142,7 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n                     p.bump();\n                     auto value = p.get_str(s);\n                     auto hi = p.get_hi_pos();\n-                    ret @spanned(lo, hi, ast::meta_key_value(ident, value));\n+                    ret @spanned(lo, hi, ast::meta_name_value(ident, value));\n                 }\n                 case (_) {\n                     p.fatal(\"Metadata items must be string literals\");"}, {"sha": "c2899e17953a1a32b8ee39d32ae39dc6978671eb", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -30,22 +30,22 @@ fn metadata_matches(hashmap[str, str] mm, &vec[@ast::meta_item] metas) ->\n              vec::len(metas), mm.size());\n     for (@ast::meta_item mi in metas) {\n         alt (mi.node) {\n-            case (ast::meta_key_value(?key, ?value)) {\n-                alt (mm.find(key)) {\n+            case (ast::meta_name_value(?name, ?value)) {\n+                alt (mm.find(name)) {\n                     case (some(?v)) {\n                         if (v == value) {\n-                            log #fmt(\"matched '%s': '%s'\", key,\n+                            log #fmt(\"matched '%s': '%s'\", name,\n                                      value);\n                         } else {\n                             log #fmt(\"missing '%s': '%s' (got '%s')\",\n-                                     key,\n+                                     name,\n                                      value, v);\n                             ret false;\n                         }\n                     }\n                     case (none) {\n                         log #fmt(\"missing '%s': '%s'\",\n-                                 key, value);\n+                                 name, value);\n                         ret false;\n                     }\n                 }\n@@ -76,15 +76,14 @@ fn find_library_crate(&session::session sess, &ast::ident ident,\n     let str crate_name = ident;\n     for (@ast::meta_item mi in metas) {\n         alt (mi.node) {\n-            case (ast::meta_key_value(?key, ?value)) {\n-                if (key == \"name\") {\n+            case (ast::meta_name_value(?name, ?value)) {\n+                if (name == \"name\") {\n                     crate_name = value;\n                     break;\n                 }\n             }\n             case (_) {\n                 // FIXME (#487)\n-                sess.unimpl(\"meta_item variant\")\n             }\n         }\n     }"}, {"sha": "8a58a4ce31931e84e1e1e58ab91123e8f7376c20", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -256,16 +256,31 @@ fn item_kind_to_str(u8 kind) -> str {\n     }\n }\n \n-fn get_meta_items(&ebml::doc md) -> vec[ast::meta_item] {\n-    let vec[ast::meta_item] items = [];\n+fn get_meta_items(&ebml::doc md) -> vec[@ast::meta_item] {\n+    let vec[@ast::meta_item] items = [];\n     for each (ebml::doc meta_item_doc in\n-              ebml::tagged_docs(md, tag_meta_item_key_value)) {\n-        auto kd = ebml::get_doc(meta_item_doc, tag_meta_item_key);\n+              ebml::tagged_docs(md, tag_meta_item_word)) {\n+        auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        items += [@rec(node=ast::meta_word(n),\n+                       span=rec(lo=0u, hi=0u))];\n+    }\n+    for each (ebml::doc meta_item_doc in\n+              ebml::tagged_docs(md, tag_meta_item_name_value)) {\n+        auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         auto vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        auto k = str::unsafe_from_bytes(ebml::doc_data(kd));\n+        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         auto v = str::unsafe_from_bytes(ebml::doc_data(vd));\n-        items += [rec(node=ast::meta_key_value(k, v),\n-                      span=rec(lo=0u, hi=0u))];\n+        items += [@rec(node=ast::meta_name_value(n, v),\n+                       span=rec(lo=0u, hi=0u))];\n+    }\n+    for each (ebml::doc meta_item_doc in\n+              ebml::tagged_docs(md, tag_meta_item_list)) {\n+        auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        auto subitems = get_meta_items(meta_item_doc);\n+        items += [@rec(node=ast::meta_list(n, subitems),\n+                       span=rec(lo=0u, hi=0u))];                  \n     }\n     ret items;\n }\n@@ -279,10 +294,11 @@ fn get_attributes(&ebml::doc md) -> vec[ast::attribute] {\n                 auto meta_items = get_meta_items(attr_doc);\n                 // Currently it's only possible to have a single meta item on\n                 // an attribute\n+                log_err vec::len(meta_items);\n                 assert (vec::len(meta_items) == 1u);\n                 auto meta_item = meta_items.(0);\n                 attrs += [rec(node=rec(style=ast::attr_outer,\n-                                       value=meta_item),\n+                                       value=*meta_item),\n                               span=rec(lo=0u, hi=0u))];\n             }\n         }\n@@ -292,8 +308,8 @@ fn get_attributes(&ebml::doc md) -> vec[ast::attribute] {\n }\n \n fn list_meta_items(&ebml::doc meta_items, io::writer out) {\n-    for (ast::meta_item mi in get_meta_items(meta_items)) {\n-        out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(mi)));\n+    for (@ast::meta_item mi in get_meta_items(meta_items)) {\n+        out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(*mi)));\n     }\n }\n \n@@ -345,14 +361,14 @@ fn get_exported_metadata(&session::session sess, &str path, &vec[u8] data) ->\n         ebml::get_doc(ebml::new_doc(data), tag_meta_export);\n     auto mm = common::new_str_hash[str]();\n     for each (ebml::doc m in\n-             ebml::tagged_docs(meta_items, tag_meta_item_key_value)) {\n-        auto kd = ebml::get_doc(m, tag_meta_item_key);\n+             ebml::tagged_docs(meta_items, tag_meta_item_name_value)) {\n+        auto nd = ebml::get_doc(m, tag_meta_item_name);\n         auto vd = ebml::get_doc(m, tag_meta_item_value);\n-        auto k = str::unsafe_from_bytes(ebml::doc_data(kd));\n+        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         auto v = str::unsafe_from_bytes(ebml::doc_data(vd));\n-        log #fmt(\"metadata in %s: %s = %s\", path, k, v);\n-        if (!mm.insert(k, v)) {\n-            sess.warn(#fmt(\"Duplicate metadata item in %s: %s\", path, k));\n+        log #fmt(\"metadata in %s: %s = %s\", path, n, v);\n+        if (!mm.insert(n, v)) {\n+            sess.warn(#fmt(\"Duplicate metadata item in %s: %s\", path, n));\n         }\n     }\n     ret mm;"}, {"sha": "27a36e826753a29ef133907110878e5e48b105b0", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -418,21 +418,35 @@ fn write_int(&io::writer writer, &int n) {\n \n fn encode_meta_item(&ebml::writer ebml_w, &meta_item mi) {\n     // FIXME (#487): Support all forms of meta item\n-    ebml::start_tag(ebml_w, tag_meta_item_key_value);\n     alt (mi.node) {\n-        case (meta_key_value(?key, ?value)) {\n-            ebml::start_tag(ebml_w, tag_meta_item_key);\n-            ebml_w.writer.write(str::bytes(key));\n+        case (meta_word(?name)) {\n+            ebml::start_tag(ebml_w, tag_meta_item_word);\n+            ebml::start_tag(ebml_w, tag_meta_item_name);\n+            ebml_w.writer.write(str::bytes(name));\n+            ebml::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (meta_name_value(?name, ?value)) {\n+            ebml::start_tag(ebml_w, tag_meta_item_name_value);\n+            ebml::start_tag(ebml_w, tag_meta_item_name);\n+            ebml_w.writer.write(str::bytes(name));\n             ebml::end_tag(ebml_w);\n             ebml::start_tag(ebml_w, tag_meta_item_value);\n             ebml_w.writer.write(str::bytes(value));\n             ebml::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        case (_) {\n-            log_err \"unimplemented meta_item type\";\n+        case (meta_list(?name, ?items)) {\n+            ebml::start_tag(ebml_w, tag_meta_item_list);\n+            ebml::start_tag(ebml_w, tag_meta_item_name);\n+            ebml_w.writer.write(str::bytes(name));\n+            ebml::end_tag(ebml_w);\n+            for (@meta_item inner_item in items) {\n+                encode_meta_item(ebml_w, *inner_item);\n+            }\n+            ebml::end_tag(ebml_w);\n         }\n     }\n-    ebml::end_tag(ebml_w);\n }\n \n fn encode_attributes(&ebml::writer ebml_w, &vec[attribute] attrs) {"}, {"sha": "43d7b3581eadfa775d542b60fe09c6e8cb085831", "filename": "src/comp/metadata/tags.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fmetadata%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftags.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -44,13 +44,16 @@ const uint tag_meta_export = 0x16u;\n \n const uint tag_meta_local = 0x17u;\n \n-const uint tag_meta_item_key_value = 0x18u;\n+const uint tag_meta_item_name_value = 0x18u;\n \n-const uint tag_meta_item_key = 0x19u;\n+const uint tag_meta_item_name = 0x19u;\n \n const uint tag_meta_item_value = 0x20u;\n \n const uint tag_attributes = 0x21u;\n \n const uint tag_attribute = 0x22u;\n \n+const uint tag_meta_item_word = 0x23u;\n+\n+const uint tag_meta_item_list = 0x24u;\n\\ No newline at end of file"}, {"sha": "5d20a37e809cd2c759b14720d36dbcb93ffc0968", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -1062,16 +1062,20 @@ fn print_type_params(&ps s, &vec[ast::ty_param] params) {\n \n fn print_meta_item(&ps s, &@ast::meta_item item) {\n     ibox(s, indent_unit);\n-    // FIXME (#487): Print other meta item variants\n     alt (item.node) {\n-        case (ast::meta_key_value(?key, ?value)) {\n-            word_space(s, key);\n+        case (ast::meta_word(?name)) {\n+            word(s.s, name);\n+        }\n+        case (ast::meta_name_value(?name, ?value)) {\n+            word_space(s, name);\n             word_space(s, \"=\");\n             print_string(s, value);\n         }\n-        case (_) {\n-            log_err \"unimplemented meta_item variant\";\n-            fail;\n+        case (ast::meta_list(?name, ?items)) {\n+            word(s.s, name);\n+            popen(s);\n+            commasep(s, consistent, items, print_meta_item);\n+            pclose(s);\n         }\n     }\n     end(s);"}, {"sha": "bb8f068874c7135a00cafe608789195c1d0a9a04", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cab73f88976da05f9d51202699eac86b66941a50/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab73f88976da05f9d51202699eac86b66941a50/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=cab73f88976da05f9d51202699eac86b66941a50", "patch": "@@ -5,6 +5,8 @@\n // notation to specify their module's attributes\n #[attr1 = \"val\"];\n #[attr2 = \"val\"];\n+#[attr3];\n+#[attr4(attr5)];\n \n // These are are attributes of the following mod\n #[attr1 = \"val\"]"}]}