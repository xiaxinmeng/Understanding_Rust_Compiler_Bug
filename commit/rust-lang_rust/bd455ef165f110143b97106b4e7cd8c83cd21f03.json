{"sha": "bd455ef165f110143b97106b4e7cd8c83cd21f03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNDU1ZWYxNjVmMTEwMTQzYjk3MTA2YjRlN2NkOGM4M2NkMjFmMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T08:31:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T08:31:32Z"}, "message": "Auto merge of #52552 - eddyb:proc-macro-prep, r=alexcrichton\n\nPrepare proc_macro for decoupling it from the rest of the compiler.\n\nThis is #49219 up to the point where the bridge is introduced. Aside from moving some code around, the largest change is the rewrite of `proc_macro::quote` to be simpler and do less introspection.\n\nI'd like to also extend `quote!` with `${stmt;...;expr}` instead of just `$variable` (and maybe even `$(... $iter ...)*`), which seems pretty straight-forward now, but I don't know if/when I should.\n\nr? @alexcrichton or @dtolnay cc @jseyfried @petrochenkov", "tree": {"sha": "d9aef588ff6493330f28505c3357f6ba3abd1d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9aef588ff6493330f28505c3357f6ba3abd1d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd455ef165f110143b97106b4e7cd8c83cd21f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd455ef165f110143b97106b4e7cd8c83cd21f03", "html_url": "https://github.com/rust-lang/rust/commit/bd455ef165f110143b97106b4e7cd8c83cd21f03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd455ef165f110143b97106b4e7cd8c83cd21f03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17eb392cefdcf4b98c47f9ab36742e66a314932f", "url": "https://api.github.com/repos/rust-lang/rust/commits/17eb392cefdcf4b98c47f9ab36742e66a314932f", "html_url": "https://github.com/rust-lang/rust/commit/17eb392cefdcf4b98c47f9ab36742e66a314932f"}, {"sha": "99eac011c6059de129de4b1c8ab7c6cd6794e6e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/99eac011c6059de129de4b1c8ab7c6cd6794e6e4", "html_url": "https://github.com/rust-lang/rust/commit/99eac011c6059de129de4b1c8ab7c6cd6794e6e4"}], "stats": {"total": 1035, "additions": 465, "deletions": 570}, "files": [{"sha": "51e7647f36cc2f9673d49e27a1100182fe995f46", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -10,7 +10,8 @@\n \n use Span;\n \n-use rustc_errors as rustc;\n+use rustc_errors as errors;\n+use syntax_pos::MultiSpan;\n \n /// An enum representing a diagnostic level.\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n@@ -97,38 +98,21 @@ impl Diagnostic {\n     /// Emit the diagnostic.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n     pub fn emit(self) {\n-        ::__internal::with_sess(move |sess, _| {\n-            let handler = &sess.span_diagnostic;\n-            let level = __internal::level_to_internal_level(self.level);\n-            let mut diag = rustc::DiagnosticBuilder::new(handler, level, &*self.message);\n+        let level = self.level.to_internal();\n+        let mut diag = errors::Diagnostic::new(level, &*self.message);\n \n-            if let Some(span) = self.span {\n-                diag.set_span(span.0);\n-            }\n+        if let Some(span) = self.span {\n+            diag.set_span(span.0);\n+        }\n \n-            for child in self.children {\n-                let span = child.span.map(|s| s.0);\n-                let level = __internal::level_to_internal_level(child.level);\n-                diag.sub(level, &*child.message, span);\n-            }\n+        for child in self.children {\n+            let span = child.span.map_or(MultiSpan::new(), |s| s.0.into());\n+            let level = child.level.to_internal();\n+            diag.sub(level, &*child.message, span, None);\n+        }\n \n-            diag.emit();\n+        ::__internal::with_sess(move |sess, _| {\n+            errors::DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, diag).emit();\n         });\n     }\n }\n-\n-#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n-#[doc(hidden)]\n-pub mod __internal {\n-    use super::{Level, rustc};\n-\n-    pub fn level_to_internal_level(level: Level) -> rustc::Level {\n-        match level {\n-            Level::Error => rustc::Level::Error,\n-            Level::Warning => rustc::Level::Warning,\n-            Level::Note => rustc::Level::Note,\n-            Level::Help => rustc::Level::Help,\n-            Level::__Nonexhaustive => unreachable!(\"Level::__Nonexhaustive\")\n-        }\n-    }\n-}"}, {"sha": "61da9db76f6c81e4ca4346b6e61d5025a8ba03b1", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 69, "deletions": 279, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -44,21 +44,24 @@ extern crate syntax_pos;\n extern crate rustc_errors;\n extern crate rustc_data_structures;\n \n+#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+pub mod rustc;\n+\n mod diagnostic;\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n pub use diagnostic::{Diagnostic, Level};\n \n use std::{ascii, fmt, iter};\n+use std::path::PathBuf;\n use rustc_data_structures::sync::Lrc;\n use std::str::FromStr;\n \n-use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax::parse::lexer::{self, comments};\n use syntax_pos::{FileMap, Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n@@ -145,6 +148,9 @@ impl fmt::Debug for TokenStream {\n     }\n }\n \n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n+pub use quote::{quote, quote_span};\n+\n /// Creates a token stream containing a single token tree.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<TokenTree> for TokenStream {\n@@ -237,7 +243,7 @@ pub mod token_stream {\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n ///\n-/// This is a dummy macro, the actual implementation is in quote::Quoter\n+/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n #[macro_export]\n macro_rules! quote { () => {} }\n@@ -246,13 +252,6 @@ macro_rules! quote { () => {} }\n #[doc(hidden)]\n mod quote;\n \n-/// Quote a `Span` into a `TokenStream`.\n-/// This is needed to implement a custom quoter.\n-#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n-pub fn quote_span(span: Span) -> TokenStream {\n-    quote::Quote::quote(span)\n-}\n-\n /// A region of source code, along with macro expansion information.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Copy, Clone)]\n@@ -425,8 +424,11 @@ impl SourceFile {\n     ///\n     /// [`is_real`]: #method.is_real\n     #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n-    pub fn path(&self) -> &FileName {\n-        &self.filemap.name\n+    pub fn path(&self) -> PathBuf {\n+        match self.filemap.name {\n+            FileName::Real(ref path) => path.clone(),\n+            _ => PathBuf::from(self.filemap.name.to_string())\n+        }\n     }\n \n     /// Returns `true` if this source file is a real source file, and not generated by an external\n@@ -440,18 +442,12 @@ impl SourceFile {\n     }\n }\n \n-#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n-impl AsRef<FileName> for SourceFile {\n-    fn as_ref(&self) -> &FileName {\n-        self.path()\n-    }\n-}\n \n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl fmt::Debug for SourceFile {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"SourceFile\")\n-            .field(\"path\", self.path())\n+            .field(\"path\", &self.path())\n             .field(\"is_real\", &self.is_real())\n             .finish()\n     }\n@@ -467,13 +463,6 @@ impl PartialEq for SourceFile {\n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl Eq for SourceFile {}\n \n-#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n-impl PartialEq<FileName> for SourceFile {\n-    fn eq(&self, other: &FileName) -> bool {\n-        self.as_ref() == other\n-    }\n-}\n-\n /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n@@ -599,7 +588,7 @@ impl fmt::Display for TokenTree {\n /// A delimited token stream.\n ///\n /// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Group {\n     delimiter: Delimiter,\n@@ -693,12 +682,23 @@ impl fmt::Display for Group {\n     }\n }\n \n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+impl fmt::Debug for Group {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Group\")\n+            .field(\"delimiter\", &self.delimiter())\n+            .field(\"stream\", &self.stream())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n /// An `Punct` is an single punctuation character like `+`, `-` or `#`.\n ///\n /// Multicharacter operators like `+=` are represented as two instances of `Punct` with different\n /// forms of `Spacing` returned.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct Punct {\n     ch: char,\n     spacing: Spacing,\n@@ -782,8 +782,19 @@ impl fmt::Display for Punct {\n     }\n }\n \n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+impl fmt::Debug for Punct {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Punct\")\n+            .field(\"ch\", &self.as_char())\n+            .field(\"spacing\", &self.spacing())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n /// An identifier (`ident`).\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Ident {\n     sym: Symbol,\n@@ -797,6 +808,16 @@ impl !Send for Ident {}\n impl !Sync for Ident {}\n \n impl Ident {\n+    fn is_valid(string: &str) -> bool {\n+        let mut chars = string.chars();\n+        if let Some(start) = chars.next() {\n+            (start == '_' || start.is_xid_start())\n+                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     /// The `string` argument must be a valid identifier permitted by the\n@@ -818,26 +839,19 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        if !lexer::is_valid_ident(string) {\n+        if !Ident::is_valid(string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        Ident {\n-            sym: Symbol::intern(string),\n-            span,\n-            is_raw: false,\n-        }\n+        Ident::new_maybe_raw(string, span, false)\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n     #[unstable(feature = \"proc_macro_raw_ident\", issue = \"38356\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        let mut ident = Ident::new(string, span);\n-        if ident.sym == keywords::Underscore.name() ||\n-           ast::Ident::with_empty_ctxt(ident.sym).is_path_segment_keyword() {\n-            panic!(\"`{:?}` is not a valid raw identifier\", string)\n+        if !Ident::is_valid(string) {\n+            panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        ident.is_raw = true;\n-        ident\n+        Ident::new_maybe_raw(string, span, true)\n     }\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n@@ -859,22 +873,30 @@ impl Ident {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.is_raw {\n-            f.write_str(\"r#\")?;\n-        }\n-        self.sym.as_str().fmt(f)\n+        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Ident\")\n+            .field(\"ident\", &self.to_string())\n+            .field(\"span\", &self.span())\n+            .finish()\n     }\n }\n \n /// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n /// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n /// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n /// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n+// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n #[derive(Clone, Debug)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Literal {\n     lit: token::Lit,\n-    suffix: Option<ast::Name>,\n+    suffix: Option<Symbol>,\n     span: Span,\n }\n \n@@ -1122,236 +1144,6 @@ impl fmt::Display for Literal {\n     }\n }\n \n-impl Delimiter {\n-    fn from_internal(delim: token::DelimToken) -> Delimiter {\n-        match delim {\n-            token::Paren => Delimiter::Parenthesis,\n-            token::Brace => Delimiter::Brace,\n-            token::Bracket => Delimiter::Bracket,\n-            token::NoDelim => Delimiter::None,\n-        }\n-    }\n-\n-    fn to_internal(self) -> token::DelimToken {\n-        match self {\n-            Delimiter::Parenthesis => token::Paren,\n-            Delimiter::Brace => token::Brace,\n-            Delimiter::Bracket => token::Bracket,\n-            Delimiter::None => token::NoDelim,\n-        }\n-    }\n-}\n-\n-impl TokenTree {\n-    fn from_internal(stream: tokenstream::TokenStream, stack: &mut Vec<TokenTree>)\n-                -> TokenTree {\n-        use syntax::parse::token::*;\n-\n-        let (tree, is_joint) = stream.as_tree();\n-        let (span, token) = match tree {\n-            tokenstream::TokenTree::Token(span, token) => (span, token),\n-            tokenstream::TokenTree::Delimited(span, delimed) => {\n-                let delimiter = Delimiter::from_internal(delimed.delim);\n-                let mut g = Group::new(delimiter, TokenStream(delimed.tts.into()));\n-                g.set_span(Span(span));\n-                return g.into()\n-            }\n-        };\n-\n-        let op_kind = if is_joint { Spacing::Joint } else { Spacing::Alone };\n-        macro_rules! tt {\n-            ($e:expr) => ({\n-                let mut x = TokenTree::from($e);\n-                x.set_span(Span(span));\n-                x\n-            })\n-        }\n-        macro_rules! op {\n-            ($a:expr) => (tt!(Punct::new($a, op_kind)));\n-            ($a:expr, $b:expr) => ({\n-                stack.push(tt!(Punct::new($b, op_kind)));\n-                tt!(Punct::new($a, Spacing::Joint))\n-            });\n-            ($a:expr, $b:expr, $c:expr) => ({\n-                stack.push(tt!(Punct::new($c, op_kind)));\n-                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n-                tt!(Punct::new($a, Spacing::Joint))\n-            })\n-        }\n-\n-        match token {\n-            Eq => op!('='),\n-            Lt => op!('<'),\n-            Le => op!('<', '='),\n-            EqEq => op!('=', '='),\n-            Ne => op!('!', '='),\n-            Ge => op!('>', '='),\n-            Gt => op!('>'),\n-            AndAnd => op!('&', '&'),\n-            OrOr => op!('|', '|'),\n-            Not => op!('!'),\n-            Tilde => op!('~'),\n-            BinOp(Plus) => op!('+'),\n-            BinOp(Minus) => op!('-'),\n-            BinOp(Star) => op!('*'),\n-            BinOp(Slash) => op!('/'),\n-            BinOp(Percent) => op!('%'),\n-            BinOp(Caret) => op!('^'),\n-            BinOp(And) => op!('&'),\n-            BinOp(Or) => op!('|'),\n-            BinOp(Shl) => op!('<', '<'),\n-            BinOp(Shr) => op!('>', '>'),\n-            BinOpEq(Plus) => op!('+', '='),\n-            BinOpEq(Minus) => op!('-', '='),\n-            BinOpEq(Star) => op!('*', '='),\n-            BinOpEq(Slash) => op!('/', '='),\n-            BinOpEq(Percent) => op!('%', '='),\n-            BinOpEq(Caret) => op!('^', '='),\n-            BinOpEq(And) => op!('&', '='),\n-            BinOpEq(Or) => op!('|', '='),\n-            BinOpEq(Shl) => op!('<', '<', '='),\n-            BinOpEq(Shr) => op!('>', '>', '='),\n-            At => op!('@'),\n-            Dot => op!('.'),\n-            DotDot => op!('.', '.'),\n-            DotDotDot => op!('.', '.', '.'),\n-            DotDotEq => op!('.', '.', '='),\n-            Comma => op!(','),\n-            Semi => op!(';'),\n-            Colon => op!(':'),\n-            ModSep => op!(':', ':'),\n-            RArrow => op!('-', '>'),\n-            LArrow => op!('<', '-'),\n-            FatArrow => op!('=', '>'),\n-            Pound => op!('#'),\n-            Dollar => op!('$'),\n-            Question => op!('?'),\n-            SingleQuote => op!('\\''),\n-\n-            Ident(ident, false) => {\n-                tt!(self::Ident::new(&ident.as_str(), Span(span)))\n-            }\n-            Ident(ident, true) => {\n-                tt!(self::Ident::new_raw(&ident.as_str(), Span(span)))\n-            }\n-            Lifetime(ident) => {\n-                let ident = ident.without_first_quote();\n-                stack.push(tt!(self::Ident::new(&ident.as_str(), Span(span))));\n-                tt!(Punct::new('\\'', Spacing::Joint))\n-            }\n-            Literal(lit, suffix) => tt!(self::Literal { lit, suffix, span: Span(span) }),\n-            DocComment(c) => {\n-                let style = comments::doc_comment_style(&c.as_str());\n-                let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n-                let stream = vec![\n-                    tt!(self::Ident::new(\"doc\", Span(span))),\n-                    tt!(Punct::new('=', Spacing::Alone)),\n-                    tt!(self::Literal::string(&stripped)),\n-                ].into_iter().collect();\n-                stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n-                if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n-                }\n-                tt!(Punct::new('#', Spacing::Alone))\n-            }\n-\n-            Interpolated(_) => {\n-                __internal::with_sess(|sess, _| {\n-                    let tts = token.interpolated_to_tokenstream(sess, span);\n-                    tt!(Group::new(Delimiter::None, TokenStream(tts)))\n-                })\n-            }\n-\n-            DotEq => op!('.', '='),\n-            OpenDelim(..) | CloseDelim(..) => unreachable!(),\n-            Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n-        }\n-    }\n-\n-    fn to_internal(self) -> tokenstream::TokenStream {\n-        use syntax::parse::token::*;\n-        use syntax::tokenstream::{TokenTree, Delimited};\n-\n-        let (ch, kind, span) = match self {\n-            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n-            self::TokenTree::Group(tt) => {\n-                return TokenTree::Delimited(tt.span.0, Delimited {\n-                    delim: tt.delimiter.to_internal(),\n-                    tts: tt.stream.0.into(),\n-                }).into();\n-            },\n-            self::TokenTree::Ident(tt) => {\n-                let token = Ident(ast::Ident::new(tt.sym, tt.span.0), tt.is_raw);\n-                return TokenTree::Token(tt.span.0, token).into();\n-            }\n-            self::TokenTree::Literal(self::Literal {\n-                lit: Lit::Integer(ref a),\n-                suffix,\n-                span,\n-            })\n-                if a.as_str().starts_with(\"-\") =>\n-            {\n-                let minus = BinOp(BinOpToken::Minus);\n-                let integer = Symbol::intern(&a.as_str()[1..]);\n-                let integer = Literal(Lit::Integer(integer), suffix);\n-                let a = TokenTree::Token(span.0, minus);\n-                let b = TokenTree::Token(span.0, integer);\n-                return vec![a, b].into_iter().collect()\n-            }\n-            self::TokenTree::Literal(self::Literal {\n-                lit: Lit::Float(ref a),\n-                suffix,\n-                span,\n-            })\n-                if a.as_str().starts_with(\"-\") =>\n-            {\n-                let minus = BinOp(BinOpToken::Minus);\n-                let float = Symbol::intern(&a.as_str()[1..]);\n-                let float = Literal(Lit::Float(float), suffix);\n-                let a = TokenTree::Token(span.0, minus);\n-                let b = TokenTree::Token(span.0, float);\n-                return vec![a, b].into_iter().collect()\n-            }\n-            self::TokenTree::Literal(tt) => {\n-                let token = Literal(tt.lit, tt.suffix);\n-                return TokenTree::Token(tt.span.0, token).into()\n-            }\n-        };\n-\n-        let token = match ch {\n-            '=' => Eq,\n-            '<' => Lt,\n-            '>' => Gt,\n-            '!' => Not,\n-            '~' => Tilde,\n-            '+' => BinOp(Plus),\n-            '-' => BinOp(Minus),\n-            '*' => BinOp(Star),\n-            '/' => BinOp(Slash),\n-            '%' => BinOp(Percent),\n-            '^' => BinOp(Caret),\n-            '&' => BinOp(And),\n-            '|' => BinOp(Or),\n-            '@' => At,\n-            '.' => Dot,\n-            ',' => Comma,\n-            ';' => Semi,\n-            ':' => Colon,\n-            '#' => Pound,\n-            '$' => Dollar,\n-            '?' => Question,\n-            '\\'' => SingleQuote,\n-            _ => unreachable!(),\n-        };\n-\n-        let tree = TokenTree::Token(span.0, token);\n-        match kind {\n-            Spacing::Alone => tree.into(),\n-            Spacing::Joint => tree.joint(),\n-        }\n-    }\n-}\n-\n /// Permanently unstable internal implementation details of this crate. This\n /// should not be used.\n ///\n@@ -1364,8 +1156,6 @@ impl TokenTree {\n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]\n pub mod __internal {\n-    pub use quote::{LiteralKind, SpannedSymbol, Quoter, unquote};\n-\n     use std::cell::Cell;\n     use std::ptr;\n "}, {"sha": "7ae7b13a15217b2026cd3adfde27e88c598620c7", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 92, "deletions": 252, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -14,35 +14,26 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Literal, Spacing, Span, Ident, Punct, Group, TokenStream, TokenTree};\n-\n-use syntax::ext::base::{ExtCtxt, ProcMacro};\n-use syntax::parse::token;\n-use syntax::symbol::Symbol;\n-use syntax::tokenstream;\n-\n-/// This is the actual quote!() proc macro\n-///\n-/// It is manually loaded in CStore::load_macro_untracked\n-pub struct Quoter;\n-\n-pub fn unquote<T: Into<TokenStream> + Clone>(tokens: &T) -> TokenStream {\n-    tokens.clone().into()\n-}\n-\n-pub trait Quote {\n-    fn quote(self) -> TokenStream;\n-}\n-\n-macro_rules! tt2ts {\n-    ($e:expr) => (TokenStream::from(TokenTree::from($e)))\n-}\n-\n-macro_rules! quote_tok {\n-    (,) => { tt2ts!(Punct::new(',', Spacing::Alone)) };\n-    (.) => { tt2ts!(Punct::new('.', Spacing::Alone)) };\n-    (:) => { tt2ts!(Punct::new(':', Spacing::Alone)) };\n-    (|) => { tt2ts!(Punct::new('|', Spacing::Alone)) };\n+use {Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+\n+macro_rules! quote_tt {\n+    (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n+    ([$($t:tt)*]) => { Group::new(Delimiter::Bracket, quote!($($t)*)) };\n+    ({$($t:tt)*}) => { Group::new(Delimiter::Brace, quote!($($t)*)) };\n+    (,) => { Punct::new(',', Spacing::Alone) };\n+    (.) => { Punct::new('.', Spacing::Alone) };\n+    (:) => { Punct::new(':', Spacing::Alone) };\n+    (;) => { Punct::new(';', Spacing::Alone) };\n+    (!) => { Punct::new('!', Spacing::Alone) };\n+    (<) => { Punct::new('<', Spacing::Alone) };\n+    (>) => { Punct::new('>', Spacing::Alone) };\n+    (&) => { Punct::new('&', Spacing::Alone) };\n+    (=) => { Punct::new('=', Spacing::Alone) };\n+    ($i:ident) => { Ident::new(stringify!($i), Span::def_site()) };\n+}\n+\n+macro_rules! quote_ts {\n+    ((@ $($t:tt)*)) => { $($t)* };\n     (::) => {\n         [\n             TokenTree::from(Punct::new(':', Spacing::Joint)),\n@@ -55,65 +46,45 @@ macro_rules! quote_tok {\n             })\n             .collect::<TokenStream>()\n     };\n-    (!) => { tt2ts!(Punct::new('!', Spacing::Alone)) };\n-    (<) => { tt2ts!(Punct::new('<', Spacing::Alone)) };\n-    (>) => { tt2ts!(Punct::new('>', Spacing::Alone)) };\n-    (_) => { tt2ts!(Punct::new('_', Spacing::Alone)) };\n-    (0) => { tt2ts!(Literal::i8_unsuffixed(0)) };\n-    (&) => { tt2ts!(Punct::new('&', Spacing::Alone)) };\n-    ($i:ident) => { tt2ts!(Ident::new(stringify!($i), Span::def_site())) };\n-}\n-\n-macro_rules! quote_tree {\n-    ((unquote $($t:tt)*)) => { $($t)* };\n-    ((quote $($t:tt)*)) => { ($($t)*).quote() };\n-    (($($t:tt)*)) => { tt2ts!(Group::new(Delimiter::Parenthesis, quote!($($t)*))) };\n-    ([$($t:tt)*]) => { tt2ts!(Group::new(Delimiter::Bracket, quote!($($t)*))) };\n-    ({$($t:tt)*}) => { tt2ts!(Group::new(Delimiter::Brace, quote!($($t)*))) };\n-    ($t:tt) => { quote_tok!($t) };\n+    ($t:tt) => { TokenTree::from(quote_tt!($t)) };\n }\n \n+/// Simpler version of the real `quote!` macro, implemented solely\n+/// through `macro_rules`, for bootstrapping the real implementation\n+/// (see the `quote` function), which does not have access to the\n+/// real `quote!` macro due to the `proc_macro` crate not being\n+/// able to depend on itself.\n+///\n+/// Note: supported tokens are a subset of the real `quote!`, but\n+/// unquoting is different: instead of `$x`, this uses `(@ expr)`.\n macro_rules! quote {\n     () => { TokenStream::new() };\n     ($($t:tt)*) => {\n-        [$(quote_tree!($t),)*].iter()\n-            .cloned()\n-            .flat_map(|x| x.into_iter())\n-            .collect::<TokenStream>()\n+        [\n+            $(TokenStream::from(quote_ts!($t)),)*\n+        ].iter().cloned().collect::<TokenStream>()\n     };\n }\n \n-impl ProcMacro for Quoter {\n-    fn expand<'cx>(&self, cx: &'cx mut ExtCtxt,\n-                   _: ::syntax_pos::Span,\n-                   stream: tokenstream::TokenStream)\n-                   -> tokenstream::TokenStream {\n-        ::__internal::set_sess(cx, || TokenStream(stream).quote().0)\n-    }\n-}\n-\n-impl<T: Quote> Quote for Option<T> {\n-    fn quote(self) -> TokenStream {\n-        match self {\n-            Some(t) => quote!(Some((quote t))),\n-            None => quote!(None),\n-        }\n+/// Quote a `TokenStream` into a `TokenStream`.\n+/// This is the actual `quote!()` proc macro.\n+///\n+/// It is manually loaded in `CStore::load_macro_untracked`.\n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n+pub fn quote(stream: TokenStream) -> TokenStream {\n+    if stream.is_empty() {\n+        return quote!(::TokenStream::new());\n     }\n-}\n-\n-impl Quote for TokenStream {\n-    fn quote(self) -> TokenStream {\n-        if self.is_empty() {\n-            return quote!(::TokenStream::new());\n-        }\n-        let mut after_dollar = false;\n-        let tokens = self.into_iter().filter_map(|tree| {\n+    let mut after_dollar = false;\n+    let tokens = stream\n+        .into_iter()\n+        .filter_map(|tree| {\n             if after_dollar {\n                 after_dollar = false;\n                 match tree {\n                     TokenTree::Ident(_) => {\n-                        let tree = TokenStream::from(tree);\n-                        return Some(quote!(::__internal::unquote(&(unquote tree)),));\n+                        return Some(quote!(Into::<::TokenStream>::into(\n+                        Clone::clone(&(@ tree))),));\n                     }\n                     TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n@@ -125,186 +96,55 @@ impl Quote for TokenStream {\n                 }\n             }\n \n-            Some(quote!(::TokenStream::from((quote tree)),))\n-        }).flat_map(|t| t.into_iter()).collect::<TokenStream>();\n-\n-        if after_dollar {\n-            panic!(\"unexpected trailing `$` in `quote!`\");\n-        }\n-\n-        quote!(\n-            [(unquote tokens)].iter()\n-                .cloned()\n-                .flat_map(|x| x.into_iter())\n-                .collect::<::TokenStream>()\n-        )\n-    }\n-}\n-\n-impl Quote for TokenTree {\n-    fn quote(self) -> TokenStream {\n-        match self {\n-            TokenTree::Punct(tt) => quote!(::TokenTree::Punct( (quote tt) )),\n-            TokenTree::Group(tt) => quote!(::TokenTree::Group( (quote tt) )),\n-            TokenTree::Ident(tt) => quote!(::TokenTree::Ident( (quote tt) )),\n-            TokenTree::Literal(tt) => quote!(::TokenTree::Literal( (quote tt) )),\n-        }\n-    }\n-}\n-\n-impl Quote for char {\n-    fn quote(self) -> TokenStream {\n-        TokenTree::from(Literal::character(self)).into()\n-    }\n-}\n-\n-impl<'a> Quote for &'a str {\n-    fn quote(self) -> TokenStream {\n-        TokenTree::from(Literal::string(self)).into()\n-    }\n-}\n-\n-impl Quote for u16 {\n-    fn quote(self) -> TokenStream {\n-        TokenTree::from(Literal::u16_unsuffixed(self)).into()\n-    }\n-}\n-\n-impl Quote for Group {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Group::new((quote self.delimiter()), (quote self.stream())))\n-    }\n-}\n-\n-impl Quote for Punct {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Punct::new((quote self.as_char()), (quote self.spacing())))\n-    }\n-}\n-\n-impl Quote for Ident {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Ident::new((quote self.sym.as_str()), (quote self.span())))\n-    }\n-}\n-\n-impl Quote for Span {\n-    fn quote(self) -> TokenStream {\n-        quote!(::Span::def_site())\n-    }\n-}\n-\n-macro_rules! literals {\n-    ($($i:ident),*; $($raw:ident),*) => {\n-        pub struct SpannedSymbol {\n-            sym: Symbol,\n-            span: Span,\n-        }\n-\n-        impl SpannedSymbol {\n-            pub fn new(string: &str, span: Span) -> SpannedSymbol {\n-                SpannedSymbol { sym: Symbol::intern(string), span }\n-            }\n-        }\n-\n-        impl Quote for SpannedSymbol {\n-            fn quote(self) -> TokenStream {\n-                quote!(::__internal::SpannedSymbol::new((quote self.sym.as_str()),\n-                                                        (quote self.span)))\n-            }\n-        }\n-\n-        pub enum LiteralKind {\n-            $($i,)*\n-            $($raw(u16),)*\n-        }\n-\n-        impl LiteralKind {\n-            pub fn with_contents_and_suffix(self, contents: SpannedSymbol,\n-                                            suffix: Option<SpannedSymbol>) -> Literal {\n-                let sym = contents.sym;\n-                let suffix = suffix.map(|t| t.sym);\n-                match self {\n-                    $(LiteralKind::$i => {\n-                        Literal {\n-                            lit: token::Lit::$i(sym),\n-                            suffix,\n-                            span: contents.span,\n-                        }\n-                    })*\n-                    $(LiteralKind::$raw(n) => {\n-                        Literal {\n-                            lit: token::Lit::$raw(sym, n),\n-                            suffix,\n-                            span: contents.span,\n-                        }\n-                    })*\n-                }\n-            }\n-        }\n-\n-        impl Literal {\n-            fn kind_contents_and_suffix(self) -> (LiteralKind, SpannedSymbol, Option<SpannedSymbol>)\n-            {\n-                let (kind, contents) = match self.lit {\n-                    $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n-                    $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n-                };\n-                let suffix = self.suffix.map(|sym| SpannedSymbol::new(&sym.as_str(), self.span()));\n-                (kind, SpannedSymbol::new(&contents.as_str(), self.span()), suffix)\n-            }\n-        }\n-\n-        impl Quote for LiteralKind {\n-            fn quote(self) -> TokenStream {\n-                match self {\n-                    $(LiteralKind::$i => quote! {\n-                        ::__internal::LiteralKind::$i\n-                    },)*\n-                    $(LiteralKind::$raw(n) => quote! {\n-                        ::__internal::LiteralKind::$raw((quote n))\n-                    },)*\n-                }\n-            }\n-        }\n+            Some(quote!(::TokenStream::from((@ match tree {\n+                TokenTree::Punct(tt) => quote!(::TokenTree::Punct(::Punct::new(\n+                    (@ TokenTree::from(Literal::character(tt.as_char()))),\n+                    (@ match tt.spacing() {\n+                        Spacing::Alone => quote!(::Spacing::Alone),\n+                        Spacing::Joint => quote!(::Spacing::Joint),\n+                    }),\n+                ))),\n+                TokenTree::Group(tt) => quote!(::TokenTree::Group(::Group::new(\n+                    (@ match tt.delimiter() {\n+                        Delimiter::Parenthesis => quote!(::Delimiter::Parenthesis),\n+                        Delimiter::Brace => quote!(::Delimiter::Brace),\n+                        Delimiter::Bracket => quote!(::Delimiter::Bracket),\n+                        Delimiter::None => quote!(::Delimiter::None),\n+                    }),\n+                    (@ quote(tt.stream())),\n+                ))),\n+                TokenTree::Ident(tt) => quote!(::TokenTree::Ident(::Ident::new(\n+                    (@ TokenTree::from(Literal::string(&tt.to_string()))),\n+                    (@ quote_span(tt.span())),\n+                ))),\n+                TokenTree::Literal(tt) => quote!(::TokenTree::Literal({\n+                    let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n+                        .parse::<::TokenStream>()\n+                        .unwrap()\n+                        .into_iter();\n+                    if let (Some(::TokenTree::Literal(mut lit)), None) =\n+                        (iter.next(), iter.next())\n+                    {\n+                        lit.set_span((@ quote_span(tt.span())));\n+                        lit\n+                    } else {\n+                        unreachable!()\n+                    }\n+                }))\n+            })),))\n+        })\n+        .collect::<TokenStream>();\n \n-        impl Quote for Literal {\n-            fn quote(self) -> TokenStream {\n-                let (kind, contents, suffix) = self.kind_contents_and_suffix();\n-                quote! {\n-                    (quote kind).with_contents_and_suffix((quote contents), (quote suffix))\n-                }\n-            }\n-        }\n+    if after_dollar {\n+        panic!(\"unexpected trailing `$` in `quote!`\");\n     }\n-}\n \n-literals!(Byte, Char, Float, Str_, Integer, ByteStr; StrRaw, ByteStrRaw);\n-\n-impl Quote for Delimiter {\n-    fn quote(self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident),*) => {\n-                match self {\n-                    $(Delimiter::$i => { quote!(::Delimiter::$i) })*\n-                }\n-            }\n-        }\n-\n-        gen_match!(Parenthesis, Brace, Bracket, None)\n-    }\n+    quote!([(@ tokens)].iter().cloned().collect::<::TokenStream>())\n }\n \n-impl Quote for Spacing {\n-    fn quote(self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident),*) => {\n-                match self {\n-                    $(Spacing::$i => { quote!(::Spacing::$i) })*\n-                }\n-            }\n-        }\n-\n-        gen_match!(Alone, Joint)\n-    }\n+/// Quote a `Span` into a `TokenStream`.\n+/// This is needed to implement a custom quoter.\n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n+pub fn quote_span(_: Span) -> TokenStream {\n+    quote!(::Span::def_site())\n }"}, {"sha": "a54c695f6376fc0e817d42ea2c58fc9c0cb5067b", "filename": "src/libproc_macro/rustc.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibproc_macro%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Frustc.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -0,0 +1,284 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Delimiter, Level, Spacing, Span, __internal};\n+use {Group, Ident, Literal, Punct, TokenTree};\n+\n+use rustc_errors as errors;\n+use syntax::ast;\n+use syntax::parse::lexer::comments;\n+use syntax::parse::token;\n+use syntax::tokenstream;\n+use syntax_pos::symbol::{keywords, Symbol};\n+\n+impl Ident {\n+    pub(crate) fn new_maybe_raw(string: &str, span: Span, is_raw: bool) -> Ident {\n+        let sym = Symbol::intern(string);\n+        if is_raw\n+            && (sym == keywords::Underscore.name()\n+                || ast::Ident::with_empty_ctxt(sym).is_path_segment_keyword())\n+        {\n+            panic!(\"`{:?}` is not a valid raw identifier\", string)\n+        }\n+        Ident { sym, span, is_raw }\n+    }\n+}\n+\n+impl Delimiter {\n+    pub(crate) fn from_internal(delim: token::DelimToken) -> Delimiter {\n+        match delim {\n+            token::Paren => Delimiter::Parenthesis,\n+            token::Brace => Delimiter::Brace,\n+            token::Bracket => Delimiter::Bracket,\n+            token::NoDelim => Delimiter::None,\n+        }\n+    }\n+\n+    pub(crate) fn to_internal(self) -> token::DelimToken {\n+        match self {\n+            Delimiter::Parenthesis => token::Paren,\n+            Delimiter::Brace => token::Brace,\n+            Delimiter::Bracket => token::Bracket,\n+            Delimiter::None => token::NoDelim,\n+        }\n+    }\n+}\n+\n+impl TokenTree {\n+    pub(crate) fn from_internal(\n+        stream: tokenstream::TokenStream,\n+        stack: &mut Vec<TokenTree>,\n+    ) -> TokenTree {\n+        use syntax::parse::token::*;\n+\n+        let (tree, is_joint) = stream.as_tree();\n+        let (span, token) = match tree {\n+            tokenstream::TokenTree::Token(span, token) => (span, token),\n+            tokenstream::TokenTree::Delimited(span, delimed) => {\n+                let delimiter = Delimiter::from_internal(delimed.delim);\n+                let mut g = Group::new(delimiter, ::TokenStream(delimed.tts.into()));\n+                g.set_span(Span(span));\n+                return g.into();\n+            }\n+        };\n+\n+        let op_kind = if is_joint {\n+            Spacing::Joint\n+        } else {\n+            Spacing::Alone\n+        };\n+        macro_rules! tt {\n+            ($e:expr) => {{\n+                let mut x = TokenTree::from($e);\n+                x.set_span(Span(span));\n+                x\n+            }};\n+        }\n+        macro_rules! op {\n+            ($a:expr) => {\n+                tt!(Punct::new($a, op_kind))\n+            };\n+            ($a:expr, $b:expr) => {{\n+                stack.push(tt!(Punct::new($b, op_kind)));\n+                tt!(Punct::new($a, Spacing::Joint))\n+            }};\n+            ($a:expr, $b:expr, $c:expr) => {{\n+                stack.push(tt!(Punct::new($c, op_kind)));\n+                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n+                tt!(Punct::new($a, Spacing::Joint))\n+            }};\n+        }\n+\n+        match token {\n+            Eq => op!('='),\n+            Lt => op!('<'),\n+            Le => op!('<', '='),\n+            EqEq => op!('=', '='),\n+            Ne => op!('!', '='),\n+            Ge => op!('>', '='),\n+            Gt => op!('>'),\n+            AndAnd => op!('&', '&'),\n+            OrOr => op!('|', '|'),\n+            Not => op!('!'),\n+            Tilde => op!('~'),\n+            BinOp(Plus) => op!('+'),\n+            BinOp(Minus) => op!('-'),\n+            BinOp(Star) => op!('*'),\n+            BinOp(Slash) => op!('/'),\n+            BinOp(Percent) => op!('%'),\n+            BinOp(Caret) => op!('^'),\n+            BinOp(And) => op!('&'),\n+            BinOp(Or) => op!('|'),\n+            BinOp(Shl) => op!('<', '<'),\n+            BinOp(Shr) => op!('>', '>'),\n+            BinOpEq(Plus) => op!('+', '='),\n+            BinOpEq(Minus) => op!('-', '='),\n+            BinOpEq(Star) => op!('*', '='),\n+            BinOpEq(Slash) => op!('/', '='),\n+            BinOpEq(Percent) => op!('%', '='),\n+            BinOpEq(Caret) => op!('^', '='),\n+            BinOpEq(And) => op!('&', '='),\n+            BinOpEq(Or) => op!('|', '='),\n+            BinOpEq(Shl) => op!('<', '<', '='),\n+            BinOpEq(Shr) => op!('>', '>', '='),\n+            At => op!('@'),\n+            Dot => op!('.'),\n+            DotDot => op!('.', '.'),\n+            DotDotDot => op!('.', '.', '.'),\n+            DotDotEq => op!('.', '.', '='),\n+            Comma => op!(','),\n+            Semi => op!(';'),\n+            Colon => op!(':'),\n+            ModSep => op!(':', ':'),\n+            RArrow => op!('-', '>'),\n+            LArrow => op!('<', '-'),\n+            FatArrow => op!('=', '>'),\n+            Pound => op!('#'),\n+            Dollar => op!('$'),\n+            Question => op!('?'),\n+            SingleQuote => op!('\\''),\n+\n+            Ident(ident, false) => tt!(self::Ident::new(&ident.as_str(), Span(span))),\n+            Ident(ident, true) => tt!(self::Ident::new_raw(&ident.as_str(), Span(span))),\n+            Lifetime(ident) => {\n+                let ident = ident.without_first_quote();\n+                stack.push(tt!(self::Ident::new(&ident.as_str(), Span(span))));\n+                tt!(Punct::new('\\'', Spacing::Joint))\n+            }\n+            Literal(lit, suffix) => tt!(self::Literal {\n+                lit,\n+                suffix,\n+                span: Span(span)\n+            }),\n+            DocComment(c) => {\n+                let style = comments::doc_comment_style(&c.as_str());\n+                let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n+                let stream = vec![\n+                    tt!(self::Ident::new(\"doc\", Span(span))),\n+                    tt!(Punct::new('=', Spacing::Alone)),\n+                    tt!(self::Literal::string(&stripped)),\n+                ].into_iter()\n+                    .collect();\n+                stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n+                if style == ast::AttrStyle::Inner {\n+                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n+                }\n+                tt!(Punct::new('#', Spacing::Alone))\n+            }\n+\n+            Interpolated(_) => __internal::with_sess(|sess, _| {\n+                let tts = token.interpolated_to_tokenstream(sess, span);\n+                tt!(Group::new(Delimiter::None, ::TokenStream(tts)))\n+            }),\n+\n+            DotEq => op!('.', '='),\n+            OpenDelim(..) | CloseDelim(..) => unreachable!(),\n+            Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n+        }\n+    }\n+\n+    pub(crate) fn to_internal(self) -> tokenstream::TokenStream {\n+        use syntax::parse::token::*;\n+        use syntax::tokenstream::{Delimited, TokenTree};\n+\n+        let (ch, kind, span) = match self {\n+            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n+            self::TokenTree::Group(tt) => {\n+                return TokenTree::Delimited(\n+                    tt.span.0,\n+                    Delimited {\n+                        delim: tt.delimiter.to_internal(),\n+                        tts: tt.stream.0.into(),\n+                    },\n+                ).into();\n+            }\n+            self::TokenTree::Ident(tt) => {\n+                let token = Ident(ast::Ident::new(tt.sym, tt.span.0), tt.is_raw);\n+                return TokenTree::Token(tt.span.0, token).into();\n+            }\n+            self::TokenTree::Literal(self::Literal {\n+                lit: Lit::Integer(ref a),\n+                suffix,\n+                span,\n+            })\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let integer = Symbol::intern(&a.as_str()[1..]);\n+                let integer = Literal(Lit::Integer(integer), suffix);\n+                let a = TokenTree::Token(span.0, minus);\n+                let b = TokenTree::Token(span.0, integer);\n+                return vec![a, b].into_iter().collect();\n+            }\n+            self::TokenTree::Literal(self::Literal {\n+                lit: Lit::Float(ref a),\n+                suffix,\n+                span,\n+            })\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let float = Symbol::intern(&a.as_str()[1..]);\n+                let float = Literal(Lit::Float(float), suffix);\n+                let a = TokenTree::Token(span.0, minus);\n+                let b = TokenTree::Token(span.0, float);\n+                return vec![a, b].into_iter().collect();\n+            }\n+            self::TokenTree::Literal(tt) => {\n+                let token = Literal(tt.lit, tt.suffix);\n+                return TokenTree::Token(tt.span.0, token).into();\n+            }\n+        };\n+\n+        let token = match ch {\n+            '=' => Eq,\n+            '<' => Lt,\n+            '>' => Gt,\n+            '!' => Not,\n+            '~' => Tilde,\n+            '+' => BinOp(Plus),\n+            '-' => BinOp(Minus),\n+            '*' => BinOp(Star),\n+            '/' => BinOp(Slash),\n+            '%' => BinOp(Percent),\n+            '^' => BinOp(Caret),\n+            '&' => BinOp(And),\n+            '|' => BinOp(Or),\n+            '@' => At,\n+            '.' => Dot,\n+            ',' => Comma,\n+            ';' => Semi,\n+            ':' => Colon,\n+            '#' => Pound,\n+            '$' => Dollar,\n+            '?' => Question,\n+            '\\'' => SingleQuote,\n+            _ => unreachable!(),\n+        };\n+\n+        let tree = TokenTree::Token(span.0, token);\n+        match kind {\n+            Spacing::Alone => tree.into(),\n+            Spacing::Joint => tree.joint(),\n+        }\n+    }\n+}\n+\n+impl Level {\n+    pub(crate) fn to_internal(self) -> errors::Level {\n+        match self {\n+            Level::Error => errors::Level::Error,\n+            Level::Warning => errors::Level::Warning,\n+            Level::Note => errors::Level::Note,\n+            Level::Help => errors::Level::Help,\n+            Level::__Nonexhaustive => unreachable!(\"Level::__Nonexhaustive\"),\n+        }\n+    }\n+}"}, {"sha": "b1578b697bb8c3e1f389d68fe16f911d72269fdf", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -379,7 +379,7 @@ impl Diagnostic {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n-    pub(crate) fn sub(&mut self,\n+    pub fn sub(&mut self,\n            level: Level,\n            message: &str,\n            span: MultiSpan,"}, {"sha": "e3a7918f8c5897df13ba8790fca77ce962daa3a9", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -39,7 +39,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n use syntax::edition::Edition;\n-use syntax::ext::base::SyntaxExtension;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n@@ -517,8 +516,11 @@ impl CrateStore for cstore::CStore {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == \"proc_macro\" &&\n                   self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n+            use syntax::ext::base::SyntaxExtension;\n+            use syntax_ext::proc_macro_impl::BangProcMacro;\n+\n             let ext = SyntaxExtension::ProcMacro {\n-                expander: Box::new(::proc_macro::__internal::Quoter),\n+                expander: Box::new(BangProcMacro { inner: ::proc_macro::quote }),\n                 allow_internal_unstable: true,\n                 edition: data.root.edition,\n             };"}, {"sha": "d535c1ef90357d0c83da785a571ec9dbb3bee160", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -19,6 +19,7 @@\n #![feature(libc)]\n #![feature(macro_at_most_once_rep)]\n #![feature(proc_macro_internals)]\n+#![feature(proc_macro_quote)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]"}, {"sha": "9748e2947eebdc87307cff5f33317f6e1077e073", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd455ef165f110143b97106b4e7cd8c83cd21f03/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=bd455ef165f110143b97106b4e7cd8c83cd21f03", "patch": "@@ -1775,12 +1775,6 @@ fn ident_continue(c: Option<char>) -> bool {\n     (c > '\\x7f' && c.is_xid_continue())\n }\n \n-// The string is a valid identifier or a lifetime identifier.\n-pub fn is_valid_ident(s: &str) -> bool {\n-    let mut chars = s.chars();\n-    ident_start(chars.next()) && chars.all(|ch| ident_continue(Some(ch)))\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}