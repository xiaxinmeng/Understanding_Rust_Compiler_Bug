{"sha": "f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NzhiZGVmZGQ5NjYzYWE3OGMzMWZmYzc3NzNlMzFiY2FlNGZiMzk=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-16T10:59:27Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-16T23:34:20Z"}, "message": "Avoid repeated HashMap lookups in `opt_normalize_projection_type`.\n\nThere is a hot path through `opt_normalize_projection_type`:\n- `try_start` does a cache lookup (#1).\n- The result is a `NormalizedTy`.\n- There are no unresolved type vars, so we call `complete`.\n- `complete` does *another* cache lookup (#2), then calls\n  `SnapshotMap::insert`.\n- `insert` does *another* cache lookup (#3), inserting the same value\n  that's already in the cache.\n\nThis patch optimizes this hot path by introducing `complete_normalized`,\nfor use when the value is known in advance to be a `NormalizedTy`. It\nalways avoids lookup #2. Furthermore, if the `NormalizedTy`'s\nobligations are empty (the common case), we know that lookup #3 would be\na no-op, so we avoid it, while inserting a Noop into the `SnapshotMap`'s\nundo log.", "tree": {"sha": "ffa3ff5d6f360749f1753c0d7e8b56b79432d5fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffa3ff5d6f360749f1753c0d7e8b56b79432d5fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "html_url": "https://github.com/rust-lang/rust/commit/f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f778bdefdd9663aa78c31ffc7773e31bcae4fb39/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc409ed0938cd2f501642abcaa675977fa5035a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc409ed0938cd2f501642abcaa675977fa5035a", "html_url": "https://github.com/rust-lang/rust/commit/6fc409ed0938cd2f501642abcaa675977fa5035a"}], "stats": {"total": 25, "additions": 24, "deletions": 1}, "files": [{"sha": "da8f086b9c55db24bee085291802f22274e5f546", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f778bdefdd9663aa78c31ffc7773e31bcae4fb39/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f778bdefdd9663aa78c31ffc7773e31bcae4fb39/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "patch": "@@ -596,7 +596,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if !infcx.any_unresolved_type_vars(&ty.value) {\n-                infcx.projection_cache.borrow_mut().complete(cache_key);\n+                infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n                 ty.obligations = vec![];\n             }\n \n@@ -1682,6 +1682,23 @@ impl<'tcx> ProjectionCache<'tcx> {\n         }));\n     }\n \n+    /// A specialized version of `complete` for when the key's value is known\n+    /// to be a NormalizedTy.\n+    pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n+        // We want to insert `ty` with no obligations. If the existing value\n+        // already has no obligations (as is common) we can use `insert_noop`\n+        // to do a minimal amount of work -- the HashMap insertion is skipped,\n+        // and minimal changes are made to the undo log.\n+        if ty.obligations.is_empty() {\n+            self.map.insert_noop();\n+        } else {\n+            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(Normalized {\n+                value: ty.value,\n+                obligations: vec![]\n+            }));\n+        }\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will"}, {"sha": "6ee8c3579f5437c4d0f4602dd5bc339a2abebaee", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f778bdefdd9663aa78c31ffc7773e31bcae4fb39/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f778bdefdd9663aa78c31ffc7773e31bcae4fb39/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "patch": "@@ -67,6 +67,12 @@ impl<K, V> SnapshotMap<K, V>\n         }\n     }\n \n+    pub fn insert_noop(&mut self) {\n+        if !self.undo_log.is_empty() {\n+            self.undo_log.push(UndoLog::Noop);\n+        }\n+    }\n+\n     pub fn remove(&mut self, key: K) -> bool {\n         match self.map.remove(&key) {\n             Some(old_value) => {"}]}