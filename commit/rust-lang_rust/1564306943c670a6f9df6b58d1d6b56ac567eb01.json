{"sha": "1564306943c670a6f9df6b58d1d6b56ac567eb01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NjQzMDY5NDNjNjcwYTZmOWRmNmI1OGQxZDZiNTZhYzU2N2ViMDE=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-08-23T05:26:24Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-09-03T16:07:20Z"}, "message": "Re-factor useless_format lint", "tree": {"sha": "2774e27bf631693f4a87ebafab895a50ffe67c87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2774e27bf631693f4a87ebafab895a50ffe67c87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1564306943c670a6f9df6b58d1d6b56ac567eb01", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl1uj7oACgkQaTCGhp1Q\nZjeH5Q/8DiNuyS2yb1PtRGULGMpbSK3WfJomGFa8Pd0sdQ7Unm4k8Z8+6SDzfWGj\nS3om6E50qboWt2p0as16OO5qLOPd3F452IjpXibwLV7VG+RN7+FJj3oXNgWFyJp9\nwlHZ+mqGkTk7sAPs/TN0W2LjqcPMxYtnPkiuqHLxap74EZldneojVArWQwuClfPk\nye+62BUtE3Q1U8SFrS3du8FFR/Stip2ECqs+PfIAp6VsqWEi+NEMkUqz79c3I+vM\naX5d/QlBOe1HQppF2TuVx1HRakpUuge+qAsu6pK4/x7Je0abV2/iW+k9ARroboNv\nQZJ8NWD+Q09O5EiAUsM2rjtruJjM+/3zZ6JVqMCX8Mq2JeiCz0WnwEOWJ709x00S\n38A63BK2tNxwUOSAuqn3A89Q9xJmhsL+GlOwRZmNhPIF4Uyo5gWr6UGRo68RSha9\nqYHmXWUpxANKatgDIYVrGLFVibkfuIEXvYoq8eetoeD8AWwOnYCYMmOuFgDDu18J\nsmklYrcAAtg4Fqp7Gf6lIkDRmkTIOmlTmgbaQ/TxM8/nqVSj40jQAP9F85/FRcbb\nYgc6EWSPZ7ChH8Jxj+ugM01HqpDO8YQENn4dyy/AIqSLzn1Ew3G2mq57IXSiLgFH\nekusd3XwQI0l9yV1b59ztTWc4NX4rFzSUO5W56c20fUuyrO6suA=\n=LYZ/\n-----END PGP SIGNATURE-----", "payload": "tree 2774e27bf631693f4a87ebafab895a50ffe67c87\nparent 92bd160aacadfc9af2f3c8e8edeba60aed1e1ddc\nauthor Lzu Tao <taolzu@gmail.com> 1566537984 +0700\ncommitter flip1995 <hello@philkrones.com> 1567526840 +0200\n\nRe-factor useless_format lint\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1564306943c670a6f9df6b58d1d6b56ac567eb01", "html_url": "https://github.com/rust-lang/rust/commit/1564306943c670a6f9df6b58d1d6b56ac567eb01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1564306943c670a6f9df6b58d1d6b56ac567eb01/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92bd160aacadfc9af2f3c8e8edeba60aed1e1ddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/92bd160aacadfc9af2f3c8e8edeba60aed1e1ddc", "html_url": "https://github.com/rust-lang/rust/commit/92bd160aacadfc9af2f3c8e8edeba60aed1e1ddc"}], "stats": {"total": 198, "additions": 105, "deletions": 93}, "files": [{"sha": "add1056b0f88f0d182ac989fc17e5eb46f58631a", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 100, "deletions": 89, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/1564306943c670a6f9df6b58d1d6b56ac567eb01/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1564306943c670a6f9df6b58d1d6b56ac567eb01/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=1564306943c670a6f9df6b58d1d6b56ac567eb01", "patch": "@@ -6,7 +6,6 @@ use crate::utils::{\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n@@ -39,56 +38,16 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let Some(span) = is_expn_of(expr.span, \"format\") {\n-            if in_macro_or_desugar(span) {\n-                return;\n-            }\n-            match expr.node {\n-                // `format!(\"{}\", foo)` expansion\n-                ExprKind::Call(ref fun, ref args) => {\n-                    if_chain! {\n-                        if let ExprKind::Path(ref qpath) = fun.node;\n-                        if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-                        let new_v1 = match_def_path(cx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        let new_v1_fmt = match_def_path(cx,\n-                            fun_def_id,\n-                            &paths::FMT_ARGUMENTS_NEWV1FORMATTED\n-                        );\n-                        if new_v1 || new_v1_fmt;\n-                        if check_single_piece(&args[0]);\n-                        if let Some(format_arg) = get_single_string_arg(cx, &args[1]);\n-                        if new_v1 || check_unformatted(&args[2]);\n-                        if let ExprKind::AddrOf(_, ref format_arg) = format_arg.node;\n-                        then {\n-                            let (message, sugg) = if_chain! {\n-                                if let ExprKind::MethodCall(ref path, _, _) = format_arg.node;\n-                                if path.ident.as_interned_str().as_symbol() == sym!(to_string);\n-                                then {\n-                                    (\"`to_string()` is enough\",\n-                                    snippet(cx, format_arg.span, \"<arg>\").to_string())\n-                                } else {\n-                                    (\"consider using .to_string()\",\n-                                    format!(\"{}.to_string()\", snippet(cx, format_arg.span, \"<arg>\")))\n-                                }\n-                            };\n+        let span = match is_expn_of(expr.span, \"format\") {\n+            Some(s) if !in_macro_or_desugar(s) => s,\n+            _ => return,\n+        };\n \n-                            span_useless_format(cx, span, message, sugg);\n-                        }\n-                    }\n-                },\n-                // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprKind::Match(ref matchee, _, _) => {\n-                    if let ExprKind::Tup(ref tup) = matchee.node {\n-                        if tup.is_empty() {\n-                            let actual_snippet = snippet(cx, expr.span, \"<expr>\").to_string();\n-                            let actual_snippet = actual_snippet.replace(\"{{}}\", \"{}\");\n-                            let sugg = format!(\"{}.to_string()\", actual_snippet);\n-                            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n-                        }\n-                    }\n-                },\n-                _ => (),\n-            }\n+        // Operate on the only argument of `alloc::fmt::format`.\n+        if let Some(sugg) = on_new_v1(cx, expr) {\n+            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n+        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n+            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n         }\n     }\n }\n@@ -112,56 +71,105 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n     });\n }\n \n-/// Checks if the expressions matches `&[\"\"]`\n-fn check_single_piece(expr: &Expr) -> bool {\n+fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'a [Arm]) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\"]\n-        if let ExprKind::Array(ref exprs) = expr.node; // [\"\"]\n-        if exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = exprs[0].node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n+        if let ExprKind::AddrOf(_, ref format_args) = expr.node;\n+        if let ExprKind::Array(ref elems) = arms[0].body.node;\n+        if elems.len() == 1;\n+        if let ExprKind::Call(ref fun, ref args) = elems[0].node;\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTV1_NEW);\n+        // matches `core::fmt::Display::fmt`\n+        if args.len() == 2;\n+        if let ExprKind::Path(ref qpath) = args[1].node;\n+        if let Some(did) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n+        if arms[0].pats.len() == 1;\n+        // check `(arg0,)` in match block\n+        if let PatKind::Tuple(ref pats, None) = arms[0].pats[0].node;\n+        if pats.len() == 1;\n         then {\n-            return lit.as_str().is_empty();\n+            if let ExprKind::Lit(ref lit) = format_args.node {\n+                if let LitKind::Str(ref s, _) = lit.node {\n+                    let snip = s.as_str().replace(\"{{}}\", \"{}\");\n+                    let sugg = format!(\"\\\"{}\\\".to_string()\", snip);\n+                    return Some(sugg);\n+                }\n+                return None;\n+            } else {\n+                let snip = snippet(cx, format_args.span, \"<arg>\");\n+                if let ExprKind::MethodCall(ref path, _, _) = format_args.node {\n+                    if path.ident.name == sym!(to_string) {\n+                        return Some(format!(\"{}\", snip));\n+                    }\n+                }\n+                return Some(format!(\"{}.to_string()\", snip));\n+            }\n         }\n     }\n-\n-    false\n+    None\n }\n \n-/// Checks if the expressions matches\n-/// ```rust,ignore\n-/// &match (&\"arg\",) {\n-/// (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0,\n-/// ::std::fmt::Display::fmt)],\n-/// }\n-/// ```\n-/// and that the type of `__arg0` is `&str` or `String`,\n-/// then returns the span of first element of the matched tuple.\n-fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n+fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n-        if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;\n-        if arms.len() == 1;\n-        if arms[0].pats.len() == 1;\n-        if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n-        if pat.len() == 1;\n-        if let ExprKind::Array(ref exprs) = arms[0].body.node;\n-        if exprs.len() == 1;\n-        if let ExprKind::Call(_, ref args) = exprs[0].node;\n+        if let ExprKind::Call(ref fun, ref args) = expr.node;\n         if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].node;\n-        if let Some(fun_def_id) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1);\n+        // Argument 1 in `new_v1()`\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n+        if let ExprKind::Array(ref pieces) = arr.node;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let LitKind::Str(ref s, _) = lit.node;\n+        // Argument 2 in `new_v1()`\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n         then {\n-            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-            if ty.sty == ty::Str || match_type(cx, ty, &paths::STRING) {\n-                if let ExprKind::Tup(ref values) = match_expr.node {\n-                    return Some(&values[0]);\n+            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n+            if tup.is_empty() {\n+                let snip = s.as_str().replace(\"{{}}\", \"{}\");\n+                let sugg = format!(\"\\\"{}\\\".to_string()\", snip);\n+                return Some(sugg);\n+            } else {\n+                if s.as_str().is_empty() {\n+                    return on_argumentv1_new(cx, &tup[0], arms);\n+                } else {\n+                    return None;\n                 }\n             }\n         }\n     }\n+    None\n+}\n \n+fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.node;\n+        if args.len() == 3;\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n+        if check_unformatted(&args[2]);\n+        // Argument 1 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n+        if let ExprKind::Array(ref pieces) = arr.node;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let LitKind::Str(..) = lit.node;\n+        // Argument 2 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n+        then {\n+            return on_argumentv1_new(cx, &tup[0], arms);\n+        }\n+    }\n     None\n }\n \n@@ -170,6 +178,7 @@ fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option\n /// &[_ {\n ///    format: _ {\n ///         width: _::Implied,\n+///         precision: _::Implied,\n ///         ...\n ///    },\n ///    ...,\n@@ -180,15 +189,17 @@ fn check_unformatted(expr: &Expr) -> bool {\n         if let ExprKind::AddrOf(_, ref expr) = expr.node;\n         if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n+        // struct `core::fmt::rt::v1::Argument`\n         if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n+        // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n-        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n-        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.node;\n         if last_path_segment(precision_path).ident.name == sym!(Implied);\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n+        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n+        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         then {\n             return true;\n         }"}, {"sha": "14f570abcdbc8bad58aac5b403d9a691bdabbb2b", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1564306943c670a6f9df6b58d1d6b56ac567eb01/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1564306943c670a6f9df6b58d1d6b56ac567eb01/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=1564306943c670a6f9df6b58d1d6b56ac567eb01", "patch": "@@ -27,8 +27,9 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DROP_TRAIT: [&str; 4] = [\"core\", \"ops\", \"drop\", \"Drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n-pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTS_NEWV1FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];"}, {"sha": "d81f48b0864cc2afedb5eae08e9eefec4dc4386b", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1564306943c670a6f9df6b58d1d6b56ac567eb01/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1564306943c670a6f9df6b58d1d6b56ac567eb01/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=1564306943c670a6f9df6b58d1d6b56ac567eb01", "patch": "@@ -58,13 +58,13 @@ error: useless use of `format!`\n   --> $DIR/format.rs:59:5\n    |\n LL |     format!(\"{}\", 42.to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: `to_string()` is enough: `42.to_string();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `42.to_string();`\n \n error: useless use of `format!`\n   --> $DIR/format.rs:61:5\n    |\n LL |     format!(\"{}\", x.display().to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: `to_string()` is enough: `x.display().to_string();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `x.display().to_string();`\n \n error: aborting due to 11 previous errors\n "}]}