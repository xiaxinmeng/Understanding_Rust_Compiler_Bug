{"sha": "85e1c3baca9a23e2640c9eb408b0a65848a5d0f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZTFjM2JhY2E5YTIzZTI2NDBjOWViNDA4YjBhNjU4NDhhNWQwZjA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-19T16:14:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T16:14:56Z"}, "message": "Rollup merge of #71568 - hbina:document_unsafety_slice_sort, r=joshtriplett\n\nDocument unsafety in slice/sort.rs\n\nLet me know if these documentations are accurate c:\n\nI don't think I am capable enough to document the safety of `partition_blocks`, however.\n\nRelated issue #66219", "tree": {"sha": "5de4183e0896b46f23ada36184507fdde82c04e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5de4183e0896b46f23ada36184507fdde82c04e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85e1c3baca9a23e2640c9eb408b0a65848a5d0f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7OSACRBK7hj4Ov3rIwAAdHIIAK8oEJitW0EIBhVE0FQczQzj\nMrVxb9moMW2N0KP7t4Iqf6cCXGFh3JUtp13Gw4JwAvgGbEJTviF5OxtoEWMik8Xu\nQFhHFYvfhx5SjbQSsofH2QQQq5RN/TSmjt8Bt3cbbvrRLdW6J12CwRZXqXknycg8\nROj1skek3EDyrG43Nw2ee88QVo6xPNFhnUdrghM9+eccuZIJcOo8VP3e80ExBD/F\n6x39hP6AFvJICQ4Q/qGobjOdiKMdpfR9ehJHQyQqn5CT60LXyHF03ZmlC4sEm7v/\nssBhdj4/7VqS5ScLLHNZ9we53troeOc7c7KXSOuP+BWSpls8G6X0iUSG1e5KuVA=\n=eAz7\n-----END PGP SIGNATURE-----\n", "payload": "tree 5de4183e0896b46f23ada36184507fdde82c04e4\nparent 72417d84fb51495a4f1d007fb2397a0b2609ab63\nparent 5a9df8406ffadb399bf85d4c4d844a4254f89f81\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592583296 -0700\ncommitter GitHub <noreply@github.com> 1592583296 -0700\n\nRollup merge of #71568 - hbina:document_unsafety_slice_sort, r=joshtriplett\n\nDocument unsafety in slice/sort.rs\n\nLet me know if these documentations are accurate c:\n\nI don't think I am capable enough to document the safety of `partition_blocks`, however.\n\nRelated issue #66219\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85e1c3baca9a23e2640c9eb408b0a65848a5d0f0", "html_url": "https://github.com/rust-lang/rust/commit/85e1c3baca9a23e2640c9eb408b0a65848a5d0f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85e1c3baca9a23e2640c9eb408b0a65848a5d0f0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72417d84fb51495a4f1d007fb2397a0b2609ab63", "url": "https://api.github.com/repos/rust-lang/rust/commits/72417d84fb51495a4f1d007fb2397a0b2609ab63", "html_url": "https://github.com/rust-lang/rust/commit/72417d84fb51495a4f1d007fb2397a0b2609ab63"}, {"sha": "5a9df8406ffadb399bf85d4c4d844a4254f89f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9df8406ffadb399bf85d4c4d844a4254f89f81", "html_url": "https://github.com/rust-lang/rust/commit/5a9df8406ffadb399bf85d4c4d844a4254f89f81"}], "stats": {"total": 73, "additions": 70, "deletions": 3}, "files": [{"sha": "8b2ac294764ff5aa49fc17796b45a1a8f651910d", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/85e1c3baca9a23e2640c9eb408b0a65848a5d0f0/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e1c3baca9a23e2640c9eb408b0a65848a5d0f0/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=85e1c3baca9a23e2640c9eb408b0a65848a5d0f0", "patch": "@@ -1,6 +1,6 @@\n //! Slice sorting\n //!\n-//! This module contains an sort algorithm based on Orson Peters' pattern-defeating quicksort,\n+//! This module contains a sorting algorithm based on Orson Peters' pattern-defeating quicksort,\n //! published at: https://github.com/orlp/pdqsort\n //!\n //! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n@@ -20,6 +20,9 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n+        // SAFETY:  This is a helper class.\n+        //          Please refer to its usage for correctness.\n+        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }\n@@ -32,6 +35,21 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n+    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n+    // and copying memory (`ptr::copy_nonoverlapping`).\n+    //\n+    // a. Indexing:\n+    //  1. We checked the size of the array to >=2.\n+    //  2. All the indexing that we will do is always between {0 <= index < len} at most.\n+    //\n+    // b. Memory copying\n+    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n+    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n+    //     Namely, `i` and `i-1`.\n+    //  3. If the slice is properly aligned, the elements are properly aligned.\n+    //     It is the caller's responsibility to make sure the slice is properly aligned.\n+    //\n+    // See comments below for further detail.\n     unsafe {\n         // If the first two elements are out-of-order...\n         if len >= 2 && is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n@@ -62,6 +80,21 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n+    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n+    // and copying memory (`ptr::copy_nonoverlapping`).\n+    //\n+    // a. Indexing:\n+    //  1. We checked the size of the array to >= 2.\n+    //  2. All the indexing that we will do is always between `0 <= index < len-1` at most.\n+    //\n+    // b. Memory copying\n+    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n+    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n+    //     Namely, `i` and `i+1`.\n+    //  3. If the slice is properly aligned, the elements are properly aligned.\n+    //     It is the caller's responsibility to make sure the slice is properly aligned.\n+    //\n+    // See comments below for further detail.\n     unsafe {\n         // If the last two elements are out-of-order...\n         if len >= 2 && is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {\n@@ -103,6 +136,8 @@ where\n     let mut i = 1;\n \n     for _ in 0..MAX_STEPS {\n+        // SAFETY: We already explicitly did the bound checking with `i < len`.\n+        // All our subsequent indexing is only in the range `0 <= index < len`\n         unsafe {\n             // Find the next pair of adjacent out-of-order elements.\n             while i < len && !is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {\n@@ -220,6 +255,7 @@ where\n     let mut offsets_l = [MaybeUninit::<u8>::uninit(); BLOCK];\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n+    // SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())` is always safe`\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n@@ -268,6 +304,16 @@ where\n             let mut elem = l;\n \n             for i in 0..block_l {\n+                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n+                //         According to the conditions required by the function, we satisfy them because:\n+                //         1. `offsets_l` is stack-allocated, and thus considered separate allocated object.\n+                //         2. The function `is_less` returns a `bool`.\n+                //            Casting a `bool` will never overflow `isize`.\n+                //         3. We have guaranteed that `block_l` will be `<= BLOCK`.\n+                //            Plus, `end_l` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n+                //            Thus, we know that even in the worst case (all invocations of `is_less` returns false) we will only be at most 1 byte pass the end.\n+                //        Another unsafety operation here is dereferencing `elem`.\n+                //        However, `elem` was initially the begin pointer to the slice which is always valid.\n                 unsafe {\n                     // Branchless comparison.\n                     *end_l = i as u8;\n@@ -284,6 +330,17 @@ where\n             let mut elem = r;\n \n             for i in 0..block_r {\n+                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n+                //         According to the conditions required by the function, we satisfy them because:\n+                //         1. `offsets_r` is stack-allocated, and thus considered separate allocated object.\n+                //         2. The function `is_less` returns a `bool`.\n+                //            Casting a `bool` will never overflow `isize`.\n+                //         3. We have guaranteed that `block_r` will be `<= BLOCK`.\n+                //            Plus, `end_r` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n+                //            Thus, we know that even in the worst case (all invocations of `is_less` returns true) we will only be at most 1 byte pass the end.\n+                //        Another unsafety operation here is dereferencing `elem`.\n+                //        However, `elem` was initially `1 * sizeof(T)` past the end and we decrement it by `1 * sizeof(T)` before accessing it.\n+                //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.\n                 unsafe {\n                     // Branchless comparison.\n                     elem = elem.offset(-1);\n@@ -404,8 +461,13 @@ where\n         // Find the first pair of out-of-order elements.\n         let mut l = 0;\n         let mut r = v.len();\n+\n+        // SAFETY: The unsafety below involves indexing an array.\n+        // For the first one: We already do the bounds checking here with `l < r`.\n+        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n+        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n         unsafe {\n-            // Find the first element greater then or equal to the pivot.\n+            // Find the first element greater than or equal to the pivot.\n             while l < r && is_less(v.get_unchecked(l), pivot) {\n                 l += 1;\n             }\n@@ -444,6 +506,7 @@ where\n \n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n+    // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.\n     let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n     let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n     let pivot = &*tmp;\n@@ -452,8 +515,12 @@ where\n     let mut l = 0;\n     let mut r = v.len();\n     loop {\n+        // SAFETY: The unsafety below involves indexing an array.\n+        // For the first one: We already do the bounds checking here with `l < r`.\n+        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n+        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n         unsafe {\n-            // Find the first element greater that the pivot.\n+            // Find the first element greater than the pivot.\n             while l < r && !is_less(pivot, v.get_unchecked(l)) {\n                 l += 1;\n             }"}]}