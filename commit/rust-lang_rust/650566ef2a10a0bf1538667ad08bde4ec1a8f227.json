{"sha": "650566ef2a10a0bf1538667ad08bde4ec1a8f227", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MDU2NmVmMmExMGEwYmYxNTM4NjY3YWQwOGJkZTRlYzFhOGYyMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-27T07:32:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-27T07:32:56Z"}, "message": "Auto merge of #26575 - eddyb:tycx, r=nikomatsakis\n\nNext step towards split local/global type contexts, after #26351.\r\ncc @rust-lang/compiler @jroesch", "tree": {"sha": "5e3e62d5fc47ba86cdbb261bda8b69e14c5273e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e3e62d5fc47ba86cdbb261bda8b69e14c5273e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/650566ef2a10a0bf1538667ad08bde4ec1a8f227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/650566ef2a10a0bf1538667ad08bde4ec1a8f227", "html_url": "https://github.com/rust-lang/rust/commit/650566ef2a10a0bf1538667ad08bde4ec1a8f227", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/650566ef2a10a0bf1538667ad08bde4ec1a8f227/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c03d098747be06286f2aebc1e76f8c08352fdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c03d098747be06286f2aebc1e76f8c08352fdf", "html_url": "https://github.com/rust-lang/rust/commit/d3c03d098747be06286f2aebc1e76f8c08352fdf"}, {"sha": "ad66c215aa2b20cf42968915571886e6ce8e9dd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad66c215aa2b20cf42968915571886e6ce8e9dd4", "html_url": "https://github.com/rust-lang/rust/commit/ad66c215aa2b20cf42968915571886e6ce8e9dd4"}], "stats": {"total": 9821, "additions": 4656, "deletions": 5165}, "files": [{"sha": "b844717e61388e14e8bfb16cb1526664c3c83f17", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -23,7 +23,6 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::def;\n-use middle::ty::lookup_item_type;\n use middle::ty::{self, Ty};\n use middle::stability;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -133,7 +132,7 @@ pub fn def_to_string(did: DefId) -> String {\n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: NodeId) {\n-    let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n+    let v = ecx.tcx.item_variances(ast_util::local_def(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -144,8 +143,8 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              id: ast::NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n-                           &ty::lookup_item_type(ecx.tcx, local_def(id)),\n-                           &ty::lookup_predicates(ecx.tcx, local_def(id)));\n+                           &ecx.tcx.lookup_item_type(local_def(id)),\n+                           &ecx.tcx.lookup_predicates(local_def(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -293,8 +292,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n \n     let mut disr_val = 0;\n     let mut i = 0;\n-    let vi = ty::enum_variants(ecx.tcx,\n-                               DefId { krate: ast::LOCAL_CRATE, node: id });\n+    let vi = ecx.tcx.enum_variants(local_def(id));\n     for variant in variants {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n@@ -319,7 +317,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         match variant.node.kind {\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(_) => {\n-                let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n+                let fields = ecx.tcx.lookup_struct_fields(def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n                                                  &fields[..],\n@@ -328,9 +326,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n-        if (*vi)[i].disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, (*vi)[i].disr_val);\n-            disr_val = (*vi)[i].disr_val;\n+        let specified_disr_val = vi[i].disr_val;\n+        if specified_disr_val != disr_val {\n+            encode_disr_val(ecx, rbml_w, specified_disr_val);\n+            disr_val = specified_disr_val;\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, def_id.local_id());\n \n@@ -379,9 +378,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n                 for &method_did in impl_items.get(base_impl_did).unwrap() {\n-                    let impl_item = ty::impl_or_trait_item(\n-                        ecx.tcx,\n-                        method_did.def_id());\n+                    let impl_item = ecx.tcx.impl_or_trait_item(method_did.def_id());\n                     if let ty::MethodTraitItem(ref m) = impl_item {\n                         encode_reexported_static_method(rbml_w,\n                                                         exp,\n@@ -875,7 +872,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(impl_item) = impl_item_opt {\n         if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n-            let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n+            let scheme = ecx.tcx.lookup_item_type(m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n@@ -923,7 +920,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &ii.attrs);\n     } else {\n         encode_predicates(rbml_w, ecx,\n-                          &ty::lookup_predicates(ecx.tcx, associated_type.def_id),\n+                          &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n \n@@ -995,7 +992,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n     assert!(ast_util::is_local(trait_def_id));\n-    let def = ty::lookup_trait_def(ecx.tcx, trait_def_id);\n+    let def = ecx.tcx.lookup_trait_def(trait_def_id);\n \n     def.for_each_impl(ecx.tcx, |impl_def_id| {\n         rbml_w.start_tag(tag_items_data_item_extension_impl);\n@@ -1161,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n-        let fields = ty::lookup_struct_fields(tcx, def_id);\n+        let fields = tcx.lookup_struct_fields(def_id);\n \n         /* First, encode the fields\n            These come first because we need to write them to make\n@@ -1220,7 +1217,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = ty::impl_trait_ref(tcx, local_def(item.id)).unwrap();\n+          let trait_ref = tcx.impl_trait_ref(local_def(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1274,7 +1271,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = ty::impl_trait_ref(tcx, local_def(item.id)) {\n+        if let Some(trait_ref) = tcx.impl_trait_ref(local_def(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1298,7 +1295,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n-            match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+            match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n                     encode_info_for_associated_const(ecx,\n                                                      rbml_w,\n@@ -1333,22 +1330,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n-        let trait_def = ty::lookup_trait_def(tcx, def_id);\n-        let trait_predicates = ty::lookup_predicates(tcx, def_id);\n+        let trait_def = tcx.lookup_trait_def(def_id);\n+        let trait_predicates = tcx.lookup_predicates(def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-        encode_defaulted(rbml_w, ty::trait_has_default_impl(tcx, def_id));\n+        encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates,\n                         tag_item_generics);\n-        encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n+        encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n+        for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n                 ty::ConstTraitItemId(const_def_id) => {\n@@ -1380,7 +1377,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n \n         // Now output the trait item info for each trait item.\n-        let r = ty::trait_item_def_ids(tcx, def_id);\n+        let r = tcx.trait_item_def_ids(def_id);\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, ast::LOCAL_CRATE);\n \n@@ -1397,7 +1394,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_stability(rbml_w, stab);\n \n             let trait_item_type =\n-                ty::impl_or_trait_item(tcx, item_def_id.def_id());\n+                tcx.impl_or_trait_item(item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n                 ty::ConstTraitItem(associated_const) => {"}, {"sha": "a5b9e40593a839566142adbe2ce243a00edafabd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -21,7 +21,7 @@ pub use self::DefIdSource::*;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, ToPredicate, Ty};\n+use middle::ty::{self, ToPredicate, Ty, HasTypeFlags};\n \n use std::str;\n use syntax::abi;\n@@ -471,14 +471,14 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let def = parse_def_(st, NominalType, conv);\n         let substs = parse_substs_(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_enum(tcx, def, st.tcx.mk_substs(substs));\n+        return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n         let trait_ref = ty::Binder(parse_trait_ref_(st, conv));\n         let bounds = parse_existential_bounds_(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(tcx, trait_ref, bounds);\n+        return tcx.mk_trait(trait_ref, bounds);\n       }\n       'p' => {\n         assert_eq!(next(st), '[');\n@@ -487,38 +487,38 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n         let name = token::intern(&parse_str(st, ']'));\n-        return ty::mk_param(tcx, space, index, name);\n+        return tcx.mk_param(space, index, name);\n       }\n-      '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n-      '*' => return ty::mk_ptr(tcx, parse_mt_(st, conv)),\n+      '~' => return tcx.mk_box(parse_ty_(st, conv)),\n+      '*' => return tcx.mk_ptr(parse_mt_(st, conv)),\n       '&' => {\n         let r = parse_region_(st, conv);\n         let mt = parse_mt_(st, conv);\n-        return ty::mk_rptr(tcx, tcx.mk_region(r), mt);\n+        return tcx.mk_ref(tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty_(st, conv);\n-        let sz = parse_size(st);\n-        return ty::mk_vec(tcx, t, sz);\n+        return match parse_size(st) {\n+            Some(n) => tcx.mk_array(t, n),\n+            None => tcx.mk_slice(t)\n+        };\n       }\n       'v' => {\n-        return ty::mk_str(tcx);\n+        return tcx.mk_str();\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n         st.pos = st.pos + 1;\n-        return ty::mk_tup(tcx, params);\n+        return tcx.mk_tup(params);\n       }\n       'F' => {\n           let def_id = parse_def_(st, NominalType, conv);\n-          return ty::mk_bare_fn(tcx, Some(def_id),\n-                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       'G' => {\n-          return ty::mk_bare_fn(tcx, None,\n-                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -534,7 +534,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n             // If there is a closure buried in the type some where, then we\n             // need to re-convert any def ids (see case 'k', below). That means\n             // we can't reuse the cached version.\n-            if !ty::type_has_ty_closure(tt) {\n+            if !tt.has_closure_types() {\n                 return tt;\n             }\n           }\n@@ -558,20 +558,20 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           let did = parse_def_(st, NominalType, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_struct(st.tcx, did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_struct(did, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def_(st, ClosureSource, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_closure(st.tcx, did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs));\n       }\n       'P' => {\n           assert_eq!(next(st), '[');\n           let trait_ref = parse_trait_ref_(st, conv);\n           let name = token::intern(&parse_str(st, ']'));\n-          return ty::mk_projection(tcx, trait_ref, name);\n+          return tcx.mk_projection(trait_ref, name);\n       }\n       'e' => {\n           return tcx.types.err;"}, {"sha": "fb0131f258d437df00d5561bea74a9b3046f2520", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -49,10 +49,10 @@ pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match nty {\n         ast::TyBool => tcx.types.bool,\n         ast::TyChar => tcx.types.char,\n-        ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n-        ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n-        ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n-        ast::TyStr => ty::mk_str(tcx)\n+        ast::TyInt(it) => tcx.mk_mach_int(it),\n+        ast::TyUint(uit) => tcx.mk_mach_uint(uit),\n+        ast::TyFloat(ft) => tcx.mk_mach_float(ft),\n+        ast::TyStr => tcx.mk_str()\n     }\n }\n "}, {"sha": "ec1fd67616b81eb8cdeb2f797e3273409ab74586", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -66,8 +66,8 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(..) if ty::type_is_c_like_enum(\n-                tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n+            ty::TyEnum(..) if t.is_c_like_enum(tcx) =>\n+                Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n             ty::TyBareFn(..) => Some(CastTy::FnPtr),"}, {"sha": "801b3a721e40d614daa4eb5f5856aca01bcb2e89", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -411,14 +411,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().get(&method_call) {\n+        let fn_ty = match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => method.ty,\n-            None => ty::expr_ty_adjusted(self.tcx, func_or_rcvr)\n-        });\n+            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n+        };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if return_ty.diverges() {\n+        if fn_ty.fn_ret().diverges() {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "62bf1648725cd4c122e523ef8a619a0f6d7b2081", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => ty::empty_parameter_environment(self.tcx)\n+            None => self.tcx.empty_parameter_environment()\n         };\n         f(&mut euv::ExprUseVisitor::new(self, &param_env))\n     }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                                       fn_like.id());\n             self.add_qualif(qualif);\n \n-            if ty::type_contents(self.tcx, ret_ty).interior_unsafe() {\n+            if ret_ty.type_contents(self.tcx).interior_unsafe() {\n                 self.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n \n@@ -266,8 +266,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_static_mut_type(&self, e: &ast::Expr) {\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-        let tcontents = ty::type_contents(self.tcx, node_ty);\n+        let node_ty = self.tcx.node_id_to_type(e.id);\n+        let tcontents = node_ty.type_contents(self.tcx);\n \n         let suffix = if tcontents.has_dtor() {\n             \"destructors\"\n@@ -282,12 +282,12 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n-        let ty = ty::node_id_to_type(self.tcx, e.id);\n+        let ty = self.tcx.node_id_to_type(e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment(self.tcx);\n+        let env = self.tcx.empty_parameter_environment();\n         match fulfill_cx.select_all_or_error(&infcx, &env) {\n             Ok(()) => { },\n             Err(ref errors) => {\n@@ -402,7 +402,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n+        let node_ty = self.tcx.node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n \n         // Special-case some expressions to avoid certain flags bubbling up.\n@@ -479,7 +479,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // initializer values (very bad).\n                 // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n                 // propagated from another error, so erroring again would be just noise.\n-                let tc = ty::type_contents(self.tcx, node_ty);\n+                let tc = node_ty.type_contents(self.tcx);\n                 if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n                     outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n@@ -529,7 +529,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(did, _) |\n-        ty::TyEnum(did, _) if ty::has_dtor(v.tcx, did) => {\n+        ty::TyEnum(did, _) if v.tcx.has_dtor(did) => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n@@ -560,7 +560,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprUnary(op, ref inner) => {\n-            match ty::node_id_to_type(v.tcx, inner.id).sty {\n+            match v.tcx.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == ast::UnDeref);\n \n@@ -574,7 +574,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprBinary(op, ref lhs, _) => {\n-            match ty::node_id_to_type(v.tcx, lhs.id).sty {\n+            match v.tcx.node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == ast::BiEq || op.node == ast::BiNe ||\n                             op.node == ast::BiLe || op.node == ast::BiLt ||\n@@ -731,7 +731,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprClosure(..) => {\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n+            if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n                         \"global closures can't capture anything\");\n                 v.add_qualif(ConstQualif::NOT_CONST);"}, {"sha": "d2b3b83e4f42f95bcd343ce00ce4e77b384213ad", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -20,7 +20,7 @@ use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::WriteAndRead;\n use middle::expr_use_visitor as euv;\n-use middle::mem_categorization::cmt;\n+use middle::mem_categorization::{cmt, Typer};\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n@@ -149,7 +149,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut MatchCheckCtxt {\n         tcx: tcx,\n-        param_env: ty::empty_parameter_environment(tcx),\n+        param_env: tcx.empty_parameter_environment(),\n     }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n@@ -203,9 +203,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n+            let pat_ty = cx.tcx.node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !type_is_empty(cx.tcx, pat_ty) {\n+                if !pat_ty.is_empty(cx.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n                               \"non-exhaustive patterns: type {} is non-empty\",\n@@ -231,11 +231,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n     ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n-                let pat_ty = ty::pat_ty(cx.tcx, p);\n+                let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(def_id, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n-                        if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n+                        if cx.tcx.enum_variants(def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n                                 && variant.args.is_empty()\n                         ) {\n@@ -509,12 +509,12 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n                 &Variant(vid) =>\n-                    (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n+                    (vid, cx.tcx.enum_variant_with_id(cid, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid, !ty::is_tuple_struct(cx.tcx, cid))\n+                    (cid, !cx.tcx.is_tuple_struct(cid))\n             };\n             if is_structure {\n-                let fields = ty::lookup_struct_fields(cx.tcx, vid);\n+                let fields = cx.tcx.lookup_struct_fields(vid);\n                 let field_pats: Vec<_> = fields.into_iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n@@ -605,7 +605,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n         },\n \n         ty::TyEnum(eid, _) =>\n-            ty::enum_variants(cx.tcx, eid)\n+            cx.tcx.enum_variants(eid)\n                 .iter()\n                 .map(|va| Variant(va.id))\n                 .collect(),\n@@ -651,12 +651,14 @@ fn is_useful(cx: &MatchCheckCtxt,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        ty::mk_nil(cx.tcx)\n+        cx.tcx.mk_nil()\n     } else {\n-        let left_ty = ty::pat_ty(cx.tcx, &*real_pat);\n+        let left_ty = cx.tcx.pat_ty(&*real_pat);\n \n         match real_pat.node {\n-            ast::PatIdent(ast::BindByRef(..), _, _) => ty::deref(left_ty, false).unwrap().ty,\n+            ast::PatIdent(ast::BindByRef(..), _, _) => {\n+                left_ty.builtin_deref(false).unwrap().ty\n+            }\n             _ => left_ty,\n         }\n     };\n@@ -815,11 +817,11 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n         },\n         ty::TyEnum(eid, _) => {\n             match *ctor {\n-                Variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                Variant(id) => cx.tcx.enum_variant_with_id(eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n-        ty::TyStruct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n+        ty::TyStruct(cid, _) => cx.tcx.lookup_struct_fields(cid).len(),\n         ty::TyArray(_, n) => n,\n         _ => 0\n     }\n@@ -911,7 +913,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 },\n                 _ => {\n                     // Assume this is a struct.\n-                    match ty::ty_to_def_id(node_id_to_type(cx.tcx, pat_id)) {\n+                    match cx.tcx.node_id_to_type(pat_id).ty_to_def_id() {\n                         None => {\n                             cx.tcx.sess.span_bug(pat_span,\n                                                  \"struct pattern wasn't of a \\\n@@ -922,7 +924,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 }\n             };\n             class_id.map(|variant_id| {\n-                let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                let struct_fields = cx.tcx.lookup_struct_fields(variant_id);\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.ident.name == sf.name) {\n                         Some(ref f) => &*f.node.pat,\n@@ -1107,8 +1109,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n-                        let pat_ty = ty::node_id_to_type(tcx, p.id);\n-                        if ty::type_moves_by_default(&cx.param_env, pat.span, pat_ty) {\n+                        let pat_ty = tcx.node_id_to_type(p.id);\n+                        if cx.param_env.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }"}, {"sha": "1489e946fe2ce57f090612399c3c9114ad42ab4c", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n+        if !cmt.ty.is_sized(self.param_env, span) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 cmt.ty);"}, {"sha": "1b1725dd15c851fea0cfddf49c22061177089fd2", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -126,9 +126,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         Some(ref_id) => {\n-                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                            let trait_id = tcx.trait_of_item(def_id)\n                                               .unwrap();\n-                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                            let substs = tcx.node_id_item_substs(ref_id)\n                                             .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs)\n@@ -176,7 +176,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // a trait-associated const if the caller gives us\n                         // the expression that refers to it.\n                         Some(ref_id) => {\n-                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                            let substs = tcx.node_id_item_substs(ref_id)\n                                             .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs).map(|e| e.id)\n@@ -714,7 +714,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n     eval_const_expr_with_substs(tcx, e, ty_hint, |id| {\n-        ty::node_id_item_substs(tcx, id).substs\n+        tcx.node_id_item_substs(id).substs\n     })\n }\n \n@@ -725,7 +725,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n     fn fromb(b: bool) -> ConstVal { Int(b as i64) }\n \n-    let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n+    let ety = ty_hint.or_else(|| tcx.expr_ty_opt(e));\n \n     // If type of expression itself is int or uint, normalize in these\n     // bindings so that isize/usize is mapped to a type with an\n@@ -882,7 +882,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         // FIXME (#23833): the type-hint can cause problems,\n         // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n         // type to the sum, and thus no overflow is signaled.\n-        let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n+        let base_hint = tcx.expr_ty_opt(&**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n@@ -1030,10 +1030,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let param_env = ty::empty_parameter_environment(tcx);\n+    let param_env = tcx.empty_parameter_environment();\n     let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n@@ -1056,7 +1056,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n \n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n-            match ty::associated_consts(tcx, impl_data.impl_def_id)\n+            match tcx.associated_consts(impl_data.impl_def_id)\n                      .iter().find(|ic| ic.name == ti.ident.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {"}, {"sha": "bd8b8afbdfe88de30b24c88deb6f623dc4c77b3e", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Some(method) => {\n                 match method.origin {\n                     ty::MethodStatic(def_id) => {\n-                        match ty::provided_source(self.tcx, def_id) {\n+                        match self.tcx.provided_source(def_id) {\n                             Some(p_did) => self.check_def_id(p_did),\n                             None => self.check_def_id(def_id)\n                         }\n@@ -116,9 +116,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         method_num: index,\n                         ..\n                     }) => {\n-                        let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_ref.def_id,\n-                                                        index);\n+                        let trait_item = self.tcx.trait_item(trait_ref.def_id, index);\n                         self.check_def_id(trait_item.def_id());\n                     }\n                 }\n@@ -132,9 +130,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n-        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n             ty::TyStruct(id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let fields = self.tcx.lookup_struct_fields(id);\n                 let field_id = fields.iter()\n                     .find(|field| field.name == name).unwrap().id;\n                 self.live_symbols.insert(field_id.node);\n@@ -144,9 +142,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n-        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n             ty::TyStruct(id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let fields = self.tcx.lookup_struct_fields(id);\n                 let field_id = fields[idx].id;\n                 self.live_symbols.insert(field_id.node);\n             },\n@@ -159,8 +157,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n-                match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n-                                                           lhs.id)) {\n+                match self.tcx.node_id_to_type(lhs.id).ty_to_def_id() {\n                     None => {\n                         self.tcx.sess.span_bug(lhs.span,\n                                                \"struct pattern wasn't of a \\\n@@ -170,7 +167,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 }\n             }\n         };\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let fields = self.tcx.lookup_struct_fields(id);\n         for pat in pats {\n             if let ast::PatWild(ast::PatWildSingle) = pat.node.pat.node {\n                 continue;\n@@ -480,8 +477,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n \n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n-        let field_type = ty::node_id_to_type(self.tcx, node.id);\n-        let is_marker_field = match ty::ty_to_def_id(field_type) {\n+        let field_type = self.tcx.node_id_to_type(node.id);\n+        let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n             _ => false\n         };"}, {"sha": "c48d5d5da40200bcc8d7b51b200722d00e9c1206", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n     fn check_str_index(&mut self, e: &ast::Expr) {\n         let base_type = match e.node {\n-            ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n+            ast::ExprIndex(ref base, _) => self.tcx.node_id_to_type(base.id),\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {:?}\",\n@@ -149,15 +149,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprCall(ref base, _) => {\n-                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n-                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -174,7 +174,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             ast::ExprPath(..) => {\n-                if let def::DefStatic(_, true) = ty::resolve_expr(self.tcx, expr) {\n+                if let def::DefStatic(_, true) = self.tcx.resolve_expr(expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }"}, {"sha": "a15d02ea29605903a4f9d083dcb0ef41b2a67658", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -229,7 +229,7 @@ impl OverloadedCallType {\n \n     fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n                       -> OverloadedCallType {\n-        let method_descriptor = match ty::impl_or_trait_item(tcx, method_id) {\n+        let method_descriptor = match tcx.impl_or_trait_item(method_id) {\n             ty::MethodTraitItem(ref method_descriptor) => {\n                 (*method_descriptor).clone()\n             }\n@@ -244,7 +244,7 @@ impl OverloadedCallType {\n             }\n             ty::ImplContainer(impl_id) => impl_id,\n         };\n-        let trait_ref = match ty::impl_trait_ref(tcx, impl_id) {\n+        let trait_ref = match tcx.impl_trait_ref(impl_id) {\n             None => {\n                 tcx.sess.bug(\"statically resolved overloaded call impl \\\n                               didn't implement a trait?!\")\n@@ -502,9 +502,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n-                let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n-                let bk = ty::BorrowKind::from_mutbl(m);\n-                self.borrow_expr(&**base, r, bk, AddrOf);\n+                if let ty::TyRef(&r, _) = expr_ty.sty {\n+                    let bk = ty::BorrowKind::from_mutbl(m);\n+                    self.borrow_expr(&**base, r, bk, AddrOf);\n+                }\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n@@ -740,7 +741,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // expression that will actually be used\n         let with_fields = match with_cmt.ty.sty {\n             ty::TyStruct(did, substs) => {\n-                ty::struct_fields(self.tcx(), did, substs)\n+                self.tcx().struct_fields(did, substs)\n             }\n             _ => {\n                 // the base expression should always evaluate to a\n@@ -821,8 +822,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                     // the method call infrastructure should have\n                     // replaced all late-bound regions with variables:\n-                    let self_ty = ty::ty_fn_sig(method_ty).input(0);\n-                    let self_ty = ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap();\n+                    let self_ty = method_ty.fn_sig().input(0);\n+                    let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n \n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -922,10 +923,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // This is always an rvalue, since we are producing a new\n         // (temporary) indirection.\n \n-        let adj_ty =\n-            ty::adjust_ty_for_autoref(self.tcx(),\n-                                      cmt_base_ty,\n-                                      opt_autoref);\n+        let adj_ty = cmt_base_ty.adjust_for_autoref(self.tcx(), opt_autoref);\n \n         self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n     }\n@@ -1074,12 +1072,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n                     ast::PatIdent(ast::BindByRef(m), _, _) => {\n-                        let (r, bk) = {\n-                            (ty::ty_region(tcx, pat.span, pat_ty),\n-                             ty::BorrowKind::from_mutbl(m))\n-                        };\n-                        delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                             r, bk, RefBinding);\n+                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(pat.id, pat.span, cmt_pat,\n+                                            r, bk, RefBinding);\n+                        }\n                     }\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n@@ -1152,7 +1149,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                         Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n-                                if ty::enum_is_univariant(tcx, enum_did) {\n+                                if tcx.enum_is_univariant(enum_did) {\n                                     cmt_pat\n                                 } else {\n                                     let cmt_pat_ty = cmt_pat.ty;\n@@ -1238,7 +1235,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n+        self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n                 let id_var = freevar.def.def_id().node;\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n@@ -1283,7 +1280,7 @@ fn copy_or_move<'tcx>(typer: &mc::Typer<'tcx>,\n                       move_reason: MoveReason)\n                       -> ConsumeMode\n {\n-    if typer.type_moves_by_default(cmt.span, cmt.ty) {\n+    if typer.type_moves_by_default(cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "d5fa885b16ab50cf08a08c41de13218967fe60cb", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n             ty::TyEnum(def_id, substs) |\n             ty::TyStruct(def_id, substs) => {\n-                let item_scheme = ty::lookup_item_type(self.tcx(), def_id);\n+                let item_scheme = self.tcx().lookup_item_type(def_id);\n                 self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                            substs: &Substs<'tcx>)\n     {\n         let predicates =\n-            ty::lookup_predicates(self.tcx(), def_id).instantiate(self.tcx(), substs);\n+            self.tcx().lookup_predicates(def_id).instantiate(self.tcx(), substs);\n         let predicates = match self.fully_normalize(&predicates) {\n             Ok(predicates) => predicates,\n             Err(ErrorReported) => { return; }\n@@ -250,15 +250,15 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 ty::Predicate::Equate(..) => { }\n                 ty::Predicate::Projection(..) => { }\n                 ty::Predicate::RegionOutlives(ref data) => {\n-                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                    match self.tcx().no_late_bound_regions(data) {\n                         None => { }\n                         Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                             self.push_sub_region_constraint(Some(ty), r_b, r_a);\n                         }\n                     }\n                 }\n                 ty::Predicate::TypeOutlives(ref data) => {\n-                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                    match self.tcx().no_late_bound_regions(data) {\n                         None => { }\n                         Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                             self.stack.push((r_b, Some(ty)));\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                                     .map(|pred| Implication::Predicate(def_id, pred));\n         self.out.extend(obligations);\n \n-        let variances = ty::item_variances(self.tcx(), def_id);\n+        let variances = self.tcx().item_variances(def_id);\n \n         for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n             match variance {\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                data);\n \n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n-            match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+            match self.tcx().no_late_bound_regions(&poly_trait_ref) {\n                 Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n                 None => { }\n             }\n@@ -330,11 +330,11 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                trait_ref);\n \n         let trait_def_id = trait_ref.def_id;\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n         let assoc_type_projections: Vec<_> =\n             trait_def.associated_type_names\n                      .iter()\n-                     .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n+                     .map(|&name| self.tcx().mk_projection(trait_ref.clone(), name))\n                      .collect();\n         debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n                assoc_type_projections);\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + ty::HasTypeFlags\n     {\n         let value =\n             traits::fully_normalize(self.infcx,\n@@ -437,7 +437,7 @@ pub fn object_region_bounds<'tcx>(\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n     // Note that we preserve the overall binding levels here.\n     assert!(!open_ty.has_escaping_regions());\n@@ -447,5 +447,5 @@ pub fn object_region_bounds<'tcx>(\n     let mut predicates = others.to_predicates(tcx, open_ty);\n     predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n \n-    ty::required_region_bounds(tcx, open_ty, predicates)\n+    tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "d2268894b20a1d5cb2c06e5b4d2f9e2417317620", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n-        let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n+        let a1 = self.tcx().erase_late_bound_regions(a);\n+        let b1 = self.tcx().erase_late_bound_regions(b);\n         let c = try!(self.relate(&a1, &b1));\n         Ok(ty::Binder(c))\n     }"}, {"sha": "13b2214d35328f0ee972547377dd9c4940513aa9", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -129,8 +129,8 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n          .unify_var_value(vid, val)\n          .map_err(|e| int_unification_error(vid_is_expected, e)));\n     match val {\n-        IntType(v) => Ok(ty::mk_mach_int(infcx.tcx, v)),\n-        UintType(v) => Ok(ty::mk_mach_uint(infcx.tcx, v)),\n+        IntType(v) => Ok(infcx.tcx.mk_mach_int(v)),\n+        UintType(v) => Ok(infcx.tcx.mk_mach_uint(v)),\n     }\n }\n \n@@ -145,7 +145,7 @@ fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n          .borrow_mut()\n          .unify_var_value(vid, val)\n          .map_err(|e| float_unification_error(vid_is_expected, e)));\n-    Ok(ty::mk_mach_float(infcx.tcx, val))\n+    Ok(infcx.tcx.mk_mach_float(val))\n }\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {"}, {"sha": "17075c0cba6cabe0f64ba18bd6a7f5b73f5ef1d2", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 155, "deletions": 203, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -77,7 +77,7 @@ use middle::def;\n use middle::infer;\n use middle::region;\n use middle::subst;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::{Region, ReFree};\n \n use std::cell::{Cell, RefCell};\n@@ -91,123 +91,125 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-pub fn note_and_explain_region(tcx: &ty::ctxt,\n-                               prefix: &str,\n-                               region: ty::Region,\n-                               suffix: &str) {\n-    fn item_scope_tag(item: &ast::Item) -> &'static str {\n-        match item.node {\n-            ast::ItemImpl(..) => \"impl\",\n-            ast::ItemStruct(..) => \"struct\",\n-            ast::ItemEnum(..) => \"enum\",\n-            ast::ItemTrait(..) => \"trait\",\n-            ast::ItemFn(..) => \"function body\",\n-            _ => \"item\"\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn note_and_explain_region(&self,\n+                                   prefix: &str,\n+                                   region: ty::Region,\n+                                   suffix: &str) {\n+        fn item_scope_tag(item: &ast::Item) -> &'static str {\n+            match item.node {\n+                ast::ItemImpl(..) => \"impl\",\n+                ast::ItemStruct(..) => \"struct\",\n+                ast::ItemEnum(..) => \"enum\",\n+                ast::ItemTrait(..) => \"trait\",\n+                ast::ItemFn(..) => \"function body\",\n+                _ => \"item\"\n+            }\n         }\n-    }\n-\n-    fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n-                    -> (String, Option<Span>) {\n-        let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n-         Some(span))\n-    }\n \n-    let (description, span) = match region {\n-        ty::ReScope(scope) => {\n-            let new_string;\n-            let unknown_scope = || {\n-                format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n-                        prefix, scope, suffix)\n-            };\n-            let span = match scope.span(&tcx.map) {\n-                Some(s) => s,\n-                None => return tcx.sess.note(&unknown_scope())\n-            };\n-            let tag = match tcx.map.find(scope.node_id()) {\n-                Some(ast_map::NodeBlock(_)) => \"block\",\n-                Some(ast_map::NodeExpr(expr)) => match expr.node {\n-                    ast::ExprCall(..) => \"call\",\n-                    ast::ExprMethodCall(..) => \"method call\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n-                    ast::ExprMatch(..) => \"match\",\n-                    _ => \"expression\",\n-                },\n-                Some(ast_map::NodeStmt(_)) => \"statement\",\n-                Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n-                Some(_) | None => {\n-                    return tcx.sess.span_note(span, &unknown_scope());\n-                }\n-            };\n-            let scope_decorated_tag = match scope {\n-                region::CodeExtent::Misc(_) => tag,\n-                region::CodeExtent::ParameterScope { .. } => {\n-                    \"scope of parameters for function\"\n-                }\n-                region::CodeExtent::DestructionScope(_) => {\n-                    new_string = format!(\"destruction scope surrounding {}\", tag);\n-                    &new_string[..]\n-                }\n-                region::CodeExtent::Remainder(r) => {\n-                    new_string = format!(\"block suffix following statement {}\",\n-                                         r.first_statement_index);\n-                    &new_string[..]\n-                }\n-            };\n-            explain_span(tcx, scope_decorated_tag, span)\n+        fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n+                        -> (String, Option<Span>) {\n+            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n+            (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n+             Some(span))\n         }\n \n-        ty::ReFree(ref fr) => {\n-            let prefix = match fr.bound_region {\n-                ty::BrAnon(idx) => {\n-                    format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n-                }\n-                ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n-                _ => {\n-                    format!(\"the lifetime {} as defined on\",\n-                            fr.bound_region)\n-                }\n-            };\n+        let (description, span) = match region {\n+            ty::ReScope(scope) => {\n+                let new_string;\n+                let unknown_scope = || {\n+                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                            prefix, scope, suffix)\n+                };\n+                let span = match scope.span(&self.map) {\n+                    Some(s) => s,\n+                    None => return self.sess.note(&unknown_scope())\n+                };\n+                let tag = match self.map.find(scope.node_id()) {\n+                    Some(ast_map::NodeBlock(_)) => \"block\",\n+                    Some(ast_map::NodeExpr(expr)) => match expr.node {\n+                        ast::ExprCall(..) => \"call\",\n+                        ast::ExprMethodCall(..) => \"method call\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        ast::ExprMatch(..) => \"match\",\n+                        _ => \"expression\",\n+                    },\n+                    Some(ast_map::NodeStmt(_)) => \"statement\",\n+                    Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                    Some(_) | None => {\n+                        return self.sess.span_note(span, &unknown_scope());\n+                    }\n+                };\n+                let scope_decorated_tag = match scope {\n+                    region::CodeExtent::Misc(_) => tag,\n+                    region::CodeExtent::ParameterScope { .. } => {\n+                        \"scope of parameters for function\"\n+                    }\n+                    region::CodeExtent::DestructionScope(_) => {\n+                        new_string = format!(\"destruction scope surrounding {}\", tag);\n+                        &new_string[..]\n+                    }\n+                    region::CodeExtent::Remainder(r) => {\n+                        new_string = format!(\"block suffix following statement {}\",\n+                                             r.first_statement_index);\n+                        &new_string[..]\n+                    }\n+                };\n+                explain_span(self, scope_decorated_tag, span)\n+            }\n \n-            match tcx.map.find(fr.scope.node_id) {\n-                Some(ast_map::NodeBlock(ref blk)) => {\n-                    let (msg, opt_span) = explain_span(tcx, \"block\", blk.span);\n-                    (format!(\"{} {}\", prefix, msg), opt_span)\n-                }\n-                Some(ast_map::NodeItem(it)) => {\n-                    let tag = item_scope_tag(&*it);\n-                    let (msg, opt_span) = explain_span(tcx, tag, it.span);\n-                    (format!(\"{} {}\", prefix, msg), opt_span)\n-                }\n-                Some(_) | None => {\n-                    // this really should not happen\n-                    (format!(\"{} unknown free region bounded by scope {:?}\",\n-                             prefix, fr.scope), None)\n+            ty::ReFree(ref fr) => {\n+                let prefix = match fr.bound_region {\n+                    ty::BrAnon(idx) => {\n+                        format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                    }\n+                    ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                    _ => {\n+                        format!(\"the lifetime {} as defined on\",\n+                                fr.bound_region)\n+                    }\n+                };\n+\n+                match self.map.find(fr.scope.node_id) {\n+                    Some(ast_map::NodeBlock(ref blk)) => {\n+                        let (msg, opt_span) = explain_span(self, \"block\", blk.span);\n+                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                    }\n+                    Some(ast_map::NodeItem(it)) => {\n+                        let tag = item_scope_tag(&*it);\n+                        let (msg, opt_span) = explain_span(self, tag, it.span);\n+                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                    }\n+                    Some(_) | None => {\n+                        // this really should not happen\n+                        (format!(\"{} unknown free region bounded by scope {:?}\",\n+                                 prefix, fr.scope), None)\n+                    }\n                 }\n             }\n-        }\n \n-        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+            ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-        ty::ReEarlyBound(ref data) => {\n-            (format!(\"{}\", token::get_name(data.name)), None)\n-        }\n+            ty::ReEarlyBound(ref data) => {\n+                (format!(\"{}\", token::get_name(data.name)), None)\n+            }\n \n-        // I believe these cases should not occur (except when debugging,\n-        // perhaps)\n-        ty::ReInfer(_) | ty::ReLateBound(..) => {\n-            (format!(\"lifetime {:?}\", region), None)\n+            // I believe these cases should not occur (except when debugging,\n+            // perhaps)\n+            ty::ReInfer(_) | ty::ReLateBound(..) => {\n+                (format!(\"lifetime {:?}\", region), None)\n+            }\n+        };\n+        let message = format!(\"{}{}{}\", prefix, description, suffix);\n+        if let Some(span) = span {\n+            self.sess.span_note(span, &message);\n+        } else {\n+            self.sess.note(&message);\n         }\n-    };\n-    let message = format!(\"{}{}{}\", prefix, description, suffix);\n-    if let Some(span) = span {\n-        tcx.sess.span_note(span, &message);\n-    } else {\n-        tcx.sess.note(&message);\n     }\n }\n \n@@ -226,7 +228,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -491,7 +493,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                      terr: &ty::type_err<'tcx>) {\n         let span = trace.origin.span();\n         self.report_type_error(trace, terr);\n-        ty::note_and_explain_type_err(self.tcx, terr, span);\n+        self.tcx.note_and_explain_type_err(terr, span);\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n@@ -504,18 +506,18 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n-        if expected.contains_error() {\n+        if expected.references_error() {\n             return None;\n         }\n \n         let found = exp_found.found.resolve(self);\n-        if found.contains_error() {\n+        if found.references_error() {\n             return None;\n         }\n \n@@ -576,8 +578,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n                         bound_kind));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\");\n@@ -600,13 +601,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n                     \"\");\n@@ -615,42 +614,33 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 span_err!(self.tcx.sess, span, E0313,\n                     \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   upvar_id.var_id)\n-                                .to_string());\n-                note_and_explain_region(\n-                    self.tcx,\n+                            self.tcx.local_var_name_str(upvar_id.var_id));\n+                self.tcx.note_and_explain_region(\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"...but `{}` is only valid for \",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   upvar_id.var_id)\n-                                .to_string()),\n+                             self.tcx.local_var_name_str(upvar_id.var_id)),\n                     sup,\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n                 span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...the closure must be valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but the closure's stack frame is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n                 span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the closure is only valid for \",\n                     sup,\n                     \"\");\n@@ -659,8 +649,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"dereference of reference outside its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n@@ -669,25 +658,21 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     &format!(\"captured variable `{}` does not \\\n-                            outlive the enclosing closure\",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   id).to_string()));\n-                note_and_explain_region(\n-                    self.tcx,\n+                              outlive the enclosing closure\",\n+                             self.tcx.local_var_name_str(id)));\n+                self.tcx.note_and_explain_region(\n                     \"captured variable is valid for \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"closure is valid for \",\n                     sub,\n                     \"\");\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(span,\n                                        \"index of slice outside its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n@@ -697,13 +682,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of the source pointer does not outlive \\\n                      lifetime bound of the object type\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"object type is valid for \",\n                     sub,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"source pointer is only valid for \",\n                     sup,\n                     \"\");\n@@ -714,7 +697,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(self.tcx,\n+                self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n@@ -723,13 +706,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\");\n@@ -740,7 +721,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(self.tcx,\n+                self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n@@ -750,8 +731,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of method receiver does not outlive \\\n                      the method call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n@@ -761,8 +741,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of function argument does not outlive \\\n                      the function call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n@@ -772,8 +751,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of return value does not outlive \\\n                      the function call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n@@ -783,8 +761,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of operand does not outlive \\\n                      the operation\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n@@ -794,8 +771,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"reference is not valid \\\n                      at the time of borrow\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n@@ -805,8 +781,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"automatically reference is not valid \\\n                      at the time of borrow\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n@@ -817,8 +792,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n                             self.ty_to_string(t)));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n@@ -829,13 +803,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"unsafe use of destructor: destructor might be called \\\n                      while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"superregion: \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"subregion: \",\n                     sub,\n                     \"\");\n@@ -844,8 +816,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"lifetime of variable does not enclose its declaration\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n@@ -856,13 +827,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the pointer is valid for \",\n                     sub,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"but the referenced data is only valid for \",\n                     sup,\n                     \"\");\n@@ -878,16 +847,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sup_region: Region) {\n         self.report_inference_failure(var_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&sup_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n@@ -903,16 +870,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                region2: Region) {\n         self.report_inference_failure(var_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"first, the lifetime must be contained by \",\n             region1,\n             \"...\");\n \n         self.note_region_origin(&origin1);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"but, the lifetime must also be contained by \",\n             region2,\n             \"...\");\n@@ -1353,7 +1318,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     };\n                     match a_def {\n                         def::DefTy(did, _) | def::DefStruct(did) => {\n-                            let generics = ty::lookup_item_type(self.tcx, did).generics;\n+                            let generics = self.tcx.lookup_item_type(did).generics;\n \n                             let expected =\n                                 generics.regions.len(subst::TypeSpace) as u32;\n@@ -1591,7 +1556,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string())\n+                        self.tcx.local_var_name_str(upvar_id.var_id).to_string())\n             }\n         };\n \n@@ -1671,7 +1636,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\n                         \"...so that closure can access `{}`\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id)\n+                        self.tcx.local_var_name_str(upvar_id.var_id)\n                             .to_string()))\n             }\n             infer::InfStackClosure(span) => {\n@@ -1695,9 +1660,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n-                            ty::local_var_name_str(\n-                                self.tcx,\n-                                id).to_string()));\n+                            self.tcx.local_var_name_str(id)));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1793,26 +1756,19 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n pub trait Resolvable<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n-    fn contains_error(&self) -> bool;\n }\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-    fn contains_error(&self) -> bool {\n-        ty::type_is_error(*self)\n-    }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n                    -> ty::TraitRef<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-    fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(self)\n-    }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n@@ -1822,10 +1778,6 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-\n-    fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&self.0)\n-    }\n }\n \n fn lifetimes_in_scope(tcx: &ty::ctxt,"}, {"sha": "d65c4061f11eb3cb7c6b46c6c9f0c038f5307a15", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -30,7 +30,7 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;\n                 self.freshen_count += 1;\n-                let t = ty::mk_infer(self.infcx.tcx, freshener(index));\n+                let t = self.infcx.tcx.mk_infer(freshener(index));\n                 entry.insert(t);\n                 t\n             }\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) && !ty::type_has_erasable_regions(t) {\n+        if !t.needs_infer() && !t.has_erasable_regions() {\n             return t;\n         }\n "}, {"sha": "9005e1b8c53a514e39aa9d22db248efb3685959b", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -507,7 +507,7 @@ pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                   types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n                                   defs: &[ty::TypeParameterDef<'tcx>]) {\n         for def in defs {\n-            let ty = ty::mk_param_from_def(tcx, def);\n+            let ty = tcx.mk_param_from_def(def);\n             types.push(def.space, ty);\n         }\n     }"}, {"sha": "f1af2705d4ed891d9f619eb2709886f909c80889", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -26,7 +26,7 @@ use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -772,11 +772,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var(&self) -> Ty<'tcx> {\n-        ty::mk_var(self.tcx, self.next_ty_var_id(false))\n+        self.tcx.mk_var(self.next_ty_var_id(false))\n     }\n \n     pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n-        ty::mk_var(self.tcx, self.next_ty_var_id(true))\n+        self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n \n     pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n@@ -973,20 +973,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n-        match resolved_expected {\n-            Some(t) if ty::type_is_error(t) => (),\n-            _ => {\n-                let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                    format!(\" ({})\", t_err)\n-                });\n+        if !resolved_expected.references_error() {\n+            let error_str = err.map_or(\"\".to_string(), |t_err| {\n+                format!(\" ({})\", t_err)\n+            });\n \n-                self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n-                    mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str));\n+            self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n+                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n+                error_str));\n \n-                if let Some(err) = err {\n-                    ty::note_and_explain_type_err(self.tcx, err, sp)\n-                }\n+            if let Some(err) = err {\n+                self.tcx.note_and_explain_type_err(err, sp)\n             }\n         }\n     }\n@@ -1001,7 +998,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is TyError.\n-        if ty::type_is_error(actual_ty) {\n+        if actual_ty.references_error() {\n             return;\n         }\n "}, {"sha": "fac7b53ca76aa5b4ec264c066e166e3cde7de7ab", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -1672,7 +1672,7 @@ impl<'tcx> GenericKind<'tcx> {\n             GenericKind::Param(ref p) =>\n                 p.to_ty(tcx),\n             GenericKind::Projection(ref p) =>\n-                ty::mk_projection(tcx, p.trait_ref.clone(), p.item_name),\n+                tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }"}, {"sha": "41a0d373fba43da8a8979a135ed658701337df10", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFoldable};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,7 +36,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx>\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_has_ty_infer(t) {\n+        if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t0 = self.infcx.shallow_resolve(t);\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) {\n+        if !t.needs_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);"}, {"sha": "c13cec45dc44a353e678486754d5730751e6c16d", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -26,8 +26,8 @@ impl UnifyKey for ty::IntVid {\n impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n-            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n+            ty::IntType(i) => tcx.mk_mach_int(i),\n+            ty::UintType(i) => tcx.mk_mach_uint(i),\n         }\n     }\n }\n@@ -43,6 +43,6 @@ impl UnifyKey for ty::FloatVid {\n \n impl<'tcx> ToType<'tcx> for ast::FloatTy {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_mach_float(tcx, *self)\n+        tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "c5f6f0126de378eec7d6fcba1fb9ba2f8a529bfb", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -13,7 +13,7 @@ use metadata::csearch;\n use middle::def::DefFn;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n \n use std::fmt;\n \n@@ -30,7 +30,7 @@ pub fn check_crate(tcx: &ctxt) {\n         tcx: tcx,\n         param_envs: Vec::new(),\n         dummy_sized_ty: tcx.types.isize,\n-        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.isize, None),\n+        dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n     };\n     visit::walk_crate(&mut visitor, tcx.map.krate());\n }\n@@ -54,7 +54,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n+        let intrinsic = match self.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n@@ -92,8 +92,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         // Simple case: no type parameters involved.\n         if\n-            !ty::type_has_params(from) && !ty::type_has_self(from) &&\n-            !ty::type_has_params(to) && !ty::type_has_self(to)\n+            !from.has_param_types() && !from.has_self_ty() &&\n+            !to.has_param_types() && !to.has_self_ty()\n         {\n             let restriction = TransmuteRestriction {\n                 span: span,\n@@ -160,8 +160,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // In all cases, we keep the original unsubstituted types\n         // around for error reporting.\n \n-        let from_tc = ty::type_contents(self.tcx, from);\n-        let to_tc = ty::type_contents(self.tcx, to);\n+        let from_tc = from.type_contents(self.tcx);\n+        let to_tc = to.type_contents(self.tcx);\n         if from_tc.interior_param() || to_tc.interior_param() {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute to or from a type that contains \\\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n                        space, index, param_ty);\n \n-                if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n+                if !param_ty.is_sized(param_env, span) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n \n                     substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n@@ -253,9 +253,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         if let ast::ExprPath(..) = expr.node {\n-            match ty::resolve_expr(self.tcx, expr) {\n+            match self.tcx.resolve_expr(expr) {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n-                    let typ = ty::node_id_to_type(self.tcx, expr.id);\n+                    let typ = self.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         TyBareFn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {"}, {"sha": "d354c1667da38b7b03dcfcfaffaf5aab0c9a0c02", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -465,7 +465,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ty::with_freevars(ir.tcx, expr.id, |freevars| {\n+        ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n                 if let DefLocal(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -1137,9 +1137,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ast::ExprCall(ref f, ref args) => {\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f)).diverges()\n-            };\n+            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n+                self.ir.tcx.expr_ty_adjusted(&**f).fn_ret().diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1152,8 +1151,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-            let diverges = ty::ty_fn_ret(method_ty).diverges();\n-            let succ = if diverges {\n+            let succ = if method_ty.fn_ret().diverges() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1496,12 +1494,11 @@ fn check_fn(_v: &Liveness,\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n-        let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n+        let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ =>\n-                ty::ty_fn_ret(fn_ty),\n+            _ => fn_ty.fn_ret()\n         }\n     }\n \n@@ -1514,23 +1511,22 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     {\n         // within the fn body, late-bound regions are liberated:\n         let fn_ret =\n-            ty::liberate_late_bound_regions(\n-                self.ir.tcx,\n+            self.ir.tcx.liberate_late_bound_regions(\n                 region::DestructionScopeData::new(body.id),\n                 &self.fn_ret(id));\n \n         match fn_ret {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n \n-                if ty::type_is_nil(t_ret) {\n+                if t_ret.is_nil() {\n                     // for nil return types, it is ok to not return a value expl.\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n-                                    ty::expr_ty(self.ir.tcx, &**e) == t_ret\n+                                    self.ir.tcx.expr_ty(&**e) == t_ret\n                                 },\n                                 _ => false\n                             },"}, {"sha": "969ffaf88a719cee613a7df622075f404d974cfa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -285,7 +285,7 @@ pub type McResult<T> = Result<T, ()>;\n pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool;\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>;\n@@ -406,9 +406,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         let unadjusted_ty = try!(self.expr_ty(expr));\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().get(&expr.id),\n-                         |method_call| self.typer.node_method_ty(method_call)))\n+        Ok(unadjusted_ty.adjust(\n+            self.tcx(), expr.span, expr.id,\n+            self.typer.adjustments().borrow().get(&expr.id),\n+            |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -426,7 +427,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                match ty::deref(base_ty, false) {\n+                match base_ty.builtin_deref(false) {\n                     Some(t) => t.ty,\n                     None => { return Err(()); }\n                 }\n@@ -927,14 +928,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty =\n-                    ty::no_late_bound_regions(\n-                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n+                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n         };\n         let base_cmt_ty = base_cmt.ty;\n-        match ty::deref(base_cmt_ty, true) {\n+        match base_cmt_ty.builtin_deref(true) {\n             Some(mt) => {\n                 let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n                                               mt.ty,\n@@ -1023,11 +1023,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n \n                 // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n-                let self_ty = ty::ty_fn_sig(method_ty).input(0);\n-                ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap()\n+                let self_ty = method_ty.fn_sig().input(0);\n+                self.tcx().no_late_bound_regions(&self_ty).unwrap()\n             }\n             None => {\n-                match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n+                match base_cmt.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {\n                         return Err(());\n@@ -1081,7 +1081,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n                     mutbl:m,\n-                    ty: match ty::deref(base_cmt.ty, false) {\n+                    ty: match base_cmt.ty.builtin_deref(false) {\n                         Some(mt) => mt.ty,\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n@@ -1244,7 +1244,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let cmt = match opt_def {\n             Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n-                if !ty::enum_is_univariant(self.tcx(), enum_did) => {\n+                if !self.tcx().enum_is_univariant(enum_did) => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                 }\n             _ => cmt\n@@ -1375,7 +1375,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // types are generated by method resolution and always have\n         // all late-bound regions fully instantiated, so we just want\n         // to skip past the binder.\n-        ty::no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+        self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n            .unwrap()\n            .unwrap() // overloaded ops do not diverge, either\n     }\n@@ -1583,7 +1583,7 @@ impl<'tcx> fmt::Debug for categorization<'tcx> {\n             cat_static_item => write!(f, \"static\"),\n             cat_rvalue(r) => write!(f, \"rvalue({:?})\", r),\n             cat_local(id) => {\n-               let name = ty::tls::with(|tcx| ty::local_var_name_str(tcx, id));\n+               let name = ty::tls::with(|tcx| tcx.local_var_name_str(id));\n                write!(f, \"local({})\", name)\n             }\n             cat_upvar(upvar) => {"}, {"sha": "15a1ba853245b0934771e3e8f2daa7b4ecb24cf7", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -192,7 +192,7 @@ pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n }\n \n pub fn def_to_path(tcx: &ty::ctxt, id: ast::DefId) -> ast::Path {\n-    ty::with_path(tcx, id, |path| ast::Path {\n+    tcx.with_path(id, |path| ast::Path {\n         global: false,\n         segments: path.last().map(|elem| ast::PathSegment {\n             identifier: ast::Ident::new(elem.name()),"}, {"sha": "4766ae8933d0b535564e6e0769e3d21a16df50cb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -382,7 +382,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n         // items.\n         ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n-            let trait_items = ty::trait_items(tcx, trait_did);\n+            let trait_items = tcx.trait_items(trait_did);\n \n             for impl_item in impl_items {\n                 let item = trait_items.iter().find(|item| {\n@@ -425,7 +425,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                             method_num: index,\n                             ..\n                         }) => {\n-                            ty::trait_item(tcx, trait_ref.def_id, index).def_id()\n+                            tcx.trait_item(trait_ref.def_id, index).def_id()\n                         }\n                     }\n                 }\n@@ -434,9 +434,9 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         }\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;\n-            match ty::expr_ty_adjusted(tcx, base_e).sty {\n+            match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(did, _) => {\n-                    ty::lookup_struct_fields(tcx, did)\n+                    tcx.lookup_struct_fields(did)\n                         .iter()\n                         .find(|f| f.name == field.node.name)\n                         .unwrap_or_else(|| {\n@@ -451,9 +451,9 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         }\n         ast::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n-            match ty::expr_ty_adjusted(tcx, base_e).sty {\n+            match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(did, _) => {\n-                    ty::lookup_struct_fields(tcx, did)\n+                    tcx.lookup_struct_fields(did)\n                         .get(field.node)\n                         .unwrap_or_else(|| {\n                             tcx.sess.span_bug(field.span,\n@@ -468,10 +468,10 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n             }\n         }\n         ast::ExprStruct(_, ref expr_fields, _) => {\n-            let type_ = ty::expr_ty(tcx, e);\n+            let type_ = tcx.expr_ty(e);\n             match type_.sty {\n                 ty::TyStruct(did, _) => {\n-                    let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                    let struct_fields = tcx.lookup_struct_fields(did);\n                     // check the stability of each field that appears\n                     // in the construction expression.\n                     for field in expr_fields {\n@@ -525,11 +525,11 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let did = match ty::pat_ty_opt(tcx, pat) {\n+    let did = match tcx.pat_ty_opt(pat) {\n         Some(&ty::TyS { sty: ty::TyStruct(did, _), .. }) => did,\n         Some(_) | None => return,\n     };\n-    let struct_fields = ty::lookup_struct_fields(tcx, did);\n+    let struct_fields = tcx.lookup_struct_fields(did);\n     match pat.node {\n         // Foo(a, b, c)\n         ast::PatEnum(_, Some(ref pat_fields)) => {\n@@ -574,7 +574,7 @@ fn is_internal(tcx: &ty::ctxt, span: Span) -> bool {\n }\n \n fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n-    match ty::trait_item_of_item(tcx, id) {\n+    match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n             if trait_method_id != id => {\n                 is_staged_api(tcx, trait_method_id)\n@@ -602,7 +602,7 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n     debug!(\"lookup(id={:?})\", id);\n \n     // is this definition the implementation of a trait method?\n-    match ty::trait_item_of_item(tcx, id) {\n+    match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n             debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n             return lookup(tcx, trait_method_id)\n@@ -617,8 +617,8 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n     };\n \n     item_stab.or_else(|| {\n-        if ty::is_impl(tcx, id) {\n-            if let Some(trait_id) = ty::trait_id_of_impl(tcx, id) {\n+        if tcx.is_impl(id) {\n+            if let Some(trait_id) = tcx.trait_id_of_impl(id) {\n                 // FIXME (#18969): for the time being, simply use the\n                 // stability of the trait to determine the stability of any\n                 // unmarked impls for it. See FIXME above for more details."}, {"sha": "56798ae6848a54152ac8bfb3580b7cce2d94a567", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -13,7 +13,7 @@\n pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n \n use std::fmt;\n@@ -100,17 +100,6 @@ impl<'tcx> Substs<'tcx> {\n         *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n     }\n \n-    pub fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n-            match self.regions {\n-                ErasedRegions =>\n-                    false,\n-                NonerasedRegions(ref regions) =>\n-                    regions.iter().any(|r| r.escapes_depth(depth)),\n-            }\n-        }\n-    }\n-\n     pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().cloned()\n     }\n@@ -632,7 +621,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_subst(t) {\n+        if !t.needs_subst() {\n             return t;\n         }\n \n@@ -729,10 +718,10 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// first case we do not increase the Debruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n-               ty, self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, has_escaping_regions={:?})\",\n+               ty, self.region_binders_passed, ty.has_escaping_regions());\n \n-        if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n+        if self.region_binders_passed == 0 || !ty.has_escaping_regions() {\n             return ty;\n         }\n "}, {"sha": "371b5c309a85067016b756ec8c3a55fb4b8b112f", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -38,7 +38,7 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n            impl1_def_id,\n            impl2_def_id);\n \n-    let param_env = &ty::empty_parameter_environment(infcx.tcx);\n+    let param_env = &infcx.tcx.empty_parameter_environment();\n     let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n     infcx.probe(|_| {\n         overlap(selcx, impl1_def_id, impl2_def_id) || overlap(selcx, impl2_def_id, impl1_def_id)\n@@ -111,7 +111,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n     // already\n     if\n         trait_ref.def_id.krate != ast::LOCAL_CRATE &&\n-        !ty::has_attr(tcx, trait_ref.def_id, \"fundamental\")\n+        !tcx.has_attr(trait_ref.def_id, \"fundamental\")\n     {\n         debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n         return false;\n@@ -142,13 +142,13 @@ fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     let impl_substs =\n         &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n     let impl_trait_ref =\n-        ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n+        selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref =\n         impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n         project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n \n-    let predicates = ty::lookup_predicates(selcx.tcx(), impl_def_id);\n+    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         project::normalize(selcx, ObligationCause::dummy(), &predicates);\n@@ -183,7 +183,7 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n-    let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n@@ -280,9 +280,9 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n         ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) =>\n-            ty::has_attr(tcx, def_id, \"fundamental\"),\n+            tcx.has_attr(def_id, \"fundamental\"),\n         ty::TyTrait(ref data) =>\n-            ty::has_attr(tcx, data.principal_def_id(), \"fundamental\"),\n+            tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n         _ =>\n             false\n     }"}, {"sha": "582873082a68b2625f07949c0456089859f22805", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -25,7 +25,7 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n-use middle::ty::{self, ToPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n+use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n@@ -79,14 +79,14 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                      span: Span) -> Option<String> {\n     let def_id = trait_ref.def_id;\n     let mut report = None;\n-    for item in ty::get_attrs(infcx.tcx, def_id).iter() {\n+    for item in infcx.tcx.get_attrs(def_id).iter() {\n         if item.check_name(\"rustc_on_unimplemented\") {\n             let err_sp = if item.meta().span == DUMMY_SP {\n                 span\n             } else {\n                 item.meta().span\n             };\n-            let def = ty::lookup_trait_def(infcx.tcx, def_id);\n+            let def = infcx.tcx.lookup_trait_def(def_id);\n             let trait_str = def.trait_ref.to_string();\n             if let Some(ref istring) = item.value_str() {\n                 let mut generic_map = def.generics.types.iter_enumerated()\n@@ -245,7 +245,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n-            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n+            if !actual_trait_ref.self_ty().references_error() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n@@ -260,7 +260,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         TraitNotObjectSafe(did) => {\n             span_err!(infcx.tcx.sess, obligation.cause.span, E0038,\n                 \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-                ty::item_path_str(infcx.tcx, did));\n+                infcx.tcx.item_path_str(did));\n \n             for violation in object_safety_violations(infcx.tcx, did) {\n                 match violation {\n@@ -325,8 +325,8 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let trait_ref = data.to_poly_trait_ref();\n             let self_ty = trait_ref.self_ty();\n             let all_types = &trait_ref.substs().types;\n-            if all_types.iter().any(|&t| ty::type_is_error(t)) {\n-            } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n+            if all_types.references_error() {\n+            } else if all_types.needs_infer() {\n                 // This is kind of a hack: it frequently happens that some earlier\n                 // error prevents types from being fully inferred, and then we get\n                 // a bunch of uninteresting errors saying something like \"<generic\n@@ -401,7 +401,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n-            let item_name = ty::item_path_str(tcx, item_def_id);\n+            let item_name = tcx.item_path_str(item_def_id);\n             tcx.sess.span_note(\n                 cause_span,\n                 &format!(\"required by `{}`\", item_name));\n@@ -442,8 +442,8 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n         ObligationCauseCode::ClosureCapture(var_id, closure_span, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-            let trait_name = ty::item_path_str(tcx, def_id);\n-            let name = ty::local_var_name_str(tcx, var_id);\n+            let trait_name = tcx.item_path_str(def_id);\n+            let name = tcx.local_var_name_str(var_id);\n             span_note!(tcx.sess, closure_span,\n                        \"the closure that captures `{}` requires that all captured variables \\\n                        implement the trait `{}`\","}, {"sha": "5e274dcec70e431b423b2209d93a135daee40c49", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::infer::InferCtxt;\n-use middle::ty::{self, RegionEscape, Ty};\n+use middle::ty::{self, RegionEscape, Ty, HasTypeFlags};\n \n use std::collections::HashSet;\n use std::fmt;\n@@ -421,7 +421,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             // regions.  If there are, we will call this obligation an\n             // error. Eventually we should be able to support some\n             // cases here, I imagine (e.g., `for<'a> int : 'a`).\n-            if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n+            if selcx.tcx().count_late_bound_regions(binder) != 0 {\n                 errors.push(\n                     FulfillmentError::new(\n                         obligation.clone(),"}, {"sha": "845ba62307fa57340b9ed4c995f085ced55306f1", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -17,7 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use middle::free_region::FreeRegionMap;\n use middle::subst;\n-use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty_fold::TypeFoldable;\n use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::rc::Rc;\n@@ -432,7 +432,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_param_env(value={:?})\", value);\n "}, {"sha": "e7f11b06bd132b1d7c82faac784d704cd149f34c", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -57,7 +57,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n-    let def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let def = tcx.lookup_trait_def(trait_def_id);\n \n     let result = def.object_safety().unwrap_or_else(|| {\n         let result = object_safety_violations(tcx, trait_def_id).is_empty();\n@@ -90,7 +90,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     // Check methods for violations.\n     let mut violations: Vec<_> =\n-        ty::trait_items(tcx, trait_def_id).iter()\n+        tcx.trait_items(trait_def_id).iter()\n         .flat_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n@@ -122,10 +122,10 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     trait_def_id: ast::DefId)\n                                     -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n     let trait_ref = trait_def.trait_ref.clone();\n     let trait_ref = trait_ref.to_poly_trait_ref();\n-    let predicates = ty::lookup_super_predicates(tcx, trait_def_id);\n+    let predicates = tcx.lookup_super_predicates(trait_def_id);\n     predicates\n         .predicates\n         .into_iter()\n@@ -153,8 +153,8 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    let trait_predicates = ty::lookup_predicates(tcx, trait_def_id);\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+    let trait_predicates = tcx.lookup_predicates(trait_def_id);\n     generics_require_sized_self(tcx, &trait_def.generics, &trait_predicates)\n }\n \n@@ -169,7 +169,7 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let free_substs = ty::construct_free_substs(tcx, generics, ast::DUMMY_NODE_ID);\n+    let free_substs = tcx.construct_free_substs(generics, ast::DUMMY_NODE_ID);\n     let predicates = predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n@@ -306,7 +306,7 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n     let mut error = false;\n-    ty::maybe_walk_ty(ty, |ty| {\n+    ty.maybe_walk(|ty| {\n         match ty.sty {\n             ty::TyParam(ref param_ty) => {\n                 if param_ty.space == SelfSpace {\n@@ -321,7 +321,7 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                 // Compute supertraits of current trait lazily.\n                 if supertraits.is_none() {\n-                    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                    let trait_def = tcx.lookup_trait_def(trait_def_id);\n                     let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n                     supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n                 }"}, {"sha": "184de682c67db20d71b849d30ea24fd9588dc139", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -23,8 +23,7 @@ use super::util;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{self, ToPredicate, ReferencesError, RegionEscape,\n-                 HasProjectionTypes, ToPolyTraitRef, Ty};\n+use middle::ty::{self, ToPredicate, RegionEscape, HasTypeFlags, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n@@ -195,7 +194,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n@@ -206,7 +205,7 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n                                           depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n@@ -238,7 +237,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n         }\n     }\n \n-    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes>(&mut self, value: &T) -> T {\n+    fn fold<T:TypeFoldable<'tcx> + HasTypeFlags>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n         if !value.has_projection_types() {\n@@ -374,7 +373,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n                    depth,\n                    obligations);\n \n-            if ty::type_has_projection(projected_ty) {\n+            if projected_ty.has_projection_types() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n@@ -525,9 +524,9 @@ fn project_type<'cx,'tcx>(\n             Ok(ProjectedTy::Progress(ty, obligations))\n         }\n         None => {\n-            Ok(ProjectedTy::NoProgress(ty::mk_projection(selcx.tcx(),\n-                                                         obligation.predicate.trait_ref.clone(),\n-                                                         obligation.predicate.item_name)))\n+            Ok(ProjectedTy::NoProgress(selcx.tcx().mk_projection(\n+                obligation.predicate.trait_ref.clone(),\n+                obligation.predicate.item_name)))\n         }\n     }\n }\n@@ -575,7 +574,7 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = ty::lookup_predicates(selcx.tcx(), trait_ref.def_id);\n+    let trait_predicates = selcx.tcx().lookup_predicates(trait_ref.def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n@@ -774,7 +773,7 @@ fn confirm_fn_pointer_candidate<'cx,'tcx>(\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     let fn_type = selcx.infcx().shallow_resolve(fn_type);\n-    let sig = ty::ty_fn_sig(fn_type);\n+    let sig = fn_type.fn_sig();\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n }\n \n@@ -893,7 +892,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n \n     // It is not in the impl - get the default from the trait.\n     let trait_ref = obligation.predicate.trait_ref;\n-    for trait_item in ty::trait_items(selcx.tcx(), trait_ref.def_id).iter() {\n+    for trait_item in selcx.tcx().trait_items(trait_ref.def_id).iter() {\n         if let &ty::TypeTraitItem(ref assoc_ty) = trait_item {\n             if assoc_ty.name == obligation.predicate.item_name {\n                 if let Some(ty) = assoc_ty.ty {"}, {"sha": "01faa6b7cf7b9a9d86238b725535b1f93a5f2791", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -38,7 +38,7 @@ use super::util;\n \n use middle::fast_reject;\n use middle::subst::{Subst, Substs, TypeSpace};\n-use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty, HasTypeFlags};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -540,7 +540,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let input_types = stack.fresh_trait_ref.0.input_types();\n-        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_fresh(t));\n+        let unbound_input_types = input_types.iter().any(|ty| ty.is_fresh());\n         if\n             unbound_input_types &&\n              (self.intercrate ||\n@@ -675,7 +675,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n-        if ty::type_is_error(stack.obligation.predicate.0.self_ty()) {\n+        if stack.obligation.predicate.0.self_ty().references_error() {\n             return Ok(Some(ErrorCandidate));\n         }\n \n@@ -773,7 +773,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match candidate {\n             ImplCandidate(def_id) => {\n-                match ty::trait_impl_polarity(self.tcx(), def_id) {\n+                match self.tcx().trait_impl_polarity(def_id) {\n                     Some(ast::ImplPolarity::Negative) => return Err(Unimplemented),\n                     _ => {}\n                 }\n@@ -886,7 +886,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match *candidate {\n             Ok(Some(_)) | Err(_) => true,\n             Ok(None) => {\n-                cache_fresh_trait_pred.0.input_types().iter().any(|&t| ty::type_has_ty_infer(t))\n+                cache_fresh_trait_pred.0.input_types().has_infer_types()\n             }\n         }\n     }\n@@ -1024,7 +1024,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 projection_trait_ref={:?}\",\n                projection_trait_ref);\n \n-        let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n+        let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n         let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 bounds={:?}\",\n@@ -1224,7 +1224,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n-        let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n+        let def = self.tcx().lookup_trait_def(obligation.predicate.def_id());\n \n         def.for_each_relevant_impl(\n             self.tcx(),\n@@ -1252,7 +1252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let def_id = obligation.predicate.def_id();\n \n-        if ty::trait_has_default_impl(self.tcx(), def_id) {\n+        if self.tcx().trait_has_default_impl(def_id) {\n             match self_ty.sty {\n                 ty::TyTrait(..) => {\n                     // For object types, we don't know what the closed\n@@ -1264,7 +1264,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // object types, because it just lets you reflect\n                     // onto the object type, not into the object's\n                     // interior.\n-                    if ty::has_attr(self.tcx(), def_id, \"rustc_reflect_like\") {\n+                    if self.tcx().has_attr(def_id, \"rustc_reflect_like\") {\n                         candidates.vec.push(DefaultImplObjectCandidate(def_id));\n                     }\n                 }\n@@ -1397,7 +1397,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let self_ty = match ty::no_late_bound_regions(self.tcx(), &obligation.self_ty()) {\n+        let self_ty = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n@@ -1736,15 +1736,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::TyStruct(def_id, substs) => {\n                 let types: Vec<Ty> =\n-                    ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                    self.tcx().struct_fields(def_id, substs).iter()\n                                                                  .map(|f| f.mt.ty)\n                                                                  .collect();\n                 nominal(bound, types)\n             }\n \n             ty::TyEnum(def_id, substs) => {\n                 let types: Vec<Ty> =\n-                    ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                    self.tcx().substd_enum_variants(def_id, substs)\n                     .iter()\n                     .flat_map(|variant| &variant.args)\n                     .cloned()\n@@ -1881,13 +1881,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::TyStruct(def_id, substs) => {\n-                Some(ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                Some(self.tcx().struct_fields(def_id, substs).iter()\n                      .map(|f| f.mt.ty)\n                      .collect())\n             }\n \n             ty::TyEnum(def_id, substs) => {\n-                Some(ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                Some(self.tcx().substd_enum_variants(def_id, substs)\n                      .iter()\n                      .flat_map(|variant| &variant.args)\n                      .map(|&ty| ty)\n@@ -2161,7 +2161,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation,\n                trait_def_id);\n \n-        assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n+        assert!(self.tcx().has_attr(trait_def_id, \"rustc_reflect_like\"));\n \n         // OK to skip binder, it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n@@ -2178,7 +2178,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // reintroduce the two binding levels we skipped, then flatten into one\n                 let all_types = ty::Binder(ty::Binder(all_types));\n-                let all_types = ty::flatten_late_bound_regions(self.tcx(), &all_types);\n+                let all_types = self.tcx().flatten_late_bound_regions(&all_types);\n \n                 self.vtable_default_impl(obligation, trait_def_id, all_types)\n             }\n@@ -2334,7 +2334,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = ty::ty_fn_sig(self_ty);\n+        let sig = self_ty.fn_sig();\n         let trait_ref =\n             util::closure_trait_ref_and_return_type(self.tcx(),\n                                                     obligation.predicate.def_id(),\n@@ -2434,7 +2434,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n-            ty::no_late_bound_regions(tcx, &obligation.self_ty()).unwrap());\n+            tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n         debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n@@ -2451,7 +2451,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     projection_bounds: data_a.bounds.projection_bounds.clone(),\n                 };\n \n-                let new_trait = ty::mk_trait(tcx, data_a.principal.clone(), bounds);\n+                let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n                     return Err(Unimplemented);\n@@ -2525,8 +2525,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // Struct<T> -> Struct<U>.\n             (&ty::TyStruct(def_id, substs_a), &ty::TyStruct(_, substs_b)) => {\n-                let fields = ty::lookup_struct_fields(tcx, def_id).iter().map(|f| {\n-                    ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n+                let fields = tcx.lookup_struct_fields(def_id).iter().map(|f| {\n+                    tcx.lookup_field_type_unsubstituted(def_id, f.id)\n                 }).collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n@@ -2536,15 +2536,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Err(Unimplemented);\n                 };\n                 let mut ty_params = vec![];\n-                ty::walk_ty(field, |ty| {\n+                for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n                         assert!(p.space == TypeSpace);\n                         let idx = p.idx as usize;\n                         if !ty_params.contains(&idx) {\n                             ty_params.push(idx);\n                         }\n                     }\n-                });\n+                }\n                 if ty_params.is_empty() {\n                     return Err(Unimplemented);\n                 }\n@@ -2558,7 +2558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n                 }\n                 for &ty in fields.init() {\n-                    if ty::type_is_error(ty.subst(tcx, &new_substs)) {\n+                    if ty.subst(tcx, &new_substs).references_error() {\n                         return Err(Unimplemented);\n                     }\n                 }\n@@ -2573,7 +2573,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let param_b = *substs_b.types.get(TypeSpace, i);\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n                 }\n-                let new_struct = ty::mk_struct(tcx, def_id, tcx.mk_substs(new_substs));\n+                let new_struct = tcx.mk_struct(def_id, tcx.mk_substs(new_substs));\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n                     return Err(Unimplemented);\n@@ -2628,7 +2628,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                   -> Result<(Normalized<'tcx, Substs<'tcx>>,\n                              infer::SkolemizationMap), ()>\n     {\n-        let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n+        let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n         // consider a \"quick reject\". This avoids creating more types\n@@ -2765,7 +2765,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                          impl_def_id);\n \n         // Find the self type for the impl.\n-        let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n+        let impl_self_ty = self.tcx().lookup_item_type(impl_def_id).ty;\n         let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n \n         debug!(\"match_impl_self_types(obligation_self_ty={:?}, impl_self_ty={:?})\",\n@@ -2890,7 +2890,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n \n-        let predicates = ty::lookup_predicates(self.tcx(), def_id);\n+        let predicates = self.tcx().lookup_predicates(def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n         let mut predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);"}, {"sha": "5c9a8d6c1aa3fb411be50c23fd2de96e05de13fd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -43,19 +43,19 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n         // regions before we throw things into the underlying set.\n         let normalized_pred = match *pred {\n             ty::Predicate::Trait(ref data) =>\n-                ty::Predicate::Trait(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::Trait(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::Equate(ref data) =>\n-                ty::Predicate::Equate(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::Equate(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::RegionOutlives(ref data) =>\n-                ty::Predicate::RegionOutlives(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::RegionOutlives(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::TypeOutlives(ref data) =>\n-                ty::Predicate::TypeOutlives(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::TypeOutlives(self.tcx.anonymize_late_bound_regions(data)),\n \n             ty::Predicate::Projection(ref data) =>\n-                ty::Predicate::Projection(ty::anonymize_late_bound_regions(self.tcx, data)),\n+                ty::Predicate::Projection(self.tcx.anonymize_late_bound_regions(data)),\n         };\n         self.set.insert(normalized_pred)\n     }\n@@ -116,7 +116,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = ty::lookup_super_predicates(self.tcx, data.def_id());\n+                let predicates = self.tcx.lookup_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n@@ -236,7 +236,7 @@ impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n             None => { return None; }\n         };\n \n-        let predicates = ty::lookup_super_predicates(self.tcx, def_id);\n+        let predicates = self.tcx.lookup_super_predicates(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates.predicates\n@@ -297,7 +297,7 @@ pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                           -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n-    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n@@ -416,7 +416,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             break;\n         }\n \n-        let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+        let trait_items = tcx.trait_items(bound_ref.def_id());\n         for trait_item in trait_items.iter() {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n@@ -427,7 +427,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // count number of methods preceding the one we are selecting and\n     // add them to the total offset; skip over associated types.\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    let trait_items = tcx.trait_items(trait_def_id);\n     for trait_item in trait_items.iter().take(method_offset_in_trait) {\n         match *trait_item {\n             ty::MethodTraitItem(_) => method_count += 1,\n@@ -456,14 +456,14 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n {\n     let arguments_tuple = match tuple_arguments {\n         TupleArgumentsFlag::No => sig.0.inputs[0],\n-        TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n+        TupleArgumentsFlag::Yes => tcx.mk_tup(sig.0.inputs.to_vec()),\n     };\n     let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n     let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs(trait_substs),\n     };\n-    ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n+    ty::Binder((trait_ref, sig.0.output.unwrap_or(tcx.mk_nil())))\n }\n \n impl<'tcx,O:fmt::Debug> fmt::Debug for super::Obligation<'tcx, O> {"}, {"sha": "302ec08db6f26751918c3bd0b7fa36712e850dcc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3115, "deletions": 3450, "changes": 6565, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227"}, {"sha": "012f5216ed7e3060d4584ad988b72583268cd5d1", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -36,7 +36,7 @@\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::traits;\n \n use std::fmt;\n@@ -641,7 +641,7 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             ty.sty.clone()\n         }\n     };\n-    ty::mk_t(this.tcx(), sty)\n+    this.tcx().mk_ty(sty)\n }\n \n pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n@@ -896,7 +896,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_escapes_depth(t, self.current_depth-1) {\n+        if !t.has_regions_escaping_depth(self.current_depth-1) {\n             return t;\n         }\n \n@@ -946,7 +946,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_has_erasable_regions(t) {\n+        if !t.has_erasable_regions() {\n             return t;\n         }\n "}, {"sha": "4e88e23377d0c56e6a969fcb0bd0c4a757f491a7", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -113,7 +113,7 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n \n     let variances;\n     let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = ty::item_variances(relation.tcx(), item_def_id);\n+        variances = relation.tcx().item_variances(item_def_id);\n         Some(&*variances)\n     } else {\n         None\n@@ -469,21 +469,21 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_id == b_id =>\n         {\n             let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_enum(a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n         {\n             let principal = try!(relation.relate(&a_.principal, &b_.principal));\n             let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n-            Ok(ty::mk_trait(tcx, principal, bounds))\n+            Ok(tcx.mk_trait(principal, bounds))\n         }\n \n         (&ty::TyStruct(a_id, a_substs), &ty::TyStruct(b_id, b_substs))\n             if a_id == b_id =>\n         {\n             let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_struct(a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyClosure(a_id, a_substs),\n@@ -494,33 +494,33 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_closure(a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n         {\n             let typ = try!(relation.relate(&a_inner, &b_inner));\n-            Ok(ty::mk_uniq(tcx, typ))\n+            Ok(tcx.mk_box(typ))\n         }\n \n         (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n         {\n             let mt = try!(relation.relate(a_mt, b_mt));\n-            Ok(ty::mk_ptr(tcx, mt))\n+            Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n         {\n             let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n             let mt = try!(relation.relate(a_mt, b_mt));\n-            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n+            Ok(tcx.mk_ref(tcx.mk_region(r), mt))\n         }\n \n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n         {\n             let t = try!(relation.relate(&a_t, &b_t));\n             if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+                Ok(tcx.mk_array(t, sz_a))\n             } else {\n                 Err(ty::terr_fixed_array_size(expected_found(relation, &sz_a, &sz_b)))\n             }\n@@ -529,7 +529,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n         (&ty::TySlice(a_t), &ty::TySlice(b_t)) =>\n         {\n             let t = try!(relation.relate(&a_t, &b_t));\n-            Ok(ty::mk_vec(tcx, t, None))\n+            Ok(tcx.mk_slice(t))\n         }\n \n         (&ty::TyTuple(ref as_), &ty::TyTuple(ref bs)) =>\n@@ -538,7 +538,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n                 let ts = try!(as_.iter().zip(bs)\n                                  .map(|(a, b)| relation.relate(a, b))\n                                  .collect::<Result<_, _>>());\n-                Ok(ty::mk_tup(tcx, ts))\n+                Ok(tcx.mk_tup(ts))\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(ty::terr_tuple_size(\n                     expected_found(relation, &as_.len(), &bs.len())))\n@@ -551,13 +551,13 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_opt_def_id == b_opt_def_id =>\n         {\n             let fty = try!(relation.relate(a_fty, b_fty));\n-            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n+            Ok(tcx.mk_fn(a_opt_def_id, tcx.mk_bare_fn(fty)))\n         }\n \n         (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n         {\n             let projection_ty = try!(relation.relate(a_data, b_data));\n-            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+            Ok(tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name))\n         }\n \n         _ =>"}, {"sha": "dcdf457965efa054a9ca5df60cdd02ee3301f81f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -14,13 +14,12 @@ use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n-use middle::ty::{mt, Ty};\n use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use middle::ty::TyClosure;\n use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n-use middle::ty;\n+use middle::ty::{self, mt, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFoldable};\n \n use std::fmt;\n@@ -52,7 +51,7 @@ fn fn_sig(f: &mut fmt::Formatter,\n \n     match output {\n         ty::FnConverging(ty) => {\n-            if !ty::type_is_nil(ty) {\n+            if !ty.is_nil() {\n                 try!(write!(f, \" -> {}\", ty));\n             }\n             Ok(())\n@@ -72,7 +71,7 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n     where GG: for<'tcx> FnOnce(&ty::ctxt<'tcx>) -> ty::Generics<'tcx>\n {\n     let (fn_trait_kind, verbose) = try!(ty::tls::with(|tcx| {\n-        try!(write!(f, \"{}\", ty::item_path_str(tcx, did)));\n+        try!(write!(f, \"{}\", tcx.item_path_str(did)));\n         Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose()))\n     }));\n \n@@ -155,7 +154,7 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n             ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n                 match def.default {\n                     Some(default) => {\n-                        if !has_self && ty::type_has_self(default) {\n+                        if !has_self && default.has_self_ty() {\n                             // In an object type, there is no `Self`, and\n                             // thus if the default value references Self,\n                             // the user will be required to give an\n@@ -266,7 +265,7 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n                       projection_bounds,\n-                      |tcx| ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n+                      |tcx| tcx.lookup_trait_def(trait_ref.def_id).generics.clone())\n     }\n }\n \n@@ -617,7 +616,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         parameterized(f, self.substs, self.def_id, &[],\n-                      |tcx| ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n+                      |tcx| tcx.lookup_trait_def(self.def_id).generics.clone())\n     }\n }\n \n@@ -672,7 +671,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n \n                 if let Some(def_id) = opt_def_id {\n                     try!(write!(f, \" {{{}}}\", ty::tls::with(|tcx| {\n-                        ty::item_path_str(tcx, def_id)\n+                        tcx.item_path_str(def_id)\n                     })));\n                 }\n                 Ok(())\n@@ -682,7 +681,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n             TyEnum(did, substs) | TyStruct(did, substs) => {\n                 parameterized(f, substs, did, &[],\n-                              |tcx| ty::lookup_item_type(tcx, did).generics)\n+                              |tcx| tcx.lookup_item_type(did).generics)\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n@@ -721,7 +720,7 @@ impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"UpvarId({};`{}`;{})\",\n                self.var_id,\n-               ty::tls::with(|tcx| ty::local_var_name_str(tcx, self.var_id)),\n+               ty::tls::with(|tcx| tcx.local_var_name_str(self.var_id)),\n                self.closure_expr_id)\n     }\n }"}, {"sha": "9d4fb4c994d404bd18fa2046567282aa8b7f8dcc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -752,7 +752,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n                     ty::TyStruct(def_id, _) | ty::TyEnum(def_id, _) => {\n-                        if ty::has_dtor(self.tcx(), def_id) {\n+                        if self.tcx().has_dtor(def_id) {\n                             // In the case where the owner implements drop, then\n                             // the path must be initialized to prevent a case of\n                             // partial reinitialization"}, {"sha": "9bd4da28c99fbd2d839b5ba3b3c14985ce708f00", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -353,7 +353,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         (&ty::TyStruct(def_id, ref _substs), None) => {\n-            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            let fields = tcx.lookup_struct_fields(def_id);\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n                     for f in &fields {\n@@ -378,7 +378,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n \n         (&ty::TyEnum(enum_def_id, substs), ref enum_variant_info) => {\n             let variant_info = {\n-                let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);\n+                let mut variants = tcx.substd_enum_variants(enum_def_id, substs);\n                 match *enum_variant_info {\n                     Some((variant_def_id, ref _lp2)) =>\n                         variants.iter()\n@@ -442,9 +442,9 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n     let loan_path_elem = LpInterior(InteriorField(new_field_name));\n     let new_lp_type = match new_field_name {\n         mc::NamedField(ast_name) =>\n-            ty::named_element_ty(tcx, parent.to_type(), ast_name, opt_variant_did),\n+            tcx.named_element_ty(parent.to_type(), ast_name, opt_variant_did),\n         mc::PositionalField(idx) =>\n-            ty::positional_element_ty(tcx, parent.to_type(), idx, opt_variant_did),\n+            tcx.positional_element_ty(parent.to_type(), idx, opt_variant_did),\n     };\n     let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n     let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());"}, {"sha": "2b33dde2cbe2daa18f1e5c4e67beb1e7614cd5bb", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -35,7 +35,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              decl_id: ast::NodeId,\n                              _decl_span: Span,\n                              var_id: ast::NodeId) {\n-    let ty = ty::node_id_to_type(bccx.tcx, var_id);\n+    let ty = bccx.tcx.node_id_to_type(var_id);\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n@@ -180,7 +180,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::TyStruct(did, _) | ty::TyEnum(did, _) => {\n-                    if ty::has_dtor(bccx.tcx, did) {\n+                    if bccx.tcx.has_dtor(did) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "44a4a0d250402ec8c2493b15f374eef1d8275c09", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -490,7 +490,7 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let param_env = ty::empty_parameter_environment(self.bccx.tcx);\n+            let param_env = self.bccx.tcx.empty_parameter_environment();\n             let mc = mc::MemCategorizationContext::new(&param_env);\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);"}, {"sha": "5baabebea116b57b5e080ed16bccaa3dbf7e7044", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -137,7 +137,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyStruct(did, _) |\n-                ty::TyEnum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n+                ty::TyEnum(did, _) if bccx.tcx.has_dtor(did) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\"}, {"sha": "4f726044a1bac866f385396a1608beec40076175", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -29,8 +29,8 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::infer::error_reporting::note_and_explain_region;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Typer;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n \n@@ -662,7 +662,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                      .map\n                                                      .find(the_move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n+                        (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             move_data::MovePat => {\n-                let pat_ty = ty::node_id_to_type(self.tcx, the_move.id);\n+                let pat_ty = self.tcx.node_id_to_type(the_move.id);\n                 let span = self.tcx.map.span(the_move.id);\n                 self.tcx.sess.span_note(span,\n                     &format!(\"`{}` moved here{} because it has type `{}`, \\\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                      .map\n                                                      .find(the_move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n+                        (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n@@ -747,7 +747,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                     -> (&'static str, &'static str) {\n             match ty.sty {\n                 _ => {\n-                    if ty::type_moves_by_default(param_env, span, ty) {\n+                    if param_env.type_moves_by_default(ty, span) {\n                         (\"non-copyable\",\n                          \"perhaps you meant to use `clone()`?\")\n                     } else {\n@@ -997,13 +997,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             err_out_of_scope(super_scope, sub_scope) => {\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"reference must be valid for \",\n                     sub_scope,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n@@ -1020,14 +1018,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     None => self.cmt_to_string(&*err.cmt),\n                 };\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n                     \"\");\n@@ -1041,14 +1037,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n-                out.push_str(&ty::local_var_name_str(self.tcx, id));\n+                out.push_str(&self.tcx.local_var_name_str(id));\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n+                out.push_str(&self.tcx.item_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1094,7 +1090,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n+                out.push_str(&self.tcx.item_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1184,7 +1180,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n+                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };\n@@ -1216,7 +1212,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n+                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };"}, {"sha": "1ad3f53c328d90b2c24661b86308f4f8972c0b5b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -648,16 +648,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n-    ty::with_ctxt(sess,\n-                  arenas,\n-                  def_map,\n-                  named_region_map,\n-                  ast_map,\n-                  freevars,\n-                  region_map,\n-                  lang_items,\n-                  stability::Index::new(krate),\n-                  |tcx| {\n+    ty::ctxt::create_and_enter(sess,\n+                               arenas,\n+                               def_map,\n+                               named_region_map,\n+                               ast_map,\n+                               freevars,\n+                               region_map,\n+                               lang_items,\n+                               stability::Index::new(krate),\n+                               |tcx| {\n \n         // passes are timed inside typeck\n         typeck::check_crate(tcx, trait_map);"}, {"sha": "610f3f3a75ee64b40e6c7ffc7211c42aeca6e41b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              &ty::expr_ty(self.tcx, expr).to_string()));\n+                              &self.tcx.expr_ty(expr).to_string()));\n                 s.pclose()\n             }\n             _ => Ok(())"}, {"sha": "5ec6e293684ccf20ca804a6c3fd3aa0d5b0f9ee5", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 48, "deletions": 54, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -22,7 +22,7 @@ use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n-use rustc_typeck::middle::ty::{self, Ty};\n+use rustc_typeck::middle::ty::{self, Ty, RegionEscape};\n use rustc_typeck::middle::ty_relate::TypeRelation;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n@@ -130,16 +130,16 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    ty::with_ctxt(sess,\n-                  &arenas,\n-                  def_map,\n-                  named_region_map,\n-                  ast_map,\n-                  freevars,\n-                  region_map,\n-                  lang_items,\n-                  stability::Index::new(krate),\n-                  |tcx| {\n+    ty::ctxt::create_and_enter(sess,\n+                               &arenas,\n+                               def_map,\n+                               named_region_map,\n+                               ast_map,\n+                               freevars,\n+                               region_map,\n+                               lang_items,\n+                               stability::Index::new(krate),\n+                               |tcx| {\n         let infcx = infer::new_infer_ctxt(tcx);\n         body(Env { infcx: &infcx });\n         let free_regions = FreeRegionMap::new();\n@@ -256,30 +256,29 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 -> Ty<'tcx>\n     {\n         let input_args = input_tys.iter().cloned().collect();\n-        ty::mk_bare_fn(self.infcx.tcx,\n-                       None,\n-                       self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n-                           unsafety: ast::Unsafety::Normal,\n-                           abi: abi::Rust,\n-                           sig: ty::Binder(ty::FnSig {\n-                               inputs: input_args,\n-                               output: ty::FnConverging(output_ty),\n-                               variadic: false\n-                           })\n-                       }))\n+        self.infcx.tcx.mk_fn(None,\n+            self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n+                unsafety: ast::Unsafety::Normal,\n+                abi: abi::Rust,\n+                sig: ty::Binder(ty::FnSig {\n+                    inputs: input_args,\n+                    output: ty::FnConverging(output_ty),\n+                    variadic: false\n+                })\n+            }))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n-        ty::mk_nil(self.infcx.tcx)\n+        self.infcx.tcx.mk_nil()\n     }\n \n     pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n-        ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n+        self.infcx.tcx.mk_tup(vec![ty1, ty2])\n     }\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(space, index, token::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self,\n@@ -302,32 +301,29 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n                                            id: u32,\n                                            debruijn: ty::DebruijnIndex)\n                                            -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(CodeExtent::from_node_id(id));\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n@@ -337,15 +333,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(ty::ReStatic),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReStatic),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n@@ -745,22 +739,22 @@ fn escaping() {\n         // Situation:\n         // Theta = [A -> &'a foo]\n \n-        assert!(!ty::type_has_escaping_regions(env.t_nil()));\n+        assert!(!env.t_nil().has_escaping_regions());\n \n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        assert!(!ty::type_has_escaping_regions(t_rptr_free1));\n+        assert!(!t_rptr_free1.has_escaping_regions());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n-        assert!(ty::type_has_escaping_regions(t_rptr_bound1));\n+        assert!(t_rptr_bound1.has_escaping_regions());\n \n         let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n-        assert!(ty::type_has_escaping_regions(t_rptr_bound2));\n+        assert!(t_rptr_bound2.has_escaping_regions());\n \n         // t_fn = fn(A)\n         let t_param = env.t_param(subst::TypeSpace, 0);\n-        assert!(!ty::type_has_escaping_regions(t_param));\n+        assert!(!t_param.has_escaping_regions());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n-        assert!(!ty::type_has_escaping_regions(t_fn));\n+        assert!(!t_fn.has_escaping_regions());\n     })\n }\n \n@@ -804,9 +798,9 @@ fn walk_ty() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n-        let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n-        let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n+        let tup1_ty = tcx.mk_tup(vec!(int_ty, uint_ty, int_ty, uint_ty));\n+        let tup2_ty = tcx.mk_tup(vec!(tup1_ty, tup1_ty, uint_ty));\n+        let uniq_ty = tcx.mk_box(tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n         assert_eq!(walked, [uniq_ty,\n                             tup2_ty,\n@@ -822,9 +816,9 @@ fn walk_ty_skip_subtree() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n-        let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n-        let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n+        let tup1_ty = tcx.mk_tup(vec!(int_ty, uint_ty, int_ty, uint_ty));\n+        let tup2_ty = tcx.mk_tup(vec!(tup1_ty, tup1_ty, uint_ty));\n+        let uniq_ty = tcx.mk_box(tup2_ty);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree."}, {"sha": "8fe07da157970dd04a9d2000e8e04ea6e6825b8d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -30,6 +30,7 @@\n \n use metadata::{csearch, decoder};\n use middle::def::*;\n+use middle::mem_categorization::Typer;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n@@ -142,7 +143,7 @@ impl LintPass for TypeLimits {\n                         }\n                     },\n                     _ => {\n-                        let t = ty::expr_ty(cx.tcx, &**expr);\n+                        let t = cx.tcx.expr_ty(&**expr);\n                         match t.sty {\n                             ty::TyUint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATION, e.span,\n@@ -168,7 +169,7 @@ impl LintPass for TypeLimits {\n                 }\n \n                 if is_shift_binop(binop.node) {\n-                    let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n+                    let opt_ty_bits = match cx.tcx.expr_ty(&**l).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None\n@@ -193,7 +194,7 @@ impl LintPass for TypeLimits {\n                 }\n             },\n             ast::ExprLit(ref lit) => {\n-                match ty::expr_ty(cx.tcx, e).sty {\n+                match cx.tcx.expr_ty(e).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n@@ -343,7 +344,7 @@ impl LintPass for TypeLimits {\n             } else {\n                 binop\n             };\n-            match ty::expr_ty(tcx, expr).sty {\n+            match tcx.expr_ty(expr).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -412,7 +413,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n \n-                if !ty::is_ffi_safe(self.cx.tcx, tty) {\n+                if !tty.is_ffi_safe(self.cx.tcx) {\n                     self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                       \"found type without foreign-function-safe \\\n                                        representation annotation in foreign module, consider \\\n@@ -482,20 +483,11 @@ pub struct BoxPointers;\n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n-        let mut n_uniq: usize = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match t.sty {\n-                ty::TyBox(_) => {\n-                    n_uniq += 1;\n-                }\n-                _ => ()\n-            };\n-            t\n-        });\n-\n-        if n_uniq > 0 {\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n-            cx.span_lint(BOX_POINTERS, span, &m[..]);\n+        for leaf_ty in ty.walk() {\n+            if let ty::TyBox(_) = leaf_ty.sty {\n+                let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n+                cx.span_lint(BOX_POINTERS, span, &m);\n+            }\n         }\n     }\n }\n@@ -512,7 +504,7 @@ impl LintPass for BoxPointers {\n             ast::ItemEnum(..) |\n             ast::ItemStruct(..) =>\n                 self.check_heap_type(cx, it.span,\n-                                     ty::node_id_to_type(cx.tcx, it.id)),\n+                                     cx.tcx.node_id_to_type(it.id)),\n             _ => ()\n         }\n \n@@ -521,15 +513,15 @@ impl LintPass for BoxPointers {\n             ast::ItemStruct(ref struct_def, _) => {\n                 for struct_field in &struct_def.fields {\n                     self.check_heap_type(cx, struct_field.span,\n-                                         ty::node_id_to_type(cx.tcx, struct_field.node.id));\n+                                         cx.tcx.node_id_to_type(struct_field.node.id));\n                 }\n             }\n             _ => ()\n         }\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let ty = ty::expr_ty(cx.tcx, e);\n+        let ty = cx.tcx.expr_ty(e);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -582,13 +574,13 @@ impl LintPass for RawPointerDerive {\n             ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n                 // Deriving the Copy trait does not cause a warning\n                 if let &Some(ref trait_ref) = t_ref_opt {\n-                    let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                    let def_id = cx.tcx.trait_ref_to_def_id(trait_ref);\n                     if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n                         return;\n                     }\n                 }\n \n-                match ty::node_id_to_type(cx.tcx, item.id).sty {\n+                match cx.tcx.node_id_to_type(item.id).sty {\n                     ty::TyEnum(did, _) => did,\n                     ty::TyStruct(did, _) => did,\n                     _ => return,\n@@ -732,7 +724,7 @@ impl LintPass for UnusedResults {\n             return;\n         }\n \n-        let t = ty::expr_ty(cx.tcx, expr);\n+        let t = cx.tcx.expr_ty(expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyBool => return,\n@@ -877,7 +869,7 @@ fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n         Some(item) => match item.container() {\n             ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n             ty::ImplContainer(cid) => {\n-                match ty::impl_trait_ref(cx.tcx, cid) {\n+                match cx.tcx.impl_trait_ref(cid) {\n                     Some(_) => MethodContext::TraitImpl,\n                     None => MethodContext::PlainImpl\n                 }\n@@ -1601,7 +1593,7 @@ impl LintPass for MissingDoc {\n             ast::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n                 match cx.tcx.map.find(real_trait.node) {\n                     Some(ast_map::NodeItem(item)) => if item.vis == ast::Visibility::Inherited {\n                         for itm in impl_items {\n@@ -1699,23 +1691,23 @@ impl LintPass for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_struct(cx.tcx, local_def(item.id),\n-                              cx.tcx.mk_substs(Substs::empty()))\n+                cx.tcx.mk_struct(local_def(item.id),\n+                                 cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_enum(cx.tcx, local_def(item.id),\n-                            cx.tcx.mk_substs(Substs::empty()))\n+                cx.tcx.mk_enum(local_def(item.id),\n+                               cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n         };\n-        let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n-        if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n+        let parameter_environment = cx.tcx.empty_parameter_environment();\n+        if !parameter_environment.type_moves_by_default(ty, item.span) {\n             return;\n         }\n-        if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n+        if parameter_environment.can_type_implement_copy(ty, item.span).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\\n@@ -1763,11 +1755,11 @@ impl LintPass for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let debug_def = ty::lookup_trait_def(cx.tcx, debug);\n+            let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if d.krate == ast::LOCAL_CRATE {\n-                    if let Some(ty_def) = ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)) {\n+                    if let Some(ty_def) = cx.tcx.node_id_to_type(d.node).ty_to_def_id() {\n                         impls.insert(ty_def.node);\n                     }\n                 }\n@@ -1878,7 +1870,7 @@ impl LintPass for UnconditionalRecursion {\n             visit::FkFnBlock => return\n         };\n \n-        let impl_def_id = ty::impl_of_method(cx.tcx, local_def(id))\n+        let impl_def_id = cx.tcx.impl_of_method(local_def(id))\n             .unwrap_or(local_def(ast::DUMMY_NODE_ID));\n         assert!(ast_util::is_local(impl_def_id));\n         let impl_node_id = impl_def_id.node;\n@@ -2010,7 +2002,7 @@ impl LintPass for UnconditionalRecursion {\n                     // method instead.\n                     ty::MethodTypeParam(\n                         ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n-                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n+                        tcx.trait_item(trait_ref.def_id, method_num).def_id()\n                     }\n \n                     // The `impl` is known, so we check that with a\n@@ -2175,11 +2167,11 @@ impl LintPass for MutableTransmutes {\n                 ast::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let DefFn(did, _) = ty::resolve_expr(cx.tcx, expr) {\n+            if let DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = ty::node_id_to_type(cx.tcx, expr.id);\n+                let typ = cx.tcx.node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyBareFn(_, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         if let ty::FnConverging(to) = bare_fn.sig.0.output {\n@@ -2194,11 +2186,11 @@ impl LintPass for MutableTransmutes {\n         }\n \n         fn def_id_is_transmute(cx: &Context, def_id: DefId) -> bool {\n-            match ty::lookup_item_type(cx.tcx, def_id).ty.sty {\n+            match cx.tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyBareFn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n             }\n-            ty::with_path(cx.tcx, def_id, |path| match path.last() {\n+            cx.tcx.with_path(def_id, |path| match path.last() {\n                 Some(ref last) => last.name().as_str() == \"transmute\",\n                 _ => false\n             })\n@@ -2251,7 +2243,7 @@ impl LintPass for DropWithReprExtern {\n             let (drop_impl_did, dtor_self_type) =\n                 if dtor_did.krate == ast::LOCAL_CRATE {\n                     let impl_did = ctx.tcx.map.get_parent_did(dtor_did.node);\n-                    let ty = ty::lookup_item_type(ctx.tcx, impl_did).ty;\n+                    let ty = ctx.tcx.lookup_item_type(impl_did).ty;\n                     (impl_did, ty)\n                 } else {\n                     continue;\n@@ -2261,9 +2253,9 @@ impl LintPass for DropWithReprExtern {\n                 ty::TyEnum(self_type_did, _) |\n                 ty::TyStruct(self_type_did, _) |\n                 ty::TyClosure(self_type_did, _) => {\n-                    let hints = ty::lookup_repr_hints(ctx.tcx, self_type_did);\n+                    let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n-                        ty::ty_dtor(ctx.tcx, self_type_did).has_drop_flag() {\n+                        ctx.tcx.ty_dtor(self_type_did).has_drop_flag() {\n                         let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n                                                                      codemap::DUMMY_SP);\n                         let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,"}, {"sha": "24803562fa3734fffef5be24fa77caf5d2b4ad42", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                     _ => true,\n                 };\n-                let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n+                let tr = self.tcx.impl_trait_ref(local_def(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n                     !is_local(tr.def_id) ||\n                      self.exported_items.contains(&tr.def_id.node)\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n+                            match self.tcx.impl_trait_ref(id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n+                            match self.tcx.impl_trait_ref(id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n@@ -476,7 +476,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n+                            match self.tcx.impl_trait_ref(id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n@@ -537,7 +537,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n-                            match ty::impl_trait_ref(self.tcx, imp) {\n+                            match self.tcx.impl_trait_ref(imp) {\n                                 Some(..) => return Allowable,\n                                 _ if ii.vis == ast::Public => {\n                                     return Allowable\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                    span: Span,\n                    id: ast::DefId,\n                    name: FieldName) {\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let fields = self.tcx.lookup_struct_fields(id);\n         let field = match name {\n             NamedField(f_name) => {\n                 debug!(\"privacy - check named field {} in struct {:?}\", f_name, id);\n@@ -709,10 +709,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             return\n         }\n \n-        let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n+        let struct_type = self.tcx.lookup_item_type(id).ty;\n         let struct_desc = match struct_type.sty {\n             ty::TyStruct(_, _) =>\n-                format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n+                format!(\"struct `{}`\", self.tcx.item_path_str(id)),\n             // struct variant fields have inherited visibility\n             ty::TyEnum(..) => return,\n             _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                            name: ast::Name) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n-        let method_id = match ty::impl_or_trait_item(self.tcx, method_id) {\n+        let method_id = match self.tcx.impl_or_trait_item(method_id) {\n             ty::MethodTraitItem(method_type) => {\n                 method_type.provided_source.unwrap_or(method_id)\n             }\n@@ -893,12 +893,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n-                if let ty::TyStruct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span, id, NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span, id, UnnamedField(idx.node));\n                 }\n             }\n@@ -917,12 +917,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n-                match ty::expr_ty(self.tcx, expr).sty {\n+                match self.tcx.expr_ty(expr).sty {\n                     ty::TyStruct(ctor_id, _) => {\n                         // RFC 736: ensure all unmentioned fields are visible.\n                         // Rather than computing the set of unmentioned fields\n                         // (i.e. `all_fields - fields`), just check them all.\n-                        let all_fields = ty::lookup_struct_fields(self.tcx, ctor_id);\n+                        let all_fields = self.tcx.lookup_struct_fields(ctor_id);\n                         for field in all_fields {\n                             self.check_field(expr.span, ctor_id,\n                                              NamedField(field.name));\n@@ -950,7 +950,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprPath(..) => {\n                 let guard = |did: ast::DefId| {\n-                    let fields = ty::lookup_struct_fields(self.tcx, did);\n+                    let fields = self.tcx.lookup_struct_fields(did);\n                     let any_priv = fields.iter().any(|f| {\n                         f.vis != ast::Public && (\n                             !is_local(f.id) ||\n@@ -994,7 +994,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                match ty::pat_ty(self.tcx, pattern).sty {\n+                match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(id, _) => {\n                         for field in fields {\n                             self.check_field(pattern.span, id,\n@@ -1025,7 +1025,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n-                match ty::pat_ty(self.tcx, pattern).sty {\n+                match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(id, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             if let ast::PatWild(..) = field.node {\n@@ -1337,7 +1337,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = ty::trait_ref_to_def_id(self.tcx, tr);\n+                        let did = self.tcx.trait_ref_to_def_id(tr);\n \n                         !is_local(did) || self.trait_is_public(did.node)\n                     });"}, {"sha": "5ddad0e1947e83eda92f508ace6a8398ebdd6424", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -311,7 +311,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match ty::impl_of_method(self.tcx, ast_util::local_def(id)) {\n+        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n             Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -320,11 +320,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&ty_to_string(&**ty));\n \n-                            match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n+                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        &ty::item_path_str(self.tcx, def_id));\n+                                        &self.tcx.item_path_str(def_id));\n                                 },\n                                 None => {}\n                             }\n@@ -344,12 +344,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                  impl_id.node, id, self.tcx.map.get(impl_id.node)));\n                 },\n             },\n-            None => match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n+            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n                     match self.tcx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            format!(\"::{}\", ty::item_path_str(self.tcx, def_id))\n+                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n                         }\n                         _ => {\n                             self.sess.span_bug(span,\n@@ -368,7 +368,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n \n         // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_item_of_item(self.tcx, ast_util::local_def(id))\n+        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n             .and_then(|new_id| {\n                 let def_id = new_id.def_id();\n                 if def_id.node != 0 && def_id != ast_util::local_def(id) {\n@@ -776,10 +776,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefMethod(declid, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = ty::impl_or_trait_item(self.tcx, declid);\n+                    let ti = self.tcx.impl_or_trait_item(declid);\n                     match provenence {\n                         def::FromTrait(def_id) => {\n-                            Some(ty::trait_items(self.tcx, def_id)\n+                            Some(self.tcx.trait_items(def_id)\n                                     .iter()\n                                     .find(|mr| {\n                                         mr.name() == ti.name()\n@@ -793,10 +793,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                            .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n-                                                ty::impl_or_trait_item(\n-                                                    self.tcx,\n-                                                    mr.def_id()\n-                                                ).name() == ti.name()\n+                                                self.tcx.impl_or_trait_item(mr.def_id()).name()\n+                                                    == ti.name()\n                                             })\n                                            .unwrap()\n                                            .def_id())\n@@ -826,7 +824,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // modules or types in the path prefix\n         match def {\n             def::DefMethod(did, _) => {\n-                let ti = ty::impl_or_trait_item(self.tcx, did);\n+                let ti = self.tcx.impl_or_trait_item(did);\n                 if let ty::MethodTraitItem(m) = ti {\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {\n                         self.write_sub_path_trait_truncated(path);\n@@ -895,14 +893,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             ty::MethodStaticClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id =\n-                    match ty::trait_item_of_item(self.tcx, def_id) {\n+                    match self.tcx.trait_item_of_item(def_id) {\n                         None => None,\n                         Some(decl_id) => Some(decl_id.def_id()),\n                     };\n \n                 // This incantation is required if the method referenced is a\n                 // trait's default implementation.\n-                let def_id = match ty::impl_or_trait_item(self.tcx, def_id) {\n+                let def_id = match self.tcx.impl_or_trait_item(def_id) {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n@@ -915,16 +913,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             }\n             ty::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n-                let trait_item = ty::trait_item(self.tcx,\n-                                                mp.trait_ref.def_id,\n-                                                mp.method_num);\n+                let trait_item = self.tcx.trait_item(mp.trait_ref.def_id,\n+                                                     mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n             ty::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n-                let trait_item = ty::trait_item(self.tcx,\n-                                                mo.trait_ref.def_id,\n-                                                mo.method_num);\n+                let trait_item = self.tcx.trait_item(mo.trait_ref.def_id,\n+                                                     mo.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n         };\n@@ -953,7 +949,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n-                        match ty::ty_to_def_id(ty::node_id_to_type(self.tcx, p.id)) {\n+                        match self.tcx.node_id_to_type(p.id).ty_to_def_id() {\n                             None => {\n                                 self.sess.span_bug(p.span,\n                                                    &format!(\"Could not find struct_def for `{}`\",\n@@ -965,7 +961,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 };\n \n                 if let Some(struct_def) = struct_def {\n-                    let struct_fields = ty::lookup_struct_fields(self.tcx, struct_def);\n+                    let struct_fields = self.tcx.lookup_struct_fields(struct_def);\n                     for &Spanned { node: ref field, span } in fields {\n                         let sub_span = self.span.span_for_first_ident(span);\n                         for f in &struct_fields {\n@@ -1252,10 +1248,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let ty = &ty::expr_ty_adjusted(self.tcx, &**sub_ex).sty;\n+                let ty = &self.tcx.expr_ty_adjusted(&**sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n+                        let fields = self.tcx.lookup_struct_fields(def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n                                 let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);"}, {"sha": "27805b9d8330b90066a29234a60cd9ba521bc5ef", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -327,10 +327,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n-                let ty = &ty::expr_ty_adjusted(self.tcx, &sub_ex).sty;\n+                let ty = &self.tcx.expr_ty_adjusted(&sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n+                        let fields = self.tcx.lookup_struct_fields(def_id);\n                         for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -354,7 +354,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(ref path, _, _) => {\n-                let ty = &ty::expr_ty_adjusted(&self.tcx, expr).sty;\n+                let ty = &self.tcx.expr_ty_adjusted(expr).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n@@ -384,7 +384,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               struct_id: DefId,\n                               parent: NodeId)\n                               -> VariableRefData {\n-        let fields = ty::lookup_struct_fields(&self.tcx, struct_id);\n+        let fields = self.tcx.lookup_struct_fields(struct_id);\n         let field_name = get_ident(field_ref.ident.node).to_string();\n         for f in &fields {\n             if f.name == field_ref.ident.node.name {"}, {"sha": "47c2a5e579d941556252aca22000b49cff86c105", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -197,6 +197,7 @@ use middle::def::{self, DefMap};\n use middle::expr_use_visitor as euv;\n use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Typer;\n use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n@@ -235,7 +236,7 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n         match const_eval::compare_lit_exprs(tcx, self.0, other.0, None,\n-                                            |id| {ty::node_id_item_substs(tcx, id).substs}) {\n+                                            |id| {tcx.node_id_item_substs(id).substs}) {\n             Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }\n@@ -279,7 +280,7 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         let ccx = bcx.ccx();\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n-                let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n+                let lit_ty = bcx.tcx().node_id_to_type(lit_expr.id);\n                 let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n@@ -562,7 +563,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n             check_match::Constructor::Variant(def_id)\n     };\n \n-    let param_env = ty::empty_parameter_environment(bcx.tcx());\n+    let param_env = bcx.tcx().empty_parameter_environment();\n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n         param_env: param_env,\n@@ -603,7 +604,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n-                        let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n+                        let variant = tcx.enum_variant_with_id(enum_id, var_id);\n                         Variant(variant.disr_val,\n                                 adt::represent_node(bcx, cur.id),\n                                 var_id,\n@@ -662,16 +663,20 @@ fn bind_subslice_pat(bcx: Block,\n                      offset_right: usize) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty));\n+    let vec_ty_contents = match vec_ty.sty {\n+        ty::TyBox(ty) => ty,\n+        ty::TyRef(_, mt) | ty::TyRawPtr(mt) => mt.ty,\n+        _ => vec_ty\n+    };\n+    let unit_ty = vec_ty_contents.sequence_element_type(bcx.tcx());\n     let vec_datum = match_datum(val, vec_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n \n     let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n     let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n-    let slice_ty = ty::mk_slice(bcx.tcx(),\n-                                bcx.tcx().mk_region(ty::ReStatic),\n-                                ty::mt {ty: unit_ty, mutbl: ast::MutImmutable});\n+    let slice_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReStatic),\n+                                         bcx.tcx().mk_slice(unit_ty));\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n           GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n@@ -836,7 +841,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n-    if ty::type_is_scalar(rhs_t) {\n+    if rhs_t.is_scalar() {\n         let cmp = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n         return Result::new(cx, cmp);\n     }\n@@ -849,9 +854,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                     // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n                     let pat_len = val_ty(rhs).element_type().array_length();\n-                    let ty_str_slice = ty::mk_str_slice(cx.tcx(),\n-                                                        cx.tcx().mk_region(ty::ReStatic),\n-                                                        ast::MutImmutable);\n+                    let ty_str_slice = cx.tcx().mk_static_str();\n \n                     let rhs_str = alloc_ty(cx, ty_str_slice, \"rhs_str\");\n                     Store(cx, GEPi(cx, rhs, &[0, 0]), expr::get_dataptr(cx, rhs_str));\n@@ -1058,14 +1061,14 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                          .unwrap_or(DUMMY_NODE_ID);\n \n     let left_ty = if pat_id == DUMMY_NODE_ID {\n-        ty::mk_nil(tcx)\n+        tcx.mk_nil()\n     } else {\n         node_id_type(bcx, pat_id)\n     };\n \n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n-        param_env: ty::empty_parameter_environment(bcx.tcx()),\n+        param_env: bcx.tcx().empty_parameter_environment(),\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n@@ -1088,9 +1091,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // The last field is technically unsized but\n                 // since we can only ever match that field behind\n                 // a reference we construct a fat ptr here.\n-                let fields = ty::lookup_struct_fields(bcx.tcx(), def_id);\n+                let fields = bcx.tcx().lookup_struct_fields(def_id);\n                 let unsized_ty = fields.iter().last().map(|field| {\n-                    let fty = ty::lookup_field_type(bcx.tcx(), def_id, field.id, substs);\n+                    let fty = bcx.tcx().lookup_field_type(def_id, field.id, substs);\n                     monomorphize::normalize_associated_type(bcx.tcx(), &fty)\n                 }).unwrap();\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n@@ -1140,7 +1143,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n-                kind = if ty::type_is_integral(left_ty) {\n+                kind = if left_ty.is_integral() {\n                     Switch\n                 } else {\n                     Compare\n@@ -1407,13 +1410,13 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n-        let param_env = ty::empty_parameter_environment(tcx);\n+        let param_env = tcx.empty_parameter_environment();\n \n         let llmatch;\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !ty::type_moves_by_default(&param_env, span, variable_ty) || reassigned =>\n+                if !param_env.type_moves_by_default(variable_ty, span) || reassigned =>\n             {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n@@ -1466,7 +1469,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     }\n \n     let t = node_id_type(bcx, discr_expr.id);\n-    let chk = if ty::type_is_empty(tcx, t) {\n+    let chk = if t.is_empty(tcx) {\n         Unreachable\n     } else {\n         Infallible\n@@ -1745,9 +1748,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n-                                                         enum_id,\n-                                                         var_id);\n+                    let vinfo = ccx.tcx().enum_variant_with_id(enum_id, var_id);\n                     let args = extract_variant_args(bcx,\n                                                     &*repr,\n                                                     vinfo.disr_val,\n@@ -1787,7 +1788,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n                 for f in fields {\n-                    let ix = ty::field_idx_strict(tcx, f.node.ident.name, field_tys);\n+                    let ix = tcx.field_idx_strict(f.node.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, &*f.node.pat, fldptr, cleanup_scope);"}, {"sha": "3ce76167e85171b08425da88a9d34406e769acbb", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -209,13 +209,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n         ty::TyStruct(def_id, substs) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n+            let fields = cx.tcx().lookup_struct_fields(def_id);\n             let mut ftys = fields.iter().map(|field| {\n-                let fty = ty::lookup_field_type(cx.tcx(), def_id, field.id, substs);\n+                let fty = cx.tcx().lookup_field_type(def_id, field.id, substs);\n                 monomorphize::normalize_associated_type(cx.tcx(), &fty)\n             }).collect::<Vec<_>>();\n-            let packed = ty::lookup_packed(cx.tcx(), def_id);\n-            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n+            let packed = cx.tcx().lookup_packed(def_id);\n+            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -230,10 +230,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::TyEnum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).get(0)\n+            let hint = *cx.tcx().lookup_repr_hints(def_id).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n+            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n \n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n@@ -261,9 +261,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n-                                      discriminants\",\n-                                      ty::item_path_str(cx.tcx(),\n-                                                        def_id)));\n+                                        discriminants\",\n+                                       cx.tcx().item_path_str(def_id)));\n             }\n \n             if cases.len() == 1 {\n@@ -411,9 +410,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n         ty::TyStruct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n-            let nonzero_fields = ty::lookup_struct_fields(tcx, did);\n+            let nonzero_fields = tcx.lookup_struct_fields(did);\n             assert_eq!(nonzero_fields.len(), 1);\n-            let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n+            let nonzero_field = tcx.lookup_field_type(did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n                 ty::TyRawPtr(ty::mt { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n@@ -430,9 +429,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n         ty::TyStruct(def_id, substs) => {\n-            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            let fields = tcx.lookup_struct_fields(def_id);\n             for (j, field) in fields.iter().enumerate() {\n-                let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);\n+                let field_ty = tcx.lookup_field_type(def_id, field.id, substs);\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);\n@@ -504,7 +503,7 @@ fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n                    def_id: ast::DefId,\n                    substs: &subst::Substs<'tcx>)\n                    -> Vec<Case<'tcx>> {\n-    ty::enum_variants(tcx, def_id).iter().map(|vi| {\n+    tcx.enum_variants(def_id).iter().map(|vi| {\n         let arg_tys = vi.args.iter().map(|&raw_ty| {\n             monomorphize::apply_param_substs(tcx, substs, &raw_ty)\n         }).collect();\n@@ -623,8 +622,8 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n \n pub fn ty_of_inttype<'tcx>(tcx: &ty::ctxt<'tcx>, ity: IntType) -> Ty<'tcx> {\n     match ity {\n-        attr::SignedInt(t) => ty::mk_mach_int(tcx, t),\n-        attr::UnsignedInt(t) => ty::mk_mach_uint(tcx, t)\n+        attr::SignedInt(t) => tcx.mk_mach_int(t),\n+        attr::UnsignedInt(t) => tcx.mk_mach_uint(t)\n     }\n }\n \n@@ -1078,7 +1077,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.dtor_type());\n+    let ptr_ty = bcx.tcx().mk_imm_ptr(tcx.dtor_type());\n     match *r {\n         Univariant(ref st, dtor) if dtor_active(dtor) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);"}, {"sha": "b432560bc4b3c2c8c96f2de4d6b85eef8f26b371", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -153,7 +153,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n \n     let mut attrs = llvm::AttrBuilder::new();\n     let ret_ty = fn_sig.output;\n@@ -262,7 +262,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                     attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n                 } else {\n                     attrs.arg(idx, llvm::NonNullAttribute);\n-                    if ty::type_is_trait(inner) {\n+                    if inner.is_trait() {\n                         attrs.arg(idx + 1, llvm::NonNullAttribute);\n                     }\n                 }\n@@ -274,7 +274,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n                 // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n                 // on memory dependencies rather than pointer equality\n-                let interior_unsafe = ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe();\n+                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n \n                 if mt.mutbl == ast::MutMutable || !interior_unsafe {\n                     attrs.arg(idx, llvm::Attribute::NoAlias);\n@@ -291,7 +291,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                     attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n                 } else {\n                     attrs.arg(idx, llvm::NonNullAttribute);\n-                    if ty::type_is_trait(mt.ty) {\n+                    if mt.ty.is_trait() {\n                         attrs.arg(idx + 1, llvm::NonNullAttribute);\n                     }\n                 }"}, {"sha": "f035b32e3596df0c30544ccffd4d12d3b2856c71", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -40,7 +40,7 @@ use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::subst::Substs;\n-use middle::ty::{self, Ty, ClosureTyper, type_is_simd, simd_size};\n+use middle::ty::{self, Ty, ClosureTyper, HasTypeFlags};\n use rustc::ast_map;\n use session::config::{self, NoDebugInfo};\n use session::Session;\n@@ -202,10 +202,10 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let closure_kind = ccx.tcx().closure_kind(closure_id);\n     match closure_kind {\n         ty::FnClosureKind => {\n-            ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n+            ccx.tcx().mk_imm_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnMutClosureKind => {\n-            ty::mk_mut_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n+            ccx.tcx().mk_mut_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnOnceClosureKind => fn_ty\n     }\n@@ -232,7 +232,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n     // don't do this then linker errors can be generated where the linker\n     // complains that one object files has a thread local version of the\n     // symbol and another one doesn't.\n-    for attr in ty::get_attrs(ccx.tcx(), did).iter() {\n+    for attr in ccx.tcx().get_attrs(did).iter() {\n         if attr.check_name(\"thread_local\") {\n             llvm::set_thread_local(c, true);\n         }\n@@ -443,11 +443,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       ty::TyArray(_, n) => {\n         let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n-        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        let unit_ty = t.sequence_element_type(cx.tcx());\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::TySlice(_) | ty::TyStr => {\n-        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        let unit_ty = t.sequence_element_type(cx.tcx());\n         cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n       }\n       ty::TyTuple(ref args) => {\n@@ -462,7 +462,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ty::enum_variants(ccx.tcx(), tid);\n+          let variants = ccx.tcx().enum_variants(tid);\n           let n_variants = (*variants).len();\n \n           // NB: we must hit the discriminant first so that structural\n@@ -626,9 +626,9 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n-        ty::TyStruct(_, _) if type_is_simd(cx.tcx(), rhs_t) => {\n+        ty::TyStruct(_, _) if rhs_t.is_simd(cx.tcx()) => {\n             let mut res = C_bool(cx.ccx(), false);\n-            for i in 0 .. simd_size(cx.tcx(), rhs_t) {\n+            for i in 0 .. rhs_t.simd_size(cx.tcx()) {\n                 res = Or(cx, res,\n                          IsNull(cx,\n                                 ExtractElement(cx, rhs, C_int(cx.ccx(), i as i64))), debug_loc);\n@@ -805,13 +805,13 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let val =  if ty::type_is_bool(t) {\n+    let val =  if t.is_bool() {\n         LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n-    } else if ty::type_is_char(t) {\n+    } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n+    } else if (t.is_region_ptr() || t.is_unique())\n         && !common::type_is_fat_ptr(cx.tcx(), t) {\n             LoadNonNull(cx, ptr)\n     } else {\n@@ -844,15 +844,15 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n }\n \n pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty::type_is_bool(ty) {\n+    if ty.is_bool() {\n         ZExt(bcx, val, Type::i8(bcx.ccx()))\n     } else {\n         val\n     }\n }\n \n pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty::type_is_bool(ty) {\n+    if ty.is_bool() {\n         Trunc(bcx, val, Type::i1(bcx.ccx()))\n     } else {\n         val\n@@ -958,7 +958,7 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              t: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n-    if ty::type_is_structural(t) {\n+    if t.is_structural() {\n         let llty = type_of::type_of(ccx, t);\n         let llsz = llsize_of(ccx, llty);\n         let llalign = type_of::align_of(ccx, t);\n@@ -1012,7 +1012,7 @@ pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) ->\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n-    assert!(!ty::type_has_params(t));\n+    assert!(!t.has_param_types());\n     let val = alloca(bcx, ty, name);\n     return val;\n }\n@@ -1221,7 +1221,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n-          param_env: ty::empty_parameter_environment(ccx.tcx()),\n+          param_env: ccx.tcx().empty_parameter_environment(),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n           needs_ret_allocas: nested_returns,\n@@ -1584,7 +1584,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n         closure::ClosureEnv::Closure(_) => {\n-            vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n+            vec![ccx.tcx().mk_tup(monomorphized_arg_types)]\n         }\n     };\n     for monomorphized_arg_type in &monomorphized_arg_types {\n@@ -1673,9 +1673,9 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n-    let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n-    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n-    let abi = ty::ty_fn_abi(fn_ty);\n+    let fn_ty = ccx.tcx().node_id_to_type(id);\n+    let output_type = ccx.tcx().erase_late_bound_regions(&fn_ty.fn_ret());\n+    let abi = fn_ty.fn_abi();\n     trans_closure(ccx, decl, body, llfndecl, param_substs, id, attrs, output_type, abi,\n                   closure::ClosureEnv::NotClosure);\n }\n@@ -1709,7 +1709,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let result_ty = match ctor_ty.sty {\n         ty::TyBareFn(_, ref bft) => {\n-            ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n+            bcx.tcx().erase_late_bound_regions(&bft.sig.output()).unwrap()\n         }\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n@@ -1782,12 +1782,12 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                                                      disr: ty::Disr,\n                                                      param_substs: &'tcx Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n-    let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n+    let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n         ty::TyBareFn(_, ref bft) => {\n-            ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n+            ccx.tcx().erase_late_bound_regions(&bft.sig.output())\n         }\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n@@ -1803,9 +1803,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let arg_tys =\n-        ty::erase_late_bound_regions(\n-            ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n+    let arg_tys = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_args());\n \n     let arg_datums = create_datums_for_fn_args(bcx, &arg_tys[..]);\n \n@@ -1841,7 +1839,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n         return\n     }\n \n-    let ty = ty::node_id_to_type(ccx.tcx(), id);\n+    let ty = ccx.tcx().node_id_to_type(id);\n     let avar = adt::represent_type(ccx, ty);\n     match *avar {\n         adt::General(_, ref variants, _) => {\n@@ -2040,7 +2038,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     // error in trans. This is used to write compile-fail tests\n                     // that actually test that compilation succeeds without\n                     // reporting an error.\n-                    if ty::has_attr(ccx.tcx(), local_def(item.id), \"rustc_error\") {\n+                    if ccx.tcx().has_attr(local_def(item.id), \"rustc_error\") {\n                         ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n                     }\n                 }\n@@ -2120,7 +2118,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n-                                   ty::FnConverging(ty::mk_nil(ccx.tcx()))).unwrap_or_else(||{\n+                                   ty::FnConverging(ccx.tcx().mk_nil())).unwrap_or_else(||{\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n     finish_register_fn(ccx, sym, node_id, llfn);\n@@ -2202,7 +2200,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                                &ccx.int_type());\n \n         let llfn = declare::define_cfn(ccx, \"main\", llfty,\n-                                       ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+                                       ccx.tcx().mk_nil()).unwrap_or_else(||{\n             ccx.sess().span_err(sp, \"entry symbol `main` defined multiple times\");\n             // FIXME: We should be smart and show a better diagnostic here.\n             ccx.sess().help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\");\n@@ -2319,7 +2317,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val: id={} item={:?}\", id, item);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n-            let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n+            let ty = ccx.tcx().node_id_to_type(i.id);\n             let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n@@ -2339,7 +2337,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n                         // otherwise some LLVM optimization passes don't work as expected\n-                        let llty = if ty::type_is_bool(ty) {\n+                        let llty = if ty.is_bool() {\n                             llvm::LLVMInt8TypeInContext(ccx.llcx())\n                         } else {\n                             llvm::LLVMTypeOf(v)\n@@ -2426,7 +2424,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n-                    let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n+                    let ty = ccx.tcx().node_id_to_type(ni.id);\n                     let name = foreign::link_name(&*ni);\n                     let llfn = foreign::register_foreign_item_fn(ccx, abi, ty, &name);\n                     attributes::from_fn_attrs(ccx, &ni.attrs, llfn);\n@@ -2447,7 +2445,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n             };\n             assert!(!args.is_empty());\n-            let ty = ty::node_id_to_type(ccx.tcx(), id);\n+            let ty = ccx.tcx().node_id_to_type(id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);\n             let sym = exported_name(ccx,\n@@ -2476,7 +2474,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             };\n             let parent = ccx.tcx().map.get_parent(id);\n             let struct_item = ccx.tcx().map.expect_item(parent);\n-            let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n+            let ty = ccx.tcx().node_id_to_type(ctor_id);\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n@@ -2508,7 +2506,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    attrs: &[ast::Attribute], span: Span) -> ValueRef {\n-    let mty = ty::node_id_to_type(ccx.tcx(), id);\n+    let mty = ccx.tcx().node_id_to_type(id);\n \n     let sym = exported_name(ccx, id, mty, &attrs);\n "}, {"sha": "24abe0ed3fdd2f7c36867bd704e2a12987ff0b3a", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -49,7 +49,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::ty::MethodCall;\n use rustc::ast_map;\n \n@@ -173,7 +173,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                                                 bcx.fcx.param_substs).val)\n             }\n             def::DefVariant(tid, vid, _) => {\n-                let vinfo = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n+                let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);\n                 let substs = common::node_id_substs(bcx.ccx(),\n                                                     ExprId(ref_expr.id),\n                                                     bcx.fcx.param_substs);\n@@ -277,7 +277,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         ty::FnOnceClosureKind => false,\n     };\n     let bare_fn_ty_maybe_ref = if is_by_ref {\n-        ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty)\n+        tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), bare_fn_ty)\n     } else {\n         bare_fn_ty\n     };\n@@ -307,19 +307,18 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                       bare_fn_ty));\n             }\n         };\n-    let sig = ty::erase_late_bound_regions(tcx, sig);\n-    let tuple_input_ty = ty::mk_tup(tcx, sig.inputs.to_vec());\n-    let tuple_fn_ty = ty::mk_bare_fn(tcx,\n-                                     opt_def_id,\n-                                     tcx.mk_bare_fn(ty::BareFnTy {\n-                                         unsafety: ast::Unsafety::Normal,\n-                                         abi: synabi::RustCall,\n-                                         sig: ty::Binder(ty::FnSig {\n-                                             inputs: vec![bare_fn_ty_maybe_ref,\n-                                                          tuple_input_ty],\n-                                             output: sig.output,\n-                                             variadic: false\n-                                         })}));\n+    let sig = tcx.erase_late_bound_regions(sig);\n+    let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n+    let tuple_fn_ty = tcx.mk_fn(opt_def_id,\n+        tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: ast::Unsafety::Normal,\n+            abi: synabi::RustCall,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: vec![bare_fn_ty_maybe_ref,\n+                             tuple_input_ty],\n+                output: sig.output,\n+                variadic: false\n+            })}));\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n@@ -402,22 +401,22 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n            param_substs,\n            substs);\n \n-    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n-    assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n+    assert!(!substs.types.needs_infer());\n+    assert!(!substs.types.has_escaping_regions());\n     let substs = substs.erase_regions();\n \n     // Load the info for the appropriate trait if necessary.\n-    match ty::trait_of_item(tcx, def_id) {\n+    match tcx.trait_of_item(def_id) {\n         None => {}\n         Some(trait_id) => {\n-            ty::populate_implementations_for_trait_if_necessary(tcx, trait_id)\n+            tcx.populate_implementations_for_trait_if_necessary(trait_id)\n         }\n     }\n \n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (is_default, def_id, substs) = match ty::provided_source(tcx, def_id) {\n+    let (is_default, def_id, substs) = match tcx.provided_source(def_id) {\n         None => {\n             (false, def_id, tcx.mk_substs(substs))\n         }\n@@ -435,16 +434,16 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            let impl_id = ty::impl_or_trait_item(tcx, def_id).container()\n+            let impl_id = tcx.impl_or_trait_item(def_id).container()\n                                                              .id();\n-            let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n+            let impl_or_trait_item = tcx.impl_or_trait_item(source_id);\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n-                    let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n+                    let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &trait_ref, &*method)\n+                        tcx.make_substs_for_receiver_types(&trait_ref, &*method)\n                         .erase_regions();\n \n                     // And compose them\n@@ -517,7 +516,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n             let ref_ty = match node {\n-                ExprId(id) => ty::node_id_to_type(tcx, id),\n+                ExprId(id) => tcx.node_id_to_type(id),\n                 MethodCallKey(method_call) => {\n                     tcx.method_map.borrow().get(&method_call).unwrap().ty\n                 }\n@@ -535,7 +534,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     }\n \n     // Type scheme of the function item (may have type params)\n-    let fn_type_scheme = ty::lookup_item_type(tcx, def_id);\n+    let fn_type_scheme = tcx.lookup_item_type(def_id);\n     let fn_type = monomorphize::normalize_associated_type(tcx, &fn_type_scheme.ty);\n \n     // Find the actual function pointer.\n@@ -615,7 +614,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Some(method) => match method.origin {\n             ty::MethodTraitObject(_) => match method.ty.sty {\n                 ty::TyBareFn(_, ref fty) => {\n-                    ty::mk_bare_fn(bcx.tcx(), None, meth::opaque_method_ty(bcx.tcx(), fty))\n+                    bcx.tcx().mk_fn(None, meth::opaque_method_ty(bcx.tcx(), fty))\n                 }\n                 _ => method.ty\n             },\n@@ -641,7 +640,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n-        ty::node_id_to_type(bcx.tcx(), did.node)\n+        bcx.tcx().node_id_to_type(did.node)\n     } else {\n         csearch::get_type(bcx.tcx(), did).ty\n     };\n@@ -693,7 +692,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     let (abi, ret_ty) = match callee_ty.sty {\n         ty::TyBareFn(_, ref f) => {\n-            let output = ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output());\n+            let output = bcx.tcx().erase_late_bound_regions(&f.sig.output());\n             (f.abi, output)\n         }\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n@@ -749,7 +748,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         expr::Ignore => {\n             let ret_ty = match ret_ty {\n                 ty::FnConverging(ret_ty) => ret_ty,\n-                ty::FnDiverging => ty::mk_nil(ccx.tcx())\n+                ty::FnDiverging => ccx.tcx().mk_nil()\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n@@ -915,9 +914,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              ignore_self: bool)\n                              -> Block<'blk, 'tcx>\n {\n-    let args =\n-        ty::erase_late_bound_regions(\n-            bcx.tcx(), &ty::ty_fn_args(fn_ty));\n+    let args = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_args());\n \n     // Translate the `self` argument first.\n     if !ignore_self {\n@@ -978,7 +975,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               ignore_self: bool)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &ty::ty_fn_args(fn_ty));\n+    let arg_tys = bcx.tcx().erase_late_bound_regions( &fn_ty.fn_args());\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         bcx = trans_arg_datum(bcx,\n@@ -1024,8 +1021,8 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &ty::ty_fn_args(fn_ty));\n-    let variadic = ty::fn_is_variadic(fn_ty);\n+    let arg_tys = cx.tcx().erase_late_bound_regions(&fn_ty.fn_args());\n+    let variadic = fn_ty.fn_sig().0.variadic;\n \n     let mut bcx = cx;\n "}, {"sha": "cb30bcdbf53996ed0dd26f587d1cfe7d16f9f436", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -135,7 +135,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         return None\n     }\n \n-    let function_type = ty::node_id_to_type(ccx.tcx(), closure_id.node);\n+    let function_type = ccx.tcx().node_id_to_type(closure_id.node);\n     let function_type = monomorphize::apply_param_substs(ccx.tcx(), substs, &function_type);\n \n     // Normalize type so differences in regions and typedefs don't cause\n@@ -218,9 +218,9 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let function_type = typer.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(tcx, id, |fv| fv.iter().cloned().collect());\n+        tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n \n-    let sig = ty::erase_late_bound_regions(tcx, &function_type.sig);\n+    let sig = tcx.erase_late_bound_regions(&function_type.sig);\n \n     trans_closure(ccx,\n                   decl,\n@@ -363,16 +363,16 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n     let substs = tcx.mk_substs(substs);\n-    let closure_ty = ty::mk_closure(tcx, closure_def_id, substs);\n-    let ref_closure_ty = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), closure_ty);\n+    let closure_ty = tcx.mk_closure(closure_def_id, substs);\n+    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n     let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                abi: abi,\n                                                                sig: sig.clone() });\n-    let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n+    let llref_fn_ty = tcx.mk_fn(None, llref_bare_fn_ty);\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n@@ -383,7 +383,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let llonce_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                 abi: abi,\n                                                                 sig: sig });\n-    let llonce_fn_ty = ty::mk_bare_fn(tcx, None, llonce_bare_fn_ty);\n+    let llonce_fn_ty = tcx.mk_fn(None, llonce_bare_fn_ty);\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n@@ -392,7 +392,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n             ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n         });\n \n-    let sig = ty::erase_late_bound_regions(tcx, &llonce_bare_fn_ty.sig);\n+    let sig = tcx.erase_late_bound_regions(&llonce_bare_fn_ty.sig);\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,"}, {"sha": "777b61f25f0ef1f0536c49ee5b11f9b5b4aa3684", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -23,6 +23,7 @@ use middle::def;\n use middle::infer;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Typer;\n use middle::region;\n use middle::subst::{self, Subst, Substs};\n use trans::base;\n@@ -37,7 +38,7 @@ use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n-use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rustc::ast_map::{PathElem, PathName};\n@@ -89,7 +90,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n             where T : TypeFoldable<'tcx>\n         {\n-            let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n+            let u = self.tcx().anonymize_late_bound_regions(t);\n             ty_fold::super_fold_binder(self, &u)\n         }\n \n@@ -119,7 +120,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n \n /// Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty::type_is_sized(None, tcx, DUMMY_SP, ty)\n+    ty.is_sized(&tcx.empty_parameter_environment(), DUMMY_SP)\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -155,13 +156,13 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n         }\n \n         let mut needs_unwind_cleanup = false;\n-        ty::maybe_walk_ty(ty, |ty| {\n+        ty.maybe_walk(|ty| {\n             needs_unwind_cleanup |= match ty.sty {\n                 ty::TyBool | ty::TyInt(_) | ty::TyUint(_) |\n                 ty::TyFloat(_) | ty::TyTuple(_) | ty::TyRawPtr(_) => false,\n \n                 ty::TyEnum(did, substs) =>\n-                    ty::enum_variants(tcx, did).iter().any(|v|\n+                    tcx.enum_variants(did).iter().any(|v|\n                         v.args.iter().any(|&aty| {\n                             let t = aty.subst(tcx, substs);\n                             type_needs_unwind_cleanup_(tcx, t, tycache)\n@@ -183,7 +184,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n /// (Note that this implies that if `ty` has a destructor attached,\n /// then `type_needs_drop` will definitely return `true` for `ty`.)\n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_needs_drop_given_env(cx, ty, &ty::empty_parameter_environment(cx))\n+    type_needs_drop_given_env(cx, ty, &cx.empty_parameter_environment())\n }\n \n /// Core implementation of type_needs_drop, potentially making use of\n@@ -195,7 +196,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // normalized version of the type, and therefore will definitely\n     // know whether the type implements Copy (and thus needs no\n     // cleanup/drop/zeroing) ...\n-    let implements_copy = !ty::type_moves_by_default(&param_env, DUMMY_SP, ty);\n+    let implements_copy = !param_env.type_moves_by_default(ty, DUMMY_SP);\n \n     if implements_copy { return false; }\n \n@@ -210,17 +211,17 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // bound attached (see above), it is sound to treat it as having a\n     // destructor (e.g. zero its memory on move).\n \n-    let contents = ty::type_contents(cx, ty);\n+    let contents = ty.type_contents(cx);\n     debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n     contents.needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyStruct(def_id, substs) => {\n-            let fields = ty::lookup_struct_fields(ccx.tcx(), def_id);\n+            let fields = ccx.tcx().lookup_struct_fields(def_id);\n             fields.len() == 1 && {\n-                let ty = ty::lookup_field_type(ccx.tcx(), def_id, fields[0].id, substs);\n+                let ty = ccx.tcx().lookup_field_type(def_id, fields[0].id, substs);\n                 let ty = monomorphize::normalize_associated_type(ccx.tcx(), &ty);\n                 type_is_immediate(ccx, ty)\n             }\n@@ -234,10 +235,10 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     use trans::type_of::sizing_type_of;\n \n     let tcx = ccx.tcx();\n-    let simple = ty::type_is_scalar(ty) ||\n-        ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n+    let simple = ty.is_scalar() ||\n+        ty.is_unique() || ty.is_region_ptr() ||\n         type_is_newtype_immediate(ccx, ty) ||\n-        ty::type_is_simd(tcx, ty);\n+        ty.is_simd(tcx);\n     if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n@@ -267,7 +268,7 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n /// zero-size, but not all zero-size types use a `void` return type (in order to aid with C ABI\n /// compatibility).\n pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n-    ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n+    ty.is_nil() || ty.is_empty(ccx.tcx())\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n@@ -336,7 +337,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n pub fn validate_substs(substs: &Substs) {\n-    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(!substs.types.needs_infer());\n }\n \n // work around bizarre resolve errors\n@@ -512,7 +513,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -610,7 +611,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,\n@@ -661,8 +662,8 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n \n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n-        self.fcx.param_env.type_moves_by_default(span, ty)\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        self.fcx.param_env.type_moves_by_default(ty, span)\n     }\n }\n \n@@ -952,7 +953,7 @@ pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> T\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     let tcx = bcx.tcx();\n-    let t = ty::node_id_to_type(tcx, id);\n+    let t = tcx.node_id_to_type(id);\n     monomorphize_type(bcx, t)\n }\n \n@@ -961,7 +962,7 @@ pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx>\n }\n \n pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-    monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n+    monomorphize_type(bcx, bcx.tcx().expr_ty_adjusted(ex))\n }\n \n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n@@ -989,7 +990,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n            trait_ref, trait_ref.def_id());\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     // Do the initial selection for the obligation. This yields the\n@@ -1077,7 +1078,7 @@ impl<'a,'tcx> NormalizingClosureTyper<'a,'tcx> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingClosureTyper<'a,'tcx> {\n         // Parameter environment is used to give details about type parameters,\n         // but since we are in trans, everything is fully monomorphized.\n-        NormalizingClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+        NormalizingClosureTyper { param_env: tcx.empty_parameter_environment() }\n     }\n }\n \n@@ -1111,7 +1112,7 @@ impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let result = ty::closure_upvars(&self.param_env, def_id, substs);\n+        let result = self.param_env.closure_upvars(def_id, substs);\n         monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n     }\n }\n@@ -1187,14 +1188,14 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = match node {\n         ExprId(id) => {\n-            ty::node_id_item_substs(tcx, id).substs\n+            tcx.node_id_item_substs(id).substs\n         }\n         MethodCallKey(method_call) => {\n             tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()\n         }\n     };\n \n-    if substs.types.any(|t| ty::type_needs_infer(*t)) {\n+    if substs.types.needs_infer() {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n                                  node, substs));\n         }"}, {"sha": "8ec60000ee8425014f7385d3f2e0e410a68ca087", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -57,7 +57,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             C_integral(Type::uint_from_ty(cx, t), u, false)\n         }\n         ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n-            let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n+            let lit_int_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_int_ty.sty {\n                 ty::TyInt(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n@@ -75,7 +75,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             C_floating(&fs, Type::float_from_ty(cx, t))\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n-            let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n+            let lit_float_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_float_ty.sty {\n                 ty::TyFloat(t) => {\n                     C_floating(&fs, Type::float_from_ty(cx, t))\n@@ -149,7 +149,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                          v: ValueRef,\n                          ty: Ty<'tcx>)\n                          -> (ValueRef, Ty<'tcx>) {\n-    match ty::deref(ty, true) {\n+    match ty.builtin_deref(true) {\n         Some(mt) => {\n             if type_is_sized(cx.tcx(), mt.ty) {\n                 (const_deref_ptr(cx, v), mt.ty)\n@@ -249,7 +249,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n-                                                  &ty::expr_ty(ccx.tcx(), expr));\n+                                                  &ccx.tcx().expr_ty(expr));\n         const_expr_unadjusted(ccx, expr, ty, param_substs, None)\n     } else {\n         const_expr(ccx, expr, param_substs, None).0\n@@ -276,11 +276,11 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             fn_args: FnArgMap)\n                             -> (ValueRef, Ty<'tcx>) {\n     let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n-                                               &ty::expr_ty(cx.tcx(), e));\n+                                               &cx.tcx().expr_ty(e));\n     let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args);\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n-                                                            &ty::expr_ty_adjusted(cx.tcx(), e));\n+                                                            &cx.tcx().expr_ty_adjusted(e));\n     let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n         Some(ty::AdjustReifyFnPointer) => {\n@@ -306,7 +306,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     // Don't copy data to do a deref+ref\n                     // (i.e., skip the last auto-deref).\n                     llconst = addr_of(cx, llconst, \"autoref\");\n-                    ty = ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ty);\n+                    ty = cx.tcx().mk_imm_ref(cx.tcx().mk_region(ty::ReStatic), ty);\n                 }\n             } else {\n                 let (dv, dt) = const_deref(cx, llconst, ty);\n@@ -323,7 +323,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                               param_substs,\n                                                               &target);\n \n-                let pointee_ty = ty::deref(ty, true)\n+                let pointee_ty = ty.builtin_deref(true)\n                     .expect(\"consts: unsizing got non-pointer type\").ty;\n                 let (base, old_info) = if !type_is_sized(cx.tcx(), pointee_ty) {\n                     // Normally, the source is a thin pointer and we are\n@@ -338,7 +338,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (llconst, None)\n                 };\n \n-                let unsized_ty = ty::deref(target, true)\n+                let unsized_ty = target.builtin_deref(true)\n                     .expect(\"consts: unsizing got non-pointer target type\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                 let base = ptrcast(base, ptr_ty);\n@@ -499,14 +499,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n-            let is_simd = ty::type_is_simd(cx.tcx(), ty);\n+            let is_simd = ty.is_simd(cx.tcx());\n             let intype = if is_simd {\n-                ty::simd_type(cx.tcx(), ty)\n+                ty.simd_type(cx.tcx())\n             } else {\n                 ty\n             };\n-            let is_float = ty::type_is_fp(intype);\n-            let signed = ty::type_is_signed(intype);\n+            let is_float = intype.is_fp();\n+            let signed = intype.is_signed();\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs, fn_args);\n \n@@ -572,7 +572,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             check_unary_expr_validity(cx, e, ty, te);\n \n-            let is_float = ty::type_is_fp(ty);\n+            let is_float = ty.is_fp();\n             match u {\n               ast::UnUniq | ast::UnDeref => {\n                 const_deref(cx, te, ty).0\n@@ -588,7 +588,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n+                  let ix = cx.tcx().field_idx_strict(field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n@@ -660,7 +660,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n             if type_is_fat_ptr(cx.tcx(), t_expr) {\n                 // Fat pointer casts.\n-                let t_cast_inner = ty::deref(t_cast, true).expect(\"cast to non-pointer\").ty;\n+                let t_cast_inner = t_cast.builtin_deref(true).expect(\"cast to non-pointer\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n                 let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n                                    ptr_ty);\n@@ -681,11 +681,11 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n               }\n               (CastTy::Int(_), CastTy::Int(_)) => {\n-                let s = ty::type_is_signed(t_expr) as Bool;\n+                let s = t_expr.is_signed() as Bool;\n                 llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n               (CastTy::Int(_), CastTy::Float) => {\n-                if ty::type_is_signed(t_expr) {\n+                if t_expr.is_signed() {\n                     llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n                     llvm::LLVMConstUIToFP(v, llty.to_ref())\n@@ -781,15 +781,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  if ty::type_is_simd(cx.tcx(), ety) {\n+                  if ety.is_simd(cx.tcx()) {\n                       C_vector(&cs[..])\n                   } else {\n                       adt::trans_const(cx, &*repr, discr, &cs[..])\n                   }\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n+            let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n                               .collect::<Vec<_>>();\n@@ -801,9 +801,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n-            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n+            let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = ty::eval_repeat_count(cx.tcx(), count);\n+            let n = cx.tcx().eval_repeat_count(count);\n             let unit_val = const_expr(cx, &**elem, param_substs, fn_args).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {\n@@ -829,9 +829,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n-                    let vinfo = ty::enum_variant_with_id(cx.tcx(),\n-                                                         enum_did,\n-                                                         variant_did);\n+                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n                     if !vinfo.args.is_empty() {\n                         // N-ary variant.\n                         expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -875,7 +873,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n                   }\n                   def::DefStruct(_) => {\n-                      if ty::type_is_simd(cx.tcx(), ety) {\n+                      if ety.is_simd(cx.tcx()) {\n                           C_vector(&arg_vals[..])\n                       } else {\n                           let repr = adt::represent_type(cx, ety);\n@@ -884,9 +882,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                   }\n                   def::DefVariant(enum_did, variant_did, _) => {\n                       let repr = adt::represent_type(cx, ety);\n-                      let vinfo = ty::enum_variant_with_id(cx.tcx(),\n-                                                           enum_did,\n-                                                           variant_did);\n+                      let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n@@ -945,8 +941,8 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) ->\n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != ast::MutMutable {\n-            let node_ty = ty::node_id_to_type(ccx.tcx(), id);\n-            let tcontents = ty::type_contents(ccx.tcx(), node_ty);\n+            let node_ty = ccx.tcx().node_id_to_type(id);\n+            let tcontents = node_ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n                 llvm::LLVMSetGlobalConstant(g, True);\n             }"}, {"sha": "cf9d70cc65727098e9dc957410434ac22c0b4a79", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -791,15 +791,15 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n         ($name:expr, fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -939,7 +939,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             } else if *key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &void),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 llvm::SetLinkage(f, llvm::InternalLinkage);\n \n                 let bld = ccx.builder();\n@@ -962,7 +962,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             } else if *key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "2c539b67cb6274c282e6c1de5651412274d6020c", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -101,7 +101,8 @@ use trans::cleanup::CleanupMethods;\n use trans::expr;\n use trans::tvec;\n use trans::type_of;\n-use middle::ty::{self, Ty};\n+use middle::mem_categorization::Typer;\n+use middle::ty::Ty;\n \n use std::fmt;\n use syntax::ast;\n@@ -605,9 +606,8 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n          * affine values (since they must never be duplicated).\n          */\n \n-        assert!(!ty::type_moves_by_default(&ty::empty_parameter_environment(bcx.tcx()),\n-                                           DUMMY_SP,\n-                                           self.ty));\n+        assert!(!bcx.tcx().empty_parameter_environment()\n+                          .type_moves_by_default(self.ty, DUMMY_SP));\n         self.shallow_copy_raw(bcx, dst)\n     }\n \n@@ -640,7 +640,7 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     }\n \n     pub fn to_llbool<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(ty::type_is_bool(self.ty));\n+        assert!(self.ty.is_bool());\n         self.to_llscalarish(bcx)\n     }\n }"}, {"sha": "1fbbf0763aa53ba293c5f394a0167047ca0a6b58", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -242,9 +242,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::TyTrait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n \n-                let principal =\n-                    ty::erase_late_bound_regions(cx.tcx(),\n-                                                 &trait_data.principal);\n+                let principal = cx.tcx().erase_late_bound_regions(&trait_data.principal);\n \n                 from_def_id_and_substs(self,\n                                        cx,\n@@ -261,7 +259,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 unique_type_id.push_str(\" fn(\");\n \n-                let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+                let sig = cx.tcx().erase_late_bound_regions(sig);\n \n                 for &parameter_type in &sig.inputs {\n                     let parameter_type_id =\n@@ -376,7 +374,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n         unique_type_id.push_str(\"|\");\n \n-        let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+        let sig = cx.tcx().erase_late_bound_regions(sig);\n \n         for &parameter_type in &sig.inputs {\n             let parameter_type_id =\n@@ -562,7 +560,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+    let data_ptr_type = cx.tcx().mk_ptr(ty::mt {\n         ty: element_type,\n         mutbl: ast::MutImmutable\n     });\n@@ -626,7 +624,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = ty::erase_late_bound_regions(cx.tcx(), signature);\n+    let signature = cx.tcx().erase_late_bound_regions(signature);\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n@@ -1176,7 +1174,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n-    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+    let mut fields = cx.tcx().struct_fields(def_id, substs);\n \n     // The `Ty` values returned by `ty::struct_fields` can still contain\n     // `TyProjection` variants, so normalize those away.\n@@ -1192,7 +1190,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n             fields: fields,\n-            is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n+            is_simd: struct_type.is_simd(cx.tcx()),\n             span: span,\n         })\n     )\n@@ -1588,7 +1586,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, &loc.file.name);\n \n-    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n+    let variants = cx.tcx().enum_variants(enum_def_id);\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n@@ -1891,7 +1889,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n+    let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_name(name).to_string();"}, {"sha": "7487e8d331bf55f47af81de1a7fca74fbb4b66fa", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -30,7 +30,7 @@ use rustc::ast_map;\n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use trans;\n use trans::monomorphize;\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::ty::{Ty, ClosureTyper};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n \n@@ -412,11 +412,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n-        let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n+        let return_type = cx.tcx().node_id_to_type(fn_ast_id);\n         let return_type = monomorphize::apply_param_substs(cx.tcx(),\n                                                            param_substs,\n                                                            &return_type);\n-        if ty::type_is_nil(return_type) {\n+        if return_type.is_nil() {\n             signature.push(ptr::null_mut())\n         } else {\n             signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n@@ -425,7 +425,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // Arguments types\n         for arg in &fn_decl.inputs {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n-            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n+            let arg_type = cx.tcx().node_id_to_type(arg.pat.id);\n             let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n                                                             param_substs,\n                                                             &arg_type);"}, {"sha": "2e5943a248a5f81bbfd6b128d58f00b80fa86635", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -16,7 +16,7 @@ use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::ast_map;\n use trans::common::CrateContext;\n-use middle::ty::{self, ClosureTyper};\n+use middle::ty::ClosureTyper;\n \n use std::ffi::CString;\n use std::ptr;\n@@ -56,7 +56,7 @@ pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n }\n \n pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n-    ty::with_path(cx.tcx(), def_id, |path| {\n+    cx.tcx().with_path(def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n             let crate_namespace_name = token::intern(crate_root_namespace(cx));"}, {"sha": "6ea43d7392c944e19793905f49b9d3f5a9429802", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -106,7 +106,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::TyTrait(ref trait_data) => {\n-            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            let principal = cx.tcx().erase_late_bound_regions(&trait_data.principal);\n             push_item_name(cx, principal.def_id, false, output);\n             push_type_params(cx, principal.substs, output);\n         },\n@@ -123,7 +123,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            let sig = cx.tcx().erase_late_bound_regions(sig);\n             if !sig.inputs.is_empty() {\n                 for &parameter_type in &sig.inputs {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n@@ -144,7 +144,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(')');\n \n             match sig.output {\n-                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) if result_type.is_nil() => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");\n                     push_debuginfo_type_name(cx, result_type, true, output);\n@@ -170,7 +170,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       def_id: ast::DefId,\n                       qualified: bool,\n                       output: &mut String) {\n-        ty::with_path(cx.tcx(), def_id, |path| {\n+        cx.tcx().with_path(def_id, |path| {\n             if qualified {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     output.push_str(crate_root_namespace(cx));"}, {"sha": "646ca6733c3b61864c8b2bacc7483f47542ae341", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -128,7 +128,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n-    let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n+    let sig = ty::Binder(ccx.tcx().erase_late_bound_regions(sig));\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));"}, {"sha": "8fd88055b8e45a58417999ed8567778b34680f66", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -73,7 +73,6 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::cast::{CastKind, CastTy};\n-use middle::ty::{struct_fields, tup_fields};\n use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n@@ -252,7 +251,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llty = type_of::type_of(bcx.ccx(), const_ty);\n             // HACK(eddyb) get around issues with lifetime intrinsics.\n             let scratch = alloca_no_lifetime(bcx, llty, \"const\");\n-            let lldest = if !ty::type_is_structural(const_ty) {\n+            let lldest = if !const_ty.is_structural() {\n                 // Cast pointer to slot, because constants have different types.\n                 PointerCast(bcx, scratch, val_ty(global))\n             } else {\n@@ -313,7 +312,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 old_info: Option<ValueRef>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> ValueRef {\n-    let (source, target) = ty::struct_lockstep_tails(ccx.tcx(), source, target);\n+    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n         (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n@@ -500,7 +499,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let kind = match fulfill_obligation(bcx.ccx(), span, trait_ref) {\n                 traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-                    ty::custom_coerce_unsized_kind(bcx.tcx(), impl_def_id)\n+                    bcx.tcx().custom_coerce_unsized_kind(impl_def_id)\n                 }\n                 vtable => {\n                     bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {:?}\",\n@@ -748,7 +747,7 @@ fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                base: &ast::Expr,\n                                field: ast::Name)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |tcx, field_tys| ty::field_idx_strict(tcx, field, field_tys))\n+    trans_field(bcx, base, |tcx, field_tys| tcx.field_idx_strict(field, field_tys))\n }\n \n /// Translates `base.<idx>`.\n@@ -789,9 +788,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n             let ref_ty = // invoked methods have LB regions instantiated:\n-                ty::no_late_bound_regions(\n-                    bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n-            let elt_ty = match ty::deref(ref_ty, true) {\n+                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+            let elt_ty = match ref_ty.builtin_deref(true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n                                             \"index method didn't return a \\\n@@ -835,7 +833,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                       ccx.int_type());\n             let ix_val = {\n                 if ix_size < int_size {\n-                    if ty::type_is_signed(expr_ty(bcx, idx)) {\n+                    if expr_ty(bcx, idx).is_signed() {\n                         SExt(bcx, ix_val, ccx.int_type())\n                     } else { ZExt(bcx, ix_val, ccx.int_type()) }\n                 } else if ix_size > int_size {\n@@ -845,7 +843,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            let unit_ty = ty::sequence_element_type(bcx.tcx(), base_datum.ty);\n+            let unit_ty = base_datum.ty.sequence_element_type(bcx.tcx());\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n@@ -1110,7 +1108,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              expr.span,\n                              expr.id,\n-                             ty::mk_struct(tcx, did, tcx.mk_substs(substs)),\n+                             tcx.mk_struct(did, tcx.mk_substs(substs)),\n                              dest)\n             } else {\n                 tcx.sess.span_bug(expr.span,\n@@ -1227,7 +1225,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match def {\n         def::DefVariant(tid, vid, _) => {\n-            let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n+            let variant_info = bcx.tcx().enum_variant_with_id(tid, vid);\n             if !variant_info.args.is_empty() {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n@@ -1247,7 +1245,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n-                ty::TyStruct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n+                ty::TyStruct(did, _) if bcx.tcx().has_dtor(did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }\n@@ -1342,13 +1340,22 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::TyStruct(did, substs) => {\n-            let fields = struct_fields(tcx, did, substs);\n+            let fields = tcx.struct_fields(did, substs);\n             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n             op(0, &fields[..])\n         }\n \n         ty::TyTuple(ref v) => {\n-            op(0, &tup_fields(&v[..]))\n+            let fields: Vec<_> = v.iter().enumerate().map(|(i, &f)| {\n+                ty::field {\n+                    name: token::intern(&i.to_string()),\n+                    mt: ty::mt {\n+                        ty: f,\n+                        mutbl: ast::MutImmutable\n+                    }\n+                }\n+            }).collect();\n+            op(0, &fields)\n         }\n \n         ty::TyEnum(_, substs) => {\n@@ -1364,8 +1371,8 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n-                            let variant_info = ty::enum_variant_with_id(tcx, enum_id, variant_id);\n-                            let fields = struct_fields(tcx, variant_id, substs);\n+                            let variant_info = tcx.enum_variant_with_id(enum_id, variant_id);\n+                            let fields = tcx.struct_fields(variant_id, substs);\n                             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n                             op(variant_info.disr_val, &fields[..])\n                         }\n@@ -1490,7 +1497,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    if ty::type_is_simd(bcx.tcx(), ty) {\n+    if ty.is_simd(bcx.tcx()) {\n         // Issue 23112: The original logic appeared vulnerable to same\n         // order-of-eval bug. But, SIMD values are tuple-structs;\n         // i.e. functional record update (FRU) syntax is unavailable.\n@@ -1626,11 +1633,11 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let val = datum.to_llscalarish(bcx);\n             let (bcx, llneg) = {\n-                if ty::type_is_fp(un_ty) {\n+                if un_ty.is_fp() {\n                     let result = FNeg(bcx, val, debug_loc);\n                     (bcx, result)\n                 } else {\n-                    let is_signed = ty::type_is_signed(un_ty);\n+                    let is_signed = un_ty.is_signed();\n                     let result = Neg(bcx, val, debug_loc);\n                     let bcx = if bcx.ccx().check_overflow() && is_signed {\n                         let (llty, min) = base::llty_and_min_for_signed_ty(bcx, un_ty);\n@@ -1697,7 +1704,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            lval: Datum<'tcx, Lvalue>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n-    let dest_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), lval.ty);\n+    let dest_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReStatic), lval.ty);\n     let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n     memcpy_ty(bcx, scratch.val, lval.val, scratch.ty);\n \n@@ -1735,14 +1742,14 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let tcx = bcx.tcx();\n-    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let is_simd = lhs_t.is_simd(tcx);\n     let intype = if is_simd {\n-        ty::simd_type(tcx, lhs_t)\n+        lhs_t.simd_type(tcx)\n     } else {\n         lhs_t\n     };\n-    let is_float = ty::type_is_fp(intype);\n-    let is_signed = ty::type_is_signed(intype);\n+    let is_float = intype.is_fp();\n+    let is_signed = intype.is_signed();\n     let info = expr_info(binop_expr);\n \n     let binop_debug_loc = binop_expr.debug_loc();\n@@ -1999,7 +2006,7 @@ pub fn cast_is_noop<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return true;\n     }\n \n-    match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n+    match (t_in.builtin_deref(true), t_out.builtin_deref(true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out\n         }\n@@ -2108,7 +2115,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ll_t_in = val_ty(discr);\n         (discr, adt::is_discr_signed(&*repr))\n     } else {\n-        (datum.to_llscalarish(bcx), ty::type_is_signed(t_in))\n+        (datum.to_llscalarish(bcx), t_in.is_signed())\n     };\n \n     let newval = match (r_t_in, r_t_out) {\n@@ -2180,7 +2187,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Compute final type. Note that we are loose with the region and\n     // mutability, since those things don't matter in trans.\n     let referent_ty = lv_datum.ty;\n-    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), referent_ty);\n+    let ptr_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReStatic), referent_ty);\n \n     // Get the pointer.\n     let llref = lv_datum.to_llref();\n@@ -2241,8 +2248,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let ref_ty = // invoked methods have their LB regions instantiated\n-                ty::no_late_bound_regions(\n-                    ccx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n+                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n@@ -2545,13 +2551,13 @@ fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n     let tcx = bcx.tcx();\n-    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let is_simd = lhs_t.is_simd(tcx);\n     let intype = if is_simd {\n-        ty::simd_type(tcx, lhs_t)\n+        lhs_t.simd_type(tcx)\n     } else {\n         lhs_t\n     };\n-    let is_signed = ty::type_is_signed(intype);\n+    let is_signed = intype.is_signed();\n     if is_signed {\n         AShr(bcx, lhs, rhs, binop_debug_loc)\n     } else {\n@@ -2629,9 +2635,9 @@ fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n \n     match expr.node {\n         ast::ExprPath(..) => {\n-            match ty::resolve_expr(tcx, expr) {\n+            match tcx.resolve_expr(expr) {\n                 def::DefStruct(_) | def::DefVariant(..) => {\n-                    if let ty::TyBareFn(..) = ty::node_id_to_type(tcx, expr.id).sty {\n+                    if let ty::TyBareFn(..) = tcx.node_id_to_type(expr.id).sty {\n                         // ctor function\n                         ExprKind::RvalueDatum\n                     } else {"}, {"sha": "9e8c0189a9762722a7683480a7bc632c623684cf", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -109,7 +109,7 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n \n pub fn register_static(ccx: &CrateContext,\n                        foreign_item: &ast::ForeignItem) -> ValueRef {\n-    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n+    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n@@ -245,7 +245,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::TyBareFn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          &llsig.llarg_tys,\n@@ -324,7 +324,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n-            if ty::type_is_bool(passed_arg_tys[i]) {\n+            if passed_arg_tys[i].is_bool() {\n                 let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n                 Trunc(bcx, val, Type::i1(bcx.ccx()))\n             } else {\n@@ -450,7 +450,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n     if !tcx.sess.features.borrow().simd_ffi {\n         let check = |ast_ty: &ast::Ty, ty: ty::Ty| {\n-            if ty::type_is_simd(tcx, ty) {\n+            if ty.is_simd(tcx) {\n                 tcx.sess.span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n@@ -478,7 +478,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n             match foreign_mod.abi {\n                 Rust | RustIntrinsic => {}\n                 abi => {\n-                    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n+                    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n                         ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n                         _ => ccx.tcx().sess.span_bug(foreign_item.span,\n@@ -538,7 +538,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n     let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n-                                   ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+                                   ty::FnConverging(ccx.tcx().mk_nil()));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n@@ -554,7 +554,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n     let tys = foreign_types_for_id(ccx, node_id);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let t = ty::node_id_to_type(ccx.tcx(), node_id);\n+    let t = ccx.tcx().node_id_to_type(node_id);\n     let cconv = match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n@@ -578,7 +578,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 hash: Option<&str>) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n-    let fnty = ty::node_id_to_type(ccx.tcx(), id);\n+    let fnty = ccx.tcx().node_id_to_type(id);\n     let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n     let tys = foreign_types_for_fn_ty(ccx, mty);\n \n@@ -601,7 +601,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n-        let t = ty::node_id_to_type(tcx, id);\n+        let t = tcx.node_id_to_type(id);\n         let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n@@ -777,7 +777,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // pointer).  It makes adapting types easier, since we can\n             // always just bitcast pointers.\n             if !foreign_indirect {\n-                llforeign_arg = if ty::type_is_bool(rust_ty) {\n+                llforeign_arg = if rust_ty.is_bool() {\n                     let lltemp = builder.alloca(Type::bool(ccx), \"\");\n                     builder.store(builder.zext(llforeign_arg, Type::bool(ccx)), lltemp);\n                     lltemp\n@@ -799,7 +799,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let llrust_arg = if rust_indirect || type_is_fat_ptr(ccx.tcx(), rust_ty) {\n                 llforeign_arg\n             } else {\n-                if ty::type_is_bool(rust_ty) {\n+                if rust_ty.is_bool() {\n                     let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n                     builder.trunc(tmp, Type::i1(ccx))\n                 } else if type_of::type_of(ccx, rust_ty).is_aggregate() {\n@@ -933,7 +933,7 @@ fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   id: ast::NodeId) -> ForeignTypes<'tcx> {\n-    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx(), id))\n+    foreign_types_for_fn_ty(ccx, ccx.tcx().node_id_to_type(id))\n }\n \n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -942,7 +942,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyBareFn(_, ref fn_ty) => &fn_ty.sig,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        &llsig.llarg_tys,"}, {"sha": "3bcdcd89c47f5d152a30aa51380dae329b6da515", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -218,21 +218,21 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n     } else {\n-        type_of(ccx, ty::mk_uniq(ccx.tcx(), t)).ptr_to()\n+        type_of(ccx, ccx.tcx().mk_box(t)).ptr_to()\n     };\n \n     let llfnty = Type::glue_fn(ccx, llty);\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n     if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n-        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n+        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ccx.tcx().mk_nil());\n         ccx.drop_glues().borrow_mut().insert(g, llfn);\n         return llfn;\n     };\n \n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n-    let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+    let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ccx.tcx().mk_nil()).unwrap_or_else(||{\n        ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n     });\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n@@ -243,10 +243,10 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n+                      ty::FnConverging(ccx.tcx().mk_nil()),\n                       empty_substs, None, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ccx.tcx().mk_nil()));\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -261,7 +261,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_offset() as c_uint);\n     let bcx = make_drop_glue(bcx, llrawptr0, g);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n+    finish_fn(&fcx, bcx, ty::FnConverging(ccx.tcx().mk_nil()), DebugLoc::None);\n \n     llfn\n }\n@@ -326,12 +326,11 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         let tcx = ccx.tcx();\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n+        let class_ty = tcx.lookup_item_type(parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n-        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n-                                     did,\n-                                     &[get_drop_glue_type(ccx, t)],\n-                                     ty::mk_nil(ccx.tcx()));\n+        let dtor_ty = ccx.tcx().mk_ctor_fn(did,\n+                                           &[get_drop_glue_type(ccx, t)],\n+                                           ccx.tcx().mk_nil());\n         foreign::get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), &name[..], llvm::CCallConv,\n                                llty, dtor_ty)\n     }\n@@ -371,7 +370,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n     let glue_type = get_drop_glue_type(bcx.ccx(), t);\n-    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), class_did, &[glue_type], ty::mk_nil(bcx.tcx()));\n+    let dtor_ty = bcx.tcx().mk_ctor_fn(class_did, &[glue_type], bcx.tcx().mk_nil());\n     let (_, bcx) = invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None);\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n@@ -392,15 +391,15 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n-            assert!(!ty::type_is_simd(bcx.tcx(), t));\n+            assert!(!t.is_simd(bcx.tcx()));\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n             let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type));\n             let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type));\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let fields = ty::struct_fields(bcx.tcx(), id, substs);\n+            let fields = bcx.tcx().struct_fields(id, substs);\n             let last_field = fields[fields.len()-1];\n             let field_ty = last_field.mt.ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n@@ -426,7 +425,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             (Load(bcx, size_ptr), Load(bcx, align_ptr))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+            let unit_ty = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n@@ -496,7 +495,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n         }\n         ty::TyStruct(did, substs) | ty::TyEnum(did, substs) => {\n             let tcx = bcx.tcx();\n-            match (ty::ty_dtor(tcx, did), skip_dtor) {\n+            match (tcx.ty_dtor(did), skip_dtor) {\n                 (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct)."}, {"sha": "75c80690f2ad4b73f415cd93112c27135859ca74", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -14,7 +14,6 @@ use middle::astencode;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use trans::common::*;\n-use middle::ty;\n \n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -28,7 +27,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n-                   ty::item_path_str(ccx.tcx(), fn_id), node_id);\n+                   ccx.tcx().item_path_str(fn_id), node_id);\n             return Some(local_def(node_id));\n         }\n         Some(&None) => {\n@@ -104,8 +103,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n           let mut my_id = 0;\n           match item.node {\n             ast::ItemEnum(_, _) => {\n-              let vs_here = ty::enum_variants(ccx.tcx(), local_def(item.id));\n-              let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n+              let vs_here = ccx.tcx().enum_variants(local_def(item.id));\n+              let vs_there = ccx.tcx().enum_variants(parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n@@ -140,7 +139,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             // the logic to do that already exists in `middle`. In order to\n             // reuse that code, it needs to be able to look up the traits for\n             // inlined items.\n-            let ty_trait_item = ty::impl_or_trait_item(ccx.tcx(), fn_id).clone();\n+            let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n             ccx.tcx().impl_or_trait_items.borrow_mut()\n                      .insert(local_def(trait_item.id), ty_trait_item);\n \n@@ -157,7 +156,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             // Translate monomorphic impl methods immediately.\n             if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n-                let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n+                let impl_tpt = ccx.tcx().lookup_item_type(impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n                         sig.generics.ty_params.is_empty() {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());"}, {"sha": "b449c3ad060b81a82f67f31657ee0067c5eaf2d5", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -30,7 +30,7 @@ use trans::type_of;\n use trans::machine;\n use trans::machine::llsize_of;\n use trans::type_::Type;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n@@ -103,8 +103,8 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n \n         debug!(\"transmute_restriction: {:?}\", transmute_restriction);\n \n-        assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n-        assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n+        assert!(!transmute_restriction.substituted_from.has_param_types());\n+        assert!(!transmute_restriction.substituted_to.has_param_types());\n \n         let llfromtype = type_of::sizing_type_of(ccx,\n                                                  transmute_restriction.substituted_from);\n@@ -163,7 +163,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let ret_ty = match callee_ty.sty {\n         ty::TyBareFn(_, ref f) => {\n-            ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n+            bcx.tcx().erase_late_bound_regions(&f.sig.output())\n         }\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n@@ -411,10 +411,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            let hash = ty::hash_crate_independent(\n-                ccx.tcx(),\n-                *substs.types.get(FnSpace, 0),\n-                &ccx.link_meta().crate_hash);\n+            let hash = ccx.tcx().hash_crate_independent(*substs.types.get(FnSpace, 0),\n+                                                        &ccx.link_meta().crate_hash);\n             C_u64(ccx, hash)\n         }\n         (_, \"init_dropped\") => {"}, {"sha": "a3e5b640fd0f1f5d022161f6dd5808e754f641a4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -37,7 +37,7 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::MethodCall;\n \n use syntax::abi::{Rust, RustCall};\n@@ -182,7 +182,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n             expr_id={})\",\n            method_id,\n-           ty::item_path_str(tcx, trait_id),\n+           tcx.item_path_str(trait_id),\n            expr_id);\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n@@ -248,7 +248,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             substs: impl_substs,\n             nested: _ }) =>\n         {\n-            assert!(impl_substs.types.all(|t| !ty::type_needs_infer(*t)));\n+            assert!(!impl_substs.types.needs_infer());\n \n             // Create the substitutions that are in scope. This combines\n             // the type parameters from the impl with those declared earlier.\n@@ -282,7 +282,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         traits::VtableObject(ref data) => {\n             let trait_item_def_ids =\n-                ty::trait_item_def_ids(ccx.tcx(), trait_id);\n+                ccx.tcx().trait_item_def_ids(trait_id);\n             let method_offset_in_trait =\n                 trait_item_def_ids.iter()\n                                   .position(|item| item.def_id() == method_id)\n@@ -314,7 +314,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n-                                ty::impl_or_trait_item(ccx.tcx(), did.def_id()).name() == name\n+                                ccx.tcx().impl_or_trait_item(did.def_id()).name() == name\n                              }).expect(\"could not find method while \\\n                                         translating\");\n \n@@ -334,7 +334,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableImpl(vtable_impl) => {\n             let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n-            let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n+            let mname = match ccx.tcx().trait_item(trait_id, n_method) {\n                 ty::MethodTraitItem(method) => method.name,\n                 _ => {\n                     bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n@@ -567,12 +567,12 @@ pub fn trans_object_shim<'a, 'tcx>(\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n-    let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n+    let upcast_trait_ref = tcx.erase_late_bound_regions(&upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n-    let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n+    let method_ty = match tcx.trait_item(trait_id, method_offset_in_trait) {\n         ty::MethodTraitItem(method) => method,\n         _ => {\n             tcx.sess.bug(\"can't create a method shim for a non-method item\")\n@@ -584,14 +584,14 @@ pub fn trans_object_shim<'a, 'tcx>(\n     debug!(\"trans_object_shim: fty={:?} method_ty={:?}\", fty, method_ty);\n \n     //\n-    let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n-    let method_bare_fn_ty = ty::mk_bare_fn(tcx, None, method_ty);\n+    let shim_fn_ty = tcx.mk_fn(None, fty);\n+    let method_bare_fn_ty = tcx.mk_fn(None, method_ty);\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n     let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty).unwrap_or_else(||{\n         ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n     });\n \n-    let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n+    let sig = ccx.tcx().erase_late_bound_regions(&fty.sig);\n \n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -747,16 +747,16 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            substs,\n            param_substs);\n \n-    let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n+    let trt_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n         None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n                                       make a vtable for a type impl!\")\n     };\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n+    tcx.populate_implementations_for_trait_if_necessary(trt_id);\n \n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n-    let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n+    let trait_item_def_ids = tcx.trait_item_def_ids(trt_id);\n     trait_item_def_ids\n         .iter()\n \n@@ -775,7 +775,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             debug!(\"emit_vtable_methods: trait_method_def_id={:?}\",\n                    trait_method_def_id);\n \n-            let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n+            let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n                 _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n@@ -793,7 +793,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n             let impl_method_def_id = method_with_name(ccx, impl_id, name);\n-            let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n+            let impl_method_type = match tcx.impl_or_trait_item(impl_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n                 _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n@@ -806,7 +806,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // particular set of type parameters. Note that this\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n-            if ty::provided_source(tcx, impl_method_def_id).is_some() {\n+            if tcx.provided_source(impl_method_def_id).is_some() {\n                 let predicates = impl_method_type.predicates.predicates.subst(tcx, &substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"emit_vtable_methods: predicates do not hold\");\n@@ -827,7 +827,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n         -> &'tcx ty::BareFnTy<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n-    inputs[0] = ty::mk_mut_ptr(tcx, ty::mk_mach_int(tcx, ast::TyI8));\n+    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::TyI8));\n \n     tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: method_ty.unsafety,"}, {"sha": "cae810c9082e5f94a899cdd1881fa3040fa8764f", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -25,7 +25,7 @@ use trans::base;\n use trans::common::*;\n use trans::declare;\n use trans::foreign;\n-use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty::{self, HasTypeFlags, Ty};\n \n use syntax::abi;\n use syntax::ast;\n@@ -47,9 +47,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            psubsts,\n            ref_id);\n \n-    assert!(psubsts.types.all(|t| {\n-        !ty::type_needs_infer(*t) && !ty::type_has_params(*t)\n-    }));\n+    assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n@@ -58,15 +56,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         params: &psubsts.types\n     };\n \n-    let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n+    let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n \n     debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n     let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n-            ty::item_path_str(ccx.tcx(), fn_id));\n+            ccx.tcx().item_path_str(fn_id));\n             return (val, mono_ty, false);\n         }\n         None => ()\n@@ -200,7 +198,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx().map.get_parent(fn_id.node);\n-            let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n+            let tvs = ccx.tcx().enum_variants(local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n@@ -286,7 +284,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n-    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n+    debug!(\"leaving monomorphic fn {}\", ccx.tcx().item_path_str(fn_id));\n     (lldecl, mono_ty, true)\n }\n \n@@ -302,7 +300,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   param_substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)\n@@ -313,7 +311,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// and hence we can be sure that all associated types will be\n /// completely normalized away.\n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_associated_type(t={:?})\", value);\n "}, {"sha": "d94a0e235ee861fd3316451dc22ec7dc75e3b380", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -106,9 +106,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let count = elements_required(bcx, content_expr);\n     debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n \n-    let fixed_ty = ty::mk_vec(bcx.tcx(),\n-                              vt.unit_ty,\n-                              Some(count));\n+    let fixed_ty = bcx.tcx().mk_array(vt.unit_ty, count);\n     let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty);\n \n     // Always create an alloca even if zero-sized, to preserve\n@@ -227,7 +225,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return expr::trans_into(bcx, &**element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match ty::eval_repeat_count(bcx.tcx(), &**count_expr) {\n+                    match bcx.tcx().eval_repeat_count(&**count_expr) {\n                         0 => expr::trans_into(bcx, &**element, Ignore),\n                         1 => expr::trans_into(bcx, &**element, SaveIn(lldest)),\n                         count => {\n@@ -253,7 +251,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, vec_expr: &ast::Expr)\n                                    -> VecTypes<'tcx> {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n-    vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n+    vec_types(bcx, vec_ty.sequence_element_type(bcx.tcx()))\n }\n \n fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)\n@@ -279,7 +277,7 @@ fn elements_required(bcx: Block, content_expr: &ast::Expr) -> usize {\n         },\n         ast::ExprVec(ref es) => es.len(),\n         ast::ExprRepeat(_, ref count_expr) => {\n-            ty::eval_repeat_count(bcx.tcx(), &**count_expr)\n+            bcx.tcx().eval_repeat_count(&**count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "20d25518e2700c8a7dd2b5d5081dad22229b285c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -102,7 +102,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            sig,\n            abi);\n \n-    let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+    let sig = cx.tcx().erase_late_bound_regions(sig);\n     assert!(!sig.variadic); // rust fns are never variadic\n \n     let mut atys: Vec<Type> = Vec::new();\n@@ -222,9 +222,9 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyStruct(..) => {\n-            if ty::type_is_simd(cx.tcx(), t) {\n-                let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n-                let n = ty::simd_size(cx.tcx(), t) as u64;\n+            if t.is_simd(cx.tcx()) {\n+                let llet = type_of(cx, t.simd_type(cx.tcx()));\n+                let n = t.simd_size(cx.tcx()) as u64;\n                 ensure_array_fits_in_address_space(cx, llet, n, t);\n                 Type::vector(&llet, n)\n             } else {\n@@ -245,15 +245,15 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n }\n \n pub fn foreign_arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if ty::type_is_bool(t) {\n+    if t.is_bool() {\n         Type::i1(cx)\n     } else {\n         type_of(cx, t)\n     }\n }\n \n pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if ty::type_is_bool(t) {\n+    if t.is_bool() {\n         Type::i1(cx)\n     } else if type_is_immediate(cx, t) && type_of(cx, t).is_aggregate() {\n         // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n@@ -278,7 +278,7 @@ pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n /// For the raw type without far pointer indirection, see `in_memory_type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     let ty = if !type_is_sized(cx.tcx(), ty) {\n-        ty::mk_imm_ptr(cx.tcx(), ty)\n+        cx.tcx().mk_imm_ptr(ty)\n     } else {\n         ty\n     };\n@@ -362,7 +362,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                  let unsized_part = ty::struct_tail(cx.tcx(), ty);\n+                  let unsized_part = cx.tcx().struct_tail(ty);\n                   let info_ty = match unsized_part.sty {\n                       ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n                           Type::uint_from_ty(cx, ast::TyUs)\n@@ -402,9 +402,9 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           adt::type_of(cx, &*repr)\n       }\n       ty::TyStruct(did, ref substs) => {\n-          if ty::type_is_simd(cx.tcx(), t) {\n-              let llet = in_memory_type_of(cx, ty::simd_type(cx.tcx(), t));\n-              let n = ty::simd_size(cx.tcx(), t) as u64;\n+          if t.is_simd(cx.tcx()) {\n+              let llet = in_memory_type_of(cx, t.simd_type(cx.tcx()));\n+              let n = t.simd_size(cx.tcx()) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n               Type::vector(&llet, n)\n           } else {\n@@ -434,7 +434,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n         ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n-                if !ty::type_is_simd(cx.tcx(), t) => {\n+                if !t.is_simd(cx.tcx()) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n         }\n@@ -454,7 +454,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             did: ast::DefId,\n                             tps: &[Ty<'tcx>])\n                             -> String {\n-    let base = ty::item_path_str(cx.tcx(), did);\n+    let base = cx.tcx().item_path_str(did);\n     let strings: Vec<String> = tps.iter().map(|t| t.to_string()).collect();\n     let tstr = if strings.is_empty() {\n         base"}, {"sha": "2575dc0184f8c6ede732dae63908b27dfab53aa0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -56,7 +56,7 @@ use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n-use middle::ty::{self, RegionEscape, Ty, ToPredicate};\n+use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n use middle::ty_fold;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n@@ -124,7 +124,7 @@ pub trait AstConv<'tcx> {\n                                         item_name: ast::Name)\n                                         -> Ty<'tcx>\n     {\n-        if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+        if self.tcx().binds_late_bound_regions(&poly_trait_ref) {\n             span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n@@ -439,7 +439,7 @@ fn create_substs_for_ast_path<'tcx>(\n             // other type parameters may reference `Self` in their\n             // defaults. This will lead to an ICE if we are not\n             // careful!\n-            if self_ty.is_none() && ty::type_has_self(default) {\n+            if self_ty.is_none() && default.has_self_ty() {\n                 span_err!(tcx.sess, span, E0393,\n                           \"the type parameter `{}` must be explicitly specified \\\n                            in an object type because its default value `{}` references \\\n@@ -513,7 +513,7 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n         let mut accumulator = Vec::new();\n-        ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n+        input_type.accumulate_lifetimes_in_type(&mut accumulator);\n \n         if accumulator.len() == 1 {\n             // there's a chance that the unique lifetime of this\n@@ -579,7 +579,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n     let (implied_output_region,\n          params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n \n-    let input_ty = ty::mk_tup(this.tcx(), inputs);\n+    let input_ty = this.tcx().mk_tup(inputs);\n \n     let (output, output_span) = match data.output {\n         Some(ref output_ty) => {\n@@ -590,7 +590,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n              output_ty.span)\n         }\n         None => {\n-            (ty::mk_nil(this.tcx()), data.span)\n+            (this.tcx().mk_nil(), data.span)\n         }\n     };\n \n@@ -852,7 +852,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     // this, we currently insert a dummy type and then remove it\n     // later. Yuck.\n \n-    let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    let dummy_self_ty = tcx.mk_infer(ty::FreshTy(0));\n     if self_ty.is_none() { // if converting for an object type\n         let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n         assert!(dummy_substs.self_ty().is_none());                     //                    |\n@@ -924,7 +924,7 @@ fn ast_path_to_ty<'tcx>(\n     // FIXME(#12938): This is a hack until we have full support for DST.\n     if Some(did) == this.tcx().lang_items.owned_box() {\n         assert_eq!(substs.types.len(TypeSpace), 1);\n-        return ty::mk_uniq(this.tcx(), *substs.types.get(TypeSpace, 0));\n+        return this.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n     }\n \n     decl_ty.subst(this.tcx(), &substs)\n@@ -1060,7 +1060,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n         traits::supertraits(tcx, object_trait_ref)\n         .flat_map(|tr| {\n-            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n+            let trait_def = tcx.lookup_trait_def(tr.def_id());\n             trait_def.associated_type_names\n                 .clone()\n                 .into_iter()\n@@ -1078,10 +1078,10 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name,\n-                    ty::item_path_str(tcx, trait_def_id));\n+                    tcx.item_path_str(trait_def_id));\n     }\n \n-    ty::mk_trait(tcx, object.principal, object.bounds)\n+    tcx.mk_trait(object.principal, object.bounds)\n }\n \n fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n@@ -1265,7 +1265,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             _ => unreachable!()\n         }\n     } else {\n-        let trait_items = ty::trait_items(tcx, trait_did);\n+        let trait_items = tcx.trait_items(trait_did);\n         let item = trait_items.iter().find(|i| i.name() == assoc_name);\n         item.expect(\"missing associated type\").def_id()\n     };\n@@ -1290,7 +1290,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let self_ty = if let Some(ty) = opt_self_ty {\n         ty\n     } else {\n-        let path_str = ty::item_path_str(tcx, trait_def_id);\n+        let path_str = tcx.item_path_str(trait_def_id);\n         report_ambiguous_associated_type(tcx,\n                                          span,\n                                          \"Type\",\n@@ -1393,7 +1393,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         def::DefTyParam(space, index, _, name) => {\n             check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n-            ty::mk_param(tcx, space, index, name)\n+            tcx.mk_param(space, index, name)\n         }\n         def::DefSelfTy(_, Some((_, self_ty_id))) => {\n             // Self in impl (we know the concrete type).\n@@ -1411,7 +1411,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         def::DefSelfTy(Some(_), None) => {\n             // Self in trait.\n             check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n-            ty::mk_self_type(tcx)\n+            tcx.mk_self_type()\n         }\n         def::DefAssociatedTy(trait_did, _) => {\n             check_path_args(tcx, &base_segments[..base_segments.len()-2], NO_TPS | NO_REGIONS);\n@@ -1509,7 +1509,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let typ = match ast_ty.node {\n         ast::TyVec(ref ty) => {\n-            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n+            tcx.mk_slice(ast_ty_to_ty(this, rscope, &**ty))\n         }\n         ast::TyObjectSum(ref ty, ref bounds) => {\n             match ast_ty_to_trait_ref(this, rscope, &**ty, bounds) {\n@@ -1527,7 +1527,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         ast::TyPtr(ref mt) => {\n-            ty::mk_ptr(tcx, ty::mt {\n+            tcx.mk_ptr(ty::mt {\n                 ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n                 mutbl: mt.mutbl\n             })\n@@ -1540,13 +1540,13 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     rscope,\n                     Some(ty::ObjectLifetimeDefault::Specific(r)));\n             let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n-            ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n+            tcx.mk_ref(tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n         }\n         ast::TyTup(ref fields) => {\n             let flds = fields.iter()\n                              .map(|t| ast_ty_to_ty(this, rscope, &**t))\n                              .collect();\n-            ty::mk_tup(tcx, flds)\n+            tcx.mk_tup(flds)\n         }\n         ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n         ast::TyBareFn(ref bf) => {\n@@ -1555,7 +1555,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                           \"variadic function must have C calling convention\");\n             }\n             let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n-            ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n+            tcx.mk_fn(None, tcx.mk_bare_fn(bare_fn))\n         }\n         ast::TyPolyTraitRef(ref bounds) => {\n             conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n@@ -1603,11 +1603,11 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 Ok(r) => {\n                     match r {\n                         ConstVal::Int(i) =>\n-                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as usize)),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                                         i as usize),\n                         ConstVal::Uint(i) =>\n-                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as usize)),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                                         i as usize),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n                                       \"expected constant integer expression \\\n@@ -1724,7 +1724,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                     (Some(self_info.untransformed_self_ty), None)\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n-                    (Some(ty::mk_rptr(this.tcx(),\n+                    (Some(this.tcx().mk_ref(\n                                       this.tcx().mk_region(region),\n                                       ty::mt {\n                                         ty: self_info.untransformed_self_ty,\n@@ -1733,7 +1733,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                      Some(region))\n                 }\n                 ty::ByBoxExplicitSelfCategory => {\n-                    (Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty)), None)\n+                    (Some(this.tcx().mk_box(self_info.untransformed_self_ty)), None)\n                 }\n             }\n         }\n@@ -1779,7 +1779,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                                                               implied_output_region,\n                                                               lifetimes_for_params,\n                                                               &**output)),\n-        ast::DefaultReturn(..) => ty::FnConverging(ty::mk_nil(this.tcx())),\n+        ast::DefaultReturn(..) => ty::FnConverging(this.tcx().mk_nil()),\n         ast::NoReturn(..) => ty::FnDiverging\n     };\n \n@@ -2116,8 +2116,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n-                        if ty::try_add_builtin_trait(tcx,\n-                                                     trait_did,\n+                        if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {\n                             let segments = &b.trait_ref.path.segments;\n                             let parameters = &segments[segments.len() - 1].parameters;"}, {"sha": "87f867d7f90acdfe3347e00070711fa3760ad4fe", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -15,7 +15,7 @@ use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n use check::{check_expr_with_lvalue_pref, LvaluePreference};\n@@ -59,8 +59,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n                     if let ty::TyRef(_, mt) = expected_ty.sty {\n                         if let ty::TySlice(_) = mt.ty.sty {\n-                            pat_ty = ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n-                                ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+                            pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                                                     tcx.mk_slice(tcx.types.u8))\n                         }\n                     }\n                 }\n@@ -90,7 +90,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let rhs_ty = fcx.expr_ty(end);\n \n             // Check that both end-points are of numeric or char type.\n-            let numeric_or_char = |t| ty::type_is_numeric(t) || ty::type_is_char(t);\n+            let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n             let lhs_compat = numeric_or_char(lhs_ty);\n             let rhs_compat = numeric_or_char(rhs_ty);\n \n@@ -147,7 +147,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_resolved_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n-            let const_scheme = ty::lookup_item_type(tcx, const_did);\n+            let const_scheme = tcx.lookup_item_type(const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n                                                            &Substs::empty(),\n@@ -171,7 +171,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     // and T is the expected type.\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n-                    let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n+                    let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n \n                     // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                     // required. However, we use equality, which is stronger. See (*) for\n@@ -227,8 +227,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n                                             path, pat.span, pat.id) {\n                 if check_assoc_item_is_const(pcx, def, pat.span) {\n-                    let scheme = ty::lookup_item_type(tcx, def.def_id());\n-                    let predicates = ty::lookup_predicates(tcx, def.def_id());\n+                    let scheme = tcx.lookup_item_type(def.def_id());\n+                    let predicates = tcx.lookup_predicates(def.def_id());\n                     instantiate_path(fcx, segments,\n                                      scheme, &predicates,\n                                      opt_ty, def, pat.span, pat.id);\n@@ -246,7 +246,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let element_tys: Vec<_> =\n                 (0..elements.len()).map(|_| fcx.infcx().next_ty_var())\n                                         .collect();\n-            let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n+            let pat_ty = tcx.mk_tup(element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n             for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n@@ -255,7 +255,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatBox(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n-            let uniq_ty = ty::mk_uniq(tcx, inner_ty);\n+            let uniq_ty = tcx.mk_box(inner_ty);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 // Here, `demand::subtype` is good enough, but I don't\n@@ -274,7 +274,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-            let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n+            let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 // `demand::subtype` would be good enough, but using\n@@ -292,19 +292,19 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n             let pat_ty = match expected_ty.sty {\n-                ty::TyArray(_, size) => ty::mk_vec(tcx, inner_ty, Some({\n+                ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n                     let min_len = before.len() + after.len();\n                     match *slice {\n                         Some(_) => cmp::max(min_len, size),\n                         None => min_len\n                     }\n-                })),\n+                }),\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                    ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n-                        ty: inner_ty,\n-                        mutbl: ty::deref(expected_ty, true).map(|mt| mt.mutbl)\n-                                                           .unwrap_or(ast::MutImmutable)\n+                    tcx.mk_ref(tcx.mk_region(region), ty::mt {\n+                        ty: tcx.mk_slice(inner_ty),\n+                        mutbl: expected_ty.builtin_deref(true).map(|mt| mt.mutbl)\n+                                                              .unwrap_or(ast::MutImmutable)\n                     })\n                 }\n             };\n@@ -321,11 +321,11 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n             if let Some(ref slice) = *slice {\n                 let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                let mutbl = ty::deref(expected_ty, true)\n+                let mutbl = expected_ty.builtin_deref(true)\n                     .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n-                let slice_ty = ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n-                    ty: inner_ty,\n+                let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::mt {\n+                    ty: tcx.mk_slice(inner_ty),\n                     mutbl: mutbl\n                 });\n                 check_pat(pcx, &**slice, slice_ty);\n@@ -411,7 +411,7 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let tcx = pcx.fcx.ccx.tcx;\n     if pat_is_binding(&tcx.def_map, inner) {\n         let expected = fcx.infcx().shallow_resolve(expected);\n-        ty::deref(expected, true).map_or(true, |mt| match mt.ty.sty {\n+        expected.builtin_deref(true).map_or(true, |mt| match mt.ty.sty {\n             ty::TyTrait(_) => {\n                 // This is \"x = SomeTrait\" being reduced from\n                 // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n@@ -485,7 +485,7 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // us to give better error messages (pointing to a usually better\n             // arm for inconsistent arms or to the whole match when a `()` type\n             // is required).\n-            Expectation::ExpectHasType(ety) if ety != ty::mk_nil(fcx.tcx()) => {\n+            Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n                 check_expr_coercable_to_type(fcx, &*arm.body, ety);\n                 ety\n             }\n@@ -499,7 +499,7 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             check_expr_has_type(fcx, &**e, tcx.types.bool);\n         }\n \n-        if ty::type_is_error(result_ty) || ty::type_is_error(bty) {\n+        if result_ty.references_error() || bty.references_error() {\n             tcx.types.err\n         } else {\n             let (origin, expected, found) = match match_src {\n@@ -555,7 +555,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n             return;\n         },\n         _ => {\n-            let def_type = ty::lookup_item_type(tcx, def.def_id());\n+            let def_type = tcx.lookup_item_type(def.def_id());\n             match def_type.ty.sty {\n                 ty::TyStruct(struct_def_id, _) =>\n                     (struct_def_id, struct_def_id),\n@@ -579,8 +579,8 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n \n     instantiate_path(pcx.fcx,\n                      &path.segments,\n-                     ty::lookup_item_type(tcx, enum_def_id),\n-                     &ty::lookup_predicates(tcx, enum_def_id),\n+                     tcx.lookup_item_type(enum_def_id),\n+                     &tcx.lookup_predicates(enum_def_id),\n                      None,\n                      def,\n                      pat.span,\n@@ -595,7 +595,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         .map(|substs| substs.substs.clone())\n         .unwrap_or_else(|| Substs::empty());\n \n-    let struct_fields = ty::struct_fields(tcx, variant_def_id, &item_substs);\n+    let struct_fields = tcx.struct_fields(variant_def_id, &item_substs);\n     check_struct_pat_fields(pcx, pat.span, fields, &struct_fields,\n                             variant_def_id, etc);\n }\n@@ -631,10 +631,10 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n-    let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n-    let ctor_predicates = ty::lookup_predicates(tcx, enum_def);\n-    let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n-        let fn_ret = ty::no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty)).unwrap();\n+    let ctor_scheme = tcx.lookup_item_type(enum_def);\n+    let ctor_predicates = tcx.lookup_predicates(enum_def);\n+    let path_scheme = if ctor_scheme.ty.is_fn() {\n+        let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n         ty::TypeScheme {\n             ty: fn_ret.unwrap(),\n             generics: ctor_scheme.generics,\n@@ -664,14 +664,14 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ty::TyEnum(enum_def_id, expected_substs)\n             if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n         {\n-            let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n+            let variant = tcx.enum_variant_with_id(enum_def_id, def.def_id());\n             (variant.args.iter()\n                          .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n                          .collect(),\n              \"variant\")\n         }\n         ty::TyStruct(struct_def_id, expected_substs) => {\n-            let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n+            let struct_fields = tcx.struct_fields(struct_def_id, expected_substs);\n             (struct_fields.iter()\n                           .map(|field| fcx.instantiate_type_scheme(pat.span,\n                                                                    expected_substs,\n@@ -761,7 +761,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n-                            ty::item_path_str(tcx, struct_id),\n+                            tcx.item_path_str(struct_id),\n                             token::get_ident(field.ident));\n                         tcx.types.err\n                     })"}, {"sha": "4eafbaaf794d21914b5aef521b1f9eb121d79d4d", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -11,7 +11,7 @@\n use middle::infer::InferCtxt;\n use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n-use middle::ty::{self, HasProjectionTypes};\n+use middle::ty::{self, HasTypeFlags};\n use middle::ty_fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -23,7 +23,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_associated_types_in(value={:?})\", value);\n     let mut selcx = SelectionContext::new(infcx, typer);"}, {"sha": "7109e45b55279533f04b9d258ea690160f779e12", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -358,9 +358,8 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 // can't because of the annoying need for a TypeTrace.\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n-                let method_sig =\n-                    ty::no_late_bound_regions(fcx.tcx(),\n-                                              ty::ty_fn_sig(method_callee.ty)).unwrap();\n+                let method_sig = fcx.tcx().no_late_bound_regions(method_callee.ty.fn_sig())\n+                                          .unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={:?}\",\n                        method_callee);\n@@ -371,7 +370,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                     demand::eqtype(fcx, self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n-                let nilty = ty::mk_nil(fcx.tcx());\n+                let nilty = fcx.tcx().mk_nil();\n                 demand::eqtype(fcx,\n                                self.call_expr.span,\n                                method_sig.output.unwrap_or(nilty),"}, {"sha": "49b47da517720117139778d969980462eebaf615", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -45,8 +45,7 @@ use super::structurally_resolved_type;\n \n use lint;\n use middle::cast::{CastKind, CastTy};\n-use middle::ty;\n-use middle::ty::Ty;\n+use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast::UintTy::{TyU8};\n use syntax::codemap::Span;\n@@ -81,7 +80,7 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n         ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n         ty::TyStruct(did, substs) => {\n-            match ty::struct_fields(fcx.tcx(), did, substs).pop() {\n+            match fcx.tcx().struct_fields(did, substs).pop() {\n                 None => None,\n                 Some(f) => unsize_kind(fcx, f.mt.ty)\n             }\n@@ -170,7 +169,7 @@ impl<'tcx> CastCheck<'tcx> {\n     fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n-        if ty::type_is_numeric(t_cast) && ty::type_is_numeric(t_expr) {\n+        if t_cast.is_numeric() && t_expr.is_numeric() {\n             fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n                                     self.expr.id,\n                                     self.span,\n@@ -199,7 +198,7 @@ impl<'tcx> CastCheck<'tcx> {\n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n                self.cast_ty);\n \n-        if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n+        if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);"}, {"sha": "d431c0fda986580839723df4af652c241888c877", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -60,17 +60,13 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         abi::RustCall,\n         expected_sig);\n \n-    let closure_type = ty::mk_closure(fcx.ccx.tcx,\n-                                      expr_def_id,\n-                                      fcx.ccx.tcx.mk_substs(\n-                                        fcx.inh.param_env.free_substs.clone()));\n+    let closure_type = fcx.ccx.tcx.mk_closure(expr_def_id,\n+        fcx.ccx.tcx.mk_substs(fcx.inh.param_env.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n \n-    let fn_sig =\n-        ty::liberate_late_bound_regions(fcx.tcx(),\n-                                        region::DestructionScopeData::new(body.id),\n-                                        &fn_ty.sig);\n+    let fn_sig = fcx.tcx().liberate_late_bound_regions(\n+        region::DestructionScopeData::new(body.id), &fn_ty.sig);\n \n     check_fn(fcx.ccx,\n              ast::Unsafety::Normal,\n@@ -83,7 +79,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `closures` table.\n-    fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n+    fn_ty.sig.0.inputs = vec![fcx.tcx().mk_tup(fn_ty.sig.0.inputs)];\n \n     debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n            expr_def_id,"}, {"sha": "73b9a16d1ebea731bfe9dd6a3e6c6794eb82ef92", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -201,8 +201,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 // &T to autoref to &&T.\n                 return None;\n             }\n-            let ty = ty::mk_rptr(self.tcx(), r_borrow,\n-                                 mt {ty: inner_ty, mutbl: mutbl_b});\n+            let ty = self.tcx().mk_ref(r_borrow,\n+                                        mt {ty: inner_ty, mutbl: mutbl_b});\n             if let Err(err) = self.subtype(ty, b) {\n                 if first_error.is_none() {\n                     first_error = Some(err);\n@@ -271,7 +271,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             _ => (source, None)\n         };\n-        let source = ty::adjust_ty_for_autoref(self.tcx(), source, reborrow);\n+        let source = source.adjust_for_autoref(self.tcx(), reborrow);\n \n         let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n \n@@ -384,7 +384,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n             match b.sty {\n                 ty::TyBareFn(None, _) => {\n-                    let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, fn_ty_a);\n+                    let a_fn_pointer = self.tcx().mk_fn(None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n                     Ok(Some(ty::AdjustReifyFnPointer))\n                 }\n@@ -411,7 +411,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = ty::mk_ptr(self.tcx(), ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = self.tcx().mk_ptr(ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n "}, {"sha": "349d1a8bb65a8e1a0feb9000c3330876bd78a474", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -100,7 +100,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             token::get_name(trait_m.name),\n             impl_m.fty.sig.0.inputs.len(),\n             if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n-            ty::item_path_str(tcx, trait_m.def_id),\n+            tcx.item_path_str(trait_m.def_id),\n             trait_m.fty.sig.0.inputs.len());\n         return;\n     }\n@@ -275,9 +275,9 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // type.\n \n     // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n+    let impl_fty = tcx.mk_fn(None, tcx.mk_bare_fn(impl_m.fty.clone()));\n     let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-    let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n+    let trait_fty = tcx.mk_fn(None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     let err = infcx.commit_if_ok(|snapshot| {\n@@ -296,12 +296,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n-        let impl_fty =\n-            ty::mk_bare_fn(tcx,\n-                           None,\n-                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n-                                                         abi: impl_m.fty.abi,\n-                                                         sig: ty::Binder(impl_sig) }));\n+        let impl_fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: impl_m.fty.unsafety,\n+            abi: impl_m.fty.abi,\n+            sig: ty::Binder(impl_sig)\n+        }));\n         debug!(\"compare_impl_method: impl_fty={:?}\",\n                impl_fty);\n \n@@ -316,12 +315,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n-        let trait_fty =\n-            ty::mk_bare_fn(tcx,\n-                           None,\n-                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: trait_m.fty.unsafety,\n-                                                         abi: trait_m.fty.abi,\n-                                                         sig: ty::Binder(trait_sig) }));\n+        let trait_fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: trait_m.fty.unsafety,\n+            abi: trait_m.fty.abi,\n+            sig: ty::Binder(trait_sig)\n+        }));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\",\n                trait_fty);"}, {"sha": "a48cffb4472f44d9d1664a18a3ade43d384b3d4d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -37,8 +37,8 @@ use syntax::codemap::{self, Span};\n ///\n pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n     let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n-    let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n+                         ty: dtor_self_type } = tcx.lookup_item_type(drop_impl_did);\n+    let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(self_type_did, self_to_impl_substs) |\n         ty::TyStruct(self_type_did, self_to_impl_substs) |\n@@ -91,7 +91,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n     let ty::TypeScheme { generics: ref named_type_generics,\n                          ty: named_type } =\n-        ty::lookup_item_type(tcx, self_type_did);\n+        tcx.lookup_item_type(self_type_did);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     infcx.commit_if_ok(|snapshot| {\n@@ -179,7 +179,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n-    let generic_assumptions = ty::lookup_predicates(tcx, self_type_did);\n+    let generic_assumptions = tcx.lookup_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n@@ -288,7 +288,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         rcx.tcx().sess,\n                         span,\n                         \"overflowed on enum {} variant {} argument {} type: {}\",\n-                        ty::item_path_str(tcx, def_id),\n+                        tcx.item_path_str(def_id),\n                         variant,\n                         arg_index,\n                         detected_on_typ);\n@@ -298,7 +298,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         rcx.tcx().sess,\n                         span,\n                         \"overflowed on struct {} field {} type: {}\",\n-                        ty::item_path_str(tcx, def_id),\n+                        tcx.item_path_str(def_id),\n                         field,\n                         detected_on_typ);\n                 }\n@@ -365,7 +365,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         let (typ, xref_depth) = match typ.sty {\n             ty::TyStruct(struct_did, substs) => {\n                 if opt_phantom_data_def_id == Some(struct_did) {\n-                    let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n+                    let item_type = rcx.tcx().lookup_item_type(struct_did);\n                     let tp_def = item_type.generics.types\n                         .opt_get(subst::TypeSpace, 0).unwrap();\n                     let new_typ = substs.type_for_def(tp_def);\n@@ -471,13 +471,11 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     walker.skip_current_subtree();\n \n                     let fields =\n-                        ty::lookup_struct_fields(rcx.tcx(), struct_did);\n+                        rcx.tcx().lookup_struct_fields(struct_did);\n                     for field in &fields {\n-                        let field_type =\n-                            ty::lookup_field_type(rcx.tcx(),\n-                                                  struct_did,\n-                                                  field.id,\n-                                                  substs);\n+                        let field_type = rcx.tcx().lookup_field_type(struct_did,\n+                                                                     field.id,\n+                                                                     substs);\n                         try!(iterate_over_potentially_unsafe_regions_in_type(\n                             rcx,\n                             breadcrumbs,\n@@ -501,9 +499,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     walker.skip_current_subtree();\n \n                     let all_variant_info =\n-                        ty::substd_enum_variants(rcx.tcx(),\n-                                                 enum_did,\n-                                                 substs);\n+                        rcx.tcx().substd_enum_variants(enum_did, substs);\n                     for variant_info in &all_variant_info {\n                         for (i, arg_type) in variant_info.args.iter().enumerate() {\n                             try!(iterate_over_potentially_unsafe_regions_in_type(\n@@ -591,13 +587,13 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n         DtorKind::KnownDropMethod(dtor_method_did) => {\n-            let impl_did = ty::impl_of_method(tcx, dtor_method_did)\n+            let impl_did = tcx.impl_of_method(dtor_method_did)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_bug(\n                         span, \"no Drop impl found for drop method\")\n                 });\n \n-            let dtor_typescheme = ty::lookup_item_type(tcx, impl_did);\n+            let dtor_typescheme = tcx.lookup_item_type(impl_did);\n             let dtor_generics = dtor_typescheme.generics;\n \n             let mut has_pred_of_interest = false;\n@@ -609,7 +605,7 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     continue;\n                 }\n \n-                for pred in ty::lookup_predicates(tcx, item_def_id).predicates {\n+                for pred in tcx.lookup_predicates(item_def_id).predicates {\n                     let result = match pred {\n                         ty::Predicate::Equate(..) |\n                         ty::Predicate::RegionOutlives(..) |\n@@ -623,7 +619,7 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                         ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n                             let def_id = t_pred.trait_ref.def_id;\n-                            if ty::trait_items(tcx, def_id).len() != 0 {\n+                            if tcx.trait_items(def_id).len() != 0 {\n                                 // If trait has items, assume it adds\n                                 // capability to access borrowed data.\n                                 true"}, {"sha": "5f7a78ec611a29e477b63679f49df5eb490cb1dd", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -108,7 +108,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final `MethodCallee`.\n         let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n+        let fty = self.tcx().mk_fn(None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n@@ -139,7 +139,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             let region = self.infcx().next_region_var(infer::Autoref(self.span));\n             let autoref = ty::AutoPtr(self.tcx().mk_region(region), mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n-                ty::adjust_ty_for_autoref(self.tcx(), target, Some(autoref))\n+                target.adjust_for_autoref(self.tcx(), Some(autoref))\n             }))\n         } else {\n             // No unsizing should be performed without autoref (at\n@@ -179,7 +179,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         if let Some(target) = unsize {\n             target\n         } else {\n-            ty::adjust_ty_for_autoref(self.tcx(), autoderefd_ty, autoref)\n+            autoderefd_ty.adjust_for_autoref(self.tcx(), autoref)\n         }\n     }\n \n@@ -199,7 +199,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     {\n         match pick.kind {\n             probe::InherentImplPick(impl_def_id) => {\n-                assert!(ty::impl_trait_ref(self.tcx(), impl_def_id).is_none(),\n+                assert!(self.tcx().impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n@@ -254,15 +254,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     self.fcx.instantiate_type_scheme(\n                         self.span,\n                         &impl_polytype.substs,\n-                        &ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap());\n+                        &self.tcx().impl_trait_ref(impl_def_id).unwrap());\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n                                                            method_num: method_num,\n                                                            impl_def_id: Some(impl_def_id) });\n                 (impl_trait_ref.substs.clone(), origin)\n             }\n \n             probe::TraitPick(trait_def_id, method_num) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+                let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n@@ -536,8 +536,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 }\n                                 Some(ty::AutoPtr(_, _)) => {\n                                     (adr.autoderefs, adr.unsize.map(|target| {\n-                                        ty::deref(target, false)\n-                                            .expect(\"fixup: AutoPtr is not &T\").ty\n+                                        target.builtin_deref(false)\n+                                              .expect(\"fixup: AutoPtr is not &T\").ty\n                                     }))\n                                 }\n                                 Some(_) => {"}, {"sha": "0f8048f27a0e3bd8bc4c8a88c7dbd9c9bb09b5ab", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -167,7 +167,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            m_name,\n            trait_def_id);\n \n-    let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n+    let trait_def = fcx.tcx().lookup_trait_def(trait_def_id);\n \n     let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n     let input_types = match opt_input_types {\n@@ -224,7 +224,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                                        &method_ty.fty.sig).0;\n     let fn_sig = fcx.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: method_ty.fty.unsafety,\n         abi: method_ty.fty.abi.clone(),\n@@ -359,7 +359,7 @@ fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     item_name: ast::Name)\n                     -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    let trait_items = tcx.trait_items(trait_def_id);\n     trait_items\n         .iter()\n         .enumerate()\n@@ -376,6 +376,6 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .map(|&did| tcx.impl_or_trait_item(did.def_id()))\n         .find(|m| m.name() == item_name)\n }"}, {"sha": "8026fce69ecca5a418d6e46b446fd300eb02b217", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -21,6 +21,7 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty::{self, RegionEscape, Ty, ToPolyTraitRef, TraitRef};\n+use middle::ty::HasTypeFlags;\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -217,9 +218,8 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     match final_ty.sty {\n         ty::TyArray(elem_ty, _) => {\n-            let slice_ty = ty::mk_vec(fcx.tcx(), elem_ty, None);\n             steps.push(CandidateStep {\n-                self_ty: slice_ty,\n+                self_ty: fcx.tcx().mk_slice(elem_ty),\n                 autoderefs: dereferences,\n                 unsize: true\n             });\n@@ -377,7 +377,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<ast::DefId>) {\n         if let Some(impl_def_id) = lang_def_id {\n-            ty::populate_implementations_for_primitive_if_necessary(self.tcx(), impl_def_id);\n+            self.tcx().populate_implementations_for_primitive_if_necessary(impl_def_id);\n \n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n@@ -386,7 +386,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        ty::populate_inherent_implementations_for_type_if_necessary(self.tcx(), def_id);\n+        self.tcx().populate_inherent_implementations_for_type_if_necessary(def_id);\n \n         if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in impl_infos.iter() {\n@@ -528,7 +528,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+            assert!(!trait_ref.substs.types.needs_infer());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -606,7 +606,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n-            ty::trait_items(self.tcx(), trait_def_id);\n+            self.tcx().trait_items(trait_def_id);\n         let matching_index =\n             trait_items.iter()\n                        .position(|item| item.name() == self.item_name);\n@@ -647,7 +647,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                      item: ty::ImplOrTraitItem<'tcx>,\n                                                      item_index: usize)\n     {\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n         trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n@@ -665,7 +665,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             debug!(\"impl_substs={:?}\", impl_substs);\n \n             let impl_trait_ref =\n-                ty::impl_trait_ref(self.tcx(), impl_def_id)\n+                self.tcx().impl_trait_ref(impl_def_id)\n                 .unwrap() // we know this is a trait impl\n                 .subst(self.tcx(), &impl_substs);\n \n@@ -705,7 +705,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             None => { return true; }\n         };\n \n-        let impl_type = ty::lookup_item_type(self.tcx(), impl_def_id);\n+        let impl_type = self.tcx().lookup_item_type(impl_def_id);\n         let impl_simplified_type =\n             match fast_reject::simplify_type(self.tcx(), impl_type.ty, false) {\n                 Some(simplified_type) => simplified_type,\n@@ -759,7 +759,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // for the purposes of our method lookup, we only take\n             // receiver type into account, so we can just substitute\n             // fresh types here to use during substitution and subtyping.\n-            let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n             let substs = self.infcx().fresh_substs_for_trait(self.span,\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n@@ -802,8 +802,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n                    projection_trait_ref);\n \n-            let trait_predicates = ty::lookup_predicates(self.tcx(),\n-                                                         projection_trait_ref.def_id);\n+            let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n             let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n@@ -894,7 +893,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 match source {\n                     TraitSource(id) => id,\n                     ImplSource(impl_id) => {\n-                        match ty::trait_id_of_impl(tcx, impl_id) {\n+                        match tcx.trait_id_of_impl(impl_id) {\n                             Some(id) => id,\n                             None =>\n                                 tcx.sess.span_bug(span,\n@@ -928,7 +927,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_step: step={:?}\", step);\n \n-        if ty::type_is_error(step.self_ty) {\n+        if step.self_ty.references_error() {\n             return None;\n         }\n \n@@ -983,7 +982,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Search through mutabilities in order to find one where pick works:\n         [ast::MutImmutable, ast::MutMutable].iter().filter_map(|&m| {\n-            let autoref_ty = ty::mk_rptr(tcx, region, ty::mt {\n+            let autoref_ty = tcx.mk_ref(region, ty::mt {\n                 ty: step.self_ty,\n                 mutbl: m\n             });\n@@ -1081,7 +1080,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n+                    let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n                     let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n                     let traits::Normalized { value: impl_bounds,\n                                              obligations: norm_obligations } =\n@@ -1266,7 +1265,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           impl_def_id: ast::DefId)\n                           -> (Ty<'tcx>, subst::Substs<'tcx>)\n     {\n-        let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n+        let impl_pty = self.tcx().lookup_item_type(impl_def_id);\n \n         let type_vars =\n             impl_pty.generics.types.map(\n@@ -1301,7 +1300,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        ty::erase_late_bound_regions(self.tcx(), value)\n+        self.tcx().erase_late_bound_regions(value)\n     }\n }\n \n@@ -1314,7 +1313,7 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .map(|&did| tcx.impl_or_trait_item(did.def_id()))\n         .find(|item| item.name() == item_name)\n }\n \n@@ -1325,7 +1324,7 @@ fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     item_name: ast::Name)\n                     -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    let trait_items = tcx.trait_items(trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n@@ -1357,7 +1356,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n+                    assert!(!trait_ref.substs().types.needs_infer());\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }"}, {"sha": "b193ddcb2134903bb287ddde853011e58e8d597b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -15,7 +15,7 @@ use CrateCtxt;\n \n use astconv::AstConv;\n use check::{self, FnCtxt};\n-use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate};\n+use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, HasTypeFlags};\n use middle::def;\n use middle::lang_items::FnOnceTraitLangItem;\n use middle::subst::Substs;\n@@ -40,7 +40,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               error: MethodError<'tcx>)\n {\n     // avoid suggestions when we don't know what's going on.\n-    if ty::type_is_error(rcvr_ty) {\n+    if rcvr_ty.references_error() {\n         return\n     }\n \n@@ -66,7 +66,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // If the item has the name of a field, give a help note\n             if let (&ty::TyStruct(did, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                let fields = ty::lookup_struct_fields(cx, did);\n+                let fields = cx.lookup_struct_fields(did);\n \n                 if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n                     let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n@@ -89,7 +89,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     };\n \n                     // Determine if the field can be used as a function in some way\n-                    let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n+                    let field_ty = cx.lookup_field_type(did, field.id, substs);\n                     if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n                         let infcx = fcx.infcx();\n                         infcx.probe(|_| {\n@@ -159,7 +159,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n                                item_name,\n-                               ty::item_path_str(fcx.tcx(), trait_def_id));\n+                               fcx.tcx().item_path_str(trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                         msg, pprust::expr_to_string(callee))\n@@ -188,11 +188,12 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n \n-                    let insertion = match ty::impl_trait_ref(fcx.tcx(), impl_did) {\n+                    let insertion = match fcx.tcx().impl_trait_ref(impl_did) {\n                         None => format!(\"\"),\n-                        Some(trait_ref) => format!(\" of the trait `{}`\",\n-                                                   ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id)),\n+                        Some(trait_ref) => {\n+                            format!(\" of the trait `{}`\",\n+                                    fcx.tcx().item_path_str(trait_ref.def_id))\n+                        }\n                     };\n \n                     span_note!(fcx.sess(), item_span,\n@@ -207,7 +208,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n                                idx + 1,\n-                               ty::item_path_str(fcx.tcx(), trait_did));\n+                               fcx.tcx().item_path_str(trait_did));\n                 }\n             }\n         }\n@@ -243,7 +244,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx.sess().fileline_help(span,\n                                      &*format!(\"candidate #{}: use `{}`\",\n                                                i + 1,\n-                                               ty::item_path_str(fcx.tcx(), *trait_did)))\n+                                               fcx.tcx().item_path_str(*trait_did)))\n \n         }\n         return\n@@ -289,7 +290,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx.sess().fileline_help(span,\n                                      &*format!(\"candidate #{}: `{}`\",\n                                                i + 1,\n-                                               ty::item_path_str(fcx.tcx(), trait_info.def_id)))\n+                                               fcx.tcx().item_path_str(trait_info.def_id)))\n         }\n     }\n }"}, {"sha": "299ccd579ccb77130cd113dbf6e1864ab5aa7c46", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 191, "deletions": 216, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -96,8 +96,7 @@ use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n-use middle::ty::liberate_late_bound_regions;\n+use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::{MethodCall, MethodCallee, MethodMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n@@ -229,7 +228,7 @@ impl<'tcx> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.infcx().shallow_resolve(ety);\n-                if !ty::type_is_ty_var(ety) {\n+                if !ety.is_ty_var() {\n                     ExpectHasType(ety)\n                 } else {\n                     NoExpectation\n@@ -308,7 +307,7 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         let ty = self.adjust_expr_ty(expr, self.inh.adjustments.borrow().get(&expr.id));\n         self.resolve_type_vars_or_error(&ty)\n     }\n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         !traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n     }\n@@ -363,9 +362,8 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n     fn closure_upvars(&self,\n                       def_id: ast::DefId,\n                       substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        ty::closure_upvars(self, def_id, substs)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>> {\n+        ty::ctxt::closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -397,7 +395,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n@@ -430,7 +428,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::empty_parameter_environment(ccx.tcx);\n+    let param_env = ccx.tcx.empty_parameter_environment();\n     Inherited::new(ccx.tcx, param_env)\n }\n \n@@ -512,9 +510,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n             let fn_sig =\n-                liberate_late_bound_regions(ccx.tcx,\n-                                            region::DestructionScopeData::new(body.id),\n-                                            &fn_sig);\n+                ccx.tcx.liberate_late_bound_regions(region::DestructionScopeData::new(body.id),\n+                                                    &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n@@ -718,15 +715,15 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     check_representable(tcx, span, id, \"struct\");\n     check_instantiable(tcx, span, id);\n \n-    if ty::lookup_simd(tcx, local_def(id)) {\n+    if tcx.lookup_simd(local_def(id)) {\n         check_simd(tcx, span, id);\n     }\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item_type(it.id={}, it.ident={})\",\n            it.id,\n-           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+           ccx.tcx.item_path_str(local_def(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n@@ -741,7 +738,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemFn(..) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n-          match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n+          match ccx.tcx.impl_trait_ref(local_def(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n@@ -758,7 +755,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         check_struct(ccx, it.id, it.span);\n       }\n       ast::ItemTy(ref t, ref generics) => {\n-        let pty_ty = ty::node_id_to_type(ccx.tcx, it.id);\n+        let pty_ty = ccx.tcx.node_id_to_type(it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, pty_ty);\n       }\n       ast::ItemForeignMod(ref m) => {\n@@ -768,7 +765,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n+                let pty = ccx.tcx.lookup_item_type(local_def(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -790,18 +787,18 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item_body(it.id={}, it.ident={})\",\n            it.id,\n-           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+           ccx.tcx.item_path_str(local_def(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       ast::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let fn_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n-        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let impl_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n \n         for impl_item in impl_items {\n             match impl_item.node {\n@@ -820,7 +817,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         }\n       }\n       ast::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n+        let trait_def = ccx.tcx.lookup_trait_def(local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 ast::ConstTraitItem(_, Some(ref expr)) => {\n@@ -921,7 +918,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             item_generics, id);\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n \n-    let fty = ty::node_id_to_type(ccx.tcx, id);\n+    let fty = ccx.tcx.node_id_to_type(id);\n     debug!(\"check_method_body: fty={:?}\", fty);\n \n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n@@ -933,16 +930,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_items: &[P<ast::ImplItem>]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n-    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n+    let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n             ast::ConstImplItem(..) => {\n                 let impl_const_def_id = local_def(impl_item.id);\n-                let impl_const_ty = ty::impl_or_trait_item(ccx.tcx,\n-                                                           impl_const_def_id);\n+                let impl_const_ty = ccx.tcx.impl_or_trait_item(impl_const_def_id);\n \n                 // Find associated const definition.\n                 let opt_associated_const =\n@@ -985,8 +981,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n \n                 let impl_method_def_id = local_def(impl_item.id);\n-                let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n-                                                          impl_method_def_id);\n+                let impl_item_ty = ccx.tcx.impl_or_trait_item(impl_method_def_id);\n \n                 // If this is an impl of a trait method, find the\n                 // corresponding method definition in the trait.\n@@ -1027,8 +1022,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n             ast::TypeImplItem(_) => {\n                 let typedef_def_id = local_def(impl_item.id);\n-                let typedef_ty = ty::impl_or_trait_item(ccx.tcx,\n-                                                        typedef_def_id);\n+                let typedef_ty = ccx.tcx.impl_or_trait_item(typedef_def_id);\n \n                 // If this is an impl of an associated type, find the\n                 // corresponding type definition in the trait.\n@@ -1067,8 +1061,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     // Check for missing items from trait\n-    let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n-    let associated_consts = ty::associated_consts(tcx, impl_trait_ref.def_id);\n+    let provided_methods = tcx.provided_trait_methods(impl_trait_ref.def_id);\n+    let associated_consts = tcx.associated_consts(impl_trait_ref.def_id);\n     let mut missing_items = Vec::new();\n     for trait_item in trait_items.iter() {\n         match *trait_item {\n@@ -1146,7 +1140,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 ast::MutMutable => \"mut \",\n                 ast::MutImmutable => \"\"\n             };\n-            if ty::type_is_trait(t_cast) {\n+            if t_cast.is_trait() {\n                 match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                     Ok(s) => {\n                         fcx.tcx().sess.span_suggestion(t_span,\n@@ -1189,13 +1183,13 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn get_item_type_scheme(&self, _: Span, id: ast::DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n-        Ok(ty::lookup_item_type(self.tcx(), id))\n+        Ok(self.tcx().lookup_item_type(id))\n     }\n \n     fn get_trait_def(&self, _: Span, id: ast::DefId)\n                      -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n-        Ok(ty::lookup_trait_def(self.tcx(), id))\n+        Ok(self.tcx().lookup_trait_def(id))\n     }\n \n     fn ensure_super_predicates(&self, _: Span, _: ast::DefId) -> Result<(), ErrorReported> {\n@@ -1238,7 +1232,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        let trait_def = ty::lookup_trait_def(self.ccx.tcx, trait_def_id);\n+        let trait_def = self.ccx.tcx.lookup_trait_def(trait_def_id);\n         trait_def.associated_type_names.contains(&assoc_name)\n     }\n \n@@ -1296,23 +1290,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_type_vars_if_possible(ty={:?})\", ty);\n \n-        // No ty::infer()? Nothing needs doing.\n-        if !ty::type_has_ty_infer(ty) {\n+        // No TyInfer()? Nothing needs doing.\n+        if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        if !ty::type_has_ty_infer(ty) {\n+        if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n         self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        if !ty::type_has_ty_infer(ty) {\n+        if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n@@ -1333,9 +1327,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// main checking when doing a second pass before writeback. The\n     /// justification is that writeback will produce an error for\n     /// these unconstrained type variables.\n-    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n-        let t = self.infcx().resolve_type_vars_if_possible(t);\n-        if ty::type_has_ty_infer(t) || ty::type_is_error(t) { Err(()) } else { Ok(t) }\n+    fn resolve_type_vars_or_error(&self, ty: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let ty = self.infcx().resolve_type_vars_if_possible(ty);\n+        if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }\n     }\n \n     fn record_deferred_call_resolution(&self,\n@@ -1377,7 +1371,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (_, &mut ref ty) in &mut *self.inh.node_types.borrow_mut() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n             } else {\n                 match self.infcx().type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n@@ -1443,7 +1437,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n@@ -1469,7 +1463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n     }\n@@ -1506,9 +1500,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             -> TypeAndSubsts<'tcx>\n     {\n         let type_scheme =\n-            ty::lookup_item_type(self.tcx(), def_id);\n+            self.tcx().lookup_item_type(def_id);\n         let type_predicates =\n-            ty::lookup_predicates(self.tcx(), def_id);\n+            self.tcx().lookup_predicates(def_id);\n         let substs =\n             self.infcx().fresh_substs_for_generics(\n                 span,\n@@ -1543,7 +1537,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx();\n \n         let ty::TypeScheme { generics, ty: decl_ty } =\n-            ty::lookup_item_type(tcx, did);\n+            tcx.lookup_item_type(did);\n \n         let substs = astconv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n@@ -1557,7 +1551,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_nil(self.tcx()));\n+        self.write_ty(node_id, self.tcx().mk_nil());\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx().types.err);\n@@ -1651,14 +1645,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let raw_ty = self.expr_ty(expr);\n         let raw_ty = self.infcx().shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n-        ty::adjust_ty(self.tcx(),\n-                      expr.span,\n-                      expr.id,\n-                      raw_ty,\n-                      adjustment,\n-                      |method_call| self.inh.method_map.borrow()\n-                                                       .get(&method_call)\n-                                                       .map(|method| resolve_ty(method.ty)))\n+        raw_ty.adjust(self.tcx(), expr.span, expr.id, adjustment, |method_call| {\n+            self.inh.method_map.borrow().get(&method_call)\n+                                        .map(|method| resolve_ty(method.ty))\n+        })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n@@ -1798,7 +1788,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                            -> Option<Ty<'tcx>>\n     {\n         let o_field = items.iter().find(|f| f.name == fieldname);\n-        o_field.map(|f| ty::lookup_field_type(self.tcx(), class_id, f.id, substs))\n+        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n \n@@ -1811,7 +1801,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                -> Option<Ty<'tcx>>\n     {\n         let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n-        o_field.map(|f| ty::lookup_field_type(self.tcx(), class_id, f.id, substs))\n+        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n \n@@ -1948,13 +1938,13 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             UnresolvedTypeAction::Ignore => {\n                 // We can continue even when the type cannot be resolved\n-                // (i.e. it is an inference variable) because `ty::deref`\n+                // (i.e. it is an inference variable) because `Ty::builtin_deref`\n                 // and `try_overloaded_deref` both simply return `None`\n                 // in such a case without producing spurious errors.\n                 fcx.resolve_type_vars_if_possible(t)\n             }\n         };\n-        if ty::type_is_error(resolved_t) {\n+        if resolved_t.references_error() {\n             return (resolved_t, autoderefs, None);\n         }\n \n@@ -1964,7 +1954,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let mt = match ty::deref(resolved_t, false) {\n+        let mt = match resolved_t.builtin_deref(false) {\n             Some(mt) => Some(mt),\n             None => {\n                 let method_call =\n@@ -2045,15 +2035,15 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Some(method) => {\n             // extract method method return type, which will be &T;\n             // all LB regions should have been instantiated during method lookup\n-            let ret_ty = ty::ty_fn_ret(method.ty);\n-            let ret_ty = ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap();\n+            let ret_ty = method.ty.fn_ret();\n+            let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n             if let Some(method_call) = method_call {\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n             }\n \n             // method returns &T, but the type as visible to user is T, so deref\n-            ty::deref(ret_ty, true)\n+            ret_ty.builtin_deref(true)\n         }\n         None => None,\n     }\n@@ -2089,7 +2079,7 @@ fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // After we have fully autoderef'd, if the resulting type is [T; n], then\n     // do a final unsized coercion to yield [T].\n     if let ty::TyArray(element_ty, _) = ty.sty {\n-        let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n+        let adjusted_ty = fcx.tcx().mk_slice(element_ty);\n         try_index_step(fcx, MethodCall::expr(expr.id), expr, base_expr,\n                        adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n     } else {\n@@ -2125,7 +2115,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let input_ty = fcx.infcx().next_ty_var();\n \n     // First, try built-in indexing.\n-    match (ty::index(adjusted_ty), &index_ty.sty) {\n+    match (adjusted_ty.builtin_index(), &index_ty.sty) {\n         (Some(ty), &ty::TyUint(ast::TyUs)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n@@ -2186,12 +2176,12 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          tuple_arguments: TupleArgumentsFlag,\n                                          expected: Expectation<'tcx>)\n                                          -> ty::FnOutput<'tcx> {\n-    if ty::type_is_error(method_fn_ty) {\n+    if method_fn_ty.references_error() {\n         let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n \n         let err_inputs = match tuple_arguments {\n             DontTupleArguments => err_inputs,\n-            TupleArguments => vec![ty::mk_tup(fcx.tcx(), err_inputs)],\n+            TupleArguments => vec![fcx.tcx().mk_tup(err_inputs)],\n         };\n \n         check_argument_types(fcx,\n@@ -2433,17 +2423,15 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n+        ast::LitStr(..) => tcx.mk_static_str(),\n         ast::LitBinary(ref v) => {\n-            ty::mk_rptr(tcx, tcx.mk_region(ty::ReStatic), ty::mt {\n-                ty: ty::mk_vec(tcx, tcx.types.u8, Some(v.len())),\n-                mutbl: ast::MutImmutable,\n-            })\n+            tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                            tcx.mk_array(tcx.types.u8, v.len()))\n         }\n         ast::LitByte(_) => tcx.types.u8,\n         ast::LitChar(_) => tcx.types.char,\n-        ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(tcx, t),\n-        ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(tcx, t),\n+        ast::LitInt(_, ast::SignedIntLit(t, _)) => tcx.mk_mach_int(t),\n+        ast::LitInt(_, ast::UnsignedIntLit(t)) => tcx.mk_mach_uint(t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n@@ -2455,9 +2443,9 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             });\n             opt_ty.unwrap_or_else(\n-                || ty::mk_int_var(tcx, fcx.infcx().next_int_var_id()))\n+                || tcx.mk_int_var(fcx.infcx().next_int_var_id()))\n         }\n-        ast::LitFloat(_, t) => ty::mk_mach_float(tcx, t),\n+        ast::LitFloat(_, t) => tcx.mk_mach_float(t),\n         ast::LitFloatUnsuffixed(_) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n@@ -2466,7 +2454,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             });\n             opt_ty.unwrap_or_else(\n-                || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n+                || tcx.mk_float_var(fcx.infcx().next_float_var_id()))\n         }\n         ast::LitBool(_) => tcx.types.bool\n     }\n@@ -2530,7 +2518,7 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               -> TypeAndSubsts<'tcx> {\n     let tcx = fcx.tcx();\n \n-    let ity = ty::lookup_item_type(tcx, did);\n+    let ity = tcx.lookup_item_type(did);\n     let (n_tps, rps, raw_ty) =\n         (ity.generics.types.len(subst::TypeSpace),\n          ity.generics.regions.get_slice(subst::TypeSpace),\n@@ -2607,7 +2595,7 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n /// Invariant:\n /// If an expression has any sub-expressions that result in a type error,\n-/// inspecting that expression's type with `ty::type_is_error` will return\n+/// inspecting that expression's type with `ty.references_error()` will return\n /// true. Likewise, if an expression is known to diverge, inspecting its\n /// type with `ty::type_is_bot` will return true (n.b.: since Rust is\n /// strict, _|_ can appear in the type of an expression that does not,\n@@ -2705,12 +2693,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                         infer::IfExpressionWithNoElse(sp),\n                                         false,\n                                         then_ty,\n-                                        ty::mk_nil(fcx.tcx()))\n+                                        fcx.tcx().mk_nil())\n             }\n         };\n \n         let cond_ty = fcx.expr_ty(cond_expr);\n-        let if_ty = if ty::type_is_error(cond_ty) {\n+        let if_ty = if cond_ty.references_error() {\n             fcx.tcx().types.err\n         } else {\n             branches_ty\n@@ -2740,7 +2728,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n-                        let fields = ty::lookup_struct_fields(tcx, base_id);\n+                        let fields = tcx.lookup_struct_fields(base_id);\n                         fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n                     }\n@@ -2796,7 +2784,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let name = &ident;\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let fields = ty::lookup_struct_fields(tcx, id);\n+        let fields = tcx.lookup_struct_fields(id);\n         let mut best = None;\n         for elem in &fields {\n             let n = elem.name.as_str();\n@@ -2841,10 +2829,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   |base_t, _| {\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n-                        tuple_like = ty::is_tuple_struct(tcx, base_id);\n+                        tuple_like = tcx.is_tuple_struct(base_id);\n                         if tuple_like {\n                             debug!(\"tuple struct named {:?}\",  base_t);\n-                            let fields = ty::lookup_struct_fields(tcx, base_id);\n+                            let fields = tcx.lookup_struct_fields(base_id);\n                             fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n                         } else {\n@@ -2917,8 +2905,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         field.ident.span,\n                         |actual| match enum_id_opt {\n                             Some(enum_id) => {\n-                                let variant_type = ty::enum_variant_with_id(tcx,\n-                                                                            enum_id,\n+                                let variant_type = tcx.enum_variant_with_id(enum_id,\n                                                                             class_id);\n                                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n                                         actual, variant_type.name.as_str(),\n@@ -2936,7 +2923,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let skip_fields = ast_fields.iter().map(|ref x| x.ident.node.name.as_str());\n                     let actual_id = match enum_id_opt {\n                         Some(_) => class_id,\n-                        None => ty::ty_to_def_id(struct_ty).unwrap()\n+                        None => struct_ty.ty_to_def_id().unwrap()\n                     };\n                     suggest_field_names(actual_id, &field.ident, tcx, skip_fields.collect());\n                     error_happened = true;\n@@ -2949,8 +2936,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 Some((field_id, false)) => {\n                     expected_field_type =\n-                        ty::lookup_field_type(\n-                            tcx, class_id, field_id, substitutions);\n+                        tcx.lookup_field_type(class_id, field_id, substitutions);\n                     expected_field_type =\n                         fcx.normalize_associated_types_in(\n                             field.span, &expected_field_type);\n@@ -2991,8 +2977,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         if !error_happened {\n-            fcx.write_ty(node_id, ty::mk_struct(fcx.ccx.tcx,\n-                                class_id, substitutions));\n+            fcx.write_ty(node_id, fcx.ccx.tcx.mk_struct(class_id, substitutions));\n         }\n     }\n \n@@ -3011,7 +2996,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         } = fcx.instantiate_type(span, class_id);\n \n         // Look up and check the fields.\n-        let class_fields = ty::lookup_struct_fields(tcx, class_id);\n+        let class_fields = tcx.lookup_struct_fields(class_id);\n         check_struct_or_variant_fields(fcx,\n                                        struct_type,\n                                        span,\n@@ -3022,7 +3007,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n-        if ty::type_is_error(fcx.node_ty(id)) {\n+        if fcx.node_ty(id).references_error() {\n             struct_type = tcx.types.err;\n         }\n \n@@ -3054,7 +3039,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         } = fcx.instantiate_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n-        let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n+        let variant_fields = tcx.lookup_struct_fields(variant_id);\n         check_struct_or_variant_fields(fcx,\n                                        enum_type,\n                                        span,\n@@ -3102,7 +3087,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n                   if tcx.lang_items.exchange_heap() == Some(def_id) {\n-                      fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n+                      fcx.write_ty(id, tcx.mk_box(referent_ty));\n                       checked = true\n                   }\n               }\n@@ -3153,14 +3138,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx, &**oprnd, expected_inner, lvalue_pref);\n         let mut oprnd_t = fcx.expr_ty(&**oprnd);\n \n-        if !ty::type_is_error(oprnd_t) {\n+        if !oprnd_t.references_error() {\n             match unop {\n                 ast::UnUniq => {\n-                    oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n+                    oprnd_t = tcx.mk_box(oprnd_t);\n                 }\n                 ast::UnDeref => {\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n-                    oprnd_t = match ty::deref(oprnd_t, true) {\n+                    oprnd_t = match oprnd_t.builtin_deref(true) {\n                         Some(mt) => mt.ty,\n                         None => match try_overloaded_deref(fcx, expr.span,\n                                                            Some(MethodCall::expr(expr.id)),\n@@ -3179,8 +3164,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 ast::UnNot => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n-                    if !(ty::type_is_integral(oprnd_t) ||\n-                         oprnd_t.sty == ty::TyBool) {\n+                    if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                         oprnd_t = op::check_user_unop(fcx, \"!\", \"not\",\n                                                       tcx.lang_items.not_trait(),\n                                                       expr, &**oprnd, oprnd_t, unop);\n@@ -3189,8 +3173,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 ast::UnNeg => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n-                    if !(ty::type_is_integral(oprnd_t) ||\n-                         ty::type_is_fp(oprnd_t)) {\n+                    if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                         oprnd_t = op::check_user_unop(fcx, \"-\", \"neg\",\n                                                       tcx.lang_items.neg_trait(),\n                                                       expr, &**oprnd, oprnd_t, unop);\n@@ -3213,7 +3196,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                    if ty::expr_is_lval(fcx.tcx(), &**oprnd) {\n+                    if fcx.tcx().expr_is_lval(&**oprnd) {\n                         // Lvalues may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -3232,7 +3215,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                     lvalue_pref);\n \n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n-        let oprnd_t = if ty::type_is_error(tm.ty) {\n+        let oprnd_t = if tm.ty.references_error() {\n             tcx.types.err\n         } else {\n             // Note: at this point, we cannot say what the best lifetime\n@@ -3249,7 +3232,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             // value whose address was taken can actually be made to live\n             // as long as it needs to live.\n             let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n-            ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n+            tcx.mk_ref(tcx.mk_region(region), tm)\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -3310,7 +3293,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 match *expr_opt {\n                     None =>\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n-                                                    result_type, ty::mk_nil(fcx.tcx())) {\n+                                                    result_type, fcx.tcx().mk_nil()) {\n                             span_err!(tcx.sess, expr.span, E0069,\n                                 \"`return;` in a function whose return type is \\\n                                  not `()`\");\n@@ -3341,7 +3324,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, &**lhs) {\n+        if !tcx.expr_is_lval(&**lhs) {\n             span_err!(tcx.sess, expr.span, E0070,\n                 \"illegal left-hand side expression\");\n         }\n@@ -3352,7 +3335,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n \n-        if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n+        if lhs_ty.references_error() || rhs_ty.references_error() {\n             fcx.write_error(id);\n         } else {\n             fcx.write_nil(id);\n@@ -3370,7 +3353,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_block_no_value(fcx, &**body);\n         let cond_ty = fcx.expr_ty(&**cond);\n         let body_ty = fcx.node_ty(body.id);\n-        if ty::type_is_error(cond_ty) || ty::type_is_error(body_ty) {\n+        if cond_ty.references_error() || body_ty.references_error() {\n             fcx.write_error(id);\n         }\n         else {\n@@ -3409,7 +3392,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n-              rest_err || ty::type_is_error(a)});\n+              rest_err || a.references_error()});\n         if args_err {\n             fcx.write_error(id);\n         }\n@@ -3427,7 +3410,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let t_expr = fcx.expr_ty(e);\n \n         // Eagerly check for some obvious errors.\n-        if ty::type_is_error(t_expr) {\n+        if t_expr.references_error() {\n             fcx.write_error(id);\n         } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n             report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);\n@@ -3465,12 +3448,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 t\n             }\n         };\n-        let typ = ty::mk_vec(tcx, typ, Some(args.len()));\n+        let typ = tcx.mk_array(typ, args.len());\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, tcx.types.usize);\n-        let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n+        let count = fcx.tcx().eval_repeat_count(&**count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n@@ -3504,10 +3487,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 ty::BoundCopy);\n         }\n \n-        if ty::type_is_error(element_ty) {\n+        if element_ty.references_error() {\n             fcx.write_error(id);\n         } else {\n-            let t = ty::mk_vec(tcx, t, Some(count));\n+            let t = tcx.mk_array(t, count);\n             fcx.write_ty(id, t);\n         }\n       }\n@@ -3532,13 +3515,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.expr_ty(&**e)\n                 }\n             };\n-            err_field = err_field || ty::type_is_error(t);\n+            err_field = err_field || t.references_error();\n             t\n         }).collect();\n         if err_field {\n             fcx.write_error(id);\n         } else {\n-            let typ = ty::mk_tup(tcx, elt_ts);\n+            let typ = tcx.mk_tup(elt_ts);\n             fcx.write_ty(id, typ);\n         }\n       }\n@@ -3563,7 +3546,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             },\n             def => {\n                 // Verify that this was actually a struct.\n-                let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n+                let typ = fcx.ccx.tcx.lookup_item_type(def.def_id());\n                 match typ.ty.sty {\n                     ty::TyStruct(struct_did, _) => {\n                         check_struct_constructor(fcx,\n@@ -3592,7 +3575,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // the resulting structure type. This is needed to handle type\n         // parameters correctly.\n         let actual_structure_type = fcx.expr_ty(&*expr);\n-        if !ty::type_is_error(actual_structure_type) {\n+        if !actual_structure_type.references_error() {\n             let type_and_substs = fcx.instantiate_struct_literal_ty(struct_id, path);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n@@ -3610,7 +3593,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             .ty_to_string(\n                                                 actual_structure_type),\n                                          type_error);\n-                    ty::note_and_explain_type_err(tcx, &type_error, path.span);\n+                    tcx.note_and_explain_type_err(&type_error, path.span);\n                 }\n             }\n         }\n@@ -3630,9 +3613,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let base_t = fcx.expr_ty(&**base);\n           let idx_t = fcx.expr_ty(&**idx);\n \n-          if ty::type_is_error(base_t) {\n+          if base_t.references_error() {\n               fcx.write_ty(id, base_t);\n-          } else if ty::type_is_error(idx_t) {\n+          } else if idx_t.references_error() {\n               fcx.write_ty(id, idx_t);\n           } else {\n               let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n@@ -3671,8 +3654,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               (Some(ty), None) | (None, Some(ty)) => {\n                   Some(ty)\n               }\n-              (Some(t_start), Some(t_end)) if (ty::type_is_error(t_start) ||\n-                                               ty::type_is_error(t_end)) => {\n+              (Some(t_start), Some(t_end)) if (t_start.references_error() ||\n+                                               t_end.references_error()) => {\n                   Some(fcx.tcx().types.err)\n               }\n               (Some(t_start), Some(t_end)) => {\n@@ -3690,7 +3673,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           // some bounds, then we'll need to check `t_start` against them here.\n \n           let range_type = match idx_type {\n-            Some(idx_type) if ty::type_is_error(idx_type) => {\n+            Some(idx_type) if idx_type.references_error() => {\n                 fcx.tcx().types.err\n             }\n             Some(idx_type) => {\n@@ -3705,7 +3688,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 };\n \n                 if let Some(did) = did {\n-                    let predicates = ty::lookup_predicates(tcx, did);\n+                    let predicates = tcx.lookup_predicates(did);\n                     let substs = Substs::new_type(vec![idx_type], vec![]);\n                     let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n                     fcx.add_obligations_for_parameters(\n@@ -3714,7 +3697,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                      traits::ItemObligation(did)),\n                         &bounds);\n \n-                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(did, tcx.mk_substs(substs))\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -3724,7 +3707,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Neither start nor end => RangeFull\n                 if let Some(did) = tcx.lang_items.range_full_struct() {\n                     let substs = Substs::new_type(vec![], vec![]);\n-                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(did, tcx.mk_substs(substs))\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -3765,7 +3748,7 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                                 node_id: ast::NodeId) -> bool {\n         match def {\n             def::DefAssociatedConst(..) => {\n-                if ty::type_has_params(ty) || ty::type_has_self(ty) {\n+                if ty.has_param_types() || ty.has_self_ty() {\n                     span_err!(fcx.sess(), span, E0329,\n                               \"Associated consts cannot depend \\\n                                on type parameters or Self.\");\n@@ -3933,7 +3916,7 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)\n     if let Some(ref init) = local.init {\n         check_decl_initializer(fcx, local, &**init);\n         let init_ty = fcx.expr_ty(&**init);\n-        if ty::type_is_error(init_ty) {\n+        if init_ty.references_error() {\n             fcx.write_ty(local.id, init_ty);\n         }\n     }\n@@ -3944,7 +3927,7 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)\n     };\n     _match::check_pat(&pcx, &*local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n-    if ty::type_is_error(pat_ty) {\n+    if pat_ty.references_error() {\n         fcx.write_ty(local.id, pat_ty);\n     }\n }\n@@ -3961,25 +3944,25 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n               check_decl_local(fcx, &**l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || fcx.infcx().type_var_diverges(l_t);\n-              saw_err = saw_err || ty::type_is_error(l_t);\n+              saw_err = saw_err || l_t.references_error();\n           }\n           ast::DeclItem(_) => {/* ignore for now */ }\n         }\n       }\n       ast::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, &**expr, ty::mk_nil(fcx.tcx()));\n+        check_expr_has_type(fcx, &**expr, fcx.tcx().mk_nil());\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n-        saw_err = saw_err || ty::type_is_error(expr_ty);\n+        saw_err = saw_err || expr_ty.references_error();\n       }\n       ast::StmtSemi(ref expr, id) => {\n         node_id = id;\n         check_expr(fcx, &**expr);\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot |= fcx.infcx().type_var_diverges(expr_ty);\n-        saw_err |= ty::type_is_error(expr_ty);\n+        saw_err |= expr_ty.references_error();\n       }\n       ast::StmtMac(..) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n     }\n@@ -3995,12 +3978,12 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n }\n \n pub fn check_block_no_value<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, blk: &'tcx ast::Block)  {\n-    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n+    check_block_with_expected(fcx, blk, ExpectHasType(fcx.tcx().mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n-    if ty::type_is_error(blkty) {\n+    if blkty.references_error() {\n         fcx.write_error(blk.id);\n     } else {\n-        let nilty = ty::mk_nil(fcx.tcx());\n+        let nilty = fcx.tcx().mk_nil();\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n }\n@@ -4041,7 +4024,7 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             warned = true;\n         }\n         any_diverges = any_diverges || fcx.infcx().type_var_diverges(s_ty);\n-        any_err = any_err || ty::type_is_error(s_ty);\n+        any_err = any_err || s_ty.references_error();\n     }\n     match blk.expr {\n         None => if any_err {\n@@ -4101,7 +4084,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         e: &'tcx ast::Expr,\n                         id: ast::NodeId) {\n     let inh = static_inherited_fields(ccx);\n-    let rty = ty::node_id_to_type(ccx.tcx, id);\n+    let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n     let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n@@ -4134,14 +4117,14 @@ pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n                            designation: &str) -> bool {\n-    let rty = ty::node_id_to_type(tcx, item_id);\n+    let rty = tcx.node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n     // recursive type. It is only necessary to throw an error on those that\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n-    match ty::is_type_representable(tcx, sp, rty) {\n+    match rty.is_representable(tcx, sp) {\n       ty::SelfRecursive => {\n         span_err!(tcx.sess, sp, E0072,\n             \"illegal recursive {} type; \\\n@@ -4169,8 +4152,8 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n                           item_id: ast::NodeId)\n                           -> bool {\n-    let item_ty = ty::node_id_to_type(tcx, item_id);\n-    if !ty::is_instantiable(tcx, item_ty) {\n+    let item_ty = tcx.node_id_to_type(item_id);\n+    if !item_ty.is_instantiable(tcx) {\n         span_err!(tcx.sess, sp, E0073,\n             \"this type cannot be instantiated without an \\\n              instance of itself\");\n@@ -4183,25 +4166,25 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n }\n \n pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n-    let t = ty::node_id_to_type(tcx, id);\n-    if ty::type_needs_subst(t) {\n+    let t = tcx.node_id_to_type(id);\n+    if t.needs_subst() {\n         span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n         return;\n     }\n     match t.sty {\n         ty::TyStruct(did, substs) => {\n-            let fields = ty::lookup_struct_fields(tcx, did);\n+            let fields = tcx.lookup_struct_fields(did);\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n+            let e = tcx.lookup_field_type(did, fields[0].id, substs);\n             if !fields.iter().all(\n-                         |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n+                         |f| tcx.lookup_field_type(did, f.id, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n-            if !ty::type_is_machine(e) {\n+            if !e.is_machine() {\n                 span_err!(tcx.sess, sp, E0077,\n                     \"SIMD vector element type should be machine type\");\n                 return;\n@@ -4249,13 +4232,13 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           hint: attr::ReprAttr) {\n         #![allow(trivial_numeric_casts)]\n \n-        let rty = ty::node_id_to_type(ccx.tcx, id);\n+        let rty = ccx.tcx.node_id_to_type(id);\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n \n         let inh = static_inherited_fields(ccx);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-        let (_, repr_type_ty) = ty::enum_repr_type(ccx.tcx, Some(&hint));\n+        let (_, repr_type_ty) = ccx.tcx.enum_repr_type(Some(&hint));\n         for v in vs {\n             if let Some(ref e) = v.node.disr_expr {\n                 check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n@@ -4266,7 +4249,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n         // ty::enum_variants guards against discriminant overflows, so\n         // we need not check for that.\n-        let variants = ty::enum_variants(ccx.tcx, def_id);\n+        let variants = ccx.tcx.enum_variants(def_id);\n \n         for (v, variant) in vs.iter().zip(variants.iter()) {\n             let current_disr_val = variant.disr_val;\n@@ -4300,7 +4283,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n+    let hint = *ccx.tcx.lookup_repr_hints(ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n         .get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n@@ -4338,7 +4321,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefFn(id, _) | def::DefMethod(id, _) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n         def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id, _) => {\n-            (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n+            (fcx.tcx().lookup_item_type(id), fcx.tcx().lookup_predicates(id))\n         }\n         def::DefTrait(_) |\n         def::DefTy(..) |\n@@ -4600,7 +4583,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // is inherent, there is no `Self` parameter, instead, the impl needs\n         // type parameters, which we can infer by unifying the provided `Self`\n         // with the substituted impl type.\n-        let impl_scheme = ty::lookup_item_type(fcx.tcx(), impl_def_id);\n+        let impl_scheme = fcx.tcx().lookup_item_type(impl_def_id);\n         assert_eq!(substs.types.len(subst::TypeSpace),\n                    impl_scheme.generics.types.len(subst::TypeSpace));\n         assert_eq!(substs.regions().len(subst::TypeSpace),\n@@ -4736,8 +4719,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let input_tys: Vec<Ty> =\n             data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n \n-        let tuple_ty =\n-            ty::mk_tup(fcx.tcx(), input_tys);\n+        let tuple_ty = fcx.tcx().mk_tup(input_tys);\n \n         if type_count >= 1 {\n             substs.types.push(space, tuple_ty);\n@@ -4747,7 +4729,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n \n         let output_ty =\n-            output_ty.unwrap_or(ty::mk_nil(fcx.tcx()));\n+            output_ty.unwrap_or(fcx.tcx().mk_nil());\n \n         if type_count >= 2 {\n             substs.types.push(space, output_ty);\n@@ -4870,11 +4852,11 @@ fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n-    if ty::type_is_ty_var(ty) {\n+    if ty.is_ty_var() {\n         let alternative = f();\n \n         // If not, error.\n-        if ty::type_is_ty_var(alternative) || ty::type_is_error(alternative) {\n+        if alternative.is_ty_var() || alternative.references_error() {\n             fcx.type_error_message(sp, |_actual| {\n                 \"the type of this value must be known in this context\".to_string()\n             }, ty, None);\n@@ -4933,15 +4915,12 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if tps.is_empty() { return; }\n     let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n-    ty::walk_ty(ty, |t| {\n-            match t.sty {\n-                ty::TyParam(ParamTy {idx, ..}) => {\n-                    debug!(\"Found use of ty param num {}\", idx);\n-                    tps_used[idx as usize] = true;\n-                }\n-                _ => ()\n-            }\n-        });\n+    for leaf_ty in ty.walk() {\n+        if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n+            debug!(\"Found use of ty param num {}\", idx);\n+            tps_used[idx as usize] = true;\n+        }\n+    }\n \n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n@@ -4957,7 +4936,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         let name = token::intern(&format!(\"P{}\", n));\n-        ty::mk_param(ccx.tcx, subst::FnSpace, n, name)\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n     }\n \n     let tcx = ccx.tcx;\n@@ -4968,22 +4947,22 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)),\n+            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n                                 param(ccx, 0),\n                                 param(ccx, 0)),\n                         param(ccx, 0)),\n-            \"load\" => (1, vec!(ty::mk_imm_ptr(tcx, param(ccx, 0))),\n+            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n                        param(ccx, 0)),\n-            \"store\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n-                        ty::mk_nil(tcx)),\n+            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                        tcx.mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n+                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n             \"fence\" | \"singlethreadfence\" => {\n-                (0, Vec::new(), ty::mk_nil(tcx))\n+                (0, Vec::new(), tcx.mk_nil())\n             }\n             op => {\n                 span_err!(tcx.sess, it.span, E0092,\n@@ -4996,95 +4975,92 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n         let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n+            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n             \"size_of_val\" |  \"min_align_of_val\" => {\n                 (1, vec![\n-                    ty::mk_imm_rptr(tcx,\n-                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0))\n                  ], ccx.tcx.types.usize)\n             }\n             \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n+            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1,\n                  vec!(\n-                    ty::mk_mut_rptr(tcx,\n-                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                    tcx.mk_mut_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0)),\n                     param(ccx, 0)\n                   ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"drop_in_place\" => {\n-                (1, vec![ty::mk_mut_ptr(tcx, param(ccx, 0))], ty::mk_nil(tcx))\n+                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n             }\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n-            \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),\n-                                                             ast::MutImmutable)),\n+            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n             \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n             \"offset\" | \"arith_offset\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   ccx.tcx.types.isize\n                ),\n-               ty::mk_ptr(tcx, ty::mt {\n+               tcx.mk_ptr(ty::mt {\n                    ty: param(ccx, 0),\n                    mutbl: ast::MutImmutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n                   tcx.types.usize,\n                ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   tcx.types.usize,\n                ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"write_bytes\" | \"volatile_set_memory\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n                   tcx.types.u8,\n                   tcx.types.usize,\n                ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n             \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n@@ -5165,55 +5141,54 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n \n             \"volatile_load\" =>\n-                (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n+                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil(tcx)),\n+                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i8, tcx.types.i8),\n-                ty::mk_tup(tcx, vec!(tcx.types.i8, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i8, tcx.types.bool))),\n \n             \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i16, tcx.types.i16),\n-                ty::mk_tup(tcx, vec!(tcx.types.i16, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i16, tcx.types.bool))),\n \n             \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i32, tcx.types.i32),\n-                ty::mk_tup(tcx, vec!(tcx.types.i32, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i32, tcx.types.bool))),\n \n             \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i64, tcx.types.i64),\n-                ty::mk_tup(tcx, vec!(tcx.types.i64, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i64, tcx.types.bool))),\n \n             \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.u8, tcx.types.u8),\n-                ty::mk_tup(tcx, vec!(tcx.types.u8, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u8, tcx.types.bool))),\n \n             \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.u16, tcx.types.u16),\n-                ty::mk_tup(tcx, vec!(tcx.types.u16, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u16, tcx.types.bool))),\n \n             \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n                 (0, vec!(tcx.types.u32, tcx.types.u32),\n-                ty::mk_tup(tcx, vec!(tcx.types.u32, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u32, tcx.types.bool))),\n \n             \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.u64, tcx.types.u64),\n-                ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u64, tcx.types.bool))),\n \n             \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n \n-            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, tcx.types.u8)),\n+            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n \n-            \"assume\" => (0, vec![tcx.types.bool], ty::mk_nil(tcx)),\n+            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n \n             \"discriminant_value\" => (1, vec![\n-                    ty::mk_imm_rptr(tcx,\n-                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0))], tcx.types.u64),\n \n@@ -5225,7 +5200,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n         sig: ty::Binder(FnSig {\n@@ -5234,7 +5209,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             variadic: false,\n         }),\n     }));\n-    let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n+    let i_ty = ccx.tcx.lookup_item_type(local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,"}, {"sha": "5a114c811191cdfa4659424f6d1dcdd2ac6d4579", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -21,7 +21,7 @@ use super::{\n     structurally_resolved_type,\n };\n use middle::traits;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -46,7 +46,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         fcx.write_nil(expr.id);\n     } else {\n         // error types are considered \"builtin\"\n-        assert!(!ty::type_is_error(lhs_ty) || !ty::type_is_error(rhs_ty));\n+        assert!(!lhs_ty.references_error() || !rhs_ty.references_error());\n         span_err!(tcx.sess, lhs_expr.span, E0368,\n                   \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n                   ast_util::binop_to_string(op.node),\n@@ -56,7 +56,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     }\n \n     let tcx = fcx.tcx();\n-    if !ty::expr_is_lval(tcx, lhs_expr) {\n+    if !tcx.expr_is_lval(lhs_expr) {\n         span_err!(tcx.sess, lhs_expr.span, E0067, \"illegal left-hand side expression\");\n     }\n \n@@ -86,7 +86,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // traits, because their return type is not bool. Perhaps this\n     // should change, but for now if LHS is SIMD we go down a\n     // different path that bypassess all traits.\n-    if ty::type_is_simd(fcx.tcx(), lhs_ty) {\n+    if lhs_ty.is_simd(fcx.tcx()) {\n         check_expr_coercable_to_type(fcx, rhs_expr, lhs_ty);\n         let rhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n         let return_ty = enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -97,9 +97,9 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             // && and || are a simple case.\n-            demand::suptype(fcx, lhs_expr.span, ty::mk_bool(tcx), lhs_ty);\n-            check_expr_coercable_to_type(fcx, rhs_expr, ty::mk_bool(tcx));\n-            fcx.write_ty(expr.id, ty::mk_bool(tcx));\n+            demand::suptype(fcx, lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+            check_expr_coercable_to_type(fcx, rhs_expr, tcx.mk_bool());\n+            fcx.write_ty(expr.id, tcx.mk_bool());\n         }\n         _ => {\n             // Otherwise, we always treat operators as if they are\n@@ -122,8 +122,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // can't pin this down to a specific impl.\n             let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n             if\n-                !ty::type_is_ty_var(lhs_ty) &&\n-                !ty::type_is_ty_var(rhs_ty) &&\n+                !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n                 is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op)\n             {\n                 let builtin_return_ty =\n@@ -149,15 +148,15 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.tcx();\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n-            demand::suptype(fcx, lhs_expr.span, ty::mk_bool(tcx), lhs_ty);\n-            demand::suptype(fcx, rhs_expr.span, ty::mk_bool(tcx), rhs_ty);\n-            ty::mk_bool(tcx)\n+            demand::suptype(fcx, lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+            demand::suptype(fcx, rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+            tcx.mk_bool()\n         }\n \n         BinOpCategory::Shift => {\n             // For integers, the shift amount can be of any integral\n             // type. For simd, the type must match exactly.\n-            if ty::type_is_simd(tcx, lhs_ty) {\n+            if lhs_ty.is_simd(tcx) {\n                 demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n             }\n \n@@ -177,12 +176,12 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n \n             // if this is simd, result is same as lhs, else bool\n-            if ty::type_is_simd(tcx, lhs_ty) {\n-                let unit_ty = ty::simd_type(tcx, lhs_ty);\n+            if lhs_ty.is_simd(tcx) {\n+                let unit_ty = lhs_ty.simd_type(tcx);\n                 debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n                        lhs_ty,\n                        unit_ty);\n-                if !ty::type_is_integral(unit_ty) {\n+                if !unit_ty.is_integral() {\n                     tcx.sess.span_err(\n                         lhs_expr.span,\n                         &format!(\"binary comparison operation `{}` not supported \\\n@@ -194,7 +193,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     lhs_ty\n                 }\n             } else {\n-                ty::mk_bool(tcx)\n+                tcx.mk_bool()\n             }\n         }\n     }\n@@ -228,7 +227,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(return_ty) => return_ty,\n         Err(()) => {\n             // error types are considered \"builtin\"\n-            if !ty::type_is_error(lhs_ty) {\n+            if !lhs_ty.references_error() {\n                 span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n                           \"binary operation `{}` cannot be applied to type `{}`\",\n                           ast_util::binop_to_string(op.node),\n@@ -335,8 +334,8 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n-            let ret_ty = ty::ty_fn_ret(method_ty);\n-            Ok(ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap())\n+            let ret_ty = method_ty.fn_ret();\n+            Ok(fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap())\n         }\n         None => {\n             Err(())\n@@ -428,30 +427,30 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n         }\n \n         BinOpCategory::Shift => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n-                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+            lhs.references_error() || rhs.references_error() ||\n+                lhs.is_integral() && rhs.is_integral() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx)\n         }\n \n         BinOpCategory::Math => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n-                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n-                ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+            lhs.references_error() || rhs.references_error() ||\n+                lhs.is_integral() && rhs.is_integral() ||\n+                lhs.is_floating_point() && rhs.is_floating_point() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx)\n         }\n \n         BinOpCategory::Bitwise => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n-                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n-                ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs) ||\n-                ty::type_is_bool(lhs) && ty::type_is_bool(rhs)\n+            lhs.references_error() || rhs.references_error() ||\n+                lhs.is_integral() && rhs.is_integral() ||\n+                lhs.is_floating_point() && rhs.is_floating_point() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx) ||\n+                lhs.is_bool() && rhs.is_bool()\n         }\n \n         BinOpCategory::Comparison => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n-                ty::type_is_scalar(lhs) && ty::type_is_scalar(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+            lhs.references_error() || rhs.references_error() ||\n+                lhs.is_scalar() && rhs.is_scalar() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx)\n         }\n     }\n }"}, {"sha": "13961834aebdde4a63f6f0ef025d38169da199a2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -91,7 +91,7 @@ use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall};\n+use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n \n@@ -262,13 +262,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> Ty<'tcx> {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty::type_is_error(ty_unadjusted) {\n+        if ty_unadjusted.references_error() {\n             ty_unadjusted\n         } else {\n-            let tcx = self.fcx.tcx();\n-            ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted,\n-                          self.fcx.inh.adjustments.borrow().get(&expr.id),\n-                          |method_call| self.resolve_method_type(method_call))\n+            ty_unadjusted.adjust(\n+                self.fcx.tcx(), expr.span, expr.id,\n+                self.fcx.inh.adjustments.borrow().get(&expr.id),\n+                |method_call| self.resolve_method_type(method_call))\n         }\n     }\n \n@@ -662,7 +662,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n-                        ty::no_late_bound_regions(rcx.tcx(), &ty::ty_fn_ret(method.ty)).unwrap();\n+                        rcx.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n                     fn_ret.unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -891,9 +891,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n-                let fn_sig = ty::ty_fn_sig(method.ty);\n+                let fn_sig = method.ty.fn_sig();\n                 let fn_sig = // late-bound regions should have been instantiated\n-                    ty::no_late_bound_regions(rcx.tcx(), fn_sig).unwrap();\n+                    rcx.tcx().no_late_bound_regions(fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -937,7 +937,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                             r_deref_expr, *r_ptr);\n         }\n \n-        match ty::deref(derefd_ty, true) {\n+        match derefd_ty.builtin_deref(true) {\n             Some(mt) => derefd_ty = mt.ty,\n             /* if this type can't be dereferenced, then there's already an error\n                in the session saying so. Just bail out for now */\n@@ -1017,9 +1017,9 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let ty = ty::adjust_ty(tcx, origin.span(), id, ty0,\n-                           rcx.fcx.inh.adjustments.borrow().get(&id),\n-                           |method_call| rcx.resolve_method_type(method_call));\n+    let ty = ty0.adjust(tcx, origin.span(), id,\n+                        rcx.fcx.inh.adjustments.borrow().get(&id),\n+                        |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n             ty,  ty0,\n@@ -1172,10 +1172,8 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            id, mutbl, cmt_borrowed);\n \n     let rptr_ty = rcx.resolve_node_type(id);\n-    if !ty::type_is_error(rptr_ty) {\n-        let tcx = rcx.fcx.ccx.tcx;\n+    if let ty::TyRef(&r, _) = rptr_ty.sty {\n         debug!(\"rptr_ty={}\",  rptr_ty);\n-        let r = ty::ty_region(tcx, span, rptr_ty);\n         link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);\n     }\n@@ -1462,10 +1460,8 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            generic);\n \n     // To start, collect bounds from user:\n-    let mut param_bounds =\n-        ty::required_region_bounds(rcx.tcx(),\n-                                   generic.to_ty(rcx.tcx()),\n-                                   param_env.caller_bounds.clone());\n+    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n+                                                            param_env.caller_bounds.clone());\n \n     // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n     match *generic {\n@@ -1520,7 +1516,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     debug!(\"projection_bounds(projection_ty={:?})\",\n            projection_ty);\n \n-    let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n+    let ty = tcx.mk_projection(projection_ty.trait_ref.clone(), projection_ty.item_name);\n \n     // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n     // in looking for a trait definition like:\n@@ -1532,7 +1528,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // ```\n     //\n     // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-    let trait_predicates = ty::lookup_predicates(tcx, projection_ty.trait_ref.def_id);\n+    let trait_predicates = tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n     let predicates = trait_predicates.predicates.as_slice().to_vec();\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {"}, {"sha": "1345f322476b9789a73488a25d9b6baf5a47932f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -136,7 +136,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                    closure_def_id);\n         }\n \n-        ty::with_freevars(self.tcx(), expr.id, |freevars| {\n+        self.tcx().with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n                 let var_node_id = freevar.def.local_node_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,"}, {"sha": "00bbbafd5cd32922dd60593ae1ee5404d3cb7304", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -16,7 +16,6 @@ use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n \n use std::collections::HashSet;\n@@ -56,7 +55,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n                item.id,\n-               ty::item_path_str(ccx.tcx, local_def(item.id)));\n+               ccx.tcx.item_path_str(local_def(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -80,13 +79,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ty::impl_trait_ref(ccx.tcx,\n-                                                   local_def(item.id)).unwrap();\n-                ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n+                let trait_ref = ccx.tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        if !ty::trait_has_default_impl(ccx.tcx, trait_ref.def_id) {\n+                        if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n                             span_err!(ccx.tcx.sess, item.span, E0192,\n                                       \"negative impls are only allowed for traits with \\\n                                        default impls (e.g., `Send` and `Sync`)\")\n@@ -119,9 +117,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             ast::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n-                    ty::lookup_predicates(ccx.tcx, local_def(item.id));\n+                    ccx.tcx.lookup_predicates(local_def(item.id));\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n-                if ty::trait_has_default_impl(ccx.tcx, local_def(item.id)) {\n+                if ccx.tcx.trait_has_default_impl(local_def(item.id)) {\n                     if !items.is_empty() {\n                         span_err!(ccx.tcx.sess, item.span, E0380,\n                                   \"traits with default impls (`e.g. unsafe impl \\\n@@ -138,15 +136,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let ccx = self.ccx;\n         let item_def_id = local_def(item.id);\n-        let type_scheme = ty::lookup_item_type(ccx.tcx, item_def_id);\n-        let type_predicates = ty::lookup_predicates(ccx.tcx, item_def_id);\n+        let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n+        let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n-        let param_env =\n-            ty::construct_parameter_environment(ccx.tcx,\n-                                                item.span,\n-                                                &type_scheme.generics,\n-                                                &type_predicates,\n-                                                item.id);\n+        let param_env = ccx.tcx.construct_parameter_environment(item.span,\n+                                                                &type_scheme.generics,\n+                                                                &type_predicates,\n+                                                                item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n@@ -201,7 +197,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         Some(&mut this.cache));\n             debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n-            let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh.param_env.free_substs,\n                                                       &type_scheme.ty);\n@@ -222,7 +218,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound\n             // to free.\n-            let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n+            let self_ty = fcx.tcx().node_id_to_type(item.id);\n             let self_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh.param_env.free_substs,\n                                                       &self_ty);\n@@ -231,7 +227,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Similarly, obtain an \"inside\" reference to the trait\n             // that the impl implements.\n-            let trait_ref = match ty::impl_trait_ref(fcx.tcx(), local_def(item.id)) {\n+            let trait_ref = match fcx.tcx().impl_trait_ref(local_def(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n@@ -258,7 +254,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n             let poly_trait_ref = ty::Binder(trait_ref);\n-            let predicates = ty::lookup_super_predicates(fcx.tcx(), poly_trait_ref.def_id());\n+            let predicates = fcx.tcx().lookup_super_predicates(poly_trait_ref.def_id());\n             let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n                 let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n@@ -278,8 +274,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      ast_generics: &ast::Generics)\n     {\n         let item_def_id = local_def(item.id);\n-        let ty_predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n-        let variances = ty::item_variances(self.tcx(), item_def_id);\n+        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let variances = self.tcx().item_variances(item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n             variances.types\n@@ -358,7 +354,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     span,\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n-                             ty::item_path_str(self.tcx(), def_id)));\n+                             self.tcx().item_path_str(def_id)));\n             }\n             None => {\n                 // no lang items, no help!\n@@ -432,7 +428,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             visit::FkFnBlock | visit::FkItemFn(..) => {}\n             visit::FkMethod(..) => {\n-                match ty::impl_or_trait_item(self.tcx(), local_def(id)) {\n+                match self.tcx().impl_or_trait_item(local_def(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n@@ -445,7 +441,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n         if let ast::MethodTraitItem(_, None) = trait_item.node {\n-            match ty::impl_or_trait_item(self.tcx(), local_def(trait_item.id)) {\n+            match self.tcx().impl_or_trait_item(local_def(trait_item.id)) {\n                 ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                     reject_non_type_param_bounds(\n                         self.tcx(),\n@@ -496,7 +492,7 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n     /// to the point where impl `A : Trait<B>` is implemented).\n     pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, span: Span) {\n-        let trait_predicates = ty::lookup_predicates(self.fcx.tcx(), trait_ref.def_id);\n+        let trait_predicates = self.fcx.tcx().lookup_predicates(trait_ref.def_id);\n \n         let bounds = self.fcx.instantiate_bounds(span,\n                                                  trait_ref.substs,\n@@ -538,8 +534,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         self.binding_count += 1;\n-        let value = liberate_late_bound_regions(\n-            self.fcx.tcx(),\n+        let value = self.fcx.tcx().liberate_late_bound_regions(\n             region::DestructionScopeData::new(self.scope),\n             binder);\n         debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {:?} at scope: {:?}\",\n@@ -567,7 +562,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         match t.sty{\n             ty::TyStruct(type_id, substs) |\n             ty::TyEnum(type_id, substs) => {\n-                let type_predicates = ty::lookup_predicates(self.fcx.tcx(), type_id);\n+                let type_predicates = self.fcx.tcx().lookup_predicates(type_id);\n                 let bounds = self.fcx.instantiate_bounds(self.span, substs,\n                                                          &type_predicates);\n \n@@ -638,7 +633,7 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         struct_def.fields\n         .iter()\n         .map(|field| {\n-            let field_ty = ty::node_id_to_type(fcx.tcx(), field.node.id);\n+            let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,\n                                                        &fcx.inh.param_env.free_substs,\n                                                        &field_ty);\n@@ -655,13 +650,11 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .map(|variant| {\n             match variant.node.kind {\n                 ast::TupleVariantKind(ref args) if !args.is_empty() => {\n-                    let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n+                    let ctor_ty = fcx.tcx().node_id_to_type(variant.node.id);\n \n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n-                    let arg_tys =\n-                        ty::no_late_bound_regions(\n-                            fcx.tcx(), &ty::ty_fn_args(ctor_ty)).unwrap();\n+                    let arg_tys = fcx.tcx().no_late_bound_regions(&ctor_ty.fn_args()).unwrap();\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "29119f3b5946dcc8de5a0a3fb4ae1a94abf73187", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -95,7 +95,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let rhs_ty = self.fcx.node_ty(rhs.id);\n             let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n \n-            if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n+            if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                 self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n \n                 // weird but true: the by-ref binops put an\n@@ -128,7 +128,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        self.visit_node_id(ResolvingExpr(s.span), ty::stmt_node_id(s));\n+        self.visit_node_id(ResolvingExpr(s.span), ast_util::stmt_id(s));\n         visit::walk_stmt(self, s);\n     }\n \n@@ -171,7 +171,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               ty::node_id_to_type(self.tcx(), p.id));\n+               self.tcx().node_id_to_type(p.id));\n \n         visit::walk_pat(self, p);\n     }\n@@ -334,11 +334,11 @@ impl ResolveReason {\n             ResolvingLocal(s) => s,\n             ResolvingPattern(s) => s,\n             ResolvingUpvar(upvar_id) => {\n-                ty::expr_span(tcx, upvar_id.closure_expr_id)\n+                tcx.expr_span(upvar_id.closure_expr_id)\n             }\n             ResolvingClosure(did) => {\n                 if did.krate == ast::LOCAL_CRATE {\n-                    ty::expr_span(tcx, did.node)\n+                    tcx.expr_span(did.node)\n                 } else {\n                     DUMMY_SP\n                 }\n@@ -403,7 +403,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     let span = self.reason.span(self.tcx);\n                     span_err!(self.tcx.sess, span, E0104,\n                         \"cannot resolve lifetime for captured variable `{}`: {}\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string(),\n+                        self.tcx.local_var_name_str(upvar_id.var_id).to_string(),\n                         infer::fixup_err_to_string(e));\n                 }\n "}, {"sha": "06bd572ac12f3729388a2906add266dcc0d83d53", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -139,15 +139,14 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n-        let self_type = ty::lookup_item_type(tcx, impl_did);\n+        let self_type = tcx.lookup_item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n-                                                    impl_did) {\n+        if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n                    item.ident);\n@@ -181,9 +180,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={:?})\",\n                impl_id, trait_ref);\n \n-        let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n+        let impl_type_scheme = tcx.lookup_item_type(impl_id);\n \n-        let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n+        let prov = tcx.provided_trait_methods(trait_ref.def_id);\n         for trait_method in &prov {\n             // Synthesize an ID.\n             let new_id = tcx.sess.next_node_id();\n@@ -210,8 +209,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // impl, plus its own.\n             let new_polytype = ty::TypeScheme {\n                 generics: new_method_ty.generics.clone(),\n-                ty: ty::mk_bare_fn(tcx, Some(new_did),\n-                                   tcx.mk_bare_fn(new_method_ty.fty.clone()))\n+                ty: tcx.mk_fn(Some(new_did),\n+                              tcx.mk_bare_fn(new_method_ty.fty.clone()))\n             };\n             debug!(\"new_polytype={:?}\", new_polytype);\n \n@@ -245,8 +244,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref, impl_def_id);\n-        let trait_def = ty::lookup_trait_def(self.crate_context.tcx,\n-                                             impl_trait_ref.def_id);\n+        let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n         trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n@@ -273,11 +271,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }).collect();\n \n-                if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n-                                                            local_def(item.id)) {\n-                    self.instantiate_default_methods(local_def(item.id),\n-                                                     &trait_ref,\n-                                                     &mut items);\n+                let def_id = local_def(item.id);\n+                if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(def_id) {\n+                    self.instantiate_default_methods(def_id, &trait_ref, &mut items);\n                 }\n \n                 items\n@@ -299,8 +295,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n-        ty::populate_implementations_for_trait_if_necessary(tcx, drop_trait);\n-        let drop_trait = ty::lookup_trait_def(tcx, drop_trait);\n+        tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n+        let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n         let impl_items = tcx.impl_items.borrow();\n \n@@ -312,7 +308,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = ty::lookup_item_type(tcx, impl_did);\n+            let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n                 ty::TyEnum(type_def_id, _) |\n                 ty::TyStruct(type_def_id, _) |\n@@ -355,8 +351,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(id) => id,\n             None => return,\n         };\n-        ty::populate_implementations_for_trait_if_necessary(tcx, copy_trait);\n-        let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n+        tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n+        let copy_trait = tcx.lookup_trait_def(copy_trait);\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_copy: impl_did={:?}\",\n@@ -368,7 +364,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return\n             }\n \n-            let self_type = ty::lookup_item_type(tcx, impl_did);\n+            let self_type = tcx.lookup_item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n@@ -380,7 +376,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n                    self_type);\n \n-            match ty::can_type_implement_copy(&param_env, span, self_type) {\n+            match param_env.can_type_implement_copy(self_type, span) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n                        span_err!(tcx.sess, span, E0204,\n@@ -425,7 +421,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n         };\n \n-        let trait_def = ty::lookup_trait_def(tcx, coerce_unsized_trait);\n+        let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n \n         trait_def.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n@@ -437,9 +433,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return;\n             }\n \n-            let source = ty::lookup_item_type(tcx, impl_did).ty;\n-            let trait_ref = ty::impl_trait_ref(self.crate_context.tcx,\n-                                               impl_did).unwrap();\n+            let source = tcx.lookup_item_type(impl_did).ty;\n+            let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n@@ -468,18 +463,18 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n                 (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                     infer::mk_subr(&infcx, infer::RelateObjectBound(span), *r_b, *r_a);\n-                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_rptr(tcx, r_b, ty))\n+                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n                 }\n \n                 (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n                 (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_ptr(tcx, ty))\n+                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n                 }\n \n                 (&ty::TyStruct(def_id_a, substs_a), &ty::TyStruct(def_id_b, substs_b)) => {\n                     if def_id_a != def_id_b {\n-                        let source_path = ty::item_path_str(tcx, def_id_a);\n-                        let target_path = ty::item_path_str(tcx, def_id_b);\n+                        let source_path = tcx.item_path_str(def_id_a);\n+                        let target_path = tcx.item_path_str(def_id_b);\n                         span_err!(tcx.sess, span, E0377,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures with the same \\\n@@ -489,9 +484,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let origin = infer::Misc(span);\n-                    let fields = ty::lookup_struct_fields(tcx, def_id_a);\n+                    let fields = tcx.lookup_struct_fields(def_id_a);\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                        let ty = ty::lookup_field_type_unsubstituted(tcx, def_id_a, f.id);\n+                        let ty = tcx.lookup_field_type_unsubstituted(def_id_a, f.id);\n                         let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n                         if infcx.sub_types(false, origin, b, a).is_ok() {\n                             None\n@@ -592,7 +587,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            provided_source: Option<ast::DefId>)\n                                            -> ty::Method<'tcx>\n {\n-    let combined_substs = ty::make_substs_for_receiver_types(tcx, trait_ref, method);\n+    let combined_substs = tcx.make_substs_for_receiver_types(trait_ref, method);\n \n     debug!(\"subst_receiver_types_in_method_ty: combined_substs={:?}\",\n            combined_substs);"}, {"sha": "e585b8cd2bde0fea2076d1d4a7563dc6554d5675", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -67,7 +67,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n+                let self_ty = self.tcx.lookup_item_type(def_id).ty;\n                 match self_ty.sty {\n                     ty::TyEnum(def_id, _) |\n                     ty::TyStruct(def_id, _) => {\n@@ -210,7 +210,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => { }\n@@ -269,9 +269,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 debug!(\"trait_ref={:?} trait_def_id={:?} trait_has_default_impl={}\",\n                        trait_ref,\n                        trait_def_id,\n-                       ty::trait_has_default_impl(self.tcx, trait_def_id));\n+                       self.tcx.trait_has_default_impl(trait_def_id));\n                 if\n-                    ty::trait_has_default_impl(self.tcx, trait_def_id) &&\n+                    self.tcx.trait_has_default_impl(trait_def_id) &&\n                     trait_def_id.krate != ast::LOCAL_CRATE\n                 {\n                     let self_ty = trait_ref.self_ty();\n@@ -297,15 +297,15 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                     \"cross-crate traits with a default impl, like `{}`, \\\n                                      can only be implemented for a struct/enum type \\\n                                      defined in the current crate\",\n-                                    ty::item_path_str(self.tcx, trait_def_id)))\n+                                    self.tcx.item_path_str(trait_def_id)))\n                             }\n                         }\n                         _ => {\n                             Some(format!(\n                                 \"cross-crate traits with a default impl, like `{}`, \\\n                                  can only be implemented for a struct/enum type, \\\n                                  not `{}`\",\n-                                ty::item_path_str(self.tcx, trait_def_id),\n+                                self.tcx.item_path_str(trait_def_id),\n                                 self_ty))\n                         }\n                     };\n@@ -332,7 +332,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: default trait impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,\n                               \"cannot create default implementations for traits outside the \\"}, {"sha": "b4ad55ef2e46b8a7ae3c24d64a24d75fd293cae6", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -50,9 +50,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n \n         for trait_def in trait_defs {\n-            ty::populate_implementations_for_trait_if_necessary(\n-                self.tcx,\n-                trait_def.trait_ref.def_id);\n+            self.tcx.populate_implementations_for_trait_if_necessary(trait_def.trait_ref.def_id);\n             self.check_for_overlapping_impls_of_trait(trait_def);\n         }\n     }\n@@ -147,7 +145,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n                   \"conflicting implementations for trait `{}`\",\n-                  ty::item_path_str(self.tcx, trait_def_id));\n+                  self.tcx.item_path_str(trait_def_id));\n \n         self.report_overlap_note(impl1, impl2);\n     }\n@@ -181,7 +179,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n                 let impl_def_id = ast_util::local_def(item.id);\n-                let trait_ref = ty::impl_trait_ref(self.tcx, impl_def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n@@ -194,7 +192,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n             }\n             ast::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n                 let impl_def_id = ast_util::local_def(item.id);\n-                let trait_ref = ty::impl_trait_ref(self.tcx, impl_def_id).unwrap();\n+                let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match trait_ref.self_ty().sty {\n                     ty::TyTrait(ref data) => {\n@@ -208,7 +206,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                             // giving a misleading message below.\n                             span_err!(self.tcx.sess, self_ty.span, E0372,\n                                       \"the trait `{}` cannot be made into an object\",\n-                                      ty::item_path_str(self.tcx, data.principal_def_id()));\n+                                      self.tcx.item_path_str(data.principal_def_id()));\n                         } else {\n                             let mut supertrait_def_ids =\n                                 traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n@@ -217,7 +215,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                                           \"the object type `{}` automatically \\\n                                            implements the trait `{}`\",\n                                           trait_ref.self_ty(),\n-                                          ty::item_path_str(self.tcx, trait_def_id));\n+                                          self.tcx.item_path_str(trait_def_id));\n                             }\n                         }\n                     }"}, {"sha": "c0323ba60fc47040c99ca4df4c97b9b6ac64f473", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -30,7 +30,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self, item: &'v ast::Item,\n                                 unsafety: ast::Unsafety,\n                                 polarity: ast::ImplPolarity) {\n-        match ty::impl_trait_ref(self.tcx, ast_util::local_def(item.id)) {\n+        match self.tcx.impl_trait_ref(ast_util::local_def(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {\n@@ -43,7 +43,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n             }\n \n             Some(trait_ref) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n+                let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 match (trait_def.unsafety, unsafety, polarity) {\n                     (ast::Unsafety::Unsafe,\n                      ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {"}, {"sha": "e43a3542b6e338181397124ad8264abeccbdf885", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -242,12 +242,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             AstConvRequest::GetTraitDef(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when processing `{}`...\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::EnsureSuperPredicates(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when computing the supertraits of `{}`...\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n@@ -264,12 +264,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 AstConvRequest::GetTraitDef(def_id) => {\n                     tcx.sess.note(\n                         &format!(\"...which then requires processing `{}`...\",\n-                                 ty::item_path_str(tcx, def_id)));\n+                                 tcx.item_path_str(def_id)));\n                 }\n                 AstConvRequest::EnsureSuperPredicates(def_id) => {\n                     tcx.sess.note(\n                         &format!(\"...which then requires computing the supertraits of `{}`...\",\n-                                 ty::item_path_str(tcx, def_id)));\n+                                 tcx.item_path_str(def_id)));\n                 }\n                 AstConvRequest::GetTypeParameterBounds(id) => {\n                     let def = tcx.type_parameter_def(id);\n@@ -286,13 +286,13 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             AstConvRequest::GetTraitDef(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::EnsureSuperPredicates(def_id) => {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires computing the supertraits of `{}`, \\\n                               completing the cycle.\",\n-                             ty::item_path_str(tcx, def_id)));\n+                             tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n@@ -311,7 +311,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let tcx = self.tcx;\n \n         if trait_id.krate != ast::LOCAL_CRATE {\n-            return ty::lookup_trait_def(tcx, trait_id)\n+            return tcx.lookup_trait_def(trait_id)\n         }\n \n         let item = match tcx.map.get(trait_id.node) {\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n         if trait_def_id.krate == ast::LOCAL_CRATE {\n             trait_defines_associated_type_named(self.ccx, trait_def_id.node, assoc_name)\n         } else {\n-            let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n             trait_def.associated_type_names.contains(&assoc_name)\n         }\n     }\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        ty::mk_projection(self.tcx(), trait_ref, item_name)\n+        self.tcx().mk_projection(trait_ref, item_name)\n     }\n }\n \n@@ -508,7 +508,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n         // `where T:Foo`.\n \n         let def = astconv.tcx().type_parameter_def(node_id);\n-        let ty = ty::mk_param_from_def(astconv.tcx(), &def);\n+        let ty = astconv.tcx().mk_param_from_def(&def);\n \n         let from_ty_params =\n             self.ty_params\n@@ -577,7 +577,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if !args.is_empty() => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys, enum_scheme.ty)\n+                tcx.mk_ctor_fn(variant_def_id, &input_tys, enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -631,8 +631,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     container,\n                                     None);\n \n-    let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n-                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n+    let fty = ccx.tcx.mk_fn(Some(def_id),\n+                            ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n     debug!(\"method {} (id {}) has type {:?}\",\n             ident, id, fty);\n     ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n@@ -822,7 +822,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                     ast_trait_ref,\n                                                     None);\n \n-            ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n+            tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n             tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), Some(trait_ref));\n         }\n@@ -944,7 +944,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, local_def(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = ty::lookup_predicates(tcx, local_def(it.id));\n+            let trait_predicates = tcx.lookup_predicates(local_def(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -995,7 +995,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n                             methods,\n-                            ty::mk_self_type(tcx),\n+                            tcx.mk_self_type(),\n                             &trait_def.generics,\n                             &trait_predicates);\n \n@@ -1026,7 +1026,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 check_method_self_type(ccx,\n                                        &BindingRscope::new(),\n                                        ccx.method_ty(trait_item.id),\n-                                       ty::mk_self_type(tcx),\n+                                       tcx.mk_self_type(),\n                                        &sig.explicit_self,\n                                        it.id)\n             }\n@@ -1088,7 +1088,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let substs = mk_item_substs(ccx, &scheme.generics);\n-    let selfty = ty::mk_struct(tcx, local_def(id), tcx.mk_substs(substs));\n+    let selfty = tcx.mk_struct(local_def(id), tcx.mk_substs(substs));\n \n     // If this struct is enum-like or tuple-like, create the type of its\n     // constructor.\n@@ -1110,8 +1110,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                               .unwrap()\n                                                               .ty)\n                               .collect();\n-                let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n-                                                local_def(ctor_id),\n+                let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n                                                 &inputs[..],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n@@ -1177,7 +1176,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         let scope = &(generics, &self_predicate);\n \n         // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n-        let self_param_ty = ty::mk_self_type(tcx);\n+        let self_param_ty = tcx.mk_self_type();\n         let superbounds1 = compute_bounds(&ccx.icx(scope),\n                                     self_param_ty,\n                                     bounds,\n@@ -1231,7 +1230,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         _ => tcx.sess.span_bug(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n-    let paren_sugar = ty::has_attr(tcx, def_id, \"rustc_paren_sugar\");\n+    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n     if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n         ccx.tcx.sess.span_err(\n             it.span,\n@@ -1295,12 +1294,12 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::mk_param(tcx, TypeSpace,\n+                    .map(|(i, def)| tcx.mk_param(TypeSpace,\n                                                  i as u32, def.ident.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n-        let self_ty = ty::mk_self_type(tcx);\n+        let self_ty = tcx.mk_self_type();\n \n         Substs::new_trait(types, regions, self_ty)\n     }\n@@ -1344,7 +1343,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n     };\n \n-    let super_predicates = ty::lookup_super_predicates(ccx.tcx, def_id);\n+    let super_predicates = ccx.tcx.lookup_super_predicates(def_id);\n \n     // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n@@ -1389,9 +1388,8 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 }\n             };\n \n-            let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                             self_trait_ref,\n-                                             trait_item.ident.name);\n+            let assoc_ty = ccx.tcx.mk_projection(self_trait_ref,\n+                                                 trait_item.ident.name);\n \n             let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n                                         assoc_ty,\n@@ -1409,7 +1407,7 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   -> ty::TypeScheme<'tcx>\n {\n     if def_id.krate != ast::LOCAL_CRATE {\n-        return ty::lookup_item_type(ccx.tcx, def_id);\n+        return ccx.tcx.lookup_item_type(def_id);\n     }\n \n     match ccx.tcx.map.find(def_id.node) {\n@@ -1450,7 +1448,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         ast::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n-            let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n+            let ty = tcx.mk_fn(Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n@@ -1462,13 +1460,13 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n+            let t = tcx.mk_enum(local_def(it.id), tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n+            let t = tcx.mk_struct(local_def(it.id), tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemDefaultImpl(..) |\n@@ -1531,7 +1529,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     assert!(prev_predicates.is_none());\n \n     // Debugging aid.\n-    if ty::has_attr(tcx, local_def(it.id), \"rustc_object_lifetime_default\") {\n+    if tcx.has_attr(local_def(it.id), \"rustc_object_lifetime_default\") {\n         let object_lifetime_default_reprs: String =\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n@@ -1693,20 +1691,20 @@ fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx>,\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(tcx, tpb);\n+            let trait_def_id = tcx.trait_ref_to_def_id(tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n                     tcx.sess.span_warn(span,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\\n                                        a default. Only `?Sized` is supported\");\n-                    ty::try_add_builtin_trait(tcx, kind_id, bounds);\n+                    tcx.try_add_builtin_trait(kind_id, bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(tcx, kind_id.unwrap(), bounds);\n+            tcx.try_add_builtin_trait(kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n@@ -1882,16 +1880,15 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n-            ty::walk_ty(ty, |t| {\n-                match t.sty {\n-                    ty::TyParam(p) => if p.idx > cur_idx {\n+            for leaf_ty in ty.walk() {\n+                if let ty::TyParam(p) = leaf_ty.sty {\n+                    if p.idx > cur_idx {\n                         span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n-                        },\n-                        _ => {}\n                     }\n-            });\n+                }\n+            }\n \n             Some(ty)\n         }\n@@ -2122,14 +2119,12 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         ast::Return(ref ty) =>\n             ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &**ty)),\n         ast::DefaultReturn(..) =>\n-            ty::FnConverging(ty::mk_nil(ccx.tcx)),\n+            ty::FnConverging(ccx.tcx.mk_nil()),\n         ast::NoReturn(..) =>\n             ty::FnDiverging\n     };\n \n-    let t_fn = ty::mk_bare_fn(\n-        ccx.tcx,\n-        None,\n+    let t_fn = ccx.tcx.mk_fn(None,\n         ccx.tcx.mk_bare_fn(ty::BareFnTy {\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n@@ -2150,7 +2145,7 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     let types =\n         ty_generics.types.map(\n-            |def| ty::mk_param_from_def(ccx.tcx, def));\n+            |def| ccx.tcx.mk_param_from_def(def));\n \n     let regions =\n         ty_generics.regions.map(\n@@ -2192,17 +2187,15 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         let required_type_free =\n             liberate_early_bound_regions(\n                 tcx, body_scope,\n-                &ty::liberate_late_bound_regions(\n-                    tcx, body_scope, &ty::Binder(required_type)));\n+                &tcx.liberate_late_bound_regions(body_scope, &ty::Binder(required_type)));\n \n         // The \"base type\" comes from the impl. It too may have late-bound\n         // regions from the method.\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n             liberate_early_bound_regions(\n                 tcx, body_scope,\n-                &ty::liberate_late_bound_regions(\n-                    tcx, body_scope, &ty::Binder(base_type)));\n+                &tcx.liberate_late_bound_regions(body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={:?} required_type_free={:?} \\\n                 base_type={:?} base_type_free={:?}\",\n@@ -2267,9 +2260,9 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              impl_def_id: ast::DefId,\n                                              impl_items: &[P<ast::ImplItem>])\n {\n-    let impl_scheme = ty::lookup_item_type(tcx, impl_def_id);\n-    let impl_predicates = ty::lookup_predicates(tcx, impl_def_id);\n-    let impl_trait_ref = ty::impl_trait_ref(tcx, impl_def_id);\n+    let impl_scheme = tcx.lookup_item_type(impl_def_id);\n+    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n@@ -2298,7 +2291,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()\n-                  .map(|item| ty::impl_or_trait_item(tcx, local_def(item.id)))\n+                  .map(|item| tcx.impl_or_trait_item(local_def(item.id)))\n                   .filter_map(|item| match item {\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None"}, {"sha": "7844d71462cfccf93c2942ef5a1e3a779b8e84d3", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -24,7 +24,7 @@ pub enum Parameter {\n /// by `ty` (see RFC 447).\n pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n     let mut result = vec![];\n-    ty::maybe_walk_ty(ty, |t| {\n+    ty.maybe_walk(|t| {\n         if let ty::TyProjection(..) = t.sty {\n             false // projections are not injective.\n         } else {"}, {"sha": "fc825c198e7513980376b8171a4a8ee67af9b2fe", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -105,7 +105,7 @@ pub use rustc::util;\n use middle::def;\n use middle::infer;\n use middle::subst;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::ast_map;\n use session::config;\n use util::common::time;\n@@ -148,7 +148,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n // Functions that write types into the node type table\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n-    assert!(!ty::type_needs_infer(ty));\n+    assert!(!ty.needs_infer());\n     tcx.node_type_insert(node_id, ty);\n }\n \n@@ -160,7 +160,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n                node_id,\n                item_substs);\n \n-        assert!(item_substs.substs.types.all(|t| !ty::type_needs_infer(*t)));\n+        assert!(!item_substs.substs.types.needs_infer());\n \n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n@@ -199,7 +199,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n         Ok(_) => true,\n         Err(ref terr) => {\n             span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n-            ty::note_and_explain_type_err(tcx, terr, span);\n+            tcx.note_and_explain_type_err(terr, span);\n             false\n         }\n     }\n@@ -209,7 +209,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = ty::node_id_to_type(tcx, main_id);\n+    let main_t = tcx.node_id_to_type(main_id);\n     match main_t.sty {\n         ty::TyBareFn(..) => {\n             match tcx.map.find(main_id) {\n@@ -226,12 +226,12 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(local_def(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n-                    output: ty::FnConverging(ty::mk_nil(tcx)),\n+                    output: ty::FnConverging(tcx.mk_nil()),\n                     variadic: false\n                 })\n             }));\n@@ -254,7 +254,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = ty::node_id_to_type(tcx, start_id);\n+    let start_t = tcx.node_id_to_type(start_id);\n     match start_t.sty {\n         ty::TyBareFn(..) => {\n             match tcx.map.find(start_id) {\n@@ -272,13 +272,13 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(local_def(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n                         tcx.types.isize,\n-                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, tcx.types.u8))\n+                        tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n                     ),\n                     output: ty::FnConverging(tcx.types.isize),\n                     variadic: false,"}, {"sha": "c1f9725fc8134191721eb1e0b52a24b50a98a1a0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -485,7 +485,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n-               ty::item_path_str(self.tcx, ast_util::local_def(item_id)),\n+               self.tcx.item_path_str(ast_util::local_def(item_id)),\n                item_id, kind, space, index, param_id, inf_index,\n                initial_variance);\n     }\n@@ -603,7 +603,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n-                let scheme = ty::lookup_item_type(tcx, did);\n+                let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n@@ -633,24 +633,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             ast::ItemStruct(..) => {\n-                let scheme = ty::lookup_item_type(tcx, did);\n+                let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(&scheme.generics);\n \n-                let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                let struct_fields = tcx.lookup_struct_fields(did);\n                 for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n-                    let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n+                    let field_ty = tcx.node_id_to_type(field_info.id.node);\n                     self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n                 }\n             }\n \n             ast::ItemTrait(..) => {\n-                let trait_def = ty::lookup_trait_def(tcx, did);\n+                let trait_def = tcx.lookup_trait_def(did);\n                 self.add_constraints_from_trait_ref(&trait_def.generics,\n                                                     trait_def.trait_ref,\n                                                     self.invariant);\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n-            let variances = ty::item_variances(self.tcx(), item_def_id);\n+            let variances = self.tcx().item_variances(item_def_id);\n             let variance = match kind {\n                 TypeParam => *variances.types.get(space, index),\n                 RegionParam => *variances.regions.get(space, index),\n@@ -848,7 +848,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                trait_ref,\n                variance);\n \n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n \n         self.add_constraints_from_substs(\n             generics,\n@@ -904,7 +904,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyEnum(def_id, substs) |\n             ty::TyStruct(def_id, substs) => {\n-                let item_type = ty::lookup_item_type(self.tcx(), def_id);\n+                let item_type = self.tcx().lookup_item_type(def_id);\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n@@ -924,7 +924,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+                let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n                 self.add_constraints_from_substs(\n                     generics,\n                     trait_ref.def_id,\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n-            if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n+            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n                 span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n             }\n "}, {"sha": "e80fd360e04fd2559b52ed3050a9655d5c306dc0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -150,9 +150,9 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n                             did: ast::DefId) -> clean::Trait {\n-    let def = ty::lookup_trait_def(tcx, did);\n-    let trait_items = ty::trait_items(tcx, did).clean(cx);\n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let def = tcx.lookup_trait_def(did);\n+    let trait_items = tcx.trait_items(did).clean(cx);\n+    let predicates = tcx.lookup_predicates(did);\n     let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n@@ -165,12 +165,12 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n }\n \n fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n-    let t = ty::lookup_item_type(tcx, did);\n+    let t = tcx.lookup_item_type(did);\n     let (decl, style, abi) = match t.ty.sty {\n         ty::TyBareFn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let predicates = tcx.lookup_predicates(did);\n     clean::Function {\n         decl: decl,\n         generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n@@ -183,9 +183,9 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) ->\n fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n     use syntax::parse::token::special_idents::unnamed_field;\n \n-    let t = ty::lookup_item_type(tcx, did);\n-    let predicates = ty::lookup_predicates(tcx, did);\n-    let fields = ty::lookup_struct_fields(tcx, did);\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n+    let fields = tcx.lookup_struct_fields(did);\n \n     clean::Struct {\n         struct_type: match &*fields {\n@@ -201,14 +201,14 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n }\n \n fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n-    let t = ty::lookup_item_type(tcx, did);\n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n         ty::TyEnum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: ty::enum_variants(tcx, edid).clean(cx),\n+                variants: tcx.enum_variants(edid).clean(cx),\n             })\n         }\n         _ => {}\n@@ -222,7 +222,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n \n pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                    did: ast::DefId) -> Vec<clean::Item> {\n-    ty::populate_inherent_implementations_for_type_if_necessary(tcx, did);\n+    tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n     match tcx.inherent_impls.borrow().get(&did) {\n@@ -307,16 +307,16 @@ pub fn build_impl(cx: &DocContext,\n         });\n     }\n \n-    let predicates = ty::lookup_predicates(tcx, did);\n+    let predicates = tcx.lookup_predicates(did);\n     let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n             .iter()\n             .filter_map(|did| {\n         let did = did.def_id();\n-        let impl_item = ty::impl_or_trait_item(tcx, did);\n+        let impl_item = tcx.impl_or_trait_item(did);\n         match impl_item {\n             ty::ConstTraitItem(ref assoc_const) => {\n                 let did = assoc_const.def_id;\n-                let type_scheme = ty::lookup_item_type(tcx, did);\n+                let type_scheme = tcx.lookup_item_type(did);\n                 let default = match assoc_const.default {\n                     Some(_) => Some(const_eval::lookup_const_by_id(tcx, did, None)\n                                                .unwrap().span.to_src(cx)),\n@@ -383,7 +383,7 @@ pub fn build_impl(cx: &DocContext,\n         }\n     }).collect::<Vec<_>>();\n     let polarity = csearch::get_impl_polarity(tcx, did);\n-    let ty = ty::lookup_item_type(tcx, did);\n+    let ty = tcx.lookup_item_type(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n             clean::TraitBound(polyt, _) => polyt.trait_,\n@@ -477,7 +477,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: ty::lookup_item_type(tcx, did).ty.clean(cx),\n+        type_: tcx.lookup_item_type(did).ty.clean(cx),\n         expr: sn\n     }\n }\n@@ -486,7 +486,7 @@ fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId,\n                 mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: ty::lookup_item_type(tcx, did).ty.clean(cx),\n+        type_: tcx.lookup_item_type(did).ty.clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "c25267520ccd80d89289741058fca3e28254f342", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -1332,7 +1332,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n         let provided = match self.container {\n             ty::ImplContainer(..) => false,\n             ty::TraitContainer(did) => {\n-                ty::provided_trait_methods(cx.tcx(), did).iter().any(|m| {\n+                cx.tcx().provided_trait_methods(did).iter().any(|m| {\n                     m.def_id == self.def_id\n                 })\n             }\n@@ -1742,7 +1742,7 @@ impl Clean<Item> for ty::field_ty {\n             (Some(self.name), Some(attr_map.get(&self.id.node).unwrap()))\n         };\n \n-        let ty = ty::lookup_item_type(cx.tcx(), self.id);\n+        let ty = cx.tcx().lookup_item_type(self.id);\n \n         Item {\n             name: name.clean(cx),\n@@ -2731,8 +2731,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             // are actually located on the trait/impl itself, so we need to load\n             // all of the generics from there and then look for bounds that are\n             // applied to this associated type in question.\n-            let def = ty::lookup_trait_def(cx.tcx(), did);\n-            let predicates = ty::lookup_predicates(cx.tcx(), did);\n+            let def = cx.tcx().lookup_trait_def(did);\n+            let predicates = cx.tcx().lookup_predicates(did);\n             let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n             generics.where_predicates.iter().filter_map(|pred| {\n                 let (name, self_type, trait_, bounds) = match *pred {"}, {"sha": "e65cdd8ff5de62e93a29261da5815b9f6aad93a6", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650566ef2a10a0bf1538667ad08bde4ec1a8f227/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=650566ef2a10a0bf1538667ad08bde4ec1a8f227", "patch": "@@ -30,7 +30,6 @@ use std::mem;\n use std::collections::HashMap;\n \n use rustc::middle::subst;\n-use rustc::middle::ty;\n use syntax::ast;\n \n use clean::PathParameters as PP;\n@@ -154,8 +153,8 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: ast::DefId,\n     if child == trait_ {\n         return true\n     }\n-    let def = ty::lookup_trait_def(cx.tcx(), child);\n-    let predicates = ty::lookup_predicates(cx.tcx(), child);\n+    let def = cx.tcx().lookup_trait_def(child);\n+    let predicates = cx.tcx().lookup_predicates(child);\n     let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n     generics.where_predicates.iter().filter_map(|pred| {\n         match *pred {"}]}