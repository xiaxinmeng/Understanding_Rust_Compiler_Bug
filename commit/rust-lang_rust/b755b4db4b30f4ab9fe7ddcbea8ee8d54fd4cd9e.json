{"sha": "b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NTViNGRiNGIzMGY0YWI5ZmU3ZGRjYmVhOGVlOGQ1NGZkNGNkOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-16T20:36:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-16T20:36:41Z"}, "message": "auto merge of #14781 : alexcrichton/rust/issue-14724, r=brson\n\n* os::pipe() now returns `IoResult<os::Pipe>`\r\n* os::pipe() is now unsafe because it does not arrange for deallocation of file\r\n  descriptors\r\n* PipeStream::pair() has been added. This is a safe method to get a pair of\r\n  pipes.\r\n* Dealing with pipes in native process bindings have been improved to be more\r\n  robust in the face of failure and intermittent errors. This converts a few\r\n  fail!() situations to Err situations.\r\n\r\ncc #13538\r\nCloses #14724\r\n[breaking-change]", "tree": {"sha": "461aa1485216741c6bab0a23ebc340586394d1d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461aa1485216741c6bab0a23ebc340586394d1d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "html_url": "https://github.com/rust-lang/rust/commit/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "html_url": "https://github.com/rust-lang/rust/commit/0973eb4419d0598c1134106adef2ee8dc2a2b5ff"}, {"sha": "04eced750e78770e16354c07fddf7ecaaab6ef43", "url": "https://api.github.com/repos/rust-lang/rust/commits/04eced750e78770e16354c07fddf7ecaaab6ef43", "html_url": "https://github.com/rust-lang/rust/commit/04eced750e78770e16354c07fddf7ecaaab6ef43"}], "stats": {"total": 329, "additions": 211, "deletions": 118}, "files": [{"sha": "8f245f1d5b4c47b4aec8fb3cf7b1469a074eeffa", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -172,7 +172,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(unix)] pub use consts::os::posix88::{ENOTCONN, ECONNABORTED, EADDRNOTAVAIL, EINTR};\n #[cfg(unix)] pub use consts::os::posix88::{EADDRINUSE, ENOENT, EISDIR, EAGAIN, EWOULDBLOCK};\n #[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT, EINPROGRESS};\n-#[cfg(unix)] pub use consts::os::posix88::{ENOSYS, ENOTTY, ETIMEDOUT};\n+#[cfg(unix)] pub use consts::os::posix88::{ENOSYS, ENOTTY, ETIMEDOUT, EMFILE};\n #[cfg(unix)] pub use consts::os::posix88::{SIGTERM, SIGKILL, SIGPIPE, PROT_NONE};\n #[cfg(unix)] pub use consts::os::posix01::{SIG_IGN};\n #[cfg(unix)] pub use consts::os::bsd44::{AF_UNIX};\n@@ -196,7 +196,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::c95::{WSAECONNREFUSED, WSAECONNRESET, WSAEACCES};\n #[cfg(windows)] pub use consts::os::c95::{WSAEWOULDBLOCK, WSAENOTCONN, WSAECONNABORTED};\n #[cfg(windows)] pub use consts::os::c95::{WSAEADDRNOTAVAIL, WSAEADDRINUSE, WSAEINTR};\n-#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS, WSAEINVAL};\n+#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS, WSAEINVAL, WSAEMFILE};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_INSUFFICIENT_BUFFER};\n #[cfg(windows)] pub use consts::os::extra::{O_BINARY, O_NOINHERIT, PAGE_NOACCESS};\n #[cfg(windows)] pub use consts::os::extra::{PAGE_READONLY, PAGE_READWRITE, PAGE_EXECUTE};"}, {"sha": "93938e3d5b860925fbb6b4e69e07ccd21e0d15c6", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -525,9 +525,9 @@ mod tests {\n     fn test_file_desc() {\n         // Run this test with some pipes so we don't have to mess around with\n         // opening or closing files.\n-        let os::Pipe { input, out } = os::pipe();\n-        let mut reader = FileDesc::new(input, true);\n-        let mut writer = FileDesc::new(out, true);\n+        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+        let mut reader = FileDesc::new(reader, true);\n+        let mut writer = FileDesc::new(writer, true);\n \n         writer.inner_write(bytes!(\"test\")).ok().unwrap();\n         let mut buf = [0u8, ..4];"}, {"sha": "d18e92866bf7a1054def771fafd83df9cfd0933c", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -158,8 +158,8 @@ mod imp {\n     pub type signal = libc::c_int;\n \n     pub fn new() -> (signal, signal) {\n-        let pipe = os::pipe();\n-        (pipe.input, pipe.out)\n+        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+        (reader, writer)\n     }\n \n     pub fn signal(fd: libc::c_int) {"}, {"sha": "c421dada205fc7e9f4886d195df2eda291cba6cc", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 123, "deletions": 80, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -10,12 +10,13 @@\n \n use libc::{pid_t, c_void, c_int};\n use libc;\n+use std::c_str::CString;\n+use std::io;\n use std::mem;\n use std::os;\n use std::ptr;\n-use std::rt::rtio;\n use std::rt::rtio::{ProcessConfig, IoResult, IoError};\n-use std::c_str::CString;\n+use std::rt::rtio;\n \n use super::file;\n use super::util;\n@@ -73,47 +74,43 @@ impl Process {\n \n         fn get_io(io: rtio::StdioContainer,\n                   ret: &mut Vec<Option<file::FileDesc>>)\n-            -> (Option<os::Pipe>, c_int)\n+            -> IoResult<Option<file::FileDesc>>\n         {\n             match io {\n-                rtio::Ignored => { ret.push(None); (None, -1) }\n-                rtio::InheritFd(fd) => { ret.push(None); (None, fd) }\n+                rtio::Ignored => { ret.push(None); Ok(None) }\n+                rtio::InheritFd(fd) => {\n+                    ret.push(None);\n+                    Ok(Some(file::FileDesc::new(fd, true)))\n+                }\n                 rtio::CreatePipe(readable, _writable) => {\n-                    let pipe = os::pipe();\n+                    let (reader, writer) = try!(pipe());\n                     let (theirs, ours) = if readable {\n-                        (pipe.input, pipe.out)\n+                        (reader, writer)\n                     } else {\n-                        (pipe.out, pipe.input)\n+                        (writer, reader)\n                     };\n-                    ret.push(Some(file::FileDesc::new(ours, true)));\n-                    (Some(pipe), theirs)\n+                    ret.push(Some(ours));\n+                    Ok(Some(theirs))\n                 }\n             }\n         }\n \n         let mut ret_io = Vec::new();\n-        let (in_pipe, in_fd) = get_io(cfg.stdin, &mut ret_io);\n-        let (out_pipe, out_fd) = get_io(cfg.stdout, &mut ret_io);\n-        let (err_pipe, err_fd) = get_io(cfg.stderr, &mut ret_io);\n-\n-        let res = spawn_process_os(cfg, in_fd, out_fd, err_fd);\n-\n-        unsafe {\n-            for pipe in in_pipe.iter() { let _ = libc::close(pipe.input); }\n-            for pipe in out_pipe.iter() { let _ = libc::close(pipe.out); }\n-            for pipe in err_pipe.iter() { let _ = libc::close(pipe.out); }\n-        }\n+        let res = spawn_process_os(cfg,\n+                                   try!(get_io(cfg.stdin, &mut ret_io)),\n+                                   try!(get_io(cfg.stdout, &mut ret_io)),\n+                                   try!(get_io(cfg.stderr, &mut ret_io)));\n \n         match res {\n             Ok(res) => {\n-                Ok((Process {\n-                        pid: res.pid,\n-                        handle: res.handle,\n-                        exit_code: None,\n-                        exit_signal: None,\n-                        deadline: 0,\n-                    },\n-                    ret_io))\n+                let p = Process {\n+                    pid: res.pid,\n+                    handle: res.handle,\n+                    exit_code: None,\n+                    exit_signal: None,\n+                    deadline: 0,\n+                };\n+                Ok((p, ret_io))\n             }\n             Err(e) => Err(e)\n         }\n@@ -194,6 +191,37 @@ impl Drop for Process {\n     }\n }\n \n+fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> {\n+    #[cfg(unix)] use ERROR = libc::EMFILE;\n+    #[cfg(windows)] use ERROR = libc::WSAEMFILE;\n+    struct Closer { fd: libc::c_int }\n+\n+    let os::Pipe { reader, writer } = match unsafe { os::pipe() } {\n+        Ok(p) => p,\n+        Err(io::IoError { detail, .. }) => return Err(IoError {\n+            code: ERROR as uint,\n+            extra: 0,\n+            detail: detail,\n+        })\n+    };\n+    let mut reader = Closer { fd: reader };\n+    let mut writer = Closer { fd: writer };\n+\n+    let native_reader = file::FileDesc::new(reader.fd, true);\n+    reader.fd = -1;\n+    let native_writer = file::FileDesc::new(writer.fd, true);\n+    writer.fd = -1;\n+    return Ok((native_reader, native_writer));\n+\n+    impl Drop for Closer {\n+        fn drop(&mut self) {\n+            if self.fd != -1 {\n+                let _ = unsafe { libc::close(self.fd) };\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(windows)]\n unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n     let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n@@ -246,7 +274,9 @@ struct SpawnProcessResult {\n \n #[cfg(windows)]\n fn spawn_process_os(cfg: ProcessConfig,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int)\n+                    in_fd: Option<file::FileDesc>,\n+                    out_fd: Option<file::FileDesc>,\n+                    err_fd: Option<file::FileDesc>)\n                  -> IoResult<SpawnProcessResult> {\n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n@@ -283,47 +313,51 @@ fn spawn_process_os(cfg: ProcessConfig,\n         // Similarly to unix, we don't actually leave holes for the stdio file\n         // descriptors, but rather open up /dev/null equivalents. These\n         // equivalents are drawn from libuv's windows process spawning.\n-        let set_fd = |fd: c_int, slot: &mut HANDLE, is_stdin: bool| {\n-            if fd == -1 {\n-                let access = if is_stdin {\n-                    libc::FILE_GENERIC_READ\n-                } else {\n-                    libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n-                };\n-                let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                let mut sa = libc::SECURITY_ATTRIBUTES {\n-                    nLength: size as libc::DWORD,\n-                    lpSecurityDescriptor: ptr::mut_null(),\n-                    bInheritHandle: 1,\n-                };\n-                let filename = \"NUL\".to_utf16().append_one(0);\n-                *slot = libc::CreateFileW(filename.as_ptr(),\n-                                          access,\n-                                          libc::FILE_SHARE_READ |\n-                                              libc::FILE_SHARE_WRITE,\n-                                          &mut sa,\n-                                          libc::OPEN_EXISTING,\n-                                          0,\n-                                          ptr::mut_null());\n-                if *slot == INVALID_HANDLE_VALUE as libc::HANDLE {\n-                    return Err(super::last_error())\n-                }\n-            } else {\n-                let orig = get_osfhandle(fd) as HANDLE;\n-                if orig == INVALID_HANDLE_VALUE as HANDLE {\n-                    return Err(super::last_error())\n+        let set_fd = |fd: &Option<file::FileDesc>, slot: &mut HANDLE,\n+                      is_stdin: bool| {\n+            match *fd {\n+                None => {\n+                    let access = if is_stdin {\n+                        libc::FILE_GENERIC_READ\n+                    } else {\n+                        libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n+                    };\n+                    let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                    let mut sa = libc::SECURITY_ATTRIBUTES {\n+                        nLength: size as libc::DWORD,\n+                        lpSecurityDescriptor: ptr::mut_null(),\n+                        bInheritHandle: 1,\n+                    };\n+                    let filename = \"NUL\".to_utf16().append_one(0);\n+                    *slot = libc::CreateFileW(filename.as_ptr(),\n+                                              access,\n+                                              libc::FILE_SHARE_READ |\n+                                                  libc::FILE_SHARE_WRITE,\n+                                              &mut sa,\n+                                              libc::OPEN_EXISTING,\n+                                              0,\n+                                              ptr::mut_null());\n+                    if *slot == INVALID_HANDLE_VALUE as libc::HANDLE {\n+                        return Err(super::last_error())\n+                    }\n                 }\n-                if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n-                                   0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                    return Err(super::last_error())\n+                Some(ref fd) => {\n+                    let orig = get_osfhandle(fd.fd()) as HANDLE;\n+                    if orig == INVALID_HANDLE_VALUE as HANDLE {\n+                        return Err(super::last_error())\n+                    }\n+                    if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n+                                       0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                        return Err(super::last_error())\n+                    }\n                 }\n             }\n             Ok(())\n         };\n \n-        try!(set_fd(in_fd, &mut si.hStdInput, true));\n-        try!(set_fd(out_fd, &mut si.hStdOutput, false));\n-        try!(set_fd(err_fd, &mut si.hStdError, false));\n+        try!(set_fd(&in_fd, &mut si.hStdInput, true));\n+        try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n+        try!(set_fd(&err_fd, &mut si.hStdError, false));\n \n         let cmd_str = make_command_line(cfg.program, cfg.args);\n         let mut pi = zeroed_process_information();\n@@ -464,7 +498,10 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n }\n \n #[cfg(unix)]\n-fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_int)\n+fn spawn_process_os(cfg: ProcessConfig,\n+                    in_fd: Option<file::FileDesc>,\n+                    out_fd: Option<file::FileDesc>,\n+                    err_fd: Option<file::FileDesc>)\n                 -> IoResult<SpawnProcessResult>\n {\n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n@@ -498,9 +535,7 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n \n     with_envp(cfg.env, proc(envp) {\n         with_argv(cfg.program, cfg.args, proc(argv) unsafe {\n-            let pipe = os::pipe();\n-            let mut input = file::FileDesc::new(pipe.input, true);\n-            let mut output = file::FileDesc::new(pipe.out, true);\n+            let (mut input, mut output) = try!(pipe());\n \n             // We may use this in the child, so perform allocations before the\n             // fork\n@@ -510,7 +545,7 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n \n             let pid = fork();\n             if pid < 0 {\n-                fail!(\"failure in fork: {}\", os::last_os_error());\n+                return Err(super::last_error())\n             } else if pid > 0 {\n                 drop(output);\n                 let mut bytes = [0, ..4];\n@@ -586,16 +621,24 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n             // up /dev/null into that file descriptor. Otherwise, the first file\n             // descriptor opened up in the child would be numbered as one of the\n             // stdio file descriptors, which is likely to wreak havoc.\n-            let setup = |src: c_int, dst: c_int| {\n-                let src = if src == -1 {\n-                    let flags = if dst == libc::STDIN_FILENO {\n-                        libc::O_RDONLY\n-                    } else {\n-                        libc::O_RDWR\n-                    };\n-                    devnull.with_ref(|p| libc::open(p, flags, 0))\n-                } else {\n-                    src\n+            let setup = |src: Option<file::FileDesc>, dst: c_int| {\n+                let src = match src {\n+                    None => {\n+                        let flags = if dst == libc::STDIN_FILENO {\n+                            libc::O_RDONLY\n+                        } else {\n+                            libc::O_RDWR\n+                        };\n+                        devnull.with_ref(|p| libc::open(p, flags, 0))\n+                    }\n+                    Some(obj) => {\n+                        let fd = obj.fd();\n+                        // Leak the memory and the file descriptor. We're in the\n+                        // child now an all our resources are going to be\n+                        // cleaned up very soon\n+                        mem::forget(obj);\n+                        fd\n+                    }\n                 };\n                 src != -1 && retry(|| dup2(src, dst)) != -1\n             };"}, {"sha": "84d388c113630ecba3187a4609c5e8785ae5d6f7", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -16,8 +16,10 @@\n #![allow(missing_doc)]\n \n use prelude::*;\n+\n use io::{IoResult, IoError};\n use libc;\n+use os;\n use owned::Box;\n use rt::rtio::{RtioPipe, LocalIo};\n \n@@ -27,6 +29,11 @@ pub struct PipeStream {\n     obj: Box<RtioPipe + Send>,\n }\n \n+pub struct PipePair {\n+    pub reader: PipeStream,\n+    pub writer: PipeStream,\n+}\n+\n impl PipeStream {\n     /// Consumes a file descriptor to return a pipe stream that will have\n     /// synchronous, but non-blocking reads/writes. This is useful if the file\n@@ -58,6 +65,38 @@ impl PipeStream {\n     pub fn new(inner: Box<RtioPipe + Send>) -> PipeStream {\n         PipeStream { obj: inner }\n     }\n+\n+    /// Creates a pair of in-memory OS pipes for a unidirectional communication\n+    /// stream.\n+    ///\n+    /// The structure returned contains a reader and writer I/O object. Data\n+    /// written to the writer can be read from the reader.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function can fail to succeed if the underlying OS has run out of\n+    /// available resources to allocate a new pipe.\n+    pub fn pair() -> IoResult<PipePair> {\n+        struct Closer { fd: libc::c_int }\n+\n+        let os::Pipe { reader, writer } = try!(unsafe { os::pipe() });\n+        let mut reader = Closer { fd: reader };\n+        let mut writer = Closer { fd: writer };\n+\n+        let io_reader = try!(PipeStream::open(reader.fd));\n+        reader.fd = -1;\n+        let io_writer = try!(PipeStream::open(writer.fd));\n+        writer.fd = -1;\n+        return Ok(PipePair { reader: io_reader, writer: io_writer });\n+\n+        impl Drop for Closer {\n+            fn drop(&mut self) {\n+                if self.fd != -1 {\n+                    let _ = unsafe { libc::close(self.fd) };\n+                }\n+            }\n+        }\n+    }\n }\n \n impl Clone for PipeStream {\n@@ -84,9 +123,9 @@ mod test {\n         use os;\n         use io::pipe::PipeStream;\n \n-        let os::Pipe { input, out } = os::pipe();\n-        let out = PipeStream::open(out);\n-        let mut input = PipeStream::open(input);\n+        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+        let out = PipeStream::open(writer);\n+        let mut input = PipeStream::open(reader);\n         let (tx, rx) = channel();\n         spawn(proc() {\n             let mut out = out;"}, {"sha": "0747e7ccbe3fd98c7e4ba7466ddb981525934cc7", "filename": "src/libstd/os.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -32,6 +32,7 @@\n use clone::Clone;\n use collections::Collection;\n use fmt;\n+use io::{IoResult, IoError};\n use iter::Iterator;\n use libc::{c_void, c_int};\n use libc;\n@@ -513,40 +514,50 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n pub struct Pipe {\n     /// A file descriptor representing the reading end of the pipe. Data written\n     /// on the `out` file descriptor can be read from this file descriptor.\n-    pub input: c_int,\n+    pub reader: c_int,\n     /// A file descriptor representing the write end of the pipe. Data written\n     /// to this file descriptor can be read from the `input` file descriptor.\n-    pub out: c_int,\n+    pub writer: c_int,\n }\n \n-/// Creates a new low-level OS in-memory pipe represented as a Pipe struct.\n-#[cfg(unix)]\n-pub fn pipe() -> Pipe {\n-    unsafe {\n-        let mut fds = Pipe {input: 0,\n-                            out: 0};\n-        assert_eq!(libc::pipe(&mut fds.input), 0);\n-        return Pipe {input: fds.input, out: fds.out};\n+/// Creates a new low-level OS in-memory pipe.\n+///\n+/// This function can fail to succeed if there are no more resources available\n+/// to allocate a pipe.\n+///\n+/// This function is also unsafe as there is no destructor associated with the\n+/// `Pipe` structure will return. If it is not arranged for the returned file\n+/// descriptors to be closed, the file descriptors will leak. For safe handling\n+/// of this scenario, use `std::io::PipeStream` instead.\n+pub unsafe fn pipe() -> IoResult<Pipe> {\n+    return _pipe();\n+\n+    #[cfg(unix)]\n+    unsafe fn _pipe() -> IoResult<Pipe> {\n+        let mut fds = [0, ..2];\n+        match libc::pipe(fds.as_mut_ptr()) {\n+            0 => Ok(Pipe { reader: fds[0], writer: fds[1] }),\n+            _ => Err(IoError::last_error()),\n+        }\n     }\n-}\n \n-/// Creates a new low-level OS in-memory pipe represented as a Pipe struct.\n-#[cfg(windows)]\n-pub fn pipe() -> Pipe {\n-    unsafe {\n+    #[cfg(windows)]\n+    unsafe fn _pipe() -> IoResult<Pipe> {\n         // Windows pipes work subtly differently than unix pipes, and their\n         // inheritance has to be handled in a different way that I do not\n         // fully understand. Here we explicitly make the pipe non-inheritable,\n         // which means to pass it to a subprocess they need to be duplicated\n         // first, as in std::run.\n-        let mut fds = Pipe {input: 0,\n-                    out: 0};\n-        let res = libc::pipe(&mut fds.input, 1024 as ::libc::c_uint,\n-                             (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-        assert_eq!(res, 0);\n-        assert!((fds.input != -1 && fds.input != 0 ));\n-        assert!((fds.out != -1 && fds.input != 0));\n-        return Pipe {input: fds.input, out: fds.out};\n+        let mut fds = [0, ..2];\n+        match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+            0 => {\n+                assert!(fds[0] != -1 && fds[0] != 0);\n+                assert!(fds[1] != -1 && fds[1] != 0);\n+                Ok(Pipe { reader: fds[0], writer: fds[1] })\n+            }\n+            _ => Err(IoError::last_error()),\n+        }\n     }\n }\n "}, {"sha": "8c68ef173a5e76fc216b02bc88b043ce798d6370", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=b755b4db4b30f4ab9fe7ddcbea8ee8d54fd4cd9e", "patch": "@@ -16,12 +16,12 @@ use std::io::PipeStream;\n use std::io::Command;\n \n fn test() {\n-    let os::Pipe { input, out } = os::pipe();\n-    let input = PipeStream::open(input);\n-    let mut out = PipeStream::open(out);\n-    drop(input);\n+    let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+    let reader = PipeStream::open(reader);\n+    let mut writer = PipeStream::open(writer);\n+    drop(reader);\n \n-    let _ = out.write([1]);\n+    let _ = writer.write([1]);\n }\n \n fn main() {"}]}