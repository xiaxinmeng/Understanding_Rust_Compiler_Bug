{"sha": "68517a2cca613d2018819d0eb38f6c0a864d1836", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NTE3YTJjY2E2MTNkMjAxODgxOWQwZWIzOGY2YzBhODY0ZDE4MzY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-17T12:23:09Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-19T01:56:26Z"}, "message": "syntax: convert ast_map to use a SmallIntMap.\n\nNodeIds are sequential integers starting at zero, so we can achieve some\nmemory savings by just storing the items all in a line in a vector.\n\nThe occupancy for typical crates seems to be 75-80%, so we're already\nmore efficient than a HashMap (maximum occupancy 75%), not even counting\nthe extra book-keeping that HashMap does.", "tree": {"sha": "aff340c4fdb1d38f8997479e9b5cea5990f6ea80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aff340c4fdb1d38f8997479e9b5cea5990f6ea80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68517a2cca613d2018819d0eb38f6c0a864d1836", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68517a2cca613d2018819d0eb38f6c0a864d1836", "html_url": "https://github.com/rust-lang/rust/commit/68517a2cca613d2018819d0eb38f6c0a864d1836", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68517a2cca613d2018819d0eb38f6c0a864d1836/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f6ef080bb69ce4370c04c92cc92b9a860e5725", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f6ef080bb69ce4370c04c92cc92b9a860e5725", "html_url": "https://github.com/rust-lang/rust/commit/d0f6ef080bb69ce4370c04c92cc92b9a860e5725"}], "stats": {"total": 412, "additions": 195, "deletions": 217}, "files": [{"sha": "5271d6ceba631ff7eb04db9cf08fb801c13a88a0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -496,9 +496,8 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::PathElem],\n                                     exp: &middle::resolve::Export2) {\n-    let items = ecx.tcx.items.borrow();\n-    match items.get().find(&exp.def_id.node) {\n-        Some(&ast_map::NodeItem(item, path)) => {\n+    match ecx.tcx.items.find(exp.def_id.node) {\n+        Some(ast_map::NodeItem(item, path)) => {\n             let original_name = ecx.tcx.sess.str_of(item.ident);\n \n             //\n@@ -1347,8 +1346,7 @@ fn my_visit_item(i: &Item,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n                  index: @RefCell<~[entry<i64>]>) {\n-    let items = items.borrow();\n-    match items.get().get_copy(&i.id) {\n+    match items.get(i.id) {\n         ast_map::NodeItem(_, pt) => {\n             let mut ebml_w = unsafe {\n                 ebml_w.unsafe_clone()\n@@ -1366,8 +1364,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n                          index: @RefCell<~[entry<i64>]>) {\n-    let items = items.borrow();\n-    match items.get().get_copy(&ni.id) {\n+    match items.get(ni.id) {\n         ast_map::NodeForeignItem(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str("}, {"sha": "748458789074e8b29055b79ba0a3922dc8b5abb9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -550,9 +550,8 @@ impl BorrowckCtxt {\n             move_data::Declared => {}\n \n             move_data::MoveExpr => {\n-                let items = self.tcx.items.borrow();\n-                let (expr_ty, expr_span) = match items.get().find(&move.id) {\n-                    Some(&ast_map::NodeExpr(expr)) => {\n+                let (expr_ty, expr_span) = match self.tcx.items.find(move.id) {\n+                    Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n@@ -578,9 +577,8 @@ impl BorrowckCtxt {\n             }\n \n             move_data::Captured => {\n-                let items = self.tcx.items.borrow();\n-                let (expr_ty, expr_span) = match items.get().find(&move.id) {\n-                    Some(&ast_map::NodeExpr(expr)) => {\n+                let (expr_ty, expr_span) = match self.tcx.items.find(move.id) {\n+                    Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n@@ -768,9 +766,8 @@ impl BorrowckCtxt {\n                                    out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n-                let items = self.tcx.items.borrow();\n-                match items.get().find(&id) {\n-                    Some(&ast_map::NodeLocal(ref ident, _)) => {\n+                match self.tcx.items.find(id) {\n+                    Some(ast_map::NodeLocal(ref ident, _)) => {\n                         out.push_str(token::ident_to_str(ident));\n                     }\n                     r => {"}, {"sha": "efa1bd5fd519e6e49888239108f34eb97d1257b0", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -250,8 +250,7 @@ impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n                 match def_map.get().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n-                        let ast_map = self.ast_map.borrow();\n-                        match ast_map.get().get_copy(&def_id.node) {\n+                        match self.ast_map.get(def_id.node) {\n                             ast_map::NodeItem(it, _) => {\n                                 self.visit_item(it, ());\n                             }"}, {"sha": "770275f3f6a21aab02c3128f1c6adc9a1790fbc1", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -108,10 +108,9 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n \n     if ast_util::is_local(enum_def) {\n         {\n-            let items = tcx.items.borrow();\n-            match items.get().find(&enum_def.node) {\n+            match tcx.items.find(enum_def.node) {\n                 None => None,\n-                Some(&ast_map::NodeItem(it, _)) => match it.node {\n+                Some(ast_map::NodeItem(it, _)) => match it.node {\n                     ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                         variant_expr(*variants, variant_def.node)\n                     }\n@@ -161,10 +160,9 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n                           -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n         {\n-            let items = tcx.items.borrow();\n-            match items.get().find(&def_id.node) {\n+            match tcx.items.find(def_id.node) {\n                 None => None,\n-                Some(&ast_map::NodeItem(it, _)) => match it.node {\n+                Some(ast_map::NodeItem(it, _)) => match it.node {\n                     ItemStatic(_, ast::MutImmutable, const_expr) => {\n                         Some(const_expr)\n                     }"}, {"sha": "746cc74d7f6f1a01b72b21c3147b3faa4af07151", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -38,12 +38,11 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n         return false;\n     }\n \n-    let items = tcx.items.borrow();\n-    match items.get().find(&def_id.node) {\n-        Some(&ast_map::NodeItem(..))\n-        | Some(&ast_map::NodeMethod(..))\n-        | Some(&ast_map::NodeForeignItem(..))\n-        | Some(&ast_map::NodeTraitMethod(..)) => true,\n+    match tcx.items.find(def_id.node) {\n+        Some(ast_map::NodeItem(..))\n+        | Some(ast_map::NodeMethod(..))\n+        | Some(ast_map::NodeForeignItem(..))\n+        | Some(ast_map::NodeTraitMethod(..)) => true,\n         _ => false\n     }\n }\n@@ -136,9 +135,8 @@ impl MarkSymbolVisitor {\n             }\n             scanned.insert(id);\n \n-            let items = self.tcx.items.borrow();\n-            match items.get().find(&id) {\n-                Some(node) => {\n+            match self.tcx.items.find(id) {\n+                Some(ref node) => {\n                     self.live_symbols.insert(id);\n                     self.visit_node(node);\n                 }"}, {"sha": "3938a786a3991e7950dfafd3ab26465a8e8ed1be", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -75,9 +75,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n         ItemFn(..) => {\n             if item.ident.name == special_idents::main.name {\n                 {\n-                    let ast_map = ctxt.ast_map.borrow();\n-                    match ast_map.get().find(&item.id) {\n-                        Some(&ast_map::NodeItem(_, path)) => {\n+                    match ctxt.ast_map.find(item.id) {\n+                        Some(ast_map::NodeItem(_, path)) => {\n                             if path.len() == 0 {\n                                 // This is a top-level function so can be 'main'\n                                 if ctxt.main_fn.is_none() {"}, {"sha": "07caf28b8019c8589fdd1e9580f028b474679845", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -1330,8 +1330,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n     let stability = if ast_util::is_local(id) {\n         // this crate\n-        let items = cx.tcx.items.borrow();\n-        match items.get().find(&id.node) {\n+        match cx.tcx.items.find(id.node) {\n             Some(ast_node) => {\n                 let s = ast_node.with_attrs(|attrs| {\n                     attrs.map(|a| {"}, {"sha": "a430790a2af30a6c7703b11a98e0b7725b91830c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -431,8 +431,7 @@ impl<'a> PrivacyVisitor<'a> {\n         let mut closest_private_id = did.node;\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let items = self.tcx.items.borrow();\n-            let vis = match items.get().find(&closest_private_id) {\n+            let vis = match self.tcx.items.find(closest_private_id) {\n                 // If this item is a method, then we know for sure that it's an\n                 // actual method and not a static method. The reason for this is\n                 // that these cases are only hit in the ExprMethodCall\n@@ -449,22 +448,22 @@ impl<'a> PrivacyVisitor<'a> {\n                 // invocation.\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n-                Some(&ast_map::NodeMethod(ref m, imp, _)) => {\n+                Some(ast_map::NodeMethod(ref m, imp, _)) => {\n                     match ty::impl_trait_ref(self.tcx, imp) {\n                         Some(..) => return Allowable,\n                         _ if m.vis == ast::Public => return Allowable,\n                         _ => m.vis\n                     }\n                 }\n-                Some(&ast_map::NodeTraitMethod(..)) => {\n+                Some(ast_map::NodeTraitMethod(..)) => {\n                     return Allowable;\n                 }\n \n                 // This is not a method call, extract the visibility as one\n                 // would normally look at it\n-                Some(&ast_map::NodeItem(it, _)) => it.vis,\n-                Some(&ast_map::NodeForeignItem(_, _, v, _)) => v,\n-                Some(&ast_map::NodeVariant(ref v, _, _)) => {\n+                Some(ast_map::NodeItem(it, _)) => it.vis,\n+                Some(ast_map::NodeForeignItem(_, _, v, _)) => v,\n+                Some(ast_map::NodeVariant(ref v, _, _)) => {\n                     // sadly enum variants still inherit visibility, so only\n                     // break out of this is explicitly private\n                     if v.node.vis == ast::Private { break }\n@@ -538,9 +537,8 @@ impl<'a> PrivacyVisitor<'a> {\n                     self.tcx.sess.span_err(span, format!(\"{} is inaccessible\",\n                                                          msg));\n                 }\n-                let items = self.tcx.items.borrow();\n-                match items.get().find(&id) {\n-                    Some(&ast_map::NodeItem(item, _)) => {\n+                match self.tcx.items.find(id) {\n+                    Some(ast_map::NodeItem(item, _)) => {\n                         let desc = match item.node {\n                             ast::ItemMod(..) => \"module\",\n                             ast::ItemTrait(..) => \"trait\","}, {"sha": "6f8ad77e90b2d83346d67386542a0f206a5129fe", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -66,9 +66,8 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n     }\n     if is_local(impl_src) {\n         {\n-            let items = tcx.items.borrow();\n-            match items.get().find(&impl_src.node) {\n-                Some(&ast_map::NodeItem(item, _)) => {\n+            match tcx.items.find(impl_src.node) {\n+                Some(ast_map::NodeItem(item, _)) => {\n                     item_might_be_inlined(item)\n                 }\n                 Some(..) | None => {\n@@ -213,30 +212,29 @@ impl ReachableContext {\n         }\n \n         let node_id = def_id.node;\n-        let items = tcx.items.borrow();\n-        match items.get().find(&node_id) {\n-            Some(&ast_map::NodeItem(item, _)) => {\n+        match tcx.items.find(node_id) {\n+            Some(ast_map::NodeItem(item, _)) => {\n                 match item.node {\n                     ast::ItemFn(..) => item_might_be_inlined(item),\n                     _ => false,\n                 }\n             }\n-            Some(&ast_map::NodeTraitMethod(trait_method, _, _)) => {\n+            Some(ast_map::NodeTraitMethod(trait_method, _, _)) => {\n                 match *trait_method {\n                     ast::Required(_) => false,\n                     ast::Provided(_) => true,\n                 }\n             }\n-            Some(&ast_map::NodeMethod(method, impl_did, _)) => {\n+            Some(ast_map::NodeMethod(method, impl_did, _)) => {\n                 if generics_require_inlining(&method.generics) ||\n                         attributes_specify_inlining(method.attrs) {\n                     true\n                 } else {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.crate == ast::LOCAL_CRATE);\n-                    match items.get().find(&impl_did.node) {\n-                        Some(&ast_map::NodeItem(item, _)) => {\n+                    match tcx.items.find(impl_did.node) {\n+                        Some(ast_map::NodeItem(item, _)) => {\n                             match item.node {\n                                 ast::ItemImpl(ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n@@ -294,9 +292,8 @@ impl ReachableContext {\n             };\n \n             scanned.insert(search_item);\n-            let items = self.tcx.items.borrow();\n-            match items.get().find(&search_item) {\n-                Some(item) => self.propagate_node(item, search_item,\n+            match self.tcx.items.find(search_item) {\n+                Some(ref item) => self.propagate_node(item, search_item,\n                                                   &mut visitor),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n                 None => {"}, {"sha": "583a15b85c9a05e9c4887ffa8a840a1b8a5f1bf6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -1731,8 +1731,7 @@ impl Visitor<()> for TransItemVisitor {\n pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     let path = {\n-        let items = ccx.tcx.items.borrow();\n-        match items.get().get_copy(&item.id) {\n+        match ccx.tcx.items.get(item.id) {\n             ast_map::NodeItem(_, p) => p,\n             // tjc: ?\n             _ => fail!(\"trans_item\"),\n@@ -2034,10 +2033,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n         Some(v) => v,\n         None => {\n             let mut foreign = false;\n-            let item = {\n-                let items = ccx.tcx.items.borrow();\n-                items.get().get_copy(&id)\n-            };\n+            let item = ccx.tcx.items.get(id);\n             let val = match item {\n                 ast_map::NodeItem(i, pth) => {\n "}, {"sha": "229a1b3662defea610468d6cdfd6c67b0ed63a78", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -365,13 +365,12 @@ pub fn trans_fn_ref_with_vtables(\n         must_monomorphise = true;\n     } else if def_id.crate == ast::LOCAL_CRATE {\n         {\n-            let items = ccx.tcx.items.borrow();\n             let map_node = session::expect(\n                 ccx.sess,\n-                items.get().find(&def_id.node),\n+                ccx.tcx.items.find(def_id.node),\n                 || format!(\"local item should be in ast map\"));\n \n-            match *map_node {\n+            match map_node {\n                 ast_map::NodeForeignItem(_, abis, _, _) => {\n                     must_monomorphise = abis.is_intrinsic()\n                 }"}, {"sha": "d70f2ab7d99b9175d279fb2585c1a4e8690d13a8", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -166,10 +166,7 @@ pub fn get_const_val(cx: @CrateContext,\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n-        let opt_item = {\n-            let items = cx.tcx.items.borrow();\n-            items.get().get_copy(&def_id.node)\n-        };\n+        let opt_item = cx.tcx.items.get(def_id.node);\n \n         match opt_item {\n             ast_map::NodeItem(item, _) => {"}, {"sha": "d256dd7e9a37955d36b2cc49a92f9afd8f1b38a2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -322,10 +322,8 @@ pub fn create_captured_var_metadata(bcx: &Block,\n \n     let cx = bcx.ccx();\n \n-    let ast_item = {\n-        let items = cx.tcx.items.borrow();\n-        items.get().find_copy(&node_id)\n-    };\n+    let ast_item = cx.tcx.items.find(node_id);\n+\n     let variable_ident = match ast_item {\n         None => {\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n@@ -423,10 +421,7 @@ pub fn create_self_argument_metadata(bcx: &Block,\n     }\n \n     // Extract the span of the self argument from the method's AST\n-    let fnitem = {\n-        let items = bcx.ccx().tcx.items.borrow();\n-        items.get().get_copy(&bcx.fcx.id)\n-    };\n+    let fnitem = bcx.ccx().tcx.items.get(bcx.fcx.id);\n     let span = match fnitem {\n         ast_map::NodeMethod(method, _, _) => {\n             method.explicit_self.span\n@@ -613,10 +608,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n-    let fnitem = {\n-        let items = cx.tcx.items.borrow();\n-        items.get().get_copy(&fn_ast_id)\n-    };\n+    let fnitem = cx.tcx.items.get(fn_ast_id);\n+\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item, _) => {\n             match item.node {\n@@ -1098,8 +1091,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     match scope_map.get().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n-            let items = fcx.ccx.tcx.items.borrow();\n-            let node = items.get().get_copy(&node_id);\n+            let node = fcx.ccx.tcx.items.get(node_id);\n \n             fcx.ccx.sess.span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n@@ -1419,9 +1411,8 @@ fn describe_enum_variant(cx: &CrateContext,\n     // Find the source code location of the variant's definition\n     let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n         {\n-            let items = cx.tcx.items.borrow();\n-            match items.get().find(&variant_info.id.node) {\n-                Some(&ast_map::NodeVariant(ref variant, _, _)) => variant.span,\n+            match cx.tcx.items.find(variant_info.id.node) {\n+                Some(ast_map::NodeVariant(ref variant, _, _)) => variant.span,\n                 ref node => {\n                     cx.sess.span_warn(span,\n                         format!(\"debuginfo::enum_metadata()::\\\n@@ -2300,9 +2291,8 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n     let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n     let definition_span = if def_id.crate == ast::LOCAL_CRATE {\n         {\n-            let items = cx.tcx.items.borrow();\n-            let definition_span = match items.get().find(&def_id.node) {\n-                Some(&ast_map::NodeItem(item, _)) => item.span,\n+            let definition_span = match cx.tcx.items.find(def_id.node) {\n+                Some(ast_map::NodeItem(item, _)) => item.span,\n                 ref node => {\n                     cx.sess.span_warn(warning_span,\n                         format!(\"debuginfo::\\"}, {"sha": "2526d8e3fea27655410b3a47adb9ed67908361be", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -354,9 +354,8 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::ForeignItemFn(..) => {\n-                let items = ccx.tcx.items.borrow();\n                 let (abis, mut path) =\n-                    match items.get().get_copy(&foreign_item.id) {\n+                    match ccx.tcx.items.get(foreign_item.id) {\n                         ast_map::NodeForeignItem(_, abis, _, path) => {\n                             (abis, (*path).clone())\n                         }"}, {"sha": "675052856304dc73c8b1bba3ef43d38e50118add", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -337,8 +337,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n                 let sp = {\n-                    let items = ccx.tcx.items.borrow();\n-                    match items.get().get_copy(&ref_id.unwrap()) {\n+                    match ccx.tcx.items.get(ref_id.unwrap()) {\n                         ast_map::NodeExpr(e) => e.span,\n                         _ => fail!(\"transmute has non-expr arg\"),\n                     }"}, {"sha": "3badfc38df6c767655c085355b5f9ba6c95f6749", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -238,8 +238,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n     let mname = if method_id.crate == ast::LOCAL_CRATE {\n         {\n-            let items = bcx.tcx().items.borrow();\n-            match items.get().get_copy(&method_id.node) {\n+            match bcx.tcx().items.get(method_id.node) {\n                 ast_map::NodeTraitMethod(trait_method, _, _) => {\n                     ast_util::trait_method_to_ty_method(trait_method).ident\n                 }"}, {"sha": "5e3e323639422c5cc3c0bc45008183a39a17faab", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -95,10 +95,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let mut is_static_provided = None;\n \n     let map_node = {\n-        let items = ccx.tcx.items.borrow();\n         session::expect(\n             ccx.sess,\n-            items.get().find_copy(&fn_id.node),\n+            ccx.tcx.items.find(fn_id.node),\n             || format!(\"While monomorphizing {:?}, couldn't find it in the \\\n                         item map (may have attempted to monomorphize an item \\\n                         defined in a different crate?)\", fn_id))"}, {"sha": "815aa4ba38e0a46298615321eab1ce1b06ada8f4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -3557,9 +3557,8 @@ pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     if is_local(id) {\n         {\n-            let items = cx.items.borrow();\n-            match items.get().find(&id.node) {\n-                Some(&ast_map::NodeItem(item, _)) => {\n+            match cx.items.find(id.node) {\n+                Some(ast_map::NodeItem(item, _)) => {\n                     match item.node {\n                         ItemTrait(_, _, ref ms) => {\n                             let (_, p) = ast_util::split_trait_methods(*ms);\n@@ -3688,9 +3687,8 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     let ret = if id.crate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         {\n-            let items = cx.items.borrow();\n-            match items.get().find(&id.node) {\n-                Some(&ast_map::NodeItem(item, _)) => {\n+            match cx.items.find(id.node) {\n+                Some(ast_map::NodeItem(item, _)) => {\n                     match item.node {\n                         ast::ItemImpl(_, ref opt_trait, _, _) => {\n                             match opt_trait {\n@@ -3885,8 +3883,7 @@ pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::Path {\n     //                each variant.\n     // let node = cx.items.get(&id.node);\n     // match *node {\n-    let items = cx.items.borrow();\n-    match *items.get().get(&id.node) {\n+    match cx.items.get(id.node) {\n         ast_map::NodeItem(item, path) => {\n             let item_elt = match item.node {\n                 ItemMod(_) | ItemForeignMod(_) => {\n@@ -3956,8 +3953,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n         {\n-            let items = cx.items.borrow();\n-            match items.get().get_copy(&id.node) {\n+            match cx.items.get(id.node) {\n               ast_map::NodeItem(item, _) => {\n                   match item.node {\n                     ast::ItemEnum(ref enum_definition, _) => {\n@@ -4081,9 +4077,8 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         {\n-            let items = tcx.items.borrow();\n-            match items.get().find(&did.node) {\n-                Some(&ast_map::NodeItem(item, _)) => {\n+            match tcx.items.find(did.node) {\n+                Some(ast_map::NodeItem(item, _)) => {\n                     item.attrs.iter().advance(|attr| f(attr.node.value))\n                 }\n                 _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n@@ -4165,17 +4160,16 @@ pub fn lookup_field_type(tcx: ctxt,\n pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n   if did.crate == ast::LOCAL_CRATE {\n       {\n-          let items = cx.items.borrow();\n-          match items.get().find(&did.node) {\n-           Some(&ast_map::NodeItem(i,_)) => {\n+          match cx.items.find(did.node) {\n+           Some(ast_map::NodeItem(i,_)) => {\n              match i.node {\n                 ast::ItemStruct(struct_def, _) => {\n                    struct_field_tys(struct_def.fields)\n                 }\n                 _ => cx.sess.bug(\"struct ID bound to non-struct\")\n              }\n            }\n-           Some(&ast_map::NodeVariant(ref variant, _, _)) => {\n+           Some(ast_map::NodeVariant(ref variant, _, _)) => {\n               match (*variant).node.kind {\n                 ast::StructVariantKind(struct_def) => {\n                   struct_field_tys(struct_def.fields)\n@@ -4704,13 +4698,12 @@ pub fn populate_implementations_for_trait_if_necessary(\n /// If it implements no trait, return `None`.\n pub fn trait_id_of_impl(tcx: ctxt,\n                         def_id: ast::DefId) -> Option<ast::DefId> {\n-    let items = tcx.items.borrow();\n-    let node = match items.get().find(&def_id.node) {\n+    let node = match tcx.items.find(def_id.node) {\n         Some(node) => node,\n         None => return None\n     };\n     match node {\n-        &ast_map::NodeItem(item, _) => {\n+        ast_map::NodeItem(item, _) => {\n             match item.node {\n                 ast::ItemImpl(_, Some(ref trait_ref), _, _) => {\n                     Some(node_id_to_trait_ref(tcx, trait_ref.ref_id).def_id)"}, {"sha": "293442417d2bee96f4a77fd092f0dc98dbb879fc", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -1306,10 +1306,9 @@ impl<'a> LookupContext<'a> {\n     fn report_static_candidate(&self, idx: uint, did: DefId) {\n         let span = if did.crate == ast::LOCAL_CRATE {\n             {\n-                let items = self.tcx().items.borrow();\n-                match items.get().find(&did.node) {\n-                  Some(&ast_map::NodeMethod(m, _, _)) => m.span,\n-                  Some(&ast_map::NodeTraitMethod(trait_method, _, _)) => {\n+                match self.tcx().items.find(did.node) {\n+                  Some(ast_map::NodeMethod(m, _, _)) => m.span,\n+                  Some(ast_map::NodeTraitMethod(trait_method, _, _)) => {\n                       match *trait_method {\n                           ast::Provided(m) => m.span,\n                           _ => {"}, {"sha": "89c24cf4116758eace2e3a23cd690d3ad0fa27af", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -570,14 +570,13 @@ impl CoherenceChecker {\n \n                         // Make sure that this type precisely names a nominal\n                         // type.\n-                        let items = self.crate_context.tcx.items.borrow();\n-                        match items.get().find(&def_id.node) {\n+                        match self.crate_context.tcx.items.find(def_id.node) {\n                             None => {\n                                 self.crate_context.tcx.sess.span_bug(\n                                     original_type.span,\n                                     \"resolve didn't resolve this type?!\");\n                             }\n-                            Some(&NodeItem(item, _)) => {\n+                            Some(NodeItem(item, _)) => {\n                                 match item.node {\n                                     ItemStruct(..) | ItemEnum(..) => true,\n                                     _ => false,\n@@ -628,9 +627,8 @@ impl CoherenceChecker {\n \n     pub fn span_of_impl(&self, implementation: @Impl) -> Span {\n         assert_eq!(implementation.did.crate, LOCAL_CRATE);\n-        let items = self.crate_context.tcx.items.borrow();\n-        match items.get().find(&implementation.did.node) {\n-            Some(&NodeItem(item, _)) => {\n+        match self.crate_context.tcx.items.find(implementation.did.node) {\n+            Some(NodeItem(item, _)) => {\n                 return item.span;\n             }\n             _ => {\n@@ -734,9 +732,8 @@ impl CoherenceChecker {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.crate == ast::LOCAL_CRATE {\n                         {\n-                            let items = tcx.items.borrow();\n-                            match items.get().find(&impl_info.did.node) {\n-                                Some(&ast_map::NodeItem(item, _)) => {\n+                            match tcx.items.find(impl_info.did.node) {\n+                                Some(ast_map::NodeItem(item, _)) => {\n                                     tcx.sess.span_err((*item).span,\n                                                       \"the Drop trait may \\\n                                                        only be implemented \\"}, {"sha": "474335caa7bb80b67735ee052ba7fe785c674dd9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -110,10 +110,9 @@ impl AstConv for CrateCtxt {\n             return csearch::get_type(self.tcx, id)\n         }\n \n-        let items = self.tcx.items.borrow();\n-        match items.get().find(&id.node) {\n-            Some(&ast_map::NodeItem(item, _)) => ty_of_item(self, item),\n-            Some(&ast_map::NodeForeignItem(foreign_item, abis, _, _)) => {\n+        match self.tcx.items.find(id.node) {\n+            Some(ast_map::NodeItem(item, _)) => ty_of_item(self, item),\n+            Some(ast_map::NodeForeignItem(foreign_item, abis, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item, abis)\n             }\n             ref x => {\n@@ -185,8 +184,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n     let tcx = ccx.tcx;\n-    let items = tcx.items.borrow();\n-    match items.get().get_copy(&trait_id) {\n+    match tcx.items.get(trait_id) {\n         ast_map::NodeItem(item, _) => {\n             match item.node {\n                 ast::ItemTrait(ref generics, _, ref ms) => {\n@@ -720,9 +718,8 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let items = ccx.tcx.items.borrow();\n-    let abis = match items.get().find(&i.id) {\n-        Some(&ast_map::NodeForeignItem(_, abis, _, _)) => abis,\n+    let abis = match ccx.tcx.items.find(i.id) {\n+        Some(ast_map::NodeForeignItem(_, abis, _, _)) => abis,\n         ref x => {\n             ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n                                    in get_item_ty(): {:?}\", (*x)));\n@@ -774,9 +771,8 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n \n-    let items = ccx.tcx.items.borrow();\n-    match items.get().get(&trait_id.node) {\n-        &ast_map::NodeItem(item, _) => trait_def_of_item(ccx, item),\n+    match ccx.tcx.items.get(trait_id.node) {\n+        ast_map::NodeItem(item, _) => trait_def_of_item(ccx, item),\n         _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                    trait_id.node))\n     }"}, {"sha": "da3a2eebfeb1beeaf428d54bdf85ee753fccac7e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -347,9 +347,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n         ty::ty_bare_fn(..) => {\n-            let items = tcx.items.borrow();\n-            match items.get().find(&main_id) {\n-                Some(&ast_map::NodeItem(it,_)) => {\n+            match tcx.items.find(main_id) {\n+                Some(ast_map::NodeItem(it,_)) => {\n                     match it.node {\n                         ast::ItemFn(_, _, _, ref ps, _)\n                         if ps.is_parameterized() => {\n@@ -393,9 +392,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {\n         ty::ty_bare_fn(_) => {\n-            let items = tcx.items.borrow();\n-            match items.get().find(&start_id) {\n-                Some(&ast_map::NodeItem(it,_)) => {\n+            match tcx.items.find(start_id) {\n+                Some(ast_map::NodeItem(it,_)) => {\n                     match it.node {\n                         ast::ItemFn(_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {"}, {"sha": "dc35ab7e885ee222c8466cacc33cbd7d320d8fb1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -72,15 +72,14 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n-        let items = cx.items.borrow();\n-        match items.get().find(&node_id) {\n-          Some(&ast_map::NodeBlock(ref blk)) => {\n+        match cx.items.find(node_id) {\n+          Some(ast_map::NodeBlock(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n-          Some(&ast_map::NodeCalleeScope(expr)) => {\n+          Some(ast_map::NodeCalleeScope(expr)) => {\n               explain_span(cx, \"callee\", expr.span)\n           }\n-          Some(&ast_map::NodeExpr(expr)) => {\n+          Some(ast_map::NodeExpr(expr)) => {\n             match expr.node {\n               ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n               ast::ExprMethodCall(..) => {\n@@ -90,10 +89,10 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n               _ => explain_span(cx, \"expression\", expr.span)\n             }\n           }\n-          Some(&ast_map::NodeStmt(stmt)) => {\n+          Some(ast_map::NodeStmt(stmt)) => {\n               explain_span(cx, \"statement\", stmt.span)\n           }\n-          Some(&ast_map::NodeItem(it, _)) if (match it.node {\n+          Some(ast_map::NodeItem(it, _)) if (match it.node {\n                 ast::ItemFn(..) => true, _ => false}) => {\n               explain_span(cx, \"function body\", it.span)\n           }\n@@ -114,13 +113,12 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n-        let items = cx.items.borrow();\n-        match items.get().find(&fr.scope_id) {\n-          Some(&ast_map::NodeBlock(ref blk)) => {\n+        match cx.items.find(fr.scope_id) {\n+          Some(ast_map::NodeBlock(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n-          Some(&ast_map::NodeItem(it, _)) if match it.node {\n+          Some(ast_map::NodeItem(it, _)) if match it.node {\n                 ast::ItemImpl(..) => true, _ => false} => {\n             let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -174,13 +172,12 @@ pub fn bound_region_to_str(cx: ctxt,\n }\n \n pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n-    let items = cx.items.borrow();\n-    match items.get().find(&node_id) {\n-      Some(&ast_map::NodeBlock(ref blk)) => {\n+    match cx.items.find(node_id) {\n+      Some(ast_map::NodeBlock(ref blk)) => {\n         format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n       }\n-      Some(&ast_map::NodeExpr(expr)) => {\n+      Some(ast_map::NodeExpr(expr)) => {\n         match expr.node {\n           ast::ExprCall(..) => {\n             format!(\"<call at {}>\",\n@@ -751,14 +748,13 @@ impl Repr for ast::DefId {\n         // and otherwise fallback to just printing the crate/node pair\n         if self.crate == ast::LOCAL_CRATE {\n             {\n-                let items = tcx.items.borrow();\n-                match items.get().find(&self.node) {\n-                    Some(&ast_map::NodeItem(..)) |\n-                    Some(&ast_map::NodeForeignItem(..)) |\n-                    Some(&ast_map::NodeMethod(..)) |\n-                    Some(&ast_map::NodeTraitMethod(..)) |\n-                    Some(&ast_map::NodeVariant(..)) |\n-                    Some(&ast_map::NodeStructCtor(..)) => {\n+                match tcx.items.find(self.node) {\n+                    Some(ast_map::NodeItem(..)) |\n+                    Some(ast_map::NodeForeignItem(..)) |\n+                    Some(ast_map::NodeMethod(..)) |\n+                    Some(ast_map::NodeTraitMethod(..)) |\n+                    Some(ast_map::NodeVariant(..)) |\n+                    Some(ast_map::NodeStructCtor(..)) => {\n                         return format!(\"{:?}:{}\",\n                                        *self,\n                                        ty::item_path_str(tcx, *self));"}, {"sha": "171ec13a6e6abc012542e09a6c3a674423b3c250", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -188,10 +188,7 @@ impl<'a> RustdocVisitor<'a> {\n         };\n         if analysis.public_items.contains(&def.node) { return false }\n \n-        let item = {\n-            let items = self.cx.tycx.unwrap().items.borrow();\n-            *items.get().get(&def.node)\n-        };\n+        let item = self.cx.tycx.unwrap().items.get(def.node);\n         match item {\n             ast_map::NodeItem(it, _) => {\n                 if glob {"}, {"sha": "27f4c34d3cdc3e360c7b419a45192d410c449d84", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 79, "deletions": 37, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68517a2cca613d2018819d0eb38f6c0a864d1836/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=68517a2cca613d2018819d0eb38f6c0a864d1836", "patch": "@@ -21,8 +21,9 @@ use parse::token::special_idents;\n use print::pprust;\n use util::small_vector::SmallVector;\n \n+use std::logging;\n use std::cell::RefCell;\n-use std::hashmap::HashMap;\n+use extra::smallintmap::SmallIntMap;\n \n #[deriving(Clone, Eq)]\n pub enum PathElem {\n@@ -193,7 +194,36 @@ impl Node {\n     }\n }\n \n-pub type Map = @RefCell<HashMap<NodeId, Node>>;\n+pub struct Map {\n+    /// NodeIds are sequential integers from 0, so we can be\n+    /// super-compact by storing them in a vector. Not everything with\n+    /// a NodeId is in the map, but empirically the occupancy is about\n+    /// 75-80%, so there's not too much overhead (certainly less than\n+    /// a hashmap, since they (at the time of writing) have a maximum\n+    /// of 75% occupancy). (The additional overhead of the Option<>\n+    /// inside the SmallIntMap could be removed by adding an extra\n+    /// empty variant to Node and storing a vector here, but that was\n+    /// found to not make much difference.)\n+    ///\n+    /// Also, indexing is pretty quick when you've got a vector and\n+    /// plain old integers.\n+    priv map: @RefCell<SmallIntMap<Node>>\n+}\n+\n+impl Map {\n+    /// Retrieve the Node corresponding to `id`, failing if it cannot\n+    /// be found.\n+    pub fn get(&self, id: ast::NodeId) -> Node {\n+        let map = self.map.borrow();\n+        *map.get().get(&(id as uint))\n+    }\n+    /// Retrieve the Node corresponding to `id`, returning None if\n+    /// cannot be found.\n+    pub fn find(&self, id: ast::NodeId) -> Option<Node> {\n+        let map = self.map.borrow();\n+        map.get().find(&(id as uint)).map(|&n| n)\n+    }\n+}\n \n pub trait FoldOps {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n@@ -213,8 +243,8 @@ pub struct Ctx<F> {\n \n impl<F> Ctx<F> {\n     fn insert(&self, id: ast::NodeId, node: Node) {\n-        let mut map = self.map.borrow_mut();\n-        map.get().insert(id, node);\n+        let mut map = self.map.map.borrow_mut();\n+        map.get().insert(id as uint, node);\n     }\n \n     fn map_self(&self, m: @Method) {\n@@ -375,12 +405,27 @@ impl<F: FoldOps> Folder for Ctx<F> {\n pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n                                        fold_ops: F) -> (Crate, Map) {\n     let mut cx = Ctx {\n-        map: @RefCell::new(HashMap::new()),\n+        map: Map { map: @RefCell::new(SmallIntMap::new()) },\n         path: ~[],\n         diag: diag,\n         fold_ops: fold_ops\n     };\n-    (cx.fold_crate(c), cx.map)\n+    let crate = cx.fold_crate(c);\n+\n+    if log_enabled!(logging::DEBUG) {\n+        let map = cx.map.map.borrow();\n+        // this only makes sense for ordered stores; note the\n+        // enumerate to count the number of entries.\n+        let (entries_less_1, (largest_id, _)) =\n+            map.get().iter().enumerate().last().expect(\"AST map was empty after folding?\");\n+\n+        let entries = entries_less_1 + 1;\n+        let vector_length = largest_id + 1;\n+        debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n+              entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n+    }\n+\n+    (crate, cx.map)\n }\n \n // Used for items loaded from external crate that are being inlined into this\n@@ -430,12 +475,11 @@ pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n }\n \n pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n-    let map = map.borrow();\n-    match map.get().find(&id) {\n+    match map.find(id) {\n       None => {\n         format!(\"unknown node (id={})\", id)\n       }\n-      Some(&NodeItem(item, path)) => {\n+      Some(NodeItem(item, path)) => {\n         let path_str = path_ident_to_str(path, item.ident, itr);\n         let item_str = match item.node {\n             ItemStatic(..) => ~\"static\",\n@@ -451,80 +495,78 @@ pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n         };\n         format!(\"{} {} (id={})\", item_str, path_str, id)\n       }\n-      Some(&NodeForeignItem(item, abi, _, path)) => {\n+      Some(NodeForeignItem(item, abi, _, path)) => {\n         format!(\"foreign item {} with abi {:?} (id={})\",\n              path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n-      Some(&NodeMethod(m, _, path)) => {\n+      Some(NodeMethod(m, _, path)) => {\n         format!(\"method {} in {} (id={})\",\n              itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n-      Some(&NodeTraitMethod(ref tm, _, path)) => {\n+      Some(NodeTraitMethod(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n         format!(\"method {} in {} (id={})\",\n              itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n-      Some(&NodeVariant(ref variant, _, path)) => {\n+      Some(NodeVariant(ref variant, _, path)) => {\n         format!(\"variant {} in {} (id={})\",\n              itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n       }\n-      Some(&NodeExpr(expr)) => {\n+      Some(NodeExpr(expr)) => {\n         format!(\"expr {} (id={})\", pprust::expr_to_str(expr, itr), id)\n       }\n-      Some(&NodeCalleeScope(expr)) => {\n+      Some(NodeCalleeScope(expr)) => {\n         format!(\"callee_scope {} (id={})\", pprust::expr_to_str(expr, itr), id)\n       }\n-      Some(&NodeStmt(stmt)) => {\n+      Some(NodeStmt(stmt)) => {\n         format!(\"stmt {} (id={})\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n-      Some(&NodeArg(pat)) => {\n+      Some(NodeArg(pat)) => {\n         format!(\"arg {} (id={})\", pprust::pat_to_str(pat, itr), id)\n       }\n-      Some(&NodeLocal(ident, _)) => {\n+      Some(NodeLocal(ident, _)) => {\n         format!(\"local (id={}, name={})\", id, itr.get(ident.name))\n       }\n-      Some(&NodeBlock(block)) => {\n+      Some(NodeBlock(block)) => {\n         format!(\"block {} (id={})\", pprust::block_to_str(block, itr), id)\n       }\n-      Some(&NodeStructCtor(_, _, path)) => {\n+      Some(NodeStructCtor(_, _, path)) => {\n         format!(\"struct_ctor {} (id={})\", path_to_str(*path, itr), id)\n       }\n     }\n }\n \n pub fn node_item_query<Result>(items: Map, id: NodeId, query: |@Item| -> Result, error_msg: ~str)\n                        -> Result {\n-    let items = items.borrow();\n-    match items.get().find(&id) {\n-        Some(&NodeItem(it, _)) => query(it),\n+    match items.find(id) {\n+        Some(NodeItem(it, _)) => query(it),\n         _ => fail!(\"{}\", error_msg)\n     }\n }\n \n pub fn node_span(items: Map, id: ast::NodeId) -> Span {\n-    let items = items.borrow();\n-    match items.get().find(&id) {\n-        Some(&NodeItem(item, _)) => item.span,\n-        Some(&NodeForeignItem(foreign_item, _, _, _)) => foreign_item.span,\n-        Some(&NodeTraitMethod(trait_method, _, _)) => {\n+    match items.find(id) {\n+        Some(NodeItem(item, _)) => item.span,\n+        Some(NodeForeignItem(foreign_item, _, _, _)) => foreign_item.span,\n+        Some(NodeTraitMethod(trait_method, _, _)) => {\n             match *trait_method {\n                 Required(ref type_method) => type_method.span,\n                 Provided(ref method) => method.span,\n             }\n         }\n-        Some(&NodeMethod(method, _, _)) => method.span,\n-        Some(&NodeVariant(variant, _, _)) => variant.span,\n-        Some(&NodeExpr(expr)) => expr.span,\n-        Some(&NodeStmt(stmt)) => stmt.span,\n-        Some(&NodeArg(pat)) => pat.span,\n-        Some(&NodeLocal(_, pat)) => match pat {\n+        Some(NodeMethod(method, _, _)) => method.span,\n+        Some(NodeVariant(variant, _, _)) => variant.span,\n+        Some(NodeExpr(expr)) => expr.span,\n+        Some(NodeStmt(stmt)) => stmt.span,\n+        Some(NodeArg(pat)) => pat.span,\n+        Some(NodeLocal(_, pat)) => match pat {\n             Some(pat) => pat.span,\n             None => fail!(\"node_span: cannot get span from NodeLocal (likely `self`)\")\n         },\n-        Some(&NodeBlock(block)) => block.span,\n-        Some(&NodeStructCtor(_, item, _)) => item.span,\n-        Some(&NodeCalleeScope(expr)) => expr.span,\n+        Some(NodeBlock(block)) => block.span,\n+        Some(NodeStructCtor(_, item, _)) => item.span,\n+        Some(NodeCalleeScope(expr)) => expr.span,\n         None => fail!(\"node_span: could not find id {}\", id),\n     }\n }"}]}