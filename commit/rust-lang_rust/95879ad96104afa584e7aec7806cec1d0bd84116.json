{"sha": "95879ad96104afa584e7aec7806cec1d0bd84116", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ODc5YWQ5NjEwNGFmYTU4NGU3YWVjNzgwNmNlYzFkMGJkODQxMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-14T22:52:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-14T22:52:57Z"}, "message": "Auto merge of #75538 - tmandry:rollup-i8miv8q, r=tmandry\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #73943 (Document the unsafe keyword)\n - #74062 (deny(unsafe_op_in_unsafe_fn) in libstd/ffi/c_str.rs)\n - #74185 (Remove liballoc unneeded explicit link)\n - #74192 (Improve documentation on process::Child.std* fields)\n - #74409 (Change Debug impl of SocketAddr and IpAddr to match their Display output)\n - #75195 (BTreeMap: purge innocent use of into_kv_mut)\n - #75214 (Use intra-doc links in `mem::manually_drop` & `mem::maybe_uninit`)\n - #75432 (Switch to intra-doc links in `std::process`)\n - #75482 (Clean up E0752 explanation)\n - #75501 (Move to intra doc links in std::ffi)\n - #75509 (Tweak suggestion for `this` -> `self`)\n - #75511 (Do not emit E0228 when it is implied by E0106)\n - #75515 (Bump std's libc version to 0.2.74)\n - #75517 (Promotion and const interning comments)\n - #75519 (BTreeMap: refactor splitpoint and move testing over to unit test)\n - #75530 (Switch to intra-doc links in os/raw/*.md)\n - #75531 (Migrate unit tests of btree collections to their native breeding ground)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "069f45ea63dbee1f560f9e418ede75b2554d9ee2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/069f45ea63dbee1f560f9e418ede75b2554d9ee2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95879ad96104afa584e7aec7806cec1d0bd84116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95879ad96104afa584e7aec7806cec1d0bd84116", "html_url": "https://github.com/rust-lang/rust/commit/95879ad96104afa584e7aec7806cec1d0bd84116", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95879ad96104afa584e7aec7806cec1d0bd84116/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e21bd0633b8d970646ee6eb706c9e8acfad19af", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e21bd0633b8d970646ee6eb706c9e8acfad19af", "html_url": "https://github.com/rust-lang/rust/commit/8e21bd0633b8d970646ee6eb706c9e8acfad19af"}, {"sha": "939befd65e17432b3bdee6b48d7858b608e962c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/939befd65e17432b3bdee6b48d7858b608e962c5", "html_url": "https://github.com/rust-lang/rust/commit/939befd65e17432b3bdee6b48d7858b608e962c5"}], "stats": {"total": 1292, "additions": 725, "deletions": 567}, "files": [{"sha": "b22eb1ff6354b6f9786240b927b058e56d8f4106", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -245,7 +245,7 @@ where\n     fn replace(&mut self, key: K) -> Option<K> {\n         let root = Self::ensure_is_owned(&mut self.root);\n         match search::search_tree::<marker::Mut<'_>, K, (), K>(root.node_as_mut(), &key) {\n-            Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n+            Found(handle) => Some(mem::replace(handle.into_key_mut(), key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n                     .insert(());\n@@ -811,7 +811,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     {\n         let root_node = self.root.as_mut()?.node_as_mut();\n         match search::search_tree(root_node, key) {\n-            Found(handle) => Some(handle.into_kv_mut().1),\n+            Found(handle) => Some(handle.into_val_mut()),\n             GoDown(_) => None,\n         }\n     }\n@@ -2748,7 +2748,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n-        self.handle.into_kv_mut().1\n+        self.handle.into_val_mut()\n     }\n \n     /// Sets the value of the entry with the `OccupiedEntry`'s key,\n@@ -3024,3 +3024,6 @@ impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "910e7043092a550c09f2ef40436285eda2d263df", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,16 +1,20 @@\n-use std::collections::btree_map::Entry::{Occupied, Vacant};\n-use std::collections::BTreeMap;\n+use crate::boxed::Box;\n+use crate::collections::btree_map::Entry::{Occupied, Vacant};\n+use crate::collections::BTreeMap;\n+use crate::fmt::Debug;\n+use crate::rc::Rc;\n+use crate::string::String;\n+use crate::string::ToString;\n+use crate::vec::Vec;\n use std::convert::TryFrom;\n-use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-use super::DeterministicRng;\n+use super::super::DeterministicRng;\n \n // Value of node::CAPACITY, thus capacity of a tree with a single level,\n // i.e. a tree who's root is a leaf node at height 0.", "previous_filename": "library/alloc/tests/btree/map.rs"}, {"sha": "6c8a588eb58f33db5d98c32d2f53f2cb7695d80a", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -25,3 +25,30 @@ pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n         }\n     })\n }\n+\n+#[cfg(test)]\n+/// XorShiftRng\n+struct DeterministicRng {\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+    w: u32,\n+}\n+\n+#[cfg(test)]\n+impl DeterministicRng {\n+    fn new() -> Self {\n+        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n+    }\n+\n+    fn next(&mut self) -> u32 {\n+        let x = self.x;\n+        let t = x ^ (x << 11);\n+        self.x = self.y;\n+        self.y = self.z;\n+        self.z = self.w;\n+        let w_ = self.w;\n+        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n+        self.w\n+    }\n+}"}, {"sha": "acc2ae73572ba757aa801bafde1ae2e376efc2b5", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -43,6 +43,9 @@ use crate::boxed::Box;\n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n+const KV_IDX_CENTER: usize = B - 1;\n+const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n+const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n \n /// The underlying representation of leaf nodes.\n #[repr(C)]\n@@ -834,38 +837,12 @@ enum InsertionPlace {\n fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n     debug_assert!(edge_idx <= CAPACITY);\n     // Rust issue #74834 tries to explain these symmetric rules.\n-    let middle_kv_idx;\n-    let insertion;\n-    if edge_idx <= B - 2 {\n-        middle_kv_idx = B - 2;\n-        insertion = InsertionPlace::Left(edge_idx);\n-    } else if edge_idx == B - 1 {\n-        middle_kv_idx = B - 1;\n-        insertion = InsertionPlace::Left(edge_idx);\n-    } else if edge_idx == B {\n-        middle_kv_idx = B - 1;\n-        insertion = InsertionPlace::Right(0);\n-    } else {\n-        middle_kv_idx = B;\n-        let new_edge_idx = edge_idx - (B + 1);\n-        insertion = InsertionPlace::Right(new_edge_idx);\n-    }\n-    let mut left_len = middle_kv_idx;\n-    let mut right_len = CAPACITY - middle_kv_idx - 1;\n-    match insertion {\n-        InsertionPlace::Left(edge_idx) => {\n-            debug_assert!(edge_idx <= left_len);\n-            left_len += 1;\n-        }\n-        InsertionPlace::Right(edge_idx) => {\n-            debug_assert!(edge_idx <= right_len);\n-            right_len += 1;\n-        }\n+    match edge_idx {\n+        0..EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER - 1, InsertionPlace::Left(edge_idx)),\n+        EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER, InsertionPlace::Left(edge_idx)),\n+        EDGE_IDX_RIGHT_OF_CENTER => (KV_IDX_CENTER, InsertionPlace::Right(0)),\n+        _ => (KV_IDX_CENTER + 1, InsertionPlace::Right(edge_idx - (KV_IDX_CENTER + 1 + 1))),\n     }\n-    debug_assert!(left_len >= MIN_LEN);\n-    debug_assert!(right_len >= MIN_LEN);\n-    debug_assert!(left_len + right_len == CAPACITY);\n-    (middle_kv_idx, insertion)\n }\n \n impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n@@ -1067,6 +1044,16 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeTyp\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    pub fn into_key_mut(self) -> &'a mut K {\n+        let keys = self.node.into_key_slice_mut();\n+        unsafe { keys.get_unchecked_mut(self.idx) }\n+    }\n+\n+    pub fn into_val_mut(self) -> &'a mut V {\n+        let vals = self.node.into_val_slice_mut();\n+        unsafe { vals.get_unchecked_mut(self.idx) }\n+    }\n+\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n         unsafe {\n             let (keys, vals) = self.node.into_slices_mut();\n@@ -1261,8 +1248,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         unsafe {\n             let (k, v, edge) = self.reborrow_mut().left_edge().descend().pop();\n \n-            let k = mem::replace(self.reborrow_mut().into_kv_mut().0, k);\n-            let v = mem::replace(self.reborrow_mut().into_kv_mut().1, v);\n+            let k = mem::replace(self.kv_mut().0, k);\n+            let v = mem::replace(self.kv_mut().1, v);\n \n             match self.reborrow_mut().right_edge().descend().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push_front(k, v),\n@@ -1278,8 +1265,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         unsafe {\n             let (k, v, edge) = self.reborrow_mut().right_edge().descend().pop_front();\n \n-            let k = mem::replace(self.reborrow_mut().into_kv_mut().0, k);\n-            let v = mem::replace(self.reborrow_mut().into_kv_mut().1, v);\n+            let k = mem::replace(self.kv_mut().0, k);\n+            let v = mem::replace(self.kv_mut().1, v);\n \n             match self.reborrow_mut().left_edge().descend().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push(k, v),\n@@ -1307,7 +1294,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n                 let parent_kv = {\n-                    let kv = self.reborrow_mut().into_kv_mut();\n+                    let kv = self.kv_mut();\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n@@ -1364,7 +1351,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n                 let parent_kv = {\n-                    let kv = self.reborrow_mut().into_kv_mut();\n+                    let kv = self.kv_mut();\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n@@ -1590,3 +1577,6 @@ unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n         ret\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "e2416974ddca39c1e9410bec7f1d398930a7f51a", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -0,0 +1,25 @@\n+use super::*;\n+\n+#[test]\n+fn test_splitpoint() {\n+    for idx in 0..=CAPACITY {\n+        let (middle_kv_idx, insertion) = splitpoint(idx);\n+\n+        // Simulate performing the split:\n+        let mut left_len = middle_kv_idx;\n+        let mut right_len = CAPACITY - middle_kv_idx - 1;\n+        match insertion {\n+            InsertionPlace::Left(edge_idx) => {\n+                assert!(edge_idx <= left_len);\n+                left_len += 1;\n+            }\n+            InsertionPlace::Right(edge_idx) => {\n+                assert!(edge_idx <= right_len);\n+                right_len += 1;\n+            }\n+        }\n+        assert!(left_len >= MIN_LEN);\n+        assert!(right_len >= MIN_LEN);\n+        assert!(left_len + right_len == CAPACITY);\n+    }\n+}"}, {"sha": "a559e87e4e29855956eb15258660871a45afb54b", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1572,3 +1572,6 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T: Ord> FusedIterator for Union<'_, T> {}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "f4e957e22fe15ae07d0141ae2cc89f3e9bda908a", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "renamed", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,9 +1,10 @@\n-use std::collections::BTreeSet;\n+use crate::collections::BTreeSet;\n+use crate::vec::Vec;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicU32, Ordering};\n \n-use super::DeterministicRng;\n+use super::super::DeterministicRng;\n \n #[test]\n fn test_clone_eq() {\n@@ -15,24 +16,6 @@ fn test_clone_eq() {\n     assert_eq!(m.clone(), m);\n }\n \n-#[test]\n-fn test_hash() {\n-    use crate::hash;\n-\n-    let mut x = BTreeSet::new();\n-    let mut y = BTreeSet::new();\n-\n-    x.insert(1);\n-    x.insert(2);\n-    x.insert(3);\n-\n-    y.insert(3);\n-    y.insert(2);\n-    y.insert(1);\n-\n-    assert_eq!(hash(&x), hash(&y));\n-}\n-\n #[test]\n fn test_iter_min_max() {\n     let mut a = BTreeSet::new();", "previous_filename": "library/alloc/tests/btree/set.rs"}, {"sha": "2d25941a52412187c8a43f1bb03c25fb865eb3ab", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -80,6 +80,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n@@ -93,6 +94,7 @@\n #![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n+#![feature(exclusive_range_pattern)]\n #![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n@@ -101,6 +103,8 @@\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(libc)]\n+#![feature(map_first_last)]\n+#![feature(map_into_keys_values)]\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(nll)]"}, {"sha": "8ca0a0883cb1679a538d203e3b8471e5c4f705d5", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2620,9 +2620,6 @@ where\n ///\n /// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n /// by the [`IntoIterator`] trait).\n-///\n-/// [`Vec`]: struct.Vec.html\n-/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     buf: NonNull<T>,\n@@ -2802,10 +2799,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n \n /// A draining iterator for `Vec<T>`.\n ///\n-/// This `struct` is created by the [`drain`] method on [`Vec`].\n-///\n-/// [`drain`]: struct.Vec.html#method.drain\n-/// [`Vec`]: struct.Vec.html\n+/// This `struct` is created by [`Vec::drain`].\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve\n@@ -2933,11 +2927,8 @@ impl<T> FusedIterator for Drain<'_, T> {}\n \n /// A splicing iterator for `Vec`.\n ///\n-/// This struct is created by the [`splice()`] method on [`Vec`]. See its\n-/// documentation for more.\n-///\n-/// [`splice()`]: struct.Vec.html#method.splice\n-/// [`Vec`]: struct.Vec.html\n+/// This struct is created by [`Vec::splice()`].\n+/// See its documentation for more.\n #[derive(Debug)]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n pub struct Splice<'a, I: Iterator + 'a> {"}, {"sha": "1d08ae13e054011cd3e9f9285539fb15dfc34675", "filename": "library/alloc/tests/btree/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e21bd0633b8d970646ee6eb706c9e8acfad19af/library%2Falloc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e21bd0633b8d970646ee6eb706c9e8acfad19af/library%2Falloc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbtree%2Fmod.rs?ref=8e21bd0633b8d970646ee6eb706c9e8acfad19af", "patch": "@@ -1,27 +0,0 @@\n-mod map;\n-mod set;\n-\n-/// XorShiftRng\n-struct DeterministicRng {\n-    x: u32,\n-    y: u32,\n-    z: u32,\n-    w: u32,\n-}\n-\n-impl DeterministicRng {\n-    fn new() -> Self {\n-        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n-    }\n-\n-    fn next(&mut self) -> u32 {\n-        let x = self.x;\n-        let t = x ^ (x << 11);\n-        self.x = self.y;\n-        self.y = self.z;\n-        self.z = self.w;\n-        let w_ = self.w;\n-        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n-        self.w\n-    }\n-}"}, {"sha": "e06a95ded94c75dc09577214ea54bc8b71ae921f", "filename": "library/alloc/tests/btree_set_hash.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Ftests%2Fbtree_set_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Ftests%2Fbtree_set_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbtree_set_hash.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -0,0 +1,19 @@\n+use std::collections::BTreeSet;\n+\n+#[test]\n+fn test_hash() {\n+    use crate::hash;\n+\n+    let mut x = BTreeSet::new();\n+    let mut y = BTreeSet::new();\n+\n+    x.insert(1);\n+    x.insert(2);\n+    x.insert(3);\n+\n+    y.insert(3);\n+    y.insert(2);\n+    y.insert(1);\n+\n+    assert_eq!(hash(&x), hash(&y));\n+}"}, {"sha": "f2ba1ab64810b11a73a86d910516e36a3ea4f377", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,10 +1,7 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n-#![feature(btree_drain_filter)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n-#![feature(map_first_last)]\n-#![feature(map_into_keys_values)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n #![feature(str_split_once)]\n@@ -25,7 +22,7 @@ mod arc;\n mod binary_heap;\n mod borrow;\n mod boxed;\n-mod btree;\n+mod btree_set_hash;\n mod cow_str;\n mod fmt;\n mod heap;"}, {"sha": "e45aa86c0795a915d7f5b079e4189d8a7999e3a7", "filename": "library/core/src/mem/manually_drop.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -56,9 +56,9 @@ use crate::ptr;\n /// working with [pinned] data, where reusing the memory without calling the destructor could lead\n /// to Undefined Behaviour.\n ///\n-/// [`mem::zeroed`]: fn.zeroed.html\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-/// [pinned]: ../pin/index.html\n+/// [`mem::zeroed`]: crate::mem::zeroed\n+/// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n+/// [pinned]: crate::pin\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -116,8 +116,6 @@ impl<T> ManuallyDrop<T> {\n     /// leaving the state of this container unchanged.\n     /// It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n     ///\n-    /// [`ManuallyDrop::drop`]: #method.drop\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n     #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n     #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n     #[inline]\n@@ -148,9 +146,7 @@ impl<T: ?Sized> ManuallyDrop<T> {\n     /// This is normally prevented by the type system, but users of `ManuallyDrop` must\n     /// uphold those guarantees without assistance from the compiler.\n     ///\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    /// [`ptr::drop_in_place`]: ../ptr/fn.drop_in_place.html\n-    /// [pinned]: ../pin/index.html\n+    /// [pinned]: crate::pin\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {"}, {"sha": "d2d65fd2fa517027c365215f4e88c28e3dc98125", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -247,7 +247,7 @@ impl<T> MaybeUninit<T> {\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     ///\n-    /// [`assume_init`]: #method.assume_init\n+    /// [`assume_init`]: MaybeUninit::assume_init\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[rustc_const_stable(feature = \"const_maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n@@ -525,7 +525,7 @@ impl<T> MaybeUninit<T> {\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n-    /// [`assume_init`]: #method.assume_init\n+    /// [`assume_init`]: MaybeUninit::assume_init\n     ///\n     /// # Examples\n     ///"}, {"sha": "ef0ef415b4cbab4bbc00d7dbf5e8b86b00c627fd", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -16,7 +16,7 @@ cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.74\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.32\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "11b3f22503e83c6c6c8a474efb6519e94884ebd5", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 83, "deletions": 149, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,3 +1,4 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n use crate::ascii;\n use crate::borrow::{Borrow, Cow};\n use crate::cmp::Ordering;\n@@ -35,23 +36,23 @@ use crate::sys;\n /// example, you can build a `CString` straight out of a [`String`] or\n /// a [`&str`], since both implement that trait).\n ///\n-/// The [`new`] method will actually check that the provided `&[u8]`\n+/// The [`CString::new`] method will actually check that the provided `&[u8]`\n /// does not have 0 bytes in the middle, and return an error if it\n /// finds one.\n ///\n /// # Extracting a raw pointer to the whole C string\n ///\n-/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// `CString` implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n /// trait. This method will give you a `*const c_char` which you can\n /// feed directly to extern functions that expect a nul-terminated\n-/// string, like C's `strdup()`. Notice that [`as_ptr`] returns a\n+/// string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n /// read-only pointer; if the C code writes to it, that causes\n /// undefined behavior.\n ///\n /// # Extracting a slice of the whole C string\n ///\n /// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n-/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// `CString` with the [`CString::as_bytes`] method. Slices produced in this\n /// way do *not* contain the trailing nul terminator. This is useful\n /// when you will be calling an extern function that takes a `*const\n /// u8` argument which is not necessarily nul-terminated, plus another\n@@ -60,28 +61,19 @@ use crate::sys;\n /// [`len`][slice.len] method.\n ///\n /// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n-/// can use [`as_bytes_with_nul`] instead.\n+/// can use [`CString::as_bytes_with_nul`] instead.\n ///\n /// Once you have the kind of slice you need (with or without a nul\n /// terminator), you can call the slice's own\n /// [`as_ptr`][slice.as_ptr] method to get a read-only raw pointer to pass to\n /// extern functions. See the documentation for that function for a\n /// discussion on ensuring the lifetime of the raw pointer.\n ///\n-/// [`Into`]: ../convert/trait.Into.html\n-/// [`Vec`]: ../vec/struct.Vec.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`new`]: #method.new\n-/// [`as_bytes`]: #method.as_bytes\n-/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n-/// [`as_ptr`]: #method.as_ptr\n+/// [`&str`]: str\n /// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n /// [slice.len]: ../primitive.slice.html#method.len\n-/// [`Deref`]: ../ops/trait.Deref.html\n-/// [`CStr`]: struct.CStr.html\n-/// [`&CStr`]: struct.CStr.html\n+/// [`Deref`]: ops::Deref\n+/// [`&CStr`]: CStr\n ///\n /// # Examples\n ///\n@@ -113,7 +105,6 @@ use crate::sys;\n /// documentation of `CString` before use, as improper ownership management\n /// of `CString` instances can lead to invalid memory accesses, memory leaks,\n /// and other memory errors.\n-\n #[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CString {\n@@ -137,8 +128,8 @@ pub struct CString {\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n /// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n-/// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n-/// interface to other consumers.\n+/// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n+/// a safe interface to other consumers.\n ///\n /// # Examples\n ///\n@@ -189,11 +180,7 @@ pub struct CString {\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n ///\n-/// [`u8`]: ../primitive.u8.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`CString`]: struct.CString.html\n-/// [`from_ptr`]: #method.from_ptr\n+/// [`&str`]: str\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -218,9 +205,6 @@ pub struct CStr {\n /// This error is created by the [`new`][`CString::new`] method on\n /// [`CString`]. See its documentation for more.\n ///\n-/// [`CString`]: struct.CString.html\n-/// [`CString::new`]: struct.CString.html#method.new\n-///\n /// # Examples\n ///\n /// ```\n@@ -237,12 +221,9 @@ pub struct NulError(usize, Vec<u8>);\n /// The slice used to create a [`CStr`] must have one and only one nul byte,\n /// positioned at the end.\n ///\n-/// This error is created by the [`from_bytes_with_nul`] method on [`CStr`].\n+/// This error is created by the [`CStr::from_bytes_with_nul`] method.\n /// See its documentation for more.\n ///\n-/// [`CStr`]: struct.CStr.html\n-/// [`from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n-///\n /// # Examples\n ///\n /// ```\n@@ -261,12 +242,9 @@ pub struct FromBytesWithNulError {\n /// The vector used to create a [`CString`] must have one and only one nul byte,\n /// positioned at the end.\n ///\n-/// This error is created by the [`from_vec_with_nul`] method on [`CString`].\n+/// This error is created by the [`CString::from_vec_with_nul`] method.\n /// See its documentation for more.\n ///\n-/// [`CString`]: struct.CString.html\n-/// [`from_vec_with_nul`]: struct.CString.html#method.from_vec_with_nul\n-///\n /// # Examples\n ///\n /// ```\n@@ -316,8 +294,6 @@ impl FromVecWithNulError {\n     ///\n     /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n     /// ```\n-    ///\n-    /// [`CString`]: struct.CString.html\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }\n@@ -343,26 +319,19 @@ impl FromVecWithNulError {\n     ///\n     /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n     /// ```\n-    ///\n-    /// [`CString`]: struct.CString.html\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.bytes\n     }\n }\n \n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n-/// `CString` is just a wrapper over a buffer of bytes with a nul\n-/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n-/// validation on those bytes and may return this error.\n+/// `CString` is just a wrapper over a buffer of bytes with a nul terminator;\n+/// [`CString::into_string`] performs UTF-8 validation on those bytes and may\n+/// return this error.\n ///\n-/// This `struct` is created by the\n-/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n+/// This `struct` is created by [`CString::into_string()`]. See\n /// its documentation for more.\n-///\n-/// [`String`]: ../string/struct.String.html\n-/// [`CString`]: struct.CString.html\n-/// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n pub struct IntoStringError {\n@@ -398,8 +367,6 @@ impl CString {\n     /// This function will return an error if the supplied bytes contain an\n     /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n-    ///\n-    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         trait SpecIntoVec {\n@@ -439,11 +406,9 @@ impl CString {\n     /// Creates a C-compatible string by consuming a byte vector,\n     /// without checking for interior 0 bytes.\n     ///\n-    /// This method is equivalent to [`new`] except that no runtime assertion\n-    /// is made that `v` contains no 0 bytes, and it requires an actual\n-    /// byte vector, not anything that can be converted to one with Into.\n-    ///\n-    /// [`new`]: #method.new\n+    /// This method is equivalent to [`CString::new`] except that no runtime\n+    /// assertion is made that `v` contains no 0 bytes, and it requires an\n+    /// actual byte vector, not anything that can be converted to one with Into.\n     ///\n     /// # Examples\n     ///\n@@ -462,21 +427,22 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n+    /// Retakes ownership of a `CString` that was transferred to C via\n+    /// [`CString::into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n     /// # Safety\n     ///\n     /// This should only ever be called with a pointer that was earlier\n-    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g., trying to take\n+    /// obtained by calling [`CString::into_raw`]. Other usage (e.g., trying to take\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n     /// It should be noted that the length isn't just \"recomputed,\" but that\n     /// the recomputed length must match the original length from the\n-    /// [`into_raw`] call. This means the [`into_raw`]/`from_raw` methods\n-    /// should not be used when passing the string to C functions that can\n+    /// [`CString::into_raw`] call. This means the [`CString::into_raw`]/`from_raw`\n+    /// methods should not be used when passing the string to C functions that can\n     /// modify the string's length.\n     ///\n     /// > **Note:** If you need to borrow a string that was allocated by\n@@ -485,9 +451,6 @@ impl CString {\n     /// > make your own provisions for freeing it appropriately, likely\n     /// > with the foreign code's API to do that.\n     ///\n-    /// [`into_raw`]: #method.into_raw\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n@@ -510,26 +473,31 @@ impl CString {\n     /// ```\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n-        let len = sys::strlen(ptr) + 1; // Including the NUL byte\n-        let slice = slice::from_raw_parts_mut(ptr, len as usize);\n-        CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n+        // SAFETY: This is called with a pointer that was obtained from a call\n+        // to `CString::into_raw` and the length has not been modified. As such,\n+        // we know there is a NUL byte (and only one) at the end and that the\n+        // information about the size of the allocation is correct on Rust's\n+        // side.\n+        unsafe {\n+            let len = sys::strlen(ptr) + 1; // Including the NUL byte\n+            let slice = slice::from_raw_parts_mut(ptr, len as usize);\n+            CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n+        }\n     }\n \n     /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n     /// The pointer which this function returns must be returned to Rust and reconstituted using\n-    /// [`from_raw`] to be properly deallocated. Specifically, one\n+    /// [`CString::from_raw`] to be properly deallocated. Specifically, one\n     /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n-    /// Failure to call [`from_raw`] will lead to a memory leak.\n+    /// Failure to call [`CString::from_raw`] will lead to a memory leak.\n     ///\n     /// The C side must **not** modify the length of the string (by writing a\n     /// `NULL` somewhere inside the string or removing the final one) before\n-    /// it makes it back into Rust using [`from_raw`]. See the safety section\n-    /// in [`from_raw`].\n-    ///\n-    /// [`from_raw`]: #method.from_raw\n+    /// it makes it back into Rust using [`CString::from_raw`]. See the safety section\n+    /// in [`CString::from_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -560,8 +528,6 @@ impl CString {\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n-    /// [`String`]: ../string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -608,10 +574,8 @@ impl CString {\n         vec\n     }\n \n-    /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul terminator.\n-    ///\n-    /// [`into_bytes`]: #method.into_bytes\n+    /// Equivalent to [`CString::into_bytes()`] except that the\n+    /// returned vector includes the trailing nul terminator.\n     ///\n     /// # Examples\n     ///\n@@ -632,9 +596,7 @@ impl CString {\n     /// The returned slice does **not** contain the trailing nul\n     /// terminator, and it is guaranteed to not have any interior nul\n     /// bytes. If you need the nul terminator, use\n-    /// [`as_bytes_with_nul`] instead.\n-    ///\n-    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+    /// [`CString::as_bytes_with_nul`] instead.\n     ///\n     /// # Examples\n     ///\n@@ -651,10 +613,8 @@ impl CString {\n         &self.inner[..self.inner.len() - 1]\n     }\n \n-    /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul terminator.\n-    ///\n-    /// [`as_bytes`]: #method.as_bytes\n+    /// Equivalent to [`CString::as_bytes()`] except that the\n+    /// returned slice includes the trailing nul terminator.\n     ///\n     /// # Examples\n     ///\n@@ -673,8 +633,6 @@ impl CString {\n \n     /// Extracts a [`CStr`] slice containing the entire string.\n     ///\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -693,8 +651,6 @@ impl CString {\n \n     /// Converts this `CString` into a boxed [`CStr`].\n     ///\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -711,8 +667,6 @@ impl CString {\n     }\n \n     /// Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n-    ///\n-    /// [`Drop`]: ../ops/trait.Drop.html\n     fn into_inner(self) -> Box<[u8]> {\n         // Rationale: `mem::forget(self)` invalidates the previous call to `ptr::read(&self.inner)`\n         // so we use `ManuallyDrop` to ensure `self` is not dropped.\n@@ -722,12 +676,12 @@ impl CString {\n         unsafe { ptr::read(&this.inner) }\n     }\n \n-    /// Converts a `Vec` of `u8` to a `CString` without checking the invariants\n-    /// on the given `Vec`.\n+    /// Converts a [`Vec`]`<u8>` to a [`CString`] without checking the\n+    /// invariants on the given [`Vec`].\n     ///\n     /// # Safety\n     ///\n-    /// The given `Vec` **must** have one nul byte as its last element.\n+    /// The given [`Vec`] **must** have one nul byte as its last element.\n     /// This means it cannot be empty nor have any other nul byte anywhere else.\n     ///\n     /// # Example\n@@ -745,10 +699,10 @@ impl CString {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n-    /// Attempts to converts a `Vec` of `u8` to a `CString`.\n+    /// Attempts to converts a [`Vec`]`<u8>` to a [`CString`].\n     ///\n     /// Runtime checks are present to ensure there is only one nul byte in the\n-    /// `Vec`, its last element.\n+    /// [`Vec`], its last element.\n     ///\n     /// # Errors\n     ///\n@@ -757,8 +711,8 @@ impl CString {\n     ///\n     /// # Examples\n     ///\n-    /// A successful conversion will produce the same result as [`new`] when\n-    /// called without the ending nul byte.\n+    /// A successful conversion will produce the same result as [`CString::new`]\n+    /// when called without the ending nul byte.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -770,7 +724,7 @@ impl CString {\n     /// );\n     /// ```\n     ///\n-    /// A incorrectly formatted vector will produce an error.\n+    /// A incorrectly formatted [`Vec`] will produce an error.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -780,8 +734,6 @@ impl CString {\n     /// // No nul byte\n     /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n     /// ```\n-    ///\n-    /// [`new`]: #method.new\n     #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n     pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n         let nul_pos = memchr::memchr(0, &v);\n@@ -838,9 +790,6 @@ impl From<CString> for Vec<u8> {\n     /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n     ///\n     /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n-    ///\n-    /// [`Vec`]: ../vec/struct.Vec.html\n-    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: CString) -> Vec<u8> {\n         s.into_bytes()\n@@ -913,9 +862,6 @@ impl From<Cow<'_, CStr>> for Box<CStr> {\n #[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\n impl From<Box<CStr>> for CString {\n     /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: Box<CStr>) -> CString {\n         s.into_c_string()\n@@ -926,10 +872,6 @@ impl From<Box<CStr>> for CString {\n impl From<Vec<NonZeroU8>> for CString {\n     /// Converts a [`Vec`]`<`[`NonZeroU8`]`>` into a [`CString`] without\n     /// copying nor checking for inner null bytes.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`NonZeroU8`]: ../num/struct.NonZeroU8.html\n-    /// [`Vec`]: ../vec/struct.Vec.html\n     #[inline]\n     fn from(v: Vec<NonZeroU8>) -> CString {\n         unsafe {\n@@ -959,9 +901,6 @@ impl Clone for Box<CStr> {\n #[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n impl From<CString> for Box<CStr> {\n     /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Box`]: ../boxed/struct.Box.html\n     #[inline]\n     fn from(s: CString) -> Box<CStr> {\n         s.into_boxed_c_str()\n@@ -995,9 +934,6 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n     /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Arc`]: ../sync/struct.Arc.html\n     #[inline]\n     fn from(s: CString) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.into_inner());\n@@ -1017,9 +953,6 @@ impl From<&CStr> for Arc<CStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Rc<CStr> {\n     /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Rc`]: ../rc/struct.Rc.html\n     #[inline]\n     fn from(s: CString) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.into_inner());\n@@ -1048,8 +981,6 @@ impl NulError {\n     /// Returns the position of the nul byte in the slice that caused\n     /// [`CString::new`] to fail.\n     ///\n-    /// [`CString::new`]: struct.CString.html#method.new\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1101,9 +1032,6 @@ impl fmt::Display for NulError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<NulError> for io::Error {\n     /// Converts a [`NulError`] into a [`io::Error`].\n-    ///\n-    /// [`NulError`]: ../ffi/struct.NulError.html\n-    /// [`io::Error`]: ../io/struct.Error.html\n     fn from(_: NulError) -> io::Error {\n         io::Error::new(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n     }\n@@ -1154,8 +1082,6 @@ impl fmt::Display for FromVecWithNulError {\n impl IntoStringError {\n     /// Consumes this error, returning original [`CString`] which generated the\n     /// error.\n-    ///\n-    /// [`CString`]: struct.CString.html\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_cstring(self) -> CString {\n         self.inner\n@@ -1228,9 +1154,21 @@ impl CStr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n-        let len = sys::strlen(ptr);\n-        let ptr = ptr as *const u8;\n-        CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+        // SAFETY: The caller has provided a pointer that points to a valid C\n+        // string with a NUL terminator of size less than `isize::MAX`, whose\n+        // content remain valid and doesn't change for the lifetime of the\n+        // returned `CStr`.\n+        //\n+        // Thus computing the length is fine (a NUL byte exists), the call to\n+        // from_raw_parts is safe because we know the length is at most `isize::MAX`, meaning\n+        // the call to `from_bytes_with_nul_unchecked` is correct.\n+        //\n+        // The cast from c_char to u8 is ok because a c_char is always one byte.\n+        unsafe {\n+            let len = sys::strlen(ptr);\n+            let ptr = ptr as *const u8;\n+            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+        }\n     }\n \n     /// Creates a C string wrapper from a byte slice.\n@@ -1299,7 +1237,12 @@ impl CStr {\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_unstable(feature = \"const_cstr_unchecked\", issue = \"none\")]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        &*(bytes as *const [u8] as *const CStr)\n+        // SAFETY: Casting to CStr is safe because its internal representation\n+        // is a [u8] too (safe only inside std).\n+        // Dereferencing the obtained pointer is safe because it comes from a\n+        // reference. Making a reference is then safe because its lifetime\n+        // is bound by the lifetime of the given `bytes`.\n+        unsafe { &*(bytes as *const [u8] as *const CStr) }\n     }\n \n     /// Returns the inner pointer to this C string.\n@@ -1330,7 +1273,8 @@ impl CStr {\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n     /// lifetime information and the [`CString`] is deallocated immediately after\n-    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` expression is evaluated.\n+    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()`\n+    /// expression is evaluated.\n     /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n@@ -1345,10 +1289,8 @@ impl CStr {\n     /// }\n     /// ```\n     ///\n-    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// This way, the lifetime of the [`CString`] in `hello` encompasses\n     /// the lifetime of `ptr` and the `unsafe` block.\n-    ///\n-    /// [`CString`]: struct.CString.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n@@ -1382,15 +1324,13 @@ impl CStr {\n \n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n-    /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul terminator instead of chopping it off.\n+    /// This function is the equivalent of [`CStr::to_bytes`] except that it\n+    /// will retain the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n     /// > length calculation whenever this method is called.\n     ///\n-    /// [`to_bytes`]: #method.to_bytes\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1411,7 +1351,7 @@ impl CStr {\n     /// function will return the corresponding [`&str`] slice. Otherwise,\n     /// it will return an error with details of where UTF-8 validation failed.\n     ///\n-    /// [`&str`]: ../primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -1439,12 +1379,9 @@ impl CStr {\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n     ///\n-    /// [`Cow`]: ../borrow/enum.Cow.html\n-    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n-    /// [`Owned`]: ../borrow/enum.Cow.html#variant.Owned\n-    /// [`str`]: ../primitive.str.html\n-    /// [`String`]: ../string/struct.String.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`Borrowed`]: Cow::Borrowed\n+    /// [`Owned`]: Cow::Owned\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -1479,9 +1416,6 @@ impl CStr {\n \n     /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n     ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`CString`]: struct.CString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "0184495eecf09ffdf59ca11148b34f41f974acd1", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -88,7 +88,7 @@\n //! [`env::var_os()`] is used to query environment variables; it\n //! returns an [`Option`]`<`[`OsString`]`>`. If the environment variable\n //! exists you will get a [`Some`]`(os_string)`, which you can *then* try to\n-//! convert to a Rust string. This yields a [`Result<>`], so that\n+//! convert to a Rust string. This yields a [`Result`], so that\n //! your code can detect errors in case the environment variable did\n //! not in fact contain valid Unicode data.\n //!\n@@ -124,34 +124,22 @@\n //! method is an [`OsString`] which can be round-tripped to a Windows\n //! string losslessly.\n //!\n-//! [`String`]: ../string/struct.String.html\n-//! [`str`]: ../primitive.str.html\n-//! [`char`]: ../primitive.char.html\n-//! [`u8`]: ../primitive.u8.html\n-//! [`u16`]: ../primitive.u16.html\n //! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n //! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n-//! [`CString`]: struct.CString.html\n-//! [`CStr`]: struct.CStr.html\n-//! [`OsString`]: struct.OsString.html\n-//! [`OsStr`]: struct.OsStr.html\n-//! [`env::set_var()`]: ../env/fn.set_var.html\n-//! [`env::var_os()`]: ../env/fn.var_os.html\n-//! [`Result<>`]: ../result/enum.Result.html\n-//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n-//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n-//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n-//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n-//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n-//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n-//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n-//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n-//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n-//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n-//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n-//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n-//! [`Option`]: ../option/enum.Option.html\n-//! [`Some`]: ../option/enum.Option.html#variant.Some\n+//! [`env::set_var()`]: crate::env::set_var\n+//! [`env::var_os()`]: crate::env::var_os\n+//! [unix.OsStringExt]: crate::os::unix::ffi::OsStringExt\n+//! [`from_vec`]: crate::os::unix::ffi::OsStringExt::from_vec\n+//! [`into_vec`]: crate::os::unix::ffi::OsStringExt::into_vec\n+//! [unix.OsStrExt]: crate::os::unix::ffi::OsStrExt\n+//! [`from_bytes`]: crate::os::unix::ffi::OsStrExt::from_bytes\n+//! [`as_bytes`]: crate::os::unix::ffi::OsStrExt::as_bytes\n+//! [`OsStrExt`]: crate::os::unix::ffi::OsStrExt\n+//! [windows.OsStrExt]: crate::os::windows::ffi::OsStrExt\n+//! [`encode_wide`]: crate::os::windows::ffi::OsStrExt::encode_wide\n+//! [`collect`]: crate::iter::Iterator::collect\n+//! [windows.OsStringExt]: crate::os::windows::ffi::OsStringExt\n+//! [`from_wide`]: crate::os::windows::ffi::OsStringExt::from_wide\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "262d39d98ee2ecc66790141c9cb2b11fe3b96162", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 15, "deletions": 64, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -47,14 +47,14 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// create an `OsString` from a normal Rust string.\n ///\n /// **From slices:** Just like you can start with an empty Rust\n-/// [`String`] and then [`push_str`][String.push_str] `&str`\n+/// [`String`] and then [`String::push_str`] `&str`\n /// sub-string slices into it, you can create an empty `OsString` with\n-/// the [`new`] method and then push string slices into it with the\n-/// [`push`] method.\n+/// the [`OsString::new`] method and then push string slices into it with the\n+/// [`OsString::push`] method.\n ///\n /// # Extracting a borrowed reference to the whole OS string\n ///\n-/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n+/// You can use the [`OsString::as_os_str`] method to get an `&`[`OsStr`] from\n /// an `OsString`; this is effectively a borrowed reference to the\n /// whole string.\n ///\n@@ -63,18 +63,9 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsString` implements for [conversions] from/to native representations.\n ///\n-/// [`OsStr`]: struct.OsStr.html\n-/// [`&OsStr`]: struct.OsStr.html\n-/// [`CStr`]: struct.CStr.html\n-/// [`From`]: ../convert/trait.From.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`u16`]: ../primitive.u16.html\n-/// [String.push_str]: ../string/struct.String.html#method.push_str\n-/// [`new`]: #method.new\n-/// [`push`]: #method.push\n-/// [`as_os_str`]: #method.as_os_str\n+/// [`&OsStr`]: OsStr\n+/// [`&str`]: str\n+/// [`CStr`]: crate::ffi::CStr\n /// [conversions]: index.html#conversions\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -93,9 +84,7 @@ pub struct OsString {\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsStr` implements for [conversions] from/to native representations.\n ///\n-/// [`OsString`]: struct.OsString.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: str\n /// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -125,8 +114,6 @@ impl OsString {\n \n     /// Converts to an [`OsStr`] slice.\n     ///\n-    /// [`OsStr`]: struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -145,8 +132,6 @@ impl OsString {\n     ///\n     /// On failure, ownership of the original `OsString` is returned.\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -163,7 +148,7 @@ impl OsString {\n \n     /// Extends the string with the given [`&OsStr`] slice.\n     ///\n-    /// [`&OsStr`]: struct.OsStr.html\n+    /// [`&OsStr`]: OsStr\n     ///\n     /// # Examples\n     ///\n@@ -333,8 +318,6 @@ impl OsString {\n \n     /// Converts this `OsString` into a boxed [`OsStr`].\n     ///\n-    /// [`OsStr`]: struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -356,8 +339,6 @@ impl From<String> for OsString {\n     /// Converts a [`String`] into a [`OsString`].\n     ///\n     /// The conversion copies the data, and includes an allocation on the heap.\n-    ///\n-    /// [`OsString`]: ../../std/ffi/struct.OsString.html\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }\n@@ -544,7 +525,7 @@ impl OsStr {\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n     ///\n-    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -564,9 +545,7 @@ impl OsStr {\n     /// Any non-Unicode sequences are replaced with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n     ///\n-    /// [`Cow`]: ../../std/borrow/enum.Cow.html\n-    /// [`str`]: ../../std/primitive.str.html\n-    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -613,8 +592,6 @@ impl OsStr {\n \n     /// Copies the slice into an owned [`OsString`].\n     ///\n-    /// [`OsString`]: struct.OsString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -662,9 +639,6 @@ impl OsStr {\n     /// This number is simply useful for passing to other methods, like\n     /// [`OsString::with_capacity`] to avoid reallocations.\n     ///\n-    /// [`OsString`]: struct.OsString.html\n-    /// [`OsString::with_capacity`]: struct.OsString.html#method.with_capacity\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -682,9 +656,6 @@ impl OsStr {\n     }\n \n     /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsString`]: struct.OsString.html\n     #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n     pub fn into_os_string(self: Box<OsStr>) -> OsString {\n         let boxed = unsafe { Box::from_raw(Box::into_raw(self) as *mut Slice) };\n@@ -706,9 +677,7 @@ impl OsStr {\n     /// but non-ASCII letters are unchanged.\n     ///\n     /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    /// [`OsStr::to_ascii_lowercase`].\n     ///\n     /// # Examples\n     ///\n@@ -733,9 +702,7 @@ impl OsStr {\n     /// but non-ASCII letters are unchanged.\n     ///\n     /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    /// [`OsStr::to_ascii_uppercase`].\n     ///\n     /// # Examples\n     ///\n@@ -760,9 +727,7 @@ impl OsStr {\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n-    ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// To lowercase the value in-place, use [`OsStr::make_ascii_lowercase`].\n     ///\n     /// # Examples\n     ///\n@@ -784,9 +749,7 @@ impl OsStr {\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n-    ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// To uppercase the value in-place, use [`OsStr::make_ascii_uppercase`].\n     ///\n     /// # Examples\n     ///\n@@ -865,9 +828,6 @@ impl From<Cow<'_, OsStr>> for Box<OsStr> {\n impl From<Box<OsStr>> for OsString {\n     /// Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or\n     /// allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n     fn from(boxed: Box<OsStr>) -> OsString {\n         boxed.into_os_string()\n     }\n@@ -876,9 +836,6 @@ impl From<Box<OsStr>> for OsString {\n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n     /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n     }\n@@ -895,9 +852,6 @@ impl Clone for Box<OsStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n     /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Arc`]: ../sync/struct.Arc.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -917,9 +871,6 @@ impl From<&OsStr> for Arc<OsStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n     /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Rc`]: ../rc/struct.Rc.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "c39989a60c92b5c62d4615de8c46192064f45963", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 181, "deletions": 3, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1813,12 +1813,190 @@ mod type_keyword {}\n \n #[doc(keyword = \"unsafe\")]\n //\n-/// Code or interfaces whose [memory safety] cannot be verified by the type system.\n+/// Code or interfaces whose [memory safety] cannot be verified by the type\n+/// system.\n+///\n+/// The `unsafe` keyword has two uses: to declare the existence of contracts the\n+/// compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a\n+/// programmer has checked that these contracts have been upheld (`unsafe {}`\n+/// and `unsafe impl`, but also `unsafe fn` -- see below). They are not mutually\n+/// exclusive, as can be seen in `unsafe fn`.\n+///\n+/// # Unsafe abilities\n+///\n+/// **No matter what, Safe Rust can't cause Undefined Behavior**. This is\n+/// referred to as [soundness]: a well-typed program actually has the desired\n+/// properties. The [Nomicon][nomicon-soundness] has a more detailed explanation\n+/// on the subject.\n+///\n+/// To ensure soundness, Safe Rust is restricted enough that it can be\n+/// automatically checked. Sometimes, however, it is necessary to write code\n+/// that is correct for reasons which are too clever for the compiler to\n+/// understand. In those cases, you need to use Unsafe Rust.\n+///\n+/// Here are the abilities Unsafe Rust has in addition to Safe Rust:\n+///\n+/// - Dereference [raw pointers]\n+/// - Implement `unsafe` [`trait`]s\n+/// - Call `unsafe` functions\n+/// - Mutate [`static`]s (including [`extern`]al ones)\n+/// - Access fields of [`union`]s\n+///\n+/// However, this extra power comes with extra responsibilities: it is now up to\n+/// you to ensure soundness. The `unsafe` keyword helps by clearly marking the\n+/// pieces of code that need to worry about this.\n+///\n+/// ## The different meanings of `unsafe`\n+///\n+/// Not all uses of `unsafe` are equivalent: some are here to mark the existence\n+/// of a contract the programmer must check, others are to say \"I have checked\n+/// the contract, go ahead and do this\". The following\n+/// [discussion on Rust Internals] has more in-depth explanations about this but\n+/// here is a summary of the main points:\n+///\n+/// - `unsafe fn`: calling this function means abiding by a contract the\n+/// compiler cannot enforce.\n+/// - `unsafe trait`: implementing the [`trait`] means abiding by a\n+/// contract the compiler cannot enforce.\n+/// - `unsafe {}`: the contract necessary to call the operations inside the\n+/// block has been checked by the programmer and is guaranteed to be respected.\n+/// - `unsafe impl`: the contract necessary to implement the trait has been\n+/// checked by the programmer and is guaranteed to be respected.\n+///\n+/// `unsafe fn` also acts like an `unsafe {}` block\n+/// around the code inside the function. This means it is not just a signal to\n+/// the caller, but also promises that the preconditions for the operations\n+/// inside the function are upheld. Mixing these two meanings can be confusing\n+/// and [proposal]s exist to use `unsafe {}` blocks inside such functions when\n+/// making `unsafe` operations.\n+///\n+/// See the [Rustnomicon] and the [Reference] for more informations.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// # Examples\n+///\n+/// ## Marking elements as `unsafe`\n+///\n+/// `unsafe` can be used on functions. Note that functions and statics declared\n+/// in [`extern`] blocks are implicitly marked as `unsafe` (but not functions\n+/// declared as `extern \"something\" fn ...`). Mutable statics are always unsafe,\n+/// wherever they are declared. Methods can also be declared as `unsafe`:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// static mut FOO: &str = \"hello\";\n+///\n+/// unsafe fn unsafe_fn() {}\n+///\n+/// extern \"C\" {\n+///     fn unsafe_extern_fn();\n+///     static BAR: *mut u32;\n+/// }\n+///\n+/// trait SafeTraitWithUnsafeMethod {\n+///     unsafe fn unsafe_method(&self);\n+/// }\n+///\n+/// struct S;\n+///\n+/// impl S {\n+///     unsafe fn unsafe_method_on_struct() {}\n+/// }\n+/// ```\n+///\n+/// Traits can also be declared as `unsafe`:\n+///\n+/// ```rust\n+/// unsafe trait UnsafeTrait {}\n+/// ```\n ///\n+/// Since `unsafe fn` and `unsafe trait` indicate that there is a safety\n+/// contract that the compiler cannot enforce, documenting it is important. The\n+/// standard library has many examples of this, like the following which is an\n+/// extract from [`Vec::set_len`]. The `# Safety` section explains the contract\n+/// that must be fulfilled to safely call the function.\n+///\n+/// ```rust,ignore (stub-to-show-doc-example)\n+/// /// Forces the length of the vector to `new_len`.\n+/// ///\n+/// /// This is a low-level operation that maintains none of the normal\n+/// /// invariants of the type. Normally changing the length of a vector\n+/// /// is done using one of the safe operations instead, such as\n+/// /// `truncate`, `resize`, `extend`, or `clear`.\n+/// ///\n+/// /// # Safety\n+/// ///\n+/// /// - `new_len` must be less than or equal to `capacity()`.\n+/// /// - The elements at `old_len..new_len` must be initialized.\n+/// pub unsafe fn set_len(&mut self, new_len: usize)\n+/// ```\n+///\n+/// ## Using `unsafe {}` blocks and `impl`s\n+///\n+/// Performing `unsafe` operations requires an `unsafe {}` block:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// /// Dereference the given pointer.\n+/// ///\n+/// /// # Safety\n+/// ///\n+/// /// `ptr` must be aligned and must not be dangling.\n+/// unsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n+///     *ptr\n+/// }\n+///\n+/// let a = 3;\n+/// let b = &a as *const _;\n+/// // SAFETY: `a` has not been dropped and references are always aligned,\n+/// // so `b` is a valid address.\n+/// unsafe { assert_eq!(*b, deref_unchecked(b)); };\n+/// ```\n+///\n+/// Traits marked as `unsafe` must be [`impl`]emented using `unsafe impl`. This\n+/// makes a guarantee to other `unsafe` code that the implementation satisfies\n+/// the trait's safety contract. The [Send] and [Sync] traits are examples of\n+/// this behaviour in the standard library.\n+///\n+/// ```rust\n+/// /// Implementors of this trait must guarantee an element is always\n+/// /// accessible with index 3.\n+/// unsafe trait ThreeIndexable<T> {\n+///     /// Returns a reference to the element with index 3 in `&self`.\n+///     fn three(&self) -> &T;\n+/// }\n+///\n+/// // The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe`\n+/// // because the implementor must abide by a contract the compiler cannot\n+/// // check but as a programmer we know there will always be a valid element\n+/// // at index 3 to access.\n+/// unsafe impl<T> ThreeIndexable<T> for [T; 4] {\n+///     fn three(&self) -> &T {\n+///         // SAFETY: implementing the trait means there always is an element\n+///         // with index 3 accessible.\n+///         unsafe { self.get_unchecked(3) }\n+///     }\n+/// }\n+///\n+/// let a = [1, 2, 4, 8];\n+/// assert_eq!(a.three(), &8);\n+/// ```\n+///\n+/// [`extern`]: keyword.extern.html\n+/// [`trait`]: keyword.trait.html\n+/// [`static`]: keyword.static.html\n+/// [`union`]: keyword.union.html\n+/// [`impl`]: keyword.impl.html\n+/// [Send]: marker/trait.Send.html\n+/// [Sync]: marker/trait.Sync.html\n+/// [`Vec::set_len`]: vec/struct.Vec.html#method.set_len\n+/// [raw pointers]: ../reference/types/pointer.html\n /// [memory safety]: ../book/ch19-01-unsafe-rust.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// [Rustnomicon]: ../nomicon/index.html\n+/// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n+/// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n+/// [Reference]: ../reference/unsafety.html\n+/// [proposal]: https://github.com/rust-lang/rfcs/pull/2585\n+/// [discussion on Rust Internals]: https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\n mod unsafe_keyword {}\n \n #[doc(keyword = \"use\")]"}, {"sha": "4f751656e09c82d8d348345840f8ace30006d18d", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -37,7 +37,7 @@ use crate::vec;\n /// assert_eq!(socket.port(), 8080);\n /// assert_eq!(socket.is_ipv4(), true);\n /// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SocketAddr {\n     /// An IPv4 socket address.\n@@ -597,6 +597,13 @@ impl fmt::Display for SocketAddr {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddrV4 {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "9d7b2b807636f9568072dcf3f0397d052b185b68", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -40,7 +40,7 @@ use crate::sys_common::{AsInner, FromInner};\n /// assert_eq!(localhost_v4.is_ipv4(), true);\n /// ```\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n pub enum IpAddr {\n     /// An IPv4 address.\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n@@ -802,6 +802,13 @@ impl fmt::Display for IpAddr {\n     }\n }\n \n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+impl fmt::Debug for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<Ipv4Addr> for IpAddr {\n     /// Copies this address to a new `IpAddr::V4`."}, {"sha": "8256b725acfa399877768d57c53b9b6c35915d4b", "filename": "library/std/src/os/raw/char.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fchar.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fchar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fchar.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -5,7 +5,5 @@ Equivalent to C's `char` type.\n C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character `'\\0'`. See [`CStr`] for more information.\n \n [C's `char` type]: https://en.wikipedia.org/wiki/C_data_types#Basic_types\n-[Rust's `char` type]: ../../primitive.char.html\n-[`CStr`]: ../../ffi/struct.CStr.html\n-[`i8`]: ../../primitive.i8.html\n-[`u8`]: ../../primitive.u8.html\n+[Rust's `char` type]: char\n+[`CStr`]: crate::ffi::CStr"}, {"sha": "57f4534829ec834a1b69ae377b393adc3dfd0519", "filename": "library/std/src/os/raw/double.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fdouble.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fdouble.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fdouble.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -3,5 +3,4 @@ Equivalent to C's `double` type.\n This type will almost always be [`f64`], which is guaranteed to be an [IEEE-754 double-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a [`float`], and it may be `f32` or something entirely different from the IEEE-754 standard.\n \n [IEEE-754 double-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n-[`float`]: type.c_float.html\n-[`f64`]: ../../primitive.f64.html\n+[`float`]: c_float"}, {"sha": "61e2abc05189df2e12d7fa1b77894868f3e2d269", "filename": "library/std/src/os/raw/float.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ffloat.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ffloat.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ffloat.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -3,4 +3,3 @@ Equivalent to C's `float` type.\n This type will almost always be [`f32`], which is guaranteed to be an [IEEE-754 single-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than `f32` or not follow the IEEE-754 standard at all.\n \n [IEEE-754 single-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n-[`f32`]: ../../primitive.f32.html"}, {"sha": "8062ff2307a9537ccf9007c982aa5e0eda09135e", "filename": "library/std/src/os/raw/int.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fint.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fint.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `signed int` (`int`) type.\n \n This type will almost always be [`i32`], but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a [`short`]; some systems define it as an [`i16`], for example.\n \n-[`short`]: type.c_short.html\n-[`i32`]: ../../primitive.i32.html\n-[`i16`]: ../../primitive.i16.html\n+[`short`]: c_short"}, {"sha": "cc160783f78b7d5b429f92ac9e8750531ce64063", "filename": "library/std/src/os/raw/long.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flong.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flong.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `signed long` (`long`) type.\n \n This type will always be [`i32`] or [`i64`]. Most notably, many Linux-based systems assume an `i64`, but Windows assumes `i32`. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an [`int`], although in practice, no system would have a `long` that is neither an `i32` nor `i64`.\n \n-[`int`]: type.c_int.html\n-[`i32`]: ../../primitive.i32.html\n-[`i64`]: ../../primitive.i64.html\n+[`int`]: c_int"}, {"sha": "49c61bd61f4ad71c2c569289b978b182f125c85c", "filename": "library/std/src/os/raw/longlong.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flonglong.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flonglong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flonglong.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `signed long long` (`long long`) type.\n \n This type will almost always be [`i64`], but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a [`long`], although in practice, no system would have a `long long` that is not an `i64`, as most systems do not have a standardised [`i128`] type.\n \n-[`long`]: type.c_int.html\n-[`i64`]: ../../primitive.i64.html\n-[`i128`]: ../../primitive.i128.html\n+[`long`]: c_int"}, {"sha": "69879c9f17f4d80af70250424ed18558942cdc5c", "filename": "library/std/src/os/raw/schar.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fschar.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fschar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fschar.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `signed char` type.\n \n This type will always be [`i8`], but is included for completeness. It is defined as being a signed integer the same size as a C [`char`].\n \n-[`char`]: type.c_char.html\n-[`i8`]: ../../primitive.i8.html\n+[`char`]: c_char"}, {"sha": "3d1e53d1325f31a12fee0825a30a8e89a2c0c857", "filename": "library/std/src/os/raw/short.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fshort.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fshort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fshort.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `signed short` (`short`) type.\n \n This type will almost always be [`i16`], but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as `i32`, for example.\n \n-[`char`]: type.c_char.html\n-[`i16`]: ../../primitive.i16.html\n+[`char`]: c_char"}, {"sha": "b633bb7f8dacf5bf2ca300d0ab0a793acbbc3a49", "filename": "library/std/src/os/raw/uchar.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuchar.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuchar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuchar.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `unsigned char` type.\n \n This type will always be [`u8`], but is included for completeness. It is defined as being an unsigned integer the same size as a C [`char`].\n \n-[`char`]: type.c_char.html\n-[`u8`]: ../../primitive.u8.html\n+[`char`]: c_char"}, {"sha": "f3abea35937abd712a916313955b86932570fb00", "filename": "library/std/src/os/raw/uint.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuint.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuint.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `unsigned int` type.\n \n This type will almost always be [`u32`], but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an [`int`]; some systems define it as a [`u16`], for example.\n \n-[`int`]: type.c_int.html\n-[`u32`]: ../../primitive.u32.html\n-[`u16`]: ../../primitive.u16.html\n+[`int`]: c_int"}, {"sha": "4ab304e65777326eeef30e4e950e0296bb38881b", "filename": "library/std/src/os/raw/ulong.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulong.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulong.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `unsigned long` type.\n \n This type will always be [`u32`] or [`u64`]. Most notably, many Linux-based systems assume an `u64`, but Windows assumes `u32`. The C standard technically only requires that this type be an unsigned integer with the size of a [`long`], although in practice, no system would have a `ulong` that is neither a `u32` nor `u64`.\n \n-[`long`]: type.c_long.html\n-[`u32`]: ../../primitive.u32.html\n-[`u64`]: ../../primitive.u64.html\n+[`long`]: c_long"}, {"sha": "a27d70e17537d440fcddae685df71b4e1d6a9fd8", "filename": "library/std/src/os/raw/ulonglong.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulonglong.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulonglong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulonglong.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `unsigned long long` type.\n \n This type will almost always be [`u64`], but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a [`long long`], although in practice, no system would have a `long long` that is not a `u64`, as most systems do not have a standardised [`u128`] type.\n \n-[`long long`]: type.c_longlong.html\n-[`u64`]: ../../primitive.u64.html\n-[`u128`]: ../../primitive.u128.html\n+[`long long`]: c_longlong"}, {"sha": "6928e51b352c82d2a5aa413f20c402f4ff28dca4", "filename": "library/std/src/os/raw/ushort.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fushort.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fushort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fushort.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `unsigned short` type.\n \n This type will almost always be [`u16`], but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a [`short`].\n \n-[`short`]: type.c_short.html\n-[`u16`]: ../../primitive.u16.html\n+[`short`]: c_short"}, {"sha": "6d94fa9ebfe6d7316dd5149e7c0068a249f42ab7", "filename": "library/std/src/process.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -84,25 +84,15 @@\n //! assert_eq!(b\"test\", output.stdout.as_slice());\n //! ```\n //!\n-//! [`abort`]: fn.abort.html\n-//! [`exit`]: fn.exit.html\n+//! [`spawn`]: Command::spawn\n+//! [`output`]: Command::output\n //!\n-//! [`Command`]: struct.Command.html\n-//! [`spawn`]: struct.Command.html#method.spawn\n-//! [`output`]: struct.Command.html#method.output\n+//! [`stdout`]: Command::stdout\n+//! [`stdin`]: Command::stdin\n+//! [`stderr`]: Command::stderr\n //!\n-//! [`Child`]: struct.Child.html\n-//! [`ChildStdin`]: struct.ChildStdin.html\n-//! [`ChildStdout`]: struct.ChildStdout.html\n-//! [`ChildStderr`]: struct.ChildStderr.html\n-//! [`Stdio`]: struct.Stdio.html\n-//!\n-//! [`stdout`]: struct.Command.html#method.stdout\n-//! [`stdin`]: struct.Command.html#method.stdin\n-//! [`stderr`]: struct.Command.html#method.stderr\n-//!\n-//! [`Write`]: ../io/trait.Write.html\n-//! [`Read`]: ../io/trait.Read.html\n+//! [`Write`]: io::Write\n+//! [`Read`]: io::Read\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n \n@@ -130,7 +120,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// run, even after the `Child` handle to the child process has gone out of\n /// scope.\n ///\n-/// Calling [`wait`](#method.wait) (or other functions that wrap around it) will make\n+/// Calling [`wait`] (or other functions that wrap around it) will make\n /// the parent process wait until the child has actually exited before\n /// continuing.\n ///\n@@ -162,25 +152,44 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// assert!(ecode.success());\n /// ```\n ///\n-/// [`Command`]: struct.Command.html\n-/// [`Drop`]: ../../core/ops/trait.Drop.html\n-/// [`wait`]: #method.wait\n+/// [`wait`]: Child::wait\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n     handle: imp::Process,\n \n     /// The handle for writing to the child's standard input (stdin), if it has\n-    /// been captured.\n+    /// been captured. To avoid partially moving\n+    /// the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stdin`,\n+    /// you might find it helpful:\n+    ///\n+    /// ```compile_fail,E0425\n+    /// let stdin = child.stdin.take().unwrap();\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n \n     /// The handle for reading from the child's standard output (stdout), if it\n-    /// has been captured.\n+    /// has been captured. You might find it helpful to do\n+    ///\n+    /// ```compile_fail,E0425\n+    /// let stdout = child.stdout.take().unwrap();\n+    /// ```\n+    ///\n+    /// to avoid partially moving the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stdout`.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdout: Option<ChildStdout>,\n \n     /// The handle for reading from the child's standard error (stderr), if it\n-    /// has been captured.\n+    /// has been captured. You might find it helpful to do\n+    ///\n+    /// ```compile_fail,E0425\n+    /// let stderr = child.stderr.take().unwrap();\n+    /// ```\n+    ///\n+    /// to avoid partially moving the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stderr`.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stderr: Option<ChildStderr>,\n }\n@@ -227,9 +236,8 @@ impl fmt::Debug for Child {\n /// file handle will be closed. If the child process was blocked on input prior\n /// to being dropped, it will become unblocked after dropping.\n ///\n-/// [`Child`]: struct.Child.html\n-/// [`stdin`]: struct.Child.html#structfield.stdin\n-/// [dropped]: ../ops/trait.Drop.html\n+/// [`stdin`]: Child::stdin\n+/// [dropped]: Drop\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe,\n@@ -286,9 +294,8 @@ impl fmt::Debug for ChildStdin {\n /// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n /// underlying file handle will be closed.\n ///\n-/// [`Child`]: struct.Child.html\n-/// [`stdout`]: struct.Child.html#structfield.stdout\n-/// [dropped]: ../ops/trait.Drop.html\n+/// [`stdout`]: Child::stdout\n+/// [dropped]: Drop\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n     inner: AnonPipe,\n@@ -347,9 +354,8 @@ impl fmt::Debug for ChildStdout {\n /// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n /// underlying file handle will be closed.\n ///\n-/// [`Child`]: struct.Child.html\n-/// [`stderr`]: struct.Child.html#structfield.stderr\n-/// [dropped]: ../ops/trait.Drop.html\n+/// [`stderr`]: Child::stderr\n+/// [dropped]: Drop\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n     inner: AnonPipe,\n@@ -522,7 +528,7 @@ impl Command {\n     ///\n     /// To pass multiple arguments see [`args`].\n     ///\n-    /// [`args`]: #method.args\n+    /// [`args`]: Command::args\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +553,7 @@ impl Command {\n     ///\n     /// To pass a single argument see [`arg`].\n     ///\n-    /// [`arg`]: #method.arg\n+    /// [`arg`]: Command::arg\n     ///\n     /// # Examples\n     ///\n@@ -700,7 +706,7 @@ impl Command {\n     ///         .expect(\"ls command failed to start\");\n     /// ```\n     ///\n-    /// [`canonicalize`]: ../fs/fn.canonicalize.html\n+    /// [`canonicalize`]: crate::fs::canonicalize\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_ref().as_ref());\n@@ -712,8 +718,8 @@ impl Command {\n     /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n     /// defaults to [`piped`] when used with `output`.\n     ///\n-    /// [`inherit`]: struct.Stdio.html#method.inherit\n-    /// [`piped`]: struct.Stdio.html#method.piped\n+    /// [`inherit`]: Stdio::inherit\n+    /// [`piped`]: Stdio::piped\n     ///\n     /// # Examples\n     ///\n@@ -738,8 +744,8 @@ impl Command {\n     /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n     /// defaults to [`piped`] when used with `output`.\n     ///\n-    /// [`inherit`]: struct.Stdio.html#method.inherit\n-    /// [`piped`]: struct.Stdio.html#method.piped\n+    /// [`inherit`]: Stdio::inherit\n+    /// [`piped`]: Stdio::piped\n     ///\n     /// # Examples\n     ///\n@@ -764,8 +770,8 @@ impl Command {\n     /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n     /// defaults to [`piped`] when used with `output`.\n     ///\n-    /// [`inherit`]: struct.Stdio.html#method.inherit\n-    /// [`piped`]: struct.Stdio.html#method.piped\n+    /// [`inherit`]: Stdio::inherit\n+    /// [`piped`]: Stdio::piped\n     ///\n     /// # Examples\n     ///\n@@ -893,10 +899,8 @@ impl AsInnerMut<imp::Command> for Command {\n /// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n /// process.\n ///\n-/// [`Command`]: struct.Command.html\n-/// [`Child`]: struct.Child.html\n-/// [`output`]: struct.Command.html#method.output\n-/// [`wait_with_output`]: struct.Child.html#method.wait_with_output\n+/// [`output`]: Command::output\n+/// [`wait_with_output`]: Child::wait_with_output\n #[derive(PartialEq, Eq, Clone)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Output {\n@@ -939,10 +943,9 @@ impl fmt::Debug for Output {\n /// Describes what to do with a standard I/O stream for a child process when\n /// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n ///\n-/// [`stdin`]: struct.Command.html#method.stdin\n-/// [`stdout`]: struct.Command.html#method.stdout\n-/// [`stderr`]: struct.Command.html#method.stderr\n-/// [`Command`]: struct.Command.html\n+/// [`stdin`]: Command::stdin\n+/// [`stdout`]: Command::stdout\n+/// [`stderr`]: Command::stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Stdio(imp::Stdio);\n \n@@ -1206,10 +1209,8 @@ impl From<fs::File> for Stdio {\n /// status is exposed through the [`status`] method, or the [`wait`] method\n /// of a [`Child`] process.\n ///\n-/// [`Command`]: struct.Command.html\n-/// [`Child`]: struct.Child.html\n-/// [`status`]: struct.Command.html#method.status\n-/// [`wait`]: struct.Child.html#method.wait\n+/// [`status`]: Command::status\n+/// [`wait`]: Child::wait\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ExitStatus(imp::ExitStatus);\n@@ -1294,8 +1295,8 @@ impl fmt::Display for ExitStatus {\n /// For the platform's canonical successful and unsuccessful codes, see\n /// the [`SUCCESS`] and [`FAILURE`] associated items.\n ///\n-/// [`SUCCESS`]: #associatedconstant.SUCCESS\n-/// [`FAILURE`]: #associatedconstant.FAILURE\n+/// [`SUCCESS`]: ExitCode::SUCCESS\n+/// [`FAILURE`]: ExitCode::FAILURE\n ///\n /// **Warning**: While various forms of this were discussed in [RFC #1937],\n /// it was ultimately cut from that RFC, and thus this type is more subject\n@@ -1349,9 +1350,9 @@ impl Child {\n     /// }\n     /// ```\n     ///\n-    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n-    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n-    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n+    /// [`ErrorKind`]: io::ErrorKind\n+    /// [`InvalidInput`]: io::ErrorKind::InvalidInput\n+    /// [`Other`]: io::ErrorKind::Other\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n         self.handle.kill()\n@@ -1616,8 +1617,7 @@ pub fn exit(code: i32) -> ! {\n /// }\n /// ```\n ///\n-/// [`panic!`]: ../../std/macro.panic.html\n-/// [panic hook]: ../../std/panic/fn.set_hook.html\n+/// [panic hook]: crate::panic::set_hook\n #[stable(feature = \"process_abort\", since = \"1.17.0\")]\n pub fn abort() -> ! {\n     crate::sys::abort_internal();"}, {"sha": "b65a88cb90e88501721432cced016e00185e3cef", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -50,6 +50,13 @@ impl<'a> FnKind<'a> {\n         }\n     }\n \n+    pub fn ident(&self) -> Option<&Ident> {\n+        match self {\n+            FnKind::Fn(_, ident, ..) => Some(ident),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn decl(&self) -> &'a FnDecl {\n         match self {\n             FnKind::Fn(_, _, sig, _, _) => &sig.decl,"}, {"sha": "9736da80c2b7b178396f85e680e7ff358a15215c", "filename": "src/librustc_error_codes/error_codes/E0752.md", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,11 +1,19 @@\n-`fn main()` or the specified start function is not allowed to be\n-async. You might be seeing this error because your async runtime\n-library is not set up correctly.\n+The entry point of the program was marked as `async`.\n \n Erroneous code example:\n \n ```compile_fail,E0752\n-async fn main() -> Result<i32, ()> {\n-    Ok(1)\n+async fn main() -> Result<(), ()> { // error!\n+    Ok(())\n+}\n+```\n+\n+`fn main()` or the specified start function is not allowed to be `async`. Not\n+having a correct async runtime library setup may cause this error. To fix it,\n+declare the entry point without `async`:\n+\n+```\n+fn main() -> Result<(), ()> { // ok!\n+    Ok(())\n }\n ```"}, {"sha": "4101f70b8206dbaacda90a9940e8e35b54168fe5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -57,6 +57,12 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n+    // FIXME: since the DefId of a promoted is the DefId of its owner, this\n+    // means that promoteds in statics are actually interned like statics!\n+    // However, this is also currently crucial because we promote mutable\n+    // non-empty slices in statics to extend their lifetime, and this\n+    // ensures that they are put into a mutable allocation.\n+    // For other kinds of promoteds in statics (like array initializers), this is rather silly.\n     let intern_kind = match tcx.static_mutability(cid.instance.def_id()) {\n         Some(m) => InternKind::Static(m),\n         None if cid.promoted.is_some() => InternKind::Promoted,"}, {"sha": "6c8ee72bc66c2e01e65435a34df0ceeb13fb7eb8", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -312,7 +312,8 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     let tcx = ecx.tcx;\n     let base_intern_mode = match intern_kind {\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n-        // FIXME: what about array lengths, array initializers?\n+        // `Constant` includes array lengths.\n+        // `Promoted` includes non-`Copy` array initializers and `rustc_args_required_const` arguments.\n         InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n     };\n "}, {"sha": "94637bae44a7806cce8d6c3b9157890ebd74f512", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -101,7 +101,7 @@ impl TempState {\n /// of a larger candidate.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Candidate {\n-    /// Borrow of a constant temporary.\n+    /// Borrow of a constant temporary, candidate for lifetime extension.\n     Ref(Location),\n \n     /// Promotion of the `x` in `[x; 32]`."}, {"sha": "b3746ac2db2bdd36b863d322bed176933e9b7633", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -7,6 +7,7 @@ use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::ast::{self, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -175,16 +176,40 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         let code = source.error_code(res.is_some());\n         let mut err = self.r.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n+        let is_assoc_fn = self.self_type_is_available(span);\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-            && self.self_value_is_available(path[0].ident.span, span)\n-        {\n+        if [\"this\", \"my\"].contains(&&*item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n                 span,\n                 \"you might have meant to use `self` here instead\",\n                 \"self\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n+            if !self.self_value_is_available(path[0].ident.span, span) {\n+                if let Some((FnKind::Fn(_, _, sig, ..), fn_span)) =\n+                    &self.diagnostic_metadata.current_function\n+                {\n+                    let (span, sugg) = if let Some(param) = sig.decl.inputs.get(0) {\n+                        (param.span.shrink_to_lo(), \"&self, \")\n+                    } else {\n+                        (\n+                            self.r\n+                                .session\n+                                .source_map()\n+                                .span_through_char(*fn_span, '(')\n+                                .shrink_to_hi(),\n+                            \"&self\",\n+                        )\n+                    };\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"if you meant to use `self`, you are also missing a `self` receiver \\\n+                         argument\",\n+                        sugg.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n         }\n \n         // Emit special messages for unresolved `Self` and `self`.\n@@ -213,7 +238,38 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 if fn_kind.decl().inputs.get(0).map(|p| p.is_self()).unwrap_or(false) {\n                     err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n                 } else {\n-                    err.span_label(*span, \"this function doesn't have a `self` parameter\");\n+                    let doesnt = if is_assoc_fn {\n+                        let (span, sugg) = fn_kind\n+                            .decl()\n+                            .inputs\n+                            .get(0)\n+                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n+                            .unwrap_or_else(|| {\n+                                (\n+                                    self.r\n+                                        .session\n+                                        .source_map()\n+                                        .span_through_char(*span, '(')\n+                                        .shrink_to_hi(),\n+                                    \"&self\",\n+                                )\n+                            });\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n+                            sugg.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        \"doesn't\"\n+                    } else {\n+                        \"can't\"\n+                    };\n+                    if let Some(ident) = fn_kind.ident() {\n+                        err.span_label(\n+                            ident.span,\n+                            &format!(\"this function {} have a `self` parameter\", doesnt),\n+                        );\n+                    }\n                 }\n             }\n             return (err, Vec::new());"}, {"sha": "3093ddbeaf1ae05de8418b436a00ff5dd51e31b3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1623,6 +1623,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_bounds: &[hir::PolyTraitRef<'_>],\n         lifetime: &hir::Lifetime,\n+        borrowed: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -1837,15 +1838,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {\n-                        // FIXME: these can be redundant with E0106, but not always.\n-                        struct_span_err!(\n+                        let mut err = struct_span_err!(\n                             tcx.sess,\n                             span,\n                             E0228,\n                             \"the lifetime bound for this object type cannot be deduced \\\n                              from context; please supply an explicit bound\"\n-                        )\n-                        .emit();\n+                        );\n+                        if borrowed {\n+                            // We will have already emitted an error E0106 complaining about a\n+                            // missing named lifetime in `&dyn Trait`, so we elide this one.\n+                            err.delay_as_bug();\n+                        } else {\n+                            err.emit();\n+                        }\n                         tcx.lifetimes.re_static\n                     })\n                 }\n@@ -2873,6 +2879,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n+        self.ast_ty_to_ty_inner(ast_ty, false)\n+    }\n+\n+    /// Turns a `hir::Ty` into a `Ty`. For diagnostics' purposes we keep track of whether trait\n+    /// objects are borrowed like `&dyn Trait` to avoid emitting redundant errors.\n+    fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\", ast_ty.hir_id, ast_ty, ast_ty.kind);\n \n         let tcx = self.tcx();\n@@ -2885,7 +2897,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(\"ast_ty_to_ty: r={:?}\", r);\n-                let t = self.ast_ty_to_ty(&mt.ty);\n+                let t = self.ast_ty_to_ty_inner(&mt.ty, true);\n                 tcx.mk_ref(r, ty::TypeAndMut { ty: t, mutbl: mt.mutbl })\n             }\n             hir::TyKind::Never => tcx.types.never,\n@@ -2903,7 +2915,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n-                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n+                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed)\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);"}, {"sha": "fa0c86ecf489423b8e1b67d765fb1ff8e2e87a99", "filename": "src/test/ui/error-codes/E0424.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Ferror-codes%2FE0424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Ferror-codes%2FE0424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0424.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -6,6 +6,10 @@ impl Foo {\n     fn foo() {\n         self.bar(); //~ ERROR E0424\n     }\n+\n+    fn baz(_: i32) {\n+        self.bar(); //~ ERROR E0424\n+    }\n }\n \n fn main () {"}, {"sha": "9b8a29e8272492e64d8f513ec95b46b85d0d6d9b", "filename": "src/test/ui/error-codes/E0424.stderr", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Ferror-codes%2FE0424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Ferror-codes%2FE0424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0424.stderr?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,21 +1,37 @@\n error[E0424]: expected value, found module `self`\n   --> $DIR/E0424.rs:7:9\n    |\n-LL | /     fn foo() {\n-LL | |         self.bar();\n-   | |         ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n-LL | |     }\n-   | |_____- this function doesn't have a `self` parameter\n+LL |     fn foo() {\n+   |        --- this function doesn't have a `self` parameter\n+LL |         self.bar();\n+   |         ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+   |\n+help: add a `self` receiver parameter to make the associated `fn` a method\n+   |\n+LL |     fn foo(&self) {\n+   |            ^^^^^\n+\n+error[E0424]: expected value, found module `self`\n+  --> $DIR/E0424.rs:11:9\n+   |\n+LL |     fn baz(_: i32) {\n+   |        --- this function doesn't have a `self` parameter\n+LL |         self.bar();\n+   |         ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+   |\n+help: add a `self` receiver parameter to make the associated `fn` a method\n+   |\n+LL |     fn baz(&self, _: i32) {\n+   |            ^^^^^^\n \n error[E0424]: expected unit struct, unit variant or constant, found module `self`\n-  --> $DIR/E0424.rs:12:9\n+  --> $DIR/E0424.rs:16:9\n    |\n-LL | / fn main () {\n-LL | |     let self = \"self\";\n-   | |         ^^^^ `self` value is a keyword and may not be bound to variables or shadowed\n-LL | | }\n-   | |_- this function doesn't have a `self` parameter\n+LL | fn main () {\n+   |    ---- this function can't have a `self` parameter\n+LL |     let self = \"self\";\n+   |         ^^^^ `self` value is a keyword and may not be bound to variables or shadowed\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0424`."}, {"sha": "ee134835c37ed14eae101b077ee613c0dc68ee13", "filename": "src/test/ui/issues/issue-5099.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fissues%2Fissue-5099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fissues%2Fissue-5099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5099.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,3 +1,10 @@\n-trait B < A > { fn a() -> A { this.a } } //~ ERROR cannot find value `this` in this scope\n+trait B <A> {\n+    fn a() -> A {\n+        this.a //~ ERROR cannot find value `this` in this scope\n+    }\n+    fn b(x: i32) {\n+        this.b(x); //~ ERROR cannot find value `this` in this scope\n+    }\n+}\n \n fn main() {}"}, {"sha": "b52fd28b2b575a9490700fbce875b36175f6f9ef", "filename": "src/test/ui/issues/issue-5099.stderr", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fissues%2Fissue-5099.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fissues%2Fissue-5099.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5099.stderr?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -1,9 +1,33 @@\n error[E0425]: cannot find value `this` in this scope\n-  --> $DIR/issue-5099.rs:1:31\n+  --> $DIR/issue-5099.rs:3:9\n    |\n-LL | trait B < A > { fn a() -> A { this.a } }\n-   |                               ^^^^ not found in this scope\n+LL |         this.a\n+   |         ^^^^ not found in this scope\n+   |\n+help: you might have meant to use `self` here instead\n+   |\n+LL |         self.a\n+   |         ^^^^\n+help: if you meant to use `self`, you are also missing a `self` receiver argument\n+   |\n+LL |     fn a(&self) -> A {\n+   |          ^^^^^\n+\n+error[E0425]: cannot find value `this` in this scope\n+  --> $DIR/issue-5099.rs:6:9\n+   |\n+LL |         this.b(x);\n+   |         ^^^^ not found in this scope\n+   |\n+help: you might have meant to use `self` here instead\n+   |\n+LL |         self.b(x);\n+   |         ^^^^\n+help: if you meant to use `self`, you are also missing a `self` receiver argument\n+   |\n+LL |     fn b(&self, x: i32) {\n+   |          ^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "0339daa0d6a18c0018937304bf45bf51dd9629be", "filename": "src/test/ui/resolve/issue-2356.stderr", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -70,14 +70,15 @@ LL |         purr();\n error[E0424]: expected value, found module `self`\n   --> $DIR/issue-2356.rs:65:8\n    |\n-LL | /   fn meow() {\n-LL | |     if self.whiskers > 3 {\n-   | |        ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n-LL | |\n-LL | |         println!(\"MEOW\");\n-LL | |     }\n-LL | |   }\n-   | |___- this function doesn't have a `self` parameter\n+LL |   fn meow() {\n+   |      ---- this function doesn't have a `self` parameter\n+LL |     if self.whiskers > 3 {\n+   |        ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+   |\n+help: add a `self` receiver parameter to make the associated `fn` a method\n+   |\n+LL |   fn meow(&self) {\n+   |           ^^^^^\n \n error[E0425]: cannot find function `grow_older` in this scope\n   --> $DIR/issue-2356.rs:72:5\n@@ -112,12 +113,10 @@ LL |     purr_louder();\n error[E0424]: expected value, found module `self`\n   --> $DIR/issue-2356.rs:92:5\n    |\n-LL | / fn main() {\n-LL | |     self += 1;\n-   | |     ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n-LL | |\n-LL | | }\n-   | |_- this function doesn't have a `self` parameter\n+LL | fn main() {\n+   |    ---- this function can't have a `self` parameter\n+LL |     self += 1;\n+   |     ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n \n error: aborting due to 17 previous errors\n "}, {"sha": "fe88d105c78bf19f697db21bb7c47be77cb1a4df", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -25,8 +25,6 @@ thread_local! {\n     //~| ERROR missing lifetime specifier\n     //~| ERROR missing lifetime specifier\n     //~| ERROR missing lifetime specifier\n-    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n-    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n }\n thread_local! {\n     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n@@ -39,8 +37,6 @@ thread_local! {\n     //~| ERROR missing lifetime specifier\n     //~| ERROR missing lifetime specifier\n     //~| ERROR missing lifetime specifier\n-    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n-    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n }\n \n thread_local! {\n@@ -52,9 +48,7 @@ thread_local! {\n }\n thread_local! {\n     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-    //~^ ERROR the lifetime bound for this object type cannot be deduced from context\n-    //~| ERROR the lifetime bound for this object type cannot be deduced from context\n-    //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 1\n     //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n     //~| ERROR wrong number of lifetime arguments: expected 2, found 1\n     //~| ERROR wrong number of lifetime arguments: expected 2, found 1"}, {"sha": "9838ac72ad7675f9b3906f4bf736a138c45fca32", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "modified", "additions": 18, "deletions": 54, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95879ad96104afa584e7aec7806cec1d0bd84116/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=95879ad96104afa584e7aec7806cec1d0bd84116", "patch": "@@ -71,7 +71,7 @@ LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar<'static, 'static>>>>> = Ref\n    |                                             ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:32:48\n+  --> $DIR/missing-lifetime-specifier.rs:30:48\n    |\n LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n    |                                                ^ expected 2 lifetime parameters\n@@ -83,7 +83,7 @@ LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> =\n    |                                                ^^^^^^^^^^^^^^^^^\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:32:48\n+  --> $DIR/missing-lifetime-specifier.rs:30:48\n    |\n LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n    |                                                ^ expected 2 lifetime parameters\n@@ -95,7 +95,7 @@ LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> =\n    |                                                ^^^^^^^^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:37:44\n+  --> $DIR/missing-lifetime-specifier.rs:35:44\n    |\n LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^ expected named lifetime parameter\n@@ -107,7 +107,7 @@ LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<i32>>>>> = RefCell:\n    |                                            ^^^^^^^^\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:37:49\n+  --> $DIR/missing-lifetime-specifier.rs:35:49\n    |\n LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n    |                                                 ^ expected 2 lifetime parameters\n@@ -119,7 +119,7 @@ LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>>\n    |                                                 ^^^^^^^^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:37:44\n+  --> $DIR/missing-lifetime-specifier.rs:35:44\n    |\n LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^ expected named lifetime parameter\n@@ -131,7 +131,7 @@ LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<i32>>>>> = RefCell:\n    |                                            ^^^^^^^^\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:37:49\n+  --> $DIR/missing-lifetime-specifier.rs:35:49\n    |\n LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n    |                                                 ^ expected 2 lifetime parameters\n@@ -143,7 +143,7 @@ LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>>\n    |                                                 ^^^^^^^^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:54:44\n+  --> $DIR/missing-lifetime-specifier.rs:50:44\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^ expected named lifetime parameter\n@@ -155,7 +155,7 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> =\n    |                                            ^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:54:44\n+  --> $DIR/missing-lifetime-specifier.rs:50:44\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^ expected named lifetime parameter\n@@ -166,91 +166,55 @@ help: consider using the `'static` lifetime\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^^^^^^\n \n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/missing-lifetime-specifier.rs:23:45\n-   |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^\n-\n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/missing-lifetime-specifier.rs:23:45\n-   |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^\n-\n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/missing-lifetime-specifier.rs:37:45\n-   |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^^^^^^\n-\n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/missing-lifetime-specifier.rs:37:45\n-   |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^^^^^^\n-\n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:47:44\n+  --> $DIR/missing-lifetime-specifier.rs:43:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:47:44\n+  --> $DIR/missing-lifetime-specifier.rs:43:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:47:44\n+  --> $DIR/missing-lifetime-specifier.rs:43:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:47:44\n+  --> $DIR/missing-lifetime-specifier.rs:43:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:54:45\n+  --> $DIR/missing-lifetime-specifier.rs:50:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:54:45\n+  --> $DIR/missing-lifetime-specifier.rs:50:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/missing-lifetime-specifier.rs:54:45\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^^^^^^^^^^^^^^^\n-\n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:54:45\n+  --> $DIR/missing-lifetime-specifier.rs:50:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/missing-lifetime-specifier.rs:54:45\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^^^^^^^^^^^^^^^\n-\n error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n-  --> $DIR/missing-lifetime-specifier.rs:54:45\n+  --> $DIR/missing-lifetime-specifier.rs:50:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 22 previous errors\n \n-Some errors have detailed explanations: E0106, E0107, E0228.\n+Some errors have detailed explanations: E0106, E0107.\n For more information about an error, try `rustc --explain E0106`."}]}