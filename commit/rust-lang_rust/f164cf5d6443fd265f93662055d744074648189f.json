{"sha": "f164cf5d6443fd265f93662055d744074648189f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjRjZjVkNjQ0M2ZkMjY1ZjkzNjYyMDU1ZDc0NDA3NDY0ODE4OWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-29T23:26:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-29T23:26:38Z"}, "message": "Auto merge of #34842 - cgswords:attr_enc, r=nrc\n\nBetter attribute and metaitem encapsulation throughout the compiler\n\nThis PR refactors most (hopefully all?) of the `MetaItem` interactions outside of `libsyntax` (and a few inside) to interact with MetaItems through the provided traits instead of directly creating / destruct / matching against them. This is a necessary first step to eventually converting `MetaItem`s to internally use `TokenStream` representations (which will make `MetaItem` interactions much nicer for macro writers once the new macro system is in place).\n\nr? @nrc", "tree": {"sha": "e84bccd6a04c054c1dab83eb206932e23a5c810c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e84bccd6a04c054c1dab83eb206932e23a5c810c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f164cf5d6443fd265f93662055d744074648189f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f164cf5d6443fd265f93662055d744074648189f", "html_url": "https://github.com/rust-lang/rust/commit/f164cf5d6443fd265f93662055d744074648189f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f164cf5d6443fd265f93662055d744074648189f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a7773a18098be712d7e1ce4fded36aed8c3c311", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7773a18098be712d7e1ce4fded36aed8c3c311", "html_url": "https://github.com/rust-lang/rust/commit/5a7773a18098be712d7e1ce4fded36aed8c3c311"}, {"sha": "5553901146fa80c652abdc514b38360a0ae7418d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5553901146fa80c652abdc514b38360a0ae7418d", "html_url": "https://github.com/rust-lang/rust/commit/5553901146fa80c652abdc514b38360a0ae7418d"}], "stats": {"total": 377, "additions": 204, "deletions": 173}, "files": [{"sha": "27e1d0520dc9a323706e73c2853fa1e9a0ed51fb", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -366,18 +366,18 @@ pub fn gather_attr(attr: &ast::Attribute)\n     attr::mark_used(attr);\n \n     let meta = &attr.node.value;\n-    let metas = match meta.node {\n-        ast::MetaItemKind::List(_, ref metas) => metas,\n-        _ => {\n-            out.push(Err(meta.span));\n-            return out;\n-        }\n+    let metas = if let Some(metas) = meta.meta_item_list() {\n+        metas\n+    } else {\n+        out.push(Err(meta.span));\n+        return out;\n     };\n \n     for meta in metas {\n-        out.push(match meta.node {\n-            ast::MetaItemKind::Word(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n-            _ => Err(meta.span),\n+        out.push(if meta.is_word() {\n+            Ok((meta.name().clone(), level, meta.span))\n+        } else {\n+            Err(meta.span)\n         });\n     }\n "}, {"sha": "766e3883f2662ec33f07b4051bfebabc24a944cb", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -95,6 +95,7 @@ use std::thread;\n use rustc::session::early_error;\n \n use syntax::{ast, json};\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n@@ -392,15 +393,12 @@ fn check_cfg(sopts: &config::Options,\n \n     let mut saw_invalid_predicate = false;\n     for item in sopts.cfg.iter() {\n-        match item.node {\n-            ast::MetaItemKind::List(ref pred, _) => {\n-                saw_invalid_predicate = true;\n-                handler.emit(&MultiSpan::new(),\n-                             &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n-                                      pred),\n-                                errors::Level::Fatal);\n-            }\n-            _ => {},\n+        if item.is_meta_item_list() {\n+            saw_invalid_predicate = true;\n+            handler.emit(&MultiSpan::new(),\n+                         &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n+                                  item.name()),\n+                            errors::Level::Fatal);\n         }\n     }\n \n@@ -649,20 +647,17 @@ impl RustcDefaultCalls {\n                         if !allow_unstable_cfg && GatedCfg::gate(&*cfg).is_some() {\n                             continue;\n                         }\n-                        match cfg.node {\n-                            ast::MetaItemKind::Word(ref word) => println!(\"{}\", word),\n-                            ast::MetaItemKind::NameValue(ref name, ref value) => {\n-                                println!(\"{}=\\\"{}\\\"\", name, match value.node {\n-                                    ast::LitKind::Str(ref s, _) => s,\n-                                    _ => continue,\n-                                });\n+                        if cfg.is_word() {\n+                            println!(\"{}\", cfg.name());\n+                        } else if cfg.is_value_str() {\n+                            if let Some(s) = cfg.value_str() {\n+                                println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n                             }\n+                        } else if cfg.is_meta_item_list() {\n                             // Right now there are not and should not be any\n                             // MetaItemKind::List items in the configuration returned by\n                             // `build_configuration`.\n-                            ast::MetaItemKind::List(..) => {\n-                                panic!(\"MetaItemKind::List encountered in default cfg\")\n-                            }\n+                            panic!(\"MetaItemKind::List encountered in default cfg\")\n                         }\n                     }\n                 }"}, {"sha": "774c5ca6d6b239a75b8a72ad583f23248e698280", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -110,13 +110,11 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n             if attr.check_name(IF_THIS_CHANGED) {\n                 let mut id = None;\n                 for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    match meta_item.node {\n-                        ast::MetaItemKind::Word(ref s) if id.is_none() => id = Some(s.clone()),\n-                        _ => {\n-                            self.tcx.sess.span_err(\n-                                meta_item.span,\n-                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n-                        }\n+                    if meta_item.is_word() && id.is_none() {\n+                        id = Some(meta_item.name().clone());\n+                    } else {\n+                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n                     }\n                 }\n                 let id = id.unwrap_or(InternedString::new(ID));\n@@ -127,16 +125,13 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let mut dep_node_interned = None;\n                 let mut id = None;\n                 for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    match meta_item.node {\n-                        ast::MetaItemKind::Word(ref s) if dep_node_interned.is_none() =>\n-                            dep_node_interned = Some(s.clone()),\n-                        ast::MetaItemKind::Word(ref s) if id.is_none() =>\n-                            id = Some(s.clone()),\n-                        _ => {\n-                            self.tcx.sess.span_err(\n-                                meta_item.span,\n-                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n-                        }\n+                    if meta_item.is_word() && dep_node_interned.is_none() {\n+                        dep_node_interned = Some(meta_item.name().clone());\n+                    } else if meta_item.is_word() && id.is_none() {\n+                        id = Some(meta_item.name().clone());\n+                    } else {\n+                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n                     }\n                 }\n                 let dep_node = match dep_node_interned {"}, {"sha": "cbc5264cc2852b75f95e64e5a59c5ddaa9396b7f", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -11,6 +11,7 @@\n //! Calculation of a Strict Version Hash for crates.  For a length\n //! comment explaining the general idea, see `librustc/middle/svh.rs`.\n \n+use syntax::attr::AttributeMethods;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::svh::Svh;\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n         // to avoid hashing the AttrId\n         for attr in &krate.attrs {\n             debug!(\"krate attr {:?}\", attr);\n-            attr.node.value.hash(&mut state);\n+            attr.meta().hash(&mut state);\n         }\n \n         Svh::new(state.finish())"}, {"sha": "7547e28625c18eae079f660280d0950e971728c6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -44,7 +44,7 @@ use lint::{LintPass, LateLintPass};\n use std::collections::HashSet;\n \n use syntax::{ast};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr::{self, AttrMetaMethods, AttributeMethods};\n use syntax_pos::{self, Span};\n \n use rustc::hir::{self, PatKind};\n@@ -298,12 +298,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| {\n-            match a.node.value.node {\n-                ast::MetaItemKind::NameValue(ref name, _) if *name == \"doc\" => true,\n-                _ => false\n-            }\n-        });\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n                          &format!(\"missing documentation for {}\", desc));\n@@ -1094,10 +1089,10 @@ impl LintPass for UnstableFeatures {\n \n impl LateLintPass for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n-        if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n-            if let Some(items) = attr.node.value.meta_item_list() {\n+        if attr::contains_name(&[attr.meta().clone()], \"feature\") {\n+            if let Some(items) = attr.meta().meta_item_list() {\n                 for item in items {\n-                    ctx.span_lint(UNSTABLE_FEATURES, item.span, \"unstable feature\");\n+                    ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n                 }\n             }\n         }"}, {"sha": "63345a15e6a9bea386e3966e5c1bc556ab40826f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -1160,15 +1160,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n                 // an attribute\n                 assert_eq!(meta_items.len(), 1);\n                 let meta_item = meta_items.into_iter().nth(0).unwrap();\n-                codemap::Spanned {\n-                    node: ast::Attribute_ {\n-                        id: attr::mk_attr_id(),\n-                        style: ast::AttrStyle::Outer,\n-                        value: meta_item,\n-                        is_sugared_doc: is_sugared_doc,\n-                    },\n-                    span: syntax_pos::DUMMY_SP\n-                }\n+                attr::mk_doc_attr_outer(attr::mk_attr_id(), meta_item, is_sugared_doc)\n             }).collect()\n         },\n         None => vec![],"}, {"sha": "732c256a1910f18ca8e8b629d158d5476512f286", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -44,7 +44,7 @@ use std::rc::Rc;\n use std::u32;\n use syntax::abi::Abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n-use syntax::attr;\n+use syntax::attr::{self,AttrMetaMethods,AttributeMethods};\n use errors::Handler;\n use syntax;\n use syntax_pos::BytePos;\n@@ -1431,31 +1431,28 @@ fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n }\n \n fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n-    match mi.node {\n-      ast::MetaItemKind::Word(ref name) => {\n+    if mi.is_word() {\n+        let name = mi.name();\n         rbml_w.start_tag(tag_meta_item_word);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n+        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n         rbml_w.end_tag();\n-      }\n-      ast::MetaItemKind::NameValue(ref name, ref value) => {\n-        match value.node {\n-          ast::LitKind::Str(ref value, _) => {\n-            rbml_w.start_tag(tag_meta_item_name_value);\n-            rbml_w.wr_tagged_str(tag_meta_item_name, name);\n-            rbml_w.wr_tagged_str(tag_meta_item_value, value);\n-            rbml_w.end_tag();\n-          }\n-          _ => {/* FIXME (#623): encode other variants */ }\n-        }\n-      }\n-      ast::MetaItemKind::List(ref name, ref items) => {\n+    } else if mi.is_value_str() {\n+        let name = mi.name();\n+        /* FIXME (#623): support other literal kinds */\n+        let value = mi.value_str().unwrap();\n+        rbml_w.start_tag(tag_meta_item_name_value);\n+        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n+        rbml_w.wr_tagged_str(tag_meta_item_value, &value);\n+        rbml_w.end_tag();\n+    } else { // it must be a list\n+        let name = mi.name();\n+        let items = mi.meta_item_list().unwrap();\n         rbml_w.start_tag(tag_meta_item_list);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n+        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n         for inner_item in items {\n             encode_meta_item(rbml_w, &inner_item);\n         }\n         rbml_w.end_tag();\n-      }\n     }\n }\n \n@@ -1464,7 +1461,7 @@ fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     for attr in attrs {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, &attr.node.value);\n+        encode_meta_item(rbml_w, attr.meta());\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();"}, {"sha": "4be044c1df30720770e913e41b70d10328937a77", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -60,10 +60,10 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     }\n                     if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n                         for attr in names {\n-                            if let ast::MetaItemKind::Word(ref name) = attr.node {\n-                                sel.insert(name.clone(), attr.span);\n+                            if attr.is_word() {\n+                                sel.insert(attr.name().clone(), attr.span());\n                             } else {\n-                                span_err!(self.sess, attr.span, E0466, \"bad macro import\");\n+                                span_err!(self.sess, attr.span(), E0466, \"bad macro import\");\n                             }\n                         }\n                     }\n@@ -78,10 +78,10 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     };\n \n                     for attr in names {\n-                        if let ast::MetaItemKind::Word(ref name) = attr.node {\n-                            reexport.insert(name.clone(), attr.span);\n+                        if attr.is_word() {\n+                            reexport.insert(attr.name().clone(), attr.span());\n                         } else {\n-                            call_bad_macro_reexport(self.sess, attr.span);\n+                            call_bad_macro_reexport(self.sess, attr.span());\n                         }\n                     }\n                 }"}, {"sha": "6883c22d67525e8cae4c5e28ad81b995caffe8fe", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -498,21 +498,20 @@ pub enum Attribute {\n \n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n-        match self.node {\n-            ast::MetaItemKind::Word(ref s) => Word(s.to_string()),\n-            ast::MetaItemKind::List(ref s, ref l) => {\n-                List(s.to_string(), l.clean(cx))\n-            }\n-            ast::MetaItemKind::NameValue(ref s, ref v) => {\n-                NameValue(s.to_string(), lit_to_string(v))\n-            }\n-        }\n+        if self.is_word() {\n+            Word(self.name().to_string())\n+        } else if let Some(v) = self.value_str() {\n+            NameValue(self.name().to_string(), v.to_string())\n+        } else { // must be a list\n+            let l = self.meta_item_list().unwrap();\n+            List(self.name().to_string(), l.clean(cx))\n+       }\n     }\n }\n \n impl Clean<Attribute> for ast::Attribute {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n-        self.with_desugared_doc(|a| a.node.value.clean(cx))\n+        self.with_desugared_doc(|a| a.meta().clean(cx))\n     }\n }\n \n@@ -535,6 +534,28 @@ impl attr::AttrMetaMethods for Attribute {\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+\n+    fn is_word(&self) -> bool {\n+      match *self {\n+        Word(_) => true,\n+        _ => false,\n+      }\n+    }\n+\n+    fn is_value_str(&self) -> bool {\n+      match *self {\n+        NameValue(..) => true,\n+        _ => false,\n+      }\n+    }\n+\n+    fn is_meta_item_list(&self) -> bool {\n+      match *self {\n+        List(..) => true,\n+        _ => false,\n+      }\n+    }\n+\n     fn span(&self) -> syntax_pos::Span { unimplemented!() }\n }\n \n@@ -2568,26 +2589,6 @@ impl ToSource for syntax_pos::Span {\n     }\n }\n \n-fn lit_to_string(lit: &ast::Lit) -> String {\n-    match lit.node {\n-        ast::LitKind::Str(ref st, _) => st.to_string(),\n-        ast::LitKind::ByteStr(ref data) => format!(\"{:?}\", data),\n-        ast::LitKind::Byte(b) => {\n-            let mut res = String::from(\"b'\");\n-            for c in (b as char).escape_default() {\n-                res.push(c);\n-            }\n-            res.push('\\'');\n-            res\n-        },\n-        ast::LitKind::Char(c) => format!(\"'{}'\", c),\n-        ast::LitKind::Int(i, _t) => i.to_string(),\n-        ast::LitKind::Float(ref f, _t) => f.to_string(),\n-        ast::LitKind::FloatUnsuffixed(ref f) => f.to_string(),\n-        ast::LitKind::Bool(b) => b.to_string(),\n-    }\n-}\n-\n fn name_from_pat(p: &hir::Pat) -> String {\n     use rustc::hir::*;\n     debug!(\"Trying to get a name from pattern: {:?}\", p);"}, {"sha": "b622f6861b38379059ea23b23994b76792b9265c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 79, "deletions": 14, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -17,8 +17,8 @@ pub use self::IntType::*;\n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n use ast::{Expr, Item, Local, Stmt, StmtKind};\n-use codemap::{spanned, dummy_spanned, Spanned};\n-use syntax_pos::{Span, BytePos};\n+use codemap::{respan, spanned, dummy_spanned, Spanned};\n+use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -92,6 +92,19 @@ pub trait AttrMetaMethods {\n     /// Gets a list of inner meta items from a list MetaItem type.\n     fn meta_item_list(&self) -> Option<&[P<MetaItem>]>;\n \n+    /// Indicates if the attribute is a Word.\n+    fn is_word(&self) -> bool;\n+\n+    /// Indicates if the attribute is a Value String.\n+    fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n+\n+    /// Indicates if the attribute is a Meta-Item List.\n+    fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n+\n     fn span(&self) -> Span;\n }\n \n@@ -108,8 +121,11 @@ impl AttrMetaMethods for Attribute {\n         self.meta().value_str()\n     }\n     fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n-        self.node.value.meta_item_list()\n+        self.meta().meta_item_list()\n     }\n+\n+    fn is_word(&self) -> bool { self.meta().is_word() }\n+\n     fn span(&self) -> Span { self.meta().span }\n }\n \n@@ -140,6 +156,14 @@ impl AttrMetaMethods for MetaItem {\n             _ => None\n         }\n     }\n+\n+    fn is_word(&self) -> bool {\n+        match self.node {\n+            MetaItemKind::Word(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn span(&self) -> Span { self.span }\n }\n \n@@ -150,6 +174,9 @@ impl AttrMetaMethods for P<MetaItem> {\n     fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n+    fn is_word(&self) -> bool { (**self).is_word() }\n+    fn is_value_str(&self) -> bool { (**self).is_value_str() }\n+    fn is_meta_item_list(&self) -> bool { (**self).is_meta_item_list() }\n     fn span(&self) -> Span { (**self).span() }\n }\n \n@@ -194,22 +221,38 @@ impl AttributeMethods for Attribute {\n pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n                               -> P<MetaItem> {\n     let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n-    mk_name_value_item(name, value_lit)\n+    mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n \n pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n                           -> P<MetaItem> {\n-    P(dummy_spanned(MetaItemKind::NameValue(name, value)))\n+    mk_spanned_name_value_item(DUMMY_SP, name, value)\n }\n \n pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n-    P(dummy_spanned(MetaItemKind::List(name, items)))\n+    mk_spanned_list_item(DUMMY_SP, name, items)\n }\n \n pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n-    P(dummy_spanned(MetaItemKind::Word(name)))\n+    mk_spanned_word_item(DUMMY_SP, name)\n+}\n+\n+pub fn mk_spanned_name_value_item(sp: Span, name: InternedString, value: ast::Lit)\n+                          -> P<MetaItem> {\n+    P(respan(sp, MetaItemKind::NameValue(name, value)))\n+}\n+\n+pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<P<MetaItem>>)\n+                            -> P<MetaItem> {\n+    P(respan(sp, MetaItemKind::List(name, items)))\n+}\n+\n+pub fn mk_spanned_word_item(sp: Span, name: InternedString) -> P<MetaItem> {\n+    P(respan(sp, MetaItemKind::Word(name)))\n }\n \n+\n+\n thread_local! { static NEXT_ATTR_ID: Cell<usize> = Cell::new(0) }\n \n pub fn mk_attr_id() -> AttrId {\n@@ -223,21 +266,43 @@ pub fn mk_attr_id() -> AttrId {\n \n /// Returns an inner attribute with the given value.\n pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n-    dummy_spanned(Attribute_ {\n-        id: id,\n-        style: ast::AttrStyle::Inner,\n-        value: item,\n-        is_sugared_doc: false,\n-    })\n+    mk_spanned_attr_inner(DUMMY_SP, id, item)\n+}\n+\n+/// Returns an innter attribute with the given value and span.\n+pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n+    respan(sp,\n+           Attribute_ {\n+            id: id,\n+            style: ast::AttrStyle::Inner,\n+            value: item,\n+            is_sugared_doc: false,\n+          })\n }\n \n+\n /// Returns an outer attribute with the given value.\n pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n+    mk_spanned_attr_outer(DUMMY_SP, id, item)\n+}\n+\n+/// Returns an outer attribute with the given value and span.\n+pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n+    respan(sp,\n+           Attribute_ {\n+            id: id,\n+            style: ast::AttrStyle::Outer,\n+            value: item,\n+            is_sugared_doc: false,\n+          })\n+}\n+\n+pub fn mk_doc_attr_outer(id: AttrId, item: P<MetaItem>, is_sugared_doc: bool) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrStyle::Outer,\n         value: item,\n-        is_sugared_doc: false,\n+        is_sugared_doc: is_sugared_doc,\n     })\n }\n "}, {"sha": "5d6429f7bdfffa1bac2326fd821c5d664832b00a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -1135,30 +1135,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute {\n-        respan(sp, ast::Attribute_ {\n-            id: attr::mk_attr_id(),\n-            style: ast::AttrStyle::Outer,\n-            value: mi,\n-            is_sugared_doc: false,\n-        })\n+        attr::mk_spanned_attr_outer(sp, attr::mk_attr_id(), mi)\n     }\n \n     fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n-        P(respan(sp, ast::MetaItemKind::Word(w)))\n+        attr::mk_spanned_word_item(sp, w)\n     }\n-    fn meta_list(&self,\n-                 sp: Span,\n-                 name: InternedString,\n-                 mis: Vec<P<ast::MetaItem>> )\n+    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<P<ast::MetaItem>>)\n                  -> P<ast::MetaItem> {\n-        P(respan(sp, ast::MetaItemKind::List(name, mis)))\n+        attr::mk_spanned_list_item(sp, name, mis)\n     }\n-    fn meta_name_value(&self,\n-                       sp: Span,\n-                       name: InternedString,\n-                       value: ast::LitKind)\n+    fn meta_name_value(&self, sp: Span, name: InternedString, value: ast::LitKind)\n                        -> P<ast::MetaItem> {\n-        P(respan(sp, ast::MetaItemKind::NameValue(name, respan(sp, value))))\n+        attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n     }\n \n     fn item_use(&self, sp: Span,"}, {"sha": "5293d2ab0001a5309587f1115481f6ceb1aeeb9a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -302,9 +302,8 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n         };\n \n         if is_use {\n-            match attr.node.value.node {\n-                ast::MetaItemKind::Word(..) => (),\n-                _ => fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\"),\n+            if !attr.is_word() {\n+              fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n             }\n             return true;\n         }"}, {"sha": "2ead0f2f20ea347c22cde6d22b113e1d68100805", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -1118,14 +1118,13 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n             }\n             Some(list) => {\n                 for mi in list {\n-                    let name = match mi.node {\n-                        ast::MetaItemKind::Word(ref word) => (*word).clone(),\n-                        _ => {\n-                            span_err!(span_handler, mi.span, E0556,\n-                                      \"malformed feature, expected just one word\");\n-                            continue\n-                        }\n-                    };\n+                    let name = if mi.is_word() {\n+                                   mi.name()\n+                               } else {\n+                                   span_err!(span_handler, mi.span, E0556,\n+                                             \"malformed feature, expected just one word\");\n+                                   continue\n+                               };\n                     if let Some(&(_, _, _, setter)) = ACTIVE_FEATURES.iter()\n                         .find(|& &(n, _, _, _)| name == n) {\n                         *(setter(&mut features)) = true;"}, {"sha": "e09a64e73449b1e371ad0c94b2746f26440f46af", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -10,7 +10,7 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{self, MetaItem, MetaItemKind};\n+use syntax::ast::{MetaItem, self};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n@@ -98,15 +98,14 @@ fn expand_derive(cx: &mut ExtCtxt,\n             let mut eq_span = None;\n \n             for titem in traits.iter().rev() {\n-                let tname = match titem.node {\n-                    MetaItemKind::Word(ref tname) => tname,\n-                    _ => {\n-                        cx.span_err(titem.span, \"malformed `derive` entry\");\n-                        continue;\n-                    }\n-                };\n-\n-                if !(is_builtin_trait(tname) || cx.ecfg.enable_custom_derive()) {\n+                let tname = if titem.is_word() {\n+                                titem.name() }\n+                            else {\n+                                cx.span_err(titem.span, \"malformed `derive` entry\");\n+                                continue;\n+                            };\n+\n+                if !(is_builtin_trait(&tname) || cx.ecfg.enable_custom_derive()) {\n                     feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                                    \"custom_derive\",\n                                                    titem.span,"}, {"sha": "b1ec7fd0ab8965eeb857fff139873b05e90c4e9d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f164cf5d6443fd265f93662055d744074648189f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=f164cf5d6443fd265f93662055d744074648189f", "patch": "@@ -254,6 +254,10 @@ pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n // For code appearing from the command line\n pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n \n+// For code generated by a procedural macro, without knowing which\n+// Used in `qquote!`\n+pub const PROC_EXPN: ExpnId = ExpnId(!2);\n+\n impl ExpnId {\n     pub fn from_u32(id: u32) -> ExpnId {\n         ExpnId(id)"}]}