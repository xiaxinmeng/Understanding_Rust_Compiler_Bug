{"sha": "9b803ec4217d37fe73f1f738f8007d5d6512a425", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliODAzZWM0MjE3ZDM3ZmU3M2YxZjczOGY4MDA3ZDVkNjUxMmE0MjU=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-26T02:15:25Z"}, "committer": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-29T01:09:15Z"}, "message": "Remove auto_traits from PartitionedBounds", "tree": {"sha": "817a5b16da71803c99c07b91c0a6c02f6c21827b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/817a5b16da71803c99c07b91c0a6c02f6c21827b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b803ec4217d37fe73f1f738f8007d5d6512a425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b803ec4217d37fe73f1f738f8007d5d6512a425", "html_url": "https://github.com/rust-lang/rust/commit/9b803ec4217d37fe73f1f738f8007d5d6512a425", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b803ec4217d37fe73f1f738f8007d5d6512a425/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb35d50cad5f452e80ff88ee957962966c28a9f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb35d50cad5f452e80ff88ee957962966c28a9f6", "html_url": "https://github.com/rust-lang/rust/commit/bb35d50cad5f452e80ff88ee957962966c28a9f6"}], "stats": {"total": 130, "additions": 73, "deletions": 57}, "files": [{"sha": "5aac23f0f5fa203ebd260bbd6982345824fc7450", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9b803ec4217d37fe73f1f738f8007d5d6512a425", "patch": "@@ -71,7 +71,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n         let ty_def_id = match self.tcx.item_type(item_def_id).sty {\n             ty::TyAdt(adt, _) => adt.did,\n-            ty::TyTrait(ref obj) => obj.principal.def_id(),\n+            ty::TyDynamic(ref obj, ..) if obj.principal().is_some() =>\n+                obj.principal().unwrap().def_id(),\n             ty::TyProjection(ref proj) => proj.trait_ref.def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n@@ -359,7 +360,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n             ty::TyAdt(adt, _) => Some(adt.did),\n-            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n             ty::TyFnDef(def_id, ..) |\n             ty::TyAnon(def_id, _) => Some(def_id),\n@@ -934,7 +935,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n             ty::TyAdt(adt, _) => Some(adt.did),\n-            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => {\n                 if self.required_visibility == ty::Visibility::PrivateExternal {\n                     // Conservatively approximate the whole type alias as public without"}, {"sha": "9f3887a87686acd8f730cfda6cb23719100ec51f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9b803ec4217d37fe73f1f738f8007d5d6512a425", "patch": "@@ -962,7 +962,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                    ty.id,\n                                                    path.segments.last().unwrap(),\n                                                    span,\n-                                                   partition_bounds(tcx, span, bounds))\n+                                                   partition_bounds(bounds))\n                 } else {\n                     struct_span_err!(tcx.sess, ty.span, E0172,\n                                      \"expected a reference to a trait\")\n@@ -1045,11 +1045,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                         trait_segment,\n                                                         &mut projection_bounds);\n \n-        let PartitionedBounds { auto_traits,\n-                                trait_bounds,\n+        let PartitionedBounds { trait_bounds,\n                                 region_bounds } =\n             partitioned_bounds;\n \n+        let (auto_traits, trait_bounds) = split_auto_traits(tcx, trait_bounds);\n+\n         if !trait_bounds.is_empty() {\n             let b = &trait_bounds[0];\n             let span = b.trait_ref.path.span;\n@@ -1443,7 +1444,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                path_id,\n                                                path.segments.last().unwrap(),\n                                                span,\n-                                               partition_bounds(tcx, span, &[]))\n+                                               partition_bounds(&[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n@@ -1897,7 +1898,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         ast_bounds: &[hir::TyParamBound])\n         -> Ty<'tcx>\n     {\n-        let mut partitioned_bounds = partition_bounds(self.tcx(), span, &ast_bounds[..]);\n+        let mut partitioned_bounds = partition_bounds(ast_bounds);\n \n         let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n             partitioned_bounds.trait_bounds.remove(0)\n@@ -1982,49 +1983,62 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n }\n \n pub struct PartitionedBounds<'a> {\n-    pub auto_traits: Vec<DefId>,\n     pub trait_bounds: Vec<&'a hir::PolyTraitRef>,\n     pub region_bounds: Vec<&'a hir::Lifetime>,\n }\n \n-/// Divides a list of bounds from the AST into three groups: builtin bounds (Copy, Sized etc),\n-/// general trait bounds, and region bounds.\n-pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            _span: Span,\n-                                            ast_bounds: &'b [hir::TyParamBound])\n-                                            -> PartitionedBounds<'b>\n+/// Divides a list of general trait bounds into two groups: builtin bounds (Sync/Send) and the\n+/// remaining general trait bounds.\n+fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                         trait_bounds: Vec<&'b hir::PolyTraitRef>)\n+    -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n+{\n+    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.into_iter().partition(|bound| {\n+        match bound.trait_ref.path.def {\n+            Def::Trait(trait_did) => {\n+                // Checks whether `trait_did` refers to one of the builtin\n+                // traits, like `Send`, and adds it to `auto_traits` if so.\n+                if Some(trait_did) == tcx.lang_items.send_trait() ||\n+                    Some(trait_did) == tcx.lang_items.sync_trait() {\n+                    let segments = &bound.trait_ref.path.segments;\n+                    let parameters = &segments[segments.len() - 1].parameters;\n+                    if !parameters.types().is_empty() {\n+                        check_type_argument_count(tcx, bound.trait_ref.path.span,\n+                                                  parameters.types().len(), &[]);\n+                    }\n+                    if !parameters.lifetimes().is_empty() {\n+                        report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n+                                                     parameters.lifetimes().len(), 0);\n+                    }\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false\n+        }\n+    });\n+\n+    let auto_traits = auto_traits.into_iter().map(|tr| {\n+        if let Def::Trait(trait_did) = tr.trait_ref.path.def {\n+            trait_did\n+        } else {\n+            unreachable!()\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    (auto_traits, trait_bounds)\n+}\n+\n+/// Divides a list of bounds from the AST into two groups: general trait bounds and region bounds\n+pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(ast_bounds: &'b [hir::TyParamBound])\n+    -> PartitionedBounds<'b>\n {\n-    let mut auto_traits = Vec::new();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                match b.trait_ref.path.def {\n-                    Def::Trait(trait_did) => {\n-                        // Checks whether `trait_did` refers to one of the builtin\n-                        // traits, like `Send`, and adds it to `auto_traits` if so.\n-                        if Some(trait_did) == tcx.lang_items.send_trait() ||\n-                            Some(trait_did) == tcx.lang_items.sync_trait() {\n-                            auto_traits.push(trait_did);\n-                            let segments = &b.trait_ref.path.segments;\n-                            let parameters = &segments[segments.len() - 1].parameters;\n-                            if !parameters.types().is_empty() {\n-                                check_type_argument_count(tcx, b.trait_ref.path.span,\n-                                                          parameters.types().len(), &[]);\n-                            }\n-                            if !parameters.lifetimes().is_empty() {\n-                                report_lifetime_number_error(tcx, b.trait_ref.path.span,\n-                                                             parameters.lifetimes().len(), 0);\n-                            }\n-                            continue; // success\n-                        }\n-                    }\n-                    _ => {\n-                        // Not a trait? that's an error, but it'll get\n-                        // reported later.\n-                    }\n-                }\n                 trait_bounds.push(b);\n             }\n             hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n@@ -2035,7 +2049,6 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n \n     PartitionedBounds {\n-        auto_traits: auto_traits,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n     }\n@@ -2110,7 +2123,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n     pub region_bounds: Vec<&'tcx ty::Region>,\n-    pub auto_traits: Vec<DefId>,\n+    pub implicitly_sized: bool,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n }"}, {"sha": "8495c1b3fb8ae212fee751036de3f8e92581eac6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9b803ec4217d37fe73f1f738f8007d5d6512a425", "patch": "@@ -1584,11 +1584,10 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     assert!(prev_predicates.is_none());\n }\n \n-// Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                       bounds: &mut Vec<DefId>,\n-                                       ast_bounds: &[hir::TyParamBound],\n-                                       span: Span)\n+// Is it marked with ?Sized\n+fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                ast_bounds: &[hir::TyParamBound],\n+                                span: Span) -> bool\n {\n     let tcx = astconv.tcx();\n \n@@ -1621,11 +1620,13 @@ fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            bounds.push(kind_id.unwrap());\n+            return false;\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n     }\n+\n+    true\n }\n \n /// Returns the early-bound lifetimes declared in this generics\n@@ -1907,14 +1908,9 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n {\n     let tcx = astconv.tcx();\n     let PartitionedBounds {\n-        mut auto_traits,\n         trait_bounds,\n         region_bounds\n-    } = partition_bounds(tcx, span, &ast_bounds);\n-\n-    if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(astconv, &mut auto_traits, ast_bounds, span);\n-    }\n+    } = partition_bounds(&ast_bounds);\n \n     let mut projection_bounds = vec![];\n \n@@ -1932,9 +1928,15 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n \n     trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n+    let implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n+        !is_unsized(astconv, ast_bounds, span)\n+    } else {\n+        false\n+    };\n+\n     Bounds {\n         region_bounds: region_bounds,\n-        auto_traits: auto_traits,\n+        implicitly_sized: implicitly_sized,\n         trait_bounds: trait_bounds,\n         projection_bounds: projection_bounds,\n     }"}, {"sha": "508442fcb9453e4a0327aeb9c540f5cff5e3e736", "filename": "src/test/compile-fail/issue-16966.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Ftest%2Fcompile-fail%2Fissue-16966.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b803ec4217d37fe73f1f738f8007d5d6512a425/src%2Ftest%2Fcompile-fail%2Fissue-16966.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16966.rs?ref=9b803ec4217d37fe73f1f738f8007d5d6512a425", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:type annotations required\n+// error-pattern:type annotations or generic parameter binding required\n fn main() {\n     panic!(\n         std::default::Default::default()"}]}