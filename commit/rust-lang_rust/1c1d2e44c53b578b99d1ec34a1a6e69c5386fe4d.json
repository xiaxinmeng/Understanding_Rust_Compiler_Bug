{"sha": "1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMWQyZTQ0YzUzYjU3OGI5OWQxZWMzNGExYTZlNjljNTM4NmZlNGQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-13T03:36:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-13T03:36:59Z"}, "message": "Rollup merge of #58057 - michaelwoerister:stabilize-xlto, r=alexcrichton\n\nStabilize linker-plugin based LTO (aka cross-language LTO)\n\nThis PR stabilizes [linker plugin based LTO](https://github.com/rust-lang/rust/issues/49879), also known as \"cross-language LTO\" because it allows for doing inlining and other optimizations across language boundaries in mixed Rust/C/C++ projects.\n\nAs described in the tracking issue, it works by making `rustc` emit LLVM bitcode instead of machine code, the same as `clang` does. A linker with the proper plugin (like LLD) can then run (Thin)LTO across all modules.\n\nThe feature has been implemented over a number of pull requests and there are various [codegen](https://github.com/rust-lang/rust/blob/master/src/test/codegen/no-dllimport-w-cross-lang-lto.rs) and [run](https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps/cross-lang-lto-clang)-[make](https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps/cross-lang-lto-upstream-rlibs) [tests](https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps/cross-lang-lto) that make sure that it keeps working.\n\nIt also works for building big projects like [Firefox](https://treeherder.mozilla.org/#/jobs?repo=try&revision=2ce2d5ddcea6fbff790503eac406954e469b2f5d).\n\nThe PR makes the feature available under the `-C linker-plugin-lto` flag. As discussed in the tracking issue it is not cross-language specific and also not LLD specific. `-C linker-plugin-lto` is descriptive of what it does. If someone has a better name, let me know `:)`", "tree": {"sha": "da6973fc442f652f2e9d6fd534ec396b27f4cd0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da6973fc442f652f2e9d6fd534ec396b27f4cd0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcY5DbCRBK7hj4Ov3rIwAAdHIIAFdF4lVI8C4GjSMFfpt1+WHA\nvNCLA0ssnTrZMopeDBZ1ncFbI01DUo0vV1o7u+thvvvHqTiEPG0pQ4I1QKIkxBY4\nAJ9MmwJGJAEapPMq+KmtT1UyKK60SufrhDdDZRcXh5LIAiUDVoCO2KOW1VfyYqeY\nlGDCZVessm7ZdDwQ9vej7Y2SBu2q1uRTSygk3wGd3dga9jKNGqVojeqlG/rLCkwW\ncuY0rlyOrVvdZYsEydFhQO/Ro+PETjb7zfXMXh36vsMs2CU4yLsYAU9IOFNGVLfR\nvgGc2+VPU18BSeJywJIdytwpsGWusx6UQeCQbC16nWlHSYO+JmP215gt9rcnAXg=\n=Bov0\n-----END PGP SIGNATURE-----\n", "payload": "tree da6973fc442f652f2e9d6fd534ec396b27f4cd0a\nparent 0ab1057a56097e73f26a1c27b4fc05b551b5737a\nparent 3a9d171b0a118d8f0ecda1bf44775ec4ba9bb79d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550029019 +0100\ncommitter GitHub <noreply@github.com> 1550029019 +0100\n\nRollup merge of #58057 - michaelwoerister:stabilize-xlto, r=alexcrichton\n\nStabilize linker-plugin based LTO (aka cross-language LTO)\n\nThis PR stabilizes [linker plugin based LTO](https://github.com/rust-lang/rust/issues/49879), also known as \"cross-language LTO\" because it allows for doing inlining and other optimizations across language boundaries in mixed Rust/C/C++ projects.\n\nAs described in the tracking issue, it works by making `rustc` emit LLVM bitcode instead of machine code, the same as `clang` does. A linker with the proper plugin (like LLD) can then run (Thin)LTO across all modules.\n\nThe feature has been implemented over a number of pull requests and there are various [codegen](https://github.com/rust-lang/rust/blob/master/src/test/codegen/no-dllimport-w-cross-lang-lto.rs) and [run](https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps/cross-lang-lto-clang)-[make](https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps/cross-lang-lto-upstream-rlibs) [tests](https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps/cross-lang-lto) that make sure that it keeps working.\n\nIt also works for building big projects like [Firefox](https://treeherder.mozilla.org/#/jobs?repo=try&revision=2ce2d5ddcea6fbff790503eac406954e469b2f5d).\n\nThe PR makes the feature available under the `-C linker-plugin-lto` flag. As discussed in the tracking issue it is not cross-language specific and also not LLD specific. `-C linker-plugin-lto` is descriptive of what it does. If someone has a better name, let me know `:)`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "html_url": "https://github.com/rust-lang/rust/commit/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab1057a56097e73f26a1c27b4fc05b551b5737a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab1057a56097e73f26a1c27b4fc05b551b5737a", "html_url": "https://github.com/rust-lang/rust/commit/0ab1057a56097e73f26a1c27b4fc05b551b5737a"}, {"sha": "3a9d171b0a118d8f0ecda1bf44775ec4ba9bb79d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9d171b0a118d8f0ecda1bf44775ec4ba9bb79d", "html_url": "https://github.com/rust-lang/rust/commit/3a9d171b0a118d8f0ecda1bf44775ec4ba9bb79d"}], "stats": {"total": 233, "additions": 172, "deletions": 61}, "files": [{"sha": "34708d1847f6b802e908cc147133a1b0b475642f", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -13,4 +13,5 @@\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n-- [Contributing to `rustc`](contributing.md)\n\\ No newline at end of file\n+- [Linker-plugin based LTO](linker-plugin-lto.md)\n+- [Contributing to `rustc`](contributing.md)"}, {"sha": "73a2efcb33a75a1b2ac2473f5e15c59de932e3b5", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -0,0 +1,108 @@\n+# Linker-plugin-LTO\n+\n+The `-C linker-plugin-lto` flag allows for deferring the LTO optimization\n+to the actual linking step, which in turn allows for performing\n+interprocedural optimizations across programming language boundaries if\n+all the object files being linked were created by LLVM based toolchains.\n+The prime example here would be linking Rust code together with\n+Clang-compiled C/C++ code.\n+\n+## Usage\n+\n+There are two main cases how linker plugin based LTO can be used:\n+\n+ - compiling a Rust `staticlib` that is used as a C ABI dependency\n+ - compiling a Rust binary where `rustc` invokes the linker\n+\n+In both cases the Rust code has to be compiled with `-C linker-plugin-lto` and\n+the C/C++ code with `-flto` or `-flto=thin` so that object files are emitted\n+as LLVM bitcode.\n+\n+### Rust `staticlib` as dependency in C/C++ program\n+\n+In this case the Rust compiler just has to make sure that the object files in\n+the `staticlib` are in the right format. For linking, a linker with the\n+LLVM plugin must be used (e.g. LLD).\n+\n+Using `rustc` directly:\n+\n+```bash\n+# Compile the Rust staticlib\n+rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs\n+# Compile the C code with `-flto=thin`\n+clang -c -O2 -flto=thin -o main.o ./main.c\n+# Link everything, making sure that we use an appropriate linker\n+clang -flto=thin -fuse-ld=lld -L . -l\"name-of-your-rust-lib\" -o main -O2 ./cmain.o\n+```\n+\n+Using `cargo`:\n+\n+```bash\n+# Compile the Rust staticlib\n+RUSTFLAGS=\"-Clinker-plugin-lto\" cargo build --release\n+# Compile the C code with `-flto=thin`\n+clang -c -O2 -flto=thin -o main.o ./main.c\n+# Link everything, making sure that we use an appropriate linker\n+clang -flto=thin -fuse-ld=lld -L . -l\"name-of-your-rust-lib\" -o main -O2 ./cmain.o\n+```\n+\n+### C/C++ code as a dependency in Rust\n+\n+In this case the linker will be invoked by `rustc`. We again have to make sure\n+that an appropriate linker is used.\n+\n+Using `rustc` directly:\n+\n+```bash\n+# Compile C code with `-flto`\n+clang ./clib.c -flto=thin -c -o ./clib.o -O2\n+# Create a static library from the C code\n+ar crus ./libxyz.a ./clib.o\n+\n+# Invoke `rustc` with the additional arguments\n+rustc -Clinker-plugin-lto -L. -Copt-level=2 -Clinker=clang -Clink-arg=-fuse-ld=lld ./main.rs\n+```\n+\n+Using `cargo` directly:\n+\n+```bash\n+# Compile C code with `-flto`\n+clang ./clib.c -flto=thin -c -o ./clib.o -O2\n+# Create a static library from the C code\n+ar crus ./libxyz.a ./clib.o\n+\n+# Set the linking arguments via RUSTFLAGS\n+RUSTFLAGS=\"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld\" cargo build --release\n+```\n+\n+### Explicitly specifying the linker plugin to be used by `rustc`\n+\n+If one wants to use a linker other than LLD, the LLVM linker plugin has to be\n+specified explicitly. Otherwise the linker cannot read the object files. The\n+path to the plugin is passed as an argument to the `-Clinker-plugin-lto`\n+option:\n+\n+```bash\n+rustc -Clinker-plugin-lto=\"/path/to/LLVMgold.so\" -L. -Copt-level=2 ./main.rs\n+```\n+\n+\n+## Toolchain Compatibility\n+\n+In order for this kind of LTO to work, the LLVM linker plugin must be able to\n+handle the LLVM bitcode produced by both `rustc` and `clang`.\n+\n+Best results are achieved by using a `rustc` and `clang` that are based on the\n+exact same version of LLVM. One can use `rustc -vV` in order to view the LLVM\n+used by a given `rustc` version. Note that the version number given\n+here is only an approximation as Rust sometimes uses unstable revisions of\n+LLVM. However, the approximation is usually reliable.\n+\n+The following table shows known good combinations of toolchain versions.\n+\n+|           | Clang 7   | Clang 8   |\n+|-----------|-----------|-----------|\n+| Rust 1.34 |     \u2717     |     \u2713     |\n+| Rust 1.35 |     \u2717     |    \u2713(?)   |\n+\n+Note that the compatibility policy for this feature might change in the future."}, {"sha": "5f807bf99e7e6e5ee0d732288c942f7113990bda", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -96,18 +96,18 @@ pub enum LtoCli {\n }\n \n #[derive(Clone, PartialEq, Hash)]\n-pub enum CrossLangLto {\n+pub enum LinkerPluginLto {\n     LinkerPlugin(PathBuf),\n     LinkerPluginAuto,\n     Disabled\n }\n \n-impl CrossLangLto {\n+impl LinkerPluginLto {\n     pub fn enabled(&self) -> bool {\n         match *self {\n-            CrossLangLto::LinkerPlugin(_) |\n-            CrossLangLto::LinkerPluginAuto => true,\n-            CrossLangLto::Disabled => false,\n+            LinkerPluginLto::LinkerPlugin(_) |\n+            LinkerPluginLto::LinkerPluginAuto => true,\n+            LinkerPluginLto::Disabled => false,\n         }\n     }\n }\n@@ -812,7 +812,7 @@ macro_rules! options {\n         pub const parse_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n                   `fat`, or omitted\");\n-        pub const parse_cross_lang_lto: Option<&str> =\n+        pub const parse_linker_plugin_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n         pub const parse_merge_functions: Option<&str> =\n@@ -821,7 +821,7 @@ macro_rules! options {\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, CrossLangLto};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -1037,22 +1037,22 @@ macro_rules! options {\n             true\n         }\n \n-        fn parse_cross_lang_lto(slot: &mut CrossLangLto, v: Option<&str>) -> bool {\n+        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n             if v.is_some() {\n                 let mut bool_arg = None;\n                 if parse_opt_bool(&mut bool_arg, v) {\n                     *slot = if bool_arg.unwrap() {\n-                        CrossLangLto::LinkerPluginAuto\n+                        LinkerPluginLto::LinkerPluginAuto\n                     } else {\n-                        CrossLangLto::Disabled\n+                        LinkerPluginLto::Disabled\n                     };\n                     return true\n                 }\n             }\n \n             *slot = match v {\n-                None => CrossLangLto::LinkerPluginAuto,\n-                Some(path) => CrossLangLto::LinkerPlugin(PathBuf::from(path)),\n+                None => LinkerPluginLto::LinkerPluginAuto,\n+                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n             };\n             true\n         }\n@@ -1145,6 +1145,10 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"allow the linker to link its default libraries\"),\n     linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n                                            \"Linker flavor\"),\n+    linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n+        parse_linker_plugin_lto, [TRACKED],\n+        \"generate build artifacts that are compatible with linker-based LTO.\"),\n+\n }\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n@@ -1383,8 +1387,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"make the current crate share its generic instantiations\"),\n     chalk: bool = (false, parse_bool, [TRACKED],\n         \"enable the experimental Chalk-based trait solving engine\"),\n-    cross_lang_lto: CrossLangLto = (CrossLangLto::Disabled, parse_cross_lang_lto, [TRACKED],\n-        \"generate build artifacts that are compatible with linker-based LTO.\"),\n     no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n         \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n     no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n@@ -2440,7 +2442,7 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n-                Passes, Sanitizer, LtoCli, CrossLangLto};\n+                Passes, Sanitizer, LtoCli, LinkerPluginLto};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2507,7 +2509,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Option<Sanitizer>);\n     impl_dep_tracking_hash_via_hash!(TargetTriple);\n     impl_dep_tracking_hash_via_hash!(Edition);\n-    impl_dep_tracking_hash_via_hash!(CrossLangLto);\n+    impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2572,7 +2574,7 @@ mod tests {\n     use crate::lint;\n     use crate::middle::cstore;\n     use crate::session::config::{build_configuration, build_session_options_and_crate_config};\n-    use crate::session::config::{LtoCli, CrossLangLto};\n+    use crate::session::config::{LtoCli, LinkerPluginLto};\n     use crate::session::build_session;\n     use crate::session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n@@ -3105,6 +3107,10 @@ mod tests {\n         opts = reference.clone();\n         opts.cg.panic = Some(PanicStrategy::Abort);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.linker_plugin_lto = LinkerPluginLto::LinkerPluginAuto;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]\n@@ -3231,10 +3237,6 @@ mod tests {\n         opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n-        opts = reference.clone();\n-        opts.debugging_opts.cross_lang_lto = CrossLangLto::LinkerPluginAuto;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n         opts = reference.clone();\n         opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "bfd447e8dd81c060322f20dd064227d2facdc67f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -1267,7 +1267,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     // bitcode during ThinLTO. Therefore we disallow dynamic linking on MSVC\n     // when compiling for LLD ThinLTO. This way we can validly just not generate\n     // the `dllimport` attributes and `__imp_` symbols in that case.\n-    if sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+    if sess.opts.cg.linker_plugin_lto.enabled() &&\n        sess.opts.cg.prefer_dynamic &&\n        sess.target.target.options.is_like_msvc {\n         sess.err(\"Linker plugin based LTO is not supported together with \\"}, {"sha": "548c94abc076f49cc855da34b8906e0a3eecfe26", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -857,7 +857,7 @@ fn link_args(cmd: &mut dyn Linker,\n              codegen_results: &CodegenResults) {\n \n     // Linker plugins should be specified early in the list of arguments\n-    cmd.cross_lang_lto();\n+    cmd.linker_plugin_lto();\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n@@ -1491,7 +1491,7 @@ fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n         Lto::Thin => {\n             // If we defer LTO to the linker, we haven't run LTO ourselves, so\n             // any upstream object files have not been copied yet.\n-            !sess.opts.debugging_opts.cross_lang_lto.enabled()\n+            !sess.opts.cg.linker_plugin_lto.enabled()\n         }\n         Lto::No |\n         Lto::ThinLocal => false,"}, {"sha": "ac55244d8d931f93b772177183095911f0c8f0e2", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -159,7 +159,7 @@ pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n-    if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n+    if cgcx.opts.cg.linker_plugin_lto.enabled() {\n         unreachable!(\"We should never reach this case if the LTO step \\\n                       is deferred to the linker\");\n     }"}, {"sha": "e78715319727b4b158cf6f9d54d06956dbdd6640", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -366,7 +366,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 let opt_level = config.opt_level.map(|x| to_llvm_opt_settings(x).0)\n                     .unwrap_or(llvm::CodeGenOptLevel::None);\n                 let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal ||\n-                    (cgcx.lto != Lto::Fat && cgcx.opts.debugging_opts.cross_lang_lto.enabled());\n+                    (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n                 with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n                     llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n                     llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);"}, {"sha": "ca9e2c87be2374ffbc34f2eb7a216c20f2b894e3", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -275,12 +275,12 @@ impl CodegenCx<'ll, 'tcx> {\n                 self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n-                // dynamic linking when cross-language LTO is enabled.\n-                !self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n+                // dynamic linking when linker plugin based LTO is enabled.\n+                !self.tcx.sess.opts.cg.linker_plugin_lto.enabled();\n \n             // If this assertion triggers, there's something wrong with commandline\n             // argument validation.\n-            debug_assert!(!(self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+            debug_assert!(!(self.tcx.sess.opts.cg.linker_plugin_lto.enabled() &&\n                             self.tcx.sess.target.target.options.is_like_msvc &&\n                             self.tcx.sess.opts.cg.prefer_dynamic));\n "}, {"sha": "356bb8d50ad0d45ecb74e849307b9e62d42c3532", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfo,\n-                             CrossLangLto, Lto};\n+                             LinkerPluginLto, Lto};\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use serialize::{json, Encoder};\n@@ -127,7 +127,7 @@ pub trait Linker {\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n-    fn cross_lang_lto(&mut self);\n+    fn linker_plugin_lto(&mut self);\n     // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n     fn finalize(&mut self) -> Command;\n }\n@@ -183,7 +183,7 @@ impl<'a> GccLinker<'a> {\n         }\n     }\n \n-    fn push_cross_lang_lto_args(&mut self, plugin_path: Option<&OsStr>) {\n+    fn push_linker_plugin_lto_args(&mut self, plugin_path: Option<&OsStr>) {\n         if let Some(plugin_path) = plugin_path {\n             let mut arg = OsString::from(\"-plugin=\");\n             arg.push(plugin_path);\n@@ -454,16 +454,16 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn cross_lang_lto(&mut self) {\n-        match self.sess.opts.debugging_opts.cross_lang_lto {\n-            CrossLangLto::Disabled => {\n+    fn linker_plugin_lto(&mut self) {\n+        match self.sess.opts.cg.linker_plugin_lto {\n+            LinkerPluginLto::Disabled => {\n                 // Nothing to do\n             }\n-            CrossLangLto::LinkerPluginAuto => {\n-                self.push_cross_lang_lto_args(None);\n+            LinkerPluginLto::LinkerPluginAuto => {\n+                self.push_linker_plugin_lto_args(None);\n             }\n-            CrossLangLto::LinkerPlugin(ref path) => {\n-                self.push_cross_lang_lto_args(Some(path.as_os_str()));\n+            LinkerPluginLto::LinkerPlugin(ref path) => {\n+                self.push_linker_plugin_lto_args(Some(path.as_os_str()));\n             }\n         }\n     }\n@@ -697,7 +697,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n \n-    fn cross_lang_lto(&mut self) {\n+    fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n }\n@@ -865,7 +865,7 @@ impl<'a> Linker for EmLinker<'a> {\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n \n-    fn cross_lang_lto(&mut self) {\n+    fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n }\n@@ -1047,7 +1047,7 @@ impl<'a> Linker for WasmLd<'a> {\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n \n-    fn cross_lang_lto(&mut self) {\n+    fn linker_plugin_lto(&mut self) {\n         // Do nothing for now\n     }\n }\n@@ -1207,6 +1207,6 @@ impl<'a> Linker for PtxLinker<'a> {\n     fn group_end(&mut self) {\n     }\n \n-    fn cross_lang_lto(&mut self) {\n+    fn linker_plugin_lto(&mut self) {\n     }\n }"}, {"sha": "2922d326c3b355e80c06f76ee7d1c31549499b38", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -126,7 +126,7 @@ impl ModuleConfig {\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode ||\n-                              sess.opts.debugging_opts.cross_lang_lto.enabled();\n+                              sess.opts.cg.linker_plugin_lto.enabled();\n         let embed_bitcode = sess.target.target.options.embed_bitcode ||\n                             sess.opts.debugging_opts.embed_bitcode;\n         if embed_bitcode {\n@@ -737,7 +737,7 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     // If the linker does LTO, we don't have to do it. Note that we\n     // keep doing full LTO, if it is requested, as not to break the\n     // assumption that the output will be a single module.\n-    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n+    let linker_does_lto = cgcx.opts.cg.linker_plugin_lto.enabled();\n \n     // When we're automatically doing ThinLTO for multi-codegen-unit\n     // builds we don't actually want to LTO the allocator modules if\n@@ -1883,14 +1883,14 @@ pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n     // This should never be true (because it's not supported). If it is true,\n     // something is wrong with commandline arg validation.\n-    assert!(!(tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+    assert!(!(tcx.sess.opts.cg.linker_plugin_lto.enabled() &&\n               tcx.sess.target.target.options.is_like_msvc &&\n               tcx.sess.opts.cg.prefer_dynamic));\n \n     tcx.sess.target.target.options.is_like_msvc &&\n         tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n-    // dynamic linking when cross-language LTO is enabled.\n-    !tcx.sess.opts.debugging_opts.cross_lang_lto.enabled()\n+    // dynamic linking when linker plugin LTO is enabled.\n+    !tcx.sess.opts.cg.linker_plugin_lto.enabled()\n }"}, {"sha": "33fc2bc1540d3f5831631239dd54ea45ed3b12e4", "filename": "src/test/codegen/no-dllimport-w-cross-lang-lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Fcodegen%2Fno-dllimport-w-cross-lang-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Fcodegen%2Fno-dllimport-w-cross-lang-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fno-dllimport-w-cross-lang-lto.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -3,7 +3,7 @@\n \n // no-prefer-dynamic\n // only-msvc\n-// compile-flags: -Z cross-lang-lto\n+// compile-flags: -C linker-plugin-lto\n \n #![crate_type = \"rlib\"]\n "}, {"sha": "3fdf6ab6d002f409fc610ed7da018e8bcb3cfdd9", "filename": "src/test/codegen/target-cpu-on-functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Fcodegen%2Ftarget-cpu-on-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Fcodegen%2Ftarget-cpu-on-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftarget-cpu-on-functions.rs?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -3,7 +3,7 @@\n \n // no-prefer-dynamic\n // ignore-tidy-linelength\n-// compile-flags: -C no-prepopulate-passes -C panic=abort -Z cross-lang-lto -Cpasses=name-anon-globals\n+// compile-flags: -C no-prepopulate-passes -C panic=abort -C linker-plugin-lto -Cpasses=name-anon-globals\n \n #![crate_type = \"staticlib\"]\n "}, {"sha": "b3c5fb2d79647bffde8f7bb8add1530e9e9c2727", "filename": "src/test/run-make-fulldeps/cross-lang-lto-clang/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto-clang%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto-clang%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto-clang%2FMakefile?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -8,7 +8,7 @@\n all: cpp-executable rust-executable\n \n cpp-executable:\n-\t$(RUSTC) -Zcross-lang-lto=on -o $(TMPDIR)/librustlib-xlto.a -Copt-level=2 -Ccodegen-units=1 ./rustlib.rs\n+\t$(RUSTC) -Clinker-plugin-lto=on -o $(TMPDIR)/librustlib-xlto.a -Copt-level=2 -Ccodegen-units=1 ./rustlib.rs\n \t$(CLANG) -flto=thin -fuse-ld=lld -L $(TMPDIR) -lrustlib-xlto -o $(TMPDIR)/cmain ./cmain.c -O3\n \t# Make sure we don't find a call instruction to the function we expect to\n \t# always be inlined.\n@@ -20,6 +20,6 @@ cpp-executable:\n rust-executable:\n \t$(CLANG) ./clib.c -flto=thin -c -o $(TMPDIR)/clib.o -O2\n \t(cd $(TMPDIR); $(AR) crus ./libxyz.a ./clib.o)\n-\t$(RUSTC) -Zcross-lang-lto=on -L$(TMPDIR) -Copt-level=2 -Clinker=$(CLANG) -Clink-arg=-fuse-ld=lld ./main.rs -o $(TMPDIR)/rsmain\n+\t$(RUSTC) -Clinker-plugin-lto=on -L$(TMPDIR) -Copt-level=2 -Clinker=$(CLANG) -Clink-arg=-fuse-ld=lld ./main.rs -o $(TMPDIR)/rsmain\n \tllvm-objdump -d $(TMPDIR)/rsmain | $(CGREP) -e \"call.*c_never_inlined\"\n \tllvm-objdump -d $(TMPDIR)/rsmain | $(CGREP) -v -e \"call.*c_always_inlined\""}, {"sha": "c9da06ff93f868356b47e6b4318979cc8b1261cf", "filename": "src/test/run-make-fulldeps/cross-lang-lto-upstream-rlibs/Makefile", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto-upstream-rlibs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto-upstream-rlibs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto-upstream-rlibs%2FMakefile?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -5,13 +5,13 @@\n ifndef IS_WINDOWS\n \n # This test makes sure that we don't loose upstream object files when compiling\n-# staticlibs with -Zcross-lang-lto\n+# staticlibs with -C linker-plugin-lto\n \n all: staticlib.rs upstream.rs\n-\t$(RUSTC) upstream.rs -Z cross-lang-lto -Ccodegen-units=1\n+\t$(RUSTC) upstream.rs -C linker-plugin-lto -Ccodegen-units=1\n \n \t# Check No LTO\n-\t$(RUSTC) staticlib.rs -Z cross-lang-lto -Ccodegen-units=1 -L. -o $(TMPDIR)/staticlib.a\n+\t$(RUSTC) staticlib.rs -C linker-plugin-lto -Ccodegen-units=1 -L. -o $(TMPDIR)/staticlib.a\n \t(cd $(TMPDIR); $(LD_LIB_PATH_ENVVAR)=$(REAL_LD_LIBRARY_PATH) llvm-ar x ./staticlib.a)\n \t# Make sure the upstream object file was included\n \tls $(TMPDIR)/upstream.*.rcgu.o\n@@ -20,8 +20,8 @@ all: staticlib.rs upstream.rs\n \trm $(TMPDIR)/*\n \n \t# Check ThinLTO\n-\t$(RUSTC) upstream.rs -Z cross-lang-lto -Ccodegen-units=1 -Clto=thin\n-\t$(RUSTC) staticlib.rs -Z cross-lang-lto -Ccodegen-units=1 -Clto=thin -L. -o $(TMPDIR)/staticlib.a\n+\t$(RUSTC) upstream.rs -C linker-plugin-lto -Ccodegen-units=1 -Clto=thin\n+\t$(RUSTC) staticlib.rs -C linker-plugin-lto -Ccodegen-units=1 -Clto=thin -L. -o $(TMPDIR)/staticlib.a\n \t(cd $(TMPDIR); $(LD_LIB_PATH_ENVVAR)=$(REAL_LD_LIBRARY_PATH) llvm-ar x ./staticlib.a)\n \tls $(TMPDIR)/upstream.*.rcgu.o\n "}, {"sha": "43bd05a73592c75cab1243016e0edfc52a5a6b81", "filename": "src/test/run-make-fulldeps/cross-lang-lto/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto%2FMakefile?ref=1c1d2e44c53b578b99d1ec34a1a6e69c5386fe4d", "patch": "@@ -7,14 +7,14 @@ ifndef IS_WINDOWS\n \n # This test makes sure that the object files we generate are actually\n # LLVM bitcode files (as used by linker LTO plugins) when compiling with\n-# -Z cross-lang-lto.\n+# -Clinker-plugin-lto.\n \n # this only succeeds for bitcode files\n ASSERT_IS_BITCODE_OBJ=($(LD_LIB_PATH_ENVVAR)=$(REAL_LD_LIBRARY_PATH) llvm-bcanalyzer $(1))\n EXTRACT_OBJS=(cd $(TMPDIR); rm -f ./*.o; $(LD_LIB_PATH_ENVVAR)=$(REAL_LD_LIBRARY_PATH) llvm-ar x $(1))\n \n-BUILD_LIB=$(RUSTC) lib.rs -Copt-level=2 -Z cross-lang-lto=on -Ccodegen-units=1\n-BUILD_EXE=$(RUSTC) main.rs -Copt-level=2 -Z cross-lang-lto=on -Ccodegen-units=1 --emit=obj\n+BUILD_LIB=$(RUSTC) lib.rs -Copt-level=2 -Clinker-plugin-lto -Ccodegen-units=1\n+BUILD_EXE=$(RUSTC) main.rs -Copt-level=2 -Clinker-plugin-lto -Ccodegen-units=1 --emit=obj\n \n all: staticlib staticlib-fat-lto staticlib-thin-lto rlib exe cdylib rdylib\n "}]}