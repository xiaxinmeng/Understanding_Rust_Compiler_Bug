{"sha": "b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MjBmNDZmMDMwOWZmOWZlNjgxZmM3ZjZiNGQ1NDEyYWI0MGE0Mzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-24T00:52:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-29T23:43:18Z"}, "message": "rustc: Don't generate landing pad cleanups for boxy things", "tree": {"sha": "9894b515b1b079a0796656714460aeeff292c731", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9894b515b1b079a0796656714460aeeff292c731"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "html_url": "https://github.com/rust-lang/rust/commit/b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a7a408386b8b1fbeb82cf6d695a168296c02793", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7a408386b8b1fbeb82cf6d695a168296c02793", "html_url": "https://github.com/rust-lang/rust/commit/3a7a408386b8b1fbeb82cf6d695a168296c02793"}], "stats": {"total": 101, "additions": 90, "deletions": 11}, "files": [{"sha": "1170ffba3ac5191930b40c897d4569a9d8a296a3", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "patch": "@@ -1 +1 @@\n-Subproject commit 1d6aec9d54c7a684ade521f71a4d538a6a88b14f\n+Subproject commit 1170ffba3ac5191930b40c897d4569a9d8a296a3"}, {"sha": "53ec03054c6e0e71abe28560910f469357d23284", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "patch": "@@ -3640,15 +3640,27 @@ fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n+fn trans_block_cleanups(bcx: block, cleanup_cx: block) -> block {\n+    trans_block_cleanups_(bcx, cleanup_cx, false)\n+}\n+\n+fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n    block {\n     let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n     if bcx.unreachable { ret bcx; }\n     let mut bcx = bcx;\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n         vec::riter(copy cleanups) {|cu|\n-            alt cu { clean(cfn) | clean_temp(_, cfn) { bcx = cfn(bcx); } }\n+            alt cu {\n+              clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) {\n+                // Some types don't need to be cleaned up during\n+                // landing pads because they can be freed en mass later\n+                if cleanup_type == normal_exit_and_unwind || !is_lpad {\n+                    bcx = cfn(bcx);\n+                }\n+              }\n+            }\n         }\n       }\n     }\n@@ -3662,6 +3674,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n+    let is_lpad = leave == none;\n     loop {\n         alt cur.kind {\n           block_scope(info) if info.cleanups.len() > 0u {\n@@ -3674,7 +3687,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n             let sub_cx = sub_block(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n             info.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n-            bcx = trans_block_cleanups(sub_cx, cur);\n+            bcx = trans_block_cleanups_(sub_cx, cur, is_lpad);\n           }\n           _ {}\n         }"}, {"sha": "4e0918cf6c74a2b0fecbb5c1f53cdc0534bb9949", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "patch": "@@ -201,9 +201,14 @@ fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n     }\n }\n \n+enum cleantype {\n+    normal_exit_only,\n+    normal_exit_and_unwind\n+}\n+\n enum cleanup {\n-    clean(fn@(block) -> block),\n-    clean_temp(ValueRef, fn@(block) -> block),\n+    clean(fn@(block) -> block, cleantype),\n+    clean_temp(ValueRef, fn@(block) -> block, cleantype),\n }\n \n // Used to remember and reuse existing cleanup paths\n@@ -216,15 +221,26 @@ fn scope_clean_changed(info: scope_info) {\n     info.landing_pad = none;\n }\n \n+fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n+    if ty::type_needs_unwind_cleanup(cx, ty) {\n+        normal_exit_and_unwind\n+    } else {\n+        normal_exit_only\n+    }\n+}\n+\n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean(bind base::drop_ty(_, val, ty))];\n+        info.cleanups += [clean(bind base::drop_ty(_, val, ty),\n+                                cleanup_type)];\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    let cleanup_type = cleanup_type(cx.tcx(), ty);\n     fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n        block {\n         if ty::type_is_immediate(ty) {\n@@ -234,22 +250,26 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n         }\n     }\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, bind do_drop(_, val, ty))];\n+        info.cleanups += [clean_temp(val, bind do_drop(_, val, ty),\n+                                     cleanup_type)];\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, bind base::drop_ty(_, val, ty))];\n+        info.cleanups += [clean_temp(val, bind base::drop_ty(_, val, ty),\n+                                     cleanup_type)];\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n     let free_fn = if shared { bind base::trans_shared_free(_, ptr) }\n                   else { bind base::trans_free(_, ptr) };\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(ptr, free_fn)];\n+        info.cleanups += [clean_temp(ptr, free_fn,\n+                                     normal_exit_and_unwind)];\n         scope_clean_changed(info);\n     }\n }\n@@ -263,7 +283,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n         let mut i = 0u;\n         for cu in info.cleanups {\n             alt cu {\n-              clean_temp(v, _) if v == val {\n+              clean_temp(v, _, _) if v == val {\n                 info.cleanups =\n                     vec::slice(info.cleanups, 0u, i) +\n                     vec::slice(info.cleanups, i + 1u, info.cleanups.len());"}, {"sha": "9a3d00e33d9d0f28edf8fea9010a1826b575c88d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b420f46f0309ff9fe681fc7f6b4d5412ab40a439/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b420f46f0309ff9fe681fc7f6b4d5412ab40a439", "patch": "@@ -121,6 +121,7 @@ export type_structurally_contains;\n export type_structurally_contains_uniques;\n export type_autoderef;\n export type_param;\n+export type_needs_unwind_cleanup;\n export canon_mode;\n export resolved_mode;\n export arg_mode;\n@@ -201,6 +202,7 @@ type ctxt =\n       rcache: creader_cache,\n       short_names_cache: hashmap<t, @str>,\n       needs_drop_cache: hashmap<t, bool>,\n+      needs_unwind_cleanup_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, ast_ty_to_ty_cache_entry>,\n       enum_var_cache: hashmap<def_id, @[variant_info]>,\n@@ -388,6 +390,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n       rcache: mk_rcache(),\n       short_names_cache: new_ty_hash(),\n       needs_drop_cache: new_ty_hash(),\n+      needs_unwind_cleanup_cache: new_ty_hash(),\n       kind_cache: new_ty_hash(),\n       ast_ty_to_ty_cache: map::hashmap(\n           ast_util::hash_ty, ast_util::eq_ty),\n@@ -902,6 +905,48 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     ret result;\n }\n \n+// Some things don't need cleanups during unwinding because the\n+// task can free them all at once later. Currently only things\n+// that only contain scalars and shared boxes can avoid unwind\n+// cleanups.\n+fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n+    alt cx.needs_unwind_cleanup_cache.find(ty) {\n+      some(result) { ret result; }\n+      none { }\n+    }\n+\n+    // Prevent infinite recursion\n+    cx.needs_unwind_cleanup_cache.insert(ty, false);\n+\n+    let mut needs_unwind_cleanup = false;\n+    maybe_walk_ty(ty) {|ty|\n+        alt get(ty).struct {\n+          ty_nil | ty_bot | ty_bool |\n+          ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty_box(_) | ty_rec(_) | ty_tup(_) {\n+            true\n+          }\n+          ty_enum(did, tps) {\n+            for v in *enum_variants(cx, did) {\n+                for aty in v.args {\n+                    let t = substitute_type_params(cx, tps, aty);\n+                    needs_unwind_cleanup |= type_needs_unwind_cleanup(cx, t);\n+                }\n+            }\n+            !needs_unwind_cleanup\n+          }\n+          _ {\n+            needs_unwind_cleanup = true;\n+            false\n+          }\n+        }\n+    }\n+\n+    cx.needs_unwind_cleanup_cache.insert(ty, needs_unwind_cleanup);\n+\n+    ret needs_unwind_cleanup;\n+}\n+\n enum kind { kind_sendable, kind_copyable, kind_noncopyable, }\n \n // Using these query functons is preferable to direct comparison or matching\n@@ -2323,6 +2368,7 @@ fn ast_constr_to_constr<T>(tcx: ctxt, c: @ast::constr_general<T>) ->\n     }\n }\n \n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}]}