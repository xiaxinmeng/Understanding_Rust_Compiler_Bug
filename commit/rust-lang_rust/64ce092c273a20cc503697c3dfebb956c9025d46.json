{"sha": "64ce092c273a20cc503697c3dfebb956c9025d46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0Y2UwOTJjMjczYTIwY2M1MDM2OTdjM2RmZWJiOTU2YzkwMjVkNDY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-02T12:42:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-02T12:42:51Z"}, "message": "Allow literal patterns to contain arbitrary literal expressions\n\nThis removes the need for the unary minus hacks, and allows some other\nneat things like matching on 1 >> 4.\n\nIssue #954", "tree": {"sha": "d34183cdb6f2728e21a882b18370be9300f21633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d34183cdb6f2728e21a882b18370be9300f21633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64ce092c273a20cc503697c3dfebb956c9025d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64ce092c273a20cc503697c3dfebb956c9025d46", "html_url": "https://github.com/rust-lang/rust/commit/64ce092c273a20cc503697c3dfebb956c9025d46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64ce092c273a20cc503697c3dfebb956c9025d46/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "691b517fb9e18e190763a8ac83e09f1cffa6cf11", "url": "https://api.github.com/repos/rust-lang/rust/commits/691b517fb9e18e190763a8ac83e09f1cffa6cf11", "html_url": "https://github.com/rust-lang/rust/commit/691b517fb9e18e190763a8ac83e09f1cffa6cf11"}], "stats": {"total": 303, "additions": 175, "deletions": 128}, "files": [{"sha": "7ed81be5eda2e77e1efe7fb36b893b370f921b63", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -137,6 +137,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     let freevars =\n         time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(def_map, crate));\n+    time(time_passes, \"const checking\",\n+         bind middle::check_const::check_crate(sess, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n     time(time_passes, \"typechecking\", bind typeck::check_crate(ty_cx, crate));\n     time(time_passes, \"block-use checking\",\n@@ -157,8 +159,6 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n         bind last_use::find_last_uses(crate, def_map, ref_map, ty_cx));\n     time(time_passes, \"kind checking\",\n          bind kind::check_crate(ty_cx, last_uses, crate));\n-    time(time_passes, \"const checking\",\n-         bind middle::check_const::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n     let llmod =\n         time(time_passes, \"translation\","}, {"sha": "59410cd3ecb5674c68d03177a3e54f427e11fd58", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -1,5 +1,6 @@\n import syntax::ast::*;\n-import syntax::ast_util::{variant_def_ids, dummy_sp, compare_lit, lit_eq};\n+import syntax::ast_util::{variant_def_ids, dummy_sp, compare_lit_exprs,\n+                          lit_expr_eq};\n import syntax::visit;\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n@@ -66,7 +67,7 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n       pat_wild. | pat_bind(_) { ret true; }\n       pat_lit(la) {\n         alt b.node {\n-          pat_lit(lb) { ret lit_eq(la, lb); }\n+          pat_lit(lb) { ret lit_expr_eq(la, lb); }\n           _ { ret false; }\n         }\n       }\n@@ -106,11 +107,12 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n       pat_range(begina, enda) {\n         alt b.node {\n           pat_lit(lb) {\n-            ret compare_lit(begina, lb) <= 0 && compare_lit(enda, lb) >= 0;\n+            ret compare_lit_exprs(begina, lb) <= 0 &&\n+                compare_lit_exprs(enda, lb) >= 0;\n           }\n           pat_range(beginb, endb) {\n-            ret compare_lit(begina, beginb) <= 0 &&\n-                compare_lit(enda, endb) >= 0;\n+            ret compare_lit_exprs(begina, beginb) <= 0 &&\n+                compare_lit_exprs(enda, endb) >= 0;\n           }\n           _ { ret false; }\n         }"}, {"sha": "f851033593a5ccb6e99dfbe31585a476b08b744e", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -1,46 +1,61 @@\n import syntax::ast::*;\n import syntax::visit;\n+import driver::session::session;\n \n-fn check_crate(tcx: ty::ctxt, crate: @crate) {\n-    let v =\n-        @{visit_item: bind check_item(tcx, _, _, _)\n-             with *visit::default_visitor::<()>()};\n-    visit::visit_crate(*crate, (), visit::mk_vt(v));\n-    tcx.sess.abort_if_errors();\n+fn check_crate(sess: session, crate: @crate) {\n+    visit::visit_crate(*crate, false, visit::mk_vt(@{\n+        visit_item: check_item,\n+        visit_pat: check_pat,\n+        visit_expr: bind check_expr(sess, _, _, _)\n+        with *visit::default_visitor()\n+    }));\n+    sess.abort_if_errors();\n }\n \n-fn check_item(tcx: ty::ctxt, it: @item, &&s: (), v: visit::vt<()>) {\n-    visit::visit_item(it, s, v);\n+fn check_item(it: @item, &&_is_const: bool, v: visit::vt<bool>) {\n     alt it.node {\n-      item_const(_ /* ty */, ex) {\n-         let v =\n-             @{visit_expr: bind check_const_expr(tcx, _, _, _)\n-                  with *visit::default_visitor::<()>()};\n-         check_const_expr(tcx, ex, (), visit::mk_vt(v));\n-       }\n-       _ { }\n+      item_const(_, ex) { v.visit_expr(ex, true, v); }\n+      _ { visit::visit_item(it, false, v); }\n     }\n }\n \n-fn check_const_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n-    visit::visit_expr(ex, s, v);\n-    alt ex.node {\n-      expr_lit(_) { }\n-      expr_binary(_, _, _) { /* subexps covered by visit */ }\n-      expr_unary(u, _) {\n-        alt u {\n-          box(_)  |\n-          uniq(_) |\n-          deref.  {\n-            tcx.sess.span_err(ex.span,\n-                              \"disallowed operator in constant expression\");\n+fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n+    fn is_str(e: @expr) -> bool {\n+        alt e.node { expr_lit(@{node: lit_str(_), _}) { true } _ { false } }\n+    }\n+    alt p.node {\n+      // Let through plain string literals here\n+      pat_lit(a) { if !is_str(a) { v.visit_expr(a, true, v); } }\n+      pat_range(a, b) {\n+        if !is_str(a) { v.visit_expr(a, true, v); }\n+        if !is_str(b) { v.visit_expr(b, true, v); }\n+      }\n+      _ { visit::visit_pat(p, false, v); }\n+    }\n+}\n+\n+fn check_expr(sess: session, e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n+    if is_const {\n+        alt e.node {\n+          expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n+          expr_unary(deref., _){\n+            sess.span_err(e.span,\n+                          \"disallowed operator in constant expression\");\n+            ret;\n+          }\n+          expr_lit(@{node: lit_str(_), _}) {\n+            sess.span_err(e.span,\n+                          \"string constants are not supported\");\n+          }\n+          expr_lit(_) | expr_binary(_, _, _) | expr_unary(_, _) {}\n+          _ {\n+            sess.span_err(e.span,\n+                          \"constant contains unimplemented expression type\");\n+            ret;\n           }\n-          _ { }\n         }\n-      }\n-      _ { tcx.sess.span_err(ex.span,\n-            \"constant contains unimplemented expression type\"); }\n     }\n+    visit::visit_expr(e, is_const, v);\n }\n \n // Local Variables:"}, {"sha": "efbad8d212aba8b0a17be8e61bc75dbb703dc254", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -7,32 +7,27 @@ import trans_build::*;\n import trans::{new_sub_block_ctxt, new_scope_block_ctxt, load_if_immediate};\n import syntax::ast;\n import syntax::ast_util;\n-import syntax::ast_util::{dummy_sp, lit_eq};\n+import syntax::ast_util::{dummy_sp};\n import syntax::ast::def_id;\n import syntax::codemap::span;\n \n import trans_common::*;\n \n // An option identifying a branch (either a literal, a tag variant or a range)\n tag opt {\n-    lit(@ast::lit);\n+    lit(@ast::expr);\n     var(/* variant id */uint, /* variant dids */{tg: def_id, var: def_id});\n-    range(@ast::lit, @ast::lit);\n+    range(@ast::expr, @ast::expr);\n }\n fn opt_eq(a: opt, b: opt) -> bool {\n-    alt a {\n-      lit(la) {\n-        ret alt b { lit(lb) { lit_eq(la, lb) } _ { false } };\n-      }\n-      var(ida, _) {\n-        ret alt b { var(idb, _) { ida == idb } _ { false } };\n-      }\n-      range(la1, la2) {\n-        ret alt b {\n-          range(lb1, lb2) { lit_eq(la1, lb1) && lit_eq(la2, lb2) }\n-          _ { false }\n-        };\n+    alt (a, b) {\n+      (lit(a), lit(b)) { ast_util::compare_lit_exprs(a, b) == 0 }\n+      (range(a1, a2), range(b1, b2)) {\n+        ast_util::compare_lit_exprs(a1, b1) == 0 &&\n+        ast_util::compare_lit_exprs(a2, b2) == 0\n       }\n+      (var(a, _), var(b, _)) { a == b }\n+      _ { false }\n     }\n }\n \n@@ -45,7 +40,7 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n     alt o {\n       lit(l) {\n         alt l.node {\n-          ast::lit_str(s) {\n+          ast::expr_lit(@{node: ast::lit_str(s), _}) {\n             let strty = ty::mk_str(bcx_tcx(bcx));\n             let cell = trans::empty_dest_cell();\n             bcx = trans_vec::trans_str(bcx, s, trans::by_val(cell));\n@@ -54,17 +49,14 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n           }\n           _ {\n             ret single_result(\n-                rslt(bcx, trans::trans_crate_lit(ccx, *l)));\n+                rslt(bcx, trans::trans_const_expr(ccx, l)));\n           }\n         }\n       }\n       var(id, _) { ret single_result(rslt(bcx, C_int(ccx, id as int))); }\n       range(l1, l2) {\n-        let cell1 = trans::empty_dest_cell();\n-        let cell2 = trans::empty_dest_cell();\n-        let bcx = trans::trans_lit(bcx, *l1, trans::by_val(cell1));\n-        let bcx = trans::trans_lit(bcx, *l2, trans::by_val(cell2));\n-        ret range_result(rslt(bcx, *cell1), rslt(bcx, *cell2));\n+        ret range_result(rslt(bcx, trans::trans_const_expr(ccx, l1)),\n+                         rslt(bcx, trans::trans_const_expr(ccx, l2)));\n       }\n     }\n }\n@@ -464,13 +456,9 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             }\n           }\n           lit(l) {\n-            kind = alt l.node {\n-              ast::lit_str(_) | ast::lit_nil. | ast::lit_float(_) |\n-              ast::lit_mach_float(_, _) {\n-                test_val = Load(bcx, val); compare\n-              }\n-              _ { test_val = Load(bcx, val); switch }\n-            };\n+            test_val = Load(bcx, val);\n+            let pty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n+            kind = ty::type_is_integral(ccx.tcx, pty) ? switch : compare;\n           }\n           range(_, _) {\n             test_val = Load(bcx, val);"}, {"sha": "a7dd6c81c7dc79ac93e8d814597f3c767b68fdd5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -155,6 +155,7 @@ export type_is_vec;\n export type_is_fp;\n export type_allows_implicit_copy;\n export type_is_integral;\n+export type_is_numeric;\n export type_is_native;\n export type_is_nil;\n export type_is_pod;\n@@ -1173,6 +1174,10 @@ fn type_is_fp(cx: ctxt, ty: t) -> bool {\n     }\n }\n \n+fn type_is_numeric(cx: ctxt, ty: t) -> bool {\n+    ret type_is_integral(cx, ty) || type_is_fp(cx, ty);\n+}\n+\n fn type_is_signed(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }"}, {"sha": "ae26d10dce89b600734ccd622fa42fc3e42dda47", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -1,7 +1,6 @@\n import syntax::{ast, ast_util};\n import ast::spanned;\n-import syntax::ast_util::{local_def, respan, ty_param_kind, lit_is_numeric,\n-                          lit_types_match};\n+import syntax::ast_util::{local_def, respan, ty_param_kind};\n import syntax::visit;\n import metadata::csearch;\n import driver::session;\n@@ -1253,8 +1252,8 @@ fn lit_as_float(l: @ast::lit) -> str {\n     }\n }\n \n-fn valid_range_bounds(l1: @ast::lit, l2: @ast::lit) -> bool {\n-    ast_util::compare_lit(l1, l2) <= 0\n+fn valid_range_bounds(from: @ast::expr, to: @ast::expr) -> bool {\n+    ast_util::compare_lit_exprs(from, to) <= 0\n }\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n@@ -1264,27 +1263,26 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n     alt pat.node {\n       ast::pat_wild. { write::ty_only_fixup(fcx, pat.id, expected); }\n       ast::pat_lit(lt) {\n-        let typ = check_lit(fcx.ccx, lt);\n-        typ = demand::simple(fcx, pat.span, expected, typ);\n-        write::ty_only_fixup(fcx, pat.id, typ);\n+        check_expr_with(fcx, lt, expected);\n+        write::ty_only_fixup(fcx, pat.id, expr_ty(fcx.ccx.tcx, lt));\n       }\n       ast::pat_range(begin, end) {\n-        if !lit_types_match(begin, end) {\n+        check_expr_with(fcx, begin, expected);\n+        check_expr_with(fcx, end, expected);\n+        let b_ty = resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n+                                                              begin));\n+        if b_ty != resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n+                                                              end)) {\n             fcx.ccx.tcx.sess.span_err(pat.span, \"mismatched types in range\");\n-        } else if !lit_is_numeric(begin) || !lit_is_numeric(end) {\n+        } else if !ty::type_is_numeric(fcx.ccx.tcx, b_ty) {\n             fcx.ccx.tcx.sess.span_err(pat.span,\n                                       \"non-numeric type used in range\");\n         } else if !valid_range_bounds(begin, end) {\n             fcx.ccx.tcx.sess.span_err(begin.span,\n                                       \"lower range bound must be less \\\n                                        than upper\");\n         }\n-        let typ1 = check_lit(fcx.ccx, begin);\n-        typ1 = demand::simple(fcx, pat.span, expected, typ1);\n-        write::ty_only_fixup(fcx, pat.id, typ1);\n-        let typ2 = check_lit(fcx.ccx, end);\n-        typ2 = demand::simple(fcx, pat.span, typ1, typ2);\n-        write::ty_only_fixup(fcx, pat.id, typ2);\n+        write::ty_only_fixup(fcx, pat.id, b_ty);\n       }\n       ast::pat_bind(name) {\n         let vid = lookup_local(fcx, pat.span, pat.id);"}, {"sha": "d9280a483b14b330e3dcbcefcdb8317378ee8672", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -86,13 +86,13 @@ type field_pat = {ident: ident, pat: @pat};\n tag pat_ {\n     pat_wild;\n     pat_bind(ident);\n-    pat_lit(@lit);\n     pat_tag(@path, [@pat]);\n     pat_rec([field_pat], bool);\n     pat_tup([@pat]);\n     pat_box(@pat);\n     pat_uniq(@pat);\n-    pat_range(@lit, @lit);\n+    pat_lit(@expr);\n+    pat_range(@expr, @expr);\n }\n \n tag mutability { mut; imm; maybe_mut; }"}, {"sha": "d8b52300e9168acd106de768f876ca21ebeab47e", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -225,45 +225,82 @@ fn ternary_to_if(e: @expr) -> @expr {\n \n fn ty_param_kind(tp: ty_param) -> kind { tp.kind }\n \n-fn compare_lit(a: @lit, b: @lit) -> int {\n-    fn cmp<T>(a: T, b: T) -> int { a == b ? 0 : a < b ? -1 : 1 }\n-    alt (a.node, b.node) {\n-      (lit_int(a), lit_int(b)) |\n-      (lit_mach_int(_, a), lit_mach_int(_, b)) { cmp(a, b) }\n-      (lit_uint(a), lit_uint(b)) { cmp(a, b) }\n-      (lit_char(a), lit_char(b)) { cmp(a, b) }\n-      (lit_float(a), lit_float(b)) |\n-      (lit_mach_float(_, a), lit_mach_float(_, b)) {\n-        cmp(std::float::from_str(a), std::float::from_str(b))\n+// FIXME this doesn't handle big integer/float literals correctly (nor does\n+// the rest of our literal handling)\n+tag const_val { const_float(float); const_int(i64); const_str(str); }\n+\n+fn eval_const_expr(e: @expr) -> const_val {\n+    fn fromb(b: bool) -> const_val { const_int(b as i64) }\n+    alt e.node {\n+      expr_unary(neg., inner) {\n+        alt eval_const_expr(inner) {\n+          const_float(f) { const_float(-f) }\n+          const_int(i) { const_int(-i) }\n+        }\n+      }\n+      expr_unary(not., inner) {\n+        alt eval_const_expr(inner) {\n+          const_int(i) { const_int(!i) }\n+        }\n       }\n-      (lit_str(a), lit_str(b)) { cmp(a, b) }\n-      (lit_nil., lit_nil.) { 0 }\n-      (lit_bool(a), lit_bool(b)) { cmp(a, b) }\n+      expr_binary(op, a, b) {\n+        alt (eval_const_expr(a), eval_const_expr(b)) {\n+          (const_float(a), const_float(b)) {\n+            alt op {\n+              add. { const_float(a + b) } sub. { const_float(a - b) }\n+              mul. { const_float(a * b) } div. { const_float(a / b) }\n+              rem. { const_float(a % b) } eq. { fromb(a == b) }\n+              lt. { fromb(a < b) } le. { fromb(a <= b) } ne. { fromb(a != b) }\n+              ge. { fromb(a >= b) } gt. { fromb(a > b) }\n+            }\n+          }\n+          (const_int(a), const_int(b)) {\n+            alt op {\n+              add. { const_int(a + b) } sub. { const_int(a - b) }\n+              mul. { const_int(a * b) } div. { const_int(a / b) }\n+              rem. { const_int(a % b) } and. | bitand. { const_int(a & b) }\n+              or. | bitor. { const_int(a | b) } bitxor. { const_int(a ^ b) }\n+              eq. { fromb(a == b) } lt. { fromb(a < b) }\n+              le. { fromb(a <= b) } ne. { fromb(a != b) }\n+              ge. { fromb(a >= b) } gt. { fromb(a > b) }\n+            }\n+          }\n+        }\n+      }\n+      expr_lit(lit) { lit_to_const(lit) }\n     }\n }\n \n-fn lit_eq(a: @lit, b: @lit) -> bool { compare_lit(a, b) == 0 }\n-\n-fn lit_types_match(a: @lit, b: @lit) -> bool {\n-    alt (a.node, b.node) {\n-      (lit_int(_), lit_int(_)) | (lit_uint(_), lit_uint(_)) |\n-      (lit_char(_), lit_char(_)) | (lit_float(_), lit_float(_)) |\n-      (lit_str(_), lit_str(_)) | (lit_nil., lit_nil.) |\n-      (lit_bool(_), lit_bool(_ )) { true }\n-      (lit_mach_int(ta, _), lit_mach_int(tb, _)) |\n-      (lit_mach_float(ta, _), lit_mach_float(tb, _)) { ta == tb }\n-      _ { false }\n+fn lit_to_const(lit: @lit) -> const_val {\n+    alt lit.node {\n+      lit_str(s) { const_str(s) }\n+      lit_char(ch) { const_int(ch as i64) }\n+      lit_int(i) | lit_mach_int(_, i) { const_int(i as i64) }\n+      lit_uint(ui) { const_int(ui as i64) }\n+      lit_float(s) | lit_mach_float(_, s) {\n+        const_float(std::float::from_str(s))\n+      }\n+      lit_nil. { const_int(0i64) }\n+      lit_bool(b) { const_int(b as i64) }\n     }\n }\n \n-fn lit_is_numeric(l: @ast::lit) -> bool {\n-    alt l.node {\n-      ast::lit_int(_) | ast::lit_char(_) | ast::lit_uint(_) |\n-      ast::lit_mach_int(_, _) | ast::lit_float(_) | ast::lit_mach_float(_,_) {\n-        true\n-      }\n-      _ { false }\n-    }\n+fn compare_const_vals(a: const_val, b: const_val) -> int {\n+  alt (a, b) {\n+    (const_int(a), const_int(b)) { a == b ? 0 : a < b ? -1 : 1 }\n+    (const_float(a), const_float(b)) { a == b ? 0 : a < b ? -1 : 1 }\n+    (const_str(a), const_str(b)) { a == b ? 0 : a < b ? -1 : 1 }\n+  }\n+}\n+\n+fn compare_lit_exprs(a: @expr, b: @expr) -> int {\n+  compare_const_vals(eval_const_expr(a), eval_const_expr(b))\n+}\n+\n+fn lit_expr_eq(a: @expr, b: @expr) -> bool { compare_lit_exprs(a, b) == 0 }\n+\n+fn lit_eq(a: @lit, b: @lit) -> bool {\n+    compare_const_vals(lit_to_const(a), lit_to_const(b)) == 0\n }\n \n // Local Variables:"}, {"sha": "9baf6cf3ccf5f1a5bc1b4ce987521d20f6a77b65", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -9,7 +9,7 @@ import util::interner;\n import ast::{node_id, spanned};\n import front::attr;\n \n-tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; }\n+tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; RESTRICT_NO_BAR_OP; }\n \n tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n@@ -1189,6 +1189,8 @@ fn parse_more_binops(p: parser, lhs: @ast::expr, min_prec: int) ->\n       }\n       none. { none }\n     };\n+    if peeked == token::BINOP(token::OR) &&\n+       p.get_restriction() == RESTRICT_NO_BAR_OP { ret lhs; }\n     for cur: op_spec in *p.get_prec_table() {\n         if cur.prec > min_prec && cur.tok == peeked {\n             p.bump();\n@@ -1462,9 +1464,9 @@ fn parse_pat(p: parser) -> @ast::pat {\n         if p.peek() == token::RPAREN {\n             hi = p.get_hi_pos();\n             p.bump();\n-            pat =\n-                ast::pat_lit(@{node: ast::lit_nil,\n-                               span: ast_util::mk_sp(lo, hi)});\n+            let lit = @{node: ast::lit_nil, span: ast_util::mk_sp(lo, hi)};\n+            let expr = mk_expr(p, lo, hi, ast::expr_lit(lit));\n+            pat = ast::pat_lit(expr);\n         } else {\n             let fields = [parse_pat(p)];\n             while p.peek() == token::COMMA {\n@@ -1479,14 +1481,14 @@ fn parse_pat(p: parser) -> @ast::pat {\n       }\n       tok {\n         if !is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\") {\n-            let lit = parse_lit(p);\n+            let val = parse_expr_res(p, RESTRICT_NO_BAR_OP);\n             if eat_word(p, \"to\") {\n-                let end = parse_lit(p);\n+                let end = parse_expr_res(p, RESTRICT_NO_BAR_OP);\n                 hi = end.span.hi;\n-                pat = ast::pat_range(@lit, @end);\n+                pat = ast::pat_range(val, end);\n             } else {\n-                hi = lit.span.hi;\n-                pat = ast::pat_lit(@lit);\n+                hi = val.span.hi;\n+                pat = ast::pat_lit(val);\n             }\n         } else if is_plain_ident(p) &&\n                       alt p.look_ahead(1u) {"}, {"sha": "612768c4137c18f71ce9b46c70612feada825c57", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ce092c273a20cc503697c3dfebb956c9025d46/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=64ce092c273a20cc503697c3dfebb956c9025d46", "patch": "@@ -1061,7 +1061,6 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     alt pat.node {\n       ast::pat_wild. { word(s.s, \"_\"); }\n       ast::pat_bind(id) { word(s.s, id); }\n-      ast::pat_lit(lit) { print_literal(s, lit); }\n       ast::pat_tag(path, args) {\n         print_path(s, path, true);\n         if vec::len(args) > 0u {\n@@ -1094,11 +1093,12 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n       }\n       ast::pat_box(inner) { word(s.s, \"@\"); print_pat(s, inner); }\n       ast::pat_uniq(inner) { word(s.s, \"~\"); print_pat(s, inner); }\n+      ast::pat_lit(e) { print_expr(s, e); }\n       ast::pat_range(begin, end) {\n-        print_literal(s, begin);\n+        print_expr(s, begin);\n         space(s.s);\n         word_space(s, \"to\");\n-        print_literal(s, end);\n+        print_expr(s, end);\n       }\n     }\n     s.ann.post(ann_node);"}]}