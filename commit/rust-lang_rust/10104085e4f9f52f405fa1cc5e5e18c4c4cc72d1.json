{"sha": "10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMTA0MDg1ZTRmOWY1MmY0MDVmYTFjYzVlNWUxOGM0YzRjYzcyZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-13T22:20:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-13T22:20:58Z"}, "message": "Auto merge of #69144 - Dylan-DPC:rollup-apt6zjj, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #68728 (parse: merge `fn` syntax + cleanup item parsing)\n - #68938 (fix lifetime shadowing check in GATs)\n - #69057 (expand: misc cleanups and simplifications)\n - #69108 (Use HirId in TraitCandidate.)\n - #69125 (Add comment to SGX entry code)\n - #69126 (miri: fix exact_div)\n - #69127 (Enable use after scope detection in the new LLVM pass manager)\n - #69135 (Spelling error \"represening\" to \"representing\")\n - #69141 (Don't error on network failures)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e454e1e75dff88439e15462a257cb669b1d4c10d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e454e1e75dff88439e15462a257cb669b1d4c10d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "html_url": "https://github.com/rust-lang/rust/commit/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d04ce67fd14538d03fa47a2598f80d49fd564c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d04ce67fd14538d03fa47a2598f80d49fd564c6", "html_url": "https://github.com/rust-lang/rust/commit/5d04ce67fd14538d03fa47a2598f80d49fd564c6"}, {"sha": "7704e590ece52ef265e0ca16bce1180930b69330", "url": "https://api.github.com/repos/rust-lang/rust/commits/7704e590ece52ef265e0ca16bce1180930b69330", "html_url": "https://github.com/rust-lang/rust/commit/7704e590ece52ef265e0ca16bce1180930b69330"}], "stats": {"total": 1620, "additions": 754, "deletions": 866}, "files": [{"sha": "eadc9ddeee6fc827af0b4736b02abc0bb7876f13", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -270,7 +270,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n \n         let import_keys = import_ids\n             .iter()\n-            .map(|node_id| hcx.node_to_hir_id(*node_id))\n             .map(|hir_id| (hcx.local_def_path_hash(hir_id.owner), hir_id.local_id))\n             .collect();\n         (hcx.def_path_hash(*def_id), import_keys)"}, {"sha": "b2eb122bfeeade2e4916f9c8e9e7465b4940eb74", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1161,6 +1161,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n+            let v = v\n+                .into_iter()\n+                .map(|tc| tc.map_import_ids(|id| hir.definitions().node_to_hir_id(id)))\n+                .collect();\n             map.insert(hir_id.local_id, StableVec::new(v));\n         }\n "}, {"sha": "ad51c60ab017874a627720aca95c6796a5e60569", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -126,7 +126,7 @@ pub struct ResolverOutputs {\n     pub definitions: hir_map::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: NodeMap<CrateNum>,\n-    pub trait_map: TraitMap,\n+    pub trait_map: TraitMap<NodeId>,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n     pub export_map: ExportMap<NodeId>,"}, {"sha": "75938470b6fca7b248eae93d4106e7b9897f32af", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1269,6 +1269,7 @@ impl<'a> State<'a> {\n                 self.print_where_clause(&generics.where_clause);\n                 self.s.word(\" \");\n                 self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n                 for trait_item in trait_items {\n                     self.print_assoc_item(trait_item);\n                 }"}, {"sha": "371d1f744dd25755b0872f713f0b450d5eedac81", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -451,28 +451,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         _ => unreachable!(),\n                     };\n                     if !item.derive_allowed() {\n-                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                            .expect(\"`derive` attribute should exist\");\n-                        let span = attr.span;\n-                        let mut err = self.cx.struct_span_err(\n-                            span,\n-                            \"`derive` may only be applied to structs, enums and unions\",\n-                        );\n-                        if let ast::AttrStyle::Inner = attr.style {\n-                            let trait_list = derives\n-                                .iter()\n-                                .map(|t| pprust::path_to_string(t))\n-                                .collect::<Vec<_>>();\n-                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                            err.span_suggestion(\n-                                span,\n-                                \"try an outer attribute\",\n-                                suggestion,\n-                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        err.emit();\n+                        self.error_derive_forbidden_on_non_adt(&derives, &item);\n                     }\n \n                     let mut item = self.fully_configure(item);\n@@ -521,6 +500,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         fragment_with_placeholders\n     }\n \n+    fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n+        let attr =\n+            attr::find_by_name(item.attrs(), sym::derive).expect(\"`derive` attribute should exist\");\n+        let span = attr.span;\n+        let mut err = self\n+            .cx\n+            .struct_span_err(span, \"`derive` may only be applied to structs, enums and unions\");\n+        if let ast::AttrStyle::Inner = attr.style {\n+            let trait_list = derives.iter().map(|t| pprust::path_to_string(t)).collect::<Vec<_>>();\n+            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+            err.span_suggestion(\n+                span,\n+                \"try an outer attribute\",\n+                suggestion,\n+                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        err.emit();\n+    }\n+\n     fn resolve_imports(&mut self) {\n         if self.monotonic {\n             self.cx.resolver.resolve_imports();\n@@ -606,21 +606,38 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n-        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let expn_data = self.cx.current_expansion.id.expn_data();\n-            let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n-            let mut err = self.cx.struct_span_err(\n+    fn error_recursion_limit_reached(&mut self) {\n+        let expn_data = self.cx.current_expansion.id.expn_data();\n+        let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n+        self.cx\n+            .struct_span_err(\n                 expn_data.call_site,\n                 &format!(\"recursion limit reached while expanding `{}`\", expn_data.kind.descr()),\n-            );\n-            err.help(&format!(\n+            )\n+            .help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n                 suggested_limit, self.cx.ecfg.crate_name,\n-            ));\n-            err.emit();\n-            self.cx.trace_macros_diag();\n-            FatalError.raise();\n+            ))\n+            .emit();\n+        self.cx.trace_macros_diag();\n+        FatalError.raise();\n+    }\n+\n+    /// A macro's expansion does not fit in this fragment kind.\n+    /// For example, a non-type macro in a type position.\n+    fn error_wrong_fragment_kind(&mut self, kind: AstFragmentKind, mac: &ast::Mac, span: Span) {\n+        let msg = format!(\n+            \"non-{kind} macro in {kind} position: {path}\",\n+            kind = kind.name(),\n+            path = pprust::path_to_string(&mac.path),\n+        );\n+        self.cx.span_err(span, &msg);\n+        self.cx.trace_macros_diag();\n+    }\n+\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n+            self.error_recursion_limit_reached();\n         }\n \n         let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n@@ -638,13 +655,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n-                        let msg = format!(\n-                            \"non-{kind} macro in {kind} position: {path}\",\n-                            kind = fragment_kind.name(),\n-                            path = pprust::path_to_string(&mac.path),\n-                        );\n-                        self.cx.span_err(span, &msg);\n-                        self.cx.trace_macros_diag();\n+                        self.error_wrong_fragment_kind(fragment_kind, &mac, span);\n                         fragment_kind.dummy(span)\n                     };\n                     self.cx.current_expansion.prior_type_ascription = prev;\n@@ -867,7 +878,7 @@ pub fn parse_ast_fragment<'a>(\n         AstFragmentKind::ForeignItems => {\n             let mut items = SmallVec::new();\n             while this.token != token::Eof {\n-                items.push(this.parse_foreign_item()?);\n+                items.push(this.parse_foreign_item(&mut false)?);\n             }\n             AstFragment::ForeignItems(items)\n         }\n@@ -1030,13 +1041,10 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item<T>(\n+    fn classify_item(\n         &mut self,\n-        item: &mut T,\n-    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)\n-    where\n-        T: HasAttrs,\n-    {\n+        item: &mut impl HasAttrs,\n+    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool) {\n         let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item.visit_attrs(|mut attrs| {\n@@ -1050,9 +1058,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     /// Alternative to `classify_item()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem<T: HasAttrs>(\n+    fn classify_nonitem(\n         &mut self,\n-        nonitem: &mut T,\n+        nonitem: &mut impl HasAttrs,\n     ) -> (Option<ast::Attribute>, /* after_derive */ bool) {\n         let (mut attr, mut after_derive) = (None, false);\n \n@@ -1375,21 +1383,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                if item.ident == Ident::invalid() {\n-                    return noop_flat_map_item(item, self);\n-                }\n-\n+            ast::ItemKind::Mod(ast::Mod { inner, inline, .. })\n+                if item.ident != Ident::invalid() =>\n+            {\n                 let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n                 module.mod_path.push(item.ident);\n \n-                // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n-                // In the non-inline case, `inner` is never the dummy span (cf. `parse_item_mod`).\n-                // Thus, if `inner` is the dummy span, we know the module is inline.\n-                let inline_module = item.span.contains(inner) || inner.is_dummy();\n-\n-                if inline_module {\n+                if inline {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, sym::path) {\n                         self.cx.current_expansion.directory_ownership =\n                             DirectoryOwnership::Owned { relative: None };"}, {"sha": "80b379218a5d50d0fd79735a3d8bc65742c23de1", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -16,7 +16,7 @@ use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, AsmDialect, CrateSugar, Ident, Name, NodeId};\n+use syntax::ast::{self, AsmDialect, CrateSugar, Ident, Name};\n use syntax::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n pub use syntax::ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use syntax::ast::{CaptureBy, Movability, Mutability};\n@@ -2608,13 +2608,24 @@ pub type CaptureModeMap = NodeMap<CaptureBy>;\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n #[derive(Clone, Debug)]\n-pub struct TraitCandidate {\n+pub struct TraitCandidate<ID = HirId> {\n     pub def_id: DefId,\n-    pub import_ids: SmallVec<[NodeId; 1]>,\n+    pub import_ids: SmallVec<[ID; 1]>,\n+}\n+\n+impl<ID> TraitCandidate<ID> {\n+    pub fn map_import_ids<F, T>(self, f: F) -> TraitCandidate<T>\n+    where\n+        F: Fn(ID) -> T,\n+    {\n+        let TraitCandidate { def_id, import_ids } = self;\n+        let import_ids = import_ids.into_iter().map(f).collect();\n+        TraitCandidate { def_id, import_ids }\n+    }\n }\n \n // Trait method resolution\n-pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n+pub type TraitMap<ID = HirId> = NodeMap<Vec<TraitCandidate<ID>>>;\n \n // Map from the NodeId of a glob import to a list of items which are actually\n // imported."}, {"sha": "25334461a113bb7087d68c66e032b095cd734aa3", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -35,7 +35,7 @@ impl Token {\n     }\n }\n \n-/// Enum represening common lexeme types.\n+/// Enum representing common lexeme types.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum TokenKind {\n     // Multi-char tokens:"}, {"sha": "1085b85d7cde3a00daa20918d0a864a385a97da3", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -384,8 +384,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx> {\n         // Performs an exact division, resulting in undefined behavior where\n         // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`.\n-        // First, check x % y != 0.\n-        if self.binary_op(BinOp::Rem, a, b)?.to_bits()? != 0 {\n+        // First, check x % y != 0 (or if that computation overflows).\n+        let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, a, b)?;\n+        if overflow || res.to_bits(a.layout.size)? != 0 {\n             // Then, check if `b` is -1, which is the \"min_value / -1\" case.\n             let minus1 = Scalar::from_int(-1, dest.layout.size);\n             let b_scalar = b.to_scalar().unwrap();\n@@ -395,6 +396,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 throw_ub_format!(\"exact_div: {} cannot be divided by {} without remainder\", a, b,)\n             }\n         }\n+        // `Rem` says this is all right, so we can let `Div` do its job.\n         self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n     }\n }"}, {"sha": "ec0d251a3f8df7fa545444811c9209c5c9550fe0", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -207,30 +207,29 @@ pub fn features(\n     edition: Edition,\n     allow_features: &Option<Vec<String>>,\n ) -> (ast::Crate, Features) {\n-    let features;\n-    {\n-        let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n+    let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n \n-        let unconfigured_attrs = krate.attrs.clone();\n-        let err_count = sess.span_diagnostic.err_count();\n-        if let Some(attrs) = strip_unconfigured.configure(krate.attrs) {\n-            krate.attrs = attrs;\n-        } else {\n-            // the entire crate is unconfigured\n+    let unconfigured_attrs = krate.attrs.clone();\n+    let diag = &sess.span_diagnostic;\n+    let err_count = diag.err_count();\n+    let features = match strip_unconfigured.configure(krate.attrs) {\n+        None => {\n+            // The entire crate is unconfigured.\n             krate.attrs = Vec::new();\n             krate.module.items = Vec::new();\n-            return (krate, Features::default());\n+            Features::default()\n         }\n-\n-        features = get_features(&sess.span_diagnostic, &krate.attrs, edition, allow_features);\n-\n-        // Avoid reconfiguring malformed `cfg_attr`s\n-        if err_count == sess.span_diagnostic.err_count() {\n-            strip_unconfigured.features = Some(&features);\n-            strip_unconfigured.configure(unconfigured_attrs);\n+        Some(attrs) => {\n+            krate.attrs = attrs;\n+            let features = get_features(diag, &krate.attrs, edition, allow_features);\n+            if err_count == diag.err_count() {\n+                // Avoid reconfiguring malformed `cfg_attr`s.\n+                strip_unconfigured.features = Some(&features);\n+                strip_unconfigured.configure(unconfigured_attrs);\n+            }\n+            features\n         }\n-    }\n-\n+    };\n     (krate, features)\n }\n \n@@ -347,7 +346,13 @@ impl<'a> StripUnconfigured<'a> {\n             if !is_cfg(attr) {\n                 return true;\n             }\n-\n+            let meta_item = match validate_attr::parse_meta(self.sess, attr) {\n+                Ok(meta_item) => meta_item,\n+                Err(mut err) => {\n+                    err.emit();\n+                    return true;\n+                }\n+            };\n             let error = |span, msg, suggestion: &str| {\n                 let mut err = self.sess.span_diagnostic.struct_span_err(span, msg);\n                 if !suggestion.is_empty() {\n@@ -361,41 +366,15 @@ impl<'a> StripUnconfigured<'a> {\n                 err.emit();\n                 true\n             };\n-\n-            let meta_item = match validate_attr::parse_meta(self.sess, attr) {\n-                Ok(meta_item) => meta_item,\n-                Err(mut err) => {\n-                    err.emit();\n-                    return true;\n-                }\n-            };\n-            let nested_meta_items = if let Some(nested_meta_items) = meta_item.meta_item_list() {\n-                nested_meta_items\n-            } else {\n-                return error(\n-                    meta_item.span,\n-                    \"`cfg` is not followed by parentheses\",\n-                    \"cfg(/* predicate */)\",\n-                );\n-            };\n-\n-            if nested_meta_items.is_empty() {\n-                return error(meta_item.span, \"`cfg` predicate is not specified\", \"\");\n-            } else if nested_meta_items.len() > 1 {\n-                return error(\n-                    nested_meta_items.last().unwrap().span(),\n-                    \"multiple `cfg` predicates are specified\",\n-                    \"\",\n-                );\n-            }\n-\n-            match nested_meta_items[0].meta_item() {\n-                Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n-                None => error(\n-                    nested_meta_items[0].span(),\n-                    \"`cfg` predicate key cannot be a literal\",\n-                    \"\",\n-                ),\n+            let span = meta_item.span;\n+            match meta_item.meta_item_list() {\n+                None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n+                Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n+                Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n+                Some([single]) => match single.meta_item() {\n+                    Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n+                    None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n+                },\n             }\n         })\n     }\n@@ -562,14 +541,9 @@ fn is_cfg(attr: &Attribute) -> bool {\n \n /// Process the potential `cfg` attributes on a module.\n /// Also determine if the module should be included in this configuration.\n-pub fn process_configure_mod(\n-    sess: &ParseSess,\n-    cfg_mods: bool,\n-    attrs: &[Attribute],\n-) -> (bool, Vec<Attribute>) {\n+pub fn process_configure_mod(sess: &ParseSess, cfg_mods: bool, attrs: &mut Vec<Attribute>) -> bool {\n     // Don't perform gated feature checking.\n     let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n-    let mut attrs = attrs.to_owned();\n-    strip_unconfigured.process_cfg_attrs(&mut attrs);\n-    (!cfg_mods || strip_unconfigured.in_cfg(&attrs), attrs)\n+    strip_unconfigured.process_cfg_attrs(attrs);\n+    !cfg_mods || strip_unconfigured.in_cfg(&attrs)\n }"}, {"sha": "500aaaf43b92a3ddc669bb75c005f145bf9cc14e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 424, "deletions": 554, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -8,10 +8,9 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult, StashKey};\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::BytePos;\n-use syntax::ast::{self, AttrKind, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n+use syntax::ast::{self, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind};\n-use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, StrLit, Unsafe};\n+use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, Unsafe};\n use syntax::ast::{BindingMode, Block, FnDecl, FnSig, Mac, MacArgs, MacDelimiter, Param, SelfKind};\n use syntax::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n use syntax::ast::{FnHeader, ForeignItem, ForeignItemKind, Mutability, Visibility, VisibilityKind};\n@@ -22,7 +21,7 @@ use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use log::debug;\n use std::mem;\n \n-pub(super) type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n+pub(super) type ItemInfo = (Ident, ItemKind);\n \n impl<'a> Parser<'a> {\n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n@@ -83,345 +82,257 @@ impl<'a> Parser<'a> {\n         });\n \n         let lo = self.token.span;\n-\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if self.eat_keyword(kw::Use) {\n-            // USE ITEM\n-            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n-            self.expect_semi()?;\n+        if let Some((ident, kind)) = self.parse_item_kind(&mut attrs, macros_allowed, lo, &vis)? {\n+            return Ok(Some(P(self.mk_item(lo, ident, kind, vis, attrs))));\n+        }\n \n-            let span = lo.to(self.prev_span);\n-            let item = self.mk_item(span, Ident::invalid(), item_, vis, attrs);\n-            return Ok(Some(item));\n+        // FAILURE TO PARSE ITEM\n+        if let VisibilityKind::Inherited = vis.node {\n+        } else {\n+            let vs = pprust::vis_to_string(&vis);\n+            let vs = vs.trim_end();\n+            self.struct_span_err(vis.span, &format!(\"unmatched visibility `{}`\", vs))\n+                .span_label(vis.span, \"the unmatched visibility\")\n+                .help(&format!(\"you likely meant to define an item, e.g., `{} fn foo() {{}}`\", vs))\n+                .emit();\n         }\n \n-        if self.check_fn_front_matter() {\n-            // FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n-            let kind = ItemKind::Fn(sig, generics, body);\n-            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n+        if !attributes_allowed {\n+            self.recover_attrs_no_item(&attrs)?;\n         }\n+        Ok(None)\n+    }\n \n-        if self.eat_keyword(kw::Extern) {\n+    /// Parses one of the items allowed by the flags.\n+    fn parse_item_kind(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        macros_allowed: bool,\n+        lo: Span,\n+        vis: &Visibility,\n+    ) -> PResult<'a, Option<ItemInfo>> {\n+        let info = if self.eat_keyword(kw::Use) {\n+            // USE ITEM\n+            let tree = self.parse_use_tree()?;\n+            self.expect_semi()?;\n+            (Ident::invalid(), ItemKind::Use(P(tree)))\n+        } else if self.check_fn_front_matter() {\n+            // FUNCTION ITEM\n+            let (ident, sig, generics, body) = self.parse_fn(&mut false, attrs, |_| true)?;\n+            (ident, ItemKind::Fn(sig, generics, body))\n+        } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n-                return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n+                self.parse_item_extern_crate()?\n+            } else {\n+                // EXTERN BLOCK\n+                self.parse_item_foreign_mod(attrs)?\n             }\n-            // EXTERN BLOCK\n-            let abi = self.parse_abi();\n-            return Ok(Some(self.parse_item_foreign_mod(lo, abi, vis, attrs)?));\n-        }\n-\n-        if self.is_static_global() {\n+        } else if self.is_static_global() {\n             // STATIC ITEM\n-            self.bump();\n+            self.bump(); // `static`\n             let m = self.parse_mutability();\n-            let info = self.parse_item_const(Some(m))?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if let Const::Yes(const_span) = self.parse_constness() {\n+            self.parse_item_const(Some(m))?\n+        } else if let Const::Yes(const_span) = self.parse_constness() {\n             // CONST ITEM\n-            if self.eat_keyword(kw::Mut) {\n-                let prev_span = self.prev_span;\n-                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n-                    .span_label(prev_span, \"cannot be mutable\")\n-                    .span_suggestion(\n-                        const_span,\n-                        \"you might want to declare a static instead\",\n-                        \"static\".to_owned(),\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n-            }\n-\n-            let info = self.parse_item_const(None)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto]) {\n-            // UNSAFE TRAIT ITEM\n-            let unsafety = self.parse_unsafety();\n-            let info = self.parse_item_trait(lo, unsafety)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Impl)\n+            self.recover_const_mut(const_span);\n+            self.parse_item_const(None)?\n+        } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n+            // TRAIT ITEM\n+            self.parse_item_trait(attrs, lo)?\n+        } else if self.check_keyword(kw::Impl)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n             || self.check_keyword(kw::Default) && self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n         {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let info = self.parse_item_impl(unsafety, defaultness)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Mod) {\n+            self.parse_item_impl(attrs, unsafety, defaultness)?\n+        } else if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let info = self.parse_item_mod(&attrs[..])?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Type) {\n+            self.parse_item_mod(attrs)?\n+        } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n             let (ident, ty, generics) = self.parse_type_alias()?;\n-            let kind = ItemKind::TyAlias(ty, generics);\n-            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n-        }\n-\n-        if self.eat_keyword(kw::Enum) {\n+            (ident, ItemKind::TyAlias(ty, generics))\n+        } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n-            let info = self.parse_item_enum()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Trait)\n-            || (self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait]))\n-        {\n-            // TRAIT ITEM\n-            let info = self.parse_item_trait(lo, Unsafe::No)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Struct) {\n+            self.parse_item_enum()?\n+        } else if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n-            let info = self.parse_item_struct()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.is_union_item() {\n+            self.parse_item_struct()?\n+        } else if self.is_kw_followed_by_ident(kw::Union) {\n             // UNION ITEM\n-            self.bump();\n-            let info = self.parse_item_union()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n+            self.bump(); // `union`\n+            self.parse_item_union()?\n+        } else if self.eat_keyword(kw::Macro) {\n+            // MACROS 2.0 ITEM\n+            self.parse_item_decl_macro(lo)?\n+        } else if self.is_macro_rules_item() {\n+            // MACRO_RULES ITEM\n+            self.parse_item_macro_rules(vis)?\n+        } else if vis.node.is_pub() && self.isnt_macro_invocation() {\n+            self.recover_missing_kw_before_item()?;\n+            return Ok(None);\n+        } else if macros_allowed && self.token.is_path_start() {\n+            // MACRO INVOCATION ITEM\n+            (Ident::invalid(), ItemKind::Mac(self.parse_item_macro(vis)?))\n+        } else {\n+            return Ok(None);\n+        };\n+        Ok(Some(info))\n+    }\n \n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &vis, lo)? {\n-            return Ok(Some(macro_def));\n-        }\n+    /// When parsing a statement, would the start of a path be an item?\n+    pub(super) fn is_path_start_item(&mut self) -> bool {\n+        self.is_crate_vis() // no: `crate::b`, yes: `crate $item`\n+        || self.is_kw_followed_by_ident(kw::Union) // no: `union::b`, yes: `union U { .. }`\n+        || self.check_auto_or_unsafe_trait_item() // no: `auto::b`, yes: `auto trait X { .. }`\n+        || self.is_async_fn() // no(2015): `async::b`, yes: `async fn`\n+        || self.is_macro_rules_item() // no: `macro_rules::b`, yes: `macro_rules! mac`\n+    }\n \n-        // Verify whether we have encountered a struct or method definition where the user forgot to\n-        // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if vis.node.is_pub() && self.check_ident() && self.look_ahead(1, |t| *t != token::Not) {\n-            // Space between `pub` keyword and the identifier\n-            //\n-            //     pub   S {}\n-            //        ^^^ `sp` points here\n-            let sp = self.prev_span.between(self.token.span);\n-            let full_sp = self.prev_span.to(self.token.span);\n-            let ident_sp = self.token.span;\n-            if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n-                // possible public struct definition where `struct` was forgotten\n-                let ident = self.parse_ident().unwrap();\n-                let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n-                let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n+    /// Are we sure this could not possibly be a macro invocation?\n+    fn isnt_macro_invocation(&mut self) -> bool {\n+        self.check_ident() && self.look_ahead(1, |t| *t != token::Not && *t != token::ModSep)\n+    }\n+\n+    /// Recover on encountering a struct or method definition where the user\n+    /// forgot to add the `struct` or `fn` keyword after writing `pub`: `pub S {}`.\n+    fn recover_missing_kw_before_item(&mut self) -> PResult<'a, ()> {\n+        // Space between `pub` keyword and the identifier\n+        //\n+        //     pub   S {}\n+        //        ^^^ `sp` points here\n+        let sp = self.prev_span.between(self.token.span);\n+        let full_sp = self.prev_span.to(self.token.span);\n+        let ident_sp = self.token.span;\n+        if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n+            // possible public struct definition where `struct` was forgotten\n+            let ident = self.parse_ident().unwrap();\n+            let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n+            let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n+            err.span_suggestion_short(\n+                sp,\n+                &msg,\n+                \" struct \".into(),\n+                Applicability::MaybeIncorrect, // speculative\n+            );\n+            return Err(err);\n+        } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n+            let ident = self.parse_ident().unwrap();\n+            self.bump(); // `(`\n+            let kw_name = self.recover_first_param();\n+            self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n+            let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+                self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n+                self.bump(); // `{`\n+                (\"fn\", kw_name, false)\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                self.bump(); // `{`\n+                (\"fn\", kw_name, false)\n+            } else if self.check(&token::Colon) {\n+                let kw = \"struct\";\n+                (kw, kw, false)\n+            } else {\n+                (\"fn` or `struct\", \"function or struct\", true)\n+            };\n+\n+            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let mut err = self.struct_span_err(sp, &msg);\n+            if !ambiguous {\n+                self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                let suggestion =\n+                    format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n                 err.span_suggestion_short(\n                     sp,\n-                    &msg,\n-                    \" struct \".into(),\n-                    Applicability::MaybeIncorrect, // speculative\n+                    &suggestion,\n+                    format!(\" {} \", kw),\n+                    Applicability::MachineApplicable,\n                 );\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n-                let ident = self.parse_ident().unwrap();\n-                self.bump(); // `(`\n-                let kw_name = self.recover_first_param();\n-                self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n-                let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n-                    self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n-                    self.bump(); // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.bump(); // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::Colon) {\n-                    let kw = \"struct\";\n-                    (kw, kw, false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n-                    let suggestion =\n-                        format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &suggestion,\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n+            } else {\n+                if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                    err.span_suggestion(\n+                        full_sp,\n+                        \"if you meant to call a macro, try\",\n+                        format!(\"{}!\", snippet),\n+                        // this is the `ambiguous` conditional branch\n+                        Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                        err.span_suggestion(\n-                            full_sp,\n-                            \"if you meant to call a macro, try\",\n-                            format!(\"{}!\", snippet),\n-                            // this is the `ambiguous` conditional branch\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        err.help(\n-                            \"if you meant to call a macro, remove the `pub` \\\n+                    err.help(\n+                        \"if you meant to call a macro, remove the `pub` \\\n                                   and add a trailing `!` after the identifier\",\n-                        );\n-                    }\n-                }\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::Lt) {\n-                let ident = self.parse_ident().unwrap();\n-                self.eat_to_tokens(&[&token::Gt]);\n-                self.bump(); // `>`\n-                let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n-                    (\"fn\", self.recover_first_param(), false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    (\"struct\", \"struct\", false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n                     );\n                 }\n-                return Err(err);\n             }\n-        }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n-    }\n-\n-    pub(super) fn mk_item_with_info(\n-        &self,\n-        attrs: Vec<Attribute>,\n-        lo: Span,\n-        vis: Visibility,\n-        info: ItemInfo,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, item, extra_attrs) = info;\n-        let span = lo.to(self.prev_span);\n-        let attrs = Self::maybe_append(attrs, extra_attrs);\n-        Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n-    }\n-\n-    fn maybe_append<T>(mut lhs: Vec<T>, mut rhs: Option<Vec<T>>) -> Vec<T> {\n-        if let Some(ref mut rhs) = rhs {\n-            lhs.append(rhs);\n-        }\n-        lhs\n-    }\n-\n-    /// This is the fall-through for parsing items.\n-    fn parse_macro_use_or_failure(\n-        &mut self,\n-        attrs: Vec<Attribute>,\n-        macros_allowed: bool,\n-        attributes_allowed: bool,\n-        lo: Span,\n-        visibility: Visibility,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        if macros_allowed\n-            && self.token.is_path_start()\n-            && !(self.is_async_fn() && self.token.span.rust_2015())\n-        {\n-            // MACRO INVOCATION ITEM\n-\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&visibility.node, prev_span);\n-\n-            // Item macro\n-            let path = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n-            let args = self.parse_mac_args()?;\n-            if args.need_semicolon() && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n+            return Err(err);\n+        } else if self.look_ahead(1, |t| *t == token::Lt) {\n+            let ident = self.parse_ident().unwrap();\n+            self.eat_to_tokens(&[&token::Gt]);\n+            self.bump(); // `>`\n+            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n+                (\"fn\", self.recover_first_param(), false)\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                (\"struct\", \"struct\", false)\n+            } else {\n+                (\"fn` or `struct\", \"function or struct\", true)\n+            };\n+            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let mut err = self.struct_span_err(sp, &msg);\n+            if !ambiguous {\n+                err.span_suggestion_short(\n+                    sp,\n+                    &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                    format!(\" {} \", kw),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n-\n-            let hi = self.prev_span;\n-            let mac = Mac { path, args, prior_type_ascription: self.last_type_ascription };\n-            let item =\n-                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n-            return Ok(Some(item));\n-        }\n-\n-        // FAILURE TO PARSE ITEM\n-        match visibility.node {\n-            VisibilityKind::Inherited => {}\n-            _ => return Err(self.struct_span_err(self.prev_span, \"unmatched visibility `pub`\")),\n+            return Err(err);\n+        } else {\n+            Ok(())\n         }\n+    }\n \n-        if !attributes_allowed && !attrs.is_empty() {\n-            self.expected_item_err(&attrs)?;\n-        }\n-        Ok(None)\n+    /// Parses an item macro, e.g., `item!();`.\n+    fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, Mac> {\n+        let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`\n+        self.expect(&token::Not)?; // `!`\n+        let args = self.parse_mac_args()?; // `( .. )` or `[ .. ]` (followed by `;`), or `{ .. }`.\n+        self.eat_semi_for_macro_if_needed(&args);\n+        self.complain_if_pub_macro(vis, false);\n+        Ok(Mac { path, args, prior_type_ascription: self.last_type_ascription })\n     }\n \n-    /// Emits an expected-item-after-attributes error.\n-    fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n-        let message = match attrs.last() {\n-            Some(&Attribute { kind: AttrKind::DocComment(_), .. }) => {\n-                \"expected item after doc comment\"\n-            }\n-            _ => \"expected item after attributes\",\n+    /// Recover if we parsed attributes and expected an item but there was none.\n+    fn recover_attrs_no_item(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n+        let (start, end) = match attrs {\n+            [] => return Ok(()),\n+            [x0] => (x0, x0),\n+            [x0, .., xn] => (x0, xn),\n         };\n-\n-        let mut err = self.struct_span_err(self.prev_span, message);\n-        if attrs.last().unwrap().is_doc_comment() {\n-            err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n+        let msg = if end.is_doc_comment() {\n+            \"expected item after doc comment\"\n+        } else {\n+            \"expected item after attributes\"\n+        };\n+        let mut err = self.struct_span_err(end.span, msg);\n+        if end.is_doc_comment() {\n+            err.span_label(end.span, \"this doc comment doesn't document anything\");\n+        }\n+        if let [.., penultimate, _] = attrs {\n+            err.span_label(start.span.to(penultimate.span), \"other attributes here\");\n         }\n         Err(err)\n     }\n \n-    pub(super) fn is_async_fn(&self) -> bool {\n+    fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) && self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n-    /// Parses a macro invocation inside a `trait`, `impl` or `extern` block.\n-    fn parse_assoc_macro_invoc(\n-        &mut self,\n-        item_kind: &str,\n-        vis: Option<&Visibility>,\n-        at_end: &mut bool,\n-    ) -> PResult<'a, Option<Mac>> {\n-        if self.token.is_path_start() && !(self.is_async_fn() && self.token.span.rust_2015()) {\n-            let prev_span = self.prev_span;\n-            let path = self.parse_path(PathStyle::Mod)?;\n-\n-            if path.segments.len() == 1 {\n-                if !self.eat(&token::Not) {\n-                    return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n-                }\n-            } else {\n-                self.expect(&token::Not)?;\n-            }\n-\n-            if let Some(vis) = vis {\n-                self.complain_if_pub_macro(&vis.node, prev_span);\n-            }\n-\n-            *at_end = true;\n-\n-            // eat a matched-delimiter token tree:\n-            let args = self.parse_mac_args()?;\n-            if args.need_semicolon() {\n-                self.expect_semi()?;\n-            }\n-\n-            Ok(Some(Mac { path, args, prior_type_ascription: self.last_type_ascription }))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n     fn missing_assoc_item_kind_err(\n         &self,\n         item_type: &str,\n@@ -442,7 +353,7 @@ impl<'a> Parser<'a> {\n         //   |        ^ missing `fn`, `type`, or `const`\n         //     pub  path(\n         //        ^^ `sp` below will point to this\n-        let sp = prev_span.between(self.prev_span);\n+        let sp = prev_span.between(self.token.span);\n         let mut err = self\n             .struct_span_err(sp, &format!(\"{} for {}-item declaration\", expected_kinds, item_type));\n         err.span_label(sp, expected_kinds);\n@@ -451,16 +362,21 @@ impl<'a> Parser<'a> {\n \n     /// Parses an implementation item, `impl` keyword is already parsed.\n     ///\n-    ///    impl<'a, T> TYPE { /* impl items */ }\n-    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n+    /// ```\n+    /// impl<'a, T> TYPE { /* impl items */ }\n+    /// impl<'a, T> TRAIT for TYPE { /* impl items */ }\n+    /// impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    /// impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n+    /// ```\n     ///\n     /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n-    ///   `impl` GENERICS `const`? `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n-    ///   `impl` GENERICS `const`? `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    /// ```\n+    /// \"impl\" GENERICS \"const\"? \"!\"? TYPE \"for\"? (TYPE | \"..\") (\"where\" PREDICATES)? \"{\" BODY \"}\"\n+    /// \"impl\" GENERICS \"const\"? \"!\"? TYPE (\"where\" PREDICATES)? \"{\" BODY \"}\"\n+    /// ```\n     fn parse_item_impl(\n         &mut self,\n+        attrs: &mut Vec<Attribute>,\n         unsafety: Unsafe,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n@@ -515,7 +431,7 @@ impl<'a> Parser<'a> {\n \n         generics.where_clause = self.parse_where_clause()?;\n \n-        let (impl_items, attrs) = self.parse_impl_body()?;\n+        let impl_items = self.parse_item_list(attrs, |p, at_end| p.parse_impl_item(at_end))?;\n \n         let item_kind = match ty_second {\n             Some(ty_second) => {\n@@ -568,18 +484,25 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok((Ident::invalid(), item_kind, Some(attrs)))\n+        Ok((Ident::invalid(), item_kind))\n     }\n \n-    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<P<AssocItem>>, Vec<Attribute>)> {\n+    fn parse_item_list<T>(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        mut parse_item: impl FnMut(&mut Parser<'a>, &mut bool) -> PResult<'a, T>,\n+    ) -> PResult<'a, Vec<T>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n-        let attrs = self.parse_inner_attributes()?;\n+        attrs.append(&mut self.parse_inner_attributes()?);\n \n-        let mut impl_items = Vec::new();\n+        let mut items = Vec::new();\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n+            if self.recover_doc_comment_before_brace() {\n+                continue;\n+            }\n             let mut at_end = false;\n-            match self.parse_impl_item(&mut at_end) {\n-                Ok(impl_item) => impl_items.push(impl_item),\n+            match parse_item(self, &mut at_end) {\n+                Ok(item) => items.push(item),\n                 Err(mut err) => {\n                     err.emit();\n                     if !at_end {\n@@ -589,7 +512,30 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         }\n-        Ok((impl_items, attrs))\n+        Ok(items)\n+    }\n+\n+    /// Recover on a doc comment before `}`.\n+    fn recover_doc_comment_before_brace(&mut self) -> bool {\n+        if let token::DocComment(_) = self.token.kind {\n+            if self.look_ahead(1, |tok| tok == &token::CloseDelim(token::Brace)) {\n+                struct_span_err!(\n+                    self.diagnostic(),\n+                    self.token.span,\n+                    E0584,\n+                    \"found a documentation comment that doesn't document anything\",\n+                )\n+                .span_label(self.token.span, \"this doc comment doesn't document anything\")\n+                .help(\n+                    \"doc comments must come before what they document, maybe a \\\n+                    comment was intended with `//`?\",\n+                )\n+                .emit();\n+                self.bump();\n+                return true;\n+            }\n+        }\n+        false\n     }\n \n     /// Parses defaultness (i.e., `default` or nothing).\n@@ -617,8 +563,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, lo: Span, unsafety: Unsafe) -> PResult<'a, ItemInfo> {\n+    /// Is this an `(unsafe auto? | auto) trait` item?\n+    fn check_auto_or_unsafe_trait_item(&mut self) -> bool {\n+        // auto trait\n+        self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait])\n+            // unsafe auto trait\n+            || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n+    }\n+\n+    /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, attrs: &mut Vec<Attribute>, lo: Span) -> PResult<'a, ItemInfo> {\n+        let unsafety = self.parse_unsafety();\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -656,43 +611,12 @@ impl<'a> Parser<'a> {\n \n             self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n-            Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n+            Ok((ident, ItemKind::TraitAlias(tps, bounds)))\n         } else {\n             // It's a normal trait.\n             tps.where_clause = self.parse_where_clause()?;\n-            self.expect(&token::OpenDelim(token::Brace))?;\n-            let mut trait_items = vec![];\n-            while !self.eat(&token::CloseDelim(token::Brace)) {\n-                if let token::DocComment(_) = self.token.kind {\n-                    if self.look_ahead(1, |tok| tok == &token::CloseDelim(token::Brace)) {\n-                        struct_span_err!(\n-                            self.diagnostic(),\n-                            self.token.span,\n-                            E0584,\n-                            \"found a documentation comment that doesn't document anything\",\n-                        )\n-                        .help(\n-                            \"doc comments must come before what they document, maybe a \\\n-                            comment was intended with `//`?\",\n-                        )\n-                        .emit();\n-                        self.bump();\n-                        continue;\n-                    }\n-                }\n-                let mut at_end = false;\n-                match self.parse_trait_item(&mut at_end) {\n-                    Ok(item) => trait_items.push(item),\n-                    Err(mut e) => {\n-                        e.emit();\n-                        if !at_end {\n-                            self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, trait_items), None))\n+            let items = self.parse_item_list(attrs, |p, at_end| p.parse_trait_item(at_end))?;\n+            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, items)))\n         }\n     }\n \n@@ -740,28 +664,28 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n-        let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n+\n+        let (ident, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_assoc_ty()?\n         } else if self.check_fn_front_matter() {\n             let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, req_name)?;\n             (ident, AssocItemKind::Fn(sig, body), generics)\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"associated\", Some(&vis), at_end)? {\n+        } else if self.check_keyword(kw::Const) {\n+            self.parse_assoc_const()?\n+        } else if self.isnt_macro_invocation() {\n+            return Err(self.missing_assoc_item_kind_err(\"associated\", self.prev_span));\n+        } else if self.token.is_path_start() {\n+            let mac = self.parse_item_macro(&vis)?;\n+            *at_end = true;\n             (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n         } else {\n-            self.parse_assoc_const()?\n+            self.recover_attrs_no_item(&attrs)?;\n+            self.unexpected()?\n         };\n \n-        Ok(AssocItem {\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(self.prev_span),\n-            ident: name,\n-            attrs,\n-            vis,\n-            defaultness,\n-            generics,\n-            kind,\n-            tokens: None,\n-        })\n+        let span = lo.to(self.prev_span);\n+        let id = DUMMY_NODE_ID;\n+        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, generics, kind, tokens: None })\n     }\n \n     /// This parses the grammar:\n@@ -860,7 +784,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n-            token::Ident(name, false) if name == kw::Underscore => {\n+            token::Ident(name @ kw::Underscore, false) => {\n                 let span = self.token.span;\n                 self.bump();\n                 Ok(Ident::new(name, span))\n@@ -877,12 +801,7 @@ impl<'a> Parser<'a> {\n     /// extern crate foo;\n     /// extern crate bar as foo;\n     /// ```\n-    fn parse_item_extern_crate(\n-        &mut self,\n-        lo: Span,\n-        visibility: Visibility,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<Item>> {\n+    fn parse_item_extern_crate(&mut self) -> PResult<'a, ItemInfo> {\n         // Accept `extern crate name-like-this` for better diagnostics\n         let orig_name = self.parse_crate_name_with_dashes()?;\n         let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n@@ -891,9 +810,7 @@ impl<'a> Parser<'a> {\n             (orig_name, None)\n         };\n         self.expect_semi()?;\n-\n-        let span = lo.to(self.prev_span);\n-        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n+        Ok((item_name, ItemKind::ExternCrate(orig_name)))\n     }\n \n     fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n@@ -936,66 +853,40 @@ impl<'a> Parser<'a> {\n \n     /// Parses `extern` for foreign ABIs modules.\n     ///\n-    /// `extern` is expected to have been\n-    /// consumed before calling this method.\n+    /// `extern` is expected to have been consumed before calling this method.\n     ///\n     /// # Examples\n     ///\n     /// ```ignore (only-for-syntax-highlight)\n     /// extern \"C\" {}\n     /// extern {}\n     /// ```\n-    fn parse_item_foreign_mod(\n-        &mut self,\n-        lo: Span,\n-        abi: Option<StrLit>,\n-        visibility: Visibility,\n-        mut attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<Item>> {\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        attrs.extend(self.parse_inner_attributes()?);\n-\n-        let mut foreign_items = vec![];\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n-            foreign_items.push(self.parse_foreign_item()?);\n-        }\n-\n-        let prev_span = self.prev_span;\n-        let m = ast::ForeignMod { abi, items: foreign_items };\n-        let invalid = Ident::invalid();\n-        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n+    fn parse_item_foreign_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let abi = self.parse_abi(); // ABI?\n+        let items = self.parse_item_list(attrs, |p, at_end| p.parse_foreign_item(at_end))?;\n+        let module = ast::ForeignMod { abi, items };\n+        Ok((Ident::invalid(), ItemKind::ForeignMod(module)))\n     }\n \n-    /// Parses a foreign item.\n-    pub fn parse_foreign_item(&mut self) -> PResult<'a, P<ForeignItem>> {\n+    /// Parses a foreign item (one in an `extern { ... }` block).\n+    pub fn parse_foreign_item(&mut self, at_end: &mut bool) -> PResult<'a, P<ForeignItem>> {\n         maybe_whole!(self, NtForeignItem, |ni| ni);\n \n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if self.check_keyword(kw::Type) {\n+        let (ident, kind) = if self.check_keyword(kw::Type) {\n             // FOREIGN TYPE ITEM\n-            self.parse_item_foreign_type(vis, lo, attrs)\n+            self.parse_item_foreign_type()?\n         } else if self.check_fn_front_matter() {\n             // FOREIGN FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n-            let kind = ForeignItemKind::Fn(sig, generics, body);\n-            let span = lo.to(self.prev_span);\n-            Ok(P(ast::ForeignItem {\n-                ident,\n-                attrs,\n-                kind,\n-                id: DUMMY_NODE_ID,\n-                span,\n-                vis,\n-                tokens: None,\n-            }))\n+            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, |_| true)?;\n+            (ident, ForeignItemKind::Fn(sig, generics, body))\n         } else if self.is_static_global() {\n             // FOREIGN STATIC ITEM\n             self.bump(); // `static`\n-            self.parse_item_foreign_static(vis, lo, attrs)\n+            self.parse_item_foreign_static()?\n         } else if self.token.is_keyword(kw::Const) {\n             // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n             self.bump(); // `const`\n@@ -1007,66 +898,37 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n-            self.parse_item_foreign_static(vis, lo, attrs)\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"extern\", Some(&vis), &mut false)? {\n-            let kind = ForeignItemKind::Macro(mac);\n-            let span = lo.to(self.prev_span);\n-            let ident = Ident::invalid();\n-            Ok(P(ForeignItem { ident, span, id: DUMMY_NODE_ID, attrs, vis, kind, tokens: None }))\n+            self.parse_item_foreign_static()?\n+        } else if self.isnt_macro_invocation() {\n+            return Err(self.missing_assoc_item_kind_err(\"extern\", self.prev_span));\n+        } else if self.token.is_path_start() {\n+            let mac = self.parse_item_macro(&vis)?;\n+            *at_end = true;\n+            (Ident::invalid(), ForeignItemKind::Macro(mac))\n         } else {\n-            if !attrs.is_empty() {\n-                self.expected_item_err(&attrs)?;\n-            }\n-            self.unexpected()\n-        }\n+            self.recover_attrs_no_item(&attrs)?;\n+            self.unexpected()?\n+        };\n+        Ok(P(self.mk_item(lo, ident, kind, vis, attrs)))\n     }\n \n     /// Parses a static item from a foreign module.\n     /// Assumes that the `static` keyword is already parsed.\n-    fn parse_item_foreign_static(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<ForeignItem>> {\n+    fn parse_item_foreign_static(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n         let mutbl = self.parse_mutability();\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let hi = self.token.span;\n         self.expect_semi()?;\n-        Ok(P(ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Static(ty, mutbl),\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-            tokens: None,\n-        }))\n+        Ok((ident, ForeignItemKind::Static(ty, mutbl)))\n     }\n \n     /// Parses a type from a foreign module.\n-    fn parse_item_foreign_type(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<ForeignItem>> {\n+    fn parse_item_foreign_type(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n         self.expect_keyword(kw::Type)?;\n-\n         let ident = self.parse_ident()?;\n-        let hi = self.token.span;\n         self.expect_semi()?;\n-        Ok(P(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Ty,\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-            tokens: None,\n-        }))\n+        Ok((ident, ForeignItemKind::Ty))\n     }\n \n     fn is_static_global(&mut self) -> bool {\n@@ -1086,6 +948,22 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Recover on `const mut` with `const` already eaten.\n+    fn recover_const_mut(&mut self, const_span: Span) {\n+        if self.eat_keyword(kw::Mut) {\n+            let span = self.prev_span;\n+            self.struct_span_err(span, \"const globals cannot be mutable\")\n+                .span_label(span, \"cannot be mutable\")\n+                .span_suggestion(\n+                    const_span,\n+                    \"you might want to declare a static instead\",\n+                    \"static\".to_owned(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n+    }\n+\n     /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty = $expr` with\n     /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n     ///\n@@ -1110,7 +988,7 @@ impl<'a> Parser<'a> {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),\n         };\n-        Ok((id, item, None))\n+        Ok((id, item))\n     }\n \n     /// We were supposed to parse `:` but instead, we're already at `=`.\n@@ -1163,7 +1041,7 @@ impl<'a> Parser<'a> {\n \n         let enum_definition =\n             EnumDef { variants: variants.into_iter().filter_map(|v| v).collect() };\n-        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n+        Ok((id, ItemKind::Enum(enum_definition, generics)))\n     }\n \n     fn parse_enum_variant(&mut self) -> PResult<'a, Option<Variant>> {\n@@ -1257,7 +1135,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n+        Ok((class_name, ItemKind::Struct(vdata, generics)))\n     }\n \n     /// Parses `union Foo { ... }`.\n@@ -1281,12 +1159,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        Ok((class_name, ItemKind::Union(vdata, generics), None))\n-    }\n-\n-    pub(super) fn is_union_item(&self) -> bool {\n-        self.token.is_keyword(kw::Union)\n-            && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+        Ok((class_name, ItemKind::Union(vdata, generics)))\n     }\n \n     fn parse_record_struct_body(\n@@ -1436,112 +1309,109 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub(super) fn eat_macro_def(\n-        &mut self,\n-        attrs: &[Attribute],\n-        vis: &Visibility,\n-        lo: Span,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, def) = if self.eat_keyword(kw::Macro) {\n-            let ident = self.parse_ident()?;\n-            let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                self.parse_mac_args()?\n-            } else if self.check(&token::OpenDelim(token::Paren)) {\n-                let params = self.parse_token_tree();\n-                let pspan = params.span();\n-                let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_token_tree()\n-                } else {\n-                    return self.unexpected();\n-                };\n-                let bspan = body.span();\n-                let tokens = TokenStream::new(vec![\n-                    params.into(),\n-                    TokenTree::token(token::FatArrow, pspan.between(bspan)).into(),\n-                    body.into(),\n-                ]);\n-                let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n-                P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n-            } else {\n+    /// Parses a declarative macro 2.0 definition.\n+    /// The `macro` keyword has already been parsed.\n+    /// ```\n+    /// MacBody = \"{\" TOKEN_STREAM \"}\" ;\n+    /// MacParams = \"(\" TOKEN_STREAM \")\" ;\n+    /// DeclMac = \"macro\" Ident MacParams? MacBody ;\n+    /// ```\n+    fn parse_item_decl_macro(&mut self, lo: Span) -> PResult<'a, ItemInfo> {\n+        let ident = self.parse_ident()?;\n+        let body = if self.check(&token::OpenDelim(token::Brace)) {\n+            self.parse_mac_args()? // `MacBody`\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            let params = self.parse_token_tree(); // `MacParams`\n+            let pspan = params.span();\n+            if !self.check(&token::OpenDelim(token::Brace)) {\n                 return self.unexpected();\n-            };\n+            }\n+            let body = self.parse_token_tree(); // `MacBody`\n+            // Convert `MacParams MacBody` into `{ MacParams => MacBody }`.\n+            let bspan = body.span();\n+            let arrow = TokenTree::token(token::FatArrow, pspan.between(bspan)); // `=>`\n+            let tokens = TokenStream::new(vec![params.into(), arrow.into(), body.into()]);\n+            let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n+            P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n+        } else {\n+            return self.unexpected();\n+        };\n+\n+        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_span));\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n+    }\n \n-            (ident, ast::MacroDef { body, legacy: false })\n-        } else if self.check_keyword(sym::macro_rules)\n+    /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n+    fn is_macro_rules_item(&mut self) -> bool {\n+        self.check_keyword(sym::macro_rules)\n             && self.look_ahead(1, |t| *t == token::Not)\n             && self.look_ahead(2, |t| t.is_ident())\n-        {\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&vis.node, prev_span);\n-            self.bump();\n-            self.bump();\n-\n-            let ident = self.parse_ident()?;\n-            let body = self.parse_mac_args()?;\n-            if body.need_semicolon() && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n-            }\n+    }\n \n-            (ident, ast::MacroDef { body, legacy: true })\n-        } else {\n-            return Ok(None);\n-        };\n+    /// Parses a legacy `macro_rules! foo { ... }` declarative macro.\n+    fn parse_item_macro_rules(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n+        self.expect_keyword(sym::macro_rules)?; // `macro_rules`\n+        self.expect(&token::Not)?; // `!`\n \n-        let span = lo.to(self.prev_span);\n+        let ident = self.parse_ident()?;\n+        let body = self.parse_mac_args()?;\n+        self.eat_semi_for_macro_if_needed(&body);\n+        self.complain_if_pub_macro(vis, true);\n+\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true })))\n+    }\n \n-        if !def.legacy {\n-            self.sess.gated_spans.gate(sym::decl_macro, span);\n+    /// Item macro invocations or `macro_rules!` definitions need inherited visibility.\n+    /// If that's not the case, emit an error.\n+    fn complain_if_pub_macro(&self, vis: &Visibility, macro_rules: bool) {\n+        if let VisibilityKind::Inherited = vis.node {\n+            return;\n         }\n \n-        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n+        let vstr = pprust::vis_to_string(vis);\n+        let vstr = vstr.trim_end();\n+        if macro_rules {\n+            let msg = format!(\"can't qualify macro_rules invocation with `{}`\", vstr);\n+            self.struct_span_err(vis.span, &msg)\n+                .span_suggestion(\n+                    vis.span,\n+                    \"try exporting the macro\",\n+                    \"#[macro_export]\".to_owned(),\n+                    Applicability::MaybeIncorrect, // speculative\n+                )\n+                .emit();\n+        } else {\n+            self.struct_span_err(vis.span, \"can't qualify macro invocation with `pub`\")\n+                .span_suggestion(\n+                    vis.span,\n+                    \"remove the visibility\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .help(&format!(\"try adjusting the macro to put `{}` inside the invocation\", vstr))\n+                .emit();\n+        }\n     }\n \n-    fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n-        match *vis {\n-            VisibilityKind::Inherited => {}\n-            _ => {\n-                let mut err = if self.token.is_keyword(sym::macro_rules) {\n-                    let mut err =\n-                        self.struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n-                    err.span_suggestion(\n-                        sp,\n-                        \"try exporting the macro\",\n-                        \"#[macro_export]\".to_owned(),\n-                        Applicability::MaybeIncorrect, // speculative\n-                    );\n-                    err\n-                } else {\n-                    let mut err =\n-                        self.struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n-                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n-                    err\n-                };\n-                err.emit();\n-            }\n+    fn eat_semi_for_macro_if_needed(&mut self, args: &MacArgs) {\n+        if args.need_semicolon() && !self.eat(&token::Semi) {\n+            self.report_invalid_macro_expansion_item(args);\n         }\n     }\n \n-    fn report_invalid_macro_expansion_item(&self) {\n-        let has_close_delim = self\n-            .sess\n-            .source_map()\n-            .span_to_snippet(self.prev_span)\n-            .map(|s| s.ends_with(\")\") || s.ends_with(\"]\"))\n-            .unwrap_or(false);\n-\n+    fn report_invalid_macro_expansion_item(&self, args: &MacArgs) {\n         let mut err = self.struct_span_err(\n             self.prev_span,\n             \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n         );\n-\n-        // To avoid ICE, we shouldn't emit actual suggestions when it hasn't closing delims\n-        if has_close_delim {\n+        if self.unclosed_delims.is_empty() {\n+            let DelimSpan { open, close } = match args {\n+                MacArgs::Empty | MacArgs::Eq(..) => unreachable!(),\n+                MacArgs::Delimited(dspan, ..) => *dspan,\n+            };\n             err.multipart_suggestion(\n                 \"change the delimiters to curly braces\",\n-                vec![\n-                    (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), '{'.to_string()),\n-                    (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n-                ],\n+                vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n                 Applicability::MaybeIncorrect,\n             );\n         } else {\n@@ -1552,14 +1422,13 @@ impl<'a> Parser<'a> {\n                 Applicability::HasPlaceholders,\n             );\n         }\n-\n         err.span_suggestion(\n             self.prev_span.shrink_to_hi(),\n             \"add a semicolon\",\n             ';'.to_string(),\n             Applicability::MaybeIncorrect,\n-        )\n-        .emit();\n+        );\n+        err.emit();\n     }\n \n     /// Checks if current token is one of tokens which cannot be nested like `kw::Enum`. In case\n@@ -1591,15 +1460,16 @@ impl<'a> Parser<'a> {\n         Ok(true)\n     }\n \n-    fn mk_item(\n+    fn mk_item<K>(\n         &self,\n-        span: Span,\n+        lo: Span,\n         ident: Ident,\n-        kind: ItemKind,\n+        kind: K,\n         vis: Visibility,\n         attrs: Vec<Attribute>,\n-    ) -> P<Item> {\n-        P(Item { ident, attrs, id: DUMMY_NODE_ID, kind, vis, span, tokens: None })\n+    ) -> Item<K> {\n+        let span = lo.to(self.prev_span);\n+        Item { ident, attrs, id: DUMMY_NODE_ID, kind, vis, span, tokens: None }\n     }\n }\n "}, {"sha": "79944dc35e523f358ce672b6125d84bdedafdbfd", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -572,6 +572,11 @@ impl<'a> Parser<'a> {\n         if !self.eat_keyword(kw) { self.unexpected() } else { Ok(()) }\n     }\n \n+    /// Is the given keyword `kw` followed by a non-reserved identifier?\n+    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n+        self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+    }\n+\n     fn check_or_expected(&mut self, ok: bool, typ: TokenType) -> bool {\n         if ok {\n             true"}, {"sha": "754923ae55e29683494143a914bcbf3086b15af2", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -40,36 +40,34 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n-    pub(super) fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n-        let (in_cfg, outer_attrs) =\n-            crate::config::process_configure_mod(self.sess, self.cfg_mods, outer_attrs);\n+    pub(super) fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let in_cfg = crate::config::process_configure_mod(self.sess, self.cfg_mods, attrs);\n \n         let id_span = self.token.span;\n         let id = self.parse_ident()?;\n-        if self.eat(&token::Semi) {\n+        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n             if in_cfg && self.recurse_into_file_modules {\n                 // This mod is in an external file. Let's go get it!\n                 let ModulePathSuccess { path, directory_ownership } =\n-                    self.submod_path(id, &outer_attrs, id_span)?;\n-                let (module, attrs) =\n-                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n-                Ok((id, ItemKind::Mod(module), Some(attrs)))\n+                    self.submod_path(id, &attrs, id_span)?;\n+                self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?\n             } else {\n-                let placeholder = ast::Mod { inner: DUMMY_SP, items: Vec::new(), inline: false };\n-                Ok((id, ItemKind::Mod(placeholder), None))\n+                (ast::Mod { inner: DUMMY_SP, items: Vec::new(), inline: false }, Vec::new())\n             }\n         } else {\n             let old_directory = self.directory.clone();\n-            self.push_directory(id, &outer_attrs);\n+            self.push_directory(id, &attrs);\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.token.span;\n-            let attrs = self.parse_inner_attributes()?;\n+            let inner_attrs = self.parse_inner_attributes()?;\n             let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n \n             self.directory = old_directory;\n-            Ok((id, ItemKind::Mod(module), Some(attrs)))\n-        }\n+            (module, inner_attrs)\n+        };\n+        attrs.append(&mut inner_attrs);\n+        Ok((id, ItemKind::Mod(module)))\n     }\n \n     /// Given a termination token, parses all of the items in a module."}, {"sha": "742fc4802fd9d6db0cb0f7fdfc982f0efd3bd8fa", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -7,10 +7,10 @@ use crate::maybe_whole;\n use crate::DirectoryOwnership;\n \n use rustc_errors::{Applicability, PResult};\n-use rustc_span::source_map::{respan, BytePos, Span};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::source_map::{BytePos, Span};\n+use rustc_span::symbol::{kw, sym};\n use syntax::ast;\n-use syntax::ast::{AttrStyle, AttrVec, Attribute, Mac, MacStmtStyle, VisibilityKind};\n+use syntax::ast::{AttrStyle, AttrVec, Attribute, Mac, MacStmtStyle};\n use syntax::ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n use syntax::ptr::P;\n use syntax::token::{self, TokenKind};\n@@ -55,21 +55,11 @@ impl<'a> Parser<'a> {\n             return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n         }\n \n-        let mac_vis = respan(lo, VisibilityKind::Inherited);\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &mac_vis, lo)? {\n-            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))));\n-        }\n-\n-        // Starts like a simple path, being careful to avoid contextual keywords\n-        // such as a union items, item with `crate` visibility or auto trait items.\n-        // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n-        // like a path (1 token), but it fact not a path.\n-        if self.token.is_path_start()\n-            && !self.token.is_qpath_start()\n-            && !self.is_union_item() // `union::b::c` - path, `union U { ... }` - not a path.\n-            && !self.is_crate_vis() // `crate::b::c` - path, `crate struct S;` - not a path.\n-            && !self.is_auto_trait_item()\n-            && !self.is_async_fn()\n+        // Starts like a simple path, being careful to avoid contextual keywords,\n+        // e.g., `union`, items with `crate` visibility, or `auto trait` items.\n+        // We aim to parse an arbitrary path `a::b` but not something that starts like a path\n+        // (1 token), but it fact not a path. Also, we avoid stealing syntax from `parse_item_`.\n+        if self.token.is_path_start() && !self.token.is_qpath_start() && !self.is_path_start_item()\n         {\n             let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -199,10 +189,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n-        self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n-    }\n-\n     fn recover_stmt_local(\n         &mut self,\n         lo: Span,\n@@ -299,16 +285,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_auto_trait_item(&self) -> bool {\n-        // auto trait\n-        (self.token.is_keyword(kw::Auto) &&\n-            self.is_keyword_ahead(1, &[kw::Trait]))\n-        || // unsafe auto trait\n-        (self.token.is_keyword(kw::Unsafe) &&\n-         self.is_keyword_ahead(1, &[kw::Auto]) &&\n-         self.is_keyword_ahead(2, &[kw::Trait]))\n-    }\n-\n     /// Parses a block. No inner attributes are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);"}, {"sha": "bcf558d1563edd66d2bb522e6c25d86378534d27", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -2078,7 +2078,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-    ) -> Vec<TraitCandidate> {\n+    ) -> Vec<TraitCandidate<NodeId>> {\n         debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n \n         let mut found_traits = Vec::new();\n@@ -2123,7 +2123,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ident: Ident,\n         ns: Namespace,\n         module: Module<'a>,\n-        found_traits: &mut Vec<TraitCandidate>,\n+        found_traits: &mut Vec<TraitCandidate<NodeId>>,\n     ) {\n         assert!(ns == TypeNS || ns == ValueNS);\n         let mut traits = module.traits.borrow_mut();"}, {"sha": "4278bf867f305a4a1616b284d3ef95ce61eaec73", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -865,7 +865,7 @@ pub struct Resolver<'a> {\n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: NodeMap<CrateNum>,\n     export_map: ExportMap<NodeId>,\n-    trait_map: TraitMap,\n+    trait_map: TraitMap<NodeId>,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items"}, {"sha": "5bc5222f9fc15666e479f38be15802fb9668df32", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -747,7 +747,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n                 };\n-                self.with(scope, |_old_scope, this| {\n+                self.with(scope, |old_scope, this| {\n+                    this.check_lifetime_params(old_scope, &generics.params);\n                     this.visit_generics(generics);\n                     for bound in bounds {\n                         this.visit_param_bound(bound);\n@@ -804,7 +805,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n                 };\n-                self.with(scope, |_old_scope, this| {\n+                self.with(scope, |old_scope, this| {\n+                    this.check_lifetime_params(old_scope, &generics.params);\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });"}, {"sha": "8f0fbc2d60c9fc06951e42cbf760530235671787", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -902,13 +902,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             for trait_candidate in applicable_traits.iter() {\n                 let trait_did = trait_candidate.def_id;\n                 if duplicates.insert(trait_did) {\n-                    let import_ids = trait_candidate\n-                        .import_ids\n-                        .iter()\n-                        .map(|node_id| self.fcx.tcx.hir().node_to_hir_id(*node_id))\n-                        .collect();\n-                    let result =\n-                        self.assemble_extension_candidates_for_trait(import_ids, trait_did);\n+                    let result = self.assemble_extension_candidates_for_trait(\n+                        &trait_candidate.import_ids,\n+                        trait_did,\n+                    );\n                     result?;\n                 }\n             }\n@@ -920,7 +917,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let mut duplicates = FxHashSet::default();\n         for trait_info in suggest::all_traits(self.tcx) {\n             if duplicates.insert(trait_info.def_id) {\n-                self.assemble_extension_candidates_for_trait(smallvec![], trait_info.def_id)?;\n+                self.assemble_extension_candidates_for_trait(&smallvec![], trait_info.def_id)?;\n             }\n         }\n         Ok(())\n@@ -959,7 +956,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn assemble_extension_candidates_for_trait(\n         &mut self,\n-        import_ids: SmallVec<[hir::HirId; 1]>,\n+        import_ids: &SmallVec<[hir::HirId; 1]>,\n         trait_def_id: DefId,\n     ) -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\", trait_def_id);"}, {"sha": "1f06c9da3a9939b696db3c97ca7fd05eed3612f9", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -151,6 +151,7 @@ elf_entry:\n     pushfq\n     andq $~0x40400, (%rsp)\n     popfq\n+/*  check for abort */\n     bt $0,.Laborted(%rip)\n     jc .Lreentry_panic\n .endm"}, {"sha": "65071c3ed86e0f1b75057ca1dfb47e3d497737bb", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -824,14 +824,14 @@ LLVMRustOptimizeWithNewPassManager(\n     }\n \n     if (SanitizerOptions->SanitizeAddress) {\n-      // FIXME: Rust does not expose the UseAfterScope option.\n       PipelineStartEPCallbacks.push_back([&](ModulePassManager &MPM) {\n         MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n       });\n       OptimizerLastEPCallbacks.push_back(\n         [SanitizerOptions](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n           FPM.addPass(AddressSanitizerPass(\n-              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover,\n+              /*UseAfterScope=*/true));\n         }\n       );\n       PipelineStartEPCallbacks.push_back("}, {"sha": "bb4fb1459bd64597037bb9afad15ac31bb73bec0", "filename": "src/test/pretty/trait-inner-attr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fpretty%2Ftrait-inner-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fpretty%2Ftrait-inner-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ftrait-inner-attr.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -0,0 +1,7 @@\n+// pp-exact\n+\n+trait Foo {\n+    #![allow(bar)]\n+}\n+\n+fn main() { }"}, {"sha": "5c308948bd3f87d2574713b0a53362618442172a", "filename": "src/test/ui/generic-associated-types/shadowing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -2,17 +2,17 @@\n #![feature(generic_associated_types)]\n \n trait Shadow<'a> {\n-    //FIXME(#44265): The lifetime parameter shadowing should cause an error.\n     type Bar<'a>;\n+    //~^ ERROR lifetime name `'a` shadows a lifetime name that is already in scope\n }\n \n trait NoShadow<'a> {\n     type Bar<'b>; // OK\n }\n \n impl<'a> NoShadow<'a> for &'a u32 {\n-    //FIXME(#44265): The lifetime parameter shadowing should cause an error.\n     type Bar<'a> = i32;\n+    //~^ ERROR lifetime name `'a` shadows a lifetime name that is already in scope\n }\n \n trait ShadowT<T> {"}, {"sha": "2d9a0d6fceb2dbaf6754faa28268dae58531980f", "filename": "src/test/ui/generic-associated-types/shadowing.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -14,6 +14,22 @@ LL | impl<T> NoShadowT<T> for Option<T> {\n LL |     type Bar<T> = i32;\n    |              ^ already used\n \n+error[E0496]: lifetime name `'a` shadows a lifetime name that is already in scope\n+  --> $DIR/shadowing.rs:5:14\n+   |\n+LL | trait Shadow<'a> {\n+   |              -- first declared here\n+LL |     type Bar<'a>;\n+   |              ^^ lifetime 'a already in scope\n+\n+error[E0496]: lifetime name `'a` shadows a lifetime name that is already in scope\n+  --> $DIR/shadowing.rs:14:14\n+   |\n+LL | impl<'a> NoShadow<'a> for &'a u32 {\n+   |      -- first declared here\n+LL |     type Bar<'a> = i32;\n+   |              ^^ lifetime 'a already in scope\n+\n error: type-generic associated types are not yet implemented\n   --> $DIR/shadowing.rs:19:5\n    |\n@@ -30,6 +46,7 @@ LL |     type Bar<U>; // OK\n    |\n    = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0403`.\n+Some errors have detailed explanations: E0403, E0496.\n+For more information about an error, try `rustc --explain E0403`."}, {"sha": "6221b90b31dd7f7d2313674f180d1bc5fff08afd", "filename": "src/test/ui/issues/issue-58856-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -7,11 +7,11 @@ LL |     fn how_are_you(&self -> Empty {\n    |                   |     help: `)` may belong here\n    |                   unclosed delimiter\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `)`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `)`\n   --> $DIR/issue-58856-2.rs:11:1\n    |\n LL |     }\n-   |      - expected one of 10 possible tokens\n+   |      - expected one of 11 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "b2beb73503bb074c6fdd56ade5db145d2f272019", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n LL |         });\n    |          ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `;`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `;`\n   --> $DIR/issue-60075.rs:6:11\n    |\n LL |     fn qux() -> Option<usize> {"}, {"sha": "a70163df1cb93209788d3400b1a8e325d203e959", "filename": "src/test/ui/macros/issue-54441.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,6 +1,7 @@\n macro_rules! m {\n+    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n     () => {\n-        let //~ ERROR expected\n+        let\n     };\n }\n "}, {"sha": "761e7aec7235a2a14a878695ceb4807e3684122b", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,13 +1,11 @@\n-error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `static`, `type`, or `unsafe`, found keyword `let`\n-  --> $DIR/issue-54441.rs:3:9\n+error: missing `fn`, `type`, or `static` for extern-item declaration\n+  --> $DIR/issue-54441.rs:1:1\n    |\n-LL |         let\n-   |         ^^^ expected one of 9 possible tokens\n-...\n-LL |     m!();\n-   |     ----- in this macro invocation\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / macro_rules! m {\n+LL | |\n+LL | |     () => {\n+LL | |         let\n+   | |________^ missing `fn`, `type`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "a2acb94372b8cec895dfdd46bad4516971a48383", "filename": "src/test/ui/parser/attr-before-eof.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattr-before-eof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattr-before-eof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-before-eof.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n error: expected item after attributes\n-  --> $DIR/attr-before-eof.rs:3:16\n+  --> $DIR/attr-before-eof.rs:3:1\n    |\n LL | #[derive(Debug)]\n-   |                ^\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1c892eac08f3bd13ea9844c430c3b0f4c883a20a", "filename": "src/test/ui/parser/attr-dangling-in-mod.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattr-dangling-in-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattr-dangling-in-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-dangling-in-mod.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n error: expected item after attributes\n-  --> $DIR/attr-dangling-in-mod.rs:6:14\n+  --> $DIR/attr-dangling-in-mod.rs:6:1\n    |\n LL | #[foo = \"bar\"]\n-   |              ^\n+   | ^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ea899dca7b221d453848bee5712b39131f189e49", "filename": "src/test/ui/parser/attrs-after-extern-mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,13 +1,7 @@\n-// Constants (static variables) can be used to match in patterns, but mutable\n-// statics cannot. This ensures that there's some form of error if this is\n-// attempted.\n+// Make sure there's an error when given `extern { ... #[attr] }`.\n \n-extern crate libc;\n+fn main() {}\n \n extern {\n-    static mut rust_dbg_static_mut: libc::c_int;\n-    pub fn rust_dbg_static_mut_check_four();\n     #[cfg(stage37)] //~ ERROR expected item after attributes\n }\n-\n-pub fn main() {}"}, {"sha": "6060f3afe1e95c4b78cdea35f6a6190cee207240", "filename": "src/test/ui/parser/attrs-after-extern-mod.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n error: expected item after attributes\n-  --> $DIR/attrs-after-extern-mod.rs:10:19\n+  --> $DIR/attrs-after-extern-mod.rs:6:5\n    |\n LL |     #[cfg(stage37)]\n-   |                   ^\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "65ecb1ebbe919fbe0ef59ac42a85e8e5c5de5b18", "filename": "src/test/ui/parser/default.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -19,7 +19,8 @@ impl Foo for u16 {\n }\n \n impl Foo for u32 { //~ ERROR not all trait items implemented, missing: `foo`\n-    default pub fn foo<T: Default>() -> T { T::default() } //~ ERROR expected one of\n+    default pub fn foo<T: Default>() -> T { T::default() }\n+    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n }\n \n fn main() {}"}, {"sha": "ede9e4715186311e9e4d28aa261562059956ae37", "filename": "src/test/ui/parser/default.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found keyword `pub`\n-  --> $DIR/default.rs:22:13\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/default.rs:22:12\n    |\n LL |     default pub fn foo<T: Default>() -> T { T::default() }\n-   |             ^^^ expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`\n+   |            ^ missing `fn`, `type`, or `const`\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/default.rs:16:5"}, {"sha": "14fd01af2f98af15345c4a6995b4634bf32390e7", "filename": "src/test/ui/parser/doc-before-attr.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-before-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-before-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-attr.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,10 @@\n error: expected item after attributes\n-  --> $DIR/doc-before-attr.rs:4:16\n+  --> $DIR/doc-before-attr.rs:4:1\n    |\n+LL | /// hi\n+   | ------ other attributes here\n LL | #[derive(Debug)]\n-   |                ^\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "040206b80ffd05d1b6be8a863c981e0557044b64", "filename": "src/test/ui/parser/doc-before-extern-rbrace.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,4 +1,6 @@\n+fn main() {}\n+\n extern {\n     /// hi\n-    //~^ ERROR expected item after doc comment\n+    //~^ ERROR found a documentation comment that doesn't document anything\n }"}, {"sha": "0edceb268a7f5a37dff21b7fe900b0cf5f1e7464", "filename": "src/test/ui/parser/doc-before-extern-rbrace.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,11 @@\n-error: expected item after doc comment\n-  --> $DIR/doc-before-extern-rbrace.rs:2:5\n+error[E0584]: found a documentation comment that doesn't document anything\n+  --> $DIR/doc-before-extern-rbrace.rs:4:5\n    |\n LL |     /// hi\n    |     ^^^^^^ this doc comment doesn't document anything\n+   |\n+   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0584`."}, {"sha": "246255a0a46751f2d25f6df6dd48e07fcbd63f64", "filename": "src/test/ui/parser/doc-inside-trait-item.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -2,7 +2,7 @@ error[E0584]: found a documentation comment that doesn't document anything\n   --> $DIR/doc-inside-trait-item.rs:3:5\n    |\n LL |     /// empty doc\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^ this doc comment doesn't document anything\n    |\n    = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n "}, {"sha": "1d271fa64b0ec31c02c3c7bbd999ec521198cca6", "filename": "src/test/ui/parser/duplicate-visibility.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,4 +1,6 @@\n-// error-pattern: expected one of `(`, `async`, `const`, `extern`, `fn`\n+fn main() {}\n+\n extern {\n     pub pub fn foo();\n+    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n }"}, {"sha": "36a3a1ed5a0ccbd972ab381b784ff0f4fab5d0df", "filename": "src/test/ui/parser/duplicate-visibility.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `extern`, `fn`, `static`, `type`, or `unsafe`, found keyword `pub`\n-  --> $DIR/duplicate-visibility.rs:3:9\n+error: missing `fn`, `type`, or `static` for extern-item declaration\n+  --> $DIR/duplicate-visibility.rs:4:8\n    |\n LL |     pub pub fn foo();\n-   |         ^^^ expected one of 8 possible tokens\n+   |        ^ missing `fn`, `type`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "8dba6b362cdfaf4f5d2c161b01f01f2da8a0fe47", "filename": "src/test/ui/parser/inner-attr-in-trait-def.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Finner-attr-in-trait-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Finner-attr-in-trait-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finner-attr-in-trait-def.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#![deny(non_camel_case_types)]\n+\n+fn main() {}\n+\n+trait foo_bar {\n+    #![allow(non_camel_case_types)]\n+}"}, {"sha": "982a6be23ac5fb1814e14e99b9ba14fbcade81a6", "filename": "src/test/ui/parser/issue-19398.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,5 +1,6 @@\n trait T {\n-    extern \"Rust\" unsafe fn foo(); //~ ERROR expected one of `async`, `const`\n+    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+    extern \"Rust\" unsafe fn foo();\n }\n \n fn main() {}"}, {"sha": "2bd6ac3a4b3a49998821322f793ec265e2d5330b", "filename": "src/test/ui/parser/issue-19398.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,10 +1,11 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found keyword `extern`\n-  --> $DIR/issue-19398.rs:2:5\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/issue-19398.rs:1:10\n    |\n-LL | trait T {\n-   |          - expected one of 10 possible tokens\n-LL |     extern \"Rust\" unsafe fn foo();\n-   |     ^^^^^^ unexpected token\n+LL |   trait T {\n+   |  __________^\n+LL | |\n+LL | |     extern \"Rust\" unsafe fn foo();\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: aborting due to previous error\n "}, {"sha": "168c7e76162bcffc6d42e3920b727a41a2cfde09", "filename": "src/test/ui/parser/issue-20711-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -4,6 +4,7 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n+    //~^ ERROR expected item after attributes\n+}\n \n fn main() {}"}, {"sha": "10ef31584dec10a516f3431b086a88a359f224e3", "filename": "src/test/ui/parser/issue-20711-2.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,10 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n-  --> $DIR/issue-20711-2.rs:7:1\n+error: expected item after attributes\n+  --> $DIR/issue-20711-2.rs:6:5\n    |\n LL |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-   |                                                  - expected one of 9 possible tokens\n-LL | }\n-   | ^ unexpected token\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "020bb79d6e74e075effabfe12367e482a4a63e04", "filename": "src/test/ui/parser/issue-20711.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -2,6 +2,7 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n+    //~^ ERROR expected item after attributes\n+}\n \n fn main() {}"}, {"sha": "66768de569418dca62594660747e107ee2449770", "filename": "src/test/ui/parser/issue-20711.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,10 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n-  --> $DIR/issue-20711.rs:5:1\n+error: expected item after attributes\n+  --> $DIR/issue-20711.rs:4:5\n    |\n LL |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-   |                                                  - expected one of 9 possible tokens\n-LL | }\n-   | ^ unexpected token\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "25c1efe35ae11cb7f31b806e48f5f439d7e262dd", "filename": "src/test/ui/parser/issue-32446.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `...`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `...`\n   --> $DIR/issue-32446.rs:4:11\n    |\n LL | trait T { ... }\n-   |           ^^^ expected one of 10 possible tokens\n+   |           ^^^ expected one of 11 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "327bc65818fa9ada1fc968b2677a5f4005f8df84", "filename": "src/test/ui/parser/issue-41155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found `}`\n+error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, `unsafe`, or identifier, found `}`\n   --> $DIR/issue-41155.rs:5:1\n    |\n LL |     pub\n-   |        - expected one of 8 possible tokens\n+   |        - expected one of 9 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "8a44ee761ed677e7a65b5b90c01af6bd11eaf7a3", "filename": "src/test/ui/parser/issue-58094-missing-right-square-bracket.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-58094-missing-right-square-bracket.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fissue-58094-missing-right-square-bracket.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-58094-missing-right-square-bracket.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -7,10 +7,10 @@ LL | #[\u0405\n    |  unclosed delimiter\n \n error: expected item after attributes\n-  --> $DIR/issue-58094-missing-right-square-bracket.rs:4:4\n+  --> $DIR/issue-58094-missing-right-square-bracket.rs:4:1\n    |\n LL | #[\u0405\n-   |    ^\n+   | ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f5f8a01e6a440eeea4fe03007d1579275d5e46cc", "filename": "src/test/ui/parser/macro/pub-item-macro.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,12 +1,15 @@\n // Issue #14660\n \n-macro_rules! priv_x { () => {\n-    static x: u32 = 0;\n-}}\n+macro_rules! priv_x {\n+    () => {\n+        static x: u32 = 0;\n+    };\n+}\n \n macro_rules! pub_x { () => {\n     pub priv_x!(); //~ ERROR can't qualify macro invocation with `pub`\n-    //~^ HELP try adjusting the macro to put `pub` inside the invocation\n+    //~^ HELP remove the visibility\n+    //~| HELP try adjusting the macro to put `pub` inside the invocation\n }}\n \n mod foo {"}, {"sha": "4ff96532e03a82d1fc9330f8fd2de093c5c95e7f", "filename": "src/test/ui/parser/macro/pub-item-macro.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n error: can't qualify macro invocation with `pub`\n-  --> $DIR/pub-item-macro.rs:8:5\n+  --> $DIR/pub-item-macro.rs:10:5\n    |\n LL |     pub priv_x!();\n-   |     ^^^\n+   |     ^^^ help: remove the visibility\n ...\n LL |     pub_x!();\n    |     --------- in this macro invocation\n@@ -11,16 +11,16 @@ LL |     pub_x!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0603]: static `x` is private\n-  --> $DIR/pub-item-macro.rs:17:23\n+  --> $DIR/pub-item-macro.rs:20:23\n    |\n LL |     let y: u32 = foo::x;\n    |                       ^ this static is private\n    |\n note: the static `x` is defined here\n-  --> $DIR/pub-item-macro.rs:4:5\n+  --> $DIR/pub-item-macro.rs:5:9\n    |\n-LL |     static x: u32 = 0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |         static x: u32 = 0;\n+   |         ^^^^^^^^^^^^^^^^^^\n ...\n LL |     pub_x!();\n    |     --------- in this macro invocation"}, {"sha": "9d05e85bcc00e06e26881230e4678d256d9c0fc9", "filename": "src/test/ui/parser/macro/trait-non-item-macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `2`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or identifier, found `2`\n   --> $DIR/trait-non-item-macros.rs:2:19\n    |\n LL |     ($a:expr) => ($a)\n-   |                   ^^ expected one of 9 possible tokens\n+   |                   ^^ expected one of 10 possible tokens\n ...\n LL |     bah!(2);\n    |     -------- in this macro invocation"}, {"sha": "592215030f552f2030ee4ee45abccae64ec5c7b4", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,12 +1,14 @@\n+fn main() {}\n+\n impl T for () { //~ ERROR cannot find trait `T` in this scope\n \n fn foo(&self) {}\n+//~^ ERROR missing `fn`, `type`, or `const`\n \n-trait T { //~ ERROR expected one of\n+trait T {\n     fn foo(&self);\n }\n \n pub(crate) struct Bar<T>();\n \n-fn main() {}\n //~ ERROR this file contains an unclosed delimiter"}, {"sha": "1ec54525105f66598efdaefd1ad2c7418cd129a8", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.stderr", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,29 +1,24 @@\n error: this file contains an unclosed delimiter\n-  --> $DIR/missing-close-brace-in-impl-trait.rs:12:52\n+  --> $DIR/missing-close-brace-in-impl-trait.rs:14:52\n    |\n LL | impl T for () {\n    |               - unclosed delimiter\n ...\n LL |\n    |                                                    ^\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found keyword `trait`\n-  --> $DIR/missing-close-brace-in-impl-trait.rs:5:1\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/missing-close-brace-in-impl-trait.rs:5:17\n    |\n-LL | impl T for () {\n-   |               - unclosed delimiter\n-LL | \n-LL | fn foo(&self) {}\n-   |                 -\n-   |                 |\n-   |                 expected one of 10 possible tokens\n-   |                 help: `}` may belong here\n-LL | \n-LL | trait T {\n-   | ^^^^^ unexpected token\n+LL |   fn foo(&self) {}\n+   |  _________________^\n+LL | |\n+LL | |\n+LL | | trait T {\n+   | |_ missing `fn`, `type`, or `const`\n \n error[E0405]: cannot find trait `T` in this scope\n-  --> $DIR/missing-close-brace-in-impl-trait.rs:1:6\n+  --> $DIR/missing-close-brace-in-impl-trait.rs:3:6\n    |\n LL | impl T for () {\n    |      ^ not found in this scope"}, {"sha": "077e33471942741c42f993dde3e85ca95945f6cc", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -3,7 +3,7 @@ trait T {\n     fn foo(&self);\n \n pub(crate) struct Bar<T>();\n-//~^ ERROR expected one of\n+//~^ ERROR missing `fn`, `type`, or `const`\n \n impl T for Bar<usize> {\n fn foo(&self) {}"}, {"sha": "1bb153c461d90b20dd1feab86f6bfecf1b3cc4d6", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -7,11 +7,11 @@ LL | trait T {\n LL | fn main() {}\n    |                                                                 ^\n \n-error: expected one of `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found keyword `struct`\n-  --> $DIR/missing-close-brace-in-trait.rs:5:12\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/missing-close-brace-in-trait.rs:5:11\n    |\n LL | pub(crate) struct Bar<T>();\n-   |            ^^^^^^ expected one of 7 possible tokens\n+   |           ^ missing `fn`, `type`, or `const`\n \n error[E0601]: `main` function not found in crate `missing_close_brace_in_trait`\n   --> $DIR/missing-close-brace-in-trait.rs:1:1"}, {"sha": "0183bdcf6220bcf41a660803e46613ff2b8dd58d", "filename": "src/test/ui/parser/pub-method-macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -15,7 +15,8 @@ mod bleh {\n \n     impl S {\n         pub defn!(f); //~ ERROR can't qualify macro invocation with `pub`\n-        //~^ HELP try adjusting the macro to put `pub` inside the invocation\n+        //~^ HELP remove the visibility\n+        //~| HELP try adjusting the macro to put `pub` inside the invocation\n     }\n }\n "}, {"sha": "7c7a909267a1cfecd4c53e209444643430ca723a", "filename": "src/test/ui/parser/pub-method-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -2,7 +2,7 @@ error: can't qualify macro invocation with `pub`\n   --> $DIR/pub-method-macro.rs:17:9\n    |\n LL |         pub defn!(f);\n-   |         ^^^\n+   |         ^^^ help: remove the visibility\n    |\n    = help: try adjusting the macro to put `pub` inside the invocation\n "}, {"sha": "9e12222f3fd8b54d6b74c63cfd47c6685b050158", "filename": "src/test/ui/parser/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,8 @@\n struct S;\n \n impl S {\n+    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n     static fn f() {}\n-    //~^ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`,\n }\n \n fn main() {}"}, {"sha": "5edf88026fbece1eb122ccaf4ab803568b12eb59", "filename": "src/test/ui/parser/removed-syntax-static-fn.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,10 +1,11 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found keyword `static`\n-  --> $DIR/removed-syntax-static-fn.rs:4:5\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/removed-syntax-static-fn.rs:3:9\n    |\n-LL | impl S {\n-   |         - expected one of 10 possible tokens\n-LL |     static fn f() {}\n-   |     ^^^^^^ unexpected token\n+LL |   impl S {\n+   |  _________^\n+LL | |\n+LL | |     static fn f() {}\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: aborting due to previous error\n "}, {"sha": "3f8904fbe79d878e1fc261ea4162b1fd00ad5f4d", "filename": "src/test/ui/pub/pub-restricted-error-fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,3 +1,2 @@\n-#![feature(pub_restricted)]\n-\n pub(crate) () fn foo() {} //~ unmatched visibility\n+//~^ ERROR expected item, found `(`"}, {"sha": "c0168b02da607550a36e1d4610d74eed46281530", "filename": "src/test/ui/pub/pub-restricted-error-fn.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -1,8 +1,16 @@\n-error: unmatched visibility `pub`\n-  --> $DIR/pub-restricted-error-fn.rs:3:10\n+error: unmatched visibility `pub(crate)`\n+  --> $DIR/pub-restricted-error-fn.rs:1:1\n    |\n LL | pub(crate) () fn foo() {}\n-   |          ^\n+   | ^^^^^^^^^^ the unmatched visibility\n+   |\n+   = help: you likely meant to define an item, e.g., `pub(crate) fn foo() {}`\n+\n+error: expected item, found `(`\n+  --> $DIR/pub-restricted-error-fn.rs:1:12\n+   |\n+LL | pub(crate) () fn foo() {}\n+   |            ^ expected item\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "226779ad0c0ce6d11daf8422fabe47452cea1d1a", "filename": "src/tools/rustbook/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs?ref=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1", "patch": "@@ -115,6 +115,8 @@ pub fn linkcheck(\n                     eprintln!(\"Timeout for link `{}`\", link.link.uri);\n                 } else if err.is_server_error() {\n                     eprintln!(\"Server error for link `{}`\", link.link.uri);\n+                } else if !err.is_http() {\n+                    eprintln!(\"Non-HTTP-related error for link: {} {}\", link.link.uri, err);\n                 } else {\n                     is_real_error = true;\n                 }"}]}