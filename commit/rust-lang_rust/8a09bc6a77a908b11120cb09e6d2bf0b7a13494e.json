{"sha": "8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMDliYzZhNzdhOTA4YjExMTIwY2IwOWU2ZDJiZjBiN2ExMzQ5NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T03:53:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T03:53:39Z"}, "message": "Auto merge of #48995 - aravind-pg:canonical-query, r=nikomatsakis\n\nCreate a canonical trait query for `evaluate_obligation`\n\nThis builds on the canonical query machinery introduced in #48411 to introduce a new canonical trait query for `evaluate_obligation` in the trait selector. Also ports most callers of the original `evaluate_obligation` to the new system (except in coherence, which requires support for intercrate mode). Closes #48537.\n\nr? @nikomatsakis", "tree": {"sha": "763af9a091d5ef3bb8a718a7410a97eb451583bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/763af9a091d5ef3bb8a718a7410a97eb451583bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "html_url": "https://github.com/rust-lang/rust/commit/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e05b78daa628ad88952d856c68cb5708434fa934", "url": "https://api.github.com/repos/rust-lang/rust/commits/e05b78daa628ad88952d856c68cb5708434fa934", "html_url": "https://github.com/rust-lang/rust/commit/e05b78daa628ad88952d856c68cb5708434fa934"}, {"sha": "e423dcc7133f20c8da2609dba96afeeab1efbc5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e423dcc7133f20c8da2609dba96afeeab1efbc5a", "html_url": "https://github.com/rust-lang/rust/commit/e423dcc7133f20c8da2609dba96afeeab1efbc5a"}], "stats": {"total": 450, "additions": 341, "deletions": 109}, "files": [{"sha": "e4f432e7caf494d789bd520299e6774db9cb22bd", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -70,7 +70,8 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{CanonicalProjectionGoal,\n+                    CanonicalTyGoal, CanonicalPredicateGoal};\n use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n \n@@ -643,6 +644,7 @@ define_dep_nodes!( <'tcx>\n     [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n     [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n+    [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n "}, {"sha": "5a626e7b82cc47c17f5b297dc63a9dc6ec1ad0a3", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -154,7 +154,10 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                                            recursion_depth: 0,\n                                            predicate: p })\n                      .chain(obligations)\n-                     .find(|o| !selcx.evaluate_obligation(o));\n+                     .find(|o| !selcx.predicate_may_hold_fatal(o));\n+    // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n+    // to the canonical trait query form, `infcx.predicate_may_hold`, once\n+    // the new system supports intercrate mode (which coherence needs).\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);"}, {"sha": "285d530a38a69cab5e6eda57c2f29f9f5470d651", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -24,6 +24,7 @@ use super::{\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n+    Overflow,\n };\n \n use errors::DiagnosticBuilder;\n@@ -659,8 +660,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 predicate: ty::Predicate::Trait(predicate),\n                                 .. obligation.clone()\n                             };\n-                            let mut selcx = SelectionContext::new(self);\n-                            if selcx.evaluate_obligation(&unit_obligation) {\n+                            if self.predicate_may_hold(&unit_obligation) {\n                                 err.note(\"the trait is implemented for `()`. \\\n                                          Possibly this error has been caused by changes to \\\n                                          Rust's type-inference algorithm \\\n@@ -830,6 +830,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 err.struct_error(self.tcx, span, \"constant expression\")\n             }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n         };\n         self.note_obligation_cause(&mut err, obligation);\n         err.emit();\n@@ -872,7 +876,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 .count();\n \n             let mut trait_type = trait_ref.self_ty();\n-            let mut selcx = SelectionContext::new(self);\n \n             for refs_remaining in 0..refs_number {\n                 if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n@@ -886,7 +889,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                          obligation.param_env,\n                                                          new_trait_ref.to_predicate());\n \n-                    if selcx.evaluate_obligation(&new_obligation) {\n+                    if self.predicate_may_hold(&new_obligation) {\n                         let sp = self.tcx.sess.codemap()\n                             .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n \n@@ -1322,7 +1325,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 cleaned_pred.to_predicate()\n             );\n \n-            selcx.evaluate_obligation(&obligation)\n+            self.predicate_may_hold(&obligation)\n         })\n     }\n "}, {"sha": "6e20150718110ae2a0540ddf435ff1e3c64398c8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -333,7 +333,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n             if data.is_global() {\n                 // no type variables present, can use evaluation for better caching.\n                 // FIXME: consider caching errors too.\n-                if selcx.evaluate_obligation_conservatively(&obligation) {\n+                if selcx.infcx().predicate_must_hold(&obligation) {\n                     debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n                            data, obligation.recursion_depth);\n                     return Ok(Some(vec![]))"}, {"sha": "dd5208e908e19e117243b7a13280b27abeff8a7f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -41,7 +41,7 @@ pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n-pub use self::select::IntercrateAmbiguityCause;\n+pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::engine::TraitEngine;\n@@ -74,6 +74,19 @@ pub enum IntercrateMode {\n     Fixed\n }\n \n+// The mode that trait queries run in\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TraitQueryMode {\n+    // Standard/un-canonicalized queries get accurate\n+    // spans etc. passed in and hence can do reasonable\n+    // error reporting on their own.\n+    Standard,\n+    // Canonicalized queries get dummy spans and hence\n+    // must generally propagate errors to\n+    // pre-canonicalization callsites.\n+    Canonical,\n+}\n+\n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n@@ -349,6 +362,7 @@ pub enum SelectionError<'tcx> {\n                                 ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n     ConstEvalFailure(ConstEvalErr<'tcx>),\n+    Overflow,\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -550,8 +564,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         predicate: trait_ref.to_predicate(),\n     };\n \n-    let result = SelectionContext::new(infcx)\n-        .evaluate_obligation_conservatively(&obligation);\n+    let result = infcx.predicate_must_hold(&obligation);\n     debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n            ty, infcx.tcx.item_path_str(def_id), result);\n "}, {"sha": "4e028cac49abe18474503d907447d865a88038f5", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use infer::canonical::{Canonical, Canonicalize};\n+use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n+             TraitQueryMode, OverflowError};\n+use traits::query::CanonicalPredicateGoal;\n+use ty::{ParamEnvAnd, Predicate, TyCtxt};\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Evaluates whether the predicate can be satisfied (by any means)\n+    /// in the given `ParamEnv`.\n+    pub fn predicate_may_hold(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        self.evaluate_obligation(obligation).may_apply()\n+    }\n+\n+    /// Evaluates whether the predicate can be satisfied in the given\n+    /// `ParamEnv`, and returns `false` if not certain. However, this is\n+    /// not entirely accurate if inference variables are involved.\n+    pub fn predicate_must_hold(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        self.evaluate_obligation(obligation) == EvaluationResult::EvaluatedToOk\n+    }\n+\n+    // Helper function that canonicalizes and runs the query, as well as handles\n+    // overflow.\n+    fn evaluate_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> EvaluationResult {\n+        let (c_pred, _) =\n+            self.canonicalize_query(&obligation.param_env.and(obligation.predicate));\n+        // Run canonical query. If overflow occurs, rerun from scratch but this time\n+        // in standard trait query mode so that overflow is handled appropriately\n+        // within `SelectionContext`.\n+        match self.tcx.global_tcx().evaluate_obligation(c_pred) {\n+            Ok(result) => result,\n+            Err(OverflowError) => {\n+                let mut selcx =\n+                    SelectionContext::with_query_mode(&self, TraitQueryMode::Standard);\n+                selcx.evaluate_obligation_recursively(obligation)\n+                     .expect(\"Overflow should be caught earlier in standard query mode\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ParamEnvAnd<'tcx, Predicate<'tcx>> {\n+    type Canonicalized = CanonicalPredicateGoal<'gcx>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}"}, {"sha": "096633ddab2f7893cb6961a27b4e357c0ae7bad3", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -19,6 +19,7 @@ use infer::canonical::Canonical;\n use ty::{self, Ty};\n \n pub mod dropck_outlives;\n+pub mod evaluate_obligation;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n \n@@ -27,6 +28,9 @@ pub type CanonicalProjectionGoal<'tcx> =\n \n pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n \n+pub type CanonicalPredicateGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct NoSolution;\n "}, {"sha": "4ba3655bb644abec51a0c615aedd4d0d58e55ba9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 158, "deletions": 85, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -17,12 +17,12 @@ use self::EvaluationResult::*;\n \n use super::coherence::{self, Conflict};\n use super::DerivedObligationCause;\n-use super::IntercrateMode;\n+use super::{IntercrateMode, TraitQueryMode};\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n-use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n+use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch, Overflow};\n use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n use super::Selection;\n@@ -87,7 +87,12 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// Controls whether or not to filter out negative impls when selecting.\n     /// This is used in librustdoc to distinguish between the lack of an impl\n     /// and a negative impl\n-    allow_negative_impls: bool\n+    allow_negative_impls: bool,\n+\n+    /// The mode that trait queries run in, which informs our error handling\n+    /// policy. In essence, canonicalized queries need their errors propagated\n+    /// rather than immediately reported because we do not have accurate spans.\n+    query_mode: TraitQueryMode,\n }\n \n #[derive(Clone, Debug)]\n@@ -319,7 +324,7 @@ enum BuiltinImplConditions<'tcx> {\n ///     all the \"potential success\" candidates can potentially succeed,\n ///     so they are no-ops when unioned with a definite error, and within\n ///     the categories it's easy to see that the unions are correct.\n-enum EvaluationResult {\n+pub enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n     /// Evaluation is known to be ambiguous - it *might* hold for some\n@@ -385,7 +390,7 @@ enum EvaluationResult {\n }\n \n impl EvaluationResult {\n-    fn may_apply(self) -> bool {\n+    pub fn may_apply(self) -> bool {\n         match self {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n@@ -408,6 +413,26 @@ impl EvaluationResult {\n     }\n }\n \n+impl_stable_hash_for!(enum self::EvaluationResult {\n+    EvaluatedToOk,\n+    EvaluatedToAmbig,\n+    EvaluatedToUnknown,\n+    EvaluatedToRecur,\n+    EvaluatedToErr\n+});\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// Indicates that trait evaluation caused overflow.\n+pub struct OverflowError;\n+\n+impl_stable_hash_for!(struct OverflowError { });\n+\n+impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n+    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n+        SelectionError::Overflow\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>\n@@ -421,6 +446,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -433,6 +459,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: Some(mode),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -445,6 +472,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n+            query_mode: TraitQueryMode::Standard,\n+        }\n+    }\n+\n+    pub fn with_query_mode(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+                           query_mode: TraitQueryMode) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+        debug!(\"with_query_mode({:?})\", query_mode);\n+        SelectionContext {\n+            infcx,\n+            freshener: infcx.freshener(),\n+            intercrate: None,\n+            intercrate_ambiguity_causes: None,\n+            allow_negative_impls: false,\n+            query_mode,\n         }\n     }\n \n@@ -528,12 +569,27 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n-        let ret = match self.candidate_from_obligation(&stack)? {\n-            None => None,\n-            Some(candidate) => Some(self.confirm_candidate(obligation, candidate)?)\n+\n+        let candidate = match self.candidate_from_obligation(&stack) {\n+            Err(SelectionError::Overflow) => {\n+                // In standard mode, overflow must have been caught and reported\n+                // earlier.\n+                assert!(self.query_mode == TraitQueryMode::Canonical);\n+                return Err(SelectionError::Overflow);\n+            },\n+            Err(e) => { return Err(e); },\n+            Ok(None) => { return Ok(None); },\n+            Ok(Some(candidate)) => candidate\n         };\n \n-        Ok(ret)\n+        match self.confirm_candidate(obligation, candidate) {\n+            Err(SelectionError::Overflow) => {\n+                assert!(self.query_mode == TraitQueryMode::Canonical);\n+                return Err(SelectionError::Overflow);\n+            },\n+            Err(e) => Err(e),\n+            Ok(candidate) => Ok(Some(candidate))\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -547,32 +603,30 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     // we can be sure it does not.\n \n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n-    pub fn evaluate_obligation(&mut self,\n-                               obligation: &PredicateObligation<'tcx>)\n-                               -> bool\n+    pub fn predicate_may_hold_fatal(&mut self,\n+                                    obligation: &PredicateObligation<'tcx>)\n+                                    -> bool\n     {\n-        debug!(\"evaluate_obligation({:?})\",\n+        debug!(\"predicate_may_hold_fatal({:?})\",\n                obligation);\n \n-        self.probe(|this, _| {\n-            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-                .may_apply()\n-        })\n+        // This fatal query is a stopgap that should only be used in standard mode,\n+        // where we do not expect overflow to be propagated.\n+        assert!(self.query_mode == TraitQueryMode::Standard);\n+\n+        self.evaluate_obligation_recursively(obligation)\n+            .expect(\"Overflow should be caught earlier in standard query mode\")\n+            .may_apply()\n     }\n \n-    /// Evaluates whether the obligation `obligation` can be satisfied,\n-    /// and returns `false` if not certain. However, this is not entirely\n-    /// accurate if inference variables are involved.\n-    pub fn evaluate_obligation_conservatively(&mut self,\n-                                              obligation: &PredicateObligation<'tcx>)\n-                                              -> bool\n+    /// Evaluates whether the obligation `obligation` can be satisfied and returns\n+    /// an `EvaluationResult`.\n+    pub fn evaluate_obligation_recursively(&mut self,\n+                                           obligation: &PredicateObligation<'tcx>)\n+                                           -> Result<EvaluationResult, OverflowError>\n     {\n-        debug!(\"evaluate_obligation_conservatively({:?})\",\n-               obligation);\n-\n         self.probe(|this, _| {\n             this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-                == EvaluatedToOk\n         })\n     }\n \n@@ -582,29 +636,29 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n-                                                -> EvaluationResult\n+                                                -> Result<EvaluationResult, OverflowError>\n         where I : IntoIterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation);\n+            let eval = self.evaluate_predicate_recursively(stack, obligation)?;\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n                    obligation, eval);\n             if let EvaluatedToErr = eval {\n                 // fast-path - EvaluatedToErr is the top of the lattice,\n                 // so we don't need to look on the other predicates.\n-                return EvaluatedToErr;\n+                return Ok(EvaluatedToErr);\n             } else {\n                 result = cmp::max(result, eval);\n             }\n         }\n-        result\n+        Ok(result)\n     }\n \n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n-                                           -> EvaluationResult\n+                                           -> Result<EvaluationResult, OverflowError>\n     {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n@@ -620,11 +674,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n-                        EvaluatedToOk\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations)\n                     },\n-                    Some(Err(_)) => EvaluatedToErr,\n-                    None => EvaluatedToAmbig,\n+                    Some(Err(_)) => Ok(EvaluatedToErr),\n+                    None => Ok(EvaluatedToAmbig),\n                 }\n             }\n \n@@ -636,21 +689,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n                     None =>\n-                        EvaluatedToAmbig,\n+                        Ok(EvaluatedToAmbig),\n                 }\n             }\n \n             ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n                 // we do not consider region relationships when\n                 // evaluating trait matches\n-                EvaluatedToOk\n+                Ok(EvaluatedToOk)\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n-                    EvaluatedToOk\n+                    Ok(EvaluatedToOk)\n                 } else {\n-                    EvaluatedToErr\n+                    Ok(EvaluatedToErr)\n                 }\n             }\n \n@@ -668,10 +721,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         result\n                     }\n                     Ok(None) => {\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                     Err(_) => {\n-                        EvaluatedToErr\n+                        Ok(EvaluatedToErr)\n                     }\n                 }\n             }\n@@ -680,13 +733,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 match self.infcx.closure_kind(closure_def_id, closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n-                            EvaluatedToOk\n+                            Ok(EvaluatedToOk)\n                         } else {\n-                            EvaluatedToErr\n+                            Ok(EvaluatedToErr)\n                         }\n                     }\n                     None => {\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n             }\n@@ -707,16 +760,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                 promoted: None\n                             };\n                             match self.tcx().const_eval(param_env.and(cid)) {\n-                                Ok(_) => EvaluatedToOk,\n-                                Err(_) => EvaluatedToErr\n+                                Ok(_) => Ok(EvaluatedToOk),\n+                                Err(_) => Ok(EvaluatedToErr)\n                             }\n                         } else {\n-                            EvaluatedToErr\n+                            Ok(EvaluatedToErr)\n                         }\n                     }\n                     None => {\n                         // Inference variables still left in param_env or substs.\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n             }\n@@ -726,7 +779,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_trait_predicate_recursively<'o>(&mut self,\n                                                 previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                                 mut obligation: TraitObligation<'tcx>)\n-                                                -> EvaluationResult\n+                                                -> Result<EvaluationResult, OverflowError>\n     {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n@@ -745,22 +798,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n                    fresh_trait_ref,\n                    result);\n-            return result;\n+            return Ok(result);\n         }\n \n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n+        let result = result?;\n \n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n         self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n-        result\n+        Ok(result)\n     }\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &TraitObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult\n+                          -> Result<EvaluationResult, OverflowError>\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -815,7 +869,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            return EvaluatedToAmbig;\n+            return Ok(EvaluatedToAmbig);\n         }\n         if unbound_input_types &&\n               stack.iter().skip(1).any(\n@@ -825,7 +879,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n-            return EvaluatedToUnknown;\n+            return Ok(EvaluatedToUnknown);\n         }\n \n         // If there is any previous entry on the stack that precisely\n@@ -860,18 +914,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToOk;\n+                return Ok(EvaluatedToOk);\n             } else {\n                 debug!(\"evaluate_stack({:?}) --> recursive, inductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToRecur;\n+                return Ok(EvaluatedToRecur);\n             }\n         }\n \n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n-            Ok(None) => EvaluatedToAmbig,\n-            Err(..) => EvaluatedToErr\n+            Ok(None) => Ok(EvaluatedToAmbig),\n+            Err(Overflow) => Err(OverflowError),\n+            Err(..) => Ok(EvaluatedToErr)\n         }\n     }\n \n@@ -909,7 +964,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_candidate<'o>(&mut self,\n                               stack: &TraitObligationStack<'o, 'tcx>,\n                               candidate: &SelectionCandidate<'tcx>)\n-                              -> EvaluationResult\n+                              -> Result<EvaluationResult, OverflowError>\n     {\n         debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n                stack.obligation.recursion_depth, candidate);\n@@ -921,12 +976,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         stack.list(),\n                         selection.nested_obligations().iter())\n                 }\n-                Err(..) => EvaluatedToErr\n+                Err(..) => Ok(EvaluatedToErr)\n             }\n-        });\n+        })?;\n         debug!(\"evaluate_candidate: depth={} result={:?}\",\n                stack.obligation.recursion_depth, result);\n-        result\n+        Ok(result)\n     }\n \n     fn check_evaluation_cache(&self,\n@@ -1000,7 +1055,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            self.infcx().report_overflow_error(&stack.obligation, true);\n+            match self.query_mode {\n+                TraitQueryMode::Standard => {\n+                    self.infcx().report_overflow_error(&stack.obligation, true);\n+                },\n+                TraitQueryMode::Canonical => {\n+                    return Err(Overflow);\n+                },\n+            }\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -1081,9 +1143,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n                     // Heuristics: show the diagnostics when there are no candidates in crate.\n                     if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                        if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n-                            !self.evaluate_candidate(stack, &c).may_apply()\n-                        }) {\n+                        let no_candidates_apply =\n+                            candidate_set\n+                            .vec\n+                            .iter()\n+                            .map(|c| self.evaluate_candidate(stack, &c))\n+                            .collect::<Result<Vec<_>, OverflowError>>()?\n+                            .iter()\n+                            .all(|r| !r.may_apply());\n+                        if !candidate_set.ambiguous && no_candidates_apply {\n                             let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                             let self_ty = trait_ref.self_ty();\n                             let trait_desc = trait_ref.to_string();\n@@ -1151,18 +1219,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization.\n-        let mut candidates: Vec<_> = candidates.into_iter().filter_map(|c| {\n-            let eval = self.evaluate_candidate(stack, &c);\n-            if eval.may_apply() {\n-                Some(EvaluatedCandidate {\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let candidates: Result<Vec<Option<EvaluatedCandidate>>, _> = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => Ok(Some(EvaluatedCandidate {\n                     candidate: c,\n                     evaluation: eval,\n-                })\n-            } else {\n-                None\n-            }\n-        }).collect();\n+                })),\n+                Ok(_) => Ok(None),\n+                Err(OverflowError) => Err(Overflow),\n+            })\n+            .collect();\n+\n+        let mut candidates: Vec<EvaluatedCandidate> =\n+            candidates?.into_iter().filter_map(|c| c).collect();\n \n         // If there are STILL multiple candidate, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -1537,12 +1608,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n \n-        let matching_bounds =\n-            matching_bounds.filter(\n-                |bound| self.evaluate_where_clause(stack, bound.clone()).may_apply());\n-\n-        let param_candidates =\n-            matching_bounds.map(|bound| ParamCandidate(bound));\n+        // keep only those bounds which may apply, and propagate overflow if it occurs\n+        let mut param_candidates = vec![];\n+        for bound in matching_bounds {\n+            let wc = self.evaluate_where_clause(stack, bound.clone())?;\n+            if wc.may_apply() {\n+                param_candidates.push(ParamCandidate(bound));\n+            }\n+        }\n \n         candidates.vec.extend(param_candidates);\n \n@@ -1552,14 +1625,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_where_clause<'o>(&mut self,\n                                  stack: &TraitObligationStack<'o, 'tcx>,\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                 -> EvaluationResult\n+                                 -> Result<EvaluationResult, OverflowError>\n     {\n         self.probe(move |this, _| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n-                Err(()) => EvaluatedToErr\n+                Err(()) => Ok(EvaluatedToErr)\n             }\n         })\n     }"}, {"sha": "d7e42655bbb5be35eca4e6b14c757a7778c0a167", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -177,6 +177,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::ConstEvalFailure(ref err) => {\n                 tcx.lift(err).map(super::ConstEvalFailure)\n             }\n+            super::Overflow => bug!() // FIXME: ape ConstEvalFailure?\n         }\n     }\n }"}, {"sha": "1fd0632580cfc018ff96ac478533a84ec6ba9f42", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -11,7 +11,7 @@\n use dep_graph::SerializedDepNodeIndex;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n@@ -73,6 +73,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_region\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalPredicateGoal<'tcx>) -> String {\n+        format!(\"evaluating trait selection obligation `{}`\", goal.value.value)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)"}, {"sha": "da29f23589e85e7a5f464cc5d325d1fbc8b49787", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -11,7 +11,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -200,3 +200,13 @@ impl<'tcx> Key for CanonicalTyGoal<'tcx> {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for CanonicalPredicateGoal<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "cb929225bcdcfd59486b8bf8d4eccc94786885a2", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -32,8 +32,9 @@ use mir;\n use mir::interpret::{GlobalId};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n-use traits::Vtable;\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n+use traits::{self, Vtable};\n+use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal,\n+                    CanonicalTyGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n@@ -433,6 +434,12 @@ define_maps! { <'tcx>\n         NoSolution,\n     >,\n \n+    /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n+    /// `infcx.predicate_must_hold()` instead.\n+    [] fn evaluate_obligation: EvaluateObligation(\n+        CanonicalPredicateGoal<'tcx>\n+    ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n+\n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n "}, {"sha": "1cde745d4d87f4d19851a1a49270de7dca087ad8", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -977,6 +977,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n         DepKind::DropckOutlives |\n+        DepKind::EvaluateObligation |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::InstanceDefSizeEstimate |\n         DepKind::ProgramClausesForEnv |"}, {"sha": "21259bbcd38ff9df779a2e9d7923079e05126fe7", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::traits::{EvaluationResult, Obligation, ObligationCause,\n+                    OverflowError, SelectionContext, TraitQueryMode};\n+use rustc::traits::query::CanonicalPredicateGoal;\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n+use syntax::codemap::DUMMY_SP;\n+\n+crate fn evaluate_obligation<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalPredicateGoal<'tcx>,\n+) -> Result<EvaluationResult, OverflowError> {\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let (\n+            ParamEnvAnd {\n+                param_env,\n+                value: predicate,\n+            },\n+            _canonical_inference_vars,\n+        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+\n+        let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n+        let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+\n+        selcx.evaluate_obligation_recursively(&obligation)\n+    })\n+}"}, {"sha": "7f18fac2db5a3a5b8996c722c6959492ac4302c1", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -22,6 +22,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n mod dropck_outlives;\n+mod evaluate_obligation;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n mod util;\n@@ -38,6 +39,7 @@ pub fn provide(p: &mut Providers) {\n             normalize_erasing_regions::normalize_ty_after_erasing_regions,\n         program_clauses_for: lowering::program_clauses_for,\n         program_clauses_for_env: lowering::program_clauses_for_env,\n+        evaluate_obligation: evaluate_obligation::evaluate_obligation,\n         ..*p\n     };\n }"}, {"sha": "3199ff17ae92697558cb3d699e1b7d60c8a4fb61", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -120,15 +120,15 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx);\n         let obligation = traits::Obligation::new(cause.clone(),\n                                                  self.fcx.param_env,\n                                                  trait_ref.to_predicate());\n-        if !selcx.evaluate_obligation(&obligation) {\n+        if !self.fcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;\n         }\n \n+        let mut selcx = traits::SelectionContext::new(self.fcx);\n         let normalized = traits::normalize_projection_type(&mut selcx,\n                                                            self.fcx.param_env,\n                                                            ty::ProjectionTy::from_ref_and_name("}, {"sha": "5f904a9419b1d6b85caf708d4460d5cd6682a428", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -277,8 +277,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      poly_trait_ref.to_predicate());\n \n         // Now we want to know if this can be matched\n-        let mut selcx = traits::SelectionContext::new(self);\n-        if !selcx.evaluate_obligation(&obligation) {\n+        if !self.predicate_may_hold(&obligation) {\n             debug!(\"--> Cannot match obligation\");\n             return None; // Cannot be matched, no such method resolution is possible.\n         }"}, {"sha": "476ae6809737a33eeaa05c4713ed63491052b405", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -1173,7 +1173,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     let predicate = trait_ref.to_predicate();\n                     let obligation =\n                         traits::Obligation::new(cause.clone(), self.param_env, predicate);\n-                    if !selcx.evaluate_obligation(&obligation) {\n+                    if !self.predicate_may_hold(&obligation) {\n                         if self.probe(|_| self.select_trait_candidate(trait_ref).is_err()) {\n                             // This candidate's primary obligation doesn't even\n                             // select - don't bother registering anything in\n@@ -1201,7 +1201,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // Evaluate those obligations to see if they might possibly hold.\n             for o in candidate_obligations.into_iter().chain(sub_obligations) {\n                 let o = self.resolve_type_vars_if_possible(&o);\n-                if !selcx.evaluate_obligation(&o) {\n+                if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n                         possibly_unsatisfied_predicates.push(pred.skip_binder().trait_ref);"}, {"sha": "2dc7c7fe71a89e7b2e08507541cf4b264e22caf5", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -19,7 +19,7 @@ use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use namespace::Namespace;\n-use rustc::traits::{Obligation, SelectionContext};\n+use rustc::traits::Obligation;\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n@@ -65,7 +65,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              self.body_id,\n                                              self.param_env,\n                                              poly_trait_ref.to_predicate());\n-                        SelectionContext::new(self).evaluate_obligation(&obligation)\n+                        self.predicate_may_hold(&obligation)\n                     })\n                 })\n             }"}, {"sha": "fc365a4b9aaeefa10bb5fb9e6fa39ed761f8c447", "filename": "src/test/compile-fail/issue-23080-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-tidy-linelength\n \n+//~^^^^^^^^^^^^ ERROR\n+\n #![feature(optin_builtin_traits)]\n \n unsafe auto trait Trait {\n@@ -22,5 +24,4 @@ fn call_method<T: Trait>(x: T) {}\n fn main() {\n     // ICE\n     call_method(());\n-    //~^ ERROR\n }"}, {"sha": "efa9a58d6331036e1f634923a141f120a32d8d43", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09bc6a77a908b11120cb09e6d2bf0b7a13494e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=8a09bc6a77a908b11120cb09e6d2bf0b7a13494e", "patch": "@@ -34,6 +34,7 @@ error[E0391]: cycle detected when processing `cycle1`\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n note: ...which requires processing `cycle2::{{impl-Trait}}`...\n   --> $DIR/auto-trait-leak.rs:49:16\n    |\n@@ -44,6 +45,7 @@ note: ...which requires processing `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n note: ...which requires processing `cycle1::{{impl-Trait}}`...\n   --> $DIR/auto-trait-leak.rs:42:16\n    |"}]}