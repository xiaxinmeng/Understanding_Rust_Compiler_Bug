{"sha": "88e8b0a5fa17075475c75941932056f7289c5bcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZThiMGE1ZmExNzA3NTQ3NWM3NTk0MTkzMjA1NmY3Mjg5YzViY2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-16T14:01:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-16T14:01:09Z"}, "message": "Merge #7620\n\n7620: Support control flow in `extract_function` assist r=matklad a=cpud36\n\nSupport `return`ing from outer function, `break`ing and `continue`ing outer loops when extracting function.\r\n\r\n# Example\r\nTransforms\r\n```rust\r\nfn foo() -> i32 {\r\n  let items = [1,2,3];\r\n  let mut sum = 0;\r\n  for &item in items {\r\n    <|>if item == 42 {\r\n      break;\r\n    }<|>\r\n    sum += item;\r\n  }\r\n  sum\r\n}\r\n```\r\nInto \r\n```rust\r\nfn foo() -> i32 {\r\n  let items = [1,2,3];\r\n  let mut sum = 0;\r\n  for &item in items {\r\n    if fun_name(item) {\r\n      break;\r\n    }\r\n    sum += item;\r\n  }\r\n  sum\r\n}\r\n\r\nfn fun_name(item: i32) -> bool {\r\n  if item == 42 {\r\n    return true;\r\n  }\r\n  false\r\n}\r\n```\r\n\r\n![add_explicit_type_infer_type](https://user-images.githubusercontent.com/4218373/107544222-0fadf280-6bdb-11eb-9625-ed6194ba92c0.gif)\r\n\r\n# Features\r\n\r\nSupported variants\r\n- break and function does not return => uses `bool` and plain if\r\n- break and function does return => uses `Option<T>` and matches on it\r\n- break with value and function does not return => uses `Option<T>` and if let\r\n- break with value and function does return => uses `Result<T, U>` and matches on t\r\n- same for `return` and `continue`(but we can't continue with value)\r\n\r\nAssist does handle nested loops and nested items(like functions, modules, impls)\r\n\r\nTry `expr?` operator is allowed together with `return Err(_)` and `return None`.\r\n`return expr` is not allowed.\r\n\r\n# Not supported\r\n## Mixing `return` with `break` or `continue`\r\nIf we have e.g. a `return` and a `break` in the selected code, it is unclear what the produced code should look like.\r\nWe can try `Result<T, Option<U>>` or something like that, but it isn't idiomatic, nor it is established. Otherwise, implementation\r\nis relatively simple.\r\n\r\n## `break` with label\r\nNot sure how to handle different labels for multiple `break`s.\r\n\r\n[edit] implemented try `expr?`\n\nCo-authored-by: Vladyslav Katasonov <cpud47@gmail.com>", "tree": {"sha": "84889038ca64a9ee4775ecf5605ed0213b90a0b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84889038ca64a9ee4775ecf5605ed0213b90a0b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88e8b0a5fa17075475c75941932056f7289c5bcf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgK9AlCRBK7hj4Ov3rIwAAdHIIAFhsvDc3/WrtUFKI1n8URpqn\n7bRfQ80piG+ZFAGBmwpyaEETAtfuK0BGjcQTYdhBL/ECN1bLp5tm3bwz25K/chwx\nFpLKPPYuD+L5lLOQg8rwLMetqgGjVRwXpA8Eg1nB7og7Xl113w2zN3PKQHp8OX9a\nkQK/y0Y6qBji+YgLbj/7VywC2yUdN5BTRN7v1xZPnQymgd5KY7r54mqLJz2AaRWO\nO09zKHcj5KAr/WO3C5H5zxroTLBv38gw+NRhDPzAQRd8JKFfvfLuAoDnvRkUt8HM\nIJyoSHBOGPztPKxVJR9mKvHaFjxHeKY/tDsUiOs09fJXRfPWYI24uJYTF0crLmg=\n=1DZo\n-----END PGP SIGNATURE-----\n", "payload": "tree 84889038ca64a9ee4775ecf5605ed0213b90a0b7\nparent 00d5a9563af9c84cdea9d029a9583be0513cc459\nparent 37a8cec6386d57e76b3067af48c78867aa9922ed\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1613484069 +0000\ncommitter GitHub <noreply@github.com> 1613484069 +0000\n\nMerge #7620\n\n7620: Support control flow in `extract_function` assist r=matklad a=cpud36\n\nSupport `return`ing from outer function, `break`ing and `continue`ing outer loops when extracting function.\r\n\r\n# Example\r\nTransforms\r\n```rust\r\nfn foo() -> i32 {\r\n  let items = [1,2,3];\r\n  let mut sum = 0;\r\n  for &item in items {\r\n    <|>if item == 42 {\r\n      break;\r\n    }<|>\r\n    sum += item;\r\n  }\r\n  sum\r\n}\r\n```\r\nInto \r\n```rust\r\nfn foo() -> i32 {\r\n  let items = [1,2,3];\r\n  let mut sum = 0;\r\n  for &item in items {\r\n    if fun_name(item) {\r\n      break;\r\n    }\r\n    sum += item;\r\n  }\r\n  sum\r\n}\r\n\r\nfn fun_name(item: i32) -> bool {\r\n  if item == 42 {\r\n    return true;\r\n  }\r\n  false\r\n}\r\n```\r\n\r\n![add_explicit_type_infer_type](https://user-images.githubusercontent.com/4218373/107544222-0fadf280-6bdb-11eb-9625-ed6194ba92c0.gif)\r\n\r\n# Features\r\n\r\nSupported variants\r\n- break and function does not return => uses `bool` and plain if\r\n- break and function does return => uses `Option<T>` and matches on it\r\n- break with value and function does not return => uses `Option<T>` and if let\r\n- break with value and function does return => uses `Result<T, U>` and matches on t\r\n- same for `return` and `continue`(but we can't continue with value)\r\n\r\nAssist does handle nested loops and nested items(like functions, modules, impls)\r\n\r\nTry `expr?` operator is allowed together with `return Err(_)` and `return None`.\r\n`return expr` is not allowed.\r\n\r\n# Not supported\r\n## Mixing `return` with `break` or `continue`\r\nIf we have e.g. a `return` and a `break` in the selected code, it is unclear what the produced code should look like.\r\nWe can try `Result<T, Option<U>>` or something like that, but it isn't idiomatic, nor it is established. Otherwise, implementation\r\nis relatively simple.\r\n\r\n## `break` with label\r\nNot sure how to handle different labels for multiple `break`s.\r\n\r\n[edit] implemented try `expr?`\n\nCo-authored-by: Vladyslav Katasonov <cpud47@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88e8b0a5fa17075475c75941932056f7289c5bcf", "html_url": "https://github.com/rust-lang/rust/commit/88e8b0a5fa17075475c75941932056f7289c5bcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88e8b0a5fa17075475c75941932056f7289c5bcf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00d5a9563af9c84cdea9d029a9583be0513cc459", "url": "https://api.github.com/repos/rust-lang/rust/commits/00d5a9563af9c84cdea9d029a9583be0513cc459", "html_url": "https://github.com/rust-lang/rust/commit/00d5a9563af9c84cdea9d029a9583be0513cc459"}, {"sha": "37a8cec6386d57e76b3067af48c78867aa9922ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a8cec6386d57e76b3067af48c78867aa9922ed", "html_url": "https://github.com/rust-lang/rust/commit/37a8cec6386d57e76b3067af48c78867aa9922ed"}], "stats": {"total": 1772, "additions": 1525, "deletions": 247}, "files": [{"sha": "6b87c3c05724cf0898d1150d388426a15a69f1df", "filename": "crates/assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=88e8b0a5fa17075475c75941932056f7289c5bcf", "patch": "@@ -88,7 +88,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n \n     let early_expression: ast::Expr = match parent_container.kind() {\n         WHILE_EXPR | LOOP_EXPR => make::expr_continue(),\n-        FN => make::expr_return(),\n+        FN => make::expr_return(None),\n         _ => return None,\n     };\n "}, {"sha": "9f34cc7250fbc0b4bc6e4d0194f4b6d69d98f144", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1453, "deletions": 234, "changes": 1687, "blob_url": "https://github.com/rust-lang/rust/blob/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=88e8b0a5fa17075475c75941932056f7289c5bcf", "patch": "@@ -1,3 +1,6 @@\n+use std::iter;\n+\n+use ast::make;\n use either::Either;\n use hir::{HirDisplay, Local};\n use ide_db::{\n@@ -13,9 +16,9 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n-    AstToken, Direction, SyntaxElement,\n+    SyntaxElement,\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n-    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n use test_utils::mark;\n \n@@ -81,11 +84,9 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         // We should not have variables that outlive body if we have expression block\n         return None;\n     }\n+    let control_flow = external_control_flow(ctx, &body)?;\n \n-    let target_range = match &body {\n-        FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-        FunctionBody::Span { .. } => ctx.frange.range,\n-    };\n+    let target_range = body.text_range();\n \n     acc.add(\n         AssistId(\"extract_function\", crate::AssistKind::RefactorExtract),\n@@ -98,28 +99,158 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 name: \"fun_name\".to_string(),\n                 self_param: self_param.map(|(_, pat)| pat),\n                 params,\n+                control_flow,\n                 ret_ty,\n                 body,\n                 vars_defined_in_body_and_outlive,\n             };\n \n-            builder.replace(target_range, format_replacement(ctx, &fun));\n-\n             let new_indent = IndentLevel::from_node(&insert_after);\n             let old_indent = fun.body.indent_level();\n \n+            builder.replace(target_range, format_replacement(ctx, &fun, old_indent));\n+\n             let fn_def = format_function(ctx, module, &fun, old_indent, new_indent);\n             let insert_offset = insert_after.text_range().end();\n             builder.insert(insert_offset, fn_def);\n         },\n     )\n }\n \n+fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n+    let mut ret_expr = None;\n+    let mut try_expr = None;\n+    let mut break_expr = None;\n+    let mut continue_expr = None;\n+    let (syntax, text_range) = match body {\n+        FunctionBody::Expr(expr) => (expr.syntax(), expr.syntax().text_range()),\n+        FunctionBody::Span { parent, text_range } => (parent.syntax(), *text_range),\n+    };\n+\n+    let mut nested_loop = None;\n+    let mut nested_scope = None;\n+\n+    for e in syntax.preorder() {\n+        let e = match e {\n+            WalkEvent::Enter(e) => e,\n+            WalkEvent::Leave(e) => {\n+                if nested_loop.as_ref() == Some(&e) {\n+                    nested_loop = None;\n+                }\n+                if nested_scope.as_ref() == Some(&e) {\n+                    nested_scope = None;\n+                }\n+                continue;\n+            }\n+        };\n+        if nested_scope.is_some() {\n+            continue;\n+        }\n+        if !text_range.contains_range(e.text_range()) {\n+            continue;\n+        }\n+        match e.kind() {\n+            SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n+                if nested_loop.is_none() {\n+                    nested_loop = Some(e);\n+                }\n+            }\n+            SyntaxKind::FN\n+            | SyntaxKind::CONST\n+            | SyntaxKind::STATIC\n+            | SyntaxKind::IMPL\n+            | SyntaxKind::MODULE => {\n+                if nested_scope.is_none() {\n+                    nested_scope = Some(e);\n+                }\n+            }\n+            SyntaxKind::RETURN_EXPR => {\n+                ret_expr = Some(ast::ReturnExpr::cast(e).unwrap());\n+            }\n+            SyntaxKind::TRY_EXPR => {\n+                try_expr = Some(ast::TryExpr::cast(e).unwrap());\n+            }\n+            SyntaxKind::BREAK_EXPR if nested_loop.is_none() => {\n+                break_expr = Some(ast::BreakExpr::cast(e).unwrap());\n+            }\n+            SyntaxKind::CONTINUE_EXPR if nested_loop.is_none() => {\n+                continue_expr = Some(ast::ContinueExpr::cast(e).unwrap());\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n+        (Some(e), None, None, None) => {\n+            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n+            let def = ctx.sema.to_def(&func)?;\n+            let ret_ty = def.ret_type(ctx.db());\n+            let kind = try_kind_of_ty(ret_ty, ctx)?;\n+\n+            Some(FlowKind::Try { kind })\n+        }\n+        (Some(_), Some(r), None, None) => match r.expr() {\n+            Some(expr) => {\n+                if let Some(kind) = expr_err_kind(&expr, ctx) {\n+                    Some(FlowKind::TryReturn { expr, kind })\n+                } else {\n+                    mark::hit!(external_control_flow_try_and_return_non_err);\n+                    return None;\n+                }\n+            }\n+            None => return None,\n+        },\n+        (Some(_), _, _, _) => {\n+            mark::hit!(external_control_flow_try_and_bc);\n+            return None;\n+        }\n+        (None, Some(r), None, None) => match r.expr() {\n+            Some(expr) => Some(FlowKind::ReturnValue(expr)),\n+            None => Some(FlowKind::Return),\n+        },\n+        (None, Some(_), _, _) => {\n+            mark::hit!(external_control_flow_return_and_bc);\n+            return None;\n+        }\n+        (None, None, Some(_), Some(_)) => {\n+            mark::hit!(external_control_flow_break_and_continue);\n+            return None;\n+        }\n+        (None, None, Some(b), None) => match b.expr() {\n+            Some(expr) => Some(FlowKind::BreakValue(expr)),\n+            None => Some(FlowKind::Break),\n+        },\n+        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+        (None, None, None, None) => None,\n+    };\n+\n+    Some(ControlFlow { kind })\n+}\n+\n+/// Checks is expr is `Err(_)` or `None`\n+fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n+    let func_name = match expr {\n+        ast::Expr::CallExpr(call_expr) => call_expr.expr()?,\n+        ast::Expr::PathExpr(_) => expr.clone(),\n+        _ => return None,\n+    };\n+    let text = func_name.syntax().text();\n+\n+    if text == \"Err\" {\n+        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n+    } else if text == \"None\" {\n+        Some(TryKind::Option)\n+    } else {\n+        None\n+    }\n+}\n+\n #[derive(Debug)]\n struct Function {\n     name: String,\n     self_param: Option<ast::SelfParam>,\n     params: Vec<Param>,\n+    control_flow: ControlFlow,\n     ret_ty: RetType,\n     body: FunctionBody,\n     vars_defined_in_body_and_outlive: Vec<Local>,\n@@ -134,6 +265,11 @@ struct Param {\n     is_copy: bool,\n }\n \n+#[derive(Debug)]\n+struct ControlFlow {\n+    kind: Option<FlowKind>,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ParamKind {\n     Value,\n@@ -142,6 +278,30 @@ enum ParamKind {\n     MutRef,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n+enum FunType {\n+    Unit,\n+    Single(hir::Type),\n+    Tuple(Vec<hir::Type>),\n+}\n+\n+impl Function {\n+    fn return_type(&self, ctx: &AssistContext) -> FunType {\n+        match &self.ret_ty {\n+            RetType::Expr(ty) if ty.is_unit() => FunType::Unit,\n+            RetType::Expr(ty) => FunType::Single(ty.clone()),\n+            RetType::Stmt => match self.vars_defined_in_body_and_outlive.as_slice() {\n+                [] => FunType::Unit,\n+                [var] => FunType::Single(var.ty(ctx.db())),\n+                vars => {\n+                    let types = vars.iter().map(|v| v.ty(ctx.db())).collect();\n+                    FunType::Tuple(types)\n+                }\n+            },\n+        }\n+    }\n+}\n+\n impl ParamKind {\n     fn is_ref(&self) -> bool {\n         matches!(self, ParamKind::SharedRef | ParamKind::MutRef)\n@@ -158,30 +318,121 @@ impl Param {\n         }\n     }\n \n-    fn value_prefix(&self) -> &'static str {\n+    fn to_arg(&self, ctx: &AssistContext) -> ast::Expr {\n+        let var = path_expr_from_local(ctx, self.var);\n         match self.kind() {\n-            ParamKind::Value | ParamKind::MutValue => \"\",\n-            ParamKind::SharedRef => \"&\",\n-            ParamKind::MutRef => \"&mut \",\n+            ParamKind::Value | ParamKind::MutValue => var,\n+            ParamKind::SharedRef => make::expr_ref(var, false),\n+            ParamKind::MutRef => make::expr_ref(var, true),\n         }\n     }\n \n-    fn type_prefix(&self) -> &'static str {\n-        match self.kind() {\n-            ParamKind::Value | ParamKind::MutValue => \"\",\n-            ParamKind::SharedRef => \"&\",\n-            ParamKind::MutRef => \"&mut \",\n+    fn to_param(&self, ctx: &AssistContext, module: hir::Module) -> ast::Param {\n+        let var = self.var.name(ctx.db()).unwrap().to_string();\n+        let var_name = make::name(&var);\n+        let pat = match self.kind() {\n+            ParamKind::MutValue => make::ident_mut_pat(var_name),\n+            ParamKind::Value | ParamKind::SharedRef | ParamKind::MutRef => {\n+                make::ident_pat(var_name)\n+            }\n+        };\n+\n+        let ty = make_ty(&self.ty, ctx, module);\n+        let ty = match self.kind() {\n+            ParamKind::Value | ParamKind::MutValue => ty,\n+            ParamKind::SharedRef => make::ty_ref(ty, false),\n+            ParamKind::MutRef => make::ty_ref(ty, true),\n+        };\n+\n+        make::param(pat.into(), ty)\n+    }\n+}\n+\n+/// Control flow that is exported from extracted function\n+///\n+/// E.g.:\n+/// ```rust,no_run\n+/// loop {\n+///     $0\n+///     if 42 == 42 {\n+///         break;\n+///     }\n+///     $0\n+/// }\n+/// ```\n+#[derive(Debug, Clone)]\n+enum FlowKind {\n+    /// Return without value (`return;`)\n+    Return,\n+    /// Return with value (`return $expr;`)\n+    ReturnValue(ast::Expr),\n+    Try {\n+        kind: TryKind,\n+    },\n+    TryReturn {\n+        expr: ast::Expr,\n+        kind: TryKind,\n+    },\n+    /// Break without value (`return;`)\n+    Break,\n+    /// Break with value (`break $expr;`)\n+    BreakValue(ast::Expr),\n+    /// Continue\n+    Continue,\n+}\n+\n+#[derive(Debug, Clone)]\n+enum TryKind {\n+    Option,\n+    Result { ty: hir::Type },\n+}\n+\n+impl FlowKind {\n+    fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n+        match self {\n+            FlowKind::Return | FlowKind::ReturnValue(_) => make::expr_return(expr),\n+            FlowKind::Break | FlowKind::BreakValue(_) => make::expr_break(expr),\n+            FlowKind::Try { .. } | FlowKind::TryReturn { .. } => {\n+                stdx::never!(\"cannot have result handler with try\");\n+                expr.unwrap_or_else(|| make::expr_return(None))\n+            }\n+            FlowKind::Continue => {\n+                stdx::always!(expr.is_none(), \"continue with value is not possible\");\n+                make::expr_continue()\n+            }\n         }\n     }\n \n-    fn mut_pattern(&self) -> &'static str {\n-        match self.kind() {\n-            ParamKind::MutValue => \"mut \",\n-            _ => \"\",\n+    fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n+        match self {\n+            FlowKind::ReturnValue(expr)\n+            | FlowKind::BreakValue(expr)\n+            | FlowKind::TryReturn { expr, .. } => ctx.sema.type_of_expr(expr),\n+            FlowKind::Try { .. } => {\n+                stdx::never!(\"try does not have defined expr_ty\");\n+                None\n+            }\n+            FlowKind::Return | FlowKind::Break | FlowKind::Continue => None,\n         }\n     }\n }\n \n+fn try_kind_of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n+    if ty.is_unknown() {\n+        // We favour Result for `expr?`\n+        return Some(TryKind::Result { ty });\n+    }\n+    let adt = ty.as_adt()?;\n+    let name = adt.name(ctx.db());\n+    // FIXME: use lang items to determine if it is std type or user defined\n+    //        E.g. if user happens to define type named `Option`, we would have false positive\n+    match name.to_string().as_str() {\n+        \"Option\" => Some(TryKind::Option),\n+        \"Result\" => Some(TryKind::Result { ty }),\n+        _ => None,\n+    }\n+}\n+\n #[derive(Debug)]\n enum RetType {\n     Expr(hir::Type),\n@@ -195,21 +446,13 @@ impl RetType {\n             RetType::Stmt => true,\n         }\n     }\n-\n-    fn as_fn_ret(&self) -> Option<&hir::Type> {\n-        match self {\n-            RetType::Stmt => None,\n-            RetType::Expr(ty) if ty.is_unit() => None,\n-            RetType::Expr(ty) => Some(ty),\n-        }\n-    }\n }\n \n /// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n #[derive(Debug)]\n enum FunctionBody {\n     Expr(ast::Expr),\n-    Span { elements: Vec<SyntaxElement>, leading_indent: String },\n+    Span { parent: ast::BlockExpr, text_range: TextRange },\n }\n \n impl FunctionBody {\n@@ -226,81 +469,48 @@ impl FunctionBody {\n         }\n     }\n \n-    fn from_range(node: &SyntaxNode, range: TextRange) -> Option<FunctionBody> {\n-        let mut first = node.token_at_offset(range.start()).left_biased()?;\n-        let last = node.token_at_offset(range.end()).right_biased()?;\n-\n-        let mut leading_indent = String::new();\n-\n-        let leading_trivia = first\n-            .siblings_with_tokens(Direction::Prev)\n-            .skip(1)\n-            .take_while(|e| e.kind() == SyntaxKind::WHITESPACE && e.as_token().is_some());\n-\n-        for e in leading_trivia {\n-            let token = e.as_token().unwrap();\n-            let text = token.text();\n-            match text.rfind('\\n') {\n-                Some(pos) => {\n-                    leading_indent = text[pos..].to_owned();\n-                    break;\n-                }\n-                None => first = token.clone(),\n-            }\n-        }\n-\n-        let mut elements: Vec<_> = first\n-            .siblings_with_tokens(Direction::Next)\n-            .take_while(|e| e.as_token() != Some(&last))\n-            .collect();\n-\n-        if !(last.kind() == SyntaxKind::WHITESPACE && last.text().lines().count() <= 2) {\n-            elements.push(last.into());\n-        }\n-\n-        Some(FunctionBody::Span { elements, leading_indent })\n+    fn from_range(node: SyntaxNode, text_range: TextRange) -> Option<FunctionBody> {\n+        let block = ast::BlockExpr::cast(node)?;\n+        Some(Self::Span { parent: block, text_range })\n     }\n \n     fn indent_level(&self) -> IndentLevel {\n         match &self {\n             FunctionBody::Expr(expr) => IndentLevel::from_node(expr.syntax()),\n-            FunctionBody::Span { elements, .. } => elements\n-                .iter()\n-                .filter_map(SyntaxElement::as_node)\n-                .map(IndentLevel::from_node)\n-                .min_by_key(|level| level.0)\n-                .expect(\"body must contain at least one node\"),\n+            FunctionBody::Span { parent, .. } => IndentLevel::from_node(parent.syntax()) + 1,\n         }\n     }\n \n     fn tail_expr(&self) -> Option<ast::Expr> {\n         match &self {\n             FunctionBody::Expr(expr) => Some(expr.clone()),\n-            FunctionBody::Span { elements, .. } => {\n-                elements.iter().rev().find_map(|e| e.as_node()).cloned().and_then(ast::Expr::cast)\n+            FunctionBody::Span { parent, text_range } => {\n+                let tail_expr = parent.tail_expr()?;\n+                if text_range.contains_range(tail_expr.syntax().text_range()) {\n+                    Some(tail_expr)\n+                } else {\n+                    None\n+                }\n             }\n         }\n     }\n \n     fn descendants(&self) -> impl Iterator<Item = SyntaxNode> + '_ {\n         match self {\n             FunctionBody::Expr(expr) => Either::Right(expr.syntax().descendants()),\n-            FunctionBody::Span { elements, .. } => Either::Left(\n-                elements\n-                    .iter()\n-                    .filter_map(SyntaxElement::as_node)\n-                    .flat_map(SyntaxNode::descendants),\n+            FunctionBody::Span { parent, text_range } => Either::Left(\n+                parent\n+                    .syntax()\n+                    .descendants()\n+                    .filter(move |it| text_range.contains_range(it.text_range())),\n             ),\n         }\n     }\n \n     fn text_range(&self) -> TextRange {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-            FunctionBody::Span { elements, .. } => TextRange::new(\n-                elements.first().unwrap().text_range().start(),\n-                elements.last().unwrap().text_range().end(),\n-            ),\n+            FunctionBody::Span { parent: _, text_range } => *text_range,\n         }\n     }\n \n@@ -321,30 +531,27 @@ impl HasTokenAtOffset for FunctionBody {\n     fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n-            FunctionBody::Span { elements, .. } => {\n-                stdx::always!(self.text_range().contains(offset));\n-                let mut iter = elements\n-                    .iter()\n-                    .filter(|element| element.text_range().contains_inclusive(offset));\n-                let element1 = iter.next().expect(\"offset does not fall into body\");\n-                let element2 = iter.next();\n-                stdx::always!(iter.next().is_none(), \"> 2 tokens at offset\");\n-                let t1 = match element1 {\n-                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n-                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n-                };\n-                let t2 = element2.map(|e| match e {\n-                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n-                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n-                });\n-\n-                match t2 {\n-                    Some(t2) => match (t1.clone().right_biased(), t2.clone().left_biased()) {\n-                        (Some(e1), Some(e2)) => TokenAtOffset::Between(e1, e2),\n-                        (Some(_), None) => t1,\n-                        (None, _) => t2,\n-                    },\n-                    None => t1,\n+            FunctionBody::Span { parent, text_range } => {\n+                match parent.syntax().token_at_offset(offset) {\n+                    TokenAtOffset::None => TokenAtOffset::None,\n+                    TokenAtOffset::Single(t) => {\n+                        if text_range.contains_range(t.text_range()) {\n+                            TokenAtOffset::Single(t)\n+                        } else {\n+                            TokenAtOffset::None\n+                        }\n+                    }\n+                    TokenAtOffset::Between(a, b) => {\n+                        match (\n+                            text_range.contains_range(a.text_range()),\n+                            text_range.contains_range(b.text_range()),\n+                        ) {\n+                            (true, true) => TokenAtOffset::Between(a, b),\n+                            (true, false) => TokenAtOffset::Single(a),\n+                            (false, true) => TokenAtOffset::Single(b),\n+                            (false, false) => TokenAtOffset::None,\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -389,7 +596,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // we have selected a few statements in a block\n     // so covering_element returns the whole block\n     if node.kind() == BLOCK_EXPR {\n-        let body = FunctionBody::from_range(&node, selection_range);\n+        let body = FunctionBody::from_range(node.clone(), selection_range);\n         if body.is_some() {\n             return body;\n         }\n@@ -400,7 +607,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // so we try to expand covering_element to parent and repeat the previous\n     if let Some(parent) = node.parent() {\n         if parent.kind() == BLOCK_EXPR {\n-            let body = FunctionBody::from_range(&parent, selection_range);\n+            let body = FunctionBody::from_range(parent, selection_range);\n             if body.is_some() {\n                 return body;\n             }\n@@ -642,13 +849,9 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n \n /// checks if local variable is used after(outside of) body\n fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n-    let usages = Definition::Local(*var)\n-        .usages(&ctx.sema)\n-        .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-        .all();\n-    let mut usages = usages.iter().flat_map(|(_, rs)| rs.iter());\n-\n-    usages.any(|reference| body.preceedes_range(reference.range))\n+    let usages = LocalUsages::find(ctx, *var);\n+    let has_usages = usages.iter().any(|reference| body.preceedes_range(reference.range));\n+    has_usages\n }\n \n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n@@ -675,10 +878,7 @@ enum Anchor {\n fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n     match body {\n         FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n-        FunctionBody::Span { elements, .. } => {\n-            let node = elements.iter().find_map(|e| e.as_node())?;\n-            scope_for_fn_insertion_node(&node, anchor)\n-        }\n+        FunctionBody::Span { parent, .. } => scope_for_fn_insertion_node(parent.syntax(), anchor),\n     }\n }\n \n@@ -711,9 +911,24 @@ fn scope_for_fn_insertion_node(node: &SyntaxNode, anchor: Anchor) -> Option<Synt\n     last_ancestor\n }\n \n-fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n-    let mut buf = String::new();\n+fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String {\n+    let ret_ty = fun.return_type(ctx);\n+\n+    let args = fun.params.iter().map(|param| param.to_arg(ctx));\n+    let args = make::arg_list(args);\n+    let call_expr = if fun.self_param.is_some() {\n+        let self_arg = make::expr_path(make_path_from_text(\"self\"));\n+        make::expr_method_call(self_arg, &fun.name, args)\n+    } else {\n+        let func = make::expr_path(make_path_from_text(&fun.name));\n+        make::expr_call(func, args)\n+    };\n \n+    let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n+\n+    let expr = handler.make_call_expr(call_expr).indent(indent);\n+\n+    let mut buf = String::new();\n     match fun.vars_defined_in_body_and_outlive.as_slice() {\n         [] => {}\n         [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n@@ -726,34 +941,131 @@ fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n             buf.push_str(\") = \");\n         }\n     }\n-\n-    if fun.self_param.is_some() {\n-        format_to!(buf, \"self.\");\n-    }\n-    format_to!(buf, \"{}(\", fun.name);\n-    format_arg_list_to(&mut buf, fun, ctx);\n-    format_to!(buf, \")\");\n-\n-    if fun.ret_ty.is_unit() {\n-        format_to!(buf, \";\");\n+    format_to!(buf, \"{}\", expr);\n+    if fun.ret_ty.is_unit()\n+        && (!fun.vars_defined_in_body_and_outlive.is_empty() || !expr.is_block_like())\n+    {\n+        buf.push(';');\n     }\n-\n     buf\n }\n \n-fn format_arg_list_to(buf: &mut String, fun: &Function, ctx: &AssistContext) {\n-    let mut it = fun.params.iter();\n-    if let Some(param) = it.next() {\n-        format_arg_to(buf, ctx, param);\n+enum FlowHandler {\n+    None,\n+    Try { kind: TryKind },\n+    If { action: FlowKind },\n+    IfOption { action: FlowKind },\n+    MatchOption { none: FlowKind },\n+    MatchResult { err: FlowKind },\n+}\n+\n+impl FlowHandler {\n+    fn from_ret_ty(fun: &Function, ret_ty: &FunType) -> FlowHandler {\n+        match &fun.control_flow.kind {\n+            None => FlowHandler::None,\n+            Some(flow_kind) => {\n+                let action = flow_kind.clone();\n+                if *ret_ty == FunType::Unit {\n+                    match flow_kind {\n+                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                            FlowHandler::If { action }\n+                        }\n+                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                            FlowHandler::IfOption { action }\n+                        }\n+                        FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n+                            FlowHandler::Try { kind: kind.clone() }\n+                        }\n+                    }\n+                } else {\n+                    match flow_kind {\n+                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                            FlowHandler::MatchOption { none: action }\n+                        }\n+                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                            FlowHandler::MatchResult { err: action }\n+                        }\n+                        FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n+                            FlowHandler::Try { kind: kind.clone() }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n-    for param in it {\n-        buf.push_str(\", \");\n-        format_arg_to(buf, ctx, param);\n+\n+    fn make_call_expr(&self, call_expr: ast::Expr) -> ast::Expr {\n+        match self {\n+            FlowHandler::None => call_expr,\n+            FlowHandler::Try { kind: _ } => make::expr_try(call_expr),\n+            FlowHandler::If { action } => {\n+                let action = action.make_result_handler(None);\n+                let stmt = make::expr_stmt(action);\n+                let block = make::block_expr(iter::once(stmt.into()), None);\n+                let condition = make::condition(call_expr, None);\n+                make::expr_if(condition, block, None)\n+            }\n+            FlowHandler::IfOption { action } => {\n+                let path = make_path_from_text(\"Some\");\n+                let value_pat = make::ident_pat(make::name(\"value\"));\n+                let pattern = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                let cond = make::condition(call_expr, Some(pattern.into()));\n+                let value = make::expr_path(make_path_from_text(\"value\"));\n+                let action_expr = action.make_result_handler(Some(value));\n+                let action_stmt = make::expr_stmt(action_expr);\n+                let then = make::block_expr(iter::once(action_stmt.into()), None);\n+                make::expr_if(cond, then, None)\n+            }\n+            FlowHandler::MatchOption { none } => {\n+                let some_name = \"value\";\n+\n+                let some_arm = {\n+                    let path = make_path_from_text(\"Some\");\n+                    let value_pat = make::ident_pat(make::name(some_name));\n+                    let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                    let value = make::expr_path(make_path_from_text(some_name));\n+                    make::match_arm(iter::once(pat.into()), value)\n+                };\n+                let none_arm = {\n+                    let path = make_path_from_text(\"None\");\n+                    let pat = make::path_pat(path);\n+                    make::match_arm(iter::once(pat), none.make_result_handler(None))\n+                };\n+                let arms = make::match_arm_list(vec![some_arm, none_arm]);\n+                make::expr_match(call_expr, arms)\n+            }\n+            FlowHandler::MatchResult { err } => {\n+                let ok_name = \"value\";\n+                let err_name = \"value\";\n+\n+                let ok_arm = {\n+                    let path = make_path_from_text(\"Ok\");\n+                    let value_pat = make::ident_pat(make::name(ok_name));\n+                    let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                    let value = make::expr_path(make_path_from_text(ok_name));\n+                    make::match_arm(iter::once(pat.into()), value)\n+                };\n+                let err_arm = {\n+                    let path = make_path_from_text(\"Err\");\n+                    let value_pat = make::ident_pat(make::name(err_name));\n+                    let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                    let value = make::expr_path(make_path_from_text(err_name));\n+                    make::match_arm(iter::once(pat.into()), err.make_result_handler(Some(value)))\n+                };\n+                let arms = make::match_arm_list(vec![ok_arm, err_arm]);\n+                make::expr_match(call_expr, arms)\n+            }\n+        }\n     }\n }\n \n-fn format_arg_to(buf: &mut String, ctx: &AssistContext, param: &Param) {\n-    format_to!(buf, \"{}{}\", param.value_prefix(), param.var.name(ctx.db()).unwrap());\n+fn make_path_from_text(text: &str) -> ast::Path {\n+    make::path_unqualified(make::path_segment(make::name_ref(text)))\n+}\n+\n+fn path_expr_from_local(ctx: &AssistContext, var: Local) -> ast::Expr {\n+    let name = var.name(ctx.db()).unwrap().to_string();\n+    make::expr_path(make_path_from_text(&name))\n }\n \n fn format_function(\n@@ -764,132 +1076,233 @@ fn format_function(\n     new_indent: IndentLevel,\n ) -> String {\n     let mut fn_def = String::new();\n-    format_to!(fn_def, \"\\n\\n{}fn $0{}(\", new_indent, fun.name);\n-    format_function_param_list_to(&mut fn_def, ctx, module, fun);\n-    fn_def.push(')');\n-    format_function_ret_to(&mut fn_def, ctx, module, fun);\n-    fn_def.push_str(\" {\");\n-    format_function_body_to(&mut fn_def, ctx, old_indent, new_indent, fun);\n-    format_to!(fn_def, \"{}}}\", new_indent);\n+    let params = make_param_list(ctx, module, fun);\n+    let ret_ty = make_ret_ty(ctx, module, fun);\n+    let body = make_body(ctx, old_indent, new_indent, fun);\n+    format_to!(fn_def, \"\\n\\n{}fn $0{}{}\", new_indent, fun.name, params);\n+    if let Some(ret_ty) = ret_ty {\n+        format_to!(fn_def, \" {}\", ret_ty);\n+    }\n+    format_to!(fn_def, \" {}\", body);\n \n     fn_def\n }\n \n-fn format_function_param_list_to(\n-    fn_def: &mut String,\n-    ctx: &AssistContext,\n-    module: hir::Module,\n-    fun: &Function,\n-) {\n-    let mut it = fun.params.iter();\n-    if let Some(self_param) = &fun.self_param {\n-        format_to!(fn_def, \"{}\", self_param);\n-    } else if let Some(param) = it.next() {\n-        format_param_to(fn_def, ctx, module, param);\n-    }\n-    for param in it {\n-        fn_def.push_str(\", \");\n-        format_param_to(fn_def, ctx, module, param);\n-    }\n-}\n-\n-fn format_param_to(fn_def: &mut String, ctx: &AssistContext, module: hir::Module, param: &Param) {\n-    format_to!(\n-        fn_def,\n-        \"{}{}: {}{}\",\n-        param.mut_pattern(),\n-        param.var.name(ctx.db()).unwrap(),\n-        param.type_prefix(),\n-        format_type(&param.ty, ctx, module)\n-    );\n+fn make_param_list(ctx: &AssistContext, module: hir::Module, fun: &Function) -> ast::ParamList {\n+    let self_param = fun.self_param.clone();\n+    let params = fun.params.iter().map(|param| param.to_param(ctx, module));\n+    make::param_list(self_param, params)\n }\n \n-fn format_function_ret_to(\n-    fn_def: &mut String,\n-    ctx: &AssistContext,\n-    module: hir::Module,\n-    fun: &Function,\n-) {\n-    if let Some(ty) = fun.ret_ty.as_fn_ret() {\n-        format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n-    } else {\n-        match fun.vars_defined_in_body_and_outlive.as_slice() {\n-            [] => {}\n-            [var] => {\n-                format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n-            }\n-            [v0, vs @ ..] => {\n-                format_to!(fn_def, \" -> ({}\", format_type(&v0.ty(ctx.db()), ctx, module));\n-                for var in vs {\n-                    format_to!(fn_def, \", {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+impl FunType {\n+    fn make_ty(&self, ctx: &AssistContext, module: hir::Module) -> ast::Type {\n+        match self {\n+            FunType::Unit => make::ty_unit(),\n+            FunType::Single(ty) => make_ty(ty, ctx, module),\n+            FunType::Tuple(types) => match types.as_slice() {\n+                [] => {\n+                    stdx::never!(\"tuple type with 0 elements\");\n+                    make::ty_unit()\n                 }\n-                fn_def.push(')');\n-            }\n+                [ty] => {\n+                    stdx::never!(\"tuple type with 1 element\");\n+                    make_ty(ty, ctx, module)\n+                }\n+                types => {\n+                    let types = types.iter().map(|ty| make_ty(ty, ctx, module));\n+                    make::ty_tuple(types)\n+                }\n+            },\n         }\n     }\n }\n \n-fn format_function_body_to(\n-    fn_def: &mut String,\n+fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Option<ast::RetType> {\n+    let fun_ty = fun.return_type(ctx);\n+    let handler = FlowHandler::from_ret_ty(fun, &fun_ty);\n+    let ret_ty = match &handler {\n+        FlowHandler::None => {\n+            if matches!(fun_ty, FunType::Unit) {\n+                return None;\n+            }\n+            fun_ty.make_ty(ctx, module)\n+        }\n+        FlowHandler::Try { kind: TryKind::Option } => {\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(fun_ty.make_ty(ctx, module)))\n+        }\n+        FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n+            let handler_ty = parent_ret_ty\n+                .type_parameters()\n+                .nth(1)\n+                .map(|ty| make_ty(&ty, ctx, module))\n+                .unwrap_or_else(make::ty_unit);\n+            make::ty_generic(\n+                make::name_ref(\"Result\"),\n+                vec![fun_ty.make_ty(ctx, module), handler_ty],\n+            )\n+        }\n+        FlowHandler::If { .. } => make::ty(\"bool\"),\n+        FlowHandler::IfOption { action } => {\n+            let handler_ty = action\n+                .expr_ty(ctx)\n+                .map(|ty| make_ty(&ty, ctx, module))\n+                .unwrap_or_else(make::ty_unit);\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(handler_ty))\n+        }\n+        FlowHandler::MatchOption { .. } => {\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(fun_ty.make_ty(ctx, module)))\n+        }\n+        FlowHandler::MatchResult { err } => {\n+            let handler_ty =\n+                err.expr_ty(ctx).map(|ty| make_ty(&ty, ctx, module)).unwrap_or_else(make::ty_unit);\n+            make::ty_generic(\n+                make::name_ref(\"Result\"),\n+                vec![fun_ty.make_ty(ctx, module), handler_ty],\n+            )\n+        }\n+    };\n+    Some(make::ret_type(ret_ty))\n+}\n+\n+fn make_body(\n     ctx: &AssistContext,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     fun: &Function,\n-) {\n-    match &fun.body {\n+) -> ast::BlockExpr {\n+    let ret_ty = fun.return_type(ctx);\n+    let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n+    let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n-            fn_def.push('\\n');\n-            let expr = expr.dedent(old_indent).indent(new_indent + 1);\n-            let expr = fix_param_usages(ctx, &fun.params, expr.syntax());\n-            format_to!(fn_def, \"{}{}\", new_indent + 1, expr);\n-            fn_def.push('\\n');\n+            let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n+            let expr = ast::Expr::cast(expr).unwrap();\n+            let expr = expr.dedent(old_indent).indent(IndentLevel(1));\n+\n+            make::block_expr(Vec::new(), Some(expr))\n         }\n-        FunctionBody::Span { elements, leading_indent } => {\n-            format_to!(fn_def, \"{}\", leading_indent);\n-            let new_indent_str = format!(\"\\n{}\", new_indent + 1);\n-            for mut element in elements {\n-                let new_ws;\n-                if let Some(ws) = element.as_token().cloned().and_then(ast::Whitespace::cast) {\n-                    let text = ws.syntax().text();\n-                    if text.contains('\\n') {\n-                        let new_text = text.replace(&format!(\"\\n{}\", old_indent), &new_indent_str);\n-                        new_ws = ast::make::tokens::whitespace(&new_text).into();\n-                        element = &new_ws;\n-                    }\n-                }\n+        FunctionBody::Span { parent, text_range } => {\n+            let mut elements: Vec<_> = parent\n+                .syntax()\n+                .children()\n+                .filter(|it| text_range.contains_range(it.text_range()))\n+                .map(|it| rewrite_body_segment(ctx, &fun.params, &handler, &it))\n+                .collect();\n+\n+            let mut tail_expr = match elements.pop() {\n+                Some(node) => ast::Expr::cast(node.clone()).or_else(|| {\n+                    elements.push(node);\n+                    None\n+                }),\n+                None => None,\n+            };\n \n-                match element {\n-                    syntax::NodeOrToken::Node(node) => {\n-                        format_to!(fn_def, \"{}\", fix_param_usages(ctx, &fun.params, node));\n+            if tail_expr.is_none() {\n+                match fun.vars_defined_in_body_and_outlive.as_slice() {\n+                    [] => {}\n+                    [var] => {\n+                        tail_expr = Some(path_expr_from_local(ctx, *var));\n                     }\n-                    syntax::NodeOrToken::Token(token) => {\n-                        format_to!(fn_def, \"{}\", token);\n+                    vars => {\n+                        let exprs = vars.iter().map(|var| path_expr_from_local(ctx, *var));\n+                        let expr = make::expr_tuple(exprs);\n+                        tail_expr = Some(expr);\n                     }\n                 }\n             }\n-            if !fn_def.ends_with('\\n') {\n-                fn_def.push('\\n');\n-            }\n+\n+            let elements = elements.into_iter().filter_map(|node| match ast::Stmt::cast(node) {\n+                Some(stmt) => Some(stmt),\n+                None => {\n+                    stdx::never!(\"block contains non-statement\");\n+                    None\n+                }\n+            });\n+\n+            let body_indent = IndentLevel(1);\n+            let elements = elements.map(|stmt| stmt.dedent(old_indent).indent(body_indent));\n+            let tail_expr = tail_expr.map(|expr| expr.dedent(old_indent).indent(body_indent));\n+\n+            make::block_expr(elements, tail_expr)\n         }\n-    }\n+    };\n \n-    match fun.vars_defined_in_body_and_outlive.as_slice() {\n-        [] => {}\n-        [var] => format_to!(fn_def, \"{}{}\\n\", new_indent + 1, var.name(ctx.db()).unwrap()),\n-        [v0, vs @ ..] => {\n-            format_to!(fn_def, \"{}({}\", new_indent + 1, v0.name(ctx.db()).unwrap());\n-            for var in vs {\n-                format_to!(fn_def, \", {}\", var.name(ctx.db()).unwrap());\n-            }\n-            fn_def.push_str(\")\\n\");\n+    let block = match &handler {\n+        FlowHandler::None => block,\n+        FlowHandler::Try { kind } => {\n+            let block = with_default_tail_expr(block, make::expr_unit());\n+            map_tail_expr(block, |tail_expr| {\n+                let constructor = match kind {\n+                    TryKind::Option => \"Some\",\n+                    TryKind::Result { .. } => \"Ok\",\n+                };\n+                let func = make::expr_path(make_path_from_text(constructor));\n+                let args = make::arg_list(iter::once(tail_expr));\n+                make::expr_call(func, args)\n+            })\n+        }\n+        FlowHandler::If { .. } => {\n+            let lit_false = ast::Literal::cast(make::tokens::literal(\"false\").parent()).unwrap();\n+            with_tail_expr(block, lit_false.into())\n         }\n+        FlowHandler::IfOption { .. } => {\n+            let none = make::expr_path(make_path_from_text(\"None\"));\n+            with_tail_expr(block, none)\n+        }\n+        FlowHandler::MatchOption { .. } => map_tail_expr(block, |tail_expr| {\n+            let some = make::expr_path(make_path_from_text(\"Some\"));\n+            let args = make::arg_list(iter::once(tail_expr));\n+            make::expr_call(some, args)\n+        }),\n+        FlowHandler::MatchResult { .. } => map_tail_expr(block, |tail_expr| {\n+            let ok = make::expr_path(make_path_from_text(\"Ok\"));\n+            let args = make::arg_list(iter::once(tail_expr));\n+            make::expr_call(ok, args)\n+        }),\n+    };\n+\n+    block.indent(new_indent)\n+}\n+\n+fn map_tail_expr(block: ast::BlockExpr, f: impl FnOnce(ast::Expr) -> ast::Expr) -> ast::BlockExpr {\n+    let tail_expr = match block.tail_expr() {\n+        Some(tail_expr) => tail_expr,\n+        None => return block,\n+    };\n+    make::block_expr(block.statements(), Some(f(tail_expr)))\n+}\n+\n+fn with_default_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr {\n+    match block.tail_expr() {\n+        Some(_) => block,\n+        None => make::block_expr(block.statements(), Some(tail_expr)),\n     }\n }\n \n+fn with_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr {\n+    let stmt_tail = block.tail_expr().map(|expr| make::expr_stmt(expr).into());\n+    let stmts = block.statements().chain(stmt_tail);\n+    make::block_expr(stmts, Some(tail_expr))\n+}\n+\n fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n }\n \n+fn make_ty(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> ast::Type {\n+    let ty_str = format_type(ty, ctx, module);\n+    make::ty(&ty_str)\n+}\n+\n+fn rewrite_body_segment(\n+    ctx: &AssistContext,\n+    params: &[Param],\n+    handler: &FlowHandler,\n+    syntax: &SyntaxNode,\n+) -> SyntaxNode {\n+    let syntax = fix_param_usages(ctx, params, syntax);\n+    update_external_control_flow(handler, &syntax)\n+}\n+\n /// change all usages to account for added `&`/`&mut` for some params\n fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n     let mut rewriter = SyntaxRewriter::default();\n@@ -919,7 +1332,7 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n                     rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n                 }\n                 Some(_) | None => {\n-                    rewriter.replace_ast(&path, &ast::make::expr_prefix(T![*], path.clone()));\n+                    rewriter.replace_ast(&path, &make::expr_prefix(T![*], path.clone()));\n                 }\n             };\n         }\n@@ -928,6 +1341,98 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n     rewriter.rewrite(syntax)\n }\n \n+fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) -> SyntaxNode {\n+    let mut rewriter = SyntaxRewriter::default();\n+\n+    let mut nested_loop = None;\n+    let mut nested_scope = None;\n+    for event in syntax.preorder() {\n+        let node = match event {\n+            WalkEvent::Enter(e) => {\n+                match e.kind() {\n+                    SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n+                        if nested_loop.is_none() {\n+                            nested_loop = Some(e.clone());\n+                        }\n+                    }\n+                    SyntaxKind::FN\n+                    | SyntaxKind::CONST\n+                    | SyntaxKind::STATIC\n+                    | SyntaxKind::IMPL\n+                    | SyntaxKind::MODULE => {\n+                        if nested_scope.is_none() {\n+                            nested_scope = Some(e.clone());\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                e\n+            }\n+            WalkEvent::Leave(e) => {\n+                if nested_loop.as_ref() == Some(&e) {\n+                    nested_loop = None;\n+                }\n+                if nested_scope.as_ref() == Some(&e) {\n+                    nested_scope = None;\n+                }\n+                continue;\n+            }\n+        };\n+        if nested_scope.is_some() {\n+            continue;\n+        }\n+        let expr = match ast::Expr::cast(node) {\n+            Some(e) => e,\n+            None => continue,\n+        };\n+        match expr {\n+            ast::Expr::ReturnExpr(return_expr) if nested_scope.is_none() => {\n+                let expr = return_expr.expr();\n+                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n+                    rewriter.replace_ast(&return_expr.into(), &replacement);\n+                }\n+            }\n+            ast::Expr::BreakExpr(break_expr) if nested_loop.is_none() => {\n+                let expr = break_expr.expr();\n+                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n+                    rewriter.replace_ast(&break_expr.into(), &replacement);\n+                }\n+            }\n+            ast::Expr::ContinueExpr(continue_expr) if nested_loop.is_none() => {\n+                if let Some(replacement) = make_rewritten_flow(handler, None) {\n+                    rewriter.replace_ast(&continue_expr.into(), &replacement);\n+                }\n+            }\n+            _ => {\n+                // do nothing\n+            }\n+        }\n+    }\n+\n+    rewriter.rewrite(syntax)\n+}\n+\n+fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Option<ast::Expr> {\n+    let value = match handler {\n+        FlowHandler::None | FlowHandler::Try { .. } => return None,\n+        FlowHandler::If { .. } => {\n+            ast::Literal::cast(make::tokens::literal(\"true\").parent()).unwrap().into()\n+        }\n+        FlowHandler::IfOption { .. } => {\n+            let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n+            let args = make::arg_list(iter::once(expr));\n+            make::expr_call(make::expr_path(make_path_from_text(\"Some\")), args)\n+        }\n+        FlowHandler::MatchOption { .. } => make::expr_path(make_path_from_text(\"None\")),\n+        FlowHandler::MatchResult { .. } => {\n+            let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n+            let args = make::arg_list(iter::once(expr));\n+            make::expr_call(make::expr_path(make_path_from_text(\"Err\")), args)\n+        }\n+    };\n+    Some(make::expr_return(Some(value)))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -2095,6 +2600,66 @@ fn $0fun_name(c: &Counter) {\n         );\n     }\n \n+    #[test]\n+    fn copy_used_after() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+fn foo() {\n+    let n = 0;\n+    $0let m = n;$0\n+    let k = n;\n+}\"##,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+fn foo() {\n+    let n = 0;\n+    fun_name(n);\n+    let k = n;\n+}\n+\n+fn $0fun_name(n: i32) {\n+    let m = n;\n+}\"##,\n+        )\n+    }\n+\n+    #[test]\n+    fn copy_custom_used_after() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+struct Counter(i32);\n+impl Copy for Counter {}\n+fn foo() {\n+    let c = Counter(0);\n+    $0let n = c.0;$0\n+    let m = c.0;\n+}\"##,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+struct Counter(i32);\n+impl Copy for Counter {}\n+fn foo() {\n+    let c = Counter(0);\n+    fun_name(c);\n+    let m = c.0;\n+}\n+\n+fn $0fun_name(c: Counter) {\n+    let n = c.0;\n+}\"##,\n+        );\n+    }\n+\n     #[test]\n     fn indented_stmts() {\n         check_assist(\n@@ -2156,4 +2721,658 @@ mod bar {\n }\",\n         );\n     }\n+\n+    #[test]\n+    fn break_loop() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> {\n+    #[lang = \"None\"] None,\n+    #[lang = \"Some\"] Some(T),\n+}\n+use Option::*;\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let m = n + 1;\n+        break;\n+        let k = 2;$0\n+        let h = 1 + k;\n+    }\n+}\"##,\n+            r##\"\n+enum Option<T> {\n+    #[lang = \"None\"] None,\n+    #[lang = \"Some\"] Some(T),\n+}\n+use Option::*;\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let k = match fun_name(n) {\n+            Some(value) => value,\n+            None => break,\n+        };\n+        let h = 1 + k;\n+    }\n+}\n+\n+fn $0fun_name(n: i32) -> Option<i32> {\n+    let m = n + 1;\n+    return None;\n+    let k = 2;\n+    Some(k)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_to_parent() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+enum Result<T, E> {\n+    #[lang = \"Ok\"] Ok(T),\n+    #[lang = \"Err\"] Err(E),\n+}\n+use Result::*;\n+fn foo() -> i64 {\n+    let n = 1;\n+    $0let m = n + 1;\n+    return 1;\n+    let k = 2;$0\n+    (n + k) as i64\n+}\"##,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+enum Result<T, E> {\n+    #[lang = \"Ok\"] Ok(T),\n+    #[lang = \"Err\"] Err(E),\n+}\n+use Result::*;\n+fn foo() -> i64 {\n+    let n = 1;\n+    let k = match fun_name(n) {\n+        Ok(value) => value,\n+        Err(value) => return value,\n+    };\n+    (n + k) as i64\n+}\n+\n+fn $0fun_name(n: i32) -> Result<i32, i64> {\n+    let m = n + 1;\n+    return Err(1);\n+    let k = 2;\n+    Ok(k)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_and_continue() {\n+        mark::check!(external_control_flow_break_and_continue);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let m = n + 1;\n+        break;\n+        let k = 2;\n+        continue;\n+        let k = k + 1;$0\n+        let r = n + k;\n+    }\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_and_break() {\n+        mark::check!(external_control_flow_return_and_bc);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let m = n + 1;\n+        break;\n+        let k = 2;\n+        return;\n+        let k = k + 1;$0\n+        let r = n + k;\n+    }\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_loop_with_if() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        $0let m = n + 1;\n+        break;\n+        n += m;$0\n+        let h = 1 + n;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        if fun_name(&mut n) {\n+            break;\n+        }\n+        let h = 1 + n;\n+    }\n+}\n+\n+fn $0fun_name(n: &mut i32) -> bool {\n+    let m = *n + 1;\n+    return true;\n+    *n += m;\n+    false\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_loop_nested() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        $0let m = n + 1;\n+        if m == 42 {\n+            break;\n+        }$0\n+        let h = 1;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        if fun_name(n) {\n+            break;\n+        }\n+        let h = 1;\n+    }\n+}\n+\n+fn $0fun_name(n: i32) -> bool {\n+    let m = n + 1;\n+    if m == 42 {\n+        return true;\n+    }\n+    false\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_from_nested_loop() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0\n+        let k = 1;\n+        loop {\n+            return;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = match fun_name() {\n+            Some(value) => value,\n+            None => return,\n+        };\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    loop {\n+        return None;\n+    }\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_from_nested_loop() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        loop {\n+            break;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = fun_name();\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let k = 1;\n+    loop {\n+        break;\n+    }\n+    let m = k + 1;\n+    m\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_from_nested_and_outer_loops() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        loop {\n+            break;\n+        }\n+        if k == 42 {\n+            break;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = match fun_name() {\n+            Some(value) => value,\n+            None => break,\n+        };\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    loop {\n+        break;\n+    }\n+    if k == 42 {\n+        return None;\n+    }\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_from_nested_fn() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        fn test() {\n+            return;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = fun_name();\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let k = 1;\n+    fn test() {\n+        return;\n+    }\n+    let m = k + 1;\n+    m\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_with_value() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() -> i32 {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        if k == 42 {\n+            break 3;\n+        }\n+        let m = k + 1;$0\n+        let h = 1;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() -> i32 {\n+    loop {\n+        let n = 1;\n+        if let Some(value) = fun_name() {\n+            break value;\n+        }\n+        let h = 1;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    if k == 42 {\n+        return Some(3);\n+    }\n+    let m = k + 1;\n+    None\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_with_value_and_return() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() -> i64 {\n+    loop {\n+        let n = 1;\n+        $0\n+        let k = 1;\n+        if k == 42 {\n+            break 3;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() -> i64 {\n+    loop {\n+        let n = 1;\n+        let m = match fun_name() {\n+            Ok(value) => value,\n+            Err(value) => break value,\n+        };\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = 1;\n+    if k == 42 {\n+        return Err(3);\n+    }\n+    let m = k + 1;\n+    Ok(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_option() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn bar() -> Option<i32> { None }\n+fn foo() -> Option<()> {\n+    let n = bar()?;\n+    $0let k = foo()?;\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Some(())\n+}\"##,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn bar() -> Option<i32> { None }\n+fn foo() -> Option<()> {\n+    let n = bar()?;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Some(())\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = foo()?;\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_option_unit() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    let m = k + 1;$0\n+    let h = 1 + n;\n+    Some(())\n+}\"##,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    let n = 1;\n+    fun_name()?;\n+    let h = 1 + n;\n+    Some(())\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    let k = foo()?;\n+    let m = k + 1;\n+    Some(())\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_result() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Ok(())\n+}\"##,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Ok(())\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = foo()?;\n+    let m = k + 1;\n+    Ok(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_option_with_return() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    if k == 42 {\n+        return None;\n+    }\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Some(())\n+}\"##,\n+            r##\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    let n = 1;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Some(())\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = foo()?;\n+    if k == 42 {\n+        return None;\n+    }\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_result_with_return() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    if k == 42 {\n+        return Err(1);\n+    }\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Ok(())\n+}\"##,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Ok(())\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = foo()?;\n+    if k == 42 {\n+        return Err(1);\n+    }\n+    let m = k + 1;\n+    Ok(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_and_break() {\n+        mark::check!(external_control_flow_try_and_bc);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    loop {\n+        let n = Some(1);\n+        $0let m = n? + 1;\n+        break;\n+        let k = 2;\n+        let k = k + 1;$0\n+        let r = n + k;\n+    }\n+    Some(())\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_and_return_ok() {\n+        mark::check!(external_control_flow_try_and_return_non_err);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    if k == 42 {\n+        return Ok(1);\n+    }\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Ok(())\n+}\"##,\n+        );\n+    }\n }"}, {"sha": "95982498122d7fd5ba38665565c41b43e3ece1bf", "filename": "crates/assists/src/handlers/generate_function.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=88e8b0a5fa17075475c75941932056f7289c5bcf", "patch": "@@ -215,8 +215,11 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| make::param(name, ty));\n-    Some((None, make::param_list(params)))\n+    let params = arg_names\n+        .into_iter()\n+        .zip(arg_types)\n+        .map(|(name, ty)| make::param(make::ident_pat(make::name(&name)).into(), make::ty(&ty)));\n+    Some((None, make::param_list(None, params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers."}, {"sha": "720f561a1724ff753d656337c186917a3852cdb2", "filename": "crates/assists/src/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fassists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests.rs?ref=88e8b0a5fa17075475c75941932056f7289c5bcf", "patch": "@@ -195,6 +195,7 @@ fn assist_order_if_expr() {\n     let assists = Assist::get(&db, &TEST_CONFIG, false, frange);\n     let mut assists = assists.iter();\n \n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into function\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Replace with match\");\n }\n@@ -220,6 +221,7 @@ fn assist_filter_works() {\n         let assists = Assist::get(&db, &cfg, false, frange);\n         let mut assists = assists.iter();\n \n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into function\");\n         assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n         assert_eq!(assists.next().expect(\"expected assist\").label, \"Replace with match\");\n     }\n@@ -228,9 +230,10 @@ fn assist_filter_works() {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n         let assists = Assist::get(&db, &cfg, false, frange);\n-        assert_eq!(assists.len(), 1);\n+        assert_eq!(assists.len(), 2);\n \n         let mut assists = assists.iter();\n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into function\");\n         assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n     }\n "}, {"sha": "7d43d4097191308a448c9e255c71d7f975330395", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=88e8b0a5fa17075475c75941932056f7289c5bcf", "patch": "@@ -1802,6 +1802,18 @@ impl Type {\n         None\n     }\n \n+    pub fn type_parameters(&self) -> impl Iterator<Item = Type> + '_ {\n+        let ty = self.ty.value.strip_references();\n+        let substs = match ty {\n+            Ty::Apply(apply_ty) => &apply_ty.parameters,\n+            Ty::Opaque(opaque_ty) => &opaque_ty.parameters,\n+            _ => return Either::Left(iter::empty()),\n+        };\n+\n+        let iter = substs.iter().map(move |ty| self.derived(ty.clone()));\n+        Either::Right(iter)\n+    }\n+\n     pub fn iterate_method_candidates<T>(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "5eee335458eb3795afc2d2dc23222d8311c18ef3", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e8b0a5fa17075475c75941932056f7289c5bcf/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=88e8b0a5fa17075475c75941932056f7289c5bcf", "patch": "@@ -24,11 +24,24 @@ pub fn name_ref(text: &str) -> ast::NameRef {\n // FIXME: replace stringly-typed constructor with a family of typed ctors, a-la\n // `expr_xxx`.\n pub fn ty(text: &str) -> ast::Type {\n-    ast_from_text(&format!(\"impl {} for D {{}};\", text))\n+    ast_from_text(&format!(\"fn f() -> {} {{}}\", text))\n }\n pub fn ty_unit() -> ast::Type {\n     ty(\"()\")\n }\n+// FIXME: handle types of length == 1\n+pub fn ty_tuple(types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n+    let contents = types.into_iter().join(\", \");\n+    ty(&format!(\"({})\", contents))\n+}\n+// FIXME: handle path to type\n+pub fn ty_generic(name: ast::NameRef, types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n+    let contents = types.into_iter().join(\", \");\n+    ty(&format!(\"{}<{}>\", name, contents))\n+}\n+pub fn ty_ref(target: ast::Type, exclusive: bool) -> ast::Type {\n+    ty(&if exclusive { format!(\"&mut {}\", target) } else { format!(\"&{}\", target) })\n+}\n \n pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {};\")\n@@ -175,11 +188,20 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n pub fn expr_continue() -> ast::Expr {\n     expr_from_text(\"continue\")\n }\n-pub fn expr_break() -> ast::Expr {\n-    expr_from_text(\"break\")\n+pub fn expr_break(expr: Option<ast::Expr>) -> ast::Expr {\n+    match expr {\n+        Some(expr) => expr_from_text(&format!(\"break {}\", expr)),\n+        None => expr_from_text(\"break\"),\n+    }\n }\n-pub fn expr_return() -> ast::Expr {\n-    expr_from_text(\"return\")\n+pub fn expr_return(expr: Option<ast::Expr>) -> ast::Expr {\n+    match expr {\n+        Some(expr) => expr_from_text(&format!(\"return {}\", expr)),\n+        None => expr_from_text(\"return\"),\n+    }\n+}\n+pub fn expr_try(expr: ast::Expr) -> ast::Expr {\n+    expr_from_text(&format!(\"{}?\", expr))\n }\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n     expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n@@ -212,6 +234,10 @@ pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n pub fn expr_paren(expr: ast::Expr) -> ast::Expr {\n     expr_from_text(&format!(\"({})\", expr))\n }\n+pub fn expr_tuple(elements: impl IntoIterator<Item = ast::Expr>) -> ast::Expr {\n+    let expr = elements.into_iter().format(\", \");\n+    expr_from_text(&format!(\"({})\", expr))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -236,6 +262,13 @@ pub fn ident_pat(name: ast::Name) -> ast::IdentPat {\n         ast_from_text(&format!(\"fn f({}: ())\", text))\n     }\n }\n+pub fn ident_mut_pat(name: ast::Name) -> ast::IdentPat {\n+    return from_text(name.text());\n+\n+    fn from_text(text: &str) -> ast::IdentPat {\n+        ast_from_text(&format!(\"fn f(mut {}: ())\", text))\n+    }\n+}\n \n pub fn wildcard_pat() -> ast::WildcardPat {\n     return from_text(\"_\");\n@@ -356,17 +389,25 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n         .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n }\n \n-pub fn param(name: String, ty: String) -> ast::Param {\n-    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n+pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n+    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n }\n \n pub fn ret_type(ty: ast::Type) -> ast::RetType {\n     ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n }\n \n-pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList {\n+pub fn param_list(\n+    self_param: Option<ast::SelfParam>,\n+    pats: impl IntoIterator<Item = ast::Param>,\n+) -> ast::ParamList {\n     let args = pats.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n+    let list = match self_param {\n+        Some(self_param) if args.is_empty() => format!(\"fn f({}) {{ }}\", self_param),\n+        Some(self_param) => format!(\"fn f({}, {}) {{ }}\", self_param, args),\n+        None => format!(\"fn f({}) {{ }}\", args),\n+    };\n+    ast_from_text(&list)\n }\n \n pub fn generic_param(name: String, ty: Option<ast::TypeBoundList>) -> ast::GenericParam {"}]}