{"sha": "eed48f560fa44e60cec89df894018dc4599730d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZDQ4ZjU2MGZhNDRlNjBjZWM4OWRmODk0MDE4ZGM0NTk5NzMwZDA=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-04T13:36:49Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T16:27:13Z"}, "message": "rustc_codegen_llvm: use safe references for Metadata and DI*.", "tree": {"sha": "d845d272c0e8b68d8faa25049febdcde63b23a14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d845d272c0e8b68d8faa25049febdcde63b23a14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eed48f560fa44e60cec89df894018dc4599730d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eed48f560fa44e60cec89df894018dc4599730d0", "html_url": "https://github.com/rust-lang/rust/commit/eed48f560fa44e60cec89df894018dc4599730d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eed48f560fa44e60cec89df894018dc4599730d0/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d0d82ce10bfbdb44aab9a2f120b236ebc7e0175", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d0d82ce10bfbdb44aab9a2f120b236ebc7e0175", "html_url": "https://github.com/rust-lang/rust/commit/6d0d82ce10bfbdb44aab9a2f120b236ebc7e0175"}], "stats": {"total": 788, "additions": 411, "deletions": 377}, "files": [{"sha": "f6fdf18dd94df4f0d1bf9e649be6f7a3867030b4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -31,7 +31,7 @@ use super::ModuleKind;\n use abi;\n use back::link;\n use back::write::{self, OngoingCodegen};\n-use llvm::{ValueRef, Vector, get_param};\n+use llvm::{TypeKind, ValueRef, get_param};\n use llvm;\n use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -349,10 +349,10 @@ fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n     if op.is_shift() {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n-        if rhs_llty.kind() == Vector {\n+        if rhs_llty.kind() == TypeKind::Vector {\n             rhs_llty = rhs_llty.element_type()\n         }\n-        if lhs_llty.kind() == Vector {\n+        if lhs_llty.kind() == TypeKind::Vector {\n             lhs_llty = lhs_llty.element_type()\n         }\n         let rhs_sz = rhs_llty.int_width();"}, {"sha": "4d6744c516cdffb0bb81e03757a1ea4d8a62bb7a", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -13,10 +13,9 @@ use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n use llvm;\n-use llvm::debuginfo::DIScope_opaque;\n+use llvm::debuginfo::DIScope;\n use common::CodegenCx;\n use rustc::mir::{Mir, SourceScope};\n-use std::ptr::NonNull;\n \n use libc::c_uint;\n \n@@ -28,24 +27,24 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use syntax_pos::BytePos;\n \n #[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope {\n-    pub scope_metadata: Option<NonNull<DIScope_opaque>>,\n+pub struct MirDebugScope<'ll> {\n+    pub scope_metadata: Option<&'ll DIScope>,\n     // Start and end offsets of the file to which this DIScope belongs.\n     // These are used to quickly determine whether some span refers to the same file.\n     pub file_start_pos: BytePos,\n     pub file_end_pos: BytePos,\n }\n \n-impl MirDebugScope {\n+impl MirDebugScope<'ll> {\n     pub fn is_valid(&self) -> bool {\n         !self.scope_metadata.is_none()\n     }\n }\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n-    -> IndexVec<SourceScope, MirDebugScope> {\n+pub fn create_mir_scopes(cx: &CodegenCx<'ll, '_>, mir: &Mir, debug_context: &FunctionDebugContext<'ll>)\n+    -> IndexVec<SourceScope, MirDebugScope<'ll>> {\n     let null_scope = MirDebugScope {\n         scope_metadata: None,\n         file_start_pos: BytePos(0),\n@@ -77,12 +76,12 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n     scopes\n }\n \n-fn make_mir_scope(cx: &CodegenCx,\n+fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n                   has_variables: &BitVector<SourceScope>,\n-                  debug_context: &FunctionDebugContextData,\n+                  debug_context: &FunctionDebugContextData<'ll>,\n                   scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, MirDebugScope>) {\n+                  scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {\n     if scopes[scope].is_valid() {\n         return;\n     }\n@@ -95,7 +94,7 @@ fn make_mir_scope(cx: &CodegenCx,\n         // The root is the function itself.\n         let loc = span_start(cx, mir.span);\n         scopes[scope] = MirDebugScope {\n-            scope_metadata: NonNull::new(debug_context.fn_metadata),\n+            scope_metadata: Some(debug_context.fn_metadata),\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -109,7 +108,7 @@ fn make_mir_scope(cx: &CodegenCx,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata.unwrap().as_ptr() != debug_context.fn_metadata {\n+        if parent_scope.scope_metadata.unwrap() != debug_context.fn_metadata {\n             scopes[scope] = parent_scope;\n             return;\n         }\n@@ -121,9 +120,9 @@ fn make_mir_scope(cx: &CodegenCx,\n                                       debug_context.defining_crate);\n \n     let scope_metadata = unsafe {\n-        NonNull::new(llvm::LLVMRustDIBuilderCreateLexicalBlock(\n+        Some(llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(cx),\n-            parent_scope.scope_metadata.unwrap().as_ptr(),\n+            parent_scope.scope_metadata.unwrap(),\n             file_metadata,\n             loc.line as c_uint,\n             loc.col.to_usize() as c_uint))"}, {"sha": "ae2e350dc651c2189691a24b41d948ed36f843a6", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 212, "deletions": 175, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -20,7 +20,7 @@ use super::{CrateDebugContext};\n use abi;\n \n use llvm::{self, ValueRef};\n-use llvm::debuginfo::{DIType, DIFile, DIScope_opaque, DIScope, DIDescriptor,\n+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -38,15 +38,34 @@ use rustc::util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n-use std::fmt::Write;\n+use std::fmt::{self, Write};\n+use std::hash::{Hash, Hasher};\n use std::iter;\n use std::ptr;\n-use std::ptr::NonNull;\n use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax::symbol::{Interner, InternedString, Symbol};\n use syntax_pos::{self, Span, FileName};\n \n+impl PartialEq for llvm::Metadata {\n+    fn eq(&self, other: &Self) -> bool {\n+        self as *const _ == other as *const _\n+    }\n+}\n+\n+impl Eq for llvm::Metadata {}\n+\n+impl Hash for llvm::Metadata {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self as *const Self).hash(hasher);\n+    }\n+}\n+\n+impl fmt::Debug for llvm::Metadata {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (self as *const Self).fmt(f)\n+    }\n+}\n \n // From DWARF 5.\n // See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n@@ -65,7 +84,7 @@ const DW_ATE_unsigned_char: c_uint = 0x08;\n pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n-pub const NO_SCOPE_METADATA: Option<NonNull<DIScope_opaque>> = None;\n+pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n \n #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n pub struct UniqueTypeId(ast::Name);\n@@ -74,19 +93,19 @@ pub struct UniqueTypeId(ast::Name);\n // created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n // faster lookup, also by Ty. The TypeMap is responsible for creating\n // UniqueTypeIds.\n-pub struct TypeMap<'tcx> {\n+pub struct TypeMap<'ll, 'tcx> {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FxHashMap<UniqueTypeId, DIType>,\n+    unique_id_to_metadata: FxHashMap<UniqueTypeId, &'ll DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FxHashMap<Ty<'tcx>, DIType>,\n+    type_to_metadata: FxHashMap<Ty<'tcx>, &'ll DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n     type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n-impl<'tcx> TypeMap<'tcx> {\n-    pub fn new() -> TypeMap<'tcx> {\n+impl TypeMap<'ll, 'tcx> {\n+    pub fn new() -> Self {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n             type_to_metadata: FxHashMap(),\n@@ -97,30 +116,34 @@ impl<'tcx> TypeMap<'tcx> {\n \n     // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     // the mapping already exists.\n-    fn register_type_with_metadata<'a>(&mut self,\n-                                       type_: Ty<'tcx>,\n-                                       metadata: DIType) {\n+    fn register_type_with_metadata(\n+        &mut self,\n+        type_: Ty<'tcx>,\n+        metadata: &'ll DIType,\n+    ) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             bug!(\"Type metadata for Ty '{}' is already in the TypeMap!\", type_);\n         }\n     }\n \n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n-    fn register_unique_id_with_metadata(&mut self,\n-                                        unique_type_id: UniqueTypeId,\n-                                        metadata: DIType) {\n+    fn register_unique_id_with_metadata(\n+        &mut self,\n+        unique_type_id: UniqueTypeId,\n+        metadata: &'ll DIType,\n+    ) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n                  self.get_unique_type_id_as_string(unique_type_id));\n         }\n     }\n \n-    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<DIType> {\n+    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<&'ll DIType> {\n         self.type_to_metadata.get(&type_).cloned()\n     }\n \n-    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n+    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<&'ll DIType> {\n         self.unique_id_to_metadata.get(&unique_type_id).cloned()\n     }\n \n@@ -182,23 +205,23 @@ impl<'tcx> TypeMap<'tcx> {\n // needed to generate the missing parts of the description. See the\n // documentation section on Recursive Types at the top of this file for more\n // information.\n-enum RecursiveTypeDescription<'tcx> {\n+enum RecursiveTypeDescription<'ll, 'tcx> {\n     UnfinishedMetadata {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n-        metadata_stub: DICompositeType,\n-        member_description_factory: MemberDescriptionFactory<'tcx>,\n+        metadata_stub: &'ll DICompositeType,\n+        member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n     },\n-    FinalMetadata(DICompositeType)\n+    FinalMetadata(&'ll DICompositeType)\n }\n \n-fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n+fn create_and_register_recursive_type_forward_declaration(\n+    cx: &CodegenCx<'ll, 'tcx>,\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    metadata_stub: DICompositeType,\n-    member_description_factory: MemberDescriptionFactory<'tcx>)\n- -> RecursiveTypeDescription<'tcx> {\n+    metadata_stub: &'ll DICompositeType,\n+    member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n \n     // Insert the stub into the TypeMap in order to allow for recursive references\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -213,11 +236,11 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n     }\n }\n \n-impl<'tcx> RecursiveTypeDescription<'tcx> {\n+impl RecursiveTypeDescription<'ll, 'tcx> {\n     // Finishes up the description of the type in question (mostly by providing\n     // descriptions of the fields of the given type) and returns the final type\n     // metadata.\n-    fn finalize<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> MetadataCreationResult {\n+    fn finalize(&self, cx: &CodegenCx<'ll, 'tcx>) -> MetadataCreationResult<'ll> {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n@@ -269,12 +292,13 @@ macro_rules! return_if_metadata_created_in_meantime {\n     )\n }\n \n-fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                unique_type_id: UniqueTypeId,\n-                                array_or_slice_type: Ty<'tcx>,\n-                                element_type: Ty<'tcx>,\n-                                span: Span)\n-                                -> MetadataCreationResult {\n+fn fixed_vec_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    array_or_slice_type: Ty<'tcx>,\n+    element_type: Ty<'tcx>,\n+    span: Span,\n+) -> MetadataCreationResult<'ll> {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n@@ -289,7 +313,7 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     };\n \n     let subrange = unsafe {\n-        NonNull::new(llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound))\n+        Some(llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound))\n     };\n \n     let subscripts = create_DIArray(DIB(cx), &[subrange]);\n@@ -305,12 +329,13 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                slice_ptr_type: Ty<'tcx>,\n-                                element_type: Ty<'tcx>,\n-                                unique_type_id: UniqueTypeId,\n-                                span: Span)\n-                                -> MetadataCreationResult {\n+fn vec_slice_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    slice_ptr_type: Ty<'tcx>,\n+    element_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> MetadataCreationResult<'ll> {\n     let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n \n     let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n@@ -354,12 +379,12 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                      unique_type_id: UniqueTypeId,\n-                                      signature: ty::PolyFnSig<'tcx>,\n-                                      span: Span)\n-                                      -> MetadataCreationResult\n-{\n+fn subroutine_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    signature: ty::PolyFnSig<'tcx>,\n+    span: Span,\n+) -> MetadataCreationResult<'ll> {\n     let signature = cx.tcx.normalize_erasing_late_bound_regions(\n         ty::ParamEnv::reveal_all(),\n         &signature,\n@@ -369,12 +394,12 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         // return type\n         match signature.output().sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => None,\n-            _ => NonNull::new(type_metadata(cx, signature.output(), span))\n+            _ => Some(type_metadata(cx, signature.output(), span))\n         }\n     ).chain(\n         // regular arguments\n         signature.inputs().iter().map(|argument_type| {\n-            NonNull::new(type_metadata(cx, argument_type, span))\n+            Some(type_metadata(cx, argument_type, span))\n         })\n     ).collect();\n \n@@ -396,19 +421,20 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n // trait_type should be the actual trait (e.g., Trait). Where the trait is part\n // of a DST struct, there is no trait_object_type and the results of this\n // function will be a little bit weird.\n-fn trait_pointer_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    trait_type: Ty<'tcx>,\n-                                    trait_object_type: Option<Ty<'tcx>>,\n-                                    unique_type_id: UniqueTypeId)\n-                                    -> DIType {\n+fn trait_pointer_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    trait_type: Ty<'tcx>,\n+    trait_object_type: Option<Ty<'tcx>>,\n+    unique_type_id: UniqueTypeId,\n+) -> &'ll DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n         ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n             let def_id = principal.def_id();\n-            NonNull::new(get_namespace_for_item(cx, def_id))\n+            Some(get_namespace_for_item(cx, def_id))\n         } else {\n             NO_SCOPE_METADATA\n         },\n@@ -463,10 +489,11 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                             syntax_pos::DUMMY_SP)\n }\n \n-pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                               t: Ty<'tcx>,\n-                               usage_site_span: Span)\n-                               -> DIType {\n+pub fn type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    t: Ty<'tcx>,\n+    usage_site_span: Span,\n+) -> &'ll DIType {\n     // Get the unique type id of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -683,9 +710,9 @@ pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CodegenCx,\n+pub fn file_metadata(cx: &CodegenCx<'ll, '_>,\n                      file_name: &FileName,\n-                     defining_crate: CrateNum) -> DIFile {\n+                     defining_crate: CrateNum) -> &'ll DIFile {\n     debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n            file_name,\n            defining_crate);\n@@ -701,14 +728,14 @@ pub fn file_metadata(cx: &CodegenCx,\n     file_metadata_raw(cx, &file_name.to_string(), &directory.to_string_lossy())\n }\n \n-pub fn unknown_file_metadata(cx: &CodegenCx) -> DIFile {\n+pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n     file_metadata_raw(cx, \"<unknown>\", \"\")\n }\n \n-fn file_metadata_raw(cx: &CodegenCx,\n+fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n                      file_name: &str,\n                      directory: &str)\n-                     -> DIFile {\n+                     -> &'ll DIFile {\n     let key = (Symbol::intern(file_name), Symbol::intern(directory));\n \n     if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(&key) {\n@@ -731,9 +758,7 @@ fn file_metadata_raw(cx: &CodegenCx,\n     file_metadata\n }\n \n-fn basic_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                 t: Ty<'tcx>) -> DIType {\n-\n+fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n@@ -768,19 +793,22 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return ty_metadata;\n }\n \n-fn foreign_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   t: Ty<'tcx>,\n-                                   unique_type_id: UniqueTypeId) -> DIType {\n+fn foreign_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    t: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+) -> &'ll DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n     let name = compute_debuginfo_type_name(cx, t, false);\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n-fn pointer_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   pointer_type: Ty<'tcx>,\n-                                   pointee_type_metadata: DIType)\n-                                   -> DIType {\n+fn pointer_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    pointer_type: Ty<'tcx>,\n+    pointee_type_metadata: &'ll DIType,\n+) -> &'ll DIType {\n     let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n     let name = CString::new(name).unwrap();\n@@ -796,8 +824,8 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n pub fn compile_unit_metadata(tcx: TyCtxt,\n                              codegen_unit_name: &str,\n-                             debug_context: &CrateDebugContext)\n-                             -> DIDescriptor {\n+                             debug_context: &CrateDebugContext<'ll, '_>)\n+                             -> &'ll DIDescriptor {\n     let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n         None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),\n@@ -872,13 +900,13 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n     }\n }\n \n-struct MetadataCreationResult {\n-    metadata: DIType,\n+struct MetadataCreationResult<'ll> {\n+    metadata: &'ll DIType,\n     already_stored_in_typemap: bool\n }\n \n-impl MetadataCreationResult {\n-    fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n+impl MetadataCreationResult<'ll> {\n+    fn new(metadata: &'ll DIType, already_stored_in_typemap: bool) -> Self {\n         MetadataCreationResult {\n             metadata,\n             already_stored_in_typemap,\n@@ -889,9 +917,9 @@ impl MetadataCreationResult {\n // Description of a type member, which can either be a regular field (as in\n // structs or tuples) or an enum variant.\n #[derive(Debug)]\n-struct MemberDescription {\n+struct MemberDescription<'ll> {\n     name: String,\n-    type_metadata: DIType,\n+    type_metadata: &'ll DIType,\n     offset: Size,\n     size: Size,\n     align: Align,\n@@ -902,17 +930,17 @@ struct MemberDescription {\n // for some record-like type. MemberDescriptionFactories are used to defer the\n // creation of type member descriptions in order to break cycles arising from\n // recursive type definitions.\n-enum MemberDescriptionFactory<'tcx> {\n+enum MemberDescriptionFactory<'ll, 'tcx> {\n     StructMDF(StructMemberDescriptionFactory<'tcx>),\n     TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n-    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n+    EnumMDF(EnumMemberDescriptionFactory<'ll, 'tcx>),\n     UnionMDF(UnionMemberDescriptionFactory<'tcx>),\n-    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n+    VariantMDF(VariantMemberDescriptionFactory<'ll, 'tcx>)\n }\n \n-impl<'tcx> MemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+impl MemberDescriptionFactory<'ll, 'tcx> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         match *self {\n             StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -945,8 +973,8 @@ struct StructMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n@@ -969,11 +997,12 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n }\n \n \n-fn prepare_struct_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                     struct_type: Ty<'tcx>,\n-                                     unique_type_id: UniqueTypeId,\n-                                     span: Span)\n-                                     -> RecursiveTypeDescription<'tcx> {\n+fn prepare_struct_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    struct_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n \n     let (struct_def_id, variant) = match struct_type.sty {\n@@ -987,7 +1016,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                   struct_type,\n                                                   &struct_name,\n                                                   unique_type_id,\n-                                                  NonNull::new(containing_scope));\n+                                                  Some(containing_scope));\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -1014,8 +1043,8 @@ struct TupleMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n             let (size, align) = cx.size_and_align_of(component_type);\n@@ -1031,12 +1060,13 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_tuple_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    tuple_type: Ty<'tcx>,\n-                                    component_types: &[Ty<'tcx>],\n-                                    unique_type_id: UniqueTypeId,\n-                                    span: Span)\n-                                    -> RecursiveTypeDescription<'tcx> {\n+fn prepare_tuple_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    tuple_type: Ty<'tcx>,\n+    component_types: &[Ty<'tcx>],\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n \n     create_and_register_recursive_type_forward_declaration(\n@@ -1067,8 +1097,8 @@ struct UnionMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n@@ -1084,11 +1114,12 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_union_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    union_type: Ty<'tcx>,\n-                                    unique_type_id: UniqueTypeId,\n-                                    span: Span)\n-                                    -> RecursiveTypeDescription<'tcx> {\n+fn prepare_union_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    union_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n \n     let (union_def_id, variant) = match union_type.sty {\n@@ -1126,17 +1157,17 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n // the members of this union; so for every variant of the given enum, this\n // factory will produce one MemberDescription (all with no name and a fixed\n // offset of zero bytes).\n-struct EnumMemberDescriptionFactory<'tcx> {\n+struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyLayout<'tcx>,\n-    discriminant_type_metadata: Option<DIType>,\n-    containing_scope: DIScope,\n+    discriminant_type_metadata: Option<&'ll DIType>,\n+    containing_scope: &'ll DIScope,\n     span: Span,\n }\n \n-impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n@@ -1261,17 +1292,17 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n }\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n-struct VariantMemberDescriptionFactory<'tcx> {\n+struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n     // Cloned from the layout::Struct describing the variant.\n     offsets: Vec<layout::Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<DIType>,\n+    discriminant_type_metadata: Option<&'ll DIType>,\n     span: Span,\n }\n \n-impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             let (size, align) = cx.size_and_align_of(ty);\n             MemberDescription {\n@@ -1290,8 +1321,8 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n }\n \n #[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo {\n-    RegularDiscriminant(DIType),\n+enum EnumDiscriminantInfo<'ll> {\n+    RegularDiscriminant(&'ll DIType),\n     OptimizedDiscriminant,\n     NoDiscriminant\n }\n@@ -1300,13 +1331,14 @@ enum EnumDiscriminantInfo {\n // of the variant, and (3) a MemberDescriptionFactory for producing the\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n-fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   layout: layout::TyLayout<'tcx>,\n-                                   variant: &'tcx ty::VariantDef,\n-                                   discriminant_info: EnumDiscriminantInfo,\n-                                   containing_scope: DIScope,\n-                                   span: Span)\n-                                   -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n+fn describe_enum_variant(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    layout: layout::TyLayout<'tcx>,\n+    variant: &'tcx ty::VariantDef,\n+    discriminant_info: EnumDiscriminantInfo<'ll>,\n+    containing_scope: &'ll DIScope,\n+    span: Span,\n+) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n     let variant_name = variant.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n@@ -1319,7 +1351,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                            layout.ty,\n                                            &variant_name,\n                                            unique_type_id,\n-                                           NonNull::new(containing_scope));\n+                                           Some(containing_scope));\n \n     // If this is not a univariant enum, there is also the discriminant field.\n     let (discr_offset, discr_arg) = match discriminant_info {\n@@ -1360,12 +1392,13 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     (metadata_stub, member_description_factory)\n }\n \n-fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   enum_def_id: DefId,\n-                                   unique_type_id: UniqueTypeId,\n-                                   span: Span)\n-                                   -> RecursiveTypeDescription<'tcx> {\n+fn prepare_enum_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type: Ty<'tcx>,\n+    enum_def_id: DefId,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n \n     let containing_scope = get_namespace_for_item(cx, enum_def_id);\n@@ -1384,7 +1417,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let token = v.name.as_str();\n             let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n-                NonNull::new(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n@@ -1491,18 +1524,19 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                     composite_type: Ty<'tcx>,\n-                                     composite_type_name: &str,\n-                                     composite_type_unique_id: UniqueTypeId,\n-                                     member_descriptions: &[MemberDescription],\n-                                     containing_scope: Option<NonNull<DIScope_opaque>>,\n-\n-                                     // Ignore source location information as long as it\n-                                     // can't be reconstructed for non-local crates.\n-                                     _file_metadata: DIFile,\n-                                     _definition_span: Span)\n-                                     -> DICompositeType {\n+fn composite_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    composite_type: Ty<'tcx>,\n+    composite_type_name: &str,\n+    composite_type_unique_id: UniqueTypeId,\n+    member_descriptions: &[MemberDescription<'ll>],\n+    containing_scope: Option<&'ll DIScope>,\n+\n+    // Ignore source location information as long as it\n+    // can't be reconstructed for non-local crates.\n+    _file_metadata: &'ll DIFile,\n+    _definition_span: Span,\n+) -> &'ll DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(cx,\n                                                      composite_type,\n@@ -1517,9 +1551,9 @@ fn composite_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return composite_type_metadata;\n }\n \n-fn set_members_of_composite_type(cx: &CodegenCx,\n-                                 composite_type_metadata: DICompositeType,\n-                                 member_descriptions: &[MemberDescription]) {\n+fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n+                                 composite_type_metadata: &'ll DICompositeType,\n+                                 member_descriptions: &[MemberDescription<'ll>]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n     // create_struct_stub. This would cause a hard to trace assertion in\n@@ -1543,7 +1577,7 @@ fn set_members_of_composite_type(cx: &CodegenCx,\n             let member_name = member_description.name.as_bytes();\n             let member_name = CString::new(member_name).unwrap();\n             unsafe {\n-                NonNull::new(llvm::LLVMRustDIBuilderCreateMemberType(\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n@@ -1568,12 +1602,13 @@ fn set_members_of_composite_type(cx: &CodegenCx,\n // A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n // any caching, does not add any fields to the struct. This can be done later\n // with set_members_of_composite_type().\n-fn create_struct_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                struct_type: Ty<'tcx>,\n-                                struct_type_name: &str,\n-                                unique_type_id: UniqueTypeId,\n-                                containing_scope: Option<NonNull<DIScope_opaque>>)\n-                                -> DICompositeType {\n+fn create_struct_stub(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    struct_type: Ty<'tcx>,\n+    struct_type_name: &str,\n+    unique_type_id: UniqueTypeId,\n+    containing_scope: Option<&'ll DIScope>,\n+) -> &'ll DICompositeType {\n     let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n     let name = CString::new(struct_type_name).unwrap();\n@@ -1605,12 +1640,13 @@ fn create_struct_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return metadata_stub;\n }\n \n-fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                               union_type: Ty<'tcx>,\n-                               union_type_name: &str,\n-                               unique_type_id: UniqueTypeId,\n-                               containing_scope: DIScope)\n-                               -> DICompositeType {\n+fn create_union_stub(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    union_type: Ty<'tcx>,\n+    union_type_name: &str,\n+    unique_type_id: UniqueTypeId,\n+    containing_scope: &'ll DIScope,\n+) -> &'ll DICompositeType {\n     let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n     let name = CString::new(union_type_name).unwrap();\n@@ -1632,7 +1668,7 @@ fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             union_size.bits(),\n             union_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n-            NonNull::new(empty_array),\n+            Some(empty_array),\n             0, // RuntimeLang\n             unique_type_id.as_ptr())\n     };\n@@ -1686,7 +1722,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n-                                                    NonNull::new(var_scope),\n+                                                    Some(var_scope),\n                                                     var_name.as_ptr(),\n                                                     // If null, linkage_name field is omitted,\n                                                     // which is what we want for no_mangle statics\n@@ -1704,11 +1740,12 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n }\n \n // Creates an \"extension\" of an existing DIScope into another file.\n-pub fn extend_scope_to_file(cx: &CodegenCx,\n-                            scope_metadata: DIScope,\n-                            file: &syntax_pos::FileMap,\n-                            defining_crate: CrateNum)\n-                            -> DILexicalBlock {\n+pub fn extend_scope_to_file(\n+    cx: &CodegenCx<'ll, '_>,\n+    scope_metadata: &'ll DIScope,\n+    file: &syntax_pos::FileMap,\n+    defining_crate: CrateNum,\n+) -> &'ll DILexicalBlock {\n     let file_metadata = file_metadata(cx, &file.name, defining_crate);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n@@ -1754,7 +1791,7 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             None,\n             empty_array,\n             0,\n-            NonNull::new(type_metadata),\n+            Some(type_metadata),\n             name.as_ptr()\n         );\n "}, {"sha": "27a4c60b36df38399e1c809a43fe148b73dfd576", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -39,7 +39,6 @@ use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n-use std::ptr::NonNull;\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n@@ -71,15 +70,15 @@ pub struct CrateDebugContext<'a, 'tcx> {\n     llcontext: &'a llvm::Context,\n     llmod: &'a llvm::Module,\n     builder: &'a DIBuilder,\n-    created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), DIType>>,\n+    created_files: RefCell<FxHashMap<(Symbol, Symbol), &'a DIFile>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), &'a DIType>>,\n \n-    type_map: RefCell<TypeMap<'tcx>>,\n-    namespace_map: RefCell<DefIdMap<DIScope>>,\n+    type_map: RefCell<TypeMap<'a, 'tcx>>,\n+    namespace_map: RefCell<DefIdMap<&'a DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n-    composite_types_completed: RefCell<FxHashSet<DIType>>,\n+    composite_types_completed: RefCell<FxHashSet<&'a DIType>>,\n }\n \n impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n@@ -101,14 +100,14 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext {\n-    RegularContext(FunctionDebugContextData),\n+pub enum FunctionDebugContext<'ll> {\n+    RegularContext(FunctionDebugContextData<'ll>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n \n-impl FunctionDebugContext {\n-    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n+impl FunctionDebugContext<'ll> {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<'ll> {\n         match *self {\n             FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n@@ -130,8 +129,8 @@ impl FunctionDebugContext {\n     }\n }\n \n-pub struct FunctionDebugContextData {\n-    fn_metadata: DISubprogram,\n+pub struct FunctionDebugContextData<'ll> {\n+    fn_metadata: &'ll DISubprogram,\n     source_locations_enabled: Cell<bool>,\n     pub defining_crate: CrateNum,\n }\n@@ -201,11 +200,13 @@ pub fn finalize(cx: &CodegenCx) {\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n-pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                               instance: Instance<'tcx>,\n-                                               sig: ty::FnSig<'tcx>,\n-                                               llfn: ValueRef,\n-                                               mir: &mir::Mir) -> FunctionDebugContext {\n+pub fn create_function_debug_context(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    sig: ty::FnSig<'tcx>,\n+    llfn: ValueRef,\n+    mir: &mir::Mir,\n+) -> FunctionDebugContext<'ll> {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n@@ -302,8 +303,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n-    fn get_function_signature<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                        sig: ty::FnSig<'tcx>) -> DIArray {\n+    fn get_function_signature(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> &'ll DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n         }\n@@ -313,7 +316,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         // Return type -- llvm::DIBuilder wants this at index 0\n         signature.push(match sig.output().sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => None,\n-            _ => NonNull::new(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n+            _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n         });\n \n         let inputs = if sig.abi == Abi::RustCall {\n@@ -342,19 +345,19 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     }\n                     _ => t\n                 };\n-                NonNull::new(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n             }));\n         } else {\n             signature.extend(inputs.iter().map(|t| {\n-                NonNull::new(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n             }));\n         }\n \n         if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n             if let ty::TyTuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 signature.extend(\n                     args.iter().map(|argument_type| {\n-                        NonNull::new(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n+                        Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n                     })\n                 );\n             }\n@@ -363,13 +366,13 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &signature[..]);\n     }\n \n-    fn get_template_parameters<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                         generics: &ty::Generics,\n-                                         substs: &Substs<'tcx>,\n-                                         file_metadata: DIFile,\n-                                         name_to_append_suffix_to: &mut String)\n-                                         -> DIArray\n-    {\n+    fn get_template_parameters(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        generics: &ty::Generics,\n+        substs: &Substs<'tcx>,\n+        file_metadata: &'ll DIFile,\n+        name_to_append_suffix_to: &mut String,\n+    ) -> &'ll DIArray {\n         if substs.types().next().is_none() {\n             return create_DIArray(DIB(cx), &[]);\n         }\n@@ -399,14 +402,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                         type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                     let name = CString::new(name.as_str().as_bytes()).unwrap();\n                     Some(unsafe {\n-                        NonNull::new(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n+                        Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n                             None,\n                             name.as_ptr(),\n                             actual_type_metadata,\n                             file_metadata,\n                             0,\n-                            0))\n+                            0,\n+                        ))\n                     })\n                 } else {\n                     None\n@@ -429,9 +433,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         names\n     }\n \n-    fn get_containing_scope<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n-                                        instance: Instance<'tcx>)\n-                                        -> DIScope {\n+    fn get_containing_scope(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        instance: Instance<'tcx>,\n+    ) -> &'ll DIScope {\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n@@ -473,10 +478,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n pub fn declare_local(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    dbg_context: &FunctionDebugContext,\n+    dbg_context: &FunctionDebugContext<'ll>,\n     variable_name: ast::Name,\n     variable_type: Ty<'tcx>,\n-    scope_metadata: DIScope,\n+    scope_metadata: &'ll DIScope,\n     variable_access: VariableAccess,\n     variable_kind: VariableKind,\n     span: Span,"}, {"sha": "9f1141a7e7db06cacf8d8f88472e5527cd6d587c", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::map::DefPathData;\n use common::CodegenCx;\n \n use std::ffi::CString;\n-use std::ptr::NonNull;\n \n pub fn mangled_name_of_instance<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n@@ -32,17 +31,17 @@ pub fn mangled_name_of_instance<'a, 'tcx>(\n      tcx.symbol_name(instance)\n }\n \n-pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;\n     }\n \n     let def_key = cx.tcx.def_key(def_id);\n-    let parent_scope = def_key.parent.and_then(|parent| {\n-        NonNull::new(item_namespace(cx, DefId {\n+    let parent_scope = def_key.parent.map(|parent| {\n+        item_namespace(cx, DefId {\n             krate: def_id.krate,\n             index: parent\n-        }))\n+        })\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {"}, {"sha": "ae117ffd3ecd10365a4132a8436c7e1ce6f2a6d5", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -15,7 +15,7 @@ use super::metadata::UNKNOWN_COLUMN_NUMBER;\n use super::FunctionDebugContext;\n \n use llvm;\n-use llvm::debuginfo::{DIScope_opaque, DIScope};\n+use llvm::debuginfo::DIScope;\n use builder::Builder;\n \n use libc::c_uint;\n@@ -26,7 +26,10 @@ use syntax_pos::{Span, Pos};\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n pub fn set_source_location(\n-    debug_context: &FunctionDebugContext, bx: &Builder, scope: Option<NonNull<DIScope_opaque>>, span: Span\n+    debug_context: &FunctionDebugContext<'ll>,\n+    bx: &Builder<'_, 'll, '_>,\n+    scope: Option<&'ll DIScope>,\n+    span: Span,\n ) {\n     let function_debug_context = match *debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n@@ -40,7 +43,7 @@ pub fn set_source_location(\n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n         debug!(\"set_source_location: {}\", bx.sess().codemap().span_to_string(span));\n         let loc = span_start(bx.cx, span);\n-        InternalDebugLocation::new(scope.unwrap().as_ptr(), loc.line, loc.col.to_usize())\n+        InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };\n@@ -53,7 +56,7 @@ pub fn set_source_location(\n /// they are disabled when beginning to codegen a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext) {\n+pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext<'ll>) {\n     match *dbg_context {\n         FunctionDebugContext::RegularContext(ref data) => {\n             data.source_locations_enabled.set(true)\n@@ -64,13 +67,13 @@ pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext) {\n \n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum InternalDebugLocation {\n-    KnownLocation { scope: DIScope, line: usize, col: usize },\n+pub enum InternalDebugLocation<'ll> {\n+    KnownLocation { scope: &'ll DIScope, line: usize, col: usize },\n     UnknownLocation\n }\n \n-impl InternalDebugLocation {\n-    pub fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n+impl InternalDebugLocation<'ll> {\n+    pub fn new(scope: &'ll DIScope, line: usize, col: usize) -> Self {\n         KnownLocation {\n             scope,\n             line,\n@@ -79,7 +82,7 @@ impl InternalDebugLocation {\n     }\n }\n \n-pub fn set_debug_location(bx: &Builder, debug_location: InternalDebugLocation) {\n+pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDebugLocation<'ll>) {\n     let metadata_node = match debug_location {\n         KnownLocation { scope, line, col } => {\n             // For MSVC, set the column number to zero."}, {"sha": "d4d817abd5600369ee94405bd6e7a2ab413266dd", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -17,10 +17,9 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::DefIdTree;\n \n use llvm;\n-use llvm::debuginfo::{DIScope, DIBuilder, DIDescriptor_opaque, DIArray};\n+use llvm::debuginfo::{DIScope, DIBuilder, DIDescriptor, DIArray};\n use common::{CodegenCx};\n \n-use std::ptr::NonNull;\n use syntax_pos::{self, Span};\n \n pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n@@ -37,7 +36,7 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n }\n \n #[allow(non_snake_case)]\n-pub fn create_DIArray(builder: &DIBuilder, arr: &[Option<NonNull<DIDescriptor_opaque>>]) -> DIArray {\n+pub fn create_DIArray(builder: &'ll DIBuilder, arr: &[Option<&'ll DIDescriptor>]) -> &'ll DIArray {\n     return unsafe {\n         llvm::LLVMRustDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n     };\n@@ -49,7 +48,7 @@ pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n }\n \n #[inline]\n-pub fn debug_context(cx: &'a CodegenCx<'ll, 'tcx>) -> &'a CrateDebugContext<'a, 'tcx> {\n+pub fn debug_context(cx: &'a CodegenCx<'ll, 'tcx>) -> &'a CrateDebugContext<'ll, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n \n@@ -59,7 +58,7 @@ pub fn DIB(cx: &CodegenCx<'ll, '_>) -> &'ll DIBuilder {\n     cx.dbg_cx.as_ref().unwrap().builder\n }\n \n-pub fn get_namespace_for_item(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+pub fn get_namespace_for_item(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     item_namespace(cx, cx.tcx.parent(def_id)\n         .expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "e52ebc7f34beaba01ca0ec660e60bd1b4eb36a97", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -12,7 +12,7 @@\n \n use intrinsics::{self, Intrinsic};\n use llvm;\n-use llvm::{ValueRef};\n+use llvm::{TypeKind, ValueRef};\n use abi::{Abi, FnType, LlvmType, PassMode};\n use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n@@ -1060,7 +1060,7 @@ fn generic_simd_intrinsic(\n                   found `{}` with length {}\",\n                  in_len, in_ty,\n                  ret_ty, out_len);\n-        require!(llret_ty.element_type().kind() == llvm::Integer,\n+        require!(llret_ty.element_type().kind() == TypeKind::Integer,\n                  \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n                  ret_ty,\n                  ret_ty.simd_type(tcx));"}, {"sha": "389cfa1d7b107f2d5cfbb2408b84f0ab1e0f5028", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 102, "deletions": 107, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -15,9 +15,9 @@\n // https://reviews.llvm.org/D26769\n \n use super::debuginfo::{\n-    DIBuilder, DIDescriptor_opaque, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType_opaque,\n-    DIType, DIBasicType, DIDerivedType, DICompositeType, DIScope_opaque, DIScope, DIVariable,\n-    DIGlobalVariable, DIArray_opaque, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,\n+    DIBuilder, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,\n+    DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,\n+    DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,\n     DINameSpace, DIFlags,\n };\n \n@@ -380,8 +380,7 @@ extern { pub type Context; }\n extern { pub type Type; }\n extern { pub type Value_opaque; }\n pub type ValueRef = *mut Value_opaque;\n-extern { pub type Metadata_opaque; }\n-pub type MetadataRef = *mut Metadata_opaque;\n+extern { pub type Metadata; }\n extern { pub type BasicBlock_opaque; }\n pub type BasicBlockRef = *mut BasicBlock_opaque;\n extern { pub type Builder; }\n@@ -431,28 +430,23 @@ pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_v\n \n \n pub mod debuginfo {\n-    use super::Metadata_opaque;\n+    use super::Metadata;\n \n     extern { pub type DIBuilder; }\n \n-    pub type DIDescriptor_opaque = Metadata_opaque;\n-    pub type DIDescriptor = *mut DIDescriptor_opaque;\n-    pub type DIScope_opaque = DIDescriptor_opaque;\n-    pub type DIScope = *mut DIScope_opaque;\n-    pub type DILocation = DIDescriptor;\n+    pub type DIDescriptor = Metadata;\n+    pub type DIScope = DIDescriptor;\n     pub type DIFile = DIScope;\n     pub type DILexicalBlock = DIScope;\n     pub type DISubprogram = DIScope;\n     pub type DINameSpace = DIScope;\n-    pub type DIType_opaque = DIDescriptor_opaque;\n-    pub type DIType = *mut DIType_opaque;\n+    pub type DIType = DIDescriptor;\n     pub type DIBasicType = DIType;\n     pub type DIDerivedType = DIType;\n     pub type DICompositeType = DIDerivedType;\n     pub type DIVariable = DIDescriptor;\n     pub type DIGlobalVariable = DIDescriptor;\n-    pub type DIArray_opaque = DIDescriptor_opaque;\n-    pub type DIArray = *mut DIArray_opaque;\n+    pub type DIArray = DIDescriptor;\n     pub type DISubrange = DIDescriptor;\n     pub type DIEnumerator = DIDescriptor;\n     pub type DITemplateTypeParameter = DIDescriptor;\n@@ -1366,157 +1360,157 @@ extern \"C\" {\n \n     pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n \n-    pub fn LLVMRustMetadataAsValue(C: &Context, MD: MetadataRef) -> ValueRef;\n+    pub fn LLVMRustMetadataAsValue(C: &'a Context, MD: &'a Metadata) -> ValueRef;\n \n     pub fn LLVMRustDIBuilderCreate(M: &Module) -> &DIBuilder;\n \n     pub fn LLVMRustDIBuilderDispose(Builder: &DIBuilder);\n \n     pub fn LLVMRustDIBuilderFinalize(Builder: &DIBuilder);\n \n-    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: &DIBuilder,\n+    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: &'a DIBuilder,\n                                               Lang: c_uint,\n-                                              File: DIFile,\n+                                              File: &'a DIFile,\n                                               Producer: *const c_char,\n                                               isOptimized: bool,\n                                               Flags: *const c_char,\n                                               RuntimeVer: c_uint,\n                                               SplitName: *const c_char)\n-                                              -> DIDescriptor;\n+                                              -> &'a DIDescriptor;\n \n     pub fn LLVMRustDIBuilderCreateFile(Builder: &DIBuilder,\n                                        Filename: *const c_char,\n                                        Directory: *const c_char)\n-                                       -> DIFile;\n+                                       -> &DIFile;\n \n-    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: &DIBuilder,\n-                                                 File: DIFile,\n-                                                 ParameterTypes: DIArray)\n-                                                 -> DICompositeType;\n+    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: &'a DIBuilder,\n+                                                 File: &'a DIFile,\n+                                                 ParameterTypes: &'a DIArray)\n+                                                 -> &'a DICompositeType;\n \n-    pub fn LLVMRustDIBuilderCreateFunction(Builder: &DIBuilder,\n-                                           Scope: DIDescriptor,\n+    pub fn LLVMRustDIBuilderCreateFunction(Builder: &'a DIBuilder,\n+                                           Scope: &'a DIDescriptor,\n                                            Name: *const c_char,\n                                            LinkageName: *const c_char,\n-                                           File: DIFile,\n+                                           File: &'a DIFile,\n                                            LineNo: c_uint,\n-                                           Ty: DIType,\n+                                           Ty: &'a DIType,\n                                            isLocalToUnit: bool,\n                                            isDefinition: bool,\n                                            ScopeLine: c_uint,\n                                            Flags: DIFlags,\n                                            isOptimized: bool,\n                                            Fn: ValueRef,\n-                                           TParam: DIArray,\n-                                           Decl: Option<NonNull<DIDescriptor_opaque>>)\n-                                           -> DISubprogram;\n+                                           TParam: &'a DIArray,\n+                                           Decl: Option<&'a DIDescriptor>)\n+                                           -> &'a DISubprogram;\n \n     pub fn LLVMRustDIBuilderCreateBasicType(Builder: &DIBuilder,\n                                             Name: *const c_char,\n                                             SizeInBits: u64,\n                                             AlignInBits: u32,\n                                             Encoding: c_uint)\n-                                            -> DIBasicType;\n+                                            -> &DIBasicType;\n \n-    pub fn LLVMRustDIBuilderCreatePointerType(Builder: &DIBuilder,\n-                                              PointeeTy: DIType,\n+    pub fn LLVMRustDIBuilderCreatePointerType(Builder: &'a DIBuilder,\n+                                              PointeeTy: &'a DIType,\n                                               SizeInBits: u64,\n                                               AlignInBits: u32,\n                                               Name: *const c_char)\n-                                              -> DIDerivedType;\n+                                              -> &'a DIDerivedType;\n \n-    pub fn LLVMRustDIBuilderCreateStructType(Builder: &DIBuilder,\n-                                             Scope: Option<NonNull<DIDescriptor_opaque>>,\n+    pub fn LLVMRustDIBuilderCreateStructType(Builder: &'a DIBuilder,\n+                                             Scope: Option<&'a DIDescriptor>,\n                                              Name: *const c_char,\n-                                             File: DIFile,\n+                                             File: &'a DIFile,\n                                              LineNumber: c_uint,\n                                              SizeInBits: u64,\n                                              AlignInBits: u32,\n                                              Flags: DIFlags,\n-                                             DerivedFrom: Option<NonNull<DIType_opaque>>,\n-                                             Elements: DIArray,\n+                                             DerivedFrom: Option<&'a DIType>,\n+                                             Elements: &'a DIArray,\n                                              RunTimeLang: c_uint,\n-                                             VTableHolder: Option<NonNull<DIType_opaque>>,\n+                                             VTableHolder: Option<&'a DIType>,\n                                              UniqueId: *const c_char)\n-                                             -> DICompositeType;\n+                                             -> &'a DICompositeType;\n \n-    pub fn LLVMRustDIBuilderCreateMemberType(Builder: &DIBuilder,\n-                                             Scope: DIDescriptor,\n+    pub fn LLVMRustDIBuilderCreateMemberType(Builder: &'a DIBuilder,\n+                                             Scope: &'a DIDescriptor,\n                                              Name: *const c_char,\n-                                             File: DIFile,\n+                                             File: &'a DIFile,\n                                              LineNo: c_uint,\n                                              SizeInBits: u64,\n                                              AlignInBits: u32,\n                                              OffsetInBits: u64,\n                                              Flags: DIFlags,\n-                                             Ty: DIType)\n-                                             -> DIDerivedType;\n+                                             Ty: &'a DIType)\n+                                             -> &'a DIDerivedType;\n \n-    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: &DIBuilder,\n-                                               Scope: DIScope,\n-                                               File: DIFile,\n+    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: &'a DIBuilder,\n+                                               Scope: &'a DIScope,\n+                                               File: &'a DIFile,\n                                                Line: c_uint,\n                                                Col: c_uint)\n-                                               -> DILexicalBlock;\n+                                               -> &'a DILexicalBlock;\n \n-    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(Builder: &DIBuilder,\n-                                                   Scope: DIScope,\n-                                                   File: DIFile)\n-                                                   -> DILexicalBlock;\n+    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(Builder: &'a DIBuilder,\n+                                                   Scope: &'a DIScope,\n+                                                   File: &'a DIFile)\n+                                                   -> &'a DILexicalBlock;\n \n-    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: &DIBuilder,\n-                                                 Context: Option<NonNull<DIScope_opaque>>,\n+    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: &'a DIBuilder,\n+                                                 Context: Option<&'a DIScope>,\n                                                  Name: *const c_char,\n                                                  LinkageName: *const c_char,\n-                                                 File: DIFile,\n+                                                 File: &'a DIFile,\n                                                  LineNo: c_uint,\n-                                                 Ty: DIType,\n+                                                 Ty: &'a DIType,\n                                                  isLocalToUnit: bool,\n                                                  Val: ValueRef,\n-                                                 Decl: Option<NonNull<DIDescriptor_opaque>>,\n+                                                 Decl: Option<&'a DIDescriptor>,\n                                                  AlignInBits: u32)\n-                                                 -> DIGlobalVariable;\n+                                                 -> &'a DIGlobalVariable;\n \n-    pub fn LLVMRustDIBuilderCreateVariable(Builder: &DIBuilder,\n+    pub fn LLVMRustDIBuilderCreateVariable(Builder: &'a DIBuilder,\n                                            Tag: c_uint,\n-                                           Scope: DIDescriptor,\n+                                           Scope: &'a DIDescriptor,\n                                            Name: *const c_char,\n-                                           File: DIFile,\n+                                           File: &'a DIFile,\n                                            LineNo: c_uint,\n-                                           Ty: DIType,\n+                                           Ty: &'a DIType,\n                                            AlwaysPreserve: bool,\n                                            Flags: DIFlags,\n                                            ArgNo: c_uint,\n                                            AlignInBits: u32)\n-                                           -> DIVariable;\n+                                           -> &'a DIVariable;\n \n-    pub fn LLVMRustDIBuilderCreateArrayType(Builder: &DIBuilder,\n+    pub fn LLVMRustDIBuilderCreateArrayType(Builder: &'a DIBuilder,\n                                             Size: u64,\n                                             AlignInBits: u32,\n-                                            Ty: DIType,\n-                                            Subscripts: DIArray)\n-                                            -> DIType;\n+                                            Ty: &'a DIType,\n+                                            Subscripts: &'a DIArray)\n+                                            -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderCreateVectorType(Builder: &DIBuilder,\n+    pub fn LLVMRustDIBuilderCreateVectorType(Builder: &'a DIBuilder,\n                                              Size: u64,\n                                              AlignInBits: u32,\n-                                             Ty: DIType,\n-                                             Subscripts: DIArray)\n-                                             -> DIType;\n+                                             Ty: &'a DIType,\n+                                             Subscripts: &'a DIArray)\n+                                             -> &'a DIType;\n \n     pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: &DIBuilder,\n                                                 Lo: i64,\n                                                 Count: i64)\n-                                                -> DISubrange;\n+                                                -> &DISubrange;\n \n-    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: &DIBuilder,\n-                                             Ptr: *const Option<NonNull<DIDescriptor_opaque>>,\n+    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: &'a DIBuilder,\n+                                             Ptr: *const Option<&'a DIDescriptor>,\n                                              Count: c_uint)\n-                                             -> DIArray;\n+                                             -> &'a DIArray;\n \n-    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: &DIBuilder,\n+    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: &'a DIBuilder,\n                                                Val: ValueRef,\n-                                               VarInfo: DIVariable,\n+                                               VarInfo: &'a DIVariable,\n                                                AddrOps: *const i64,\n                                                AddrOpsCount: c_uint,\n                                                DL: ValueRef,\n@@ -1526,60 +1520,61 @@ extern \"C\" {\n     pub fn LLVMRustDIBuilderCreateEnumerator(Builder: &DIBuilder,\n                                              Name: *const c_char,\n                                              Val: u64)\n-                                             -> DIEnumerator;\n+                                             -> &DIEnumerator;\n \n-    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: &DIBuilder,\n-                                                  Scope: DIScope,\n+    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: &'a DIBuilder,\n+                                                  Scope: &'a DIScope,\n                                                   Name: *const c_char,\n-                                                  File: DIFile,\n+                                                  File: &'a DIFile,\n                                                   LineNumber: c_uint,\n                                                   SizeInBits: u64,\n                                                   AlignInBits: u32,\n-                                                  Elements: DIArray,\n-                                                  ClassType: DIType)\n-                                                  -> DIType;\n+                                                  Elements: &'a DIArray,\n+                                                  ClassType: &'a DIType)\n+                                                  -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderCreateUnionType(Builder: &DIBuilder,\n-                                            Scope: DIScope,\n+    pub fn LLVMRustDIBuilderCreateUnionType(Builder: &'a DIBuilder,\n+                                            Scope: &'a DIScope,\n                                             Name: *const c_char,\n-                                            File: DIFile,\n+                                            File: &'a DIFile,\n                                             LineNumber: c_uint,\n                                             SizeInBits: u64,\n                                             AlignInBits: u32,\n                                             Flags: DIFlags,\n-                                            Elements: Option<NonNull<DIArray_opaque>>,\n+                                            Elements: Option<&'a DIArray>,\n                                             RunTimeLang: c_uint,\n                                             UniqueId: *const c_char)\n-                                            -> DIType;\n+                                            -> &'a DIType;\n \n     pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n \n-    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: &DIBuilder,\n-                                                        Scope: Option<NonNull<DIScope_opaque>>,\n+    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: &'a DIBuilder,\n+                                                        Scope: Option<&'a DIScope>,\n                                                         Name: *const c_char,\n-                                                        Ty: DIType,\n-                                                        File: DIFile,\n+                                                        Ty: &'a DIType,\n+                                                        File: &'a DIFile,\n                                                         LineNo: c_uint,\n                                                         ColumnNo: c_uint)\n-                                                        -> DITemplateTypeParameter;\n+                                                        -> &'a DITemplateTypeParameter;\n \n \n-    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: &DIBuilder,\n-                                            Scope: Option<NonNull<DIScope_opaque>>,\n+    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: &'a DIBuilder,\n+                                            Scope: Option<&'a DIScope>,\n                                             Name: *const c_char,\n-                                            File: DIFile,\n+                                            File: &'a DIFile,\n                                             LineNo: c_uint)\n-                                            -> DINameSpace;\n-    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: &DIBuilder,\n-                                               CompositeType: DIType,\n-                                               TypeArray: DIArray);\n+                                            -> &'a DINameSpace;\n \n+    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: &'a DIBuilder,\n+                                               CompositeType: &'a DIType,\n+                                               TypeArray: &'a DIArray);\n \n-    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: &Context,\n+\n+    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: &'a Context,\n                                                 Line: c_uint,\n                                                 Column: c_uint,\n-                                                Scope: DIScope,\n-                                                InlinedAt: Option<NonNull<Metadata_opaque>>)\n+                                                Scope: &'a DIScope,\n+                                                InlinedAt: Option<&'a Metadata>)\n                                                 -> ValueRef;\n     pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n     pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> i64;"}, {"sha": "37f1bf5c1e70f2d92508a16e1d497a257997752d", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -16,7 +16,6 @@\n \n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n-pub use self::TypeKind::*;\n pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n pub use self::CodeGenOptSize::*;"}, {"sha": "62369ea5792bf7cb459dc3dd57b48cdd46dd2acf", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -11,7 +11,7 @@\n use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n-use llvm::debuginfo::DIScope_opaque;\n+use llvm::debuginfo::DIScope;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n@@ -29,7 +29,6 @@ use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n \n use std::iter;\n-use std::ptr::NonNull;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -48,7 +47,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n \n     mir: &'a mir::Mir<'tcx>,\n \n-    debug_context: debuginfo::FunctionDebugContext,\n+    debug_context: FunctionDebugContext<'ll>,\n \n     llfn: ValueRef,\n \n@@ -100,7 +99,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n+    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: &'tcx Substs<'tcx>,\n@@ -117,12 +116,12 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         )\n     }\n \n-    pub fn set_debug_loc(&mut self, bx: &Builder, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&mut self, bx: &Builder<'_, 'll, '_>, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n         debuginfo::set_source_location(&self.debug_context, bx, scope, span);\n     }\n \n-    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (Option<NonNull<DIScope_opaque>>, Span) {\n+    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (Option<&'ll DIScope>, Span) {\n         // Bail out if debug info emission is not enabled.\n         match self.debug_context {\n             FunctionDebugContext::DebugInfoDisabled |\n@@ -162,14 +161,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                               -> Option<NonNull<DIScope_opaque>> {\n+                               -> Option<&'ll DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.cx.sess().codemap();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            NonNull::new(debuginfo::extend_scope_to_file(self.cx,\n-                                            scope_metadata.unwrap().as_ptr(),\n+            Some(debuginfo::extend_scope_to_file(self.cx,\n+                                            scope_metadata.unwrap(),\n                                             &cm.lookup_char_pos(pos).file,\n                                             defining_crate))\n         } else {\n@@ -281,7 +280,7 @@ pub fn codegen_mir(\n                         span: decl.source_info.span,\n                         scope: decl.visibility_scope,\n                     });\n-                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap().as_ptr(),\n+                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n                         VariableAccess::DirectVariable { alloca: place.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n@@ -416,7 +415,7 @@ fn create_funclets(\n fn arg_local_refs(\n     bx: &Builder<'a, 'll, 'tcx>,\n     fx: &FunctionCx<'a, 'll, 'tcx>,\n-    scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n+    scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n     memory_locals: &BitVector<mir::Local>,\n ) -> Vec<LocalRef<'tcx>> {\n     let mir = fx.mir;\n@@ -473,7 +472,7 @@ fn arg_local_refs(\n                     bx,\n                     &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n-                    arg_ty, scope.as_ptr(),\n+                    arg_ty, scope,\n                     variable_access,\n                     VariableKind::ArgumentVariable(arg_index + 1),\n                     DUMMY_SP\n@@ -552,7 +551,7 @@ fn arg_local_refs(\n                     &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg.layout.ty,\n-                    scope.as_ptr(),\n+                    scope,\n                     variable_access,\n                     VariableKind::ArgumentVariable(arg_index + 1),\n                     DUMMY_SP\n@@ -603,7 +602,7 @@ fn arg_local_refs(\n                     &fx.debug_context,\n                     decl.debug_name,\n                     ty,\n-                    scope.as_ptr(),\n+                    scope,\n                     variable_access,\n                     VariableKind::LocalVariable,\n                     DUMMY_SP"}, {"sha": "9fa7cc46aee5eb10387549ef5b5ee34194ef308f", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed48f560fa44e60cec89df894018dc4599730d0/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=eed48f560fa44e60cec89df894018dc4599730d0", "patch": "@@ -14,7 +14,6 @@ pub use llvm::Type;\n \n use llvm;\n use llvm::{Bool, False, True, TypeKind};\n-use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CodegenCx;\n \n@@ -265,10 +264,10 @@ impl Type {\n \n     pub fn float_width(&self) -> usize {\n         match self.kind() {\n-            Float => 32,\n-            Double => 64,\n-            X86_FP80 => 80,\n-            FP128 | PPC_FP128 => 128,\n+            TypeKind::Float => 32,\n+            TypeKind::Double => 64,\n+            TypeKind::X86_FP80 => 80,\n+            TypeKind::FP128 | TypeKind::PPC_FP128 => 128,\n             _ => bug!(\"llvm_float_width called on a non-float type\")\n         }\n     }"}]}