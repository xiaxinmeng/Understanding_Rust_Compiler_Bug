{"sha": "b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NTAyMWIzMWU0M2Q1OWViMmI5MWZlNDVjZmZmY2I3ZDI1ZmIxNDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-06-25T18:02:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-06-25T18:02:19Z"}, "message": "refactor lexer to use idiomatic borrowing", "tree": {"sha": "bd79e2f15a59d9b63109524cfefc342199116f41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd79e2f15a59d9b63109524cfefc342199116f41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "html_url": "https://github.com/rust-lang/rust/commit/b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75021b31e43d59eb2b91fe45cfffcb7d25fb141/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ab9d2bd57a2203131abd723f7120e960299fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ab9d2bd57a2203131abd723f7120e960299fae", "html_url": "https://github.com/rust-lang/rust/commit/40ab9d2bd57a2203131abd723f7120e960299fae"}], "stats": {"total": 225, "additions": 104, "deletions": 121}, "files": [{"sha": "7b9e3bc4d5102966cde52aebd76547cf52303dda", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 104, "deletions": 121, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/b75021b31e43d59eb2b91fe45cfffcb7d25fb141/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75021b31e43d59eb2b91fe45cfffcb7d25fb141/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "patch": "@@ -321,33 +321,29 @@ impl<'a> StringReader<'a> {\n         (pos - self.source_file.start_pos).to_usize()\n     }\n \n-    /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `self.pos`, meaning the slice does not include\n-    /// the character `self.ch`.\n-    fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T\n-        where F: FnOnce(&str) -> T\n+    /// Slice of the source text from `start` up to but excluding `self.pos`,\n+    /// meaning the slice does not include the character `self.ch`.\n+    fn str_from(&self, start: BytePos) -> &str\n     {\n-        self.with_str_from_to(start, self.pos, f)\n+        self.str_from_to(start, self.pos)\n     }\n \n     /// Creates a Name from a given offset to the current offset.\n     fn name_from(&self, start: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n-        self.with_str_from(start, Symbol::intern)\n+        Symbol::intern(self.str_from(start))\n     }\n \n     /// As name_from, with an explicit endpoint.\n     fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n-        self.with_str_from_to(start, end, Symbol::intern)\n+        Symbol::intern(self.str_from_to(start, end))\n     }\n \n-    /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `end`.\n-    fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T\n-        where F: FnOnce(&str) -> T\n+    /// Slice of the source text spanning from `start` up to but excluding `end`.\n+    fn str_from_to(&self, start: BytePos, end: BytePos) -> &str\n     {\n-        f(&self.src[self.src_index(start)..self.src_index(end)])\n+        &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n@@ -456,8 +452,8 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        self.with_str_from(start, |string| {\n-            if string == \"_\" {\n+        match self.str_from(start) {\n+            \"_\" => {\n                 self.sess.span_diagnostic\n                     .struct_span_warn(self.mk_sp(start, self.pos),\n                                       \"underscore literal suffix is not allowed\")\n@@ -468,10 +464,9 @@ impl<'a> StringReader<'a> {\n                           <https://github.com/rust-lang/rust/issues/42326>\")\n                     .emit();\n                 None\n-            } else {\n-                Some(Symbol::intern(string))\n             }\n-        })\n+            name => Some(Symbol::intern(name))\n+        }\n     }\n \n     /// PRECONDITION: self.ch is not whitespace\n@@ -513,9 +508,7 @@ impl<'a> StringReader<'a> {\n                     }\n \n                     let kind = if doc_comment {\n-                        self.with_str_from(start_bpos, |string| {\n-                            token::DocComment(Symbol::intern(string))\n-                        })\n+                        token::DocComment(self.name_from(start_bpos))\n                     } else {\n                         token::Comment\n                     };\n@@ -615,23 +608,22 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        self.with_str_from(start_bpos, |string| {\n-            // but comments with only \"*\"s between two \"/\"s are not\n-            let kind = if is_block_doc_comment(string) {\n-                let string = if has_cr {\n-                    self.translate_crlf(start_bpos,\n-                                        string,\n-                                        \"bare CR not allowed in block doc-comment\")\n-                } else {\n-                    string.into()\n-                };\n-                token::DocComment(Symbol::intern(&string[..]))\n+        let string = self.str_from(start_bpos);\n+        // but comments with only \"*\"s between two \"/\"s are not\n+        let kind = if is_block_doc_comment(string) {\n+            let string = if has_cr {\n+                self.translate_crlf(start_bpos,\n+                                    string,\n+                                    \"bare CR not allowed in block doc-comment\")\n             } else {\n-                token::Comment\n+                string.into()\n             };\n+            token::DocComment(Symbol::intern(&string[..]))\n+        } else {\n+            token::Comment\n+        };\n \n-            Some(Token::new(kind, self.mk_sp(start_bpos, self.pos)))\n-        })\n+        Some(Token::new(kind, self.mk_sp(start_bpos, self.pos)))\n     }\n \n     /// Scan through any digits (base `scan_radix`) or underscores,\n@@ -838,20 +830,17 @@ impl<'a> StringReader<'a> {\n                     self.bump();\n                 }\n \n-                return Ok(self.with_str_from(start, |string| {\n-                    // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    let name = ast::Name::intern(string);\n-\n-                    if is_raw_ident {\n-                        let span = self.mk_sp(raw_start, self.pos);\n-                        if !name.can_be_raw() {\n-                            self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n-                        }\n-                        self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                // FIXME: perform NFKC normalization here. (Issue #2253)\n+                let name = self.name_from(start);\n+                if is_raw_ident {\n+                    let span = self.mk_sp(raw_start, self.pos);\n+                    if !name.can_be_raw() {\n+                        self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n                     }\n+                    self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                }\n \n-                    token::Ident(name, is_raw_ident)\n-                }));\n+                return Ok(token::Ident(name, is_raw_ident));\n             }\n         }\n \n@@ -1300,101 +1289,95 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn validate_char_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            if let Err((off, err)) = unescape::unescape_char(lit) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        if let Err((off, err)) = unescape::unescape_char(lit) {\n+            emit_unescape_error(\n+                &self.sess.span_diagnostic,\n+                lit,\n+                self.mk_sp(start_with_quote, self.pos),\n+                unescape::Mode::Char,\n+                0..off,\n+                err,\n+            )\n+        }\n+    }\n+\n+    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        if let Err((off, err)) = unescape::unescape_byte(lit) {\n+            emit_unescape_error(\n+                &self.sess.span_diagnostic,\n+                lit,\n+                self.mk_sp(start_with_quote, self.pos),\n+                unescape::Mode::Byte,\n+                0..off,\n+                err,\n+            )\n+        }\n+    }\n+\n+    fn validate_str_escape(&self, start_with_quote: BytePos) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        unescape::unescape_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit,\n                     self.mk_sp(start_with_quote, self.pos),\n-                    unescape::Mode::Char,\n-                    0..off,\n+                    unescape::Mode::Str,\n+                    range,\n                     err,\n                 )\n             }\n-        });\n+        })\n     }\n \n-    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            if let Err((off, err)) = unescape::unescape_byte(lit) {\n+    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        let lit = self.str_from_to(content_start, content_end);\n+        unescape::unescape_raw_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit,\n-                    self.mk_sp(start_with_quote, self.pos),\n-                    unescape::Mode::Byte,\n-                    0..off,\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                    unescape::Mode::Str,\n+                    range,\n                     err,\n                 )\n             }\n-        });\n-    }\n-\n-    fn validate_str_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            unescape::unescape_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(start_with_quote, self.pos),\n-                        unescape::Mode::Str,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n-    }\n-\n-    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        self.with_str_from_to(content_start, content_end, |lit: &str| {\n-            unescape::unescape_raw_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                        unescape::Mode::Str,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        })\n     }\n \n     fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        self.with_str_from_to(content_start, content_end, |lit: &str| {\n-            unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                        unescape::Mode::ByteStr,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        let lit = self.str_from_to(content_start, content_end);\n+        unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                    unescape::Mode::ByteStr,\n+                    range,\n+                    err,\n+                )\n+            }\n+        })\n     }\n \n     fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            unescape::unescape_byte_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(start_with_quote, self.pos),\n-                        unescape::Mode::ByteStr,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        unescape::unescape_byte_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(start_with_quote, self.pos),\n+                    unescape::Mode::ByteStr,\n+                    range,\n+                    err,\n+                )\n+            }\n+        })\n     }\n }\n "}]}